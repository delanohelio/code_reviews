{"pr_number": 988, "pr_title": "Tsk 1160", "pr_author": "BerndBreier", "pr_createdAt": "2020-03-24T14:33:10Z", "pr_url": "https://github.com/Taskana/taskana/pull/988", "merge_commit": "6bd6bd48386155644df0463edf8aeda473bd1a56", "timeline": [{"oid": "6cefb1a7f9612688d2315571fc14b9af5245c751", "url": "https://github.com/Taskana/taskana/commit/6cefb1a7f9612688d2315571fc14b9af5245c751", "message": "TSK-1143C mismatch between forward and backward calculation between planned and due", "committedDate": "2020-03-26T10:10:36Z", "type": "commit"}, {"oid": "47c87cd6ba012fca2c3651e69420d2498aefa88f", "url": "https://github.com/Taskana/taskana/commit/47c87cd6ba012fca2c3651e69420d2498aefa88f", "message": "TSK-1143 UpdateTask with Planned sometimes fails", "committedDate": "2020-03-26T10:10:37Z", "type": "commit"}, {"oid": "9b9335f41566846d89ba5723b8f6735e2a8db341", "url": "https://github.com/Taskana/taskana/commit/9b9335f41566846d89ba5723b8f6735e2a8db341", "message": "TSK-442 improve task refresh on classification update", "committedDate": "2020-03-26T10:10:37Z", "type": "commit"}, {"oid": "900aa2c5821f1a153acbf6b7d7565660a1e34623", "url": "https://github.com/Taskana/taskana/commit/900aa2c5821f1a153acbf6b7d7565660a1e34623", "message": "TSK-1143b - fix error in testcase UpdateObjectsUseUtcTimeStampsAccTest.", "committedDate": "2020-03-26T10:10:37Z", "type": "commit"}, {"oid": "7bfa207d0836a1bb71ba650ae969af708d3853f7", "url": "https://github.com/Taskana/taskana/commit/7bfa207d0836a1bb71ba650ae969af708d3853f7", "message": "TSK-442 improve task refresh on classification update", "committedDate": "2020-03-26T10:10:37Z", "type": "commit"}, {"oid": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "url": "https://github.com/Taskana/taskana/commit/bd4c775504f5e3a173976af21226bad2b2f0e02e", "message": "TSK-1160 TaskStates CANCELLED and TERMINATED", "committedDate": "2020-03-26T10:10:38Z", "type": "commit"}, {"oid": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "url": "https://github.com/Taskana/taskana/commit/bd4c775504f5e3a173976af21226bad2b2f0e02e", "message": "TSK-1160 TaskStates CANCELLED and TERMINATED", "committedDate": "2020-03-26T10:10:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1MDc3Nw==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398650777", "body": "Cancels a task.\r\nCancellation means a task is obsolete from a business perspective an does not need to be completed anymore.", "bodyText": "Cancels a task.\nCancellation means a task is obsolete from a business perspective an does not need to be completed anymore.", "bodyHTML": "<p dir=\"auto\">Cancels a task.<br>\nCancellation means a task is obsolete from a business perspective an does not need to be completed anymore.</p>", "author": "holgerhagen", "createdAt": "2020-03-26T15:12:02Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java", "diffHunk": "@@ -490,4 +490,28 @@ TaskComment getTaskComment(String taskCommentId)\n    */\n   BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n       Instant planned, List<String> taskIds);\n+\n+  /**\n+   * Cancels a task.", "originalCommit": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODcxNTk1Mw==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398715953", "bodyText": "I added the description", "author": "BerndBreier", "createdAt": "2020-03-26T16:33:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1MDc3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "4c65a6087e83b85e44118a754cf749a23cac5250", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 15b67f6fe..a07c9a1cc 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -492,7 +492,8 @@ public interface TaskService {\n       Instant planned, List<String> taskIds);\n \n   /**\n-   * Cancels a task.\n+   * Cancels a task. Cancellation means a task is obsolete from a business perspective an does not\n+   * need to be completed anymore.\n    *\n    * @param taskId the id of the task to cancel.\n    * @return the updated task.\n", "next_change": null}]}, "revised_code_in_main": {"commit": "6bd6bd48386155644df0463edf8aeda473bd1a56", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 15b67f6fe..a07c9a1cc 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -492,7 +492,8 @@ public interface TaskService {\n       Instant planned, List<String> taskIds);\n \n   /**\n-   * Cancels a task.\n+   * Cancels a task. Cancellation means a task is obsolete from a business perspective an does not\n+   * need to be completed anymore.\n    *\n    * @param taskId the id of the task to cancel.\n    * @return the updated task.\n", "next_change": {"commit": "3b13b9a95e4d7d1cf172f22fa0f2679ff1c5f79b", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex a07c9a1cc..7d96879c1 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -468,52 +369,4 @@ public interface TaskService {\n    */\n   BulkOperationResults<String, TaskanaException> setCallbackStateForTasks(\n       List<String> externalIds, CallbackState state);\n-\n-  /**\n-   * Sets the owner on a list of tasks. The owner will only be set on tasks that are in state READY.\n-   *\n-   * @param owner the new owner of the tasks\n-   * @param taskIds the IDs of the tasks on which the owner is to be set.\n-   * @return the result of the operations with Id and Exception for each failed task update.\n-   */\n-  BulkOperationResults<String, TaskanaException> setOwnerOfTasks(\n-      String owner, List<String> taskIds);\n-\n-  /**\n-   * Sets the planned property on a list of tasks. Only tasks in state READY and CLAIMED will be\n-   * affected by this method. On each task, the corresponding due date is set according to the\n-   * shortest service level in the classifications of the task and the task's attachments.\n-   *\n-   * @param planned the new 'PLANNED\" property of the tasks\n-   * @param taskIds the IDs of the tasks on which the new planned property is to be set.\n-   * @return the result of the operations with Id and Exception for each failed task update.\n-   */\n-  BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n-      Instant planned, List<String> taskIds);\n-\n-  /**\n-   * Cancels a task. Cancellation means a task is obsolete from a business perspective an does not\n-   * need to be completed anymore.\n-   *\n-   * @param taskId the id of the task to cancel.\n-   * @return the updated task.\n-   * @throws TaskNotFoundException if the Task with Id TaskId is not found\n-   * @throws InvalidStateException if the task is not in state READY or CLAIMED\n-   * @throws NotAuthorizedException if the current user is not authorized to see the task\n-   */\n-  Task cancelTask(String taskId)\n-      throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n-\n-  /**\n-   * Terminates a task. Termination is a administrative action to complete a task. This is typically\n-   * done by an administration to correct any technical issue.\n-   *\n-   * @param taskId the id of the task to cancel.\n-   * @return the updated task.\n-   * @throws TaskNotFoundException if the Task with Id TaskId is not found\n-   * @throws InvalidStateException if the task is not in state READY or CLAIMED\n-   * @throws NotAuthorizedException if the current user is not authorized to see the task\n-   */\n-  Task terminateTask(String taskId)\n-      throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n }\n", "next_change": {"commit": "20bd0922dbc332efcf4e94a0d487b077c95c5a85", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 7d96879c1..ae908e0c9 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -369,4 +375,14 @@ public interface TaskService {\n    */\n   BulkOperationResults<String, TaskanaException> setCallbackStateForTasks(\n       List<String> externalIds, CallbackState state);\n+\n+  /**\n+   * Sets the owner on a list of tasks. The owner will only be set on tasks that are in state READY.\n+   *\n+   * @param owner the new owner of the tasks\n+   * @param taskIds the IDs of the tasks on which the owner is to be set.\n+   * @return the result of the operations with Id and Exception for each failed task deletion.\n+   */\n+  BulkOperationResults<String, TaskanaException> setOwnerOfTasks(\n+      String owner, List<String> taskIds);\n }\n", "next_change": {"commit": "02a6df6f73622e86684c6c30d8f320c84078b237", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex ae908e0c9..8640a8b26 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -381,8 +382,20 @@ public interface TaskService {\n    *\n    * @param owner the new owner of the tasks\n    * @param taskIds the IDs of the tasks on which the owner is to be set.\n-   * @return the result of the operations with Id and Exception for each failed task deletion.\n+   * @return the result of the operations with Id and Exception for each failed task update.\n    */\n   BulkOperationResults<String, TaskanaException> setOwnerOfTasks(\n       String owner, List<String> taskIds);\n+\n+  /**\n+   * Sets the planned property on a list of tasks. Only tasks in state READY and CLAIMED will be\n+   * affected by this method. On each task, the corresponding due date is set according to the due\n+   * dates in the classification() of the task and the task's attachments.\n+   *\n+   * @param planned   the new 'PLANNED\" property of the tasks\n+   * @param taskIds the IDs of the tasks on which the new planned property is to be set.\n+   * @return the result of the operations with Id and Exception for each failed task update.\n+   */\n+  BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n+      Instant planned, List<String> taskIds);\n }\n", "next_change": {"commit": "3b7da72d24beb1e0f6d528f575b1ae7029f10e7f", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 8640a8b26..7951634cb 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -392,7 +467,7 @@ public interface TaskService {\n    * affected by this method. On each task, the corresponding due date is set according to the due\n    * dates in the classification() of the task and the task's attachments.\n    *\n-   * @param planned   the new 'PLANNED\" property of the tasks\n+   * @param planned the new 'PLANNED\" property of the tasks\n    * @param taskIds the IDs of the tasks on which the new planned property is to be set.\n    * @return the result of the operations with Id and Exception for each failed task update.\n    */\n", "next_change": {"commit": "7deb9254113278ccf5872283c2abd202c3cf7af0", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 7951634cb..73e0e0ce4 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -464,8 +479,8 @@ public interface TaskService {\n \n   /**\n    * Sets the planned property on a list of tasks. Only tasks in state READY and CLAIMED will be\n-   * affected by this method. On each task, the corresponding due date is set according to the due\n-   * dates in the classification() of the task and the task's attachments.\n+   * affected by this method. On each task, the corresponding due date is set according to the\n+   * shortest service level in the classifications of the task and the task's attachments.\n    *\n    * @param planned the new 'PLANNED\" property of the tasks\n    * @param taskIds the IDs of the tasks on which the new planned property is to be set.\n", "next_change": {"commit": "2ce7f86456f99d522e001080e9504ae4cd6a80f4", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 73e0e0ce4..15b67f6fe 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -488,4 +490,28 @@ public interface TaskService {\n    */\n   BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n       Instant planned, List<String> taskIds);\n+\n+  /**\n+   * Cancels a task.\n+   *\n+   * @param taskId the id of the task to cancel.\n+   * @return the updated task.\n+   * @throws TaskNotFoundException if the Task with Id TaskId is not found\n+   * @throws InvalidStateException if the task is not in state READY or CLAIMED\n+   * @throws NotAuthorizedException if the current user is not authorized to see the task\n+   */\n+  Task cancelTask(String taskId)\n+      throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n+\n+  /**\n+   * Terminates a task.\n+   *\n+   * @param taskId the id of the task to cancel.\n+   * @return the updated task.\n+   * @throws TaskNotFoundException if the Task with Id TaskId is not found\n+   * @throws InvalidStateException if the task is not in state READY or CLAIMED\n+   * @throws NotAuthorizedException if the current user is not authorized to see the task\n+   */\n+  Task terminateTask(String taskId)\n+      throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n }\n", "next_change": {"commit": "b4e1f9bc315eb701d0dec0e34c38651672239566", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 15b67f6fe..48bac1ed4 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -21,496 +24,695 @@ import pro.taskana.task.api.models.Attachment;\n import pro.taskana.task.api.models.ObjectReference;\n import pro.taskana.task.api.models.Task;\n import pro.taskana.task.api.models.TaskComment;\n+import pro.taskana.workbasket.api.WorkbasketPermission;\n import pro.taskana.workbasket.api.exceptions.WorkbasketNotFoundException;\n+import pro.taskana.workbasket.api.models.Workbasket;\n \n /** The Task Service manages all operations on tasks. */\n public interface TaskService {\n \n   /**\n-   * Claim an existing task for the current user.\n+   * Claim an existing {@linkplain Task} for the current user.\n    *\n-   * @param taskId the id of the task to be claimed\n-   * @return claimed Task\n-   * @throws TaskNotFoundException if the task with taskId was not found\n-   * @throws InvalidStateException if the state of the task with taskId is not READY\n-   * @throws InvalidOwnerException if the task with taskId is claimed by some else\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to be claimed\n+   * @return claimed {@linkplain Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} with taskId was not found\n+   * @throws InvalidStateException if the {@linkplain Task#getState() state} of the {@linkplain\n+   *     Task} with taskId is not {@linkplain TaskState#READY READY}\n+   * @throws InvalidOwnerException if the {@linkplain Task} with taskId is claimed by some else\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task claim(String taskId)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException;\n \n   /**\n-   * Claim an existing task for the current user even if it is already claimed by someone else.\n+   * Claim an existing {@linkplain Task} for the current user even if it is already claimed by\n+   * someone else.\n    *\n-   * @param taskId the id of the task to be claimed\n-   * @return claimed Task\n-   * @throws TaskNotFoundException if the task with taskId was not found\n-   * @throws InvalidStateException if the state of the task with taskId is not READY\n-   * @throws InvalidOwnerException if the task with taskId is claimed by someone else\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to be claimed\n+   * @return claimed {@linkplain Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} with taskId was not found\n+   * @throws InvalidStateException if the {@linkplain Task#getState() state} of the {@linkplain\n+   *     Task} with taskId is not READY\n+   * @throws InvalidOwnerException if the {@linkplain Task} with taskId is claimed by someone else\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task forceClaim(String taskId)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException;\n \n   /**\n-   * Cancel the claim of an existing task if it was claimed by the current user before.\n+   * Cancel the claim of an existing {@linkplain Task} if it was claimed by the current user before.\n    *\n-   * @param taskId id of the task which should be unclaimed.\n+   * @param taskId {@linkplain Task#getId() id} of the task which should be unclaimed.\n    * @return updated unclaimed task\n-   * @throws TaskNotFoundException if the task can\u00b4t be found or does not exist\n-   * @throws InvalidStateException when the task is already completed.\n-   * @throws InvalidOwnerException when the task is claimed by another user.\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @throws TaskNotFoundException if the {@linkplain Task} can't be found or does not exist\n+   * @throws InvalidStateException if the {@linkplain Task} is already in an end {@linkplain\n+   *     Task#getState() state}.\n+   * @throws InvalidOwnerException if the {@linkplain Task} is claimed by another user.\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the task is in\n    */\n   Task cancelClaim(String taskId)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException;\n \n   /**\n-   * Cancel the claim of an existing task even if it was claimed by another user.\n+   * Cancel the claim of an existing {@linkplain Task} even if it was claimed by another user.\n    *\n-   * @param taskId id of the task which should be unclaimed.\n-   * @return updated unclaimed task\n-   * @throws TaskNotFoundException if the task can\u00b4t be found or does not exist\n-   * @throws InvalidStateException when the task is already completed.\n-   * @throws InvalidOwnerException when forceCancel is false and the task is claimed by another\n-   *     user.\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @param taskId id of the {@linkplain Task} which should be unclaimed.\n+   * @return updated unclaimed {@linkplain Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} can't be found or does not exist\n+   * @throws InvalidStateException if the {@linkplain Task} is already in an end {@linkplain\n+   *     Task#getState() state}\n+   * @throws InvalidOwnerException if forceCancel is false and the {@linkplain Task} is claimed by\n+   *     another user.\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task forceCancelClaim(String taskId)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException;\n \n   /**\n-   * Complete a claimed Task as owner/admin and update State and Timestamps. If task is already\n-   * completed, the task is returned as itself.\n+   * Complete a claimed {@linkplain Task} as owner/admin and update {@linkplain Task#getState()\n+   * state} and Timestamps. If {@linkplain Task} is already completed, the {@linkplain Task} is\n+   * returned as itself.\n    *\n-   * @param taskId - Id of the Task which should be completed.\n-   * @return Task - updated task after completion.\n-   * @throws InvalidStateException when Task wasn\u00b4t claimed before.\n-   * @throws TaskNotFoundException if the given Task can\u00b4t be found in DB.\n+   * @param taskId - {@linkplain Task#getId() id} of the {@linkplain Task} which should be\n+   *     completed.\n+   * @return Task - updated {@linkplain Task} after completion.\n+   * @throws InvalidStateException if {@linkplain Task} wasn't claimed before.\n+   * @throws TaskNotFoundException if the given {@linkplain Task} can't be found in DB.\n    * @throws InvalidOwnerException if current user is not the task-owner or administrator.\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task completeTask(String taskId)\n       throws TaskNotFoundException, InvalidOwnerException, InvalidStateException,\n           NotAuthorizedException;\n \n   /**\n-   * Complete a Task and update State and Timestamps in every case if the Task exists. If task is\n-   * already completed, the task is returned as itself.\n+   * Completes a {@linkplain Task} and updates {@linkplain Task#getState() state} and Timestamps in\n+   * every case if the {@linkplain Task} exists. If {@linkplain Task} is already completed, the\n+   * {@linkplain Task} is returned as itself.\n    *\n-   * @param taskId - Id of the Task which should be completed.\n-   * @return Task - updated task after completion.\n-   * @throws InvalidStateException when Task wasn\u00b4t claimed before.\n-   * @throws TaskNotFoundException if the given Task can\u00b4t be found in DB.\n+   * @param taskId - {@linkplain Task#getId() id} of the {@linkplain Task} which should be\n+   *     completed.\n+   * @return Task - updated {@linkplain Task} after completion.\n+   * @throws InvalidStateException if {@linkplain Task} wasn't claimed before.\n+   * @throws TaskNotFoundException if the given {@linkplain Task} can't be found in DB.\n    * @throws InvalidOwnerException if current user is not the task-owner or administrator.\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task forceCompleteTask(String taskId)\n       throws TaskNotFoundException, InvalidOwnerException, InvalidStateException,\n           NotAuthorizedException;\n \n   /**\n-   * Persists a not persisted Task which does not exist already.\n-   *\n-   * @param taskToCreate the transient task object to be persisted\n-   * @return the created and persisted task\n-   * @throws TaskAlreadyExistException when the Task does already exist.\n-   * @throws NotAuthorizedException thrown if the current user is not authorized to create that task\n-   * @throws WorkbasketNotFoundException thrown if the work basket referenced by the task is not\n-   *     found\n-   * @throws ClassificationNotFoundException thrown if the {@link Classification} referenced by the\n-   *     task is not found\n+   * Inserts a not existing {@linkplain Task}. <br>\n+   * The default values of the created {@linkplain Task} are:\n+   *\n+   * <ul>\n+   *   <li><b>{@linkplain Task#getId() id}</b> - generated by {@linkplain IdGenerator}\n+   *   <li><b>{@linkplain Task#getExternalId() externalId}</b> - generated by IdGenerator\n+   *   <li><b>{@linkplain Task#getBusinessProcessId() businessProcessId}</b> - generated by\n+   *       IdGenerator\n+   *   <li><b>{@linkplain Task#getName() name}</b> - name of its Classification\n+   *   <li><b>{@linkplain Task#getDescription() description}</b> - description of its Classification\n+   *   <li><b>{@linkplain Task#getCreator() creator}</b> - id of current user\n+   *   <li><b>{@linkplain Task#getState() state}</b> - 'READY'\n+   *   <li><b>{@linkplain Task#isRead() isRead}</b> - {@code false}\n+   *   <li><b>{@linkplain Task#isTransferred() isTransferred}</b> - {@code false}\n+   * </ul>\n+   *\n+   * @param taskToCreate the transient {@linkplain Task} object to be inserted\n+   * @return the created and inserted {@linkplain Task}\n+   * @throws TaskAlreadyExistException if the {@linkplain Task} does already exist.\n+   * @throws NotAuthorizedException thrown if the current user is not authorized to create that\n+   *     {@linkplain Task}\n+   * @throws WorkbasketNotFoundException thrown if the workbasket referenced by the {@linkplain\n+   *     Task} is not found\n+   * @throws ClassificationNotFoundException thrown if the Classification referenced by the\n+   *     {@linkplain Task} is not found\n    * @throws InvalidArgumentException thrown if the primary ObjectReference is invalid\n+   * @throws AttachmentPersistenceException if an Attachment with ID will be added multiple times\n+   *     without using the task-methods\n+   * @throws ObjectReferencePersistenceException if an ObjectReference with ID will be added\n+   *     multiple times without using the task-methods\n    */\n   Task createTask(Task taskToCreate)\n       throws NotAuthorizedException, WorkbasketNotFoundException, ClassificationNotFoundException,\n-          TaskAlreadyExistException, InvalidArgumentException;\n+          TaskAlreadyExistException, InvalidArgumentException, AttachmentPersistenceException,\n+          ObjectReferencePersistenceException;\n \n   /**\n-   * Get the details of a task by Id without checking permissions.\n+   * Gets the details of a {@linkplain Task} by {@linkplain Task#getId() id} without checking\n+   * permissions.\n    *\n-   * @param taskId the id of the task\n-   * @return the Task\n-   * @throws TaskNotFoundException thrown of the {@link Task} with taskId is not found\n-   * @throws NotAuthorizedException if the current user has no READ permission for the workbasket\n-   *     the task is in.\n+   * @param taskId the {@linkplain Task#getId()} of the {@linkplain Task}\n+   * @return the {@linkplain Task}\n+   * @throws TaskNotFoundException thrown of the {@linkplain Task} with taskId is not found\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in.\n    */\n   Task getTask(String taskId) throws TaskNotFoundException, NotAuthorizedException;\n \n   /**\n-   * Transfer a task to another work basket. The transfer sets the transferred flag and resets the\n-   * read flag.\n+   * Transfers a {@linkplain Task} to another {@linkplain Workbasket} while always setting the\n+   * {@linkplain Task#isTransferred transfer} flag.\n    *\n-   * @param taskId The id of the {@link Task} to be transferred\n-   * @param destinationWorkbasketId The Id of the target work basket\n-   * @return the transferred task\n-   * @throws TaskNotFoundException Thrown if the {@link Task} with taskId was not found.\n-   * @throws WorkbasketNotFoundException Thrown if the target work basket was not found.\n+   * @see #transfer(String, String, boolean)\n+   */\n+  @SuppressWarnings(\"checkstyle:JavadocMethod\")\n+  default Task transfer(String taskId, String destinationWorkbasketId)\n+      throws TaskNotFoundException, WorkbasketNotFoundException, NotAuthorizedException,\n+          InvalidStateException {\n+    return transfer(taskId, destinationWorkbasketId, true);\n+  }\n+\n+  /**\n+   * Transfers a {@linkplain Task} to another {@linkplain Workbasket}.\n+   *\n+   * <p>The transfer resets the {@linkplain Task#isRead() read} flag and sets the {@linkplain\n+   * Task#isTransferred() transfer} flag if {@code setTransferFlag} is {@code true}.\n+   *\n+   * @param taskId the {@linkplain Task#getId()} of the {@linkplain Task} which should be\n+   *     transferred\n+   * @param destinationWorkbasketId the {@linkplain Workbasket#getId() id} of the target {@linkplain\n+   *     Workbasket}\n+   * @param setTransferFlag the control about whether to set the {@linkplain Task#isTransferred()}\n+   *     flag or not\n+   * @return the transferred {@linkplain Task}\n+   * @throws TaskNotFoundException Thrown if the {@linkplain Task} with taskId was not found.\n+   * @throws WorkbasketNotFoundException Thrown if the target {@linkplain Workbasket} was not found.\n    * @throws NotAuthorizedException Thrown if the current user is not authorized to transfer this\n-   *     {@link Task} to the target work basket\n-   * @throws InvalidStateException Thrown if the task is in a state which does not allow\n-   *     transferring\n+   *     {@linkplain Task} to the target {@linkplain Workbasket}\n+   * @throws InvalidStateException Thrown if the {@linkplain Task} is in a {@linkplain\n+   *     Task#getState() state} which does not allow transferring\n    */\n-  Task transfer(String taskId, String destinationWorkbasketId)\n+  Task transfer(String taskId, String destinationWorkbasketId, boolean setTransferFlag)\n       throws TaskNotFoundException, WorkbasketNotFoundException, NotAuthorizedException,\n           InvalidStateException;\n \n   /**\n-   * Transfer a task to another work basket. The transfer sets the transferred flag and resets the\n-   * read flag.\n+   * Transfers a {@linkplain Task} to another {@linkplain Workbasket} while always setting the\n+   * {@linkplain Task#isTransferred transfer} flag.\n+   *\n+   * @see #transfer(String, String, String, boolean)\n+   */\n+  @SuppressWarnings(\"checkstyle:JavadocMethod\")\n+  default Task transfer(String taskId, String workbasketKey, String domain)\n+      throws TaskNotFoundException, WorkbasketNotFoundException, NotAuthorizedException,\n+          InvalidStateException {\n+    return transfer(taskId, workbasketKey, domain, true);\n+  }\n+\n+  /**\n+   * Transfers a {@linkplain Task} to another {@linkplain Workbasket}.\n    *\n-   * @param taskId The id of the {@link Task} to be transferred\n-   * @param workbasketKey The key of the target work basket\n-   * @param domain The domain of the target work basket\n-   * @return the transferred task\n-   * @throws TaskNotFoundException Thrown if the {@link Task} with taskId was not found.\n-   * @throws WorkbasketNotFoundException Thrown if the target work basket was not found.\n+   * <p>The transfer resets the {@linkplain Task#isRead() read} flag and sets the transfer flag if\n+   * {@code setTransferFlag} is {@code true}.\n+   *\n+   * @param taskId the id of the {@linkplain Task} which should be transferred\n+   * @param workbasketKey the key of the target {@linkplain Workbasket}\n+   * @param domain the domain of the target {@linkplain Workbasket}\n+   * @param setTransferFlag the control about whether to set the {@linkplain Task#isTransferred()}\n+   *     flag or not\n+   * @return the transferred {@linkplain Task}\n+   * @throws TaskNotFoundException Thrown if the {@linkplain Task} with taskId was not found.\n+   * @throws WorkbasketNotFoundException Thrown if the target {@linkplain Workbasket} was not found.\n    * @throws NotAuthorizedException Thrown if the current user is not authorized to transfer this\n-   *     {@link Task} to the target work basket\n-   * @throws InvalidStateException Thrown if the task is in a state which does not allow\n-   *     transferring\n+   *     {@linkplain Task} to the target {@linkplain Workbasket}\n+   * @throws InvalidStateException Thrown if the {@linkplain Task} is in a {@linkplain\n+   *     Task#getState()} which does not allow transferring\n    */\n-  Task transfer(String taskId, String workbasketKey, String domain)\n+  Task transfer(String taskId, String workbasketKey, String domain, boolean setTransferFlag)\n       throws TaskNotFoundException, WorkbasketNotFoundException, NotAuthorizedException,\n           InvalidStateException;\n \n   /**\n-   * Marks a task as read.\n+   * Marks a {@linkplain Task} as read.\n    *\n-   * @param taskId the id of the task to be updated\n-   * @param isRead the new status of the read flag.\n-   * @return the updated Task\n-   * @throws TaskNotFoundException Thrown if the {@link Task} with taskId was not found\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to be updated\n+   * @param isRead the new status of the {@linkplain Task#isRead() read} flag\n+   * @return the updated {@linkplain Task}\n+   * @throws TaskNotFoundException Thrown if the {@linkplain Task} with taskId was not found\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task setTaskRead(String taskId, boolean isRead)\n       throws TaskNotFoundException, NotAuthorizedException;\n \n   /**\n-   * This method provides a query builder for quering the database.\n+   * Provides a query builder for querying the database.\n    *\n-   * @return a {@link TaskQuery}\n+   * @return a {@linkplain TaskQuery}\n    */\n   TaskQuery createTaskQuery();\n \n   /**\n-   * Returns a not persisted instance of {@link Task}. The returned task has no workbasket Id set.\n-   * When createTask() is invoked for this task, TaskService will call the TaskRouting SPI to\n-   * determine a workbasket for the task. If the TaskRouting API is not active, e.g. because no\n-   * TaskRouter is registered, or the TaskRouter(s) don't find a workbasket, the task will not be\n-   * persisted.\n+   * This method provides a query builder for querying the database.\n+   *\n+   * @return a {@linkplain TaskCommentQuery}\n+   */\n+  TaskCommentQuery createTaskCommentQuery();\n+\n+  /**\n+   * Returns a not inserted instance of {@linkplain Task}. The returned {@linkplain Task} has no\n+   * {@linkplain Task#getWorkbasketSummary() w} set. When createTask() is invoked for this task,\n+   * TaskService will call the TaskRouting SPI to determine a workbasket for the task. If the\n+   * TaskRouting API is not active, e.g. because no TaskRouter is registered, or the TaskRouter(s)\n+   * don't find a workbasket, the task will not be inserted.\n    *\n    * @return an empty new Task\n    */\n   Task newTask();\n \n   /**\n-   * Returns a not persisted instance of {@link Task}.\n+   * Returns a not inserted instance of {@linkplain Task}.\n    *\n-   * @param workbasketId the id of the workbasket to which the task belongs\n-   * @return an empty new Task\n+   * @param workbasketId the {@linkplain Workbasket#getId() id} of the {@linkplain Workbasket} to\n+   *     which the task belongs\n+   * @return an empty new {@linkplain Task}\n    */\n   Task newTask(String workbasketId);\n \n   /**\n-   * Returns a not persisted instance of {@link Task}.\n+   * Returns a not inserted instance of {@linkplain Task}.\n    *\n-   * @param workbasketKey the key of the workbasket to which the task belongs\n-   * @param domain the domain of the workbasket to which the task belongs\n-   * @return an empty new Task\n+   * @param workbasketKey the {@linkplain Workbasket#getKey() key} of the {@linkplain Workbasket} to\n+   *     which the {@linkplain Task} belongs\n+   * @param domain the {@linkplain Workbasket#getDomain() domain} of the {@linkplain Workbasket} to\n+   *     which the {@linkplain Task} belongs\n+   * @return an empty new {@linkplain Task}\n    */\n   Task newTask(String workbasketKey, String domain);\n \n   /**\n-   * Returns a not persisted instance of {@link TaskComment}.\n+   * Returns a not inserted instance of {@linkplain TaskComment}.\n    *\n-   * @param taskId The id of the task to which the task comment belongs\n-   * @return an empty new TaskComment\n+   * @param taskId The {@linkplain Task#getId() id} of the {@linkplain Task} to which the task\n+   *     comment belongs\n+   * @return an empty new {@linkplain TaskComment}\n    */\n   TaskComment newTaskComment(String taskId);\n \n   /**\n-   * Returns a not persisted instance of {@link Attachment}.\n+   * Returns a not inserted instance of {@linkplain Attachment}.\n    *\n-   * @return an empty new Attachment\n+   * @return an empty new {@linkplain Attachment}\n    */\n   Attachment newAttachment();\n \n   /**\n-   * Update a task.\n+   * Returns a not inserted instance of {@linkplain ObjectReference}.\n    *\n-   * @param task the task to be updated in the database\n-   * @return the updated task\n-   * @throws InvalidArgumentException if the task to be updated contains invalid properties like\n-   *     e.g. invalid object references\n-   * @throws TaskNotFoundException if the id of the task is not found in the database\n-   * @throws ConcurrencyException if the task has already been updated by another user\n-   * @throws ClassificationNotFoundException if the updated task refers to a classification that\n-   *     cannot be found\n-   * @throws NotAuthorizedException if the current user is not authorized to update the task\n-   * @throws AttachmentPersistenceException if an Attachment with ID will be added multiple times\n-   *     without using the task-methods\n-   * @throws InvalidStateException if an attempt is made to change the owner of the task and the\n-   *     task is not in state READY .\n+   * @return an empty new {@linkplain ObjectReference}\n+   */\n+  ObjectReference newObjectReference();\n+\n+  ObjectReference newObjectReference(\n+      String company, String system, String systemInstance, String type, String value);\n+\n+  /**\n+   * Update a {@linkplain Task}.\n+   *\n+   * @param task the {@linkplain Task} to be updated in the database\n+   * @return the updated {@linkplain Task}\n+   * @throws InvalidArgumentException if the {@linkplain Task} to be updated contains invalid\n+   *     properties like e.g. invalid {@linkplain ObjectReference}s\n+   * @throws TaskNotFoundException if the id of the {@linkplain Task} is not found in the database\n+   * @throws ConcurrencyException if the {@linkplain Task} has been updated by another user in the\n+   *     meantime; that's the case if the given modified timestamp differs from the one in the\n+   *     database\n+   * @throws ClassificationNotFoundException if the updated {@linkplain Task} refers to a {@link\n+   *     Classification} that cannot be found\n+   * @throws NotAuthorizedException if the current user is not authorized to update the {@linkplain\n+   *     Task}\n+   * @throws AttachmentPersistenceException if an {@linkplain Attachment} with ID will be added\n+   *     multiple times without using the Task-methods\n+   * @throws ObjectReferencePersistenceException if an {@linkplain ObjectReference} with ID will be\n+   *     added multiple times without using the Task-methods\n+   * @throws InvalidStateException if an attempt is made to change the owner of the {@linkplain\n+   *     Task} that state isn't READY.\n    */\n   Task updateTask(Task task)\n       throws InvalidArgumentException, TaskNotFoundException, ConcurrencyException,\n           ClassificationNotFoundException, NotAuthorizedException, AttachmentPersistenceException,\n-          InvalidStateException;\n+          ObjectReferencePersistenceException, InvalidStateException;\n \n   /**\n-   * Transfers a list of tasks to an other workbasket. Exceptions will be thrown if the caller got\n-   * no permissions on the target or it doesn\u00b4t exist. Other Exceptions will be stored and returned\n-   * in the end.\n+   * Transfers a list of {@linkplain Task Tasks} to another {@linkplain Workbasket} while always\n+   * setting the {@linkplain Task#isTransferred transfer} flag.\n    *\n-   * @param destinationWorkbasketId target workbasket id\n-   * @param taskIds source task which will be moved\n-   * @return Bulkresult with ID and Error in it for failed transactions.\n-   * @throws NotAuthorizedException if the caller hasn\u00b4t permissions on tarket WB.\n-   * @throws InvalidArgumentException if the method paramesters are EMPTY or NULL.\n-   * @throws WorkbasketNotFoundException if the target WB can\u00b4t be found.\n+   * @see #transferTasks(String, List, boolean)\n    */\n-  BulkOperationResults<String, TaskanaException> transferTasks(\n+  @SuppressWarnings(\"checkstyle:JavadocMethod\")\n+  default BulkOperationResults<String, TaskanaException> transferTasks(\n       String destinationWorkbasketId, List<String> taskIds)\n+      throws NotAuthorizedException, InvalidArgumentException, WorkbasketNotFoundException {\n+    return transferTasks(destinationWorkbasketId, taskIds, true);\n+  }\n+\n+  /**\n+   * Transfers a list of {@linkplain Task Tasks} to another {@linkplain Workbasket}.\n+   *\n+   * <p>The transfer resets the {@linkplain Task#isRead() read flag} and sets the {@linkplain\n+   * Task#isTransferred() transfer flag} if {@code setTransferFlag} is {@code true}. Exceptions will\n+   * be thrown if the caller got no {@linkplain WorkbasketPermission} on the target or if the target\n+   * {@linkplain Workbasket} does not exist. Other Exceptions will be stored and returned in the\n+   * end.\n+   *\n+   * @param destinationWorkbasketId {@linkplain Workbasket#getId() id} of the target {@linkplain\n+   *     Workbasket}\n+   * @param taskIds list of source {@linkplain Task Tasks} which will be moved\n+   * @param setTransferFlag the control about whether to set the {@linkplain Task#isTransferred()}\n+   *     flag or not\n+   * @return Bulkresult with {@linkplain Task#getId() ids} and Error in it for failed transactions\n+   * @throws NotAuthorizedException if the caller has no permissions on target {@linkplain\n+   *     Workbasket}\n+   * @throws InvalidArgumentException if the method parameters are EMPTY or NULL\n+   * @throws WorkbasketNotFoundException if the target {@linkplain Workbasket} can not be found\n+   */\n+  BulkOperationResults<String, TaskanaException> transferTasks(\n+      String destinationWorkbasketId, List<String> taskIds, boolean setTransferFlag)\n       throws NotAuthorizedException, InvalidArgumentException, WorkbasketNotFoundException;\n \n   /**\n-   * Transfers a list of tasks to an other workbasket. Exceptions will be thrown if the caller got\n-   * no permissions on the target or it doesn\u00b4t exist. Other Exceptions will be stored and returned\n+   * Transfers a list of {@linkplain Task Tasks} to another {@linkplain Workbasket} while always\n+   * setting the {@linkplain Task#isTransferred} flag.\n+   *\n+   * @see #transferTasks(String, String, List, boolean)\n+   */\n+  @SuppressWarnings(\"checkstyle:JavadocMethod\")\n+  default BulkOperationResults<String, TaskanaException> transferTasks(\n+      String destinationWorkbasketKey, String destinationWorkbasketDomain, List<String> taskIds)\n+      throws NotAuthorizedException, InvalidArgumentException, WorkbasketNotFoundException {\n+    return transferTasks(destinationWorkbasketKey, destinationWorkbasketDomain, taskIds, true);\n+  }\n+\n+  /**\n+   * Transfers a list of {@linkplain Task Tasks} to another {@linkplain Workbasket}.\n+   *\n+   * <p>The transfer resets the {@linkplain Task#isRead() read flag} and sets the {@linkplain\n+   * Task#isTransferred() transfer flag} if {@code setTransferFlag} is {@code true}. Exceptions will\n+   * be thrown if the caller got no {@linkplain WorkbasketPermission Permission} on the target\n+   * {@linkplain Workbasket} or if it does not exist. Other Exceptions will be stored and returned\n    * in the end.\n    *\n-   * @param destinationWorkbasketKey target workbasket key\n-   * @param destinationWorkbasketDomain target workbasket domain\n-   * @param taskIds source task which will be moved\n-   * @return Bulkresult with ID and Error in it for failed transactions.\n-   * @throws NotAuthorizedException if the caller hasn\u00b4t permissions on tarket WB.\n-   * @throws InvalidArgumentException if the method paramesters are EMPTY or NULL.\n-   * @throws WorkbasketNotFoundException if the target WB can\u00b4t be found.\n+   * @param destinationWorkbasketKey target {@linkplain Workbasket#getKey()} Workbasket}\n+   * @param destinationWorkbasketDomain target {@linkplain Workbasket#getDomain() domain}\n+   * @param taskIds List of source {@linkplain Task Tasks} which will be moved\n+   * @param setTransferFlag the control about whether to set the {@linkplain Task#isTransferred()}\n+   *     flag or not\n+   * @return BulkResult with {@linkplain Task#getId() id} and Error in it for failed transactions.\n+   * @throws NotAuthorizedException if the caller has no {@linkplain WorkbasketPermission} on target\n+   *     {@linkplain Workbasket}.\n+   * @throws InvalidArgumentException if the method parameters are EMPTY or NULL.\n+   * @throws WorkbasketNotFoundException if the target {@linkplain Workbasket} can not be found.\n    */\n   BulkOperationResults<String, TaskanaException> transferTasks(\n-      String destinationWorkbasketKey, String destinationWorkbasketDomain, List<String> taskIds)\n+      String destinationWorkbasketKey,\n+      String destinationWorkbasketDomain,\n+      List<String> taskIds,\n+      boolean setTransferFlag)\n       throws NotAuthorizedException, InvalidArgumentException, WorkbasketNotFoundException;\n \n   /**\n-   * Deletes the task with the given Id.\n+   * Deletes the {@linkplain Task} with the given {@linkplain Task#getId() id}.\n    *\n-   * @param taskId The Id of the task to delete.\n-   * @throws TaskNotFoundException If the given Id does not refer to an existing task.\n-   * @throws InvalidStateException If the state of the referenced task is not Completed.\n-   * @throws NotAuthorizedException if the current user is not member of role ADMIN\n+   * @param taskId The {@linkplain Task#getId() id} of the {@linkplain Task} to delete.\n+   * @throws TaskNotFoundException If the given {@linkplain Task#getId() id} does not refer to an\n+   *     existing {@linkplain Task}.\n+   * @throws InvalidStateException If the {@linkplain Task#getState() state} of the referenced\n+   *     {@linkplain Task} is not an end state.\n+   * @throws NotAuthorizedException if the current user is not member of role {@linkplain\n+   *     TaskanaRole#ADMIN}\n    */\n   void deleteTask(String taskId)\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n \n   /**\n-   * Deletes the task with the given Id even if it is not completed.\n+   * Deletes the {@linkplain Task} with the given {@linkplain Task#getId() id} even if it is not\n+   * completed.\n    *\n-   * @param taskId The Id of the task to delete.\n-   * @throws TaskNotFoundException If the given Id does not refer to an existing task.\n-   * @throws InvalidStateException If the state of the referenced task is not Completed and\n-   *     forceDelet is false.\n-   * @throws NotAuthorizedException if the current user is not member of role ADMIN\n+   * @param taskId The {@linkplain Task#getId() id} of the {@linkplain Task} to delete.\n+   * @throws TaskNotFoundException If the given {@linkplain Task#getId() id} does not refer to an\n+   *     existing {@linkplain Task}.\n+   * @throws InvalidStateException If the state of the referenced {@linkplain Task} is not an end\n+   *     state and forceDelete is false.\n+   * @throws NotAuthorizedException if the current user is not member of role {@linkplain\n+   *     TaskanaRole#ADMIN}\n    */\n   void forceDeleteTask(String taskId)\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n \n   /**\n-   * Deletes a list of tasks.\n+   * Selects and claims the first {@linkplain Task} which is returned by the {@linkplain TaskQuery}.\n    *\n-   * @param tasks the ids of the tasks to delete.\n-   * @return the result of the operations with Id and Exception for each failed task deletion.\n+   * @param taskQuery the {@linkplain TaskQuery}.\n+   * @return the {@linkplain Task} that got selected and claimed\n+   * @throws InvalidOwnerException if the {@linkplain Task} is claimed by someone else\n+   * @throws NotAuthorizedException if the current user has no read permission for the Workbasket\n+   *     the {@linkplain Task} is in\n+   */\n+  Task selectAndClaim(TaskQuery taskQuery) throws NotAuthorizedException, InvalidOwnerException;\n+\n+  /**\n+   * Deletes a list of {@linkplain Task Tasks}.\n+   *\n+   * @param tasks the {@linkplain Task#getId() ids} of the tasks to delete.\n+   * @return the result of the operations with each {@linkplain Task#getId() id} and Exception for\n+   *     each failed task deletion.\n    * @throws InvalidArgumentException if the TaskIds parameter is NULL\n+   * @throws NotAuthorizedException if the current user is not member of role ADMIN\n    */\n   BulkOperationResults<String, TaskanaException> deleteTasks(List<String> tasks)\n-      throws InvalidArgumentException;\n+      throws InvalidArgumentException, NotAuthorizedException;\n \n   /**\n-   * Completes a list of tasks.\n+   * Completes a list of {@linkplain Task Tasks}.\n    *\n-   * @param taskIds of the tasks which should be completed.\n-   * @return the result of the operations with Id and Exception for each failed task completion.\n-   * @throws InvalidArgumentException If the taskId parameter is NULL.\n+   * @param taskIds {@linkplain Task#getId() ids} of the {@linkplain Task Tasks} which should be\n+   *     completed\n+   * @return the result of the operations with each {@linkplain Task#getId() id} and Exception for\n+   *     each failed completion\n+   * @throws InvalidArgumentException If the taskIds parameter is NULL\n    */\n   BulkOperationResults<String, TaskanaException> completeTasks(List<String> taskIds)\n       throws InvalidArgumentException;\n \n   /**\n-   * Updates tasks with a matching {@link ObjectReference}.\n+   * Completes each existing {@linkplain Task} in the given List in every case, independent of the\n+   * {@linkplain Task#getOwner() owner} or {@linkplain Task#getState() state} of the {@linkplain\n+   * Task}. If the {@linkplain Task} is already {@linkplain TaskState#COMPLETED completed}, the\n+   * {@linkplain Task} stays unchanged.\n+   *\n+   * @see TaskService#forceCompleteTask\n+   * @param taskIds {@linkplain Task#getId() id} of the {@linkplain Task Tasks} which should be\n+   *     completed\n+   * @return the result of the operations with {@linkplain Task#getId() id} and Exception for each\n+   *     failed completion\n+   * @throws InvalidArgumentException If the taskIds parameter is NULL\n+   */\n+  BulkOperationResults<String, TaskanaException> forceCompleteTasks(List<String> taskIds)\n+      throws InvalidArgumentException;\n+\n+  /**\n+   * Updates specified {@linkplain TaskCustomField TaskCustomFields} of {@linkplain Task Tasks}\n+   * associated with the given {@linkplain ObjectReference}.\n    *\n-   * @param selectionCriteria the {@link ObjectReference} that is used to select the tasks.\n-   * @param customFieldsToUpdate a {@link Map} that contains as key the identification of the custom\n-   *     field and as value the corresponding new value of that custom field. The key for\n-   *     identification of the custom field must be a String with value \"1\", \"2\" ... \"16\" as in the\n-   *     setCustomAttribute or getCustomAttribute method of {@link Task}\n-   * @return a list of the Ids of all modified tasks\n-   * @throws InvalidArgumentException If the customFieldsToUpdate map contains an invalid key or if\n-   *     the selectionCriteria is invalid\n+   * @param selectionCriteria the {@linkplain ObjectReference} that is used to select the tasks\n+   * @param customFieldsToUpdate a Map that contains as key the identification of the {@linkplain\n+   *     TaskCustomField} and as value the corresponding new value of that field\n+   * @return a list of the {@linkplain Task#getId() ids} of all modified {@linkplain Task Tasks}\n+   * @throws InvalidArgumentException if the given selectionCriteria is invalid or the given\n+   *     customFieldsToUpdate are NULL or empty\n    */\n   List<String> updateTasks(\n-      ObjectReference selectionCriteria, Map<String, String> customFieldsToUpdate)\n+      ObjectReference selectionCriteria, Map<TaskCustomField, String> customFieldsToUpdate)\n       throws InvalidArgumentException;\n \n   /**\n-   * Updates tasks with matching taskIds.\n+   * Updates specified {@linkplain TaskCustomField TaskCustomFields} for all given {@linkplain Task\n+   * Tasks}.\n    *\n-   * @param taskIds the taskIds that are used to select the tasks.\n-   * @param customFieldsToUpdate a {@link Map} that contains as key the identification of the custom\n-   *     field and as value the corresponding new value of that custom field. The key for\n-   *     identification of the custom field must be a String with value \"1\", \"2\" ... \"16\" as in the\n-   *     setCustomAttribute or getCustomAttribute method of {@link Task}\n-   * @return a list of the Ids of all modified tasks\n-   * @throws InvalidArgumentException If the customFieldsToUpdate map contains an invalid key or if\n-   *     the selectionCriteria is invalid\n+   * @param taskIds the {@linkplain Task#getId() taskIds} that are used to select the {@linkplain\n+   *     Task Tasks}.\n+   * @param customFieldsToUpdate a Map that contains as key the identification of the {@linkplain\n+   *     TaskCustomField} and as value the corresponding new value of that {@linkplain\n+   *     TaskCustomField}.\n+   * @return a list of the {@linkplain Task#getId() ids} of all modified {@linkplain Task Tasks}\n+   * @throws InvalidArgumentException if the given customFieldsToUpdate are NULL or empty.\n    */\n-  List<String> updateTasks(List<String> taskIds, Map<String, String> customFieldsToUpdate)\n+  List<String> updateTasks(List<String> taskIds, Map<TaskCustomField, String> customFieldsToUpdate)\n       throws InvalidArgumentException;\n \n   /**\n-   * Create a task comment.\n+   * Inserts the specified {@linkplain TaskComment} into the database.\n    *\n-   * @param taskComment the task comment to be created.\n-   * @return the created task comment.\n-   * @throws NotAuthorizedException If the current user has no authorization to create a task\n-   *     comment for the given taskId in the TaskComment or is not authorized to access the task.\n-   * @throws TaskNotFoundException If the given taskId in the TaskComment does not refer to an\n-   *     existing task.\n-   * @throws InvalidArgumentException If the given taskCommentId from the provided task comment is\n-   *     not null or empty\n+   * @param taskComment the {@linkplain TaskComment} to be created\n+   * @return the created {@linkplain TaskComment}\n+   * @throws NotAuthorizedException if the current user has no authorization to create a {@link\n+   *     TaskComment} for the given taskId or is not authorized to access the {@linkplain Task}\n+   * @throws TaskNotFoundException if the given {@linkplain TaskComment#getTaskId() taskId} does not\n+   *     refer to an existing {@linkplain Task}\n+   * @throws InvalidArgumentException if the {@linkplain TaskComment#getId() id} of the provided\n+   *     {@link TaskComment} is not NULL or empty\n    */\n   TaskComment createTaskComment(TaskComment taskComment)\n       throws NotAuthorizedException, TaskNotFoundException, InvalidArgumentException;\n \n   /**\n-   * Update a task comment.\n+   * Updates the specified {@linkplain TaskComment}.\n    *\n-   * @param taskComment the task comment to be updated in the database.\n-   * @return the updated task comment.\n-   * @throws NotAuthorizedException If the current user has no authorization to update a task\n-   *     comment or is not authorized to access the task.\n-   * @throws ConcurrencyException if an attempt is made to update the task comment and another user.\n-   *     updated it already.\n-   * @throws TaskCommentNotFoundException If the given taskCommentId in the TaskComment does not\n-   *     refer to an existing taskComment.\n-   * @throws TaskNotFoundException If the given taskId in the TaskComment does not refer to an\n-   *     existing task.\n-   * @throws InvalidArgumentException If the given taskCommentId from the provided task comment is\n-   *     null or empty\n+   * @param taskComment the {@linkplain TaskComment} to be updated in the database\n+   * @return the updated {@linkplain TaskComment}\n+   * @throws NotAuthorizedException if the current user has no authorization to update the\n+   *     {@linkplain TaskComment} or is not authorized to access the {@linkplain Task}\n+   * @throws ConcurrencyException if an attempt is made to update the {@linkplain TaskComment} and\n+   *     another user updated it already; that's the case if the given {} timestamp differs from the\n+   *     one in the database\n+   * @throws TaskCommentNotFoundException if the {@linkplain TaskComment#getId() is} of the\n+   *     specified {@linkplain TaskComment}does not refer to an existing {@linkplain TaskComment}\n+   * @throws TaskNotFoundException if the {@linkplain TaskComment#getTaskId() taskId} does not refer\n+   *     to an existing {@linkplain Task}\n+   * @throws InvalidArgumentException if the given {@linkplain TaskComment#getId() id} is NULL or\n+   *     empty\n    */\n   TaskComment updateTaskComment(TaskComment taskComment)\n       throws NotAuthorizedException, ConcurrencyException, TaskCommentNotFoundException,\n           TaskNotFoundException, InvalidArgumentException;\n \n   /**\n-   * Deletes the task comment with the given Id.\n+   * Deletes the {@linkplain TaskComment} with the given {@linkplain TaskComment#getId() id}.\n    *\n-   * @param taskCommentId The id of the task comment to delete.\n-   * @throws NotAuthorizedException If the current user has no authorization to delete a task\n+   * @param taskCommentId the {@linkplain TaskComment#getId() id} of the {@linkplain TaskComment} to\n+   *     delete\n+   * @throws NotAuthorizedException if the current user has no authorization to delete a task\n    *     comment or is not authorized to access the task.\n-   * @throws InvalidArgumentException If the taskCommentId is null/empty\n-   * @throws TaskCommentNotFoundException If the given taskCommentId in the TaskComment does not\n+   * @throws InvalidArgumentException if the taskCommentId is NULL or empty\n+   * @throws TaskCommentNotFoundException if the given taskCommentId in the TaskComment does not\n    *     refer to an existing taskComment.\n-   * @throws TaskNotFoundException If the given taskId in the TaskComment does not refer to an\n-   *     existing task.\n-   * @throws InvalidArgumentException If the given taskCommentId is null or empty\n+   * @throws TaskNotFoundException if the {@linkplain TaskComment#getTaskId() taskId} of the\n+   *     TaskComment does not refer to an existing {@linkplain Task}.\n+   * @throws InvalidArgumentException if the given taskCommentId is NULL or empty\n    */\n   void deleteTaskComment(String taskCommentId)\n       throws NotAuthorizedException, TaskCommentNotFoundException, TaskNotFoundException,\n           InvalidArgumentException;\n \n   /**\n-   * Retrieves a task comment for a given taskCommentId.\n+   * Retrieves the {@linkplain TaskComment} with the given {@linkplain TaskComment#getId() id}.\n    *\n-   * @param taskCommentId The id of the task comment which should be retrieved\n-   * @return the task comment identified by taskCommentId\n-   * @throws TaskCommentNotFoundException If the given taskCommentId in the TaskComment does not\n-   *     refer to an existing taskComment.\n-   * @throws NotAuthorizedException If the current user has no authorization to retrieve a\n-   *     taskComment from a certain task or is not authorized to access the task.\n-   * @throws TaskNotFoundException If the given taskId in the TaskComment does not refer to an\n-   *     existing task.\n-   * @throws InvalidArgumentException If the given taskCommentId is null or empty\n+   * @param taskCommentId the {@linkplain TaskComment#getId() id} of the {@linkplain TaskComment}\n+   *     which should be retrieved\n+   * @return the {@linkplain TaskComment} identified by taskCommentId\n+   * @throws TaskCommentNotFoundException if the given taskCommentId does not refer to an existing\n+   *     {@linkplain TaskComment}\n+   * @throws NotAuthorizedException if the current user has no authorization to retrieve a\n+   *     {@linkplain TaskComment} from a certain {@linkplain Task} or is not authorized to access\n+   *     the {@linkplain Task}\n+   * @throws TaskNotFoundException if the {@linkplain TaskComment#getTaskId() taskId} of the\n+   *     TaskComment does not refer to an existing {@linkplain Task}\n+   * @throws InvalidArgumentException if the given taskCommentId is NULL or empty\n    */\n   TaskComment getTaskComment(String taskCommentId)\n       throws TaskCommentNotFoundException, NotAuthorizedException, TaskNotFoundException,\n           InvalidArgumentException;\n \n   /**\n-   * Retrieves a list of task comments for a given taskId.\n+   * Retrieves the List of {@linkplain TaskComment TaskComments} for the Task with given {@linkplain\n+   * Task#getId() id}.\n    *\n-   * @param taskId The id of the task for which all task comments should be retrieved\n-   * @return the list of task comments attached to task with id taskId\n-   * @throws NotAuthorizedException If the current user has no authorization to retrieve a\n-   *     taskComment from a certain task or is not authorized to access the task.\n-   * @throws TaskNotFoundException If the given taskId in the TaskComment does not refer to an\n-   *     existing task.\n+   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} for which all task\n+   *     comments should be retrieved\n+   * @return the List of task comments attached to the specified {@linkplain Task}\n+   * @throws NotAuthorizedException if the current user has no authorization to retrieve a\n+   *     taskComment from the {@linkplain Task} or is not authorized to access the {@linkplain Task}\n+   * @throws TaskNotFoundException if the given taskId does not refer to an existing {@linkplain\n+   *     Task}\n    */\n   List<TaskComment> getTaskComments(String taskId)\n       throws NotAuthorizedException, TaskNotFoundException;\n \n   /**\n-   * Sets the callback state on a list of tasks. Note: this method is primarily intended to be used\n-   * by the TaskanaAdapter\n+   * Sets the specified {@linkplain CallbackState} on a list of {@linkplain Task Tasks}. Note: this\n+   * method is primarily intended to be used by the TaskanaAdapter\n    *\n-   * @param externalIds the EXTERNAL_IDs of the tasks on which the callback state is set.\n-   * @param state the callback state that is to be set on the tasks\n-   * @return the result of the operations with Id and Exception for each failed task deletion.\n+   * @param externalIds the {@linkplain Task#getExternalId() externalIds} of the {@linkplain Task\n+   *     Tasks} on which the {@linkplain CallbackState} is set\n+   * @param state the {@linkplain CallbackState} that is to be set on the {@linkplain Task Tasks}\n+   * @return the result of the operations with {@linkplain Task#getId() id} and Exception for each\n+   *     failed operation\n    */\n   BulkOperationResults<String, TaskanaException> setCallbackStateForTasks(\n       List<String> externalIds, CallbackState state);\n \n   /**\n-   * Sets the owner on a list of tasks. The owner will only be set on tasks that are in state READY.\n+   * Sets the {@linkplain Task#getOwner() owner} on a List of {@linkplain Task Tasks}. The\n+   * {@linkplain Task#getOwner() owner} will only be set on {@linkplain Task Tasks} that are in\n+   * state {@linkplain TaskState#READY}.\n    *\n-   * @param owner the new owner of the tasks\n-   * @param taskIds the IDs of the tasks on which the owner is to be set.\n-   * @return the result of the operations with Id and Exception for each failed task update.\n+   * @param owner the new {@linkplain Task#getOwner() owner} of the {@linkplain Task Tasks}\n+   * @param taskIds the {@linkplain Task#getId() ids} of the {@linkplain Task Tasks} on which the\n+   *     {@linkplain Task#getOwner() owner} is to be set\n+   * @return the result of the operations with {@linkplain Task#getId() id} and Exception for each\n+   *     failed {@linkplain Task}-update\n    */\n   BulkOperationResults<String, TaskanaException> setOwnerOfTasks(\n       String owner, List<String> taskIds);\n \n   /**\n-   * Sets the planned property on a list of tasks. Only tasks in state READY and CLAIMED will be\n-   * affected by this method. On each task, the corresponding due date is set according to the\n-   * shortest service level in the classifications of the task and the task's attachments.\n+   * Sets the {@linkplain Task#getPlanned() planned} Instant on a List of {@linkplain Task Tasks}.\n+   * Only {@linkplain Task Tasks} in state {@linkplain TaskState#READY} and {@linkplain\n+   * TaskState#CLAIMED} will be affected by this method. On each {@linkplain Task}, the\n+   * corresponding {@linkplain Task#getDue() due date} is set according to the shortest serviceLevel\n+   * in the {@linkplain Task#getClassificationSummary() Classification} of the {@linkplain Task} and\n+   * its {@linkplain Task#getAttachments() Attachments}.\n    *\n-   * @param planned the new 'PLANNED\" property of the tasks\n-   * @param taskIds the IDs of the tasks on which the new planned property is to be set.\n-   * @return the result of the operations with Id and Exception for each failed task update.\n+   * @param planned the new {@linkplain Task#getPlanned() planned} Instant of the {@linkplain Task\n+   *     Tasks}\n+   * @param taskIds the {@linkplain Task#getId() ids} of the {@linkplain Task Tasks} on which the\n+   *     new {@linkplain Task#getPlanned() planned} Instant is to be set\n+   * @return the result of the operations with {@linkplain Task#getId() id} and Exception for each\n+   *     failed {@linkplain Task Task} update.\n    */\n   BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n       Instant planned, List<String> taskIds);\n \n   /**\n-   * Cancels a task.\n+   * Cancels the {@linkplain Task} with the given {@linkplain Task#getId() id}. Cancellation means a\n+   * {@linkplain Task} is obsolete from a business perspective and does not need to be completed\n+   * anymore.\n    *\n-   * @param taskId the id of the task to cancel.\n-   * @return the updated task.\n-   * @throws TaskNotFoundException if the Task with Id TaskId is not found\n-   * @throws InvalidStateException if the task is not in state READY or CLAIMED\n-   * @throws NotAuthorizedException if the current user is not authorized to see the task\n+   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to cancel\n+   * @return the updated {@linkplain Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} with taskId is not found\n+   * @throws InvalidStateException if the {@linkplain Task} is not in state {@linkplain\n+   *     TaskState#READY} or {@linkplain TaskState#CLAIMED}\n+   * @throws NotAuthorizedException if the current user is not authorized to see the {@linkplain\n+   *     Task}\n    */\n   Task cancelTask(String taskId)\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n \n   /**\n-   * Terminates a task.\n+   * Terminates a {@linkplain Task}. Termination is an administrative action to complete a\n+   * {@linkplain Task}. This is typically done by administration to correct any technical issue.\n    *\n-   * @param taskId the id of the task to cancel.\n-   * @return the updated task.\n-   * @throws TaskNotFoundException if the Task with Id TaskId is not found\n-   * @throws InvalidStateException if the task is not in state READY or CLAIMED\n-   * @throws NotAuthorizedException if the current user is not authorized to see the task\n+   * @param taskId the id of the {@linkplain Task} to cancel\n+   * @return the updated {@linkplain Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} with taskId is not found\n+   * @throws InvalidStateException if the {@linkplain Task} is not in state {@linkplain\n+   *     TaskState#READY} or {@linkplain TaskState#CLAIMED}\n+   * @throws NotAuthorizedException if the current user is not authorized to see the {@linkplain\n+   *     Task}\n    */\n   Task terminateTask(String taskId)\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n", "next_change": {"commit": "a2e068119042fd305c3f494e43cd41fec80f1a30", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 48bac1ed4..a58ce2866 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -670,49 +744,53 @@ public interface TaskService {\n \n   /**\n    * Sets the {@linkplain Task#getPlanned() planned} Instant on a List of {@linkplain Task Tasks}.\n-   * Only {@linkplain Task Tasks} in state {@linkplain TaskState#READY} and {@linkplain\n+   *\n+   * <p>Only {@linkplain Task Tasks} in state {@linkplain TaskState#READY} and {@linkplain\n    * TaskState#CLAIMED} will be affected by this method. On each {@linkplain Task}, the\n-   * corresponding {@linkplain Task#getDue() due date} is set according to the shortest serviceLevel\n-   * in the {@linkplain Task#getClassificationSummary() Classification} of the {@linkplain Task} and\n-   * its {@linkplain Task#getAttachments() Attachments}.\n+   * corresponding {@linkplain Task#getDue() due} Instant is set according to the shortest\n+   * serviceLevel in the {@linkplain Task#getClassificationSummary() Classification} of the\n+   * {@linkplain Task} and its {@linkplain Task#getAttachments() Attachments}.\n    *\n    * @param planned the new {@linkplain Task#getPlanned() planned} Instant of the {@linkplain Task\n    *     Tasks}\n    * @param taskIds the {@linkplain Task#getId() ids} of the {@linkplain Task Tasks} on which the\n    *     new {@linkplain Task#getPlanned() planned} Instant is to be set\n-   * @return the result of the operations with {@linkplain Task#getId() id} and Exception for each\n-   *     failed {@linkplain Task Task} update.\n+   * @return the result of the operations with {@linkplain Task#getId() ids} and Exception for each\n+   *     failed {@linkplain Task} update\n    */\n   BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n       Instant planned, List<String> taskIds);\n \n   /**\n-   * Cancels the {@linkplain Task} with the given {@linkplain Task#getId() id}. Cancellation means a\n-   * {@linkplain Task} is obsolete from a business perspective and does not need to be completed\n-   * anymore.\n+   * Cancels the {@linkplain Task} with the given {@linkplain Task#getId() id}.\n+   *\n+   * <p>Cancellation means a {@linkplain Task} is obsolete from a business perspective and doesn't\n+   * need to be completed anymore.\n    *\n    * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to cancel\n    * @return the updated {@linkplain Task}\n-   * @throws TaskNotFoundException if the {@linkplain Task} with taskId is not found\n-   * @throws InvalidStateException if the {@linkplain Task} is not in state {@linkplain\n-   *     TaskState#READY} or {@linkplain TaskState#CLAIMED}\n-   * @throws NotAuthorizedException if the current user is not authorized to see the {@linkplain\n-   *     Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} with taskId wasn't found\n+   * @throws InvalidStateException if the {@linkplain Task} isn't in {@linkplain TaskState#READY} or\n+   *     {@linkplain TaskState#CLAIMED}\n+   * @throws NotAuthorizedException if the current user has no {@linkplain\n+   *     WorkbasketPermission#READ} for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task cancelTask(String taskId)\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n \n   /**\n    * Terminates a {@linkplain Task}. Termination is an administrative action to complete a\n-   * {@linkplain Task}. This is typically done by administration to correct any technical issue.\n+   * {@linkplain Task}.\n+   *\n+   * <p>This is typically done by administration to correct any technical issue.\n    *\n-   * @param taskId the id of the {@linkplain Task} to cancel\n+   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to cancel\n    * @return the updated {@linkplain Task}\n-   * @throws TaskNotFoundException if the {@linkplain Task} with taskId is not found\n-   * @throws InvalidStateException if the {@linkplain Task} is not in state {@linkplain\n-   *     TaskState#READY} or {@linkplain TaskState#CLAIMED}\n-   * @throws NotAuthorizedException if the current user is not authorized to see the {@linkplain\n-   *     Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} with taskId wasn't found\n+   * @throws InvalidStateException if the {@linkplain Task} isn't in {@linkplain TaskState#READY} or\n+   *     {@linkplain TaskState#CLAIMED}\n+   * @throws NotAuthorizedException if the current user isn't member of {@linkplain\n+   *     TaskanaRole#ADMIN} or {@linkplain TaskanaRole#BUSINESS_ADMIN}\n    */\n   Task terminateTask(String taskId)\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n", "next_change": {"commit": "33a88529954a490d2a042a34319cbf394ee15e9d", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex a58ce2866..6e357fdf2 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -677,121 +853,55 @@ public interface TaskService {\n       throws NotAuthorizedException, TaskCommentNotFoundException, TaskNotFoundException,\n           InvalidArgumentException;\n \n-  /**\n-   * Retrieves the {@linkplain TaskComment} with the given {@linkplain TaskComment#getId() id}.\n-   *\n-   * @param taskCommentId the {@linkplain TaskComment#getId() id} of the {@linkplain TaskComment}\n-   *     which should be retrieved\n-   * @return the {@linkplain TaskComment} identified by taskCommentId\n-   * @throws TaskCommentNotFoundException if the given taskCommentId doesn't refer to an existing\n-   *     {@linkplain TaskComment}\n-   * @throws NotAuthorizedException if the current user has no {@linkplain\n-   *     WorkbasketPermission#READ} for the {@linkplain Workbasket} of the commented {@linkplain\n-   *     Task}\n-   * @throws TaskNotFoundException if the {@linkplain TaskComment#getTaskId() taskId} of the\n-   *     TaskComment doesn't refer to an existing {@linkplain Task}\n-   * @throws InvalidArgumentException if the given taskCommentId is NULL or empty\n-   */\n-  TaskComment getTaskComment(String taskCommentId)\n-      throws TaskCommentNotFoundException, NotAuthorizedException, TaskNotFoundException,\n-          InvalidArgumentException;\n+  // endregion\n \n-  /**\n-   * Retrieves the List of {@linkplain TaskComment TaskComments} for the {@linkplain Task} with\n-   * given {@linkplain Task#getId() id}.\n-   *\n-   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} for which all\n-   *     {@linkplain TaskComment TaskComments} should be retrieved\n-   * @return the List of {@linkplain TaskComment TaskComments} attached to the specified {@linkplain\n-   *     Task}\n-   * @throws NotAuthorizedException if the current user has no {@linkplain\n-   *     WorkbasketPermission#READ} for the {@linkplain Workbasket} of the commented {@linkplain\n-   *     Task}\n-   * @throws TaskNotFoundException if the given taskId doesn't refer to an existing {@linkplain\n-   *     Task}\n-   */\n-  List<TaskComment> getTaskComments(String taskId)\n-      throws NotAuthorizedException, TaskNotFoundException;\n+  // endregion\n \n   /**\n-   * Sets the specified {@linkplain CallbackState} on a List of {@linkplain Task Tasks}.\n-   *\n-   * <p>Note: this method is primarily intended to be used by the TaskanaAdapter\n+   * Instantiates a non-persistent/non-inserted {@linkplain Attachment}.\n    *\n-   * @param externalIds the {@linkplain Task#getExternalId() externalIds} of the {@linkplain Task\n-   *     Tasks} on which the {@linkplain CallbackState} is set\n-   * @param state the {@linkplain CallbackState} that is to be set on the {@linkplain Task Tasks}\n-   * @return the result of the operations with {@linkplain Task#getId() ids} and Exception for each\n-   *     failed operation\n+   * @return the instantiated {@linkplain Attachment}\n    */\n-  BulkOperationResults<String, TaskanaException> setCallbackStateForTasks(\n-      List<String> externalIds, CallbackState state);\n+  Attachment newAttachment();\n \n   /**\n-   * Sets the {@linkplain Task#getOwner() owner} on a List of {@linkplain Task Tasks}.\n-   *\n-   * <p>The {@linkplain Task#getOwner() owner} will only be set on {@linkplain Task Tasks} that are\n-   * in {@linkplain TaskState#READY}.\n+   * Instantiates a non-persistent/non-inserted {@linkplain ObjectReference}.\n    *\n-   * @param owner the new {@linkplain Task#getOwner() owner} of the {@linkplain Task Tasks}\n-   * @param taskIds the {@linkplain Task#getId() ids} of the {@linkplain Task Tasks} on which the\n-   *     {@linkplain Task#getOwner() owner} is to be set\n-   * @return the result of the operations with {@linkplain Task#getId() ids} and Exception for each\n-   *     failed {@linkplain Task}-update\n+   * @return the instantiated {@linkplain ObjectReference}\n+   * @see #newObjectReference(String, String, String, String, String)\n    */\n-  BulkOperationResults<String, TaskanaException> setOwnerOfTasks(\n-      String owner, List<String> taskIds);\n+  ObjectReference newObjectReference();\n \n   /**\n-   * Sets the {@linkplain Task#getPlanned() planned} Instant on a List of {@linkplain Task Tasks}.\n-   *\n-   * <p>Only {@linkplain Task Tasks} in state {@linkplain TaskState#READY} and {@linkplain\n-   * TaskState#CLAIMED} will be affected by this method. On each {@linkplain Task}, the\n-   * corresponding {@linkplain Task#getDue() due} Instant is set according to the shortest\n-   * serviceLevel in the {@linkplain Task#getClassificationSummary() Classification} of the\n-   * {@linkplain Task} and its {@linkplain Task#getAttachments() Attachments}.\n+   * Instantiates a non-persistent/non-inserted {@linkplain ObjectReference}.\n    *\n-   * @param planned the new {@linkplain Task#getPlanned() planned} Instant of the {@linkplain Task\n-   *     Tasks}\n-   * @param taskIds the {@linkplain Task#getId() ids} of the {@linkplain Task Tasks} on which the\n-   *     new {@linkplain Task#getPlanned() planned} Instant is to be set\n-   * @return the result of the operations with {@linkplain Task#getId() ids} and Exception for each\n-   *     failed {@linkplain Task} update\n+   * @param company the {@linkplain ObjectReference#getCompany() company} of the new {@linkplain\n+   *     ObjectReference}\n+   * @param system the {@linkplain ObjectReference#getSystem() system} of the new {@linkplain\n+   *     ObjectReference}\n+   * @param systemInstance the {@linkplain ObjectReference#getSystemInstance() systemInstance} of\n+   *     the new {@linkplain ObjectReference}\n+   * @param type the {@linkplain ObjectReference#getType() type} of the new {@linkplain\n+   *     ObjectReference}\n+   * @param value the {@linkplain ObjectReference#getValue() value} of the new {@linkplain\n+   *     ObjectReference}\n+   * @return the instantiated {@linkplain ObjectReference}\n+   * @see #newObjectReference()\n    */\n-  BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n-      Instant planned, List<String> taskIds);\n+  ObjectReference newObjectReference(\n+      String company, String system, String systemInstance, String type, String value);\n \n   /**\n-   * Cancels the {@linkplain Task} with the given {@linkplain Task#getId() id}.\n-   *\n-   * <p>Cancellation means a {@linkplain Task} is obsolete from a business perspective and doesn't\n-   * need to be completed anymore.\n+   * Creates an empty {@linkplain TaskQuery}.\n    *\n-   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to cancel\n-   * @return the updated {@linkplain Task}\n-   * @throws TaskNotFoundException if the {@linkplain Task} with taskId wasn't found\n-   * @throws InvalidStateException if the {@linkplain Task} isn't in {@linkplain TaskState#READY} or\n-   *     {@linkplain TaskState#CLAIMED}\n-   * @throws NotAuthorizedException if the current user has no {@linkplain\n-   *     WorkbasketPermission#READ} for the {@linkplain Workbasket} the {@linkplain Task} is in\n+   * @return a {@linkplain TaskQuery}\n    */\n-  Task cancelTask(String taskId)\n-      throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n+  TaskQuery createTaskQuery();\n \n   /**\n-   * Terminates a {@linkplain Task}. Termination is an administrative action to complete a\n-   * {@linkplain Task}.\n-   *\n-   * <p>This is typically done by administration to correct any technical issue.\n+   * Creates an empty {@linkplain TaskCommentQuery}.\n    *\n-   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to cancel\n-   * @return the updated {@linkplain Task}\n-   * @throws TaskNotFoundException if the {@linkplain Task} with taskId wasn't found\n-   * @throws InvalidStateException if the {@linkplain Task} isn't in {@linkplain TaskState#READY} or\n-   *     {@linkplain TaskState#CLAIMED}\n-   * @throws NotAuthorizedException if the current user isn't member of {@linkplain\n-   *     TaskanaRole#ADMIN} or {@linkplain TaskanaRole#BUSINESS_ADMIN}\n+   * @return a {@linkplain TaskCommentQuery}\n    */\n-  Task terminateTask(String taskId)\n-      throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n+  TaskCommentQuery createTaskCommentQuery();\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6bd6bd48386155644df0463edf8aeda473bd1a56", "message": "Merge commit", "committedDate": null}, {"oid": "3b13b9a95e4d7d1cf172f22fa0f2679ff1c5f79b", "committedDate": "2020-02-03 11:41:02 +0100", "message": "TSK-991 after initial refactoring"}, {"oid": "22ac25f5c9244bdc67752b7adcb9d98f4b8d6fa2", "committedDate": "2020-02-06 14:05:27 +0100", "message": "TSK-927 reserve a task via SetOwner"}, {"oid": "5c7d38451ce7cbea2ad52d3b84be72d49c474c71", "committedDate": "2020-02-13 15:09:39 +0100", "message": "TSK-1094 introduce models package for */api and */internal"}, {"oid": "ddb12a6ad15965ad6e87d0920c975d425c575249", "committedDate": "2020-02-14 12:04:52 +0100", "message": "TSK-1095"}, {"oid": "20bd0922dbc332efcf4e94a0d487b077c95c5a85", "committedDate": "2020-02-26 14:48:50 +0100", "message": "TSK-1131 updateOwner on multiple tasks"}, {"oid": "02a6df6f73622e86684c6c30d8f320c84078b237", "committedDate": "2020-02-28 10:46:45 +0100", "message": "TSK-1139 Bulk update of Planned timestamp"}, {"oid": "3b7da72d24beb1e0f6d528f575b1ae7029f10e7f", "committedDate": "2020-03-17 11:54:26 +0100", "message": "TSK-1150 Java-API for the administration of comments for tasks"}, {"oid": "7d464bd6cde263ad9b674e5d796fcf91e4a727bf", "committedDate": "2020-03-17 11:54:26 +0100", "message": "TSK-1150 Comments from Bernd Breier"}, {"oid": "7deb9254113278ccf5872283c2abd202c3cf7af0", "committedDate": "2020-03-19 14:43:16 +0100", "message": "TSK-1143 UpdateTask planned - comments from Holger"}, {"oid": "7b409451dcf7f12714b5c9739861c9b43541e275", "committedDate": "2020-03-25 08:44:18 +0100", "message": "TSK-1143C mismatch between forward and backward calculation between planned and due"}, {"oid": "2ce7f86456f99d522e001080e9504ae4cd6a80f4", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-1160 TaskStates CANCELLED and TERMINATED"}, {"oid": "d6505284f780ec7a804adf7d6156726e85ddd4ef", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-1160 - terminate/cancel task Holger's comments"}, {"oid": "93a94f0458979e35cb92ee682be312532d1e5210", "committedDate": "2020-03-31 11:56:59 +0200", "message": "TSK-1150: added taskId as pathvariable to getTaskComment and deleteTaskComment"}, {"oid": "dffb139a822c55fcf12438e6e996fdef41b6f098", "committedDate": "2020-03-31 11:56:59 +0200", "message": "comments from Holger Hagen"}, {"oid": "1f13c2c33ac0ce2c8202a23f5d977c87717894a3", "committedDate": "2020-05-13 14:49:18 +0200", "message": "TSK-1195: Secure deleteTasks in TaskServiceImpl"}, {"oid": "496da17b3eec2490b68b27c4192b32c02935a2f0", "committedDate": "2020-06-07 15:56:30 +0200", "message": "TSK-1257: refactored claimtasks in taskService and increased test coverage"}, {"oid": "6f12677b74a36ec04e282def79e8b549d48c1988", "committedDate": "2020-06-07 15:56:30 +0200", "message": "TSK-1257: implementes forceCompleteTasks"}, {"oid": "1dfe54c0b6fb05c6811573e38feba9212fdb6a9f", "committedDate": "2020-06-30 14:50:26 +0200", "message": "TSK-1275: Support select and claim in one API call"}, {"oid": "969d3eeff653d51eb7dcf5234aa4020333613ab3", "committedDate": "2020-06-30 14:50:26 +0200", "message": "review Findings"}, {"oid": "7cc5b00be617227dac2f8d1210554108d18bad4a", "committedDate": "2020-07-24 01:05:42 +0200", "message": "TSK-1345: replaced every customField API call with CustomField enums"}, {"oid": "3967e2900e8b35329b3675844ca3a8e059916c7e", "committedDate": "2020-12-18 11:29:10 +0100", "message": "TSK-1436: rest api documentation is now build with spring-auto-restdocs"}, {"oid": "de57596ba8e816d3e751b21c949a3fe132b314f0", "committedDate": "2020-12-18 11:29:10 +0100", "message": "TSK-1436: reworked review comments."}, {"oid": "d57aeb3219f45e962d6a05b175f4397d296e819b", "committedDate": "2021-03-01 10:03:04 +0100", "message": "TSK-1524: Set the default service level to \"P0D\" (#1496)"}, {"oid": "ec822c116855052b32ef98cc496e4876c7f52fa6", "committedDate": "2021-03-02 10:34:30 +0100", "message": "TSK-1555: Initialize due of Cleanup Job based on firstRun (#1488)"}, {"oid": "0119999380b40fdc0f69677f96650de5c81bd2a5", "committedDate": "2021-03-09 18:58:51 +0100", "message": "TSK-1538: Added transfer method with control setTransferFlag (#1513)"}, {"oid": "1c83b7871f144cd07a912639b942d5938219e101", "committedDate": "2021-06-22 16:14:09 +0200", "message": "TSK-1646: Bugfix for creation / update of Task with invalid Attachment"}, {"oid": "34d2bbfa929ccaa9e9b93c173b8fa867154330bb", "committedDate": "2021-07-14 10:49:34 +0200", "message": "TSK-1647: Implemented an error key for every exception"}, {"oid": "375a92291d41c6c90b403055ac5228ccd309621a", "committedDate": "2021-07-15 14:03:00 +0200", "message": "TSK-1658: Created TaskQueryMapperSqlProvider"}, {"oid": "e264a203892c6d2111df4645abf7f373bf4ca86a", "committedDate": "2021-10-08 08:38:21 +0200", "message": "TSK-1726: Implemented option to include long name on Task / TaskComment / TaskHistoryEvent"}, {"oid": "967e59e012f94e116f2b327b6c426f44ae1bcbee", "committedDate": "2022-02-25 10:23:40 +0100", "message": "TSK-1800: add secondary object references"}, {"oid": "b4e1f9bc315eb701d0dec0e34c38651672239566", "committedDate": "2022-04-15 11:43:57 +0200", "message": "TSK-1532: Refactor names of entities in REST-Doc by capitalizing them; refactor Java-doc according to guidelines"}, {"oid": "a2e068119042fd305c3f494e43cd41fec80f1a30", "committedDate": "2022-05-31 16:01:49 +0200", "message": "TSK-1852: refactor JavaDoc in TaskService"}, {"oid": "ef875dd42a58b55bace25fb4f599d84e4d06b59b", "committedDate": "2022-08-06 14:30:59 +0200", "message": "TSK-1915: Add requestReview functionality"}, {"oid": "cc32b10d82b7888ed2eae438100d2e26fb508f0c", "committedDate": "2022-08-09 13:19:02 +0200", "message": "TSK-1916: Add requestChanges functionality"}, {"oid": "6997d640834819d21fe0325178d73bbf70de68fc", "committedDate": "2022-08-11 17:08:10 +0200", "message": "TSK-1943: added REST endpoint for force requesting changes on a Task"}, {"oid": "33a88529954a490d2a042a34319cbf394ee15e9d", "committedDate": "2022-08-18 00:02:18 +0300", "message": "TSK-1864: Reorder methods in TaskService"}, {"oid": "b9b49f47a13e748be20bf73ed605f0dfde7fcf70", "committedDate": "2022-10-20 14:20:24 +0200", "message": "TSK-1965: create endpoints for all state transitions (#2024)"}, {"oid": "20d389a7d524c156b063dfc91589bb22bebea0d7", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-1992 remove unnecessary ParentExceptions"}, {"oid": "d21eb47ffea4c2c9fff8f1d3435b77b805d03508", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-2012: renamed Mismatched_Exceptions to NotAuthorizedExceptions"}, {"oid": "37280cc73b83e2d39ab4afddd40256719d64c50c", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-2013 selectAndClaim TasK return Optional and does not throw Exception if Task is notFound"}, {"oid": "55d939ca7b7720ab12f488ed8fc2a631ecc6f05c", "committedDate": "2023-03-13 19:02:53 +0100", "message": "format entire codebase with new google-java-format version"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1MjU4Ng==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398652586", "body": "Terminates a task.\r\nTermination is a administrative action to complete a task. This is typically done by an administration to correct any technical issue. ", "bodyText": "Terminates a task.\nTermination is a administrative action to complete a task. This is typically done by an administration to correct any technical issue.", "bodyHTML": "<p dir=\"auto\">Terminates a task.<br>\nTermination is a administrative action to complete a task. This is typically done by an administration to correct any technical issue.</p>", "author": "holgerhagen", "createdAt": "2020-03-26T15:14:16Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java", "diffHunk": "@@ -490,4 +490,28 @@ TaskComment getTaskComment(String taskCommentId)\n    */\n   BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n       Instant planned, List<String> taskIds);\n+\n+  /**\n+   * Cancels a task.\n+   *\n+   * @param taskId the id of the task to cancel.\n+   * @return the updated task.\n+   * @throws TaskNotFoundException if the Task with Id TaskId is not found\n+   * @throws InvalidStateException if the task is not in state READY or CLAIMED\n+   * @throws NotAuthorizedException if the current user is not authorized to see the task\n+   */\n+  Task cancelTask(String taskId)\n+      throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n+\n+  /**\n+   * Terminates a task.", "originalCommit": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODcxNjA1NA==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398716054", "bodyText": "I added the description", "author": "BerndBreier", "createdAt": "2020-03-26T16:33:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1MjU4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "4c65a6087e83b85e44118a754cf749a23cac5250", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 15b67f6fe..a07c9a1cc 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -504,7 +505,8 @@ public interface TaskService {\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n \n   /**\n-   * Terminates a task.\n+   * Terminates a task. Termination is a administrative action to complete a task. This is typically\n+   * done by an administration to correct any technical issue.\n    *\n    * @param taskId the id of the task to cancel.\n    * @return the updated task.\n", "next_change": null}]}, "revised_code_in_main": {"commit": "6bd6bd48386155644df0463edf8aeda473bd1a56", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 15b67f6fe..a07c9a1cc 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -504,7 +505,8 @@ public interface TaskService {\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n \n   /**\n-   * Terminates a task.\n+   * Terminates a task. Termination is a administrative action to complete a task. This is typically\n+   * done by an administration to correct any technical issue.\n    *\n    * @param taskId the id of the task to cancel.\n    * @return the updated task.\n", "next_change": {"commit": "3b13b9a95e4d7d1cf172f22fa0f2679ff1c5f79b", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex a07c9a1cc..7d96879c1 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -468,52 +369,4 @@ public interface TaskService {\n    */\n   BulkOperationResults<String, TaskanaException> setCallbackStateForTasks(\n       List<String> externalIds, CallbackState state);\n-\n-  /**\n-   * Sets the owner on a list of tasks. The owner will only be set on tasks that are in state READY.\n-   *\n-   * @param owner the new owner of the tasks\n-   * @param taskIds the IDs of the tasks on which the owner is to be set.\n-   * @return the result of the operations with Id and Exception for each failed task update.\n-   */\n-  BulkOperationResults<String, TaskanaException> setOwnerOfTasks(\n-      String owner, List<String> taskIds);\n-\n-  /**\n-   * Sets the planned property on a list of tasks. Only tasks in state READY and CLAIMED will be\n-   * affected by this method. On each task, the corresponding due date is set according to the\n-   * shortest service level in the classifications of the task and the task's attachments.\n-   *\n-   * @param planned the new 'PLANNED\" property of the tasks\n-   * @param taskIds the IDs of the tasks on which the new planned property is to be set.\n-   * @return the result of the operations with Id and Exception for each failed task update.\n-   */\n-  BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n-      Instant planned, List<String> taskIds);\n-\n-  /**\n-   * Cancels a task. Cancellation means a task is obsolete from a business perspective an does not\n-   * need to be completed anymore.\n-   *\n-   * @param taskId the id of the task to cancel.\n-   * @return the updated task.\n-   * @throws TaskNotFoundException if the Task with Id TaskId is not found\n-   * @throws InvalidStateException if the task is not in state READY or CLAIMED\n-   * @throws NotAuthorizedException if the current user is not authorized to see the task\n-   */\n-  Task cancelTask(String taskId)\n-      throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n-\n-  /**\n-   * Terminates a task. Termination is a administrative action to complete a task. This is typically\n-   * done by an administration to correct any technical issue.\n-   *\n-   * @param taskId the id of the task to cancel.\n-   * @return the updated task.\n-   * @throws TaskNotFoundException if the Task with Id TaskId is not found\n-   * @throws InvalidStateException if the task is not in state READY or CLAIMED\n-   * @throws NotAuthorizedException if the current user is not authorized to see the task\n-   */\n-  Task terminateTask(String taskId)\n-      throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n }\n", "next_change": {"commit": "20bd0922dbc332efcf4e94a0d487b077c95c5a85", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 7d96879c1..ae908e0c9 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -369,4 +375,14 @@ public interface TaskService {\n    */\n   BulkOperationResults<String, TaskanaException> setCallbackStateForTasks(\n       List<String> externalIds, CallbackState state);\n+\n+  /**\n+   * Sets the owner on a list of tasks. The owner will only be set on tasks that are in state READY.\n+   *\n+   * @param owner the new owner of the tasks\n+   * @param taskIds the IDs of the tasks on which the owner is to be set.\n+   * @return the result of the operations with Id and Exception for each failed task deletion.\n+   */\n+  BulkOperationResults<String, TaskanaException> setOwnerOfTasks(\n+      String owner, List<String> taskIds);\n }\n", "next_change": {"commit": "02a6df6f73622e86684c6c30d8f320c84078b237", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex ae908e0c9..8640a8b26 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -381,8 +382,20 @@ public interface TaskService {\n    *\n    * @param owner the new owner of the tasks\n    * @param taskIds the IDs of the tasks on which the owner is to be set.\n-   * @return the result of the operations with Id and Exception for each failed task deletion.\n+   * @return the result of the operations with Id and Exception for each failed task update.\n    */\n   BulkOperationResults<String, TaskanaException> setOwnerOfTasks(\n       String owner, List<String> taskIds);\n+\n+  /**\n+   * Sets the planned property on a list of tasks. Only tasks in state READY and CLAIMED will be\n+   * affected by this method. On each task, the corresponding due date is set according to the due\n+   * dates in the classification() of the task and the task's attachments.\n+   *\n+   * @param planned   the new 'PLANNED\" property of the tasks\n+   * @param taskIds the IDs of the tasks on which the new planned property is to be set.\n+   * @return the result of the operations with Id and Exception for each failed task update.\n+   */\n+  BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n+      Instant planned, List<String> taskIds);\n }\n", "next_change": {"commit": "3b7da72d24beb1e0f6d528f575b1ae7029f10e7f", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 8640a8b26..7951634cb 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -392,7 +467,7 @@ public interface TaskService {\n    * affected by this method. On each task, the corresponding due date is set according to the due\n    * dates in the classification() of the task and the task's attachments.\n    *\n-   * @param planned   the new 'PLANNED\" property of the tasks\n+   * @param planned the new 'PLANNED\" property of the tasks\n    * @param taskIds the IDs of the tasks on which the new planned property is to be set.\n    * @return the result of the operations with Id and Exception for each failed task update.\n    */\n", "next_change": {"commit": "7deb9254113278ccf5872283c2abd202c3cf7af0", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 7951634cb..73e0e0ce4 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -464,8 +479,8 @@ public interface TaskService {\n \n   /**\n    * Sets the planned property on a list of tasks. Only tasks in state READY and CLAIMED will be\n-   * affected by this method. On each task, the corresponding due date is set according to the due\n-   * dates in the classification() of the task and the task's attachments.\n+   * affected by this method. On each task, the corresponding due date is set according to the\n+   * shortest service level in the classifications of the task and the task's attachments.\n    *\n    * @param planned the new 'PLANNED\" property of the tasks\n    * @param taskIds the IDs of the tasks on which the new planned property is to be set.\n", "next_change": {"commit": "2ce7f86456f99d522e001080e9504ae4cd6a80f4", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 73e0e0ce4..15b67f6fe 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -488,4 +490,28 @@ public interface TaskService {\n    */\n   BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n       Instant planned, List<String> taskIds);\n+\n+  /**\n+   * Cancels a task.\n+   *\n+   * @param taskId the id of the task to cancel.\n+   * @return the updated task.\n+   * @throws TaskNotFoundException if the Task with Id TaskId is not found\n+   * @throws InvalidStateException if the task is not in state READY or CLAIMED\n+   * @throws NotAuthorizedException if the current user is not authorized to see the task\n+   */\n+  Task cancelTask(String taskId)\n+      throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n+\n+  /**\n+   * Terminates a task.\n+   *\n+   * @param taskId the id of the task to cancel.\n+   * @return the updated task.\n+   * @throws TaskNotFoundException if the Task with Id TaskId is not found\n+   * @throws InvalidStateException if the task is not in state READY or CLAIMED\n+   * @throws NotAuthorizedException if the current user is not authorized to see the task\n+   */\n+  Task terminateTask(String taskId)\n+      throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n }\n", "next_change": {"commit": "b4e1f9bc315eb701d0dec0e34c38651672239566", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 15b67f6fe..48bac1ed4 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -21,496 +24,695 @@ import pro.taskana.task.api.models.Attachment;\n import pro.taskana.task.api.models.ObjectReference;\n import pro.taskana.task.api.models.Task;\n import pro.taskana.task.api.models.TaskComment;\n+import pro.taskana.workbasket.api.WorkbasketPermission;\n import pro.taskana.workbasket.api.exceptions.WorkbasketNotFoundException;\n+import pro.taskana.workbasket.api.models.Workbasket;\n \n /** The Task Service manages all operations on tasks. */\n public interface TaskService {\n \n   /**\n-   * Claim an existing task for the current user.\n+   * Claim an existing {@linkplain Task} for the current user.\n    *\n-   * @param taskId the id of the task to be claimed\n-   * @return claimed Task\n-   * @throws TaskNotFoundException if the task with taskId was not found\n-   * @throws InvalidStateException if the state of the task with taskId is not READY\n-   * @throws InvalidOwnerException if the task with taskId is claimed by some else\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to be claimed\n+   * @return claimed {@linkplain Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} with taskId was not found\n+   * @throws InvalidStateException if the {@linkplain Task#getState() state} of the {@linkplain\n+   *     Task} with taskId is not {@linkplain TaskState#READY READY}\n+   * @throws InvalidOwnerException if the {@linkplain Task} with taskId is claimed by some else\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task claim(String taskId)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException;\n \n   /**\n-   * Claim an existing task for the current user even if it is already claimed by someone else.\n+   * Claim an existing {@linkplain Task} for the current user even if it is already claimed by\n+   * someone else.\n    *\n-   * @param taskId the id of the task to be claimed\n-   * @return claimed Task\n-   * @throws TaskNotFoundException if the task with taskId was not found\n-   * @throws InvalidStateException if the state of the task with taskId is not READY\n-   * @throws InvalidOwnerException if the task with taskId is claimed by someone else\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to be claimed\n+   * @return claimed {@linkplain Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} with taskId was not found\n+   * @throws InvalidStateException if the {@linkplain Task#getState() state} of the {@linkplain\n+   *     Task} with taskId is not READY\n+   * @throws InvalidOwnerException if the {@linkplain Task} with taskId is claimed by someone else\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task forceClaim(String taskId)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException;\n \n   /**\n-   * Cancel the claim of an existing task if it was claimed by the current user before.\n+   * Cancel the claim of an existing {@linkplain Task} if it was claimed by the current user before.\n    *\n-   * @param taskId id of the task which should be unclaimed.\n+   * @param taskId {@linkplain Task#getId() id} of the task which should be unclaimed.\n    * @return updated unclaimed task\n-   * @throws TaskNotFoundException if the task can\u00b4t be found or does not exist\n-   * @throws InvalidStateException when the task is already completed.\n-   * @throws InvalidOwnerException when the task is claimed by another user.\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @throws TaskNotFoundException if the {@linkplain Task} can't be found or does not exist\n+   * @throws InvalidStateException if the {@linkplain Task} is already in an end {@linkplain\n+   *     Task#getState() state}.\n+   * @throws InvalidOwnerException if the {@linkplain Task} is claimed by another user.\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the task is in\n    */\n   Task cancelClaim(String taskId)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException;\n \n   /**\n-   * Cancel the claim of an existing task even if it was claimed by another user.\n+   * Cancel the claim of an existing {@linkplain Task} even if it was claimed by another user.\n    *\n-   * @param taskId id of the task which should be unclaimed.\n-   * @return updated unclaimed task\n-   * @throws TaskNotFoundException if the task can\u00b4t be found or does not exist\n-   * @throws InvalidStateException when the task is already completed.\n-   * @throws InvalidOwnerException when forceCancel is false and the task is claimed by another\n-   *     user.\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @param taskId id of the {@linkplain Task} which should be unclaimed.\n+   * @return updated unclaimed {@linkplain Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} can't be found or does not exist\n+   * @throws InvalidStateException if the {@linkplain Task} is already in an end {@linkplain\n+   *     Task#getState() state}\n+   * @throws InvalidOwnerException if forceCancel is false and the {@linkplain Task} is claimed by\n+   *     another user.\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task forceCancelClaim(String taskId)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException;\n \n   /**\n-   * Complete a claimed Task as owner/admin and update State and Timestamps. If task is already\n-   * completed, the task is returned as itself.\n+   * Complete a claimed {@linkplain Task} as owner/admin and update {@linkplain Task#getState()\n+   * state} and Timestamps. If {@linkplain Task} is already completed, the {@linkplain Task} is\n+   * returned as itself.\n    *\n-   * @param taskId - Id of the Task which should be completed.\n-   * @return Task - updated task after completion.\n-   * @throws InvalidStateException when Task wasn\u00b4t claimed before.\n-   * @throws TaskNotFoundException if the given Task can\u00b4t be found in DB.\n+   * @param taskId - {@linkplain Task#getId() id} of the {@linkplain Task} which should be\n+   *     completed.\n+   * @return Task - updated {@linkplain Task} after completion.\n+   * @throws InvalidStateException if {@linkplain Task} wasn't claimed before.\n+   * @throws TaskNotFoundException if the given {@linkplain Task} can't be found in DB.\n    * @throws InvalidOwnerException if current user is not the task-owner or administrator.\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task completeTask(String taskId)\n       throws TaskNotFoundException, InvalidOwnerException, InvalidStateException,\n           NotAuthorizedException;\n \n   /**\n-   * Complete a Task and update State and Timestamps in every case if the Task exists. If task is\n-   * already completed, the task is returned as itself.\n+   * Completes a {@linkplain Task} and updates {@linkplain Task#getState() state} and Timestamps in\n+   * every case if the {@linkplain Task} exists. If {@linkplain Task} is already completed, the\n+   * {@linkplain Task} is returned as itself.\n    *\n-   * @param taskId - Id of the Task which should be completed.\n-   * @return Task - updated task after completion.\n-   * @throws InvalidStateException when Task wasn\u00b4t claimed before.\n-   * @throws TaskNotFoundException if the given Task can\u00b4t be found in DB.\n+   * @param taskId - {@linkplain Task#getId() id} of the {@linkplain Task} which should be\n+   *     completed.\n+   * @return Task - updated {@linkplain Task} after completion.\n+   * @throws InvalidStateException if {@linkplain Task} wasn't claimed before.\n+   * @throws TaskNotFoundException if the given {@linkplain Task} can't be found in DB.\n    * @throws InvalidOwnerException if current user is not the task-owner or administrator.\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task forceCompleteTask(String taskId)\n       throws TaskNotFoundException, InvalidOwnerException, InvalidStateException,\n           NotAuthorizedException;\n \n   /**\n-   * Persists a not persisted Task which does not exist already.\n-   *\n-   * @param taskToCreate the transient task object to be persisted\n-   * @return the created and persisted task\n-   * @throws TaskAlreadyExistException when the Task does already exist.\n-   * @throws NotAuthorizedException thrown if the current user is not authorized to create that task\n-   * @throws WorkbasketNotFoundException thrown if the work basket referenced by the task is not\n-   *     found\n-   * @throws ClassificationNotFoundException thrown if the {@link Classification} referenced by the\n-   *     task is not found\n+   * Inserts a not existing {@linkplain Task}. <br>\n+   * The default values of the created {@linkplain Task} are:\n+   *\n+   * <ul>\n+   *   <li><b>{@linkplain Task#getId() id}</b> - generated by {@linkplain IdGenerator}\n+   *   <li><b>{@linkplain Task#getExternalId() externalId}</b> - generated by IdGenerator\n+   *   <li><b>{@linkplain Task#getBusinessProcessId() businessProcessId}</b> - generated by\n+   *       IdGenerator\n+   *   <li><b>{@linkplain Task#getName() name}</b> - name of its Classification\n+   *   <li><b>{@linkplain Task#getDescription() description}</b> - description of its Classification\n+   *   <li><b>{@linkplain Task#getCreator() creator}</b> - id of current user\n+   *   <li><b>{@linkplain Task#getState() state}</b> - 'READY'\n+   *   <li><b>{@linkplain Task#isRead() isRead}</b> - {@code false}\n+   *   <li><b>{@linkplain Task#isTransferred() isTransferred}</b> - {@code false}\n+   * </ul>\n+   *\n+   * @param taskToCreate the transient {@linkplain Task} object to be inserted\n+   * @return the created and inserted {@linkplain Task}\n+   * @throws TaskAlreadyExistException if the {@linkplain Task} does already exist.\n+   * @throws NotAuthorizedException thrown if the current user is not authorized to create that\n+   *     {@linkplain Task}\n+   * @throws WorkbasketNotFoundException thrown if the workbasket referenced by the {@linkplain\n+   *     Task} is not found\n+   * @throws ClassificationNotFoundException thrown if the Classification referenced by the\n+   *     {@linkplain Task} is not found\n    * @throws InvalidArgumentException thrown if the primary ObjectReference is invalid\n+   * @throws AttachmentPersistenceException if an Attachment with ID will be added multiple times\n+   *     without using the task-methods\n+   * @throws ObjectReferencePersistenceException if an ObjectReference with ID will be added\n+   *     multiple times without using the task-methods\n    */\n   Task createTask(Task taskToCreate)\n       throws NotAuthorizedException, WorkbasketNotFoundException, ClassificationNotFoundException,\n-          TaskAlreadyExistException, InvalidArgumentException;\n+          TaskAlreadyExistException, InvalidArgumentException, AttachmentPersistenceException,\n+          ObjectReferencePersistenceException;\n \n   /**\n-   * Get the details of a task by Id without checking permissions.\n+   * Gets the details of a {@linkplain Task} by {@linkplain Task#getId() id} without checking\n+   * permissions.\n    *\n-   * @param taskId the id of the task\n-   * @return the Task\n-   * @throws TaskNotFoundException thrown of the {@link Task} with taskId is not found\n-   * @throws NotAuthorizedException if the current user has no READ permission for the workbasket\n-   *     the task is in.\n+   * @param taskId the {@linkplain Task#getId()} of the {@linkplain Task}\n+   * @return the {@linkplain Task}\n+   * @throws TaskNotFoundException thrown of the {@linkplain Task} with taskId is not found\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in.\n    */\n   Task getTask(String taskId) throws TaskNotFoundException, NotAuthorizedException;\n \n   /**\n-   * Transfer a task to another work basket. The transfer sets the transferred flag and resets the\n-   * read flag.\n+   * Transfers a {@linkplain Task} to another {@linkplain Workbasket} while always setting the\n+   * {@linkplain Task#isTransferred transfer} flag.\n    *\n-   * @param taskId The id of the {@link Task} to be transferred\n-   * @param destinationWorkbasketId The Id of the target work basket\n-   * @return the transferred task\n-   * @throws TaskNotFoundException Thrown if the {@link Task} with taskId was not found.\n-   * @throws WorkbasketNotFoundException Thrown if the target work basket was not found.\n+   * @see #transfer(String, String, boolean)\n+   */\n+  @SuppressWarnings(\"checkstyle:JavadocMethod\")\n+  default Task transfer(String taskId, String destinationWorkbasketId)\n+      throws TaskNotFoundException, WorkbasketNotFoundException, NotAuthorizedException,\n+          InvalidStateException {\n+    return transfer(taskId, destinationWorkbasketId, true);\n+  }\n+\n+  /**\n+   * Transfers a {@linkplain Task} to another {@linkplain Workbasket}.\n+   *\n+   * <p>The transfer resets the {@linkplain Task#isRead() read} flag and sets the {@linkplain\n+   * Task#isTransferred() transfer} flag if {@code setTransferFlag} is {@code true}.\n+   *\n+   * @param taskId the {@linkplain Task#getId()} of the {@linkplain Task} which should be\n+   *     transferred\n+   * @param destinationWorkbasketId the {@linkplain Workbasket#getId() id} of the target {@linkplain\n+   *     Workbasket}\n+   * @param setTransferFlag the control about whether to set the {@linkplain Task#isTransferred()}\n+   *     flag or not\n+   * @return the transferred {@linkplain Task}\n+   * @throws TaskNotFoundException Thrown if the {@linkplain Task} with taskId was not found.\n+   * @throws WorkbasketNotFoundException Thrown if the target {@linkplain Workbasket} was not found.\n    * @throws NotAuthorizedException Thrown if the current user is not authorized to transfer this\n-   *     {@link Task} to the target work basket\n-   * @throws InvalidStateException Thrown if the task is in a state which does not allow\n-   *     transferring\n+   *     {@linkplain Task} to the target {@linkplain Workbasket}\n+   * @throws InvalidStateException Thrown if the {@linkplain Task} is in a {@linkplain\n+   *     Task#getState() state} which does not allow transferring\n    */\n-  Task transfer(String taskId, String destinationWorkbasketId)\n+  Task transfer(String taskId, String destinationWorkbasketId, boolean setTransferFlag)\n       throws TaskNotFoundException, WorkbasketNotFoundException, NotAuthorizedException,\n           InvalidStateException;\n \n   /**\n-   * Transfer a task to another work basket. The transfer sets the transferred flag and resets the\n-   * read flag.\n+   * Transfers a {@linkplain Task} to another {@linkplain Workbasket} while always setting the\n+   * {@linkplain Task#isTransferred transfer} flag.\n+   *\n+   * @see #transfer(String, String, String, boolean)\n+   */\n+  @SuppressWarnings(\"checkstyle:JavadocMethod\")\n+  default Task transfer(String taskId, String workbasketKey, String domain)\n+      throws TaskNotFoundException, WorkbasketNotFoundException, NotAuthorizedException,\n+          InvalidStateException {\n+    return transfer(taskId, workbasketKey, domain, true);\n+  }\n+\n+  /**\n+   * Transfers a {@linkplain Task} to another {@linkplain Workbasket}.\n    *\n-   * @param taskId The id of the {@link Task} to be transferred\n-   * @param workbasketKey The key of the target work basket\n-   * @param domain The domain of the target work basket\n-   * @return the transferred task\n-   * @throws TaskNotFoundException Thrown if the {@link Task} with taskId was not found.\n-   * @throws WorkbasketNotFoundException Thrown if the target work basket was not found.\n+   * <p>The transfer resets the {@linkplain Task#isRead() read} flag and sets the transfer flag if\n+   * {@code setTransferFlag} is {@code true}.\n+   *\n+   * @param taskId the id of the {@linkplain Task} which should be transferred\n+   * @param workbasketKey the key of the target {@linkplain Workbasket}\n+   * @param domain the domain of the target {@linkplain Workbasket}\n+   * @param setTransferFlag the control about whether to set the {@linkplain Task#isTransferred()}\n+   *     flag or not\n+   * @return the transferred {@linkplain Task}\n+   * @throws TaskNotFoundException Thrown if the {@linkplain Task} with taskId was not found.\n+   * @throws WorkbasketNotFoundException Thrown if the target {@linkplain Workbasket} was not found.\n    * @throws NotAuthorizedException Thrown if the current user is not authorized to transfer this\n-   *     {@link Task} to the target work basket\n-   * @throws InvalidStateException Thrown if the task is in a state which does not allow\n-   *     transferring\n+   *     {@linkplain Task} to the target {@linkplain Workbasket}\n+   * @throws InvalidStateException Thrown if the {@linkplain Task} is in a {@linkplain\n+   *     Task#getState()} which does not allow transferring\n    */\n-  Task transfer(String taskId, String workbasketKey, String domain)\n+  Task transfer(String taskId, String workbasketKey, String domain, boolean setTransferFlag)\n       throws TaskNotFoundException, WorkbasketNotFoundException, NotAuthorizedException,\n           InvalidStateException;\n \n   /**\n-   * Marks a task as read.\n+   * Marks a {@linkplain Task} as read.\n    *\n-   * @param taskId the id of the task to be updated\n-   * @param isRead the new status of the read flag.\n-   * @return the updated Task\n-   * @throws TaskNotFoundException Thrown if the {@link Task} with taskId was not found\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to be updated\n+   * @param isRead the new status of the {@linkplain Task#isRead() read} flag\n+   * @return the updated {@linkplain Task}\n+   * @throws TaskNotFoundException Thrown if the {@linkplain Task} with taskId was not found\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task setTaskRead(String taskId, boolean isRead)\n       throws TaskNotFoundException, NotAuthorizedException;\n \n   /**\n-   * This method provides a query builder for quering the database.\n+   * Provides a query builder for querying the database.\n    *\n-   * @return a {@link TaskQuery}\n+   * @return a {@linkplain TaskQuery}\n    */\n   TaskQuery createTaskQuery();\n \n   /**\n-   * Returns a not persisted instance of {@link Task}. The returned task has no workbasket Id set.\n-   * When createTask() is invoked for this task, TaskService will call the TaskRouting SPI to\n-   * determine a workbasket for the task. If the TaskRouting API is not active, e.g. because no\n-   * TaskRouter is registered, or the TaskRouter(s) don't find a workbasket, the task will not be\n-   * persisted.\n+   * This method provides a query builder for querying the database.\n+   *\n+   * @return a {@linkplain TaskCommentQuery}\n+   */\n+  TaskCommentQuery createTaskCommentQuery();\n+\n+  /**\n+   * Returns a not inserted instance of {@linkplain Task}. The returned {@linkplain Task} has no\n+   * {@linkplain Task#getWorkbasketSummary() w} set. When createTask() is invoked for this task,\n+   * TaskService will call the TaskRouting SPI to determine a workbasket for the task. If the\n+   * TaskRouting API is not active, e.g. because no TaskRouter is registered, or the TaskRouter(s)\n+   * don't find a workbasket, the task will not be inserted.\n    *\n    * @return an empty new Task\n    */\n   Task newTask();\n \n   /**\n-   * Returns a not persisted instance of {@link Task}.\n+   * Returns a not inserted instance of {@linkplain Task}.\n    *\n-   * @param workbasketId the id of the workbasket to which the task belongs\n-   * @return an empty new Task\n+   * @param workbasketId the {@linkplain Workbasket#getId() id} of the {@linkplain Workbasket} to\n+   *     which the task belongs\n+   * @return an empty new {@linkplain Task}\n    */\n   Task newTask(String workbasketId);\n \n   /**\n-   * Returns a not persisted instance of {@link Task}.\n+   * Returns a not inserted instance of {@linkplain Task}.\n    *\n-   * @param workbasketKey the key of the workbasket to which the task belongs\n-   * @param domain the domain of the workbasket to which the task belongs\n-   * @return an empty new Task\n+   * @param workbasketKey the {@linkplain Workbasket#getKey() key} of the {@linkplain Workbasket} to\n+   *     which the {@linkplain Task} belongs\n+   * @param domain the {@linkplain Workbasket#getDomain() domain} of the {@linkplain Workbasket} to\n+   *     which the {@linkplain Task} belongs\n+   * @return an empty new {@linkplain Task}\n    */\n   Task newTask(String workbasketKey, String domain);\n \n   /**\n-   * Returns a not persisted instance of {@link TaskComment}.\n+   * Returns a not inserted instance of {@linkplain TaskComment}.\n    *\n-   * @param taskId The id of the task to which the task comment belongs\n-   * @return an empty new TaskComment\n+   * @param taskId The {@linkplain Task#getId() id} of the {@linkplain Task} to which the task\n+   *     comment belongs\n+   * @return an empty new {@linkplain TaskComment}\n    */\n   TaskComment newTaskComment(String taskId);\n \n   /**\n-   * Returns a not persisted instance of {@link Attachment}.\n+   * Returns a not inserted instance of {@linkplain Attachment}.\n    *\n-   * @return an empty new Attachment\n+   * @return an empty new {@linkplain Attachment}\n    */\n   Attachment newAttachment();\n \n   /**\n-   * Update a task.\n+   * Returns a not inserted instance of {@linkplain ObjectReference}.\n    *\n-   * @param task the task to be updated in the database\n-   * @return the updated task\n-   * @throws InvalidArgumentException if the task to be updated contains invalid properties like\n-   *     e.g. invalid object references\n-   * @throws TaskNotFoundException if the id of the task is not found in the database\n-   * @throws ConcurrencyException if the task has already been updated by another user\n-   * @throws ClassificationNotFoundException if the updated task refers to a classification that\n-   *     cannot be found\n-   * @throws NotAuthorizedException if the current user is not authorized to update the task\n-   * @throws AttachmentPersistenceException if an Attachment with ID will be added multiple times\n-   *     without using the task-methods\n-   * @throws InvalidStateException if an attempt is made to change the owner of the task and the\n-   *     task is not in state READY .\n+   * @return an empty new {@linkplain ObjectReference}\n+   */\n+  ObjectReference newObjectReference();\n+\n+  ObjectReference newObjectReference(\n+      String company, String system, String systemInstance, String type, String value);\n+\n+  /**\n+   * Update a {@linkplain Task}.\n+   *\n+   * @param task the {@linkplain Task} to be updated in the database\n+   * @return the updated {@linkplain Task}\n+   * @throws InvalidArgumentException if the {@linkplain Task} to be updated contains invalid\n+   *     properties like e.g. invalid {@linkplain ObjectReference}s\n+   * @throws TaskNotFoundException if the id of the {@linkplain Task} is not found in the database\n+   * @throws ConcurrencyException if the {@linkplain Task} has been updated by another user in the\n+   *     meantime; that's the case if the given modified timestamp differs from the one in the\n+   *     database\n+   * @throws ClassificationNotFoundException if the updated {@linkplain Task} refers to a {@link\n+   *     Classification} that cannot be found\n+   * @throws NotAuthorizedException if the current user is not authorized to update the {@linkplain\n+   *     Task}\n+   * @throws AttachmentPersistenceException if an {@linkplain Attachment} with ID will be added\n+   *     multiple times without using the Task-methods\n+   * @throws ObjectReferencePersistenceException if an {@linkplain ObjectReference} with ID will be\n+   *     added multiple times without using the Task-methods\n+   * @throws InvalidStateException if an attempt is made to change the owner of the {@linkplain\n+   *     Task} that state isn't READY.\n    */\n   Task updateTask(Task task)\n       throws InvalidArgumentException, TaskNotFoundException, ConcurrencyException,\n           ClassificationNotFoundException, NotAuthorizedException, AttachmentPersistenceException,\n-          InvalidStateException;\n+          ObjectReferencePersistenceException, InvalidStateException;\n \n   /**\n-   * Transfers a list of tasks to an other workbasket. Exceptions will be thrown if the caller got\n-   * no permissions on the target or it doesn\u00b4t exist. Other Exceptions will be stored and returned\n-   * in the end.\n+   * Transfers a list of {@linkplain Task Tasks} to another {@linkplain Workbasket} while always\n+   * setting the {@linkplain Task#isTransferred transfer} flag.\n    *\n-   * @param destinationWorkbasketId target workbasket id\n-   * @param taskIds source task which will be moved\n-   * @return Bulkresult with ID and Error in it for failed transactions.\n-   * @throws NotAuthorizedException if the caller hasn\u00b4t permissions on tarket WB.\n-   * @throws InvalidArgumentException if the method paramesters are EMPTY or NULL.\n-   * @throws WorkbasketNotFoundException if the target WB can\u00b4t be found.\n+   * @see #transferTasks(String, List, boolean)\n    */\n-  BulkOperationResults<String, TaskanaException> transferTasks(\n+  @SuppressWarnings(\"checkstyle:JavadocMethod\")\n+  default BulkOperationResults<String, TaskanaException> transferTasks(\n       String destinationWorkbasketId, List<String> taskIds)\n+      throws NotAuthorizedException, InvalidArgumentException, WorkbasketNotFoundException {\n+    return transferTasks(destinationWorkbasketId, taskIds, true);\n+  }\n+\n+  /**\n+   * Transfers a list of {@linkplain Task Tasks} to another {@linkplain Workbasket}.\n+   *\n+   * <p>The transfer resets the {@linkplain Task#isRead() read flag} and sets the {@linkplain\n+   * Task#isTransferred() transfer flag} if {@code setTransferFlag} is {@code true}. Exceptions will\n+   * be thrown if the caller got no {@linkplain WorkbasketPermission} on the target or if the target\n+   * {@linkplain Workbasket} does not exist. Other Exceptions will be stored and returned in the\n+   * end.\n+   *\n+   * @param destinationWorkbasketId {@linkplain Workbasket#getId() id} of the target {@linkplain\n+   *     Workbasket}\n+   * @param taskIds list of source {@linkplain Task Tasks} which will be moved\n+   * @param setTransferFlag the control about whether to set the {@linkplain Task#isTransferred()}\n+   *     flag or not\n+   * @return Bulkresult with {@linkplain Task#getId() ids} and Error in it for failed transactions\n+   * @throws NotAuthorizedException if the caller has no permissions on target {@linkplain\n+   *     Workbasket}\n+   * @throws InvalidArgumentException if the method parameters are EMPTY or NULL\n+   * @throws WorkbasketNotFoundException if the target {@linkplain Workbasket} can not be found\n+   */\n+  BulkOperationResults<String, TaskanaException> transferTasks(\n+      String destinationWorkbasketId, List<String> taskIds, boolean setTransferFlag)\n       throws NotAuthorizedException, InvalidArgumentException, WorkbasketNotFoundException;\n \n   /**\n-   * Transfers a list of tasks to an other workbasket. Exceptions will be thrown if the caller got\n-   * no permissions on the target or it doesn\u00b4t exist. Other Exceptions will be stored and returned\n+   * Transfers a list of {@linkplain Task Tasks} to another {@linkplain Workbasket} while always\n+   * setting the {@linkplain Task#isTransferred} flag.\n+   *\n+   * @see #transferTasks(String, String, List, boolean)\n+   */\n+  @SuppressWarnings(\"checkstyle:JavadocMethod\")\n+  default BulkOperationResults<String, TaskanaException> transferTasks(\n+      String destinationWorkbasketKey, String destinationWorkbasketDomain, List<String> taskIds)\n+      throws NotAuthorizedException, InvalidArgumentException, WorkbasketNotFoundException {\n+    return transferTasks(destinationWorkbasketKey, destinationWorkbasketDomain, taskIds, true);\n+  }\n+\n+  /**\n+   * Transfers a list of {@linkplain Task Tasks} to another {@linkplain Workbasket}.\n+   *\n+   * <p>The transfer resets the {@linkplain Task#isRead() read flag} and sets the {@linkplain\n+   * Task#isTransferred() transfer flag} if {@code setTransferFlag} is {@code true}. Exceptions will\n+   * be thrown if the caller got no {@linkplain WorkbasketPermission Permission} on the target\n+   * {@linkplain Workbasket} or if it does not exist. Other Exceptions will be stored and returned\n    * in the end.\n    *\n-   * @param destinationWorkbasketKey target workbasket key\n-   * @param destinationWorkbasketDomain target workbasket domain\n-   * @param taskIds source task which will be moved\n-   * @return Bulkresult with ID and Error in it for failed transactions.\n-   * @throws NotAuthorizedException if the caller hasn\u00b4t permissions on tarket WB.\n-   * @throws InvalidArgumentException if the method paramesters are EMPTY or NULL.\n-   * @throws WorkbasketNotFoundException if the target WB can\u00b4t be found.\n+   * @param destinationWorkbasketKey target {@linkplain Workbasket#getKey()} Workbasket}\n+   * @param destinationWorkbasketDomain target {@linkplain Workbasket#getDomain() domain}\n+   * @param taskIds List of source {@linkplain Task Tasks} which will be moved\n+   * @param setTransferFlag the control about whether to set the {@linkplain Task#isTransferred()}\n+   *     flag or not\n+   * @return BulkResult with {@linkplain Task#getId() id} and Error in it for failed transactions.\n+   * @throws NotAuthorizedException if the caller has no {@linkplain WorkbasketPermission} on target\n+   *     {@linkplain Workbasket}.\n+   * @throws InvalidArgumentException if the method parameters are EMPTY or NULL.\n+   * @throws WorkbasketNotFoundException if the target {@linkplain Workbasket} can not be found.\n    */\n   BulkOperationResults<String, TaskanaException> transferTasks(\n-      String destinationWorkbasketKey, String destinationWorkbasketDomain, List<String> taskIds)\n+      String destinationWorkbasketKey,\n+      String destinationWorkbasketDomain,\n+      List<String> taskIds,\n+      boolean setTransferFlag)\n       throws NotAuthorizedException, InvalidArgumentException, WorkbasketNotFoundException;\n \n   /**\n-   * Deletes the task with the given Id.\n+   * Deletes the {@linkplain Task} with the given {@linkplain Task#getId() id}.\n    *\n-   * @param taskId The Id of the task to delete.\n-   * @throws TaskNotFoundException If the given Id does not refer to an existing task.\n-   * @throws InvalidStateException If the state of the referenced task is not Completed.\n-   * @throws NotAuthorizedException if the current user is not member of role ADMIN\n+   * @param taskId The {@linkplain Task#getId() id} of the {@linkplain Task} to delete.\n+   * @throws TaskNotFoundException If the given {@linkplain Task#getId() id} does not refer to an\n+   *     existing {@linkplain Task}.\n+   * @throws InvalidStateException If the {@linkplain Task#getState() state} of the referenced\n+   *     {@linkplain Task} is not an end state.\n+   * @throws NotAuthorizedException if the current user is not member of role {@linkplain\n+   *     TaskanaRole#ADMIN}\n    */\n   void deleteTask(String taskId)\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n \n   /**\n-   * Deletes the task with the given Id even if it is not completed.\n+   * Deletes the {@linkplain Task} with the given {@linkplain Task#getId() id} even if it is not\n+   * completed.\n    *\n-   * @param taskId The Id of the task to delete.\n-   * @throws TaskNotFoundException If the given Id does not refer to an existing task.\n-   * @throws InvalidStateException If the state of the referenced task is not Completed and\n-   *     forceDelet is false.\n-   * @throws NotAuthorizedException if the current user is not member of role ADMIN\n+   * @param taskId The {@linkplain Task#getId() id} of the {@linkplain Task} to delete.\n+   * @throws TaskNotFoundException If the given {@linkplain Task#getId() id} does not refer to an\n+   *     existing {@linkplain Task}.\n+   * @throws InvalidStateException If the state of the referenced {@linkplain Task} is not an end\n+   *     state and forceDelete is false.\n+   * @throws NotAuthorizedException if the current user is not member of role {@linkplain\n+   *     TaskanaRole#ADMIN}\n    */\n   void forceDeleteTask(String taskId)\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n \n   /**\n-   * Deletes a list of tasks.\n+   * Selects and claims the first {@linkplain Task} which is returned by the {@linkplain TaskQuery}.\n    *\n-   * @param tasks the ids of the tasks to delete.\n-   * @return the result of the operations with Id and Exception for each failed task deletion.\n+   * @param taskQuery the {@linkplain TaskQuery}.\n+   * @return the {@linkplain Task} that got selected and claimed\n+   * @throws InvalidOwnerException if the {@linkplain Task} is claimed by someone else\n+   * @throws NotAuthorizedException if the current user has no read permission for the Workbasket\n+   *     the {@linkplain Task} is in\n+   */\n+  Task selectAndClaim(TaskQuery taskQuery) throws NotAuthorizedException, InvalidOwnerException;\n+\n+  /**\n+   * Deletes a list of {@linkplain Task Tasks}.\n+   *\n+   * @param tasks the {@linkplain Task#getId() ids} of the tasks to delete.\n+   * @return the result of the operations with each {@linkplain Task#getId() id} and Exception for\n+   *     each failed task deletion.\n    * @throws InvalidArgumentException if the TaskIds parameter is NULL\n+   * @throws NotAuthorizedException if the current user is not member of role ADMIN\n    */\n   BulkOperationResults<String, TaskanaException> deleteTasks(List<String> tasks)\n-      throws InvalidArgumentException;\n+      throws InvalidArgumentException, NotAuthorizedException;\n \n   /**\n-   * Completes a list of tasks.\n+   * Completes a list of {@linkplain Task Tasks}.\n    *\n-   * @param taskIds of the tasks which should be completed.\n-   * @return the result of the operations with Id and Exception for each failed task completion.\n-   * @throws InvalidArgumentException If the taskId parameter is NULL.\n+   * @param taskIds {@linkplain Task#getId() ids} of the {@linkplain Task Tasks} which should be\n+   *     completed\n+   * @return the result of the operations with each {@linkplain Task#getId() id} and Exception for\n+   *     each failed completion\n+   * @throws InvalidArgumentException If the taskIds parameter is NULL\n    */\n   BulkOperationResults<String, TaskanaException> completeTasks(List<String> taskIds)\n       throws InvalidArgumentException;\n \n   /**\n-   * Updates tasks with a matching {@link ObjectReference}.\n+   * Completes each existing {@linkplain Task} in the given List in every case, independent of the\n+   * {@linkplain Task#getOwner() owner} or {@linkplain Task#getState() state} of the {@linkplain\n+   * Task}. If the {@linkplain Task} is already {@linkplain TaskState#COMPLETED completed}, the\n+   * {@linkplain Task} stays unchanged.\n+   *\n+   * @see TaskService#forceCompleteTask\n+   * @param taskIds {@linkplain Task#getId() id} of the {@linkplain Task Tasks} which should be\n+   *     completed\n+   * @return the result of the operations with {@linkplain Task#getId() id} and Exception for each\n+   *     failed completion\n+   * @throws InvalidArgumentException If the taskIds parameter is NULL\n+   */\n+  BulkOperationResults<String, TaskanaException> forceCompleteTasks(List<String> taskIds)\n+      throws InvalidArgumentException;\n+\n+  /**\n+   * Updates specified {@linkplain TaskCustomField TaskCustomFields} of {@linkplain Task Tasks}\n+   * associated with the given {@linkplain ObjectReference}.\n    *\n-   * @param selectionCriteria the {@link ObjectReference} that is used to select the tasks.\n-   * @param customFieldsToUpdate a {@link Map} that contains as key the identification of the custom\n-   *     field and as value the corresponding new value of that custom field. The key for\n-   *     identification of the custom field must be a String with value \"1\", \"2\" ... \"16\" as in the\n-   *     setCustomAttribute or getCustomAttribute method of {@link Task}\n-   * @return a list of the Ids of all modified tasks\n-   * @throws InvalidArgumentException If the customFieldsToUpdate map contains an invalid key or if\n-   *     the selectionCriteria is invalid\n+   * @param selectionCriteria the {@linkplain ObjectReference} that is used to select the tasks\n+   * @param customFieldsToUpdate a Map that contains as key the identification of the {@linkplain\n+   *     TaskCustomField} and as value the corresponding new value of that field\n+   * @return a list of the {@linkplain Task#getId() ids} of all modified {@linkplain Task Tasks}\n+   * @throws InvalidArgumentException if the given selectionCriteria is invalid or the given\n+   *     customFieldsToUpdate are NULL or empty\n    */\n   List<String> updateTasks(\n-      ObjectReference selectionCriteria, Map<String, String> customFieldsToUpdate)\n+      ObjectReference selectionCriteria, Map<TaskCustomField, String> customFieldsToUpdate)\n       throws InvalidArgumentException;\n \n   /**\n-   * Updates tasks with matching taskIds.\n+   * Updates specified {@linkplain TaskCustomField TaskCustomFields} for all given {@linkplain Task\n+   * Tasks}.\n    *\n-   * @param taskIds the taskIds that are used to select the tasks.\n-   * @param customFieldsToUpdate a {@link Map} that contains as key the identification of the custom\n-   *     field and as value the corresponding new value of that custom field. The key for\n-   *     identification of the custom field must be a String with value \"1\", \"2\" ... \"16\" as in the\n-   *     setCustomAttribute or getCustomAttribute method of {@link Task}\n-   * @return a list of the Ids of all modified tasks\n-   * @throws InvalidArgumentException If the customFieldsToUpdate map contains an invalid key or if\n-   *     the selectionCriteria is invalid\n+   * @param taskIds the {@linkplain Task#getId() taskIds} that are used to select the {@linkplain\n+   *     Task Tasks}.\n+   * @param customFieldsToUpdate a Map that contains as key the identification of the {@linkplain\n+   *     TaskCustomField} and as value the corresponding new value of that {@linkplain\n+   *     TaskCustomField}.\n+   * @return a list of the {@linkplain Task#getId() ids} of all modified {@linkplain Task Tasks}\n+   * @throws InvalidArgumentException if the given customFieldsToUpdate are NULL or empty.\n    */\n-  List<String> updateTasks(List<String> taskIds, Map<String, String> customFieldsToUpdate)\n+  List<String> updateTasks(List<String> taskIds, Map<TaskCustomField, String> customFieldsToUpdate)\n       throws InvalidArgumentException;\n \n   /**\n-   * Create a task comment.\n+   * Inserts the specified {@linkplain TaskComment} into the database.\n    *\n-   * @param taskComment the task comment to be created.\n-   * @return the created task comment.\n-   * @throws NotAuthorizedException If the current user has no authorization to create a task\n-   *     comment for the given taskId in the TaskComment or is not authorized to access the task.\n-   * @throws TaskNotFoundException If the given taskId in the TaskComment does not refer to an\n-   *     existing task.\n-   * @throws InvalidArgumentException If the given taskCommentId from the provided task comment is\n-   *     not null or empty\n+   * @param taskComment the {@linkplain TaskComment} to be created\n+   * @return the created {@linkplain TaskComment}\n+   * @throws NotAuthorizedException if the current user has no authorization to create a {@link\n+   *     TaskComment} for the given taskId or is not authorized to access the {@linkplain Task}\n+   * @throws TaskNotFoundException if the given {@linkplain TaskComment#getTaskId() taskId} does not\n+   *     refer to an existing {@linkplain Task}\n+   * @throws InvalidArgumentException if the {@linkplain TaskComment#getId() id} of the provided\n+   *     {@link TaskComment} is not NULL or empty\n    */\n   TaskComment createTaskComment(TaskComment taskComment)\n       throws NotAuthorizedException, TaskNotFoundException, InvalidArgumentException;\n \n   /**\n-   * Update a task comment.\n+   * Updates the specified {@linkplain TaskComment}.\n    *\n-   * @param taskComment the task comment to be updated in the database.\n-   * @return the updated task comment.\n-   * @throws NotAuthorizedException If the current user has no authorization to update a task\n-   *     comment or is not authorized to access the task.\n-   * @throws ConcurrencyException if an attempt is made to update the task comment and another user.\n-   *     updated it already.\n-   * @throws TaskCommentNotFoundException If the given taskCommentId in the TaskComment does not\n-   *     refer to an existing taskComment.\n-   * @throws TaskNotFoundException If the given taskId in the TaskComment does not refer to an\n-   *     existing task.\n-   * @throws InvalidArgumentException If the given taskCommentId from the provided task comment is\n-   *     null or empty\n+   * @param taskComment the {@linkplain TaskComment} to be updated in the database\n+   * @return the updated {@linkplain TaskComment}\n+   * @throws NotAuthorizedException if the current user has no authorization to update the\n+   *     {@linkplain TaskComment} or is not authorized to access the {@linkplain Task}\n+   * @throws ConcurrencyException if an attempt is made to update the {@linkplain TaskComment} and\n+   *     another user updated it already; that's the case if the given {} timestamp differs from the\n+   *     one in the database\n+   * @throws TaskCommentNotFoundException if the {@linkplain TaskComment#getId() is} of the\n+   *     specified {@linkplain TaskComment}does not refer to an existing {@linkplain TaskComment}\n+   * @throws TaskNotFoundException if the {@linkplain TaskComment#getTaskId() taskId} does not refer\n+   *     to an existing {@linkplain Task}\n+   * @throws InvalidArgumentException if the given {@linkplain TaskComment#getId() id} is NULL or\n+   *     empty\n    */\n   TaskComment updateTaskComment(TaskComment taskComment)\n       throws NotAuthorizedException, ConcurrencyException, TaskCommentNotFoundException,\n           TaskNotFoundException, InvalidArgumentException;\n \n   /**\n-   * Deletes the task comment with the given Id.\n+   * Deletes the {@linkplain TaskComment} with the given {@linkplain TaskComment#getId() id}.\n    *\n-   * @param taskCommentId The id of the task comment to delete.\n-   * @throws NotAuthorizedException If the current user has no authorization to delete a task\n+   * @param taskCommentId the {@linkplain TaskComment#getId() id} of the {@linkplain TaskComment} to\n+   *     delete\n+   * @throws NotAuthorizedException if the current user has no authorization to delete a task\n    *     comment or is not authorized to access the task.\n-   * @throws InvalidArgumentException If the taskCommentId is null/empty\n-   * @throws TaskCommentNotFoundException If the given taskCommentId in the TaskComment does not\n+   * @throws InvalidArgumentException if the taskCommentId is NULL or empty\n+   * @throws TaskCommentNotFoundException if the given taskCommentId in the TaskComment does not\n    *     refer to an existing taskComment.\n-   * @throws TaskNotFoundException If the given taskId in the TaskComment does not refer to an\n-   *     existing task.\n-   * @throws InvalidArgumentException If the given taskCommentId is null or empty\n+   * @throws TaskNotFoundException if the {@linkplain TaskComment#getTaskId() taskId} of the\n+   *     TaskComment does not refer to an existing {@linkplain Task}.\n+   * @throws InvalidArgumentException if the given taskCommentId is NULL or empty\n    */\n   void deleteTaskComment(String taskCommentId)\n       throws NotAuthorizedException, TaskCommentNotFoundException, TaskNotFoundException,\n           InvalidArgumentException;\n \n   /**\n-   * Retrieves a task comment for a given taskCommentId.\n+   * Retrieves the {@linkplain TaskComment} with the given {@linkplain TaskComment#getId() id}.\n    *\n-   * @param taskCommentId The id of the task comment which should be retrieved\n-   * @return the task comment identified by taskCommentId\n-   * @throws TaskCommentNotFoundException If the given taskCommentId in the TaskComment does not\n-   *     refer to an existing taskComment.\n-   * @throws NotAuthorizedException If the current user has no authorization to retrieve a\n-   *     taskComment from a certain task or is not authorized to access the task.\n-   * @throws TaskNotFoundException If the given taskId in the TaskComment does not refer to an\n-   *     existing task.\n-   * @throws InvalidArgumentException If the given taskCommentId is null or empty\n+   * @param taskCommentId the {@linkplain TaskComment#getId() id} of the {@linkplain TaskComment}\n+   *     which should be retrieved\n+   * @return the {@linkplain TaskComment} identified by taskCommentId\n+   * @throws TaskCommentNotFoundException if the given taskCommentId does not refer to an existing\n+   *     {@linkplain TaskComment}\n+   * @throws NotAuthorizedException if the current user has no authorization to retrieve a\n+   *     {@linkplain TaskComment} from a certain {@linkplain Task} or is not authorized to access\n+   *     the {@linkplain Task}\n+   * @throws TaskNotFoundException if the {@linkplain TaskComment#getTaskId() taskId} of the\n+   *     TaskComment does not refer to an existing {@linkplain Task}\n+   * @throws InvalidArgumentException if the given taskCommentId is NULL or empty\n    */\n   TaskComment getTaskComment(String taskCommentId)\n       throws TaskCommentNotFoundException, NotAuthorizedException, TaskNotFoundException,\n           InvalidArgumentException;\n \n   /**\n-   * Retrieves a list of task comments for a given taskId.\n+   * Retrieves the List of {@linkplain TaskComment TaskComments} for the Task with given {@linkplain\n+   * Task#getId() id}.\n    *\n-   * @param taskId The id of the task for which all task comments should be retrieved\n-   * @return the list of task comments attached to task with id taskId\n-   * @throws NotAuthorizedException If the current user has no authorization to retrieve a\n-   *     taskComment from a certain task or is not authorized to access the task.\n-   * @throws TaskNotFoundException If the given taskId in the TaskComment does not refer to an\n-   *     existing task.\n+   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} for which all task\n+   *     comments should be retrieved\n+   * @return the List of task comments attached to the specified {@linkplain Task}\n+   * @throws NotAuthorizedException if the current user has no authorization to retrieve a\n+   *     taskComment from the {@linkplain Task} or is not authorized to access the {@linkplain Task}\n+   * @throws TaskNotFoundException if the given taskId does not refer to an existing {@linkplain\n+   *     Task}\n    */\n   List<TaskComment> getTaskComments(String taskId)\n       throws NotAuthorizedException, TaskNotFoundException;\n \n   /**\n-   * Sets the callback state on a list of tasks. Note: this method is primarily intended to be used\n-   * by the TaskanaAdapter\n+   * Sets the specified {@linkplain CallbackState} on a list of {@linkplain Task Tasks}. Note: this\n+   * method is primarily intended to be used by the TaskanaAdapter\n    *\n-   * @param externalIds the EXTERNAL_IDs of the tasks on which the callback state is set.\n-   * @param state the callback state that is to be set on the tasks\n-   * @return the result of the operations with Id and Exception for each failed task deletion.\n+   * @param externalIds the {@linkplain Task#getExternalId() externalIds} of the {@linkplain Task\n+   *     Tasks} on which the {@linkplain CallbackState} is set\n+   * @param state the {@linkplain CallbackState} that is to be set on the {@linkplain Task Tasks}\n+   * @return the result of the operations with {@linkplain Task#getId() id} and Exception for each\n+   *     failed operation\n    */\n   BulkOperationResults<String, TaskanaException> setCallbackStateForTasks(\n       List<String> externalIds, CallbackState state);\n \n   /**\n-   * Sets the owner on a list of tasks. The owner will only be set on tasks that are in state READY.\n+   * Sets the {@linkplain Task#getOwner() owner} on a List of {@linkplain Task Tasks}. The\n+   * {@linkplain Task#getOwner() owner} will only be set on {@linkplain Task Tasks} that are in\n+   * state {@linkplain TaskState#READY}.\n    *\n-   * @param owner the new owner of the tasks\n-   * @param taskIds the IDs of the tasks on which the owner is to be set.\n-   * @return the result of the operations with Id and Exception for each failed task update.\n+   * @param owner the new {@linkplain Task#getOwner() owner} of the {@linkplain Task Tasks}\n+   * @param taskIds the {@linkplain Task#getId() ids} of the {@linkplain Task Tasks} on which the\n+   *     {@linkplain Task#getOwner() owner} is to be set\n+   * @return the result of the operations with {@linkplain Task#getId() id} and Exception for each\n+   *     failed {@linkplain Task}-update\n    */\n   BulkOperationResults<String, TaskanaException> setOwnerOfTasks(\n       String owner, List<String> taskIds);\n \n   /**\n-   * Sets the planned property on a list of tasks. Only tasks in state READY and CLAIMED will be\n-   * affected by this method. On each task, the corresponding due date is set according to the\n-   * shortest service level in the classifications of the task and the task's attachments.\n+   * Sets the {@linkplain Task#getPlanned() planned} Instant on a List of {@linkplain Task Tasks}.\n+   * Only {@linkplain Task Tasks} in state {@linkplain TaskState#READY} and {@linkplain\n+   * TaskState#CLAIMED} will be affected by this method. On each {@linkplain Task}, the\n+   * corresponding {@linkplain Task#getDue() due date} is set according to the shortest serviceLevel\n+   * in the {@linkplain Task#getClassificationSummary() Classification} of the {@linkplain Task} and\n+   * its {@linkplain Task#getAttachments() Attachments}.\n    *\n-   * @param planned the new 'PLANNED\" property of the tasks\n-   * @param taskIds the IDs of the tasks on which the new planned property is to be set.\n-   * @return the result of the operations with Id and Exception for each failed task update.\n+   * @param planned the new {@linkplain Task#getPlanned() planned} Instant of the {@linkplain Task\n+   *     Tasks}\n+   * @param taskIds the {@linkplain Task#getId() ids} of the {@linkplain Task Tasks} on which the\n+   *     new {@linkplain Task#getPlanned() planned} Instant is to be set\n+   * @return the result of the operations with {@linkplain Task#getId() id} and Exception for each\n+   *     failed {@linkplain Task Task} update.\n    */\n   BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n       Instant planned, List<String> taskIds);\n \n   /**\n-   * Cancels a task.\n+   * Cancels the {@linkplain Task} with the given {@linkplain Task#getId() id}. Cancellation means a\n+   * {@linkplain Task} is obsolete from a business perspective and does not need to be completed\n+   * anymore.\n    *\n-   * @param taskId the id of the task to cancel.\n-   * @return the updated task.\n-   * @throws TaskNotFoundException if the Task with Id TaskId is not found\n-   * @throws InvalidStateException if the task is not in state READY or CLAIMED\n-   * @throws NotAuthorizedException if the current user is not authorized to see the task\n+   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to cancel\n+   * @return the updated {@linkplain Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} with taskId is not found\n+   * @throws InvalidStateException if the {@linkplain Task} is not in state {@linkplain\n+   *     TaskState#READY} or {@linkplain TaskState#CLAIMED}\n+   * @throws NotAuthorizedException if the current user is not authorized to see the {@linkplain\n+   *     Task}\n    */\n   Task cancelTask(String taskId)\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n \n   /**\n-   * Terminates a task.\n+   * Terminates a {@linkplain Task}. Termination is an administrative action to complete a\n+   * {@linkplain Task}. This is typically done by administration to correct any technical issue.\n    *\n-   * @param taskId the id of the task to cancel.\n-   * @return the updated task.\n-   * @throws TaskNotFoundException if the Task with Id TaskId is not found\n-   * @throws InvalidStateException if the task is not in state READY or CLAIMED\n-   * @throws NotAuthorizedException if the current user is not authorized to see the task\n+   * @param taskId the id of the {@linkplain Task} to cancel\n+   * @return the updated {@linkplain Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} with taskId is not found\n+   * @throws InvalidStateException if the {@linkplain Task} is not in state {@linkplain\n+   *     TaskState#READY} or {@linkplain TaskState#CLAIMED}\n+   * @throws NotAuthorizedException if the current user is not authorized to see the {@linkplain\n+   *     Task}\n    */\n   Task terminateTask(String taskId)\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n", "next_change": {"commit": "a2e068119042fd305c3f494e43cd41fec80f1a30", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 48bac1ed4..a58ce2866 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -670,49 +744,53 @@ public interface TaskService {\n \n   /**\n    * Sets the {@linkplain Task#getPlanned() planned} Instant on a List of {@linkplain Task Tasks}.\n-   * Only {@linkplain Task Tasks} in state {@linkplain TaskState#READY} and {@linkplain\n+   *\n+   * <p>Only {@linkplain Task Tasks} in state {@linkplain TaskState#READY} and {@linkplain\n    * TaskState#CLAIMED} will be affected by this method. On each {@linkplain Task}, the\n-   * corresponding {@linkplain Task#getDue() due date} is set according to the shortest serviceLevel\n-   * in the {@linkplain Task#getClassificationSummary() Classification} of the {@linkplain Task} and\n-   * its {@linkplain Task#getAttachments() Attachments}.\n+   * corresponding {@linkplain Task#getDue() due} Instant is set according to the shortest\n+   * serviceLevel in the {@linkplain Task#getClassificationSummary() Classification} of the\n+   * {@linkplain Task} and its {@linkplain Task#getAttachments() Attachments}.\n    *\n    * @param planned the new {@linkplain Task#getPlanned() planned} Instant of the {@linkplain Task\n    *     Tasks}\n    * @param taskIds the {@linkplain Task#getId() ids} of the {@linkplain Task Tasks} on which the\n    *     new {@linkplain Task#getPlanned() planned} Instant is to be set\n-   * @return the result of the operations with {@linkplain Task#getId() id} and Exception for each\n-   *     failed {@linkplain Task Task} update.\n+   * @return the result of the operations with {@linkplain Task#getId() ids} and Exception for each\n+   *     failed {@linkplain Task} update\n    */\n   BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n       Instant planned, List<String> taskIds);\n \n   /**\n-   * Cancels the {@linkplain Task} with the given {@linkplain Task#getId() id}. Cancellation means a\n-   * {@linkplain Task} is obsolete from a business perspective and does not need to be completed\n-   * anymore.\n+   * Cancels the {@linkplain Task} with the given {@linkplain Task#getId() id}.\n+   *\n+   * <p>Cancellation means a {@linkplain Task} is obsolete from a business perspective and doesn't\n+   * need to be completed anymore.\n    *\n    * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to cancel\n    * @return the updated {@linkplain Task}\n-   * @throws TaskNotFoundException if the {@linkplain Task} with taskId is not found\n-   * @throws InvalidStateException if the {@linkplain Task} is not in state {@linkplain\n-   *     TaskState#READY} or {@linkplain TaskState#CLAIMED}\n-   * @throws NotAuthorizedException if the current user is not authorized to see the {@linkplain\n-   *     Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} with taskId wasn't found\n+   * @throws InvalidStateException if the {@linkplain Task} isn't in {@linkplain TaskState#READY} or\n+   *     {@linkplain TaskState#CLAIMED}\n+   * @throws NotAuthorizedException if the current user has no {@linkplain\n+   *     WorkbasketPermission#READ} for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task cancelTask(String taskId)\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n \n   /**\n    * Terminates a {@linkplain Task}. Termination is an administrative action to complete a\n-   * {@linkplain Task}. This is typically done by administration to correct any technical issue.\n+   * {@linkplain Task}.\n+   *\n+   * <p>This is typically done by administration to correct any technical issue.\n    *\n-   * @param taskId the id of the {@linkplain Task} to cancel\n+   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to cancel\n    * @return the updated {@linkplain Task}\n-   * @throws TaskNotFoundException if the {@linkplain Task} with taskId is not found\n-   * @throws InvalidStateException if the {@linkplain Task} is not in state {@linkplain\n-   *     TaskState#READY} or {@linkplain TaskState#CLAIMED}\n-   * @throws NotAuthorizedException if the current user is not authorized to see the {@linkplain\n-   *     Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} with taskId wasn't found\n+   * @throws InvalidStateException if the {@linkplain Task} isn't in {@linkplain TaskState#READY} or\n+   *     {@linkplain TaskState#CLAIMED}\n+   * @throws NotAuthorizedException if the current user isn't member of {@linkplain\n+   *     TaskanaRole#ADMIN} or {@linkplain TaskanaRole#BUSINESS_ADMIN}\n    */\n   Task terminateTask(String taskId)\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n", "next_change": {"commit": "33a88529954a490d2a042a34319cbf394ee15e9d", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex a58ce2866..6e357fdf2 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -677,121 +853,55 @@ public interface TaskService {\n       throws NotAuthorizedException, TaskCommentNotFoundException, TaskNotFoundException,\n           InvalidArgumentException;\n \n-  /**\n-   * Retrieves the {@linkplain TaskComment} with the given {@linkplain TaskComment#getId() id}.\n-   *\n-   * @param taskCommentId the {@linkplain TaskComment#getId() id} of the {@linkplain TaskComment}\n-   *     which should be retrieved\n-   * @return the {@linkplain TaskComment} identified by taskCommentId\n-   * @throws TaskCommentNotFoundException if the given taskCommentId doesn't refer to an existing\n-   *     {@linkplain TaskComment}\n-   * @throws NotAuthorizedException if the current user has no {@linkplain\n-   *     WorkbasketPermission#READ} for the {@linkplain Workbasket} of the commented {@linkplain\n-   *     Task}\n-   * @throws TaskNotFoundException if the {@linkplain TaskComment#getTaskId() taskId} of the\n-   *     TaskComment doesn't refer to an existing {@linkplain Task}\n-   * @throws InvalidArgumentException if the given taskCommentId is NULL or empty\n-   */\n-  TaskComment getTaskComment(String taskCommentId)\n-      throws TaskCommentNotFoundException, NotAuthorizedException, TaskNotFoundException,\n-          InvalidArgumentException;\n+  // endregion\n \n-  /**\n-   * Retrieves the List of {@linkplain TaskComment TaskComments} for the {@linkplain Task} with\n-   * given {@linkplain Task#getId() id}.\n-   *\n-   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} for which all\n-   *     {@linkplain TaskComment TaskComments} should be retrieved\n-   * @return the List of {@linkplain TaskComment TaskComments} attached to the specified {@linkplain\n-   *     Task}\n-   * @throws NotAuthorizedException if the current user has no {@linkplain\n-   *     WorkbasketPermission#READ} for the {@linkplain Workbasket} of the commented {@linkplain\n-   *     Task}\n-   * @throws TaskNotFoundException if the given taskId doesn't refer to an existing {@linkplain\n-   *     Task}\n-   */\n-  List<TaskComment> getTaskComments(String taskId)\n-      throws NotAuthorizedException, TaskNotFoundException;\n+  // endregion\n \n   /**\n-   * Sets the specified {@linkplain CallbackState} on a List of {@linkplain Task Tasks}.\n-   *\n-   * <p>Note: this method is primarily intended to be used by the TaskanaAdapter\n+   * Instantiates a non-persistent/non-inserted {@linkplain Attachment}.\n    *\n-   * @param externalIds the {@linkplain Task#getExternalId() externalIds} of the {@linkplain Task\n-   *     Tasks} on which the {@linkplain CallbackState} is set\n-   * @param state the {@linkplain CallbackState} that is to be set on the {@linkplain Task Tasks}\n-   * @return the result of the operations with {@linkplain Task#getId() ids} and Exception for each\n-   *     failed operation\n+   * @return the instantiated {@linkplain Attachment}\n    */\n-  BulkOperationResults<String, TaskanaException> setCallbackStateForTasks(\n-      List<String> externalIds, CallbackState state);\n+  Attachment newAttachment();\n \n   /**\n-   * Sets the {@linkplain Task#getOwner() owner} on a List of {@linkplain Task Tasks}.\n-   *\n-   * <p>The {@linkplain Task#getOwner() owner} will only be set on {@linkplain Task Tasks} that are\n-   * in {@linkplain TaskState#READY}.\n+   * Instantiates a non-persistent/non-inserted {@linkplain ObjectReference}.\n    *\n-   * @param owner the new {@linkplain Task#getOwner() owner} of the {@linkplain Task Tasks}\n-   * @param taskIds the {@linkplain Task#getId() ids} of the {@linkplain Task Tasks} on which the\n-   *     {@linkplain Task#getOwner() owner} is to be set\n-   * @return the result of the operations with {@linkplain Task#getId() ids} and Exception for each\n-   *     failed {@linkplain Task}-update\n+   * @return the instantiated {@linkplain ObjectReference}\n+   * @see #newObjectReference(String, String, String, String, String)\n    */\n-  BulkOperationResults<String, TaskanaException> setOwnerOfTasks(\n-      String owner, List<String> taskIds);\n+  ObjectReference newObjectReference();\n \n   /**\n-   * Sets the {@linkplain Task#getPlanned() planned} Instant on a List of {@linkplain Task Tasks}.\n-   *\n-   * <p>Only {@linkplain Task Tasks} in state {@linkplain TaskState#READY} and {@linkplain\n-   * TaskState#CLAIMED} will be affected by this method. On each {@linkplain Task}, the\n-   * corresponding {@linkplain Task#getDue() due} Instant is set according to the shortest\n-   * serviceLevel in the {@linkplain Task#getClassificationSummary() Classification} of the\n-   * {@linkplain Task} and its {@linkplain Task#getAttachments() Attachments}.\n+   * Instantiates a non-persistent/non-inserted {@linkplain ObjectReference}.\n    *\n-   * @param planned the new {@linkplain Task#getPlanned() planned} Instant of the {@linkplain Task\n-   *     Tasks}\n-   * @param taskIds the {@linkplain Task#getId() ids} of the {@linkplain Task Tasks} on which the\n-   *     new {@linkplain Task#getPlanned() planned} Instant is to be set\n-   * @return the result of the operations with {@linkplain Task#getId() ids} and Exception for each\n-   *     failed {@linkplain Task} update\n+   * @param company the {@linkplain ObjectReference#getCompany() company} of the new {@linkplain\n+   *     ObjectReference}\n+   * @param system the {@linkplain ObjectReference#getSystem() system} of the new {@linkplain\n+   *     ObjectReference}\n+   * @param systemInstance the {@linkplain ObjectReference#getSystemInstance() systemInstance} of\n+   *     the new {@linkplain ObjectReference}\n+   * @param type the {@linkplain ObjectReference#getType() type} of the new {@linkplain\n+   *     ObjectReference}\n+   * @param value the {@linkplain ObjectReference#getValue() value} of the new {@linkplain\n+   *     ObjectReference}\n+   * @return the instantiated {@linkplain ObjectReference}\n+   * @see #newObjectReference()\n    */\n-  BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n-      Instant planned, List<String> taskIds);\n+  ObjectReference newObjectReference(\n+      String company, String system, String systemInstance, String type, String value);\n \n   /**\n-   * Cancels the {@linkplain Task} with the given {@linkplain Task#getId() id}.\n-   *\n-   * <p>Cancellation means a {@linkplain Task} is obsolete from a business perspective and doesn't\n-   * need to be completed anymore.\n+   * Creates an empty {@linkplain TaskQuery}.\n    *\n-   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to cancel\n-   * @return the updated {@linkplain Task}\n-   * @throws TaskNotFoundException if the {@linkplain Task} with taskId wasn't found\n-   * @throws InvalidStateException if the {@linkplain Task} isn't in {@linkplain TaskState#READY} or\n-   *     {@linkplain TaskState#CLAIMED}\n-   * @throws NotAuthorizedException if the current user has no {@linkplain\n-   *     WorkbasketPermission#READ} for the {@linkplain Workbasket} the {@linkplain Task} is in\n+   * @return a {@linkplain TaskQuery}\n    */\n-  Task cancelTask(String taskId)\n-      throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n+  TaskQuery createTaskQuery();\n \n   /**\n-   * Terminates a {@linkplain Task}. Termination is an administrative action to complete a\n-   * {@linkplain Task}.\n-   *\n-   * <p>This is typically done by administration to correct any technical issue.\n+   * Creates an empty {@linkplain TaskCommentQuery}.\n    *\n-   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to cancel\n-   * @return the updated {@linkplain Task}\n-   * @throws TaskNotFoundException if the {@linkplain Task} with taskId wasn't found\n-   * @throws InvalidStateException if the {@linkplain Task} isn't in {@linkplain TaskState#READY} or\n-   *     {@linkplain TaskState#CLAIMED}\n-   * @throws NotAuthorizedException if the current user isn't member of {@linkplain\n-   *     TaskanaRole#ADMIN} or {@linkplain TaskanaRole#BUSINESS_ADMIN}\n+   * @return a {@linkplain TaskCommentQuery}\n    */\n-  Task terminateTask(String taskId)\n-      throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n+  TaskCommentQuery createTaskCommentQuery();\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6bd6bd48386155644df0463edf8aeda473bd1a56", "message": "Merge commit", "committedDate": null}, {"oid": "3b13b9a95e4d7d1cf172f22fa0f2679ff1c5f79b", "committedDate": "2020-02-03 11:41:02 +0100", "message": "TSK-991 after initial refactoring"}, {"oid": "22ac25f5c9244bdc67752b7adcb9d98f4b8d6fa2", "committedDate": "2020-02-06 14:05:27 +0100", "message": "TSK-927 reserve a task via SetOwner"}, {"oid": "5c7d38451ce7cbea2ad52d3b84be72d49c474c71", "committedDate": "2020-02-13 15:09:39 +0100", "message": "TSK-1094 introduce models package for */api and */internal"}, {"oid": "ddb12a6ad15965ad6e87d0920c975d425c575249", "committedDate": "2020-02-14 12:04:52 +0100", "message": "TSK-1095"}, {"oid": "20bd0922dbc332efcf4e94a0d487b077c95c5a85", "committedDate": "2020-02-26 14:48:50 +0100", "message": "TSK-1131 updateOwner on multiple tasks"}, {"oid": "02a6df6f73622e86684c6c30d8f320c84078b237", "committedDate": "2020-02-28 10:46:45 +0100", "message": "TSK-1139 Bulk update of Planned timestamp"}, {"oid": "3b7da72d24beb1e0f6d528f575b1ae7029f10e7f", "committedDate": "2020-03-17 11:54:26 +0100", "message": "TSK-1150 Java-API for the administration of comments for tasks"}, {"oid": "7d464bd6cde263ad9b674e5d796fcf91e4a727bf", "committedDate": "2020-03-17 11:54:26 +0100", "message": "TSK-1150 Comments from Bernd Breier"}, {"oid": "7deb9254113278ccf5872283c2abd202c3cf7af0", "committedDate": "2020-03-19 14:43:16 +0100", "message": "TSK-1143 UpdateTask planned - comments from Holger"}, {"oid": "7b409451dcf7f12714b5c9739861c9b43541e275", "committedDate": "2020-03-25 08:44:18 +0100", "message": "TSK-1143C mismatch between forward and backward calculation between planned and due"}, {"oid": "2ce7f86456f99d522e001080e9504ae4cd6a80f4", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-1160 TaskStates CANCELLED and TERMINATED"}, {"oid": "d6505284f780ec7a804adf7d6156726e85ddd4ef", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-1160 - terminate/cancel task Holger's comments"}, {"oid": "93a94f0458979e35cb92ee682be312532d1e5210", "committedDate": "2020-03-31 11:56:59 +0200", "message": "TSK-1150: added taskId as pathvariable to getTaskComment and deleteTaskComment"}, {"oid": "dffb139a822c55fcf12438e6e996fdef41b6f098", "committedDate": "2020-03-31 11:56:59 +0200", "message": "comments from Holger Hagen"}, {"oid": "1f13c2c33ac0ce2c8202a23f5d977c87717894a3", "committedDate": "2020-05-13 14:49:18 +0200", "message": "TSK-1195: Secure deleteTasks in TaskServiceImpl"}, {"oid": "496da17b3eec2490b68b27c4192b32c02935a2f0", "committedDate": "2020-06-07 15:56:30 +0200", "message": "TSK-1257: refactored claimtasks in taskService and increased test coverage"}, {"oid": "6f12677b74a36ec04e282def79e8b549d48c1988", "committedDate": "2020-06-07 15:56:30 +0200", "message": "TSK-1257: implementes forceCompleteTasks"}, {"oid": "1dfe54c0b6fb05c6811573e38feba9212fdb6a9f", "committedDate": "2020-06-30 14:50:26 +0200", "message": "TSK-1275: Support select and claim in one API call"}, {"oid": "969d3eeff653d51eb7dcf5234aa4020333613ab3", "committedDate": "2020-06-30 14:50:26 +0200", "message": "review Findings"}, {"oid": "7cc5b00be617227dac2f8d1210554108d18bad4a", "committedDate": "2020-07-24 01:05:42 +0200", "message": "TSK-1345: replaced every customField API call with CustomField enums"}, {"oid": "3967e2900e8b35329b3675844ca3a8e059916c7e", "committedDate": "2020-12-18 11:29:10 +0100", "message": "TSK-1436: rest api documentation is now build with spring-auto-restdocs"}, {"oid": "de57596ba8e816d3e751b21c949a3fe132b314f0", "committedDate": "2020-12-18 11:29:10 +0100", "message": "TSK-1436: reworked review comments."}, {"oid": "d57aeb3219f45e962d6a05b175f4397d296e819b", "committedDate": "2021-03-01 10:03:04 +0100", "message": "TSK-1524: Set the default service level to \"P0D\" (#1496)"}, {"oid": "ec822c116855052b32ef98cc496e4876c7f52fa6", "committedDate": "2021-03-02 10:34:30 +0100", "message": "TSK-1555: Initialize due of Cleanup Job based on firstRun (#1488)"}, {"oid": "0119999380b40fdc0f69677f96650de5c81bd2a5", "committedDate": "2021-03-09 18:58:51 +0100", "message": "TSK-1538: Added transfer method with control setTransferFlag (#1513)"}, {"oid": "1c83b7871f144cd07a912639b942d5938219e101", "committedDate": "2021-06-22 16:14:09 +0200", "message": "TSK-1646: Bugfix for creation / update of Task with invalid Attachment"}, {"oid": "34d2bbfa929ccaa9e9b93c173b8fa867154330bb", "committedDate": "2021-07-14 10:49:34 +0200", "message": "TSK-1647: Implemented an error key for every exception"}, {"oid": "375a92291d41c6c90b403055ac5228ccd309621a", "committedDate": "2021-07-15 14:03:00 +0200", "message": "TSK-1658: Created TaskQueryMapperSqlProvider"}, {"oid": "e264a203892c6d2111df4645abf7f373bf4ca86a", "committedDate": "2021-10-08 08:38:21 +0200", "message": "TSK-1726: Implemented option to include long name on Task / TaskComment / TaskHistoryEvent"}, {"oid": "967e59e012f94e116f2b327b6c426f44ae1bcbee", "committedDate": "2022-02-25 10:23:40 +0100", "message": "TSK-1800: add secondary object references"}, {"oid": "b4e1f9bc315eb701d0dec0e34c38651672239566", "committedDate": "2022-04-15 11:43:57 +0200", "message": "TSK-1532: Refactor names of entities in REST-Doc by capitalizing them; refactor Java-doc according to guidelines"}, {"oid": "a2e068119042fd305c3f494e43cd41fec80f1a30", "committedDate": "2022-05-31 16:01:49 +0200", "message": "TSK-1852: refactor JavaDoc in TaskService"}, {"oid": "ef875dd42a58b55bace25fb4f599d84e4d06b59b", "committedDate": "2022-08-06 14:30:59 +0200", "message": "TSK-1915: Add requestReview functionality"}, {"oid": "cc32b10d82b7888ed2eae438100d2e26fb508f0c", "committedDate": "2022-08-09 13:19:02 +0200", "message": "TSK-1916: Add requestChanges functionality"}, {"oid": "6997d640834819d21fe0325178d73bbf70de68fc", "committedDate": "2022-08-11 17:08:10 +0200", "message": "TSK-1943: added REST endpoint for force requesting changes on a Task"}, {"oid": "33a88529954a490d2a042a34319cbf394ee15e9d", "committedDate": "2022-08-18 00:02:18 +0300", "message": "TSK-1864: Reorder methods in TaskService"}, {"oid": "b9b49f47a13e748be20bf73ed605f0dfde7fcf70", "committedDate": "2022-10-20 14:20:24 +0200", "message": "TSK-1965: create endpoints for all state transitions (#2024)"}, {"oid": "20d389a7d524c156b063dfc91589bb22bebea0d7", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-1992 remove unnecessary ParentExceptions"}, {"oid": "d21eb47ffea4c2c9fff8f1d3435b77b805d03508", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-2012: renamed Mismatched_Exceptions to NotAuthorizedExceptions"}, {"oid": "37280cc73b83e2d39ab4afddd40256719d64c50c", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-2013 selectAndClaim TasK return Optional and does not throw Exception if Task is notFound"}, {"oid": "55d939ca7b7720ab12f488ed8fc2a631ecc6f05c", "committedDate": "2023-03-13 19:02:53 +0100", "message": "format entire codebase with new google-java-format version"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1NDI1Ng==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398654256", "body": "Maybe just \"in\" as it is a well known operator for this? Just an idea.", "bodyText": "Maybe just \"in\" as it is a well known operator for this? Just an idea.", "bodyHTML": "<p dir=\"auto\">Maybe just \"in\" as it is a well known operator for this? Just an idea.</p>", "author": "holgerhagen", "createdAt": "2020-03-26T15:16:25Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java", "diffHunk": "@@ -4,5 +4,20 @@\n public enum TaskState {\n   READY,\n   CLAIMED,\n-  COMPLETED\n+  COMPLETED,\n+  CANCELLED,\n+  TERMINATED;\n+\n+  public boolean isInStates(TaskState... states) {", "originalCommit": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE2MTM3OA==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r399161378", "bodyText": "You don't like that? Or you has overseen this ons?", "author": "holgerhagen", "createdAt": "2020-03-27T10:15:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1NDI1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI4NzI0Nw==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r399287247", "bodyText": "Ok, I didn't see this one. No problem, I'll change it to 'in'", "author": "BerndBreier", "createdAt": "2020-03-27T14:04:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1NDI1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "62d58b32c908be3bf05b5068497e4be5a20002e6", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\nindex fd7b87a38..7047e18e5 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\n", "chunk": "@@ -8,7 +8,7 @@ public enum TaskState {\n   CANCELLED,\n   TERMINATED;\n \n-  public boolean isInStates(TaskState... states) {\n+  public boolean in(TaskState... states) {\n     for (TaskState currState : states) {\n       if (this.equals(currState)) {\n         return true;\n", "next_change": null}]}, "revised_code_in_main": {"commit": "6bd6bd48386155644df0463edf8aeda473bd1a56", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\nindex fd7b87a38..7047e18e5 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\n", "chunk": "@@ -8,7 +8,7 @@ public enum TaskState {\n   CANCELLED,\n   TERMINATED;\n \n-  public boolean isInStates(TaskState... states) {\n+  public boolean in(TaskState... states) {\n     for (TaskState currState : states) {\n       if (this.equals(currState)) {\n         return true;\n", "next_change": {"commit": "3b13b9a95e4d7d1cf172f22fa0f2679ff1c5f79b", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\nindex 7047e18e5..d4aba71ba 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\n", "chunk": "@@ -4,20 +4,5 @@ package pro.taskana.task.api;\n public enum TaskState {\n   READY,\n   CLAIMED,\n-  COMPLETED,\n-  CANCELLED,\n-  TERMINATED;\n-\n-  public boolean in(TaskState... states) {\n-    for (TaskState currState : states) {\n-      if (this.equals(currState)) {\n-        return true;\n-      }\n-    }\n-    return false;\n-  }\n-\n-  public boolean isEndState() {\n-    return this.equals(COMPLETED) || this.equals(CANCELLED) || this.equals(TERMINATED);\n-  }\n+  COMPLETED\n }\n", "next_change": {"commit": "2ce7f86456f99d522e001080e9504ae4cd6a80f4", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\nindex d4aba71ba..fd7b87a38 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\n", "chunk": "@@ -4,5 +4,20 @@ package pro.taskana.task.api;\n public enum TaskState {\n   READY,\n   CLAIMED,\n-  COMPLETED\n+  COMPLETED,\n+  CANCELLED,\n+  TERMINATED;\n+\n+  public boolean isInStates(TaskState... states) {\n+    for (TaskState currState : states) {\n+      if (this.equals(currState)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  public boolean isEndState() {\n+    return this.equals(COMPLETED) || this.equals(CANCELLED) || this.equals(TERMINATED);\n+  }\n }\n", "next_change": {"commit": "bd116d4c2e02b853dd336e3f2efdcd6b330f2fe1", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\nindex fd7b87a38..522351e8e 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\n", "chunk": "@@ -8,16 +10,11 @@ public enum TaskState {\n   CANCELLED,\n   TERMINATED;\n \n-  public boolean isInStates(TaskState... states) {\n-    for (TaskState currState : states) {\n-      if (this.equals(currState)) {\n-        return true;\n-      }\n-    }\n-    return false;\n+  public boolean in(TaskState... states) {\n+    return Arrays.stream(states).anyMatch(state -> state == this);\n   }\n \n   public boolean isEndState() {\n-    return this.equals(COMPLETED) || this.equals(CANCELLED) || this.equals(TERMINATED);\n+    return this == COMPLETED || this == CANCELLED || this == TERMINATED;\n   }\n }\n", "next_change": {"commit": "fe0ce092feaa1830e115de2d1cacdc9bf79705d6", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\nindex 522351e8e..e883a54d0 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\n", "chunk": "@@ -10,11 +10,13 @@ public enum TaskState {\n   CANCELLED,\n   TERMINATED;\n \n+  public static final TaskState[] END_STATES = {COMPLETED, CANCELLED, TERMINATED};\n+\n   public boolean in(TaskState... states) {\n     return Arrays.stream(states).anyMatch(state -> state == this);\n   }\n \n   public boolean isEndState() {\n-    return this == COMPLETED || this == CANCELLED || this == TERMINATED;\n+    return in(END_STATES);\n   }\n }\n", "next_change": {"commit": "34d2bbfa929ccaa9e9b93c173b8fa867154330bb", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\nindex e883a54d0..750fb6a01 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\n", "chunk": "@@ -13,7 +13,7 @@ public enum TaskState {\n   public static final TaskState[] END_STATES = {COMPLETED, CANCELLED, TERMINATED};\n \n   public boolean in(TaskState... states) {\n-    return Arrays.stream(states).anyMatch(state -> state == this);\n+    return Arrays.asList(states).contains(this);\n   }\n \n   public boolean isEndState() {\n", "next_change": null}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6bd6bd48386155644df0463edf8aeda473bd1a56", "message": "Merge commit", "committedDate": null}, {"oid": "3b13b9a95e4d7d1cf172f22fa0f2679ff1c5f79b", "committedDate": "2020-02-03 11:41:02 +0100", "message": "TSK-991 after initial refactoring"}, {"oid": "2ce7f86456f99d522e001080e9504ae4cd6a80f4", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-1160 TaskStates CANCELLED and TERMINATED"}, {"oid": "7fdea5bef22fcd17413094243c08d88ad6d28c3d", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-1160 - terminate/cancel task more comments from Holger"}, {"oid": "bd116d4c2e02b853dd336e3f2efdcd6b330f2fe1", "committedDate": "2020-05-14 13:02:48 +0200", "message": "[TSK-1208] changed HATE terminology and replaced list resources with generic one"}, {"oid": "fe0ce092feaa1830e115de2d1cacdc9bf79705d6", "committedDate": "2020-06-09 20:30:15 +0200", "message": "TSK-1285: added constant in TaskState so that endStates can be used in combination with our queries"}, {"oid": "34d2bbfa929ccaa9e9b93c173b8fa867154330bb", "committedDate": "2021-07-14 10:49:34 +0200", "message": "TSK-1647: Implemented an error key for every exception"}, {"oid": "83890ddd16249632546e83011cf41759ddccb7da", "committedDate": "2022-07-19 15:27:44 +0200", "message": "TSK-1914: introduce IN_REVIEW and READY_FOR_REVIEW Task status"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1NTM4Mg==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398655382", "body": "Why don't we provide the converter on engine level and initialize it during startup according to the configuration?", "bodyText": "Why don't we provide the converter on engine level and initialize it during startup according to the configuration?", "bodyHTML": "<p dir=\"auto\">Why don't we provide the converter on engine level and initialize it during startup according to the configuration?</p>", "author": "holgerhagen", "createdAt": "2020-03-26T15:17:49Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java", "diffHunk": "@@ -48,14 +46,9 @@\n     this.taskanaEngine = taskanaEngine;\n     this.taskMapper = taskMapper;\n     this.attachmentMapper = attachmentMapper;\n-    DaysToWorkingDaysConverter.setGermanPublicHolidaysEnabled(\n-        taskanaEngine.getEngine().getConfiguration().isGermanPublicHolidaysEnabled());\n-    try {\n-      converter = DaysToWorkingDaysConverter.initialize();\n-    } catch (InvalidArgumentException e) {\n-      LOGGER.error(ERROR_CANNOT_INITIALIZE_DAYS_TO_WORKING_DAYS_CONVERTER);\n-      throw new SystemException(\n-          ERROR_CANNOT_INITIALIZE_DAYS_TO_WORKING_DAYS_CONVERTER, e.getCause());\n+    this.converter = WorkingDaysToDaysConverter.initialize();\n+    if (taskanaEngine.getEngine().getConfiguration().isGermanPublicHolidaysEnabled()) {", "originalCommit": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc0NzQ0OA==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398747448", "bodyText": "Apart from the DaysToWorkingDaysReportConverter, the converter is only needed in ServiceLevelHandler. I think, we should maintain and supply classes / objects there where they are needed. But if you insist to provide it on engine level, I can do that.\nWith respect to configuration: I introduce the configuration property taskana.german.holidays.enabled and set it to true in taskana.properties. Then I initialize this property in TaskanaEngineConfiguration and use it in the constructor of TaskanaEngineImpl to set that (static) property on WorkingDaysToDaysConverter.", "author": "BerndBreier", "createdAt": "2020-03-26T17:15:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1NTM4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "4c65a6087e83b85e44118a754cf749a23cac5250", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\nindex 743dbd9be..83d237766 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n", "chunk": "@@ -47,9 +47,6 @@ class ServiceLevelHandler {\n     this.taskMapper = taskMapper;\n     this.attachmentMapper = attachmentMapper;\n     this.converter = WorkingDaysToDaysConverter.initialize();\n-    if (taskanaEngine.getEngine().getConfiguration().isGermanPublicHolidaysEnabled()) {\n-      WorkingDaysToDaysConverter.setGermanPublicHolidaysEnabled(true);\n-    }\n   }\n \n   // use the same algorithm as setPlannedPropertyOfTasksImpl to refresh\n", "next_change": {"commit": "62d58b32c908be3bf05b5068497e4be5a20002e6", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\nindex 83d237766..292aaa9d9 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n", "chunk": "@@ -46,6 +46,8 @@ class ServiceLevelHandler {\n     this.taskanaEngine = taskanaEngine;\n     this.taskMapper = taskMapper;\n     this.attachmentMapper = attachmentMapper;\n+    WorkingDaysToDaysConverter.setGermanPublicHolidaysEnabled(\n+        taskanaEngine.getEngine().getConfiguration().isGermanPublicHolidaysEnabled());\n     this.converter = WorkingDaysToDaysConverter.initialize();\n   }\n \n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "6bd6bd48386155644df0463edf8aeda473bd1a56", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\nindex 743dbd9be..292aaa9d9 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n", "chunk": "@@ -46,10 +46,9 @@ class ServiceLevelHandler {\n     this.taskanaEngine = taskanaEngine;\n     this.taskMapper = taskMapper;\n     this.attachmentMapper = attachmentMapper;\n+    WorkingDaysToDaysConverter.setGermanPublicHolidaysEnabled(\n+        taskanaEngine.getEngine().getConfiguration().isGermanPublicHolidaysEnabled());\n     this.converter = WorkingDaysToDaysConverter.initialize();\n-    if (taskanaEngine.getEngine().getConfiguration().isGermanPublicHolidaysEnabled()) {\n-      WorkingDaysToDaysConverter.setGermanPublicHolidaysEnabled(true);\n-    }\n   }\n \n   // use the same algorithm as setPlannedPropertyOfTasksImpl to refresh\n", "next_change": {"commit": "02a6df6f73622e86684c6c30d8f320c84078b237", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\nindex 292aaa9d9..d6f999501 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n", "chunk": "@@ -33,43 +34,28 @@ import pro.taskana.task.internal.models.TaskImpl;\n class ServiceLevelHandler {\n \n   private static final Logger LOGGER = LoggerFactory.getLogger(ServiceLevelHandler.class);\n+  private static final String ERROR_CANNOT_INITIALIZE_DAYS_TO_WORKING_DAYS_CONVERTER =\n+      \"Internal error. Cannot initialize DaysToWorkingDaysConverter\";\n   private static final Duration MAX_DURATION = Duration.ofSeconds(Long.MAX_VALUE, 999_999_999);\n   private final InternalTaskanaEngine taskanaEngine;\n   private final TaskMapper taskMapper;\n   private final AttachmentMapper attachmentMapper;\n-  private WorkingDaysToDaysConverter converter;\n+  private DaysToWorkingDaysConverter converter;\n \n-  ServiceLevelHandler(\n+  public ServiceLevelHandler(\n       InternalTaskanaEngine taskanaEngine,\n       TaskMapper taskMapper,\n       AttachmentMapper attachmentMapper) {\n+    super();\n     this.taskanaEngine = taskanaEngine;\n     this.taskMapper = taskMapper;\n     this.attachmentMapper = attachmentMapper;\n-    WorkingDaysToDaysConverter.setGermanPublicHolidaysEnabled(\n-        taskanaEngine.getEngine().getConfiguration().isGermanPublicHolidaysEnabled());\n-    this.converter = WorkingDaysToDaysConverter.initialize();\n-  }\n-\n-  // use the same algorithm as setPlannedPropertyOfTasksImpl to refresh\n-  // priority and duration of affected tasks, just don't use a fix\n-  // planned date but the individual planned date of the tasks\n-  public void refreshPriorityAndDueDatesOfTasks(\n-      List<MinimalTaskSummary> tasks, boolean serviceLevelChanged, boolean priorityChanged) {\n-\n-    List<AttachmentSummaryImpl> attachments = getAttachmentSummaries(tasks);\n-    List<ClassificationSummary> allInvolvedClassifications =\n-        findAllClassificationsReferencedByTasksAndAttachments(tasks, attachments);\n-\n-    if (serviceLevelChanged) {\n-      List<ClassificationWithServiceLevelResolved> allInvolvedClassificationsWithDuration =\n-          resolveDurationsInClassifications(allInvolvedClassifications);\n-\n-      updateTaskDueDatesOnClassificationUpdate(\n-          tasks, attachments, allInvolvedClassificationsWithDuration);\n-    }\n-    if (priorityChanged) {\n-      updateTaskPriorityOnClassificationUpdate(tasks, attachments, allInvolvedClassifications);\n+    try {\n+      this.converter = DaysToWorkingDaysConverter.initialize();\n+    } catch (InvalidArgumentException e) {\n+      LOGGER.error(ERROR_CANNOT_INITIALIZE_DAYS_TO_WORKING_DAYS_CONVERTER);\n+      throw new SystemException(\n+          ERROR_CANNOT_INITIALIZE_DAYS_TO_WORKING_DAYS_CONVERTER, e.getCause());\n     }\n   }\n \n", "next_change": {"commit": "fa429cef97db829102f746731f4dd966358c531e", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\nindex d6f999501..617e31aae 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n", "chunk": "@@ -59,6 +58,28 @@ class ServiceLevelHandler {\n     }\n   }\n \n+  // use the same algorithm as setPlannedPropertyOfTasksImpl to refresh\n+  // priority and duration of affected tasks, just don't use a fix\n+  // planned date but the individual planned date of the tasks\n+  public void refreshPriorityAndDueDatesOfTasks(\n+      List<MinimalTaskSummary> tasks, boolean serviceLevelChanged, boolean priorityChanged) {\n+\n+    List<AttachmentSummaryImpl> attachments = getAttachmentSummaries(tasks);\n+    List<ClassificationSummary> allInvolvedClassifications =\n+        findAllClassificationsReferencedByTasksAndAttachments(tasks, attachments);\n+\n+    if (serviceLevelChanged) {\n+      List<ClassificationWithServiceLevelResolved> allInvolvedClassificationsWithDuration =\n+          resolveDurationsInClassifications(allInvolvedClassifications);\n+\n+      updateTaskDueDatesOnClassificationUpdate(\n+          tasks, attachments, allInvolvedClassificationsWithDuration);\n+    }\n+    if (priorityChanged) {\n+      updateTaskPriorityOnClassificationUpdate(tasks, attachments, allInvolvedClassifications);\n+    }\n+  }\n+\n   // Algorithm:\n   // - load all relevant tasks and their attachmentSummaries\n   // - load all classifications referenced by these tasks / attachments\n", "next_change": {"commit": "f70d84579386fa560e6013485f276d0ebb19386a", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\nindex 617e31aae..f1c982557 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n", "chunk": "@@ -76,7 +70,10 @@ class ServiceLevelHandler {\n           tasks, attachments, allInvolvedClassificationsWithDuration);\n     }\n     if (priorityChanged) {\n-      updateTaskPriorityOnClassificationUpdate(tasks, attachments, allInvolvedClassifications);\n+      List<MinimalTaskSummary> tasksWithoutManualPriority =\n+          tasks.stream().filter(t -> !t.isManualPriorityActive()).collect(Collectors.toList());\n+      updateTaskPriorityOnClassificationUpdate(\n+          tasksWithoutManualPriority, attachments, allInvolvedClassifications);\n     }\n   }\n \n", "next_change": {"commit": "93d0b27bb058a4f47218177136bce81f99103345", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\nindex f1c982557..eb18ba692 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n", "chunk": "@@ -71,7 +72,9 @@ class ServiceLevelHandler {\n     }\n     if (priorityChanged) {\n       List<MinimalTaskSummary> tasksWithoutManualPriority =\n-          tasks.stream().filter(t -> !t.isManualPriorityActive()).collect(Collectors.toList());\n+          tasks.stream()\n+              .filter(not(MinimalTaskSummary::isManualPriorityActive))\n+              .collect(Collectors.toList());\n       updateTaskPriorityOnClassificationUpdate(\n           tasksWithoutManualPriority, attachments, allInvolvedClassifications);\n     }\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6bd6bd48386155644df0463edf8aeda473bd1a56", "message": "Merge commit", "committedDate": null}, {"oid": "02a6df6f73622e86684c6c30d8f320c84078b237", "committedDate": "2020-02-28 10:46:45 +0100", "message": "TSK-1139 Bulk update of Planned timestamp"}, {"oid": "1291287419385725f59ed90a8e8960d57c8638e0", "committedDate": "2020-03-19 14:43:16 +0100", "message": "TSK-1143 UpdateTask with Planned sometimes fails"}, {"oid": "7deb9254113278ccf5872283c2abd202c3cf7af0", "committedDate": "2020-03-19 14:43:16 +0100", "message": "TSK-1143 UpdateTask planned - comments from Holger"}, {"oid": "f78e7616f65b1cf9575f246daf4bba856a3e8f1c", "committedDate": "2020-03-19 14:43:16 +0100", "message": "TSK-1143 Update Task PLANNED - Holger's comments"}, {"oid": "e470f8d200ef88c137645111f715b058ca9803e3", "committedDate": "2020-03-19 14:43:16 +0100", "message": "TSK-1143 even more comments from Holger"}, {"oid": "7b409451dcf7f12714b5c9739861c9b43541e275", "committedDate": "2020-03-25 08:44:18 +0100", "message": "TSK-1143C mismatch between forward and backward calculation between planned and due"}, {"oid": "fa429cef97db829102f746731f4dd966358c531e", "committedDate": "2020-03-26 08:47:03 +0100", "message": "TSK-1143C mismatch between forward and backward calculation between planned and due"}, {"oid": "9251975f477fb5dc5bb82f79fe11c1c566b67e59", "committedDate": "2020-03-26 08:47:03 +0100", "message": "TSK-1143 UpdateTask planned - comments from Holger"}, {"oid": "87fd1af390f7c4abe4e4097f2e52a48bf1e68c5a", "committedDate": "2020-03-26 08:47:03 +0100", "message": "TSK-442 improve task refresh on classification update"}, {"oid": "2ce7f86456f99d522e001080e9504ae4cd6a80f4", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-1160 TaskStates CANCELLED and TERMINATED"}, {"oid": "d6505284f780ec7a804adf7d6156726e85ddd4ef", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-1160 - terminate/cancel task Holger's comments"}, {"oid": "7fdea5bef22fcd17413094243c08d88ad6d28c3d", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-1160 - terminate/cancel task more comments from Holger"}, {"oid": "520eb4e2955e92eac7320a361fb228104fff5322", "committedDate": "2020-04-06 20:10:21 +0200", "message": "TSK-1177 update Planned of Task if only Due was changed"}, {"oid": "c6755b35b7226f4989aeea25ceeb3e18204fed45", "committedDate": "2020-05-22 03:25:57 +0200", "message": "TSK-1244: added due/planned logic for SLA P0D"}, {"oid": "ab6e5ecc3333dd578bea53a4562d211f2a766719", "committedDate": "2020-05-22 03:25:57 +0200", "message": "TSK-1244: optimized due/planned logic for SLA P0D"}, {"oid": "7e411d42e157b482e0e3c47eee5f75d9105cdbbe", "committedDate": "2020-05-22 03:48:27 +0200", "message": "TSK-1252: fixed newly introduced code smells"}, {"oid": "d4a516863e40f77bd494e1f1c8d95712d0e21f11", "committedDate": "2020-05-22 15:00:04 +0200", "message": "TSK-1226: made corpus christi configurable from taskana.properties file"}, {"oid": "8832876b9372c135c2c2fce88bc4820a1cab37d7", "committedDate": "2020-06-03 14:32:31 +0200", "message": "TSK-1247: Removed LoggerUtils and replaced its usages with the standard toString implementations"}, {"oid": "02e05a7d3b0eb4f0a238105fef73a1fa19b8ab5c", "committedDate": "2020-06-11 21:56:30 +0200", "message": "TSK-1286: refactored WorkingDaysToDaysConverter"}, {"oid": "41973183bcb5211ef940e834f81e74321323d996", "committedDate": "2020-08-07 14:59:19 +0200", "message": "TSK-1337: removed some code smells"}, {"oid": "34d2bbfa929ccaa9e9b93c173b8fa867154330bb", "committedDate": "2021-07-14 10:49:34 +0200", "message": "TSK-1647: Implemented an error key for every exception"}, {"oid": "8edb488bd3f854568dab1ee56c8d974fe63f95cd", "committedDate": "2021-07-14 10:49:34 +0200", "message": "TSK-1647: Implemented global frontend error handling using backend error keys"}, {"oid": "14baeb8bc1d1bbc80fe19df73df2cc7e638f9b43", "committedDate": "2021-08-26 10:32:46 +0200", "message": "TSK-1703: Create configuration property that allows to create & update due and planned timestamps with service level mismatch"}, {"oid": "f70d84579386fa560e6013485f276d0ebb19386a", "committedDate": "2022-03-29 09:44:13 +0200", "message": "TSK-1802: add manual priority to task in taskana-core"}, {"oid": "93d0b27bb058a4f47218177136bce81f99103345", "committedDate": "2022-04-26 15:27:56 +0200", "message": "TSK-1831: dropped support for JDK8"}, {"oid": "4697fbe5beefd1c72144187847ee99fcd0883d9c", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-2004: JavaDoc 4 TaskanaConfiguration.Builder#initTaskanaProperties"}, {"oid": "4a42a35a212f6bd25839432f48ec813c106874fc", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-1972: calculates working time in any resolution"}, {"oid": "fb11ff97b30a3f1277d49d48a8164c4f95bb0a6d", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-1972: Task.dueDate is inclusive."}, {"oid": "55d939ca7b7720ab12f488ed8fc2a631ecc6f05c", "committedDate": "2023-03-13 19:02:53 +0100", "message": "format entire codebase with new google-java-format version"}, {"oid": "d96b1c392a0f9ecfe72e7d0bc0aadac17620133c", "committedDate": "2023-03-15 01:00:50 +0100", "message": "TSK-1991: rework of property names"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1NzQ0Nw==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398657447", "body": "We should retain this timestamp even if the task is terminated/cancelled.", "bodyText": "We should retain this timestamp even if the task is terminated/cancelled.", "bodyHTML": "<p dir=\"auto\">We should retain this timestamp even if the task is terminated/cancelled.</p>", "author": "holgerhagen", "createdAt": "2020-03-26T15:20:22Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java", "diffHunk": "@@ -951,6 +979,29 @@ private TaskImpl checkConcurrencyAndSetModified(TaskImpl newTaskImpl, TaskImpl o\n     return newTaskImpl;\n   }\n \n+  private TaskImpl terminateCancelCommonActions(String taskId, TaskState targetState)\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n+    if (taskId == null || taskId.isEmpty()) {\n+      throw new TaskNotFoundException(taskId, String.format(TASK_WITH_ID_WAS_NOT_FOUND, taskId));\n+    }\n+    TaskImpl task = (TaskImpl) getTask(taskId);\n+    TaskState state = task.getState();\n+    if (state.isEndState()) {\n+      throw new InvalidStateException(String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n+    }\n+\n+    Instant now = Instant.now();\n+    task.setOwner(null);\n+    task.setModified(now);\n+    task.setCompleted(now);\n+    task.setClaimed(null);", "originalCommit": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc0ODU5Ng==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398748596", "bodyText": "ok, retained the claimed timestamp", "author": "BerndBreier", "createdAt": "2020-03-26T17:17:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1NzQ0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "4c65a6087e83b85e44118a754cf749a23cac5250", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 382c3861a..47a6735b9 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -994,8 +994,6 @@ public class TaskServiceImpl implements TaskService {\n     task.setOwner(null);\n     task.setModified(now);\n     task.setCompleted(now);\n-    task.setClaimed(null);\n-    task.setRead(true);\n     task.setState(targetState);\n     taskMapper.update(task);\n     LOGGER.debug(\"Task '{}' cancelled by user '{}'.\", taskId, CurrentUserContext.getUserid());\n", "next_change": {"commit": "62d58b32c908be3bf05b5068497e4be5a20002e6", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 47a6735b9..fba7860b2 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -991,7 +991,6 @@ public class TaskServiceImpl implements TaskService {\n     }\n \n     Instant now = Instant.now();\n-    task.setOwner(null);\n     task.setModified(now);\n     task.setCompleted(now);\n     task.setState(targetState);\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "6bd6bd48386155644df0463edf8aeda473bd1a56", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 382c3861a..fba7860b2 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -991,11 +991,8 @@ public class TaskServiceImpl implements TaskService {\n     }\n \n     Instant now = Instant.now();\n-    task.setOwner(null);\n     task.setModified(now);\n     task.setCompleted(now);\n-    task.setClaimed(null);\n-    task.setRead(true);\n     task.setState(targetState);\n     taskMapper.update(task);\n     LOGGER.debug(\"Task '{}' cancelled by user '{}'.\", taskId, CurrentUserContext.getUserid());\n", "next_change": {"commit": "3b13b9a95e4d7d1cf172f22fa0f2679ff1c5f79b", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex fba7860b2..e4e8b398d 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -963,85 +755,23 @@ public class TaskServiceImpl implements TaskService {\n     return result;\n   }\n \n-  private TaskImpl checkConcurrencyAndSetModified(TaskImpl newTaskImpl, TaskImpl oldTaskImpl)\n-      throws ConcurrencyException {\n-    // TODO: not safe to rely only on different timestamps.\n-    // With fast execution below 1ms there will be no concurrencyException\n-    if (oldTaskImpl.getModified() != null\n-            && !oldTaskImpl.getModified().equals(newTaskImpl.getModified())\n-        || oldTaskImpl.getClaimed() != null\n-            && !oldTaskImpl.getClaimed().equals(newTaskImpl.getClaimed())\n-        || oldTaskImpl.getState() != null\n-            && !oldTaskImpl.getState().equals(newTaskImpl.getState())) {\n-      throw new ConcurrencyException(\"The task has already been updated by another user\");\n-    }\n-    newTaskImpl.setModified(Instant.now());\n-    return newTaskImpl;\n-  }\n-\n-  private TaskImpl terminateCancelCommonActions(String taskId, TaskState targetState)\n-      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n-    if (taskId == null || taskId.isEmpty()) {\n-      throw new TaskNotFoundException(taskId, String.format(TASK_WITH_ID_WAS_NOT_FOUND, taskId));\n-    }\n-    TaskImpl task = (TaskImpl) getTask(taskId);\n-    TaskState state = task.getState();\n-    if (state.isEndState()) {\n-      throw new InvalidStateException(String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n-    }\n-\n-    Instant now = Instant.now();\n-    task.setModified(now);\n-    task.setCompleted(now);\n-    task.setState(targetState);\n-    taskMapper.update(task);\n-    LOGGER.debug(\"Task '{}' cancelled by user '{}'.\", taskId, CurrentUserContext.getUserid());\n-    return task;\n-  }\n-\n-  private BulkOperationResults<String, TaskanaException> addExceptionsForTasksWhoseOwnerWasNotSet(\n-      String owner, List<MinimalTaskSummary> existingMinimalTaskSummaries) {\n-    BulkOperationResults<String, TaskanaException> bulkLog = new BulkOperationResults<>();\n-\n-    for (MinimalTaskSummary taskSummary : existingMinimalTaskSummaries) {\n-      if (!owner.equals(taskSummary.getOwner())) { // owner was not set\n-        if (!TaskState.READY.equals(taskSummary.getTaskState())) { // due to invalid state\n-          bulkLog.addError(\n-              taskSummary.getTaskId(),\n-              new InvalidStateException(\n-                  String.format(\n-                      TASK_WITH_ID_IS_NOT_READY,\n-                      taskSummary.getTaskId(),\n-                      taskSummary.getTaskState())));\n-        } else { // due to unknown reason\n-          bulkLog.addError(\n-              taskSummary.getTaskId(),\n-              new UpdateFailedException(\n-                  String.format(\"Could not set owner of Task %s .\", taskSummary.getTaskId())));\n-        }\n-      }\n-    }\n-    return bulkLog;\n-  }\n-\n   private Task claim(String taskId, boolean forceClaim)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException {\n     String userId = CurrentUserContext.getUserid();\n     LOGGER.debug(\n         \"entry to claim(id = {}, userId = {}, forceClaim = {})\", taskId, userId, forceClaim);\n-    TaskImpl task;\n+    TaskImpl task = null;\n     try {\n       taskanaEngine.openConnection();\n       task = (TaskImpl) getTask(taskId);\n       TaskState state = task.getState();\n-      if (!state.in(TaskState.READY, TaskState.CLAIMED)) {\n-        throw new InvalidStateException(\n-            String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n+      if (state == TaskState.COMPLETED) {\n+        throw new InvalidStateException(TASK_WITH_ID + taskId + IS_ALREADY_COMPLETED);\n       }\n       if (state == TaskState.CLAIMED && !forceClaim && !task.getOwner().equals(userId)) {\n         throw new InvalidOwnerException(\n-            String.format(TASK_WITH_ID_IS_ALREADY_CLAIMED_BY, taskId, task.getOwner()));\n+            TASK_WITH_ID + taskId + IS_ALREADY_CLAIMED_BY + task.getOwner() + \".\");\n       }\n       Instant now = Instant.now();\n       task.setOwner(userId);\n", "next_change": {"commit": "2ce7f86456f99d522e001080e9504ae4cd6a80f4", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex e4e8b398d..382c3861a 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -755,23 +963,88 @@ public class TaskServiceImpl implements TaskService {\n     return result;\n   }\n \n+  private TaskImpl checkConcurrencyAndSetModified(TaskImpl newTaskImpl, TaskImpl oldTaskImpl)\n+      throws ConcurrencyException {\n+    // TODO: not safe to rely only on different timestamps.\n+    // With fast execution below 1ms there will be no concurrencyException\n+    if (oldTaskImpl.getModified() != null\n+            && !oldTaskImpl.getModified().equals(newTaskImpl.getModified())\n+        || oldTaskImpl.getClaimed() != null\n+            && !oldTaskImpl.getClaimed().equals(newTaskImpl.getClaimed())\n+        || oldTaskImpl.getState() != null\n+            && !oldTaskImpl.getState().equals(newTaskImpl.getState())) {\n+      throw new ConcurrencyException(\"The task has already been updated by another user\");\n+    }\n+    newTaskImpl.setModified(Instant.now());\n+    return newTaskImpl;\n+  }\n+\n+  private TaskImpl terminateCancelCommonActions(String taskId, TaskState targetState)\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n+    if (taskId == null || taskId.isEmpty()) {\n+      throw new TaskNotFoundException(taskId, String.format(TASK_WITH_ID_WAS_NOT_FOUND, taskId));\n+    }\n+    TaskImpl task = (TaskImpl) getTask(taskId);\n+    TaskState state = task.getState();\n+    if (state.isEndState()) {\n+      throw new InvalidStateException(String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n+    }\n+\n+    Instant now = Instant.now();\n+    task.setOwner(null);\n+    task.setModified(now);\n+    task.setCompleted(now);\n+    task.setClaimed(null);\n+    task.setRead(true);\n+    task.setState(targetState);\n+    taskMapper.update(task);\n+    LOGGER.debug(\"Task '{}' cancelled by user '{}'.\", taskId, CurrentUserContext.getUserid());\n+    return task;\n+  }\n+\n+  private BulkOperationResults<String, TaskanaException> addExceptionsForTasksWhoseOwnerWasNotSet(\n+      String owner, List<MinimalTaskSummary> existingMinimalTaskSummaries) {\n+    BulkOperationResults<String, TaskanaException> bulkLog = new BulkOperationResults<>();\n+\n+    for (MinimalTaskSummary taskSummary : existingMinimalTaskSummaries) {\n+      if (!owner.equals(taskSummary.getOwner())) { // owner was not set\n+        if (!TaskState.READY.equals(taskSummary.getTaskState())) { // due to invalid state\n+          bulkLog.addError(\n+              taskSummary.getTaskId(),\n+              new InvalidStateException(\n+                  String.format(\n+                      TASK_WITH_ID_IS_NOT_READY,\n+                      taskSummary.getTaskId(),\n+                      taskSummary.getTaskState())));\n+        } else { // due to unknown reason\n+          bulkLog.addError(\n+              taskSummary.getTaskId(),\n+              new UpdateFailedException(\n+                  String.format(\"Could not set owner of Task %s .\", taskSummary.getTaskId())));\n+        }\n+      }\n+    }\n+    return bulkLog;\n+  }\n+\n   private Task claim(String taskId, boolean forceClaim)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException {\n     String userId = CurrentUserContext.getUserid();\n     LOGGER.debug(\n         \"entry to claim(id = {}, userId = {}, forceClaim = {})\", taskId, userId, forceClaim);\n-    TaskImpl task = null;\n+    TaskImpl task;\n     try {\n       taskanaEngine.openConnection();\n       task = (TaskImpl) getTask(taskId);\n       TaskState state = task.getState();\n-      if (state == TaskState.COMPLETED) {\n-        throw new InvalidStateException(TASK_WITH_ID + taskId + IS_ALREADY_COMPLETED);\n+      if (!state.isInStates(TaskState.READY, TaskState.CLAIMED)) {\n+        throw new InvalidStateException(\n+            String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n       }\n       if (state == TaskState.CLAIMED && !forceClaim && !task.getOwner().equals(userId)) {\n         throw new InvalidOwnerException(\n-            TASK_WITH_ID + taskId + IS_ALREADY_CLAIMED_BY + task.getOwner() + \".\");\n+            String.format(TASK_WITH_ID_IS_ALREADY_CLAIMED_BY, taskId, task.getOwner()));\n       }\n       Instant now = Instant.now();\n       task.setOwner(userId);\n", "next_change": {"commit": "6f12677b74a36ec04e282def79e8b549d48c1988", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 382c3861a..5285ea062 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1037,21 +1182,10 @@ public class TaskServiceImpl implements TaskService {\n     try {\n       taskanaEngine.openConnection();\n       task = (TaskImpl) getTask(taskId);\n-      TaskState state = task.getState();\n-      if (!state.isInStates(TaskState.READY, TaskState.CLAIMED)) {\n-        throw new InvalidStateException(\n-            String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n-      }\n-      if (state == TaskState.CLAIMED && !forceClaim && !task.getOwner().equals(userId)) {\n-        throw new InvalidOwnerException(\n-            String.format(TASK_WITH_ID_IS_ALREADY_CLAIMED_BY, taskId, task.getOwner()));\n-      }\n       Instant now = Instant.now();\n-      task.setOwner(userId);\n-      task.setModified(now);\n-      task.setClaimed(now);\n-      task.setRead(true);\n-      task.setState(TaskState.CLAIMED);\n+\n+      checkPreconditionsForClaimTask(task, forceClaim);\n+      claimActionsOnTask(task, userId, now);\n       taskMapper.update(task);\n       LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n       if (HistoryEventProducer.isHistoryEnabled()) {\n", "next_change": {"commit": "d8ad7a7fb96e7d07e5f93e202cd84e03e5c1944a", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 5285ea062..f6299c27e 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1188,8 +1217,12 @@ public class TaskServiceImpl implements TaskService {\n       claimActionsOnTask(task, userId, now);\n       taskMapper.update(task);\n       LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n-      if (HistoryEventProducer.isHistoryEnabled()) {\n-        historyEventProducer.createEvent(new ClaimedEvent(task, CurrentUserContext.getUserid()));\n+      if (HistoryEventManager.isHistoryEnabled()) {\n+        historyEventManager.createEvent(\n+            new ClaimedEvent(\n+                IdGenerator.generateWithPrefix(ID_PREFIX_HISTORY_EVENT),\n+                task,\n+                CurrentUserContext.getUserid()));\n       }\n     } finally {\n       taskanaEngine.returnConnection();\n", "next_change": {"commit": "29ba5fe418ad6702648d7427d5c18b3fd06bbe83", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex f6299c27e..e11e382dc 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1219,7 +1186,7 @@ public class TaskServiceImpl implements TaskService {\n       LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n       if (HistoryEventManager.isHistoryEnabled()) {\n         historyEventManager.createEvent(\n-            new ClaimedEvent(\n+            new TaskClaimedEvent(\n                 IdGenerator.generateWithPrefix(ID_PREFIX_HISTORY_EVENT),\n                 task,\n                 CurrentUserContext.getUserid()));\n", "next_change": {"commit": "44cb21b5aec13e6548a0546dc8eb221fb1cd29ad", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex e11e382dc..5504cb522 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1189,7 +1200,7 @@ public class TaskServiceImpl implements TaskService {\n             new TaskClaimedEvent(\n                 IdGenerator.generateWithPrefix(ID_PREFIX_HISTORY_EVENT),\n                 task,\n-                CurrentUserContext.getUserid()));\n+                taskanaEngine.getEngine().getCurrentUserContext().getUserid()));\n       }\n     } finally {\n       taskanaEngine.returnConnection();\n", "next_change": {"commit": "b23c6873db22e24a0b713441317fec405db55708", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 5504cb522..fd50b0ae2 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1198,7 +1181,7 @@ public class TaskServiceImpl implements TaskService {\n       if (HistoryEventManager.isHistoryEnabled()) {\n         historyEventManager.createEvent(\n             new TaskClaimedEvent(\n-                IdGenerator.generateWithPrefix(ID_PREFIX_HISTORY_EVENT),\n+                IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n                 task,\n                 taskanaEngine.getEngine().getCurrentUserContext().getUserid()));\n       }\n", "next_change": {"commit": "bfcabea61048ccb21a591e0c4f1f8efecc7636b4", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex fd50b0ae2..ad45e047c 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1177,7 +1143,9 @@ public class TaskServiceImpl implements TaskService {\n       checkPreconditionsForClaimTask(task, forceClaim);\n       claimActionsOnTask(task, userId, now);\n       taskMapper.update(task);\n-      LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n+      if (LOGGER.isDebugEnabled()) {\n+        LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n+      }\n       if (HistoryEventManager.isHistoryEnabled()) {\n         historyEventManager.createEvent(\n             new TaskClaimedEvent(\n", "next_change": {"commit": "fb4234b6f180423c4789ba904709fd78edf7bf4f", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex ad45e047c..adc9804fa 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1146,7 +1115,7 @@ public class TaskServiceImpl implements TaskService {\n       if (LOGGER.isDebugEnabled()) {\n         LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n       }\n-      if (HistoryEventManager.isHistoryEnabled()) {\n+      if (historyEventManager.isEnabled()) {\n         historyEventManager.createEvent(\n             new TaskClaimedEvent(\n                 IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n", "next_change": {"commit": "43ed441daf60d22a579d93fde840861770b4ede5", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex adc9804fa..96da61dd7 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1116,11 +1175,15 @@ public class TaskServiceImpl implements TaskService {\n         LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n       }\n       if (historyEventManager.isEnabled()) {\n+        String changeDetails =\n+            ObjectAttributeChangeDetector.determineChangesInAttributes(oldTask, task);\n+\n         historyEventManager.createEvent(\n             new TaskClaimedEvent(\n                 IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n                 task,\n-                taskanaEngine.getEngine().getCurrentUserContext().getUserid()));\n+                taskanaEngine.getEngine().getCurrentUserContext().getUserid(),\n+                changeDetails));\n       }\n     } finally {\n       taskanaEngine.returnConnection();\n", "next_change": {"commit": "ef875dd42a58b55bace25fb4f599d84e4d06b59b", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 96da61dd7..0b2c71e16 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1191,12 +1204,63 @@ public class TaskServiceImpl implements TaskService {\n     return task;\n   }\n \n+  private Task requestReview(String taskId, boolean force)\n+      throws TaskNotFoundException, NotAuthorizedException, InvalidTaskStateException,\n+          InvalidOwnerException {\n+    String userId = taskanaEngine.getEngine().getCurrentUserContext().getUserid();\n+    TaskImpl task;\n+    try {\n+      taskanaEngine.openConnection();\n+      task = (TaskImpl) getTask(taskId);\n+\n+      TaskImpl oldTask = duplicateTaskExactly(task);\n+\n+      if (force && task.getState().isEndState()) {\n+        throw new InvalidTaskStateException(\n+            task.getId(), task.getState(), EnumUtil.allValuesExceptFor(TaskState.END_STATES));\n+      }\n+      if (!force && task.getState() != TaskState.CLAIMED) {\n+        throw new InvalidTaskStateException(task.getId(), task.getState(), TaskState.CLAIMED);\n+      }\n+      if (!force && !task.getOwner().equals(userId)) {\n+        throw new InvalidOwnerException(userId, task.getId());\n+      }\n+\n+      task.setState(TaskState.READY_FOR_REVIEW);\n+      task.setOwner(null);\n+      task.setModified(Instant.now());\n+\n+      taskMapper.update(task);\n+      if (LOGGER.isDebugEnabled()) {\n+        LOGGER.debug(\"Requested review for Task '{}' by user '{}'.\", taskId, userId);\n+      }\n+      if (historyEventManager.isEnabled()) {\n+        String changeDetails =\n+            ObjectAttributeChangeDetector.determineChangesInAttributes(oldTask, task);\n+\n+        historyEventManager.createEvent(\n+            new TaskRequestReviewEvent(\n+                IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n+                task,\n+                taskanaEngine.getEngine().getCurrentUserContext().getUserid(),\n+                changeDetails));\n+      }\n+    } finally {\n+      taskanaEngine.returnConnection();\n+    }\n+    return task;\n+  }\n+\n   private static void claimActionsOnTask(TaskSummaryImpl task, String userId, Instant now) {\n     task.setOwner(userId);\n     task.setModified(now);\n     task.setClaimed(now);\n     task.setRead(true);\n-    task.setState(TaskState.CLAIMED);\n+    if (Set.of(TaskState.READY_FOR_REVIEW, TaskState.IN_REVIEW).contains(task.getState())) {\n+      task.setState(TaskState.IN_REVIEW);\n+    } else {\n+      task.setState(TaskState.CLAIMED);\n+    }\n   }\n \n   private static void cancelClaimActionsOnTask(TaskSummaryImpl task, Instant now) {\n", "next_change": null}]}}]}}]}}, {"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex fd50b0ae2..ad45e047c 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1187,7 +1155,6 @@ public class TaskServiceImpl implements TaskService {\n       }\n     } finally {\n       taskanaEngine.returnConnection();\n-      LOGGER.debug(\"exit from claim()\");\n     }\n     return task;\n   }\n", "next_change": {"commit": "43ed441daf60d22a579d93fde840861770b4ede5", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex ad45e047c..96da61dd7 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1146,12 +1174,16 @@ public class TaskServiceImpl implements TaskService {\n       if (LOGGER.isDebugEnabled()) {\n         LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n       }\n-      if (HistoryEventManager.isHistoryEnabled()) {\n+      if (historyEventManager.isEnabled()) {\n+        String changeDetails =\n+            ObjectAttributeChangeDetector.determineChangesInAttributes(oldTask, task);\n+\n         historyEventManager.createEvent(\n             new TaskClaimedEvent(\n                 IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n                 task,\n-                taskanaEngine.getEngine().getCurrentUserContext().getUserid()));\n+                taskanaEngine.getEngine().getCurrentUserContext().getUserid(),\n+                changeDetails));\n       }\n     } finally {\n       taskanaEngine.returnConnection();\n", "next_change": {"commit": "ef875dd42a58b55bace25fb4f599d84e4d06b59b", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 96da61dd7..0b2c71e16 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1191,12 +1204,63 @@ public class TaskServiceImpl implements TaskService {\n     return task;\n   }\n \n+  private Task requestReview(String taskId, boolean force)\n+      throws TaskNotFoundException, NotAuthorizedException, InvalidTaskStateException,\n+          InvalidOwnerException {\n+    String userId = taskanaEngine.getEngine().getCurrentUserContext().getUserid();\n+    TaskImpl task;\n+    try {\n+      taskanaEngine.openConnection();\n+      task = (TaskImpl) getTask(taskId);\n+\n+      TaskImpl oldTask = duplicateTaskExactly(task);\n+\n+      if (force && task.getState().isEndState()) {\n+        throw new InvalidTaskStateException(\n+            task.getId(), task.getState(), EnumUtil.allValuesExceptFor(TaskState.END_STATES));\n+      }\n+      if (!force && task.getState() != TaskState.CLAIMED) {\n+        throw new InvalidTaskStateException(task.getId(), task.getState(), TaskState.CLAIMED);\n+      }\n+      if (!force && !task.getOwner().equals(userId)) {\n+        throw new InvalidOwnerException(userId, task.getId());\n+      }\n+\n+      task.setState(TaskState.READY_FOR_REVIEW);\n+      task.setOwner(null);\n+      task.setModified(Instant.now());\n+\n+      taskMapper.update(task);\n+      if (LOGGER.isDebugEnabled()) {\n+        LOGGER.debug(\"Requested review for Task '{}' by user '{}'.\", taskId, userId);\n+      }\n+      if (historyEventManager.isEnabled()) {\n+        String changeDetails =\n+            ObjectAttributeChangeDetector.determineChangesInAttributes(oldTask, task);\n+\n+        historyEventManager.createEvent(\n+            new TaskRequestReviewEvent(\n+                IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n+                task,\n+                taskanaEngine.getEngine().getCurrentUserContext().getUserid(),\n+                changeDetails));\n+      }\n+    } finally {\n+      taskanaEngine.returnConnection();\n+    }\n+    return task;\n+  }\n+\n   private static void claimActionsOnTask(TaskSummaryImpl task, String userId, Instant now) {\n     task.setOwner(userId);\n     task.setModified(now);\n     task.setClaimed(now);\n     task.setRead(true);\n-    task.setState(TaskState.CLAIMED);\n+    if (Set.of(TaskState.READY_FOR_REVIEW, TaskState.IN_REVIEW).contains(task.getState())) {\n+      task.setState(TaskState.IN_REVIEW);\n+    } else {\n+      task.setState(TaskState.CLAIMED);\n+    }\n   }\n \n   private static void cancelClaimActionsOnTask(TaskSummaryImpl task, Instant now) {\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6bd6bd48386155644df0463edf8aeda473bd1a56", "message": "Merge commit", "committedDate": null}, {"oid": "3b13b9a95e4d7d1cf172f22fa0f2679ff1c5f79b", "committedDate": "2020-02-03 11:41:02 +0100", "message": "TSK-991 after initial refactoring"}, {"oid": "27dd9b299b93ff13dc2d18f5803e2e314b1ac246", "committedDate": "2020-02-03 11:41:02 +0100", "message": "TSK-991 Restructuring- restructure history package"}, {"oid": "5815e38fa75956de6715569967afe7e7fc8dcd43", "committedDate": "2020-02-05 13:02:31 +0100", "message": "TSK-991: Fix Architecturtest and split DaysToWorkingDays converter for report and common"}, {"oid": "22ac25f5c9244bdc67752b7adcb9d98f4b8d6fa2", "committedDate": "2020-02-06 14:05:27 +0100", "message": "TSK-927 reserve a task via SetOwner"}, {"oid": "e308578ced577706e1f6994473e0e6252f647b9e", "committedDate": "2020-02-06 17:26:05 +0100", "message": "TSK-991: refactored report structure to meet api -> internal agreement"}, {"oid": "6eeff1ba22f5a07e459089fcb02074116ecb2d53", "committedDate": "2020-02-07 08:36:52 +0100", "message": "TSK-1065 Refactor TaskImpl"}, {"oid": "6c73ed18f205b350b1219e7f61f25f87ebe2e507", "committedDate": "2020-02-07 09:26:45 +0100", "message": "TSK-1064: refactored / simplified streams and boolean expressions"}, {"oid": "a5b3254c8dc8bbe193406920c50d9a81386adf4f", "committedDate": "2020-02-07 09:26:45 +0100", "message": "TSK-1064: refactored PrioDurationHolder -> generic Pair"}, {"oid": "f3f71a66b571f17cd1830dd19c6ff9aac186985a", "committedDate": "2020-02-11 09:48:03 +0100", "message": "TSK-1097"}, {"oid": "448d4fb8fc4586fc7bfa6b1083a22cc1453936a8", "committedDate": "2020-02-11 16:09:51 +0100", "message": "TSK-1107 Use userId-parameter in contructor of TaskanaHistoryEvent"}, {"oid": "5c7d38451ce7cbea2ad52d3b84be72d49c474c71", "committedDate": "2020-02-13 15:09:39 +0100", "message": "TSK-1094 introduce models package for */api and */internal"}, {"oid": "ddb12a6ad15965ad6e87d0920c975d425c575249", "committedDate": "2020-02-14 12:04:52 +0100", "message": "TSK-1095"}, {"oid": "20bd0922dbc332efcf4e94a0d487b077c95c5a85", "committedDate": "2020-02-26 14:48:50 +0100", "message": "TSK-1131 updateOwner on multiple tasks"}, {"oid": "7f93dd048e6b406ff43ad3b8007f3d149e015af6", "committedDate": "2020-02-26 14:48:50 +0100", "message": "TSK-1131 updateOwner Bulk - comments from Holger"}, {"oid": "02a6df6f73622e86684c6c30d8f320c84078b237", "committedDate": "2020-02-28 10:46:45 +0100", "message": "TSK-1139 Bulk update of Planned timestamp"}, {"oid": "3b7da72d24beb1e0f6d528f575b1ae7029f10e7f", "committedDate": "2020-03-17 11:54:26 +0100", "message": "TSK-1150 Java-API for the administration of comments for tasks"}, {"oid": "7d464bd6cde263ad9b674e5d796fcf91e4a727bf", "committedDate": "2020-03-17 11:54:26 +0100", "message": "TSK-1150 Comments from Bernd Breier"}, {"oid": "1291287419385725f59ed90a8e8960d57c8638e0", "committedDate": "2020-03-19 14:43:16 +0100", "message": "TSK-1143 UpdateTask with Planned sometimes fails"}, {"oid": "7deb9254113278ccf5872283c2abd202c3cf7af0", "committedDate": "2020-03-19 14:43:16 +0100", "message": "TSK-1143 UpdateTask planned - comments from Holger"}, {"oid": "f78e7616f65b1cf9575f246daf4bba856a3e8f1c", "committedDate": "2020-03-19 14:43:16 +0100", "message": "TSK-1143 Update Task PLANNED - Holger's comments"}, {"oid": "e470f8d200ef88c137645111f715b058ca9803e3", "committedDate": "2020-03-19 14:43:16 +0100", "message": "TSK-1143 even more comments from Holger"}, {"oid": "c2d974b02ea0182bfcda6f99d253b83372cf6335", "committedDate": "2020-03-26 08:47:03 +0100", "message": "TSK-1143 UpdateTask with Planned sometimes fails"}, {"oid": "87fd1af390f7c4abe4e4097f2e52a48bf1e68c5a", "committedDate": "2020-03-26 08:47:03 +0100", "message": "TSK-442 improve task refresh on classification update"}, {"oid": "7352a8a7280794299e8e0250c2b30744037a2a8b", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-1143 UpdateTask with Planned sometimes fails"}, {"oid": "28fbeb8a2e116f5178815049770d17ebc1a90c3d", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-442 improve task refresh on classification update"}, {"oid": "2ce7f86456f99d522e001080e9504ae4cd6a80f4", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-1160 TaskStates CANCELLED and TERMINATED"}, {"oid": "d6505284f780ec7a804adf7d6156726e85ddd4ef", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-1160 - terminate/cancel task Holger's comments"}, {"oid": "7fdea5bef22fcd17413094243c08d88ad6d28c3d", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-1160 - terminate/cancel task more comments from Holger"}, {"oid": "93a94f0458979e35cb92ee682be312532d1e5210", "committedDate": "2020-03-31 11:56:59 +0200", "message": "TSK-1150: added taskId as pathvariable to getTaskComment and deleteTaskComment"}, {"oid": "dffb139a822c55fcf12438e6e996fdef41b6f098", "committedDate": "2020-03-31 11:56:59 +0200", "message": "comments from Holger Hagen"}, {"oid": "d5674ed11a70cc488a9699387b90272318a22444", "committedDate": "2020-04-22 13:41:20 +0200", "message": "TSK-746 Add simple history event tracking to update and create task method"}, {"oid": "8442be7903dfc14f6bcdef2cb72f353c726db9e3", "committedDate": "2020-04-22 13:41:20 +0200", "message": "Comment from Mustapha Zorgati"}, {"oid": "3fea9ab975e55f14c9924baeb1740ef989aa66c0", "committedDate": "2020-05-06 08:54:37 +0200", "message": "TSK-1197: readded test case for testing the ordering of the databases H2, Postgress and DB2; remove Db2 10.5 travis job TSK-1197: build Postgres image with german collation"}, {"oid": "eb73c0670f522b6d1936b4323cf940640f504775", "committedDate": "2020-05-11 16:08:12 +0200", "message": "TSK-1192 Introduced new Task-Admin Role"}, {"oid": "1f13c2c33ac0ce2c8202a23f5d977c87717894a3", "committedDate": "2020-05-13 14:49:18 +0200", "message": "TSK-1195: Secure deleteTasks in TaskServiceImpl"}, {"oid": "8832876b9372c135c2c2fce88bc4820a1cab37d7", "committedDate": "2020-06-03 14:32:31 +0200", "message": "TSK-1247: Removed LoggerUtils and replaced its usages with the standard toString implementations"}, {"oid": "496da17b3eec2490b68b27c4192b32c02935a2f0", "committedDate": "2020-06-07 15:56:30 +0200", "message": "TSK-1257: refactored claimtasks in taskService and increased test coverage"}, {"oid": "6f12677b74a36ec04e282def79e8b549d48c1988", "committedDate": "2020-06-07 15:56:30 +0200", "message": "TSK-1257: implementes forceCompleteTasks"}, {"oid": "36adf71b904abe5730aba921d72a3c76cb4c5146", "committedDate": "2020-06-07 15:56:30 +0200", "message": "TSK-1257: replaced multiple helper methods with abstract helper method"}, {"oid": "a2318c267ea7f6d57cfffefc04c5285e66778fac", "committedDate": "2020-06-12 12:31:55 +0200", "message": "reformatted code"}, {"oid": "1dfe54c0b6fb05c6811573e38feba9212fdb6a9f", "committedDate": "2020-06-30 14:50:26 +0200", "message": "TSK-1275: Support select and claim in one API call"}, {"oid": "969d3eeff653d51eb7dcf5234aa4020333613ab3", "committedDate": "2020-06-30 14:50:26 +0200", "message": "review Findings"}, {"oid": "d8ad7a7fb96e7d07e5f93e202cd84e03e5c1944a", "committedDate": "2020-07-10 13:13:42 +0200", "message": "TSK-1250 On demand deletion of historical data"}, {"oid": "4bba93c5a98dcbe22dc86144b12507abce4b2be4", "committedDate": "2020-07-10 13:13:42 +0200", "message": "Review findings"}, {"oid": "abced36ecdc2edff824b2857da78581c94c40970", "committedDate": "2020-07-16 11:26:06 +0200", "message": "TSK-1336: Remove unnecessary warn logging in updateTask()"}, {"oid": "7cc5b00be617227dac2f8d1210554108d18bad4a", "committedDate": "2020-07-24 01:05:42 +0200", "message": "TSK-1345: replaced every customField API call with CustomField enums"}, {"oid": "b7237021e2e77fc0648e8117a725220d9560b3d2", "committedDate": "2020-08-05 16:48:33 +0200", "message": "TSK-1333: Add history events for cancelled/terminated tasks"}, {"oid": "29ba5fe418ad6702648d7427d5c18b3fd06bbe83", "committedDate": "2020-08-12 13:27:26 +0200", "message": "TSK-1335: Add workbasket history events"}, {"oid": "198572b6b15d375d99fd565d43cb99888b021e60", "committedDate": "2020-09-23 09:13:40 +0200", "message": "TSK-1390: Add SPI to allow task processing before creation"}, {"oid": "0e83abd0fda3d25585359a4655b1bc1e50429f39", "committedDate": "2020-09-23 09:13:40 +0200", "message": "TSK-1390: Review findings"}, {"oid": "44cb21b5aec13e6548a0546dc8eb221fb1cd29ad", "committedDate": "2020-10-09 10:25:54 +0200", "message": "TSK-1277: removed circular dependency between taskana-common and taskana-core"}, {"oid": "b23c6873db22e24a0b713441317fec405db55708", "committedDate": "2020-10-13 19:58:28 +0200", "message": "TSK-1335: removed last occurences of \"HEI\" prefix for history events"}, {"oid": "039dee4fb21035bcb9ca36e3c0becf59c03fed6c", "committedDate": "2020-11-02 09:41:48 +0100", "message": "TSK-1282: updated taskana-core to jdk11"}, {"oid": "28b3ce6f8a563bf74bf02382b77c3b817085f127", "committedDate": "2020-11-02 09:41:48 +0100", "message": "TSK-1282: replaced all usages of Arrays.asList with List.of"}, {"oid": "81b89e1c08b67fb383605fe061dec07fec4a557a", "committedDate": "2020-11-06 14:53:40 +0100", "message": "TSK-1441: Enable Admin to complete tasks already claimed by other users"}, {"oid": "ab672b27d4593dc7bf179d2e3c107a8a3ae0196f", "committedDate": "2021-01-05 15:27:27 +0100", "message": "TSK-1362: Fixed the test data to not include invalid owners for Workbaskets (#1379)"}, {"oid": "c6e82c1368da17762918b1ef5102974a302124af", "committedDate": "2021-02-02 08:16:07 +0100", "message": "TSK-1506: Fixed bug for Cleanup Jobs with more than 32767 tasks (#1457)"}, {"oid": "aa6d304b499a9df48d90ff3bfc375b25c5f00a71", "committedDate": "2021-02-03 09:34:22 +0100", "message": "TSK-1499: Fixed bug of also cleaning completed tasks with parentProcessId null/empty (#1394)"}, {"oid": "0119999380b40fdc0f69677f96650de5c81bd2a5", "committedDate": "2021-03-09 18:58:51 +0100", "message": "TSK-1538: Added transfer method with control setTransferFlag (#1513)"}, {"oid": "3ddcd2ae97ffea8bd479655e70d5182141d12220", "committedDate": "2021-04-23 17:28:11 +0200", "message": "TSK-1628: New DmnTaskRouter module"}, {"oid": "b8892020d98b905a2e4cbe12a344d93fcc68af25", "committedDate": "2021-05-19 10:29:13 +0200", "message": "TSK-795: Changed Exception when creating a Task with a non-empty taskId (#1575)"}, {"oid": "bfcabea61048ccb21a591e0c4f1f8efecc7636b4", "committedDate": "2021-05-20 09:41:58 +0200", "message": "TSK-1596: Automatic TraceLogging (#1577)"}, {"oid": "7636ec0b2a8e12ea5b3cff48f7b702472b603e5d", "committedDate": "2021-06-01 09:51:38 +0200", "message": "TSK-1501: TaskTransferrer cleaned and restructured (#1599)"}, {"oid": "b66e4d9f862a14fc740e1c25c00e80e81c74abe9", "committedDate": "2021-06-09 12:37:56 +0200", "message": "TSK-1642: now setting details attribute for TaskTransferHistoryEvent"}, {"oid": "1c83b7871f144cd07a912639b942d5938219e101", "committedDate": "2021-06-22 16:14:09 +0200", "message": "TSK-1646: Bugfix for creation / update of Task with invalid Attachment"}, {"oid": "34d2bbfa929ccaa9e9b93c173b8fa867154330bb", "committedDate": "2021-07-14 10:49:34 +0200", "message": "TSK-1647: Implemented an error key for every exception"}, {"oid": "8edb488bd3f854568dab1ee56c8d974fe63f95cd", "committedDate": "2021-07-14 10:49:34 +0200", "message": "TSK-1647: Implemented global frontend error handling using backend error keys"}, {"oid": "358e699f9f0bdf8505ff0f44ac0ad5803cdcb5c8", "committedDate": "2021-07-16 11:08:05 +0200", "message": "TSK-1664: fixed some code smells and redesigned RestHelper"}, {"oid": "99eba636a1ec363282153ae857f651d2c5d2e592", "committedDate": "2021-07-29 14:58:57 +0200", "message": "TSK-1674: Added received timestamp to task (#1638)"}, {"oid": "6da07b069aae2d41a5b9949ea69b249e9ff7903a", "committedDate": "2021-08-02 11:46:33 +0200", "message": "TSK-1647: minor improvements and fixes"}, {"oid": "dc9e3a25ce9aa317ace656ebe58bdcfefaa8c4b5", "committedDate": "2021-08-20 21:21:57 +0200", "message": "TSK-1686: Introduced an SPI for the individual calculation of priorities"}, {"oid": "54428045dd57a6d295c9a1529274b08246c731eb", "committedDate": "2021-08-30 14:18:38 +0200", "message": "TSK-1718: Performance optimization for TaskService#getTask and TaskQuery#list"}, {"oid": "e9a1f02c2e828a123b191cc031bd473ba0e51fe7", "committedDate": "2021-09-16 09:21:29 +0200", "message": "TSK-1633: created all new test API for improved test data generation"}, {"oid": "fb4234b6f180423c4789ba904709fd78edf7bf4f", "committedDate": "2021-09-21 16:35:58 +0200", "message": "TSK-1704: test API now restricting service providers to specific test"}, {"oid": "e264a203892c6d2111df4645abf7f373bf4ca86a", "committedDate": "2021-10-08 08:38:21 +0200", "message": "TSK-1726: Implemented option to include long name on Task / TaskComment / TaskHistoryEvent"}, {"oid": "c7742b3056f4c2d11ff4ddeef980e177bb82bd64", "committedDate": "2021-11-26 13:18:27 +0100", "message": "TSK-1775: reformatted entire backend code base"}, {"oid": "967e59e012f94e116f2b327b6c426f44ae1bcbee", "committedDate": "2022-02-25 10:23:40 +0100", "message": "TSK-1800: add secondary object references"}, {"oid": "4f48fe93c633e31304fa808a96c3477d78b33f2c", "committedDate": "2022-03-08 17:10:37 +0100", "message": "TSK-1807: renamed setCustomAttribute to setCustomField"}, {"oid": "93d0b27bb058a4f47218177136bce81f99103345", "committedDate": "2022-04-26 15:27:56 +0200", "message": "TSK-1831: dropped support for JDK8"}, {"oid": "1ae1df890848d22617cd10c611e5d496428db790", "committedDate": "2022-05-19 09:31:13 +0200", "message": "TSK-1889: create TASK_ROUTER role"}, {"oid": "43ed441daf60d22a579d93fde840861770b4ede5", "committedDate": "2022-05-31 16:54:29 +0300", "message": "TSK-1812: Added details in task-history for claim/cancel"}, {"oid": "83890ddd16249632546e83011cf41759ddccb7da", "committedDate": "2022-07-19 15:27:44 +0200", "message": "TSK-1914: introduce IN_REVIEW and READY_FOR_REVIEW Task status"}, {"oid": "ef875dd42a58b55bace25fb4f599d84e4d06b59b", "committedDate": "2022-08-06 14:30:59 +0200", "message": "TSK-1915: Add requestReview functionality"}, {"oid": "cc32b10d82b7888ed2eae438100d2e26fb508f0c", "committedDate": "2022-08-09 13:19:02 +0200", "message": "TSK-1916: Add requestChanges functionality"}, {"oid": "1f9d20f76f98974ec6fe5fcc4657277f6eaaf5ae", "committedDate": "2022-08-10 12:18:14 +0200", "message": "TSK-1937: implemented AfterRequestReviewProvider"}, {"oid": "340236c4a26c7f9e6ed01d9b0f88b539eced56e3", "committedDate": "2022-08-11 12:17:08 +0200", "message": "TSK-1938: Add RequestChangesProvider"}, {"oid": "cf690bf6b5d8533ab73cef4de923797a1701a5c3", "committedDate": "2022-08-11 12:36:39 +0200", "message": "TSK-1941: implemented ReviewRequired SPI"}, {"oid": "1188f6396c31c6dd2d9f0eae5e6b3f5689a38966", "committedDate": "2022-08-20 17:46:27 +0200", "message": "TSK-1945: implemented BeforeRequestReview SPI"}, {"oid": "151d23d98d598b4a8da946655519664c7b7b4490", "committedDate": "2022-08-20 17:46:27 +0200", "message": "TSK-1945: minor cleanup of TaskServiceImpl"}, {"oid": "d8ffdb1824ffb6d67e417e798ad4ad9f8ee3a866", "committedDate": "2022-08-20 18:16:23 +0200", "message": "TSK-1944: Implemented BeforeRequestChanges SPI"}, {"oid": "3575b8aa17cb4168776b0377f4df81938c24e7b4", "committedDate": "2022-08-24 12:32:26 +0200", "message": "TSK-1926: Remove duplicate from TaskServiceImpl"}, {"oid": "dc9e2e1d5fd04dda9bde2a7838f2e068e66db984", "committedDate": "2022-10-20 21:49:16 +0200", "message": "TSK-1967: make owner of Task updatable when Task is 'READY_FOR_REVIEW'"}, {"oid": "f25b6eb550bc0f9e56c9a7953d5f2d3fbfa3e0d0", "committedDate": "2023-02-09 14:18:56 +0100", "message": "fix resquestReview for an IN_REVIEW Task"}, {"oid": "291cc38ea671e3fd23d8296008192f63f9d73c32", "committedDate": "2023-02-13 08:00:43 +0100", "message": "TSK-1971 support for oracle databases (#2050)"}, {"oid": "8bfb7fae95ef4e4bf7609b6f8f552579f2f9fd2c", "committedDate": "2023-02-14 09:40:46 +0100", "message": "TSK-1977: fix setting ownerLongName while claiming"}, {"oid": "68eacbbc3e1ff9a0a6d667b25cb80ec88558bb06", "committedDate": "2023-02-14 13:57:06 +0100", "message": "TSK-1976: set ownerLongName during Task creation"}, {"oid": "61a5e32865fcbbaafa0bc0a09cb4218132cfd4a9", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-1987 immutable TaskanaEngineConfiguration"}, {"oid": "20d389a7d524c156b063dfc91589bb22bebea0d7", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-1992 remove unnecessary ParentExceptions"}, {"oid": "f9e6b268177eee452e04ef708d50a33be18305e7", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-1993 InvalidArgumentException extends TaskanaRuntimeException"}, {"oid": "4a42a35a212f6bd25839432f48ec813c106874fc", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-1972: calculates working time in any resolution"}, {"oid": "d21eb47ffea4c2c9fff8f1d3435b77b805d03508", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-2012: renamed Mismatched_Exceptions to NotAuthorizedExceptions"}, {"oid": "37280cc73b83e2d39ab4afddd40256719d64c50c", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-2013 selectAndClaim TasK return Optional and does not throw Exception if Task is notFound"}, {"oid": "55d939ca7b7720ab12f488ed8fc2a631ecc6f05c", "committedDate": "2023-03-13 19:02:53 +0100", "message": "format entire codebase with new google-java-format version"}, {"oid": "d96b1c392a0f9ecfe72e7d0bc0aadac17620133c", "committedDate": "2023-03-15 01:00:50 +0100", "message": "TSK-1991: rework of property names"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1Nzc5Mw==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398657793", "body": "Why this. We don't know if the task has been read, do we?", "bodyText": "Why this. We don't know if the task has been read, do we?", "bodyHTML": "<p dir=\"auto\">Why this. We don't know if the task has been read, do we?</p>", "author": "holgerhagen", "createdAt": "2020-03-26T15:20:47Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java", "diffHunk": "@@ -951,6 +979,29 @@ private TaskImpl checkConcurrencyAndSetModified(TaskImpl newTaskImpl, TaskImpl o\n     return newTaskImpl;\n   }\n \n+  private TaskImpl terminateCancelCommonActions(String taskId, TaskState targetState)\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n+    if (taskId == null || taskId.isEmpty()) {\n+      throw new TaskNotFoundException(taskId, String.format(TASK_WITH_ID_WAS_NOT_FOUND, taskId));\n+    }\n+    TaskImpl task = (TaskImpl) getTask(taskId);\n+    TaskState state = task.getState();\n+    if (state.isEndState()) {\n+      throw new InvalidStateException(String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n+    }\n+\n+    Instant now = Instant.now();\n+    task.setOwner(null);\n+    task.setModified(now);\n+    task.setCompleted(now);\n+    task.setClaimed(null);\n+    task.setRead(true);", "originalCommit": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc0OTM3Mw==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398749373", "bodyText": "ok, retained also the read timestamp", "author": "BerndBreier", "createdAt": "2020-03-26T17:18:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1Nzc5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "4c65a6087e83b85e44118a754cf749a23cac5250", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 382c3861a..47a6735b9 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -994,8 +994,6 @@ public class TaskServiceImpl implements TaskService {\n     task.setOwner(null);\n     task.setModified(now);\n     task.setCompleted(now);\n-    task.setClaimed(null);\n-    task.setRead(true);\n     task.setState(targetState);\n     taskMapper.update(task);\n     LOGGER.debug(\"Task '{}' cancelled by user '{}'.\", taskId, CurrentUserContext.getUserid());\n", "next_change": {"commit": "62d58b32c908be3bf05b5068497e4be5a20002e6", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 47a6735b9..fba7860b2 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -991,7 +991,6 @@ public class TaskServiceImpl implements TaskService {\n     }\n \n     Instant now = Instant.now();\n-    task.setOwner(null);\n     task.setModified(now);\n     task.setCompleted(now);\n     task.setState(targetState);\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "6bd6bd48386155644df0463edf8aeda473bd1a56", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 382c3861a..fba7860b2 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -991,11 +991,8 @@ public class TaskServiceImpl implements TaskService {\n     }\n \n     Instant now = Instant.now();\n-    task.setOwner(null);\n     task.setModified(now);\n     task.setCompleted(now);\n-    task.setClaimed(null);\n-    task.setRead(true);\n     task.setState(targetState);\n     taskMapper.update(task);\n     LOGGER.debug(\"Task '{}' cancelled by user '{}'.\", taskId, CurrentUserContext.getUserid());\n", "next_change": {"commit": "3b13b9a95e4d7d1cf172f22fa0f2679ff1c5f79b", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex fba7860b2..e4e8b398d 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -963,85 +755,23 @@ public class TaskServiceImpl implements TaskService {\n     return result;\n   }\n \n-  private TaskImpl checkConcurrencyAndSetModified(TaskImpl newTaskImpl, TaskImpl oldTaskImpl)\n-      throws ConcurrencyException {\n-    // TODO: not safe to rely only on different timestamps.\n-    // With fast execution below 1ms there will be no concurrencyException\n-    if (oldTaskImpl.getModified() != null\n-            && !oldTaskImpl.getModified().equals(newTaskImpl.getModified())\n-        || oldTaskImpl.getClaimed() != null\n-            && !oldTaskImpl.getClaimed().equals(newTaskImpl.getClaimed())\n-        || oldTaskImpl.getState() != null\n-            && !oldTaskImpl.getState().equals(newTaskImpl.getState())) {\n-      throw new ConcurrencyException(\"The task has already been updated by another user\");\n-    }\n-    newTaskImpl.setModified(Instant.now());\n-    return newTaskImpl;\n-  }\n-\n-  private TaskImpl terminateCancelCommonActions(String taskId, TaskState targetState)\n-      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n-    if (taskId == null || taskId.isEmpty()) {\n-      throw new TaskNotFoundException(taskId, String.format(TASK_WITH_ID_WAS_NOT_FOUND, taskId));\n-    }\n-    TaskImpl task = (TaskImpl) getTask(taskId);\n-    TaskState state = task.getState();\n-    if (state.isEndState()) {\n-      throw new InvalidStateException(String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n-    }\n-\n-    Instant now = Instant.now();\n-    task.setModified(now);\n-    task.setCompleted(now);\n-    task.setState(targetState);\n-    taskMapper.update(task);\n-    LOGGER.debug(\"Task '{}' cancelled by user '{}'.\", taskId, CurrentUserContext.getUserid());\n-    return task;\n-  }\n-\n-  private BulkOperationResults<String, TaskanaException> addExceptionsForTasksWhoseOwnerWasNotSet(\n-      String owner, List<MinimalTaskSummary> existingMinimalTaskSummaries) {\n-    BulkOperationResults<String, TaskanaException> bulkLog = new BulkOperationResults<>();\n-\n-    for (MinimalTaskSummary taskSummary : existingMinimalTaskSummaries) {\n-      if (!owner.equals(taskSummary.getOwner())) { // owner was not set\n-        if (!TaskState.READY.equals(taskSummary.getTaskState())) { // due to invalid state\n-          bulkLog.addError(\n-              taskSummary.getTaskId(),\n-              new InvalidStateException(\n-                  String.format(\n-                      TASK_WITH_ID_IS_NOT_READY,\n-                      taskSummary.getTaskId(),\n-                      taskSummary.getTaskState())));\n-        } else { // due to unknown reason\n-          bulkLog.addError(\n-              taskSummary.getTaskId(),\n-              new UpdateFailedException(\n-                  String.format(\"Could not set owner of Task %s .\", taskSummary.getTaskId())));\n-        }\n-      }\n-    }\n-    return bulkLog;\n-  }\n-\n   private Task claim(String taskId, boolean forceClaim)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException {\n     String userId = CurrentUserContext.getUserid();\n     LOGGER.debug(\n         \"entry to claim(id = {}, userId = {}, forceClaim = {})\", taskId, userId, forceClaim);\n-    TaskImpl task;\n+    TaskImpl task = null;\n     try {\n       taskanaEngine.openConnection();\n       task = (TaskImpl) getTask(taskId);\n       TaskState state = task.getState();\n-      if (!state.in(TaskState.READY, TaskState.CLAIMED)) {\n-        throw new InvalidStateException(\n-            String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n+      if (state == TaskState.COMPLETED) {\n+        throw new InvalidStateException(TASK_WITH_ID + taskId + IS_ALREADY_COMPLETED);\n       }\n       if (state == TaskState.CLAIMED && !forceClaim && !task.getOwner().equals(userId)) {\n         throw new InvalidOwnerException(\n-            String.format(TASK_WITH_ID_IS_ALREADY_CLAIMED_BY, taskId, task.getOwner()));\n+            TASK_WITH_ID + taskId + IS_ALREADY_CLAIMED_BY + task.getOwner() + \".\");\n       }\n       Instant now = Instant.now();\n       task.setOwner(userId);\n", "next_change": {"commit": "2ce7f86456f99d522e001080e9504ae4cd6a80f4", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex e4e8b398d..382c3861a 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -755,23 +963,88 @@ public class TaskServiceImpl implements TaskService {\n     return result;\n   }\n \n+  private TaskImpl checkConcurrencyAndSetModified(TaskImpl newTaskImpl, TaskImpl oldTaskImpl)\n+      throws ConcurrencyException {\n+    // TODO: not safe to rely only on different timestamps.\n+    // With fast execution below 1ms there will be no concurrencyException\n+    if (oldTaskImpl.getModified() != null\n+            && !oldTaskImpl.getModified().equals(newTaskImpl.getModified())\n+        || oldTaskImpl.getClaimed() != null\n+            && !oldTaskImpl.getClaimed().equals(newTaskImpl.getClaimed())\n+        || oldTaskImpl.getState() != null\n+            && !oldTaskImpl.getState().equals(newTaskImpl.getState())) {\n+      throw new ConcurrencyException(\"The task has already been updated by another user\");\n+    }\n+    newTaskImpl.setModified(Instant.now());\n+    return newTaskImpl;\n+  }\n+\n+  private TaskImpl terminateCancelCommonActions(String taskId, TaskState targetState)\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n+    if (taskId == null || taskId.isEmpty()) {\n+      throw new TaskNotFoundException(taskId, String.format(TASK_WITH_ID_WAS_NOT_FOUND, taskId));\n+    }\n+    TaskImpl task = (TaskImpl) getTask(taskId);\n+    TaskState state = task.getState();\n+    if (state.isEndState()) {\n+      throw new InvalidStateException(String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n+    }\n+\n+    Instant now = Instant.now();\n+    task.setOwner(null);\n+    task.setModified(now);\n+    task.setCompleted(now);\n+    task.setClaimed(null);\n+    task.setRead(true);\n+    task.setState(targetState);\n+    taskMapper.update(task);\n+    LOGGER.debug(\"Task '{}' cancelled by user '{}'.\", taskId, CurrentUserContext.getUserid());\n+    return task;\n+  }\n+\n+  private BulkOperationResults<String, TaskanaException> addExceptionsForTasksWhoseOwnerWasNotSet(\n+      String owner, List<MinimalTaskSummary> existingMinimalTaskSummaries) {\n+    BulkOperationResults<String, TaskanaException> bulkLog = new BulkOperationResults<>();\n+\n+    for (MinimalTaskSummary taskSummary : existingMinimalTaskSummaries) {\n+      if (!owner.equals(taskSummary.getOwner())) { // owner was not set\n+        if (!TaskState.READY.equals(taskSummary.getTaskState())) { // due to invalid state\n+          bulkLog.addError(\n+              taskSummary.getTaskId(),\n+              new InvalidStateException(\n+                  String.format(\n+                      TASK_WITH_ID_IS_NOT_READY,\n+                      taskSummary.getTaskId(),\n+                      taskSummary.getTaskState())));\n+        } else { // due to unknown reason\n+          bulkLog.addError(\n+              taskSummary.getTaskId(),\n+              new UpdateFailedException(\n+                  String.format(\"Could not set owner of Task %s .\", taskSummary.getTaskId())));\n+        }\n+      }\n+    }\n+    return bulkLog;\n+  }\n+\n   private Task claim(String taskId, boolean forceClaim)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException {\n     String userId = CurrentUserContext.getUserid();\n     LOGGER.debug(\n         \"entry to claim(id = {}, userId = {}, forceClaim = {})\", taskId, userId, forceClaim);\n-    TaskImpl task = null;\n+    TaskImpl task;\n     try {\n       taskanaEngine.openConnection();\n       task = (TaskImpl) getTask(taskId);\n       TaskState state = task.getState();\n-      if (state == TaskState.COMPLETED) {\n-        throw new InvalidStateException(TASK_WITH_ID + taskId + IS_ALREADY_COMPLETED);\n+      if (!state.isInStates(TaskState.READY, TaskState.CLAIMED)) {\n+        throw new InvalidStateException(\n+            String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n       }\n       if (state == TaskState.CLAIMED && !forceClaim && !task.getOwner().equals(userId)) {\n         throw new InvalidOwnerException(\n-            TASK_WITH_ID + taskId + IS_ALREADY_CLAIMED_BY + task.getOwner() + \".\");\n+            String.format(TASK_WITH_ID_IS_ALREADY_CLAIMED_BY, taskId, task.getOwner()));\n       }\n       Instant now = Instant.now();\n       task.setOwner(userId);\n", "next_change": {"commit": "6f12677b74a36ec04e282def79e8b549d48c1988", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 382c3861a..5285ea062 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1037,21 +1182,10 @@ public class TaskServiceImpl implements TaskService {\n     try {\n       taskanaEngine.openConnection();\n       task = (TaskImpl) getTask(taskId);\n-      TaskState state = task.getState();\n-      if (!state.isInStates(TaskState.READY, TaskState.CLAIMED)) {\n-        throw new InvalidStateException(\n-            String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n-      }\n-      if (state == TaskState.CLAIMED && !forceClaim && !task.getOwner().equals(userId)) {\n-        throw new InvalidOwnerException(\n-            String.format(TASK_WITH_ID_IS_ALREADY_CLAIMED_BY, taskId, task.getOwner()));\n-      }\n       Instant now = Instant.now();\n-      task.setOwner(userId);\n-      task.setModified(now);\n-      task.setClaimed(now);\n-      task.setRead(true);\n-      task.setState(TaskState.CLAIMED);\n+\n+      checkPreconditionsForClaimTask(task, forceClaim);\n+      claimActionsOnTask(task, userId, now);\n       taskMapper.update(task);\n       LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n       if (HistoryEventProducer.isHistoryEnabled()) {\n", "next_change": {"commit": "d8ad7a7fb96e7d07e5f93e202cd84e03e5c1944a", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 5285ea062..f6299c27e 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1188,8 +1217,12 @@ public class TaskServiceImpl implements TaskService {\n       claimActionsOnTask(task, userId, now);\n       taskMapper.update(task);\n       LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n-      if (HistoryEventProducer.isHistoryEnabled()) {\n-        historyEventProducer.createEvent(new ClaimedEvent(task, CurrentUserContext.getUserid()));\n+      if (HistoryEventManager.isHistoryEnabled()) {\n+        historyEventManager.createEvent(\n+            new ClaimedEvent(\n+                IdGenerator.generateWithPrefix(ID_PREFIX_HISTORY_EVENT),\n+                task,\n+                CurrentUserContext.getUserid()));\n       }\n     } finally {\n       taskanaEngine.returnConnection();\n", "next_change": {"commit": "29ba5fe418ad6702648d7427d5c18b3fd06bbe83", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex f6299c27e..e11e382dc 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1219,7 +1186,7 @@ public class TaskServiceImpl implements TaskService {\n       LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n       if (HistoryEventManager.isHistoryEnabled()) {\n         historyEventManager.createEvent(\n-            new ClaimedEvent(\n+            new TaskClaimedEvent(\n                 IdGenerator.generateWithPrefix(ID_PREFIX_HISTORY_EVENT),\n                 task,\n                 CurrentUserContext.getUserid()));\n", "next_change": {"commit": "44cb21b5aec13e6548a0546dc8eb221fb1cd29ad", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex e11e382dc..5504cb522 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1189,7 +1200,7 @@ public class TaskServiceImpl implements TaskService {\n             new TaskClaimedEvent(\n                 IdGenerator.generateWithPrefix(ID_PREFIX_HISTORY_EVENT),\n                 task,\n-                CurrentUserContext.getUserid()));\n+                taskanaEngine.getEngine().getCurrentUserContext().getUserid()));\n       }\n     } finally {\n       taskanaEngine.returnConnection();\n", "next_change": {"commit": "b23c6873db22e24a0b713441317fec405db55708", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 5504cb522..fd50b0ae2 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1198,7 +1181,7 @@ public class TaskServiceImpl implements TaskService {\n       if (HistoryEventManager.isHistoryEnabled()) {\n         historyEventManager.createEvent(\n             new TaskClaimedEvent(\n-                IdGenerator.generateWithPrefix(ID_PREFIX_HISTORY_EVENT),\n+                IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n                 task,\n                 taskanaEngine.getEngine().getCurrentUserContext().getUserid()));\n       }\n", "next_change": {"commit": "bfcabea61048ccb21a591e0c4f1f8efecc7636b4", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex fd50b0ae2..ad45e047c 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1177,7 +1143,9 @@ public class TaskServiceImpl implements TaskService {\n       checkPreconditionsForClaimTask(task, forceClaim);\n       claimActionsOnTask(task, userId, now);\n       taskMapper.update(task);\n-      LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n+      if (LOGGER.isDebugEnabled()) {\n+        LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n+      }\n       if (HistoryEventManager.isHistoryEnabled()) {\n         historyEventManager.createEvent(\n             new TaskClaimedEvent(\n", "next_change": {"commit": "fb4234b6f180423c4789ba904709fd78edf7bf4f", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex ad45e047c..adc9804fa 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1146,7 +1115,7 @@ public class TaskServiceImpl implements TaskService {\n       if (LOGGER.isDebugEnabled()) {\n         LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n       }\n-      if (HistoryEventManager.isHistoryEnabled()) {\n+      if (historyEventManager.isEnabled()) {\n         historyEventManager.createEvent(\n             new TaskClaimedEvent(\n                 IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n", "next_change": {"commit": "43ed441daf60d22a579d93fde840861770b4ede5", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex adc9804fa..96da61dd7 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1116,11 +1175,15 @@ public class TaskServiceImpl implements TaskService {\n         LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n       }\n       if (historyEventManager.isEnabled()) {\n+        String changeDetails =\n+            ObjectAttributeChangeDetector.determineChangesInAttributes(oldTask, task);\n+\n         historyEventManager.createEvent(\n             new TaskClaimedEvent(\n                 IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n                 task,\n-                taskanaEngine.getEngine().getCurrentUserContext().getUserid()));\n+                taskanaEngine.getEngine().getCurrentUserContext().getUserid(),\n+                changeDetails));\n       }\n     } finally {\n       taskanaEngine.returnConnection();\n", "next_change": {"commit": "ef875dd42a58b55bace25fb4f599d84e4d06b59b", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 96da61dd7..0b2c71e16 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1191,12 +1204,63 @@ public class TaskServiceImpl implements TaskService {\n     return task;\n   }\n \n+  private Task requestReview(String taskId, boolean force)\n+      throws TaskNotFoundException, NotAuthorizedException, InvalidTaskStateException,\n+          InvalidOwnerException {\n+    String userId = taskanaEngine.getEngine().getCurrentUserContext().getUserid();\n+    TaskImpl task;\n+    try {\n+      taskanaEngine.openConnection();\n+      task = (TaskImpl) getTask(taskId);\n+\n+      TaskImpl oldTask = duplicateTaskExactly(task);\n+\n+      if (force && task.getState().isEndState()) {\n+        throw new InvalidTaskStateException(\n+            task.getId(), task.getState(), EnumUtil.allValuesExceptFor(TaskState.END_STATES));\n+      }\n+      if (!force && task.getState() != TaskState.CLAIMED) {\n+        throw new InvalidTaskStateException(task.getId(), task.getState(), TaskState.CLAIMED);\n+      }\n+      if (!force && !task.getOwner().equals(userId)) {\n+        throw new InvalidOwnerException(userId, task.getId());\n+      }\n+\n+      task.setState(TaskState.READY_FOR_REVIEW);\n+      task.setOwner(null);\n+      task.setModified(Instant.now());\n+\n+      taskMapper.update(task);\n+      if (LOGGER.isDebugEnabled()) {\n+        LOGGER.debug(\"Requested review for Task '{}' by user '{}'.\", taskId, userId);\n+      }\n+      if (historyEventManager.isEnabled()) {\n+        String changeDetails =\n+            ObjectAttributeChangeDetector.determineChangesInAttributes(oldTask, task);\n+\n+        historyEventManager.createEvent(\n+            new TaskRequestReviewEvent(\n+                IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n+                task,\n+                taskanaEngine.getEngine().getCurrentUserContext().getUserid(),\n+                changeDetails));\n+      }\n+    } finally {\n+      taskanaEngine.returnConnection();\n+    }\n+    return task;\n+  }\n+\n   private static void claimActionsOnTask(TaskSummaryImpl task, String userId, Instant now) {\n     task.setOwner(userId);\n     task.setModified(now);\n     task.setClaimed(now);\n     task.setRead(true);\n-    task.setState(TaskState.CLAIMED);\n+    if (Set.of(TaskState.READY_FOR_REVIEW, TaskState.IN_REVIEW).contains(task.getState())) {\n+      task.setState(TaskState.IN_REVIEW);\n+    } else {\n+      task.setState(TaskState.CLAIMED);\n+    }\n   }\n \n   private static void cancelClaimActionsOnTask(TaskSummaryImpl task, Instant now) {\n", "next_change": null}]}}]}}]}}, {"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex fd50b0ae2..ad45e047c 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1187,7 +1155,6 @@ public class TaskServiceImpl implements TaskService {\n       }\n     } finally {\n       taskanaEngine.returnConnection();\n-      LOGGER.debug(\"exit from claim()\");\n     }\n     return task;\n   }\n", "next_change": {"commit": "43ed441daf60d22a579d93fde840861770b4ede5", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex ad45e047c..96da61dd7 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1146,12 +1174,16 @@ public class TaskServiceImpl implements TaskService {\n       if (LOGGER.isDebugEnabled()) {\n         LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n       }\n-      if (HistoryEventManager.isHistoryEnabled()) {\n+      if (historyEventManager.isEnabled()) {\n+        String changeDetails =\n+            ObjectAttributeChangeDetector.determineChangesInAttributes(oldTask, task);\n+\n         historyEventManager.createEvent(\n             new TaskClaimedEvent(\n                 IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n                 task,\n-                taskanaEngine.getEngine().getCurrentUserContext().getUserid()));\n+                taskanaEngine.getEngine().getCurrentUserContext().getUserid(),\n+                changeDetails));\n       }\n     } finally {\n       taskanaEngine.returnConnection();\n", "next_change": {"commit": "ef875dd42a58b55bace25fb4f599d84e4d06b59b", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 96da61dd7..0b2c71e16 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1191,12 +1204,63 @@ public class TaskServiceImpl implements TaskService {\n     return task;\n   }\n \n+  private Task requestReview(String taskId, boolean force)\n+      throws TaskNotFoundException, NotAuthorizedException, InvalidTaskStateException,\n+          InvalidOwnerException {\n+    String userId = taskanaEngine.getEngine().getCurrentUserContext().getUserid();\n+    TaskImpl task;\n+    try {\n+      taskanaEngine.openConnection();\n+      task = (TaskImpl) getTask(taskId);\n+\n+      TaskImpl oldTask = duplicateTaskExactly(task);\n+\n+      if (force && task.getState().isEndState()) {\n+        throw new InvalidTaskStateException(\n+            task.getId(), task.getState(), EnumUtil.allValuesExceptFor(TaskState.END_STATES));\n+      }\n+      if (!force && task.getState() != TaskState.CLAIMED) {\n+        throw new InvalidTaskStateException(task.getId(), task.getState(), TaskState.CLAIMED);\n+      }\n+      if (!force && !task.getOwner().equals(userId)) {\n+        throw new InvalidOwnerException(userId, task.getId());\n+      }\n+\n+      task.setState(TaskState.READY_FOR_REVIEW);\n+      task.setOwner(null);\n+      task.setModified(Instant.now());\n+\n+      taskMapper.update(task);\n+      if (LOGGER.isDebugEnabled()) {\n+        LOGGER.debug(\"Requested review for Task '{}' by user '{}'.\", taskId, userId);\n+      }\n+      if (historyEventManager.isEnabled()) {\n+        String changeDetails =\n+            ObjectAttributeChangeDetector.determineChangesInAttributes(oldTask, task);\n+\n+        historyEventManager.createEvent(\n+            new TaskRequestReviewEvent(\n+                IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n+                task,\n+                taskanaEngine.getEngine().getCurrentUserContext().getUserid(),\n+                changeDetails));\n+      }\n+    } finally {\n+      taskanaEngine.returnConnection();\n+    }\n+    return task;\n+  }\n+\n   private static void claimActionsOnTask(TaskSummaryImpl task, String userId, Instant now) {\n     task.setOwner(userId);\n     task.setModified(now);\n     task.setClaimed(now);\n     task.setRead(true);\n-    task.setState(TaskState.CLAIMED);\n+    if (Set.of(TaskState.READY_FOR_REVIEW, TaskState.IN_REVIEW).contains(task.getState())) {\n+      task.setState(TaskState.IN_REVIEW);\n+    } else {\n+      task.setState(TaskState.CLAIMED);\n+    }\n   }\n \n   private static void cancelClaimActionsOnTask(TaskSummaryImpl task, Instant now) {\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6bd6bd48386155644df0463edf8aeda473bd1a56", "message": "Merge commit", "committedDate": null}, {"oid": "3b13b9a95e4d7d1cf172f22fa0f2679ff1c5f79b", "committedDate": "2020-02-03 11:41:02 +0100", "message": "TSK-991 after initial refactoring"}, {"oid": "27dd9b299b93ff13dc2d18f5803e2e314b1ac246", "committedDate": "2020-02-03 11:41:02 +0100", "message": "TSK-991 Restructuring- restructure history package"}, {"oid": "5815e38fa75956de6715569967afe7e7fc8dcd43", "committedDate": "2020-02-05 13:02:31 +0100", "message": "TSK-991: Fix Architecturtest and split DaysToWorkingDays converter for report and common"}, {"oid": "22ac25f5c9244bdc67752b7adcb9d98f4b8d6fa2", "committedDate": "2020-02-06 14:05:27 +0100", "message": "TSK-927 reserve a task via SetOwner"}, {"oid": "e308578ced577706e1f6994473e0e6252f647b9e", "committedDate": "2020-02-06 17:26:05 +0100", "message": "TSK-991: refactored report structure to meet api -> internal agreement"}, {"oid": "6eeff1ba22f5a07e459089fcb02074116ecb2d53", "committedDate": "2020-02-07 08:36:52 +0100", "message": "TSK-1065 Refactor TaskImpl"}, {"oid": "6c73ed18f205b350b1219e7f61f25f87ebe2e507", "committedDate": "2020-02-07 09:26:45 +0100", "message": "TSK-1064: refactored / simplified streams and boolean expressions"}, {"oid": "a5b3254c8dc8bbe193406920c50d9a81386adf4f", "committedDate": "2020-02-07 09:26:45 +0100", "message": "TSK-1064: refactored PrioDurationHolder -> generic Pair"}, {"oid": "f3f71a66b571f17cd1830dd19c6ff9aac186985a", "committedDate": "2020-02-11 09:48:03 +0100", "message": "TSK-1097"}, {"oid": "448d4fb8fc4586fc7bfa6b1083a22cc1453936a8", "committedDate": "2020-02-11 16:09:51 +0100", "message": "TSK-1107 Use userId-parameter in contructor of TaskanaHistoryEvent"}, {"oid": "5c7d38451ce7cbea2ad52d3b84be72d49c474c71", "committedDate": "2020-02-13 15:09:39 +0100", "message": "TSK-1094 introduce models package for */api and */internal"}, {"oid": "ddb12a6ad15965ad6e87d0920c975d425c575249", "committedDate": "2020-02-14 12:04:52 +0100", "message": "TSK-1095"}, {"oid": "20bd0922dbc332efcf4e94a0d487b077c95c5a85", "committedDate": "2020-02-26 14:48:50 +0100", "message": "TSK-1131 updateOwner on multiple tasks"}, {"oid": "7f93dd048e6b406ff43ad3b8007f3d149e015af6", "committedDate": "2020-02-26 14:48:50 +0100", "message": "TSK-1131 updateOwner Bulk - comments from Holger"}, {"oid": "02a6df6f73622e86684c6c30d8f320c84078b237", "committedDate": "2020-02-28 10:46:45 +0100", "message": "TSK-1139 Bulk update of Planned timestamp"}, {"oid": "3b7da72d24beb1e0f6d528f575b1ae7029f10e7f", "committedDate": "2020-03-17 11:54:26 +0100", "message": "TSK-1150 Java-API for the administration of comments for tasks"}, {"oid": "7d464bd6cde263ad9b674e5d796fcf91e4a727bf", "committedDate": "2020-03-17 11:54:26 +0100", "message": "TSK-1150 Comments from Bernd Breier"}, {"oid": "1291287419385725f59ed90a8e8960d57c8638e0", "committedDate": "2020-03-19 14:43:16 +0100", "message": "TSK-1143 UpdateTask with Planned sometimes fails"}, {"oid": "7deb9254113278ccf5872283c2abd202c3cf7af0", "committedDate": "2020-03-19 14:43:16 +0100", "message": "TSK-1143 UpdateTask planned - comments from Holger"}, {"oid": "f78e7616f65b1cf9575f246daf4bba856a3e8f1c", "committedDate": "2020-03-19 14:43:16 +0100", "message": "TSK-1143 Update Task PLANNED - Holger's comments"}, {"oid": "e470f8d200ef88c137645111f715b058ca9803e3", "committedDate": "2020-03-19 14:43:16 +0100", "message": "TSK-1143 even more comments from Holger"}, {"oid": "c2d974b02ea0182bfcda6f99d253b83372cf6335", "committedDate": "2020-03-26 08:47:03 +0100", "message": "TSK-1143 UpdateTask with Planned sometimes fails"}, {"oid": "87fd1af390f7c4abe4e4097f2e52a48bf1e68c5a", "committedDate": "2020-03-26 08:47:03 +0100", "message": "TSK-442 improve task refresh on classification update"}, {"oid": "7352a8a7280794299e8e0250c2b30744037a2a8b", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-1143 UpdateTask with Planned sometimes fails"}, {"oid": "28fbeb8a2e116f5178815049770d17ebc1a90c3d", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-442 improve task refresh on classification update"}, {"oid": "2ce7f86456f99d522e001080e9504ae4cd6a80f4", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-1160 TaskStates CANCELLED and TERMINATED"}, {"oid": "d6505284f780ec7a804adf7d6156726e85ddd4ef", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-1160 - terminate/cancel task Holger's comments"}, {"oid": "7fdea5bef22fcd17413094243c08d88ad6d28c3d", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-1160 - terminate/cancel task more comments from Holger"}, {"oid": "93a94f0458979e35cb92ee682be312532d1e5210", "committedDate": "2020-03-31 11:56:59 +0200", "message": "TSK-1150: added taskId as pathvariable to getTaskComment and deleteTaskComment"}, {"oid": "dffb139a822c55fcf12438e6e996fdef41b6f098", "committedDate": "2020-03-31 11:56:59 +0200", "message": "comments from Holger Hagen"}, {"oid": "d5674ed11a70cc488a9699387b90272318a22444", "committedDate": "2020-04-22 13:41:20 +0200", "message": "TSK-746 Add simple history event tracking to update and create task method"}, {"oid": "8442be7903dfc14f6bcdef2cb72f353c726db9e3", "committedDate": "2020-04-22 13:41:20 +0200", "message": "Comment from Mustapha Zorgati"}, {"oid": "3fea9ab975e55f14c9924baeb1740ef989aa66c0", "committedDate": "2020-05-06 08:54:37 +0200", "message": "TSK-1197: readded test case for testing the ordering of the databases H2, Postgress and DB2; remove Db2 10.5 travis job TSK-1197: build Postgres image with german collation"}, {"oid": "eb73c0670f522b6d1936b4323cf940640f504775", "committedDate": "2020-05-11 16:08:12 +0200", "message": "TSK-1192 Introduced new Task-Admin Role"}, {"oid": "1f13c2c33ac0ce2c8202a23f5d977c87717894a3", "committedDate": "2020-05-13 14:49:18 +0200", "message": "TSK-1195: Secure deleteTasks in TaskServiceImpl"}, {"oid": "8832876b9372c135c2c2fce88bc4820a1cab37d7", "committedDate": "2020-06-03 14:32:31 +0200", "message": "TSK-1247: Removed LoggerUtils and replaced its usages with the standard toString implementations"}, {"oid": "496da17b3eec2490b68b27c4192b32c02935a2f0", "committedDate": "2020-06-07 15:56:30 +0200", "message": "TSK-1257: refactored claimtasks in taskService and increased test coverage"}, {"oid": "6f12677b74a36ec04e282def79e8b549d48c1988", "committedDate": "2020-06-07 15:56:30 +0200", "message": "TSK-1257: implementes forceCompleteTasks"}, {"oid": "36adf71b904abe5730aba921d72a3c76cb4c5146", "committedDate": "2020-06-07 15:56:30 +0200", "message": "TSK-1257: replaced multiple helper methods with abstract helper method"}, {"oid": "a2318c267ea7f6d57cfffefc04c5285e66778fac", "committedDate": "2020-06-12 12:31:55 +0200", "message": "reformatted code"}, {"oid": "1dfe54c0b6fb05c6811573e38feba9212fdb6a9f", "committedDate": "2020-06-30 14:50:26 +0200", "message": "TSK-1275: Support select and claim in one API call"}, {"oid": "969d3eeff653d51eb7dcf5234aa4020333613ab3", "committedDate": "2020-06-30 14:50:26 +0200", "message": "review Findings"}, {"oid": "d8ad7a7fb96e7d07e5f93e202cd84e03e5c1944a", "committedDate": "2020-07-10 13:13:42 +0200", "message": "TSK-1250 On demand deletion of historical data"}, {"oid": "4bba93c5a98dcbe22dc86144b12507abce4b2be4", "committedDate": "2020-07-10 13:13:42 +0200", "message": "Review findings"}, {"oid": "abced36ecdc2edff824b2857da78581c94c40970", "committedDate": "2020-07-16 11:26:06 +0200", "message": "TSK-1336: Remove unnecessary warn logging in updateTask()"}, {"oid": "7cc5b00be617227dac2f8d1210554108d18bad4a", "committedDate": "2020-07-24 01:05:42 +0200", "message": "TSK-1345: replaced every customField API call with CustomField enums"}, {"oid": "b7237021e2e77fc0648e8117a725220d9560b3d2", "committedDate": "2020-08-05 16:48:33 +0200", "message": "TSK-1333: Add history events for cancelled/terminated tasks"}, {"oid": "29ba5fe418ad6702648d7427d5c18b3fd06bbe83", "committedDate": "2020-08-12 13:27:26 +0200", "message": "TSK-1335: Add workbasket history events"}, {"oid": "198572b6b15d375d99fd565d43cb99888b021e60", "committedDate": "2020-09-23 09:13:40 +0200", "message": "TSK-1390: Add SPI to allow task processing before creation"}, {"oid": "0e83abd0fda3d25585359a4655b1bc1e50429f39", "committedDate": "2020-09-23 09:13:40 +0200", "message": "TSK-1390: Review findings"}, {"oid": "44cb21b5aec13e6548a0546dc8eb221fb1cd29ad", "committedDate": "2020-10-09 10:25:54 +0200", "message": "TSK-1277: removed circular dependency between taskana-common and taskana-core"}, {"oid": "b23c6873db22e24a0b713441317fec405db55708", "committedDate": "2020-10-13 19:58:28 +0200", "message": "TSK-1335: removed last occurences of \"HEI\" prefix for history events"}, {"oid": "039dee4fb21035bcb9ca36e3c0becf59c03fed6c", "committedDate": "2020-11-02 09:41:48 +0100", "message": "TSK-1282: updated taskana-core to jdk11"}, {"oid": "28b3ce6f8a563bf74bf02382b77c3b817085f127", "committedDate": "2020-11-02 09:41:48 +0100", "message": "TSK-1282: replaced all usages of Arrays.asList with List.of"}, {"oid": "81b89e1c08b67fb383605fe061dec07fec4a557a", "committedDate": "2020-11-06 14:53:40 +0100", "message": "TSK-1441: Enable Admin to complete tasks already claimed by other users"}, {"oid": "ab672b27d4593dc7bf179d2e3c107a8a3ae0196f", "committedDate": "2021-01-05 15:27:27 +0100", "message": "TSK-1362: Fixed the test data to not include invalid owners for Workbaskets (#1379)"}, {"oid": "c6e82c1368da17762918b1ef5102974a302124af", "committedDate": "2021-02-02 08:16:07 +0100", "message": "TSK-1506: Fixed bug for Cleanup Jobs with more than 32767 tasks (#1457)"}, {"oid": "aa6d304b499a9df48d90ff3bfc375b25c5f00a71", "committedDate": "2021-02-03 09:34:22 +0100", "message": "TSK-1499: Fixed bug of also cleaning completed tasks with parentProcessId null/empty (#1394)"}, {"oid": "0119999380b40fdc0f69677f96650de5c81bd2a5", "committedDate": "2021-03-09 18:58:51 +0100", "message": "TSK-1538: Added transfer method with control setTransferFlag (#1513)"}, {"oid": "3ddcd2ae97ffea8bd479655e70d5182141d12220", "committedDate": "2021-04-23 17:28:11 +0200", "message": "TSK-1628: New DmnTaskRouter module"}, {"oid": "b8892020d98b905a2e4cbe12a344d93fcc68af25", "committedDate": "2021-05-19 10:29:13 +0200", "message": "TSK-795: Changed Exception when creating a Task with a non-empty taskId (#1575)"}, {"oid": "bfcabea61048ccb21a591e0c4f1f8efecc7636b4", "committedDate": "2021-05-20 09:41:58 +0200", "message": "TSK-1596: Automatic TraceLogging (#1577)"}, {"oid": "7636ec0b2a8e12ea5b3cff48f7b702472b603e5d", "committedDate": "2021-06-01 09:51:38 +0200", "message": "TSK-1501: TaskTransferrer cleaned and restructured (#1599)"}, {"oid": "b66e4d9f862a14fc740e1c25c00e80e81c74abe9", "committedDate": "2021-06-09 12:37:56 +0200", "message": "TSK-1642: now setting details attribute for TaskTransferHistoryEvent"}, {"oid": "1c83b7871f144cd07a912639b942d5938219e101", "committedDate": "2021-06-22 16:14:09 +0200", "message": "TSK-1646: Bugfix for creation / update of Task with invalid Attachment"}, {"oid": "34d2bbfa929ccaa9e9b93c173b8fa867154330bb", "committedDate": "2021-07-14 10:49:34 +0200", "message": "TSK-1647: Implemented an error key for every exception"}, {"oid": "8edb488bd3f854568dab1ee56c8d974fe63f95cd", "committedDate": "2021-07-14 10:49:34 +0200", "message": "TSK-1647: Implemented global frontend error handling using backend error keys"}, {"oid": "358e699f9f0bdf8505ff0f44ac0ad5803cdcb5c8", "committedDate": "2021-07-16 11:08:05 +0200", "message": "TSK-1664: fixed some code smells and redesigned RestHelper"}, {"oid": "99eba636a1ec363282153ae857f651d2c5d2e592", "committedDate": "2021-07-29 14:58:57 +0200", "message": "TSK-1674: Added received timestamp to task (#1638)"}, {"oid": "6da07b069aae2d41a5b9949ea69b249e9ff7903a", "committedDate": "2021-08-02 11:46:33 +0200", "message": "TSK-1647: minor improvements and fixes"}, {"oid": "dc9e3a25ce9aa317ace656ebe58bdcfefaa8c4b5", "committedDate": "2021-08-20 21:21:57 +0200", "message": "TSK-1686: Introduced an SPI for the individual calculation of priorities"}, {"oid": "54428045dd57a6d295c9a1529274b08246c731eb", "committedDate": "2021-08-30 14:18:38 +0200", "message": "TSK-1718: Performance optimization for TaskService#getTask and TaskQuery#list"}, {"oid": "e9a1f02c2e828a123b191cc031bd473ba0e51fe7", "committedDate": "2021-09-16 09:21:29 +0200", "message": "TSK-1633: created all new test API for improved test data generation"}, {"oid": "fb4234b6f180423c4789ba904709fd78edf7bf4f", "committedDate": "2021-09-21 16:35:58 +0200", "message": "TSK-1704: test API now restricting service providers to specific test"}, {"oid": "e264a203892c6d2111df4645abf7f373bf4ca86a", "committedDate": "2021-10-08 08:38:21 +0200", "message": "TSK-1726: Implemented option to include long name on Task / TaskComment / TaskHistoryEvent"}, {"oid": "c7742b3056f4c2d11ff4ddeef980e177bb82bd64", "committedDate": "2021-11-26 13:18:27 +0100", "message": "TSK-1775: reformatted entire backend code base"}, {"oid": "967e59e012f94e116f2b327b6c426f44ae1bcbee", "committedDate": "2022-02-25 10:23:40 +0100", "message": "TSK-1800: add secondary object references"}, {"oid": "4f48fe93c633e31304fa808a96c3477d78b33f2c", "committedDate": "2022-03-08 17:10:37 +0100", "message": "TSK-1807: renamed setCustomAttribute to setCustomField"}, {"oid": "93d0b27bb058a4f47218177136bce81f99103345", "committedDate": "2022-04-26 15:27:56 +0200", "message": "TSK-1831: dropped support for JDK8"}, {"oid": "1ae1df890848d22617cd10c611e5d496428db790", "committedDate": "2022-05-19 09:31:13 +0200", "message": "TSK-1889: create TASK_ROUTER role"}, {"oid": "43ed441daf60d22a579d93fde840861770b4ede5", "committedDate": "2022-05-31 16:54:29 +0300", "message": "TSK-1812: Added details in task-history for claim/cancel"}, {"oid": "83890ddd16249632546e83011cf41759ddccb7da", "committedDate": "2022-07-19 15:27:44 +0200", "message": "TSK-1914: introduce IN_REVIEW and READY_FOR_REVIEW Task status"}, {"oid": "ef875dd42a58b55bace25fb4f599d84e4d06b59b", "committedDate": "2022-08-06 14:30:59 +0200", "message": "TSK-1915: Add requestReview functionality"}, {"oid": "cc32b10d82b7888ed2eae438100d2e26fb508f0c", "committedDate": "2022-08-09 13:19:02 +0200", "message": "TSK-1916: Add requestChanges functionality"}, {"oid": "1f9d20f76f98974ec6fe5fcc4657277f6eaaf5ae", "committedDate": "2022-08-10 12:18:14 +0200", "message": "TSK-1937: implemented AfterRequestReviewProvider"}, {"oid": "340236c4a26c7f9e6ed01d9b0f88b539eced56e3", "committedDate": "2022-08-11 12:17:08 +0200", "message": "TSK-1938: Add RequestChangesProvider"}, {"oid": "cf690bf6b5d8533ab73cef4de923797a1701a5c3", "committedDate": "2022-08-11 12:36:39 +0200", "message": "TSK-1941: implemented ReviewRequired SPI"}, {"oid": "1188f6396c31c6dd2d9f0eae5e6b3f5689a38966", "committedDate": "2022-08-20 17:46:27 +0200", "message": "TSK-1945: implemented BeforeRequestReview SPI"}, {"oid": "151d23d98d598b4a8da946655519664c7b7b4490", "committedDate": "2022-08-20 17:46:27 +0200", "message": "TSK-1945: minor cleanup of TaskServiceImpl"}, {"oid": "d8ffdb1824ffb6d67e417e798ad4ad9f8ee3a866", "committedDate": "2022-08-20 18:16:23 +0200", "message": "TSK-1944: Implemented BeforeRequestChanges SPI"}, {"oid": "3575b8aa17cb4168776b0377f4df81938c24e7b4", "committedDate": "2022-08-24 12:32:26 +0200", "message": "TSK-1926: Remove duplicate from TaskServiceImpl"}, {"oid": "dc9e2e1d5fd04dda9bde2a7838f2e068e66db984", "committedDate": "2022-10-20 21:49:16 +0200", "message": "TSK-1967: make owner of Task updatable when Task is 'READY_FOR_REVIEW'"}, {"oid": "f25b6eb550bc0f9e56c9a7953d5f2d3fbfa3e0d0", "committedDate": "2023-02-09 14:18:56 +0100", "message": "fix resquestReview for an IN_REVIEW Task"}, {"oid": "291cc38ea671e3fd23d8296008192f63f9d73c32", "committedDate": "2023-02-13 08:00:43 +0100", "message": "TSK-1971 support for oracle databases (#2050)"}, {"oid": "8bfb7fae95ef4e4bf7609b6f8f552579f2f9fd2c", "committedDate": "2023-02-14 09:40:46 +0100", "message": "TSK-1977: fix setting ownerLongName while claiming"}, {"oid": "68eacbbc3e1ff9a0a6d667b25cb80ec88558bb06", "committedDate": "2023-02-14 13:57:06 +0100", "message": "TSK-1976: set ownerLongName during Task creation"}, {"oid": "61a5e32865fcbbaafa0bc0a09cb4218132cfd4a9", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-1987 immutable TaskanaEngineConfiguration"}, {"oid": "20d389a7d524c156b063dfc91589bb22bebea0d7", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-1992 remove unnecessary ParentExceptions"}, {"oid": "f9e6b268177eee452e04ef708d50a33be18305e7", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-1993 InvalidArgumentException extends TaskanaRuntimeException"}, {"oid": "4a42a35a212f6bd25839432f48ec813c106874fc", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-1972: calculates working time in any resolution"}, {"oid": "d21eb47ffea4c2c9fff8f1d3435b77b805d03508", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-2012: renamed Mismatched_Exceptions to NotAuthorizedExceptions"}, {"oid": "37280cc73b83e2d39ab4afddd40256719d64c50c", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-2013 selectAndClaim TasK return Optional and does not throw Exception if Task is notFound"}, {"oid": "55d939ca7b7720ab12f488ed8fc2a631ecc6f05c", "committedDate": "2023-03-13 19:02:53 +0100", "message": "format entire codebase with new google-java-format version"}, {"oid": "d96b1c392a0f9ecfe72e7d0bc0aadac17620133c", "committedDate": "2023-03-15 01:00:50 +0100", "message": "TSK-1991: rework of property names"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2MzMyMQ==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398663321", "body": "Maybe we should add an assertion isEqualTo(5) before cancelTask to make it more clear?", "bodyText": "Maybe we should add an assertion isEqualTo(5) before cancelTask to make it more clear?", "bodyHTML": "<p dir=\"auto\">Maybe we should add an assertion isEqualTo(5) before cancelTask to make it more clear?</p>", "author": "holgerhagen", "createdAt": "2020-03-26T15:27:45Z", "path": "lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package acceptance.task;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import acceptance.AbstractAccTest;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import pro.taskana.common.api.exceptions.NotAuthorizedException;\n+import pro.taskana.security.JaasExtension;\n+import pro.taskana.security.WithAccessId;\n+import pro.taskana.task.api.TaskService;\n+import pro.taskana.task.api.TaskState;\n+import pro.taskana.task.api.exceptions.InvalidStateException;\n+import pro.taskana.task.api.exceptions.TaskNotFoundException;\n+import pro.taskana.task.api.models.Task;\n+import pro.taskana.task.api.models.TaskSummary;\n+\n+\n+/** Acceptance tests for all claim and complete scenarios. */\n+@ExtendWith(JaasExtension.class)\n+class CancelTaskAccTest extends AbstractAccTest {\n+  private TaskService taskService;\n+\n+  CancelTaskAccTest() {\n+    super();\n+    taskService = taskanaEngine.getTaskService();\n+  }\n+\n+  @BeforeEach\n+  public static void setupTest() throws Exception {\n+    resetDb(false);\n+  }\n+\n+  @WithAccessId(\n+      userName = \"user_1_1\",\n+      groupNames = {\"group_1\"})\n+  @Test\n+  void testQeryCancelledTasks() {\n+    List<TaskSummary> taskSummaries =\n+        taskService.createTaskQuery().stateIn(TaskState.CANCELLED).list();\n+    assertThat(taskSummaries.size()).isEqualTo(5);\n+  }\n+\n+  @WithAccessId(\n+      userName = \"admin\",\n+      groupNames = {\"group_1\"})\n+  @Test\n+  void testCancelReadyTask()\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n+    List<TaskSummary> taskSummaries = taskService.createTaskQuery().stateIn(TaskState.READY).list();\n+    assertThat(taskSummaries.size()).isEqualTo(47);\n+    Task task = taskService.getTask(taskSummaries.get(0).getId());\n+    taskService.cancelTask(taskSummaries.get(0).getId());\n+    long numTasks = taskService.createTaskQuery().stateIn(TaskState.READY).count();\n+    assertThat(numTasks).isEqualTo(46);\n+    numTasks = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n+    assertThat(numTasks).isEqualTo(6);\n+  }\n+\n+  @WithAccessId(\n+      userName = \"admin\",\n+      groupNames = {\"group_1\"})\n+  @Test\n+  void testCancelClaimedTask()\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n+    List<TaskSummary> taskSummaries =\n+        taskService.createTaskQuery().stateIn(TaskState.CLAIMED).list();\n+    assertThat(taskSummaries.size()).isEqualTo(19);\n+    Task task = taskService.getTask(taskSummaries.get(0).getId());\n+    taskService.cancelTask(taskSummaries.get(0).getId());\n+    long numTasks = taskService.createTaskQuery().stateIn(TaskState.CLAIMED).count();\n+    assertThat(numTasks).isEqualTo(18);\n+    numTasks = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n+    assertThat(numTasks).isEqualTo(6);", "originalCommit": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc1NDgzNQ==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398754835", "bodyText": "Done", "author": "BerndBreier", "createdAt": "2020-03-26T17:25:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2MzMyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "4c65a6087e83b85e44118a754cf749a23cac5250", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex 0c9a90579..97d4bda87 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -62,20 +60,23 @@ class CancelTaskAccTest extends AbstractAccTest {\n   }\n \n   @WithAccessId(\n-      userName = \"admin\",\n+      userName = \"user_1_2\",\n       groupNames = {\"group_1\"})\n   @Test\n   void testCancelClaimedTask()\n       throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n     List<TaskSummary> taskSummaries =\n         taskService.createTaskQuery().stateIn(TaskState.CLAIMED).list();\n-    assertThat(taskSummaries.size()).isEqualTo(19);\n-    Task task = taskService.getTask(taskSummaries.get(0).getId());\n+    assertThat(taskSummaries.size()).isEqualTo(16);\n+\n+    long numTasksCancelled = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n+    assertThat(numTasksCancelled).isEqualTo(5);\n+\n     taskService.cancelTask(taskSummaries.get(0).getId());\n-    long numTasks = taskService.createTaskQuery().stateIn(TaskState.CLAIMED).count();\n-    assertThat(numTasks).isEqualTo(18);\n-    numTasks = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n-    assertThat(numTasks).isEqualTo(6);\n+    long numTasksClaimed = taskService.createTaskQuery().stateIn(TaskState.CLAIMED).count();\n+    assertThat(numTasksClaimed).isEqualTo(15);\n+    numTasksCancelled = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n+    assertThat(numTasksCancelled).isEqualTo(6);\n   }\n \n   @WithAccessId(\n", "next_change": null}]}, "revised_code_in_main": {"commit": "6bd6bd48386155644df0463edf8aeda473bd1a56", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex 0c9a90579..97d4bda87 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -62,20 +60,23 @@ class CancelTaskAccTest extends AbstractAccTest {\n   }\n \n   @WithAccessId(\n-      userName = \"admin\",\n+      userName = \"user_1_2\",\n       groupNames = {\"group_1\"})\n   @Test\n   void testCancelClaimedTask()\n       throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n     List<TaskSummary> taskSummaries =\n         taskService.createTaskQuery().stateIn(TaskState.CLAIMED).list();\n-    assertThat(taskSummaries.size()).isEqualTo(19);\n-    Task task = taskService.getTask(taskSummaries.get(0).getId());\n+    assertThat(taskSummaries.size()).isEqualTo(16);\n+\n+    long numTasksCancelled = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n+    assertThat(numTasksCancelled).isEqualTo(5);\n+\n     taskService.cancelTask(taskSummaries.get(0).getId());\n-    long numTasks = taskService.createTaskQuery().stateIn(TaskState.CLAIMED).count();\n-    assertThat(numTasks).isEqualTo(18);\n-    numTasks = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n-    assertThat(numTasks).isEqualTo(6);\n+    long numTasksClaimed = taskService.createTaskQuery().stateIn(TaskState.CLAIMED).count();\n+    assertThat(numTasksClaimed).isEqualTo(15);\n+    numTasksCancelled = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n+    assertThat(numTasksCancelled).isEqualTo(6);\n   }\n \n   @WithAccessId(\n", "next_change": {"commit": "2ce7f86456f99d522e001080e9504ae4cd6a80f4", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex 97d4bda87..0c9a90579 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -60,23 +62,20 @@ class CancelTaskAccTest extends AbstractAccTest {\n   }\n \n   @WithAccessId(\n-      userName = \"user_1_2\",\n+      userName = \"admin\",\n       groupNames = {\"group_1\"})\n   @Test\n   void testCancelClaimedTask()\n       throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n     List<TaskSummary> taskSummaries =\n         taskService.createTaskQuery().stateIn(TaskState.CLAIMED).list();\n-    assertThat(taskSummaries.size()).isEqualTo(16);\n-\n-    long numTasksCancelled = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n-    assertThat(numTasksCancelled).isEqualTo(5);\n-\n+    assertThat(taskSummaries.size()).isEqualTo(19);\n+    Task task = taskService.getTask(taskSummaries.get(0).getId());\n     taskService.cancelTask(taskSummaries.get(0).getId());\n-    long numTasksClaimed = taskService.createTaskQuery().stateIn(TaskState.CLAIMED).count();\n-    assertThat(numTasksClaimed).isEqualTo(15);\n-    numTasksCancelled = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n-    assertThat(numTasksCancelled).isEqualTo(6);\n+    long numTasks = taskService.createTaskQuery().stateIn(TaskState.CLAIMED).count();\n+    assertThat(numTasks).isEqualTo(18);\n+    numTasks = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n+    assertThat(numTasks).isEqualTo(6);\n   }\n \n   @WithAccessId(\n", "next_change": {"commit": "d6505284f780ec7a804adf7d6156726e85ddd4ef", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex 0c9a90579..97d4bda87 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -62,20 +60,23 @@ class CancelTaskAccTest extends AbstractAccTest {\n   }\n \n   @WithAccessId(\n-      userName = \"admin\",\n+      userName = \"user_1_2\",\n       groupNames = {\"group_1\"})\n   @Test\n   void testCancelClaimedTask()\n       throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n     List<TaskSummary> taskSummaries =\n         taskService.createTaskQuery().stateIn(TaskState.CLAIMED).list();\n-    assertThat(taskSummaries.size()).isEqualTo(19);\n-    Task task = taskService.getTask(taskSummaries.get(0).getId());\n+    assertThat(taskSummaries.size()).isEqualTo(16);\n+\n+    long numTasksCancelled = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n+    assertThat(numTasksCancelled).isEqualTo(5);\n+\n     taskService.cancelTask(taskSummaries.get(0).getId());\n-    long numTasks = taskService.createTaskQuery().stateIn(TaskState.CLAIMED).count();\n-    assertThat(numTasks).isEqualTo(18);\n-    numTasks = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n-    assertThat(numTasks).isEqualTo(6);\n+    long numTasksClaimed = taskService.createTaskQuery().stateIn(TaskState.CLAIMED).count();\n+    assertThat(numTasksClaimed).isEqualTo(15);\n+    numTasksCancelled = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n+    assertThat(numTasksCancelled).isEqualTo(6);\n   }\n \n   @WithAccessId(\n", "next_change": {"commit": "2c5634c917e2246d56aff6472f7d7abc0a12a96b", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex 97d4bda87..cb1fdadce 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -83,16 +83,12 @@ class CancelTaskAccTest extends AbstractAccTest {\n       userName = \"admin\",\n       groupNames = {\"group_1\"})\n   @Test\n-  void testCancelCompletedTask()\n-      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n+  void testCancelCompletedTask() {\n     List<TaskSummary> taskSummaries =\n         taskService.createTaskQuery().stateIn(TaskState.COMPLETED).list();\n-    assertThat(taskSummaries.size()).isEqualTo(7);\n+    assertThat(taskSummaries).hasSize(7);\n \n-    ThrowingCallable taskanaCall =\n-        () -> {\n-          taskService.cancelTask(taskSummaries.get(0).getId());\n-        };\n+    ThrowingCallable taskanaCall = () -> taskService.cancelTask(taskSummaries.get(0).getId());\n \n     assertThatThrownBy(taskanaCall).isInstanceOf(InvalidStateException.class);\n   }\n", "next_change": {"commit": "ac5f04ff3bce8c8b933c0720ec2ca814f2a9fb17", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex cb1fdadce..631ad4817 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -93,9 +85,7 @@ class CancelTaskAccTest extends AbstractAccTest {\n     assertThatThrownBy(taskanaCall).isInstanceOf(InvalidStateException.class);\n   }\n \n-  @WithAccessId(\n-      userName = \"user_1_2\",\n-      groupNames = {\"group_1\"})\n+  @WithAccessId(user = \"user_1_2\", groups = \"group_1\")\n   @Test\n   void testCancelTerminatedTask() {\n     List<TaskSummary> taskSummaries =\n", "next_change": {"commit": "cc4efaa1cdd708366adea79d631b8aa5ccc013a8", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex 631ad4817..91e8d26d1 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -85,7 +103,7 @@ class CancelTaskAccTest extends AbstractAccTest {\n     assertThatThrownBy(taskanaCall).isInstanceOf(InvalidStateException.class);\n   }\n \n-  @WithAccessId(user = \"user_1_2\", groups = \"group_1\")\n+  @WithAccessId(user = \"user-1-2\", groups = \"group_1\")\n   @Test\n   void testCancelTerminatedTask() {\n     List<TaskSummary> taskSummaries =\n", "next_change": {"commit": "6952ce8959a8711f72c6319565edbee90a8b1cbd", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex 91e8d26d1..6c1fe7ff9 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -103,7 +103,7 @@ class CancelTaskAccTest extends AbstractAccTest {\n     assertThatThrownBy(taskanaCall).isInstanceOf(InvalidStateException.class);\n   }\n \n-  @WithAccessId(user = \"user-1-2\", groups = \"group_1\")\n+  @WithAccessId(user = \"user-1-2\", groups = \"group-1\")\n   @Test\n   void testCancelTerminatedTask() {\n     List<TaskSummary> taskSummaries =\n", "next_change": {"commit": "c57bbe07c7ca3ee56366c22de2375645a6371747", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex 6c1fe7ff9..a014e1dae 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -103,7 +101,7 @@ class CancelTaskAccTest extends AbstractAccTest {\n     assertThatThrownBy(taskanaCall).isInstanceOf(InvalidStateException.class);\n   }\n \n-  @WithAccessId(user = \"user-1-2\", groups = \"group-1\")\n+  @WithAccessId(user = \"user-1-2\")\n   @Test\n   void testCancelTerminatedTask() {\n     List<TaskSummary> taskSummaries =\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6bd6bd48386155644df0463edf8aeda473bd1a56", "message": "Merge commit", "committedDate": null}, {"oid": "2ce7f86456f99d522e001080e9504ae4cd6a80f4", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-1160 TaskStates CANCELLED and TERMINATED"}, {"oid": "d6505284f780ec7a804adf7d6156726e85ddd4ef", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-1160 - terminate/cancel task Holger's comments"}, {"oid": "2c5634c917e2246d56aff6472f7d7abc0a12a96b", "committedDate": "2020-04-20 08:10:16 +0200", "message": "TSK-1180: migrate from JUnit 5 assertions to assertJ assertions"}, {"oid": "ac5f04ff3bce8c8b933c0720ec2ca814f2a9fb17", "committedDate": "2020-04-27 11:06:12 +0200", "message": "TSK-1207: extended JaasExtension to run with multiple access ids"}, {"oid": "3ce41b224efde509aea998be3ace278832b1d562", "committedDate": "2020-05-06 10:18:42 +0200", "message": "TSK-1182: refined architecture tests"}, {"oid": "eb73c0670f522b6d1936b4323cf940640f504775", "committedDate": "2020-05-11 16:08:12 +0200", "message": "TSK-1192 Introduced new Task-Admin Role"}, {"oid": "baf794518cbc494b85c190c05af97bd8b84ddb02", "committedDate": "2020-05-11 16:08:12 +0200", "message": "Usage of the new TestTemplate-feature"}, {"oid": "c6755b35b7226f4989aeea25ceeb3e18204fed45", "committedDate": "2020-05-22 03:25:57 +0200", "message": "TSK-1244: added due/planned logic for SLA P0D"}, {"oid": "cc4efaa1cdd708366adea79d631b8aa5ccc013a8", "committedDate": "2020-06-05 20:03:15 +0200", "message": "TSK-1210: Replaced LoginModule with Embedded Spring LDAP"}, {"oid": "6952ce8959a8711f72c6319565edbee90a8b1cbd", "committedDate": "2020-06-07 15:56:30 +0200", "message": "TSK-1210: replaced group names with new group names"}, {"oid": "c57bbe07c7ca3ee56366c22de2375645a6371747", "committedDate": "2020-06-22 16:05:19 +0200", "message": "TSK-1283: replaced usernames with - instead of _"}, {"oid": "ec483ab21cbe35f0e0ec608b109c47a3438abb48", "committedDate": "2020-07-06 18:02:39 +0200", "message": "TSK-1318: replaced all declared Exceptions with Exception.class in all our test classes"}, {"oid": "d8ad7a7fb96e7d07e5f93e202cd84e03e5c1944a", "committedDate": "2020-07-10 13:13:42 +0200", "message": "TSK-1250 On demand deletion of historical data"}, {"oid": "47aa60033faf81caaab930410972bdc7bf7d6e05", "committedDate": "2020-10-09 10:25:54 +0200", "message": "TSK-1277: moved JaasExtension and all its necessary classes to common modules"}, {"oid": "de57596ba8e816d3e751b21c949a3fe132b314f0", "committedDate": "2020-12-18 11:29:10 +0100", "message": "TSK-1436: reworked review comments."}, {"oid": "7636ec0b2a8e12ea5b3cff48f7b702472b603e5d", "committedDate": "2021-06-01 09:51:38 +0200", "message": "TSK-1501: TaskTransferrer cleaned and restructured (#1599)"}, {"oid": "e264a203892c6d2111df4645abf7f373bf4ca86a", "committedDate": "2021-10-08 08:38:21 +0200", "message": "TSK-1726: Implemented option to include long name on Task / TaskComment / TaskHistoryEvent"}, {"oid": "a0fe4ea468f273e2e96aab4cb40407a64a2263f0", "committedDate": "2022-04-05 12:32:50 +0200", "message": "TSK-1814: structured acceptance tests in packages"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2NDU5OA==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398664598", "body": "Is it a good idea to do all these tests as admin?", "bodyText": "Is it a good idea to do all these tests as admin?", "bodyHTML": "<p dir=\"auto\">Is it a good idea to do all these tests as admin?</p>", "author": "holgerhagen", "createdAt": "2020-03-26T15:29:16Z", "path": "lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package acceptance.task;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import acceptance.AbstractAccTest;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import pro.taskana.common.api.exceptions.NotAuthorizedException;\n+import pro.taskana.security.JaasExtension;\n+import pro.taskana.security.WithAccessId;\n+import pro.taskana.task.api.TaskService;\n+import pro.taskana.task.api.TaskState;\n+import pro.taskana.task.api.exceptions.InvalidStateException;\n+import pro.taskana.task.api.exceptions.TaskNotFoundException;\n+import pro.taskana.task.api.models.Task;\n+import pro.taskana.task.api.models.TaskSummary;\n+\n+\n+/** Acceptance tests for all claim and complete scenarios. */\n+@ExtendWith(JaasExtension.class)\n+class CancelTaskAccTest extends AbstractAccTest {\n+  private TaskService taskService;\n+\n+  CancelTaskAccTest() {\n+    super();\n+    taskService = taskanaEngine.getTaskService();\n+  }\n+\n+  @BeforeEach\n+  public static void setupTest() throws Exception {\n+    resetDb(false);\n+  }\n+\n+  @WithAccessId(\n+      userName = \"user_1_1\",\n+      groupNames = {\"group_1\"})\n+  @Test\n+  void testQeryCancelledTasks() {\n+    List<TaskSummary> taskSummaries =\n+        taskService.createTaskQuery().stateIn(TaskState.CANCELLED).list();\n+    assertThat(taskSummaries.size()).isEqualTo(5);\n+  }\n+\n+  @WithAccessId(\n+      userName = \"admin\",", "originalCommit": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc2NjMwMQ==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398766301", "bodyText": "Changed it ...", "author": "BerndBreier", "createdAt": "2020-03-26T17:41:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2NDU5OA=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "2c5634c917e2246d56aff6472f7d7abc0a12a96b", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex 0c9a90579..cb1fdadce 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -42,7 +41,7 @@ class CancelTaskAccTest extends AbstractAccTest {\n   void testQeryCancelledTasks() {\n     List<TaskSummary> taskSummaries =\n         taskService.createTaskQuery().stateIn(TaskState.CANCELLED).list();\n-    assertThat(taskSummaries.size()).isEqualTo(5);\n+    assertThat(taskSummaries).hasSize(5);\n   }\n \n   @WithAccessId(\n", "next_change": {"commit": "ac5f04ff3bce8c8b933c0720ec2ca814f2a9fb17", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex cb1fdadce..631ad4817 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -44,9 +42,7 @@ class CancelTaskAccTest extends AbstractAccTest {\n     assertThat(taskSummaries).hasSize(5);\n   }\n \n-  @WithAccessId(\n-      userName = \"admin\",\n-      groupNames = {\"group_1\"})\n+  @WithAccessId(user = \"admin\", groups = \"group_1\")\n   @Test\n   void testCancelReadyTask()\n       throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n", "next_change": {"commit": "6952ce8959a8711f72c6319565edbee90a8b1cbd", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex 631ad4817..6c1fe7ff9 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -42,7 +46,7 @@ class CancelTaskAccTest extends AbstractAccTest {\n     assertThat(taskSummaries).hasSize(5);\n   }\n \n-  @WithAccessId(user = \"admin\", groups = \"group_1\")\n+  @WithAccessId(user = \"admin\", groups = \"group-1\")\n   @Test\n   void testCancelReadyTask()\n       throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n", "next_change": {"commit": "c57bbe07c7ca3ee56366c22de2375645a6371747", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex 6c1fe7ff9..a014e1dae 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -46,7 +46,7 @@ class CancelTaskAccTest extends AbstractAccTest {\n     assertThat(taskSummaries).hasSize(5);\n   }\n \n-  @WithAccessId(user = \"admin\", groups = \"group-1\")\n+  @WithAccessId(user = \"admin\")\n   @Test\n   void testCancelReadyTask()\n       throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n", "next_change": {"commit": "ec483ab21cbe35f0e0ec608b109c47a3438abb48", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex a014e1dae..f2290a179 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -48,8 +45,7 @@ class CancelTaskAccTest extends AbstractAccTest {\n \n   @WithAccessId(user = \"admin\")\n   @Test\n-  void testCancelReadyTask()\n-      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n+  void testCancelReadyTask() throws Exception {\n     List<TaskSummary> taskSummaries = taskService.createTaskQuery().stateIn(TaskState.READY).list();\n     assertThat(taskSummaries).hasSize(47);\n     taskService.cancelTask(taskSummaries.get(0).getId());\n", "next_change": {"commit": "7636ec0b2a8e12ea5b3cff48f7b702472b603e5d", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex f2290a179..c8d5b5d50 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -47,10 +47,10 @@ class CancelTaskAccTest extends AbstractAccTest {\n   @Test\n   void testCancelReadyTask() throws Exception {\n     List<TaskSummary> taskSummaries = taskService.createTaskQuery().stateIn(TaskState.READY).list();\n-    assertThat(taskSummaries).hasSize(47);\n+    assertThat(taskSummaries).hasSize(48);\n     taskService.cancelTask(taskSummaries.get(0).getId());\n     long numTasks = taskService.createTaskQuery().stateIn(TaskState.READY).count();\n-    assertThat(numTasks).isEqualTo(46);\n+    assertThat(numTasks).isEqualTo(47);\n     numTasks = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n     assertThat(numTasks).isEqualTo(6);\n   }\n", "next_change": null}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6bd6bd48386155644df0463edf8aeda473bd1a56", "message": "Merge commit", "committedDate": null}, {"oid": "2ce7f86456f99d522e001080e9504ae4cd6a80f4", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-1160 TaskStates CANCELLED and TERMINATED"}, {"oid": "d6505284f780ec7a804adf7d6156726e85ddd4ef", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-1160 - terminate/cancel task Holger's comments"}, {"oid": "2c5634c917e2246d56aff6472f7d7abc0a12a96b", "committedDate": "2020-04-20 08:10:16 +0200", "message": "TSK-1180: migrate from JUnit 5 assertions to assertJ assertions"}, {"oid": "ac5f04ff3bce8c8b933c0720ec2ca814f2a9fb17", "committedDate": "2020-04-27 11:06:12 +0200", "message": "TSK-1207: extended JaasExtension to run with multiple access ids"}, {"oid": "3ce41b224efde509aea998be3ace278832b1d562", "committedDate": "2020-05-06 10:18:42 +0200", "message": "TSK-1182: refined architecture tests"}, {"oid": "eb73c0670f522b6d1936b4323cf940640f504775", "committedDate": "2020-05-11 16:08:12 +0200", "message": "TSK-1192 Introduced new Task-Admin Role"}, {"oid": "baf794518cbc494b85c190c05af97bd8b84ddb02", "committedDate": "2020-05-11 16:08:12 +0200", "message": "Usage of the new TestTemplate-feature"}, {"oid": "c6755b35b7226f4989aeea25ceeb3e18204fed45", "committedDate": "2020-05-22 03:25:57 +0200", "message": "TSK-1244: added due/planned logic for SLA P0D"}, {"oid": "cc4efaa1cdd708366adea79d631b8aa5ccc013a8", "committedDate": "2020-06-05 20:03:15 +0200", "message": "TSK-1210: Replaced LoginModule with Embedded Spring LDAP"}, {"oid": "6952ce8959a8711f72c6319565edbee90a8b1cbd", "committedDate": "2020-06-07 15:56:30 +0200", "message": "TSK-1210: replaced group names with new group names"}, {"oid": "c57bbe07c7ca3ee56366c22de2375645a6371747", "committedDate": "2020-06-22 16:05:19 +0200", "message": "TSK-1283: replaced usernames with - instead of _"}, {"oid": "ec483ab21cbe35f0e0ec608b109c47a3438abb48", "committedDate": "2020-07-06 18:02:39 +0200", "message": "TSK-1318: replaced all declared Exceptions with Exception.class in all our test classes"}, {"oid": "d8ad7a7fb96e7d07e5f93e202cd84e03e5c1944a", "committedDate": "2020-07-10 13:13:42 +0200", "message": "TSK-1250 On demand deletion of historical data"}, {"oid": "47aa60033faf81caaab930410972bdc7bf7d6e05", "committedDate": "2020-10-09 10:25:54 +0200", "message": "TSK-1277: moved JaasExtension and all its necessary classes to common modules"}, {"oid": "de57596ba8e816d3e751b21c949a3fe132b314f0", "committedDate": "2020-12-18 11:29:10 +0100", "message": "TSK-1436: reworked review comments."}, {"oid": "7636ec0b2a8e12ea5b3cff48f7b702472b603e5d", "committedDate": "2021-06-01 09:51:38 +0200", "message": "TSK-1501: TaskTransferrer cleaned and restructured (#1599)"}, {"oid": "e264a203892c6d2111df4645abf7f373bf4ca86a", "committedDate": "2021-10-08 08:38:21 +0200", "message": "TSK-1726: Implemented option to include long name on Task / TaskComment / TaskHistoryEvent"}, {"oid": "a0fe4ea468f273e2e96aab4cb40407a64a2263f0", "committedDate": "2022-04-05 12:32:50 +0200", "message": "TSK-1814: structured acceptance tests in packages"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2Njg1NQ==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398666855", "body": "Did we decide that everybody is allowed to cancel a claimed task? I wonder if it would be better to allow only the owner to cancel claimed tasks.", "bodyText": "Did we decide that everybody is allowed to cancel a claimed task? I wonder if it would be better to allow only the owner to cancel claimed tasks.", "bodyHTML": "<p dir=\"auto\">Did we decide that everybody is allowed to cancel a claimed task? I wonder if it would be better to allow only the owner to cancel claimed tasks.</p>", "author": "holgerhagen", "createdAt": "2020-03-26T15:32:00Z", "path": "lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package acceptance.task;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import acceptance.AbstractAccTest;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import pro.taskana.common.api.exceptions.NotAuthorizedException;\n+import pro.taskana.security.JaasExtension;\n+import pro.taskana.security.WithAccessId;\n+import pro.taskana.task.api.TaskService;\n+import pro.taskana.task.api.TaskState;\n+import pro.taskana.task.api.exceptions.InvalidStateException;\n+import pro.taskana.task.api.exceptions.TaskNotFoundException;\n+import pro.taskana.task.api.models.Task;\n+import pro.taskana.task.api.models.TaskSummary;\n+\n+\n+/** Acceptance tests for all claim and complete scenarios. */\n+@ExtendWith(JaasExtension.class)\n+class CancelTaskAccTest extends AbstractAccTest {\n+  private TaskService taskService;\n+\n+  CancelTaskAccTest() {\n+    super();\n+    taskService = taskanaEngine.getTaskService();\n+  }\n+\n+  @BeforeEach\n+  public static void setupTest() throws Exception {\n+    resetDb(false);\n+  }\n+\n+  @WithAccessId(\n+      userName = \"user_1_1\",\n+      groupNames = {\"group_1\"})\n+  @Test\n+  void testQeryCancelledTasks() {\n+    List<TaskSummary> taskSummaries =\n+        taskService.createTaskQuery().stateIn(TaskState.CANCELLED).list();\n+    assertThat(taskSummaries.size()).isEqualTo(5);\n+  }\n+\n+  @WithAccessId(\n+      userName = \"admin\",\n+      groupNames = {\"group_1\"})\n+  @Test\n+  void testCancelReadyTask()\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n+    List<TaskSummary> taskSummaries = taskService.createTaskQuery().stateIn(TaskState.READY).list();\n+    assertThat(taskSummaries.size()).isEqualTo(47);\n+    Task task = taskService.getTask(taskSummaries.get(0).getId());\n+    taskService.cancelTask(taskSummaries.get(0).getId());\n+    long numTasks = taskService.createTaskQuery().stateIn(TaskState.READY).count();\n+    assertThat(numTasks).isEqualTo(46);\n+    numTasks = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n+    assertThat(numTasks).isEqualTo(6);\n+  }\n+\n+  @WithAccessId(\n+      userName = \"admin\",", "originalCommit": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc2OTk5MA==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398769990", "bodyText": "The ticket says : \" terminateTask() and cancelTask bay be called by every user that is allowed to see the task \"\nI agree, that it is strange that everybody is allowed to cancel / terminate a task. On the other hand, if you think about the adapter scenario: if a task has been cancelled / terminated in camunda, the adapter should be able to cancel / terminate it in taskana. And this without being the owner. And probably also without having admin authority. So before I change anything with respect to this, we should carefully think about what is the correct solution ....", "author": "BerndBreier", "createdAt": "2020-03-26T17:46:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2Njg1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "4c65a6087e83b85e44118a754cf749a23cac5250", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex 0c9a90579..97d4bda87 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -62,20 +60,23 @@ class CancelTaskAccTest extends AbstractAccTest {\n   }\n \n   @WithAccessId(\n-      userName = \"admin\",\n+      userName = \"user_1_2\",\n       groupNames = {\"group_1\"})\n   @Test\n   void testCancelClaimedTask()\n       throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n     List<TaskSummary> taskSummaries =\n         taskService.createTaskQuery().stateIn(TaskState.CLAIMED).list();\n-    assertThat(taskSummaries.size()).isEqualTo(19);\n-    Task task = taskService.getTask(taskSummaries.get(0).getId());\n+    assertThat(taskSummaries.size()).isEqualTo(16);\n+\n+    long numTasksCancelled = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n+    assertThat(numTasksCancelled).isEqualTo(5);\n+\n     taskService.cancelTask(taskSummaries.get(0).getId());\n-    long numTasks = taskService.createTaskQuery().stateIn(TaskState.CLAIMED).count();\n-    assertThat(numTasks).isEqualTo(18);\n-    numTasks = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n-    assertThat(numTasks).isEqualTo(6);\n+    long numTasksClaimed = taskService.createTaskQuery().stateIn(TaskState.CLAIMED).count();\n+    assertThat(numTasksClaimed).isEqualTo(15);\n+    numTasksCancelled = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n+    assertThat(numTasksCancelled).isEqualTo(6);\n   }\n \n   @WithAccessId(\n", "next_change": null}]}, "revised_code_in_main": {"commit": "6bd6bd48386155644df0463edf8aeda473bd1a56", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex 0c9a90579..97d4bda87 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -62,20 +60,23 @@ class CancelTaskAccTest extends AbstractAccTest {\n   }\n \n   @WithAccessId(\n-      userName = \"admin\",\n+      userName = \"user_1_2\",\n       groupNames = {\"group_1\"})\n   @Test\n   void testCancelClaimedTask()\n       throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n     List<TaskSummary> taskSummaries =\n         taskService.createTaskQuery().stateIn(TaskState.CLAIMED).list();\n-    assertThat(taskSummaries.size()).isEqualTo(19);\n-    Task task = taskService.getTask(taskSummaries.get(0).getId());\n+    assertThat(taskSummaries.size()).isEqualTo(16);\n+\n+    long numTasksCancelled = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n+    assertThat(numTasksCancelled).isEqualTo(5);\n+\n     taskService.cancelTask(taskSummaries.get(0).getId());\n-    long numTasks = taskService.createTaskQuery().stateIn(TaskState.CLAIMED).count();\n-    assertThat(numTasks).isEqualTo(18);\n-    numTasks = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n-    assertThat(numTasks).isEqualTo(6);\n+    long numTasksClaimed = taskService.createTaskQuery().stateIn(TaskState.CLAIMED).count();\n+    assertThat(numTasksClaimed).isEqualTo(15);\n+    numTasksCancelled = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n+    assertThat(numTasksCancelled).isEqualTo(6);\n   }\n \n   @WithAccessId(\n", "next_change": {"commit": "2ce7f86456f99d522e001080e9504ae4cd6a80f4", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex 97d4bda87..0c9a90579 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -60,23 +62,20 @@ class CancelTaskAccTest extends AbstractAccTest {\n   }\n \n   @WithAccessId(\n-      userName = \"user_1_2\",\n+      userName = \"admin\",\n       groupNames = {\"group_1\"})\n   @Test\n   void testCancelClaimedTask()\n       throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n     List<TaskSummary> taskSummaries =\n         taskService.createTaskQuery().stateIn(TaskState.CLAIMED).list();\n-    assertThat(taskSummaries.size()).isEqualTo(16);\n-\n-    long numTasksCancelled = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n-    assertThat(numTasksCancelled).isEqualTo(5);\n-\n+    assertThat(taskSummaries.size()).isEqualTo(19);\n+    Task task = taskService.getTask(taskSummaries.get(0).getId());\n     taskService.cancelTask(taskSummaries.get(0).getId());\n-    long numTasksClaimed = taskService.createTaskQuery().stateIn(TaskState.CLAIMED).count();\n-    assertThat(numTasksClaimed).isEqualTo(15);\n-    numTasksCancelled = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n-    assertThat(numTasksCancelled).isEqualTo(6);\n+    long numTasks = taskService.createTaskQuery().stateIn(TaskState.CLAIMED).count();\n+    assertThat(numTasks).isEqualTo(18);\n+    numTasks = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n+    assertThat(numTasks).isEqualTo(6);\n   }\n \n   @WithAccessId(\n", "next_change": {"commit": "d6505284f780ec7a804adf7d6156726e85ddd4ef", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex 0c9a90579..97d4bda87 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -62,20 +60,23 @@ class CancelTaskAccTest extends AbstractAccTest {\n   }\n \n   @WithAccessId(\n-      userName = \"admin\",\n+      userName = \"user_1_2\",\n       groupNames = {\"group_1\"})\n   @Test\n   void testCancelClaimedTask()\n       throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n     List<TaskSummary> taskSummaries =\n         taskService.createTaskQuery().stateIn(TaskState.CLAIMED).list();\n-    assertThat(taskSummaries.size()).isEqualTo(19);\n-    Task task = taskService.getTask(taskSummaries.get(0).getId());\n+    assertThat(taskSummaries.size()).isEqualTo(16);\n+\n+    long numTasksCancelled = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n+    assertThat(numTasksCancelled).isEqualTo(5);\n+\n     taskService.cancelTask(taskSummaries.get(0).getId());\n-    long numTasks = taskService.createTaskQuery().stateIn(TaskState.CLAIMED).count();\n-    assertThat(numTasks).isEqualTo(18);\n-    numTasks = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n-    assertThat(numTasks).isEqualTo(6);\n+    long numTasksClaimed = taskService.createTaskQuery().stateIn(TaskState.CLAIMED).count();\n+    assertThat(numTasksClaimed).isEqualTo(15);\n+    numTasksCancelled = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n+    assertThat(numTasksCancelled).isEqualTo(6);\n   }\n \n   @WithAccessId(\n", "next_change": {"commit": "2c5634c917e2246d56aff6472f7d7abc0a12a96b", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex 97d4bda87..cb1fdadce 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -83,16 +83,12 @@ class CancelTaskAccTest extends AbstractAccTest {\n       userName = \"admin\",\n       groupNames = {\"group_1\"})\n   @Test\n-  void testCancelCompletedTask()\n-      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n+  void testCancelCompletedTask() {\n     List<TaskSummary> taskSummaries =\n         taskService.createTaskQuery().stateIn(TaskState.COMPLETED).list();\n-    assertThat(taskSummaries.size()).isEqualTo(7);\n+    assertThat(taskSummaries).hasSize(7);\n \n-    ThrowingCallable taskanaCall =\n-        () -> {\n-          taskService.cancelTask(taskSummaries.get(0).getId());\n-        };\n+    ThrowingCallable taskanaCall = () -> taskService.cancelTask(taskSummaries.get(0).getId());\n \n     assertThatThrownBy(taskanaCall).isInstanceOf(InvalidStateException.class);\n   }\n", "next_change": {"commit": "ac5f04ff3bce8c8b933c0720ec2ca814f2a9fb17", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex cb1fdadce..631ad4817 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -93,9 +85,7 @@ class CancelTaskAccTest extends AbstractAccTest {\n     assertThatThrownBy(taskanaCall).isInstanceOf(InvalidStateException.class);\n   }\n \n-  @WithAccessId(\n-      userName = \"user_1_2\",\n-      groupNames = {\"group_1\"})\n+  @WithAccessId(user = \"user_1_2\", groups = \"group_1\")\n   @Test\n   void testCancelTerminatedTask() {\n     List<TaskSummary> taskSummaries =\n", "next_change": {"commit": "cc4efaa1cdd708366adea79d631b8aa5ccc013a8", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex 631ad4817..91e8d26d1 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -85,7 +103,7 @@ class CancelTaskAccTest extends AbstractAccTest {\n     assertThatThrownBy(taskanaCall).isInstanceOf(InvalidStateException.class);\n   }\n \n-  @WithAccessId(user = \"user_1_2\", groups = \"group_1\")\n+  @WithAccessId(user = \"user-1-2\", groups = \"group_1\")\n   @Test\n   void testCancelTerminatedTask() {\n     List<TaskSummary> taskSummaries =\n", "next_change": {"commit": "6952ce8959a8711f72c6319565edbee90a8b1cbd", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex 91e8d26d1..6c1fe7ff9 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -103,7 +103,7 @@ class CancelTaskAccTest extends AbstractAccTest {\n     assertThatThrownBy(taskanaCall).isInstanceOf(InvalidStateException.class);\n   }\n \n-  @WithAccessId(user = \"user-1-2\", groups = \"group_1\")\n+  @WithAccessId(user = \"user-1-2\", groups = \"group-1\")\n   @Test\n   void testCancelTerminatedTask() {\n     List<TaskSummary> taskSummaries =\n", "next_change": {"commit": "c57bbe07c7ca3ee56366c22de2375645a6371747", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex 6c1fe7ff9..a014e1dae 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -103,7 +101,7 @@ class CancelTaskAccTest extends AbstractAccTest {\n     assertThatThrownBy(taskanaCall).isInstanceOf(InvalidStateException.class);\n   }\n \n-  @WithAccessId(user = \"user-1-2\", groups = \"group-1\")\n+  @WithAccessId(user = \"user-1-2\")\n   @Test\n   void testCancelTerminatedTask() {\n     List<TaskSummary> taskSummaries =\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6bd6bd48386155644df0463edf8aeda473bd1a56", "message": "Merge commit", "committedDate": null}, {"oid": "2ce7f86456f99d522e001080e9504ae4cd6a80f4", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-1160 TaskStates CANCELLED and TERMINATED"}, {"oid": "d6505284f780ec7a804adf7d6156726e85ddd4ef", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-1160 - terminate/cancel task Holger's comments"}, {"oid": "2c5634c917e2246d56aff6472f7d7abc0a12a96b", "committedDate": "2020-04-20 08:10:16 +0200", "message": "TSK-1180: migrate from JUnit 5 assertions to assertJ assertions"}, {"oid": "ac5f04ff3bce8c8b933c0720ec2ca814f2a9fb17", "committedDate": "2020-04-27 11:06:12 +0200", "message": "TSK-1207: extended JaasExtension to run with multiple access ids"}, {"oid": "3ce41b224efde509aea998be3ace278832b1d562", "committedDate": "2020-05-06 10:18:42 +0200", "message": "TSK-1182: refined architecture tests"}, {"oid": "eb73c0670f522b6d1936b4323cf940640f504775", "committedDate": "2020-05-11 16:08:12 +0200", "message": "TSK-1192 Introduced new Task-Admin Role"}, {"oid": "baf794518cbc494b85c190c05af97bd8b84ddb02", "committedDate": "2020-05-11 16:08:12 +0200", "message": "Usage of the new TestTemplate-feature"}, {"oid": "c6755b35b7226f4989aeea25ceeb3e18204fed45", "committedDate": "2020-05-22 03:25:57 +0200", "message": "TSK-1244: added due/planned logic for SLA P0D"}, {"oid": "cc4efaa1cdd708366adea79d631b8aa5ccc013a8", "committedDate": "2020-06-05 20:03:15 +0200", "message": "TSK-1210: Replaced LoginModule with Embedded Spring LDAP"}, {"oid": "6952ce8959a8711f72c6319565edbee90a8b1cbd", "committedDate": "2020-06-07 15:56:30 +0200", "message": "TSK-1210: replaced group names with new group names"}, {"oid": "c57bbe07c7ca3ee56366c22de2375645a6371747", "committedDate": "2020-06-22 16:05:19 +0200", "message": "TSK-1283: replaced usernames with - instead of _"}, {"oid": "ec483ab21cbe35f0e0ec608b109c47a3438abb48", "committedDate": "2020-07-06 18:02:39 +0200", "message": "TSK-1318: replaced all declared Exceptions with Exception.class in all our test classes"}, {"oid": "d8ad7a7fb96e7d07e5f93e202cd84e03e5c1944a", "committedDate": "2020-07-10 13:13:42 +0200", "message": "TSK-1250 On demand deletion of historical data"}, {"oid": "47aa60033faf81caaab930410972bdc7bf7d6e05", "committedDate": "2020-10-09 10:25:54 +0200", "message": "TSK-1277: moved JaasExtension and all its necessary classes to common modules"}, {"oid": "de57596ba8e816d3e751b21c949a3fe132b314f0", "committedDate": "2020-12-18 11:29:10 +0100", "message": "TSK-1436: reworked review comments."}, {"oid": "7636ec0b2a8e12ea5b3cff48f7b702472b603e5d", "committedDate": "2021-06-01 09:51:38 +0200", "message": "TSK-1501: TaskTransferrer cleaned and restructured (#1599)"}, {"oid": "e264a203892c6d2111df4645abf7f373bf4ca86a", "committedDate": "2021-10-08 08:38:21 +0200", "message": "TSK-1726: Implemented option to include long name on Task / TaskComment / TaskHistoryEvent"}, {"oid": "a0fe4ea468f273e2e96aab4cb40407a64a2263f0", "committedDate": "2022-04-05 12:32:50 +0200", "message": "TSK-1814: structured acceptance tests in packages"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2ODA2Ng==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398668066", "body": "See comments on cancel task test.", "bodyText": "See comments on cancel task test.", "bodyHTML": "<p dir=\"auto\">See comments on cancel task test.</p>", "author": "holgerhagen", "createdAt": "2020-03-26T15:33:35Z", "path": "lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package acceptance.task;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import acceptance.AbstractAccTest;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import pro.taskana.common.api.exceptions.NotAuthorizedException;\n+import pro.taskana.security.JaasExtension;\n+import pro.taskana.security.WithAccessId;\n+import pro.taskana.task.api.TaskService;\n+import pro.taskana.task.api.TaskState;\n+import pro.taskana.task.api.exceptions.InvalidStateException;\n+import pro.taskana.task.api.exceptions.TaskNotFoundException;\n+import pro.taskana.task.api.models.Task;\n+import pro.taskana.task.api.models.TaskSummary;\n+\n+/** Acceptance tests for all claim and complete scenarios. */\n+@ExtendWith(JaasExtension.class)\n+class TerminateTaskAccTest extends AbstractAccTest {", "originalCommit": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc4MjcwMQ==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398782701", "bodyText": "done", "author": "BerndBreier", "createdAt": "2020-03-26T18:04:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2ODA2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "4c65a6087e83b85e44118a754cf749a23cac5250", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\nindex 50eca5337..f53402b4b 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n", "chunk": "@@ -16,7 +17,6 @@ import pro.taskana.task.api.TaskService;\n import pro.taskana.task.api.TaskState;\n import pro.taskana.task.api.exceptions.InvalidStateException;\n import pro.taskana.task.api.exceptions.TaskNotFoundException;\n-import pro.taskana.task.api.models.Task;\n import pro.taskana.task.api.models.TaskSummary;\n \n /** Acceptance tests for all claim and complete scenarios. */\n", "next_change": null}]}, "revised_code_in_main": {"commit": "6bd6bd48386155644df0463edf8aeda473bd1a56", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\nindex 50eca5337..f53402b4b 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n", "chunk": "@@ -16,7 +17,6 @@ import pro.taskana.task.api.TaskService;\n import pro.taskana.task.api.TaskState;\n import pro.taskana.task.api.exceptions.InvalidStateException;\n import pro.taskana.task.api.exceptions.TaskNotFoundException;\n-import pro.taskana.task.api.models.Task;\n import pro.taskana.task.api.models.TaskSummary;\n \n /** Acceptance tests for all claim and complete scenarios. */\n", "next_change": {"commit": "2ce7f86456f99d522e001080e9504ae4cd6a80f4", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\nindex f53402b4b..50eca5337 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n", "chunk": "@@ -17,6 +16,7 @@ import pro.taskana.task.api.TaskService;\n import pro.taskana.task.api.TaskState;\n import pro.taskana.task.api.exceptions.InvalidStateException;\n import pro.taskana.task.api.exceptions.TaskNotFoundException;\n+import pro.taskana.task.api.models.Task;\n import pro.taskana.task.api.models.TaskSummary;\n \n /** Acceptance tests for all claim and complete scenarios. */\n", "next_change": {"commit": "d6505284f780ec7a804adf7d6156726e85ddd4ef", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\nindex 50eca5337..f53402b4b 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n", "chunk": "@@ -16,7 +17,6 @@ import pro.taskana.task.api.TaskService;\n import pro.taskana.task.api.TaskState;\n import pro.taskana.task.api.exceptions.InvalidStateException;\n import pro.taskana.task.api.exceptions.TaskNotFoundException;\n-import pro.taskana.task.api.models.Task;\n import pro.taskana.task.api.models.TaskSummary;\n \n /** Acceptance tests for all claim and complete scenarios. */\n", "next_change": {"commit": "2c5634c917e2246d56aff6472f7d7abc0a12a96b", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\nindex f53402b4b..23ea6d76a 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n", "chunk": "@@ -22,10 +23,10 @@ import pro.taskana.task.api.models.TaskSummary;\n /** Acceptance tests for all claim and complete scenarios. */\n @ExtendWith(JaasExtension.class)\n class TerminateTaskAccTest extends AbstractAccTest {\n-  private TaskService taskService;\n+  private static TaskService taskService;\n \n-  TerminateTaskAccTest() {\n-    super();\n+  @BeforeAll\n+  static void setup() {\n     taskService = taskanaEngine.getTaskService();\n   }\n \n", "next_change": {"commit": "35705ddb02fddbade31cb2e1892040ecf8e5bbab", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\nindex 23ea6d76a..fbb980e3f 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n", "chunk": "@@ -25,16 +25,16 @@ import pro.taskana.task.api.models.TaskSummary;\n class TerminateTaskAccTest extends AbstractAccTest {\n   private static TaskService taskService;\n \n-  @BeforeAll\n-  static void setup() {\n-    taskService = taskanaEngine.getTaskService();\n-  }\n-\n   @BeforeEach\n   public void setupIndividualTest() throws Exception {\n     resetDb(false);\n   }\n \n+  @BeforeAll\n+  static void setup() {\n+    taskService = taskanaEngine.getTaskService();\n+  }\n+\n   @WithAccessId(\n       userName = \"user_1_1\",\n       groupNames = {\"group_1\"})\n", "next_change": {"commit": "ac5f04ff3bce8c8b933c0720ec2ca814f2a9fb17", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\nindex fbb980e3f..6ffd9afb1 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n", "chunk": "@@ -35,9 +35,7 @@ class TerminateTaskAccTest extends AbstractAccTest {\n     taskService = taskanaEngine.getTaskService();\n   }\n \n-  @WithAccessId(\n-      userName = \"user_1_1\",\n-      groupNames = {\"group_1\"})\n+  @WithAccessId(user = \"user_1_1\", groups = \"group_1\")\n   @Test\n   void testQueryTerminatedTasks() {\n     List<TaskSummary> taskSummaries =\n", "next_change": {"commit": "eb73c0670f522b6d1936b4323cf940640f504775", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\nindex 6ffd9afb1..03dbf0c13 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n", "chunk": "@@ -37,7 +37,7 @@ class TerminateTaskAccTest extends AbstractAccTest {\n \n   @WithAccessId(user = \"user_1_1\", groups = \"group_1\")\n   @Test\n-  void testQueryTerminatedTasks() {\n+  void should_ReturnAllTerminatedTasks_When_QueryTerminatedState() {\n     List<TaskSummary> taskSummaries =\n         taskService.createTaskQuery().stateIn(TaskState.TERMINATED).list();\n     assertThat(taskSummaries).hasSize(5);\n", "next_change": {"commit": "baf794518cbc494b85c190c05af97bd8b84ddb02", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\nindex 03dbf0c13..8621b73e3 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n", "chunk": "@@ -44,7 +45,8 @@ class TerminateTaskAccTest extends AbstractAccTest {\n   }\n \n   @WithAccessId(user = \"admin\", groups = \"group_1\")\n-  @Test\n+  @WithAccessId(user = \"taskadmin\")\n+  @TestTemplate\n   void should_TerminateTask_When_TaskStateIsReady()\n       throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n     List<TaskSummary> taskSummaries = taskService.createTaskQuery().stateIn(TaskState.READY).list();\n", "next_change": {"commit": "6952ce8959a8711f72c6319565edbee90a8b1cbd", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\nindex 8621b73e3..9e76083da 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n", "chunk": "@@ -44,7 +44,7 @@ class TerminateTaskAccTest extends AbstractAccTest {\n     assertThat(taskSummaries).hasSize(5);\n   }\n \n-  @WithAccessId(user = \"admin\", groups = \"group_1\")\n+  @WithAccessId(user = \"admin\", groups = \"group-1\")\n   @WithAccessId(user = \"taskadmin\")\n   @TestTemplate\n   void should_TerminateTask_When_TaskStateIsReady()\n", "next_change": {"commit": "c57bbe07c7ca3ee56366c22de2375645a6371747", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\nindex 9e76083da..e1ac7a25e 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n", "chunk": "@@ -44,7 +44,7 @@ class TerminateTaskAccTest extends AbstractAccTest {\n     assertThat(taskSummaries).hasSize(5);\n   }\n \n-  @WithAccessId(user = \"admin\", groups = \"group-1\")\n+  @WithAccessId(user = \"admin\")\n   @WithAccessId(user = \"taskadmin\")\n   @TestTemplate\n   void should_TerminateTask_When_TaskStateIsReady()\n", "next_change": {"commit": "ec483ab21cbe35f0e0ec608b109c47a3438abb48", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\nindex e1ac7a25e..704a1335a 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n", "chunk": "@@ -47,8 +46,7 @@ class TerminateTaskAccTest extends AbstractAccTest {\n   @WithAccessId(user = \"admin\")\n   @WithAccessId(user = \"taskadmin\")\n   @TestTemplate\n-  void should_TerminateTask_When_TaskStateIsReady()\n-      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n+  void should_TerminateTask_When_TaskStateIsReady() throws Exception {\n     List<TaskSummary> taskSummaries = taskService.createTaskQuery().stateIn(TaskState.READY).list();\n     assertThat(taskSummaries).hasSize(47);\n     taskService.terminateTask(taskSummaries.get(0).getId());\n", "next_change": {"commit": "7636ec0b2a8e12ea5b3cff48f7b702472b603e5d", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\nindex 704a1335a..f34c0a5db 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n", "chunk": "@@ -48,10 +48,10 @@ class TerminateTaskAccTest extends AbstractAccTest {\n   @TestTemplate\n   void should_TerminateTask_When_TaskStateIsReady() throws Exception {\n     List<TaskSummary> taskSummaries = taskService.createTaskQuery().stateIn(TaskState.READY).list();\n-    assertThat(taskSummaries).hasSize(47);\n+    assertThat(taskSummaries).hasSize(48);\n     taskService.terminateTask(taskSummaries.get(0).getId());\n     long numTasks = taskService.createTaskQuery().stateIn(TaskState.READY).count();\n-    assertThat(numTasks).isEqualTo(46);\n+    assertThat(numTasks).isEqualTo(47);\n     numTasks = taskService.createTaskQuery().stateIn(TaskState.TERMINATED).count();\n     assertThat(numTasks).isEqualTo(6);\n   }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6bd6bd48386155644df0463edf8aeda473bd1a56", "message": "Merge commit", "committedDate": null}, {"oid": "2ce7f86456f99d522e001080e9504ae4cd6a80f4", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-1160 TaskStates CANCELLED and TERMINATED"}, {"oid": "d6505284f780ec7a804adf7d6156726e85ddd4ef", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-1160 - terminate/cancel task Holger's comments"}, {"oid": "2c5634c917e2246d56aff6472f7d7abc0a12a96b", "committedDate": "2020-04-20 08:10:16 +0200", "message": "TSK-1180: migrate from JUnit 5 assertions to assertJ assertions"}, {"oid": "35705ddb02fddbade31cb2e1892040ecf8e5bbab", "committedDate": "2020-04-24 12:59:13 +0200", "message": "automatically formatted code"}, {"oid": "ac5f04ff3bce8c8b933c0720ec2ca814f2a9fb17", "committedDate": "2020-04-27 11:06:12 +0200", "message": "TSK-1207: extended JaasExtension to run with multiple access ids"}, {"oid": "3ce41b224efde509aea998be3ace278832b1d562", "committedDate": "2020-05-06 10:18:42 +0200", "message": "TSK-1182: refined architecture tests"}, {"oid": "eb73c0670f522b6d1936b4323cf940640f504775", "committedDate": "2020-05-11 16:08:12 +0200", "message": "TSK-1192 Introduced new Task-Admin Role"}, {"oid": "baf794518cbc494b85c190c05af97bd8b84ddb02", "committedDate": "2020-05-11 16:08:12 +0200", "message": "Usage of the new TestTemplate-feature"}, {"oid": "c6755b35b7226f4989aeea25ceeb3e18204fed45", "committedDate": "2020-05-22 03:25:57 +0200", "message": "TSK-1244: added due/planned logic for SLA P0D"}, {"oid": "cc4efaa1cdd708366adea79d631b8aa5ccc013a8", "committedDate": "2020-06-05 20:03:15 +0200", "message": "TSK-1210: Replaced LoginModule with Embedded Spring LDAP"}, {"oid": "6952ce8959a8711f72c6319565edbee90a8b1cbd", "committedDate": "2020-06-07 15:56:30 +0200", "message": "TSK-1210: replaced group names with new group names"}, {"oid": "c57bbe07c7ca3ee56366c22de2375645a6371747", "committedDate": "2020-06-22 16:05:19 +0200", "message": "TSK-1283: replaced usernames with - instead of _"}, {"oid": "ec483ab21cbe35f0e0ec608b109c47a3438abb48", "committedDate": "2020-07-06 18:02:39 +0200", "message": "TSK-1318: replaced all declared Exceptions with Exception.class in all our test classes"}, {"oid": "d8ad7a7fb96e7d07e5f93e202cd84e03e5c1944a", "committedDate": "2020-07-10 13:13:42 +0200", "message": "TSK-1250 On demand deletion of historical data"}, {"oid": "47aa60033faf81caaab930410972bdc7bf7d6e05", "committedDate": "2020-10-09 10:25:54 +0200", "message": "TSK-1277: moved JaasExtension and all its necessary classes to common modules"}, {"oid": "7636ec0b2a8e12ea5b3cff48f7b702472b603e5d", "committedDate": "2021-06-01 09:51:38 +0200", "message": "TSK-1501: TaskTransferrer cleaned and restructured (#1599)"}, {"oid": "e264a203892c6d2111df4645abf7f373bf4ca86a", "committedDate": "2021-10-08 08:38:21 +0200", "message": "TSK-1726: Implemented option to include long name on Task / TaskComment / TaskHistoryEvent"}, {"oid": "a0fe4ea468f273e2e96aab4cb40407a64a2263f0", "committedDate": "2022-04-05 12:32:50 +0200", "message": "TSK-1814: structured acceptance tests in packages"}]}, {"oid": "4c65a6087e83b85e44118a754cf749a23cac5250", "url": "https://github.com/Taskana/taskana/commit/4c65a6087e83b85e44118a754cf749a23cac5250", "message": "TSK-1160 - terminate/cancel task Holger's comments", "committedDate": "2020-03-26T18:22:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE2MTA2NA==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r399161064", "body": "Why don't we move this to the engine as well?", "bodyText": "Why don't we move this to the engine as well?", "bodyHTML": "<p dir=\"auto\">Why don't we move this to the engine as well?</p>", "author": "holgerhagen", "createdAt": "2020-03-27T10:15:24Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java", "diffHunk": "@@ -48,15 +46,7 @@\n     this.taskanaEngine = taskanaEngine;\n     this.taskMapper = taskMapper;\n     this.attachmentMapper = attachmentMapper;\n-    DaysToWorkingDaysConverter.setGermanPublicHolidaysEnabled(\n-        taskanaEngine.getEngine().getConfiguration().isGermanPublicHolidaysEnabled());\n-    try {\n-      converter = DaysToWorkingDaysConverter.initialize();\n-    } catch (InvalidArgumentException e) {\n-      LOGGER.error(ERROR_CANNOT_INITIALIZE_DAYS_TO_WORKING_DAYS_CONVERTER);\n-      throw new SystemException(\n-          ERROR_CANNOT_INITIALIZE_DAYS_TO_WORKING_DAYS_CONVERTER, e.getCause());\n-    }\n+    this.converter = WorkingDaysToDaysConverter.initialize();", "originalCommit": "4c65a6087e83b85e44118a754cf749a23cac5250", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMwNzYzOA==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r399307638", "bodyText": "The engine calls only WorkingDaysToDaysConverter.setGermanPublicHolidaysEnabled() which is a static method. The initialize() call is a factory method that creates an instance of WorkingDaysToDaysConverter.\nSince the WorkingDaysToDaysConverter is only needed inside ServiceLevelHandler, I made it an instance variable of this class.\nTo make things consistent, I'll also move the setGermanPublicHolidaysEnabled() call to the ctor of ServiceLevelHandler.", "author": "BerndBreier", "createdAt": "2020-03-27T14:32:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE2MTA2NA=="}], "type": "inlineReview", "revised_code": {"commit": "62d58b32c908be3bf05b5068497e4be5a20002e6", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\nindex 83d237766..292aaa9d9 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n", "chunk": "@@ -46,6 +46,8 @@ class ServiceLevelHandler {\n     this.taskanaEngine = taskanaEngine;\n     this.taskMapper = taskMapper;\n     this.attachmentMapper = attachmentMapper;\n+    WorkingDaysToDaysConverter.setGermanPublicHolidaysEnabled(\n+        taskanaEngine.getEngine().getConfiguration().isGermanPublicHolidaysEnabled());\n     this.converter = WorkingDaysToDaysConverter.initialize();\n   }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "6bd6bd48386155644df0463edf8aeda473bd1a56", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\nindex 83d237766..292aaa9d9 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n", "chunk": "@@ -46,6 +46,8 @@ class ServiceLevelHandler {\n     this.taskanaEngine = taskanaEngine;\n     this.taskMapper = taskMapper;\n     this.attachmentMapper = attachmentMapper;\n+    WorkingDaysToDaysConverter.setGermanPublicHolidaysEnabled(\n+        taskanaEngine.getEngine().getConfiguration().isGermanPublicHolidaysEnabled());\n     this.converter = WorkingDaysToDaysConverter.initialize();\n   }\n \n", "next_change": {"commit": "02a6df6f73622e86684c6c30d8f320c84078b237", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\nindex 292aaa9d9..d6f999501 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n", "chunk": "@@ -33,43 +34,28 @@ import pro.taskana.task.internal.models.TaskImpl;\n class ServiceLevelHandler {\n \n   private static final Logger LOGGER = LoggerFactory.getLogger(ServiceLevelHandler.class);\n+  private static final String ERROR_CANNOT_INITIALIZE_DAYS_TO_WORKING_DAYS_CONVERTER =\n+      \"Internal error. Cannot initialize DaysToWorkingDaysConverter\";\n   private static final Duration MAX_DURATION = Duration.ofSeconds(Long.MAX_VALUE, 999_999_999);\n   private final InternalTaskanaEngine taskanaEngine;\n   private final TaskMapper taskMapper;\n   private final AttachmentMapper attachmentMapper;\n-  private WorkingDaysToDaysConverter converter;\n+  private DaysToWorkingDaysConverter converter;\n \n-  ServiceLevelHandler(\n+  public ServiceLevelHandler(\n       InternalTaskanaEngine taskanaEngine,\n       TaskMapper taskMapper,\n       AttachmentMapper attachmentMapper) {\n+    super();\n     this.taskanaEngine = taskanaEngine;\n     this.taskMapper = taskMapper;\n     this.attachmentMapper = attachmentMapper;\n-    WorkingDaysToDaysConverter.setGermanPublicHolidaysEnabled(\n-        taskanaEngine.getEngine().getConfiguration().isGermanPublicHolidaysEnabled());\n-    this.converter = WorkingDaysToDaysConverter.initialize();\n-  }\n-\n-  // use the same algorithm as setPlannedPropertyOfTasksImpl to refresh\n-  // priority and duration of affected tasks, just don't use a fix\n-  // planned date but the individual planned date of the tasks\n-  public void refreshPriorityAndDueDatesOfTasks(\n-      List<MinimalTaskSummary> tasks, boolean serviceLevelChanged, boolean priorityChanged) {\n-\n-    List<AttachmentSummaryImpl> attachments = getAttachmentSummaries(tasks);\n-    List<ClassificationSummary> allInvolvedClassifications =\n-        findAllClassificationsReferencedByTasksAndAttachments(tasks, attachments);\n-\n-    if (serviceLevelChanged) {\n-      List<ClassificationWithServiceLevelResolved> allInvolvedClassificationsWithDuration =\n-          resolveDurationsInClassifications(allInvolvedClassifications);\n-\n-      updateTaskDueDatesOnClassificationUpdate(\n-          tasks, attachments, allInvolvedClassificationsWithDuration);\n-    }\n-    if (priorityChanged) {\n-      updateTaskPriorityOnClassificationUpdate(tasks, attachments, allInvolvedClassifications);\n+    try {\n+      this.converter = DaysToWorkingDaysConverter.initialize();\n+    } catch (InvalidArgumentException e) {\n+      LOGGER.error(ERROR_CANNOT_INITIALIZE_DAYS_TO_WORKING_DAYS_CONVERTER);\n+      throw new SystemException(\n+          ERROR_CANNOT_INITIALIZE_DAYS_TO_WORKING_DAYS_CONVERTER, e.getCause());\n     }\n   }\n \n", "next_change": {"commit": "fa429cef97db829102f746731f4dd966358c531e", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\nindex d6f999501..617e31aae 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n", "chunk": "@@ -59,6 +58,28 @@ class ServiceLevelHandler {\n     }\n   }\n \n+  // use the same algorithm as setPlannedPropertyOfTasksImpl to refresh\n+  // priority and duration of affected tasks, just don't use a fix\n+  // planned date but the individual planned date of the tasks\n+  public void refreshPriorityAndDueDatesOfTasks(\n+      List<MinimalTaskSummary> tasks, boolean serviceLevelChanged, boolean priorityChanged) {\n+\n+    List<AttachmentSummaryImpl> attachments = getAttachmentSummaries(tasks);\n+    List<ClassificationSummary> allInvolvedClassifications =\n+        findAllClassificationsReferencedByTasksAndAttachments(tasks, attachments);\n+\n+    if (serviceLevelChanged) {\n+      List<ClassificationWithServiceLevelResolved> allInvolvedClassificationsWithDuration =\n+          resolveDurationsInClassifications(allInvolvedClassifications);\n+\n+      updateTaskDueDatesOnClassificationUpdate(\n+          tasks, attachments, allInvolvedClassificationsWithDuration);\n+    }\n+    if (priorityChanged) {\n+      updateTaskPriorityOnClassificationUpdate(tasks, attachments, allInvolvedClassifications);\n+    }\n+  }\n+\n   // Algorithm:\n   // - load all relevant tasks and their attachmentSummaries\n   // - load all classifications referenced by these tasks / attachments\n", "next_change": {"commit": "f70d84579386fa560e6013485f276d0ebb19386a", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\nindex 617e31aae..f1c982557 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n", "chunk": "@@ -76,7 +70,10 @@ class ServiceLevelHandler {\n           tasks, attachments, allInvolvedClassificationsWithDuration);\n     }\n     if (priorityChanged) {\n-      updateTaskPriorityOnClassificationUpdate(tasks, attachments, allInvolvedClassifications);\n+      List<MinimalTaskSummary> tasksWithoutManualPriority =\n+          tasks.stream().filter(t -> !t.isManualPriorityActive()).collect(Collectors.toList());\n+      updateTaskPriorityOnClassificationUpdate(\n+          tasksWithoutManualPriority, attachments, allInvolvedClassifications);\n     }\n   }\n \n", "next_change": {"commit": "93d0b27bb058a4f47218177136bce81f99103345", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\nindex f1c982557..eb18ba692 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n", "chunk": "@@ -71,7 +72,9 @@ class ServiceLevelHandler {\n     }\n     if (priorityChanged) {\n       List<MinimalTaskSummary> tasksWithoutManualPriority =\n-          tasks.stream().filter(t -> !t.isManualPriorityActive()).collect(Collectors.toList());\n+          tasks.stream()\n+              .filter(not(MinimalTaskSummary::isManualPriorityActive))\n+              .collect(Collectors.toList());\n       updateTaskPriorityOnClassificationUpdate(\n           tasksWithoutManualPriority, attachments, allInvolvedClassifications);\n     }\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6bd6bd48386155644df0463edf8aeda473bd1a56", "message": "Merge commit", "committedDate": null}, {"oid": "02a6df6f73622e86684c6c30d8f320c84078b237", "committedDate": "2020-02-28 10:46:45 +0100", "message": "TSK-1139 Bulk update of Planned timestamp"}, {"oid": "1291287419385725f59ed90a8e8960d57c8638e0", "committedDate": "2020-03-19 14:43:16 +0100", "message": "TSK-1143 UpdateTask with Planned sometimes fails"}, {"oid": "7deb9254113278ccf5872283c2abd202c3cf7af0", "committedDate": "2020-03-19 14:43:16 +0100", "message": "TSK-1143 UpdateTask planned - comments from Holger"}, {"oid": "f78e7616f65b1cf9575f246daf4bba856a3e8f1c", "committedDate": "2020-03-19 14:43:16 +0100", "message": "TSK-1143 Update Task PLANNED - Holger's comments"}, {"oid": "e470f8d200ef88c137645111f715b058ca9803e3", "committedDate": "2020-03-19 14:43:16 +0100", "message": "TSK-1143 even more comments from Holger"}, {"oid": "7b409451dcf7f12714b5c9739861c9b43541e275", "committedDate": "2020-03-25 08:44:18 +0100", "message": "TSK-1143C mismatch between forward and backward calculation between planned and due"}, {"oid": "fa429cef97db829102f746731f4dd966358c531e", "committedDate": "2020-03-26 08:47:03 +0100", "message": "TSK-1143C mismatch between forward and backward calculation between planned and due"}, {"oid": "9251975f477fb5dc5bb82f79fe11c1c566b67e59", "committedDate": "2020-03-26 08:47:03 +0100", "message": "TSK-1143 UpdateTask planned - comments from Holger"}, {"oid": "87fd1af390f7c4abe4e4097f2e52a48bf1e68c5a", "committedDate": "2020-03-26 08:47:03 +0100", "message": "TSK-442 improve task refresh on classification update"}, {"oid": "2ce7f86456f99d522e001080e9504ae4cd6a80f4", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-1160 TaskStates CANCELLED and TERMINATED"}, {"oid": "d6505284f780ec7a804adf7d6156726e85ddd4ef", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-1160 - terminate/cancel task Holger's comments"}, {"oid": "7fdea5bef22fcd17413094243c08d88ad6d28c3d", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-1160 - terminate/cancel task more comments from Holger"}, {"oid": "520eb4e2955e92eac7320a361fb228104fff5322", "committedDate": "2020-04-06 20:10:21 +0200", "message": "TSK-1177 update Planned of Task if only Due was changed"}, {"oid": "c6755b35b7226f4989aeea25ceeb3e18204fed45", "committedDate": "2020-05-22 03:25:57 +0200", "message": "TSK-1244: added due/planned logic for SLA P0D"}, {"oid": "ab6e5ecc3333dd578bea53a4562d211f2a766719", "committedDate": "2020-05-22 03:25:57 +0200", "message": "TSK-1244: optimized due/planned logic for SLA P0D"}, {"oid": "7e411d42e157b482e0e3c47eee5f75d9105cdbbe", "committedDate": "2020-05-22 03:48:27 +0200", "message": "TSK-1252: fixed newly introduced code smells"}, {"oid": "d4a516863e40f77bd494e1f1c8d95712d0e21f11", "committedDate": "2020-05-22 15:00:04 +0200", "message": "TSK-1226: made corpus christi configurable from taskana.properties file"}, {"oid": "8832876b9372c135c2c2fce88bc4820a1cab37d7", "committedDate": "2020-06-03 14:32:31 +0200", "message": "TSK-1247: Removed LoggerUtils and replaced its usages with the standard toString implementations"}, {"oid": "02e05a7d3b0eb4f0a238105fef73a1fa19b8ab5c", "committedDate": "2020-06-11 21:56:30 +0200", "message": "TSK-1286: refactored WorkingDaysToDaysConverter"}, {"oid": "41973183bcb5211ef940e834f81e74321323d996", "committedDate": "2020-08-07 14:59:19 +0200", "message": "TSK-1337: removed some code smells"}, {"oid": "34d2bbfa929ccaa9e9b93c173b8fa867154330bb", "committedDate": "2021-07-14 10:49:34 +0200", "message": "TSK-1647: Implemented an error key for every exception"}, {"oid": "8edb488bd3f854568dab1ee56c8d974fe63f95cd", "committedDate": "2021-07-14 10:49:34 +0200", "message": "TSK-1647: Implemented global frontend error handling using backend error keys"}, {"oid": "14baeb8bc1d1bbc80fe19df73df2cc7e638f9b43", "committedDate": "2021-08-26 10:32:46 +0200", "message": "TSK-1703: Create configuration property that allows to create & update due and planned timestamps with service level mismatch"}, {"oid": "f70d84579386fa560e6013485f276d0ebb19386a", "committedDate": "2022-03-29 09:44:13 +0200", "message": "TSK-1802: add manual priority to task in taskana-core"}, {"oid": "93d0b27bb058a4f47218177136bce81f99103345", "committedDate": "2022-04-26 15:27:56 +0200", "message": "TSK-1831: dropped support for JDK8"}, {"oid": "4697fbe5beefd1c72144187847ee99fcd0883d9c", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-2004: JavaDoc 4 TaskanaConfiguration.Builder#initTaskanaProperties"}, {"oid": "4a42a35a212f6bd25839432f48ec813c106874fc", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-1972: calculates working time in any resolution"}, {"oid": "fb11ff97b30a3f1277d49d48a8164c4f95bb0a6d", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-1972: Task.dueDate is inclusive."}, {"oid": "55d939ca7b7720ab12f488ed8fc2a631ecc6f05c", "committedDate": "2023-03-13 19:02:53 +0100", "message": "format entire codebase with new google-java-format version"}, {"oid": "d96b1c392a0f9ecfe72e7d0bc0aadac17620133c", "committedDate": "2023-03-15 01:00:50 +0100", "message": "TSK-1991: rework of property names"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE2MjAwOA==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r399162008", "body": "Sorry, haven't seen this one right away. As we don't reset the claimed timestamp, we shouldn't reset the owner as well.", "bodyText": "Sorry, haven't seen this one right away. As we don't reset the claimed timestamp, we shouldn't reset the owner as well.", "bodyHTML": "<p dir=\"auto\">Sorry, haven't seen this one right away. As we don't reset the claimed timestamp, we shouldn't reset the owner as well.</p>", "author": "holgerhagen", "createdAt": "2020-03-27T10:17:10Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java", "diffHunk": "@@ -951,6 +979,27 @@ private TaskImpl checkConcurrencyAndSetModified(TaskImpl newTaskImpl, TaskImpl o\n     return newTaskImpl;\n   }\n \n+  private TaskImpl terminateCancelCommonActions(String taskId, TaskState targetState)\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n+    if (taskId == null || taskId.isEmpty()) {\n+      throw new TaskNotFoundException(taskId, String.format(TASK_WITH_ID_WAS_NOT_FOUND, taskId));\n+    }\n+    TaskImpl task = (TaskImpl) getTask(taskId);\n+    TaskState state = task.getState();\n+    if (state.isEndState()) {\n+      throw new InvalidStateException(String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n+    }\n+\n+    Instant now = Instant.now();\n+    task.setOwner(null);", "originalCommit": "4c65a6087e83b85e44118a754cf749a23cac5250", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI5NTQxOA==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r399295418", "bodyText": "Done", "author": "BerndBreier", "createdAt": "2020-03-27T14:15:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE2MjAwOA=="}], "type": "inlineReview", "revised_code": {"commit": "62d58b32c908be3bf05b5068497e4be5a20002e6", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 47a6735b9..fba7860b2 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -991,7 +991,6 @@ public class TaskServiceImpl implements TaskService {\n     }\n \n     Instant now = Instant.now();\n-    task.setOwner(null);\n     task.setModified(now);\n     task.setCompleted(now);\n     task.setState(targetState);\n", "next_change": null}]}, "revised_code_in_main": {"commit": "6bd6bd48386155644df0463edf8aeda473bd1a56", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 47a6735b9..fba7860b2 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -991,7 +991,6 @@ public class TaskServiceImpl implements TaskService {\n     }\n \n     Instant now = Instant.now();\n-    task.setOwner(null);\n     task.setModified(now);\n     task.setCompleted(now);\n     task.setState(targetState);\n", "next_change": {"commit": "3b13b9a95e4d7d1cf172f22fa0f2679ff1c5f79b", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex fba7860b2..e4e8b398d 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -963,85 +755,23 @@ public class TaskServiceImpl implements TaskService {\n     return result;\n   }\n \n-  private TaskImpl checkConcurrencyAndSetModified(TaskImpl newTaskImpl, TaskImpl oldTaskImpl)\n-      throws ConcurrencyException {\n-    // TODO: not safe to rely only on different timestamps.\n-    // With fast execution below 1ms there will be no concurrencyException\n-    if (oldTaskImpl.getModified() != null\n-            && !oldTaskImpl.getModified().equals(newTaskImpl.getModified())\n-        || oldTaskImpl.getClaimed() != null\n-            && !oldTaskImpl.getClaimed().equals(newTaskImpl.getClaimed())\n-        || oldTaskImpl.getState() != null\n-            && !oldTaskImpl.getState().equals(newTaskImpl.getState())) {\n-      throw new ConcurrencyException(\"The task has already been updated by another user\");\n-    }\n-    newTaskImpl.setModified(Instant.now());\n-    return newTaskImpl;\n-  }\n-\n-  private TaskImpl terminateCancelCommonActions(String taskId, TaskState targetState)\n-      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n-    if (taskId == null || taskId.isEmpty()) {\n-      throw new TaskNotFoundException(taskId, String.format(TASK_WITH_ID_WAS_NOT_FOUND, taskId));\n-    }\n-    TaskImpl task = (TaskImpl) getTask(taskId);\n-    TaskState state = task.getState();\n-    if (state.isEndState()) {\n-      throw new InvalidStateException(String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n-    }\n-\n-    Instant now = Instant.now();\n-    task.setModified(now);\n-    task.setCompleted(now);\n-    task.setState(targetState);\n-    taskMapper.update(task);\n-    LOGGER.debug(\"Task '{}' cancelled by user '{}'.\", taskId, CurrentUserContext.getUserid());\n-    return task;\n-  }\n-\n-  private BulkOperationResults<String, TaskanaException> addExceptionsForTasksWhoseOwnerWasNotSet(\n-      String owner, List<MinimalTaskSummary> existingMinimalTaskSummaries) {\n-    BulkOperationResults<String, TaskanaException> bulkLog = new BulkOperationResults<>();\n-\n-    for (MinimalTaskSummary taskSummary : existingMinimalTaskSummaries) {\n-      if (!owner.equals(taskSummary.getOwner())) { // owner was not set\n-        if (!TaskState.READY.equals(taskSummary.getTaskState())) { // due to invalid state\n-          bulkLog.addError(\n-              taskSummary.getTaskId(),\n-              new InvalidStateException(\n-                  String.format(\n-                      TASK_WITH_ID_IS_NOT_READY,\n-                      taskSummary.getTaskId(),\n-                      taskSummary.getTaskState())));\n-        } else { // due to unknown reason\n-          bulkLog.addError(\n-              taskSummary.getTaskId(),\n-              new UpdateFailedException(\n-                  String.format(\"Could not set owner of Task %s .\", taskSummary.getTaskId())));\n-        }\n-      }\n-    }\n-    return bulkLog;\n-  }\n-\n   private Task claim(String taskId, boolean forceClaim)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException {\n     String userId = CurrentUserContext.getUserid();\n     LOGGER.debug(\n         \"entry to claim(id = {}, userId = {}, forceClaim = {})\", taskId, userId, forceClaim);\n-    TaskImpl task;\n+    TaskImpl task = null;\n     try {\n       taskanaEngine.openConnection();\n       task = (TaskImpl) getTask(taskId);\n       TaskState state = task.getState();\n-      if (!state.in(TaskState.READY, TaskState.CLAIMED)) {\n-        throw new InvalidStateException(\n-            String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n+      if (state == TaskState.COMPLETED) {\n+        throw new InvalidStateException(TASK_WITH_ID + taskId + IS_ALREADY_COMPLETED);\n       }\n       if (state == TaskState.CLAIMED && !forceClaim && !task.getOwner().equals(userId)) {\n         throw new InvalidOwnerException(\n-            String.format(TASK_WITH_ID_IS_ALREADY_CLAIMED_BY, taskId, task.getOwner()));\n+            TASK_WITH_ID + taskId + IS_ALREADY_CLAIMED_BY + task.getOwner() + \".\");\n       }\n       Instant now = Instant.now();\n       task.setOwner(userId);\n", "next_change": {"commit": "2ce7f86456f99d522e001080e9504ae4cd6a80f4", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex e4e8b398d..382c3861a 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -755,23 +963,88 @@ public class TaskServiceImpl implements TaskService {\n     return result;\n   }\n \n+  private TaskImpl checkConcurrencyAndSetModified(TaskImpl newTaskImpl, TaskImpl oldTaskImpl)\n+      throws ConcurrencyException {\n+    // TODO: not safe to rely only on different timestamps.\n+    // With fast execution below 1ms there will be no concurrencyException\n+    if (oldTaskImpl.getModified() != null\n+            && !oldTaskImpl.getModified().equals(newTaskImpl.getModified())\n+        || oldTaskImpl.getClaimed() != null\n+            && !oldTaskImpl.getClaimed().equals(newTaskImpl.getClaimed())\n+        || oldTaskImpl.getState() != null\n+            && !oldTaskImpl.getState().equals(newTaskImpl.getState())) {\n+      throw new ConcurrencyException(\"The task has already been updated by another user\");\n+    }\n+    newTaskImpl.setModified(Instant.now());\n+    return newTaskImpl;\n+  }\n+\n+  private TaskImpl terminateCancelCommonActions(String taskId, TaskState targetState)\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n+    if (taskId == null || taskId.isEmpty()) {\n+      throw new TaskNotFoundException(taskId, String.format(TASK_WITH_ID_WAS_NOT_FOUND, taskId));\n+    }\n+    TaskImpl task = (TaskImpl) getTask(taskId);\n+    TaskState state = task.getState();\n+    if (state.isEndState()) {\n+      throw new InvalidStateException(String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n+    }\n+\n+    Instant now = Instant.now();\n+    task.setOwner(null);\n+    task.setModified(now);\n+    task.setCompleted(now);\n+    task.setClaimed(null);\n+    task.setRead(true);\n+    task.setState(targetState);\n+    taskMapper.update(task);\n+    LOGGER.debug(\"Task '{}' cancelled by user '{}'.\", taskId, CurrentUserContext.getUserid());\n+    return task;\n+  }\n+\n+  private BulkOperationResults<String, TaskanaException> addExceptionsForTasksWhoseOwnerWasNotSet(\n+      String owner, List<MinimalTaskSummary> existingMinimalTaskSummaries) {\n+    BulkOperationResults<String, TaskanaException> bulkLog = new BulkOperationResults<>();\n+\n+    for (MinimalTaskSummary taskSummary : existingMinimalTaskSummaries) {\n+      if (!owner.equals(taskSummary.getOwner())) { // owner was not set\n+        if (!TaskState.READY.equals(taskSummary.getTaskState())) { // due to invalid state\n+          bulkLog.addError(\n+              taskSummary.getTaskId(),\n+              new InvalidStateException(\n+                  String.format(\n+                      TASK_WITH_ID_IS_NOT_READY,\n+                      taskSummary.getTaskId(),\n+                      taskSummary.getTaskState())));\n+        } else { // due to unknown reason\n+          bulkLog.addError(\n+              taskSummary.getTaskId(),\n+              new UpdateFailedException(\n+                  String.format(\"Could not set owner of Task %s .\", taskSummary.getTaskId())));\n+        }\n+      }\n+    }\n+    return bulkLog;\n+  }\n+\n   private Task claim(String taskId, boolean forceClaim)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException {\n     String userId = CurrentUserContext.getUserid();\n     LOGGER.debug(\n         \"entry to claim(id = {}, userId = {}, forceClaim = {})\", taskId, userId, forceClaim);\n-    TaskImpl task = null;\n+    TaskImpl task;\n     try {\n       taskanaEngine.openConnection();\n       task = (TaskImpl) getTask(taskId);\n       TaskState state = task.getState();\n-      if (state == TaskState.COMPLETED) {\n-        throw new InvalidStateException(TASK_WITH_ID + taskId + IS_ALREADY_COMPLETED);\n+      if (!state.isInStates(TaskState.READY, TaskState.CLAIMED)) {\n+        throw new InvalidStateException(\n+            String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n       }\n       if (state == TaskState.CLAIMED && !forceClaim && !task.getOwner().equals(userId)) {\n         throw new InvalidOwnerException(\n-            TASK_WITH_ID + taskId + IS_ALREADY_CLAIMED_BY + task.getOwner() + \".\");\n+            String.format(TASK_WITH_ID_IS_ALREADY_CLAIMED_BY, taskId, task.getOwner()));\n       }\n       Instant now = Instant.now();\n       task.setOwner(userId);\n", "next_change": {"commit": "6f12677b74a36ec04e282def79e8b549d48c1988", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 382c3861a..5285ea062 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1037,21 +1182,10 @@ public class TaskServiceImpl implements TaskService {\n     try {\n       taskanaEngine.openConnection();\n       task = (TaskImpl) getTask(taskId);\n-      TaskState state = task.getState();\n-      if (!state.isInStates(TaskState.READY, TaskState.CLAIMED)) {\n-        throw new InvalidStateException(\n-            String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n-      }\n-      if (state == TaskState.CLAIMED && !forceClaim && !task.getOwner().equals(userId)) {\n-        throw new InvalidOwnerException(\n-            String.format(TASK_WITH_ID_IS_ALREADY_CLAIMED_BY, taskId, task.getOwner()));\n-      }\n       Instant now = Instant.now();\n-      task.setOwner(userId);\n-      task.setModified(now);\n-      task.setClaimed(now);\n-      task.setRead(true);\n-      task.setState(TaskState.CLAIMED);\n+\n+      checkPreconditionsForClaimTask(task, forceClaim);\n+      claimActionsOnTask(task, userId, now);\n       taskMapper.update(task);\n       LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n       if (HistoryEventProducer.isHistoryEnabled()) {\n", "next_change": {"commit": "d8ad7a7fb96e7d07e5f93e202cd84e03e5c1944a", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 5285ea062..f6299c27e 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1188,8 +1217,12 @@ public class TaskServiceImpl implements TaskService {\n       claimActionsOnTask(task, userId, now);\n       taskMapper.update(task);\n       LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n-      if (HistoryEventProducer.isHistoryEnabled()) {\n-        historyEventProducer.createEvent(new ClaimedEvent(task, CurrentUserContext.getUserid()));\n+      if (HistoryEventManager.isHistoryEnabled()) {\n+        historyEventManager.createEvent(\n+            new ClaimedEvent(\n+                IdGenerator.generateWithPrefix(ID_PREFIX_HISTORY_EVENT),\n+                task,\n+                CurrentUserContext.getUserid()));\n       }\n     } finally {\n       taskanaEngine.returnConnection();\n", "next_change": {"commit": "29ba5fe418ad6702648d7427d5c18b3fd06bbe83", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex f6299c27e..e11e382dc 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1219,7 +1186,7 @@ public class TaskServiceImpl implements TaskService {\n       LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n       if (HistoryEventManager.isHistoryEnabled()) {\n         historyEventManager.createEvent(\n-            new ClaimedEvent(\n+            new TaskClaimedEvent(\n                 IdGenerator.generateWithPrefix(ID_PREFIX_HISTORY_EVENT),\n                 task,\n                 CurrentUserContext.getUserid()));\n", "next_change": {"commit": "44cb21b5aec13e6548a0546dc8eb221fb1cd29ad", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex e11e382dc..5504cb522 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1189,7 +1200,7 @@ public class TaskServiceImpl implements TaskService {\n             new TaskClaimedEvent(\n                 IdGenerator.generateWithPrefix(ID_PREFIX_HISTORY_EVENT),\n                 task,\n-                CurrentUserContext.getUserid()));\n+                taskanaEngine.getEngine().getCurrentUserContext().getUserid()));\n       }\n     } finally {\n       taskanaEngine.returnConnection();\n", "next_change": {"commit": "b23c6873db22e24a0b713441317fec405db55708", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 5504cb522..fd50b0ae2 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1198,7 +1181,7 @@ public class TaskServiceImpl implements TaskService {\n       if (HistoryEventManager.isHistoryEnabled()) {\n         historyEventManager.createEvent(\n             new TaskClaimedEvent(\n-                IdGenerator.generateWithPrefix(ID_PREFIX_HISTORY_EVENT),\n+                IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n                 task,\n                 taskanaEngine.getEngine().getCurrentUserContext().getUserid()));\n       }\n", "next_change": {"commit": "bfcabea61048ccb21a591e0c4f1f8efecc7636b4", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex fd50b0ae2..ad45e047c 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1177,7 +1143,9 @@ public class TaskServiceImpl implements TaskService {\n       checkPreconditionsForClaimTask(task, forceClaim);\n       claimActionsOnTask(task, userId, now);\n       taskMapper.update(task);\n-      LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n+      if (LOGGER.isDebugEnabled()) {\n+        LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n+      }\n       if (HistoryEventManager.isHistoryEnabled()) {\n         historyEventManager.createEvent(\n             new TaskClaimedEvent(\n", "next_change": {"commit": "fb4234b6f180423c4789ba904709fd78edf7bf4f", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex ad45e047c..adc9804fa 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1146,7 +1115,7 @@ public class TaskServiceImpl implements TaskService {\n       if (LOGGER.isDebugEnabled()) {\n         LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n       }\n-      if (HistoryEventManager.isHistoryEnabled()) {\n+      if (historyEventManager.isEnabled()) {\n         historyEventManager.createEvent(\n             new TaskClaimedEvent(\n                 IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n", "next_change": {"commit": "43ed441daf60d22a579d93fde840861770b4ede5", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex adc9804fa..96da61dd7 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1116,11 +1175,15 @@ public class TaskServiceImpl implements TaskService {\n         LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n       }\n       if (historyEventManager.isEnabled()) {\n+        String changeDetails =\n+            ObjectAttributeChangeDetector.determineChangesInAttributes(oldTask, task);\n+\n         historyEventManager.createEvent(\n             new TaskClaimedEvent(\n                 IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n                 task,\n-                taskanaEngine.getEngine().getCurrentUserContext().getUserid()));\n+                taskanaEngine.getEngine().getCurrentUserContext().getUserid(),\n+                changeDetails));\n       }\n     } finally {\n       taskanaEngine.returnConnection();\n", "next_change": {"commit": "ef875dd42a58b55bace25fb4f599d84e4d06b59b", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 96da61dd7..0b2c71e16 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1191,12 +1204,63 @@ public class TaskServiceImpl implements TaskService {\n     return task;\n   }\n \n+  private Task requestReview(String taskId, boolean force)\n+      throws TaskNotFoundException, NotAuthorizedException, InvalidTaskStateException,\n+          InvalidOwnerException {\n+    String userId = taskanaEngine.getEngine().getCurrentUserContext().getUserid();\n+    TaskImpl task;\n+    try {\n+      taskanaEngine.openConnection();\n+      task = (TaskImpl) getTask(taskId);\n+\n+      TaskImpl oldTask = duplicateTaskExactly(task);\n+\n+      if (force && task.getState().isEndState()) {\n+        throw new InvalidTaskStateException(\n+            task.getId(), task.getState(), EnumUtil.allValuesExceptFor(TaskState.END_STATES));\n+      }\n+      if (!force && task.getState() != TaskState.CLAIMED) {\n+        throw new InvalidTaskStateException(task.getId(), task.getState(), TaskState.CLAIMED);\n+      }\n+      if (!force && !task.getOwner().equals(userId)) {\n+        throw new InvalidOwnerException(userId, task.getId());\n+      }\n+\n+      task.setState(TaskState.READY_FOR_REVIEW);\n+      task.setOwner(null);\n+      task.setModified(Instant.now());\n+\n+      taskMapper.update(task);\n+      if (LOGGER.isDebugEnabled()) {\n+        LOGGER.debug(\"Requested review for Task '{}' by user '{}'.\", taskId, userId);\n+      }\n+      if (historyEventManager.isEnabled()) {\n+        String changeDetails =\n+            ObjectAttributeChangeDetector.determineChangesInAttributes(oldTask, task);\n+\n+        historyEventManager.createEvent(\n+            new TaskRequestReviewEvent(\n+                IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n+                task,\n+                taskanaEngine.getEngine().getCurrentUserContext().getUserid(),\n+                changeDetails));\n+      }\n+    } finally {\n+      taskanaEngine.returnConnection();\n+    }\n+    return task;\n+  }\n+\n   private static void claimActionsOnTask(TaskSummaryImpl task, String userId, Instant now) {\n     task.setOwner(userId);\n     task.setModified(now);\n     task.setClaimed(now);\n     task.setRead(true);\n-    task.setState(TaskState.CLAIMED);\n+    if (Set.of(TaskState.READY_FOR_REVIEW, TaskState.IN_REVIEW).contains(task.getState())) {\n+      task.setState(TaskState.IN_REVIEW);\n+    } else {\n+      task.setState(TaskState.CLAIMED);\n+    }\n   }\n \n   private static void cancelClaimActionsOnTask(TaskSummaryImpl task, Instant now) {\n", "next_change": null}]}}]}}]}}, {"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex fd50b0ae2..ad45e047c 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1187,7 +1155,6 @@ public class TaskServiceImpl implements TaskService {\n       }\n     } finally {\n       taskanaEngine.returnConnection();\n-      LOGGER.debug(\"exit from claim()\");\n     }\n     return task;\n   }\n", "next_change": {"commit": "43ed441daf60d22a579d93fde840861770b4ede5", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex ad45e047c..96da61dd7 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1146,12 +1174,16 @@ public class TaskServiceImpl implements TaskService {\n       if (LOGGER.isDebugEnabled()) {\n         LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n       }\n-      if (HistoryEventManager.isHistoryEnabled()) {\n+      if (historyEventManager.isEnabled()) {\n+        String changeDetails =\n+            ObjectAttributeChangeDetector.determineChangesInAttributes(oldTask, task);\n+\n         historyEventManager.createEvent(\n             new TaskClaimedEvent(\n                 IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n                 task,\n-                taskanaEngine.getEngine().getCurrentUserContext().getUserid()));\n+                taskanaEngine.getEngine().getCurrentUserContext().getUserid(),\n+                changeDetails));\n       }\n     } finally {\n       taskanaEngine.returnConnection();\n", "next_change": {"commit": "ef875dd42a58b55bace25fb4f599d84e4d06b59b", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 96da61dd7..0b2c71e16 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1191,12 +1204,63 @@ public class TaskServiceImpl implements TaskService {\n     return task;\n   }\n \n+  private Task requestReview(String taskId, boolean force)\n+      throws TaskNotFoundException, NotAuthorizedException, InvalidTaskStateException,\n+          InvalidOwnerException {\n+    String userId = taskanaEngine.getEngine().getCurrentUserContext().getUserid();\n+    TaskImpl task;\n+    try {\n+      taskanaEngine.openConnection();\n+      task = (TaskImpl) getTask(taskId);\n+\n+      TaskImpl oldTask = duplicateTaskExactly(task);\n+\n+      if (force && task.getState().isEndState()) {\n+        throw new InvalidTaskStateException(\n+            task.getId(), task.getState(), EnumUtil.allValuesExceptFor(TaskState.END_STATES));\n+      }\n+      if (!force && task.getState() != TaskState.CLAIMED) {\n+        throw new InvalidTaskStateException(task.getId(), task.getState(), TaskState.CLAIMED);\n+      }\n+      if (!force && !task.getOwner().equals(userId)) {\n+        throw new InvalidOwnerException(userId, task.getId());\n+      }\n+\n+      task.setState(TaskState.READY_FOR_REVIEW);\n+      task.setOwner(null);\n+      task.setModified(Instant.now());\n+\n+      taskMapper.update(task);\n+      if (LOGGER.isDebugEnabled()) {\n+        LOGGER.debug(\"Requested review for Task '{}' by user '{}'.\", taskId, userId);\n+      }\n+      if (historyEventManager.isEnabled()) {\n+        String changeDetails =\n+            ObjectAttributeChangeDetector.determineChangesInAttributes(oldTask, task);\n+\n+        historyEventManager.createEvent(\n+            new TaskRequestReviewEvent(\n+                IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n+                task,\n+                taskanaEngine.getEngine().getCurrentUserContext().getUserid(),\n+                changeDetails));\n+      }\n+    } finally {\n+      taskanaEngine.returnConnection();\n+    }\n+    return task;\n+  }\n+\n   private static void claimActionsOnTask(TaskSummaryImpl task, String userId, Instant now) {\n     task.setOwner(userId);\n     task.setModified(now);\n     task.setClaimed(now);\n     task.setRead(true);\n-    task.setState(TaskState.CLAIMED);\n+    if (Set.of(TaskState.READY_FOR_REVIEW, TaskState.IN_REVIEW).contains(task.getState())) {\n+      task.setState(TaskState.IN_REVIEW);\n+    } else {\n+      task.setState(TaskState.CLAIMED);\n+    }\n   }\n \n   private static void cancelClaimActionsOnTask(TaskSummaryImpl task, Instant now) {\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6bd6bd48386155644df0463edf8aeda473bd1a56", "message": "Merge commit", "committedDate": null}, {"oid": "3b13b9a95e4d7d1cf172f22fa0f2679ff1c5f79b", "committedDate": "2020-02-03 11:41:02 +0100", "message": "TSK-991 after initial refactoring"}, {"oid": "27dd9b299b93ff13dc2d18f5803e2e314b1ac246", "committedDate": "2020-02-03 11:41:02 +0100", "message": "TSK-991 Restructuring- restructure history package"}, {"oid": "5815e38fa75956de6715569967afe7e7fc8dcd43", "committedDate": "2020-02-05 13:02:31 +0100", "message": "TSK-991: Fix Architecturtest and split DaysToWorkingDays converter for report and common"}, {"oid": "22ac25f5c9244bdc67752b7adcb9d98f4b8d6fa2", "committedDate": "2020-02-06 14:05:27 +0100", "message": "TSK-927 reserve a task via SetOwner"}, {"oid": "e308578ced577706e1f6994473e0e6252f647b9e", "committedDate": "2020-02-06 17:26:05 +0100", "message": "TSK-991: refactored report structure to meet api -> internal agreement"}, {"oid": "6eeff1ba22f5a07e459089fcb02074116ecb2d53", "committedDate": "2020-02-07 08:36:52 +0100", "message": "TSK-1065 Refactor TaskImpl"}, {"oid": "6c73ed18f205b350b1219e7f61f25f87ebe2e507", "committedDate": "2020-02-07 09:26:45 +0100", "message": "TSK-1064: refactored / simplified streams and boolean expressions"}, {"oid": "a5b3254c8dc8bbe193406920c50d9a81386adf4f", "committedDate": "2020-02-07 09:26:45 +0100", "message": "TSK-1064: refactored PrioDurationHolder -> generic Pair"}, {"oid": "f3f71a66b571f17cd1830dd19c6ff9aac186985a", "committedDate": "2020-02-11 09:48:03 +0100", "message": "TSK-1097"}, {"oid": "448d4fb8fc4586fc7bfa6b1083a22cc1453936a8", "committedDate": "2020-02-11 16:09:51 +0100", "message": "TSK-1107 Use userId-parameter in contructor of TaskanaHistoryEvent"}, {"oid": "5c7d38451ce7cbea2ad52d3b84be72d49c474c71", "committedDate": "2020-02-13 15:09:39 +0100", "message": "TSK-1094 introduce models package for */api and */internal"}, {"oid": "ddb12a6ad15965ad6e87d0920c975d425c575249", "committedDate": "2020-02-14 12:04:52 +0100", "message": "TSK-1095"}, {"oid": "20bd0922dbc332efcf4e94a0d487b077c95c5a85", "committedDate": "2020-02-26 14:48:50 +0100", "message": "TSK-1131 updateOwner on multiple tasks"}, {"oid": "7f93dd048e6b406ff43ad3b8007f3d149e015af6", "committedDate": "2020-02-26 14:48:50 +0100", "message": "TSK-1131 updateOwner Bulk - comments from Holger"}, {"oid": "02a6df6f73622e86684c6c30d8f320c84078b237", "committedDate": "2020-02-28 10:46:45 +0100", "message": "TSK-1139 Bulk update of Planned timestamp"}, {"oid": "3b7da72d24beb1e0f6d528f575b1ae7029f10e7f", "committedDate": "2020-03-17 11:54:26 +0100", "message": "TSK-1150 Java-API for the administration of comments for tasks"}, {"oid": "7d464bd6cde263ad9b674e5d796fcf91e4a727bf", "committedDate": "2020-03-17 11:54:26 +0100", "message": "TSK-1150 Comments from Bernd Breier"}, {"oid": "1291287419385725f59ed90a8e8960d57c8638e0", "committedDate": "2020-03-19 14:43:16 +0100", "message": "TSK-1143 UpdateTask with Planned sometimes fails"}, {"oid": "7deb9254113278ccf5872283c2abd202c3cf7af0", "committedDate": "2020-03-19 14:43:16 +0100", "message": "TSK-1143 UpdateTask planned - comments from Holger"}, {"oid": "f78e7616f65b1cf9575f246daf4bba856a3e8f1c", "committedDate": "2020-03-19 14:43:16 +0100", "message": "TSK-1143 Update Task PLANNED - Holger's comments"}, {"oid": "e470f8d200ef88c137645111f715b058ca9803e3", "committedDate": "2020-03-19 14:43:16 +0100", "message": "TSK-1143 even more comments from Holger"}, {"oid": "c2d974b02ea0182bfcda6f99d253b83372cf6335", "committedDate": "2020-03-26 08:47:03 +0100", "message": "TSK-1143 UpdateTask with Planned sometimes fails"}, {"oid": "87fd1af390f7c4abe4e4097f2e52a48bf1e68c5a", "committedDate": "2020-03-26 08:47:03 +0100", "message": "TSK-442 improve task refresh on classification update"}, {"oid": "7352a8a7280794299e8e0250c2b30744037a2a8b", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-1143 UpdateTask with Planned sometimes fails"}, {"oid": "28fbeb8a2e116f5178815049770d17ebc1a90c3d", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-442 improve task refresh on classification update"}, {"oid": "2ce7f86456f99d522e001080e9504ae4cd6a80f4", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-1160 TaskStates CANCELLED and TERMINATED"}, {"oid": "d6505284f780ec7a804adf7d6156726e85ddd4ef", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-1160 - terminate/cancel task Holger's comments"}, {"oid": "7fdea5bef22fcd17413094243c08d88ad6d28c3d", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-1160 - terminate/cancel task more comments from Holger"}, {"oid": "93a94f0458979e35cb92ee682be312532d1e5210", "committedDate": "2020-03-31 11:56:59 +0200", "message": "TSK-1150: added taskId as pathvariable to getTaskComment and deleteTaskComment"}, {"oid": "dffb139a822c55fcf12438e6e996fdef41b6f098", "committedDate": "2020-03-31 11:56:59 +0200", "message": "comments from Holger Hagen"}, {"oid": "d5674ed11a70cc488a9699387b90272318a22444", "committedDate": "2020-04-22 13:41:20 +0200", "message": "TSK-746 Add simple history event tracking to update and create task method"}, {"oid": "8442be7903dfc14f6bcdef2cb72f353c726db9e3", "committedDate": "2020-04-22 13:41:20 +0200", "message": "Comment from Mustapha Zorgati"}, {"oid": "3fea9ab975e55f14c9924baeb1740ef989aa66c0", "committedDate": "2020-05-06 08:54:37 +0200", "message": "TSK-1197: readded test case for testing the ordering of the databases H2, Postgress and DB2; remove Db2 10.5 travis job TSK-1197: build Postgres image with german collation"}, {"oid": "eb73c0670f522b6d1936b4323cf940640f504775", "committedDate": "2020-05-11 16:08:12 +0200", "message": "TSK-1192 Introduced new Task-Admin Role"}, {"oid": "1f13c2c33ac0ce2c8202a23f5d977c87717894a3", "committedDate": "2020-05-13 14:49:18 +0200", "message": "TSK-1195: Secure deleteTasks in TaskServiceImpl"}, {"oid": "8832876b9372c135c2c2fce88bc4820a1cab37d7", "committedDate": "2020-06-03 14:32:31 +0200", "message": "TSK-1247: Removed LoggerUtils and replaced its usages with the standard toString implementations"}, {"oid": "496da17b3eec2490b68b27c4192b32c02935a2f0", "committedDate": "2020-06-07 15:56:30 +0200", "message": "TSK-1257: refactored claimtasks in taskService and increased test coverage"}, {"oid": "6f12677b74a36ec04e282def79e8b549d48c1988", "committedDate": "2020-06-07 15:56:30 +0200", "message": "TSK-1257: implementes forceCompleteTasks"}, {"oid": "36adf71b904abe5730aba921d72a3c76cb4c5146", "committedDate": "2020-06-07 15:56:30 +0200", "message": "TSK-1257: replaced multiple helper methods with abstract helper method"}, {"oid": "a2318c267ea7f6d57cfffefc04c5285e66778fac", "committedDate": "2020-06-12 12:31:55 +0200", "message": "reformatted code"}, {"oid": "1dfe54c0b6fb05c6811573e38feba9212fdb6a9f", "committedDate": "2020-06-30 14:50:26 +0200", "message": "TSK-1275: Support select and claim in one API call"}, {"oid": "969d3eeff653d51eb7dcf5234aa4020333613ab3", "committedDate": "2020-06-30 14:50:26 +0200", "message": "review Findings"}, {"oid": "d8ad7a7fb96e7d07e5f93e202cd84e03e5c1944a", "committedDate": "2020-07-10 13:13:42 +0200", "message": "TSK-1250 On demand deletion of historical data"}, {"oid": "4bba93c5a98dcbe22dc86144b12507abce4b2be4", "committedDate": "2020-07-10 13:13:42 +0200", "message": "Review findings"}, {"oid": "abced36ecdc2edff824b2857da78581c94c40970", "committedDate": "2020-07-16 11:26:06 +0200", "message": "TSK-1336: Remove unnecessary warn logging in updateTask()"}, {"oid": "7cc5b00be617227dac2f8d1210554108d18bad4a", "committedDate": "2020-07-24 01:05:42 +0200", "message": "TSK-1345: replaced every customField API call with CustomField enums"}, {"oid": "b7237021e2e77fc0648e8117a725220d9560b3d2", "committedDate": "2020-08-05 16:48:33 +0200", "message": "TSK-1333: Add history events for cancelled/terminated tasks"}, {"oid": "29ba5fe418ad6702648d7427d5c18b3fd06bbe83", "committedDate": "2020-08-12 13:27:26 +0200", "message": "TSK-1335: Add workbasket history events"}, {"oid": "198572b6b15d375d99fd565d43cb99888b021e60", "committedDate": "2020-09-23 09:13:40 +0200", "message": "TSK-1390: Add SPI to allow task processing before creation"}, {"oid": "0e83abd0fda3d25585359a4655b1bc1e50429f39", "committedDate": "2020-09-23 09:13:40 +0200", "message": "TSK-1390: Review findings"}, {"oid": "44cb21b5aec13e6548a0546dc8eb221fb1cd29ad", "committedDate": "2020-10-09 10:25:54 +0200", "message": "TSK-1277: removed circular dependency between taskana-common and taskana-core"}, {"oid": "b23c6873db22e24a0b713441317fec405db55708", "committedDate": "2020-10-13 19:58:28 +0200", "message": "TSK-1335: removed last occurences of \"HEI\" prefix for history events"}, {"oid": "039dee4fb21035bcb9ca36e3c0becf59c03fed6c", "committedDate": "2020-11-02 09:41:48 +0100", "message": "TSK-1282: updated taskana-core to jdk11"}, {"oid": "28b3ce6f8a563bf74bf02382b77c3b817085f127", "committedDate": "2020-11-02 09:41:48 +0100", "message": "TSK-1282: replaced all usages of Arrays.asList with List.of"}, {"oid": "81b89e1c08b67fb383605fe061dec07fec4a557a", "committedDate": "2020-11-06 14:53:40 +0100", "message": "TSK-1441: Enable Admin to complete tasks already claimed by other users"}, {"oid": "ab672b27d4593dc7bf179d2e3c107a8a3ae0196f", "committedDate": "2021-01-05 15:27:27 +0100", "message": "TSK-1362: Fixed the test data to not include invalid owners for Workbaskets (#1379)"}, {"oid": "c6e82c1368da17762918b1ef5102974a302124af", "committedDate": "2021-02-02 08:16:07 +0100", "message": "TSK-1506: Fixed bug for Cleanup Jobs with more than 32767 tasks (#1457)"}, {"oid": "aa6d304b499a9df48d90ff3bfc375b25c5f00a71", "committedDate": "2021-02-03 09:34:22 +0100", "message": "TSK-1499: Fixed bug of also cleaning completed tasks with parentProcessId null/empty (#1394)"}, {"oid": "0119999380b40fdc0f69677f96650de5c81bd2a5", "committedDate": "2021-03-09 18:58:51 +0100", "message": "TSK-1538: Added transfer method with control setTransferFlag (#1513)"}, {"oid": "3ddcd2ae97ffea8bd479655e70d5182141d12220", "committedDate": "2021-04-23 17:28:11 +0200", "message": "TSK-1628: New DmnTaskRouter module"}, {"oid": "b8892020d98b905a2e4cbe12a344d93fcc68af25", "committedDate": "2021-05-19 10:29:13 +0200", "message": "TSK-795: Changed Exception when creating a Task with a non-empty taskId (#1575)"}, {"oid": "bfcabea61048ccb21a591e0c4f1f8efecc7636b4", "committedDate": "2021-05-20 09:41:58 +0200", "message": "TSK-1596: Automatic TraceLogging (#1577)"}, {"oid": "7636ec0b2a8e12ea5b3cff48f7b702472b603e5d", "committedDate": "2021-06-01 09:51:38 +0200", "message": "TSK-1501: TaskTransferrer cleaned and restructured (#1599)"}, {"oid": "b66e4d9f862a14fc740e1c25c00e80e81c74abe9", "committedDate": "2021-06-09 12:37:56 +0200", "message": "TSK-1642: now setting details attribute for TaskTransferHistoryEvent"}, {"oid": "1c83b7871f144cd07a912639b942d5938219e101", "committedDate": "2021-06-22 16:14:09 +0200", "message": "TSK-1646: Bugfix for creation / update of Task with invalid Attachment"}, {"oid": "34d2bbfa929ccaa9e9b93c173b8fa867154330bb", "committedDate": "2021-07-14 10:49:34 +0200", "message": "TSK-1647: Implemented an error key for every exception"}, {"oid": "8edb488bd3f854568dab1ee56c8d974fe63f95cd", "committedDate": "2021-07-14 10:49:34 +0200", "message": "TSK-1647: Implemented global frontend error handling using backend error keys"}, {"oid": "358e699f9f0bdf8505ff0f44ac0ad5803cdcb5c8", "committedDate": "2021-07-16 11:08:05 +0200", "message": "TSK-1664: fixed some code smells and redesigned RestHelper"}, {"oid": "99eba636a1ec363282153ae857f651d2c5d2e592", "committedDate": "2021-07-29 14:58:57 +0200", "message": "TSK-1674: Added received timestamp to task (#1638)"}, {"oid": "6da07b069aae2d41a5b9949ea69b249e9ff7903a", "committedDate": "2021-08-02 11:46:33 +0200", "message": "TSK-1647: minor improvements and fixes"}, {"oid": "dc9e3a25ce9aa317ace656ebe58bdcfefaa8c4b5", "committedDate": "2021-08-20 21:21:57 +0200", "message": "TSK-1686: Introduced an SPI for the individual calculation of priorities"}, {"oid": "54428045dd57a6d295c9a1529274b08246c731eb", "committedDate": "2021-08-30 14:18:38 +0200", "message": "TSK-1718: Performance optimization for TaskService#getTask and TaskQuery#list"}, {"oid": "e9a1f02c2e828a123b191cc031bd473ba0e51fe7", "committedDate": "2021-09-16 09:21:29 +0200", "message": "TSK-1633: created all new test API for improved test data generation"}, {"oid": "fb4234b6f180423c4789ba904709fd78edf7bf4f", "committedDate": "2021-09-21 16:35:58 +0200", "message": "TSK-1704: test API now restricting service providers to specific test"}, {"oid": "e264a203892c6d2111df4645abf7f373bf4ca86a", "committedDate": "2021-10-08 08:38:21 +0200", "message": "TSK-1726: Implemented option to include long name on Task / TaskComment / TaskHistoryEvent"}, {"oid": "c7742b3056f4c2d11ff4ddeef980e177bb82bd64", "committedDate": "2021-11-26 13:18:27 +0100", "message": "TSK-1775: reformatted entire backend code base"}, {"oid": "967e59e012f94e116f2b327b6c426f44ae1bcbee", "committedDate": "2022-02-25 10:23:40 +0100", "message": "TSK-1800: add secondary object references"}, {"oid": "4f48fe93c633e31304fa808a96c3477d78b33f2c", "committedDate": "2022-03-08 17:10:37 +0100", "message": "TSK-1807: renamed setCustomAttribute to setCustomField"}, {"oid": "93d0b27bb058a4f47218177136bce81f99103345", "committedDate": "2022-04-26 15:27:56 +0200", "message": "TSK-1831: dropped support for JDK8"}, {"oid": "1ae1df890848d22617cd10c611e5d496428db790", "committedDate": "2022-05-19 09:31:13 +0200", "message": "TSK-1889: create TASK_ROUTER role"}, {"oid": "43ed441daf60d22a579d93fde840861770b4ede5", "committedDate": "2022-05-31 16:54:29 +0300", "message": "TSK-1812: Added details in task-history for claim/cancel"}, {"oid": "83890ddd16249632546e83011cf41759ddccb7da", "committedDate": "2022-07-19 15:27:44 +0200", "message": "TSK-1914: introduce IN_REVIEW and READY_FOR_REVIEW Task status"}, {"oid": "ef875dd42a58b55bace25fb4f599d84e4d06b59b", "committedDate": "2022-08-06 14:30:59 +0200", "message": "TSK-1915: Add requestReview functionality"}, {"oid": "cc32b10d82b7888ed2eae438100d2e26fb508f0c", "committedDate": "2022-08-09 13:19:02 +0200", "message": "TSK-1916: Add requestChanges functionality"}, {"oid": "1f9d20f76f98974ec6fe5fcc4657277f6eaaf5ae", "committedDate": "2022-08-10 12:18:14 +0200", "message": "TSK-1937: implemented AfterRequestReviewProvider"}, {"oid": "340236c4a26c7f9e6ed01d9b0f88b539eced56e3", "committedDate": "2022-08-11 12:17:08 +0200", "message": "TSK-1938: Add RequestChangesProvider"}, {"oid": "cf690bf6b5d8533ab73cef4de923797a1701a5c3", "committedDate": "2022-08-11 12:36:39 +0200", "message": "TSK-1941: implemented ReviewRequired SPI"}, {"oid": "1188f6396c31c6dd2d9f0eae5e6b3f5689a38966", "committedDate": "2022-08-20 17:46:27 +0200", "message": "TSK-1945: implemented BeforeRequestReview SPI"}, {"oid": "151d23d98d598b4a8da946655519664c7b7b4490", "committedDate": "2022-08-20 17:46:27 +0200", "message": "TSK-1945: minor cleanup of TaskServiceImpl"}, {"oid": "d8ffdb1824ffb6d67e417e798ad4ad9f8ee3a866", "committedDate": "2022-08-20 18:16:23 +0200", "message": "TSK-1944: Implemented BeforeRequestChanges SPI"}, {"oid": "3575b8aa17cb4168776b0377f4df81938c24e7b4", "committedDate": "2022-08-24 12:32:26 +0200", "message": "TSK-1926: Remove duplicate from TaskServiceImpl"}, {"oid": "dc9e2e1d5fd04dda9bde2a7838f2e068e66db984", "committedDate": "2022-10-20 21:49:16 +0200", "message": "TSK-1967: make owner of Task updatable when Task is 'READY_FOR_REVIEW'"}, {"oid": "f25b6eb550bc0f9e56c9a7953d5f2d3fbfa3e0d0", "committedDate": "2023-02-09 14:18:56 +0100", "message": "fix resquestReview for an IN_REVIEW Task"}, {"oid": "291cc38ea671e3fd23d8296008192f63f9d73c32", "committedDate": "2023-02-13 08:00:43 +0100", "message": "TSK-1971 support for oracle databases (#2050)"}, {"oid": "8bfb7fae95ef4e4bf7609b6f8f552579f2f9fd2c", "committedDate": "2023-02-14 09:40:46 +0100", "message": "TSK-1977: fix setting ownerLongName while claiming"}, {"oid": "68eacbbc3e1ff9a0a6d667b25cb80ec88558bb06", "committedDate": "2023-02-14 13:57:06 +0100", "message": "TSK-1976: set ownerLongName during Task creation"}, {"oid": "61a5e32865fcbbaafa0bc0a09cb4218132cfd4a9", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-1987 immutable TaskanaEngineConfiguration"}, {"oid": "20d389a7d524c156b063dfc91589bb22bebea0d7", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-1992 remove unnecessary ParentExceptions"}, {"oid": "f9e6b268177eee452e04ef708d50a33be18305e7", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-1993 InvalidArgumentException extends TaskanaRuntimeException"}, {"oid": "4a42a35a212f6bd25839432f48ec813c106874fc", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-1972: calculates working time in any resolution"}, {"oid": "d21eb47ffea4c2c9fff8f1d3435b77b805d03508", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-2012: renamed Mismatched_Exceptions to NotAuthorizedExceptions"}, {"oid": "37280cc73b83e2d39ab4afddd40256719d64c50c", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-2013 selectAndClaim TasK return Optional and does not throw Exception if Task is notFound"}, {"oid": "55d939ca7b7720ab12f488ed8fc2a631ecc6f05c", "committedDate": "2023-03-13 19:02:53 +0100", "message": "format entire codebase with new google-java-format version"}, {"oid": "d96b1c392a0f9ecfe72e7d0bc0aadac17620133c", "committedDate": "2023-03-15 01:00:50 +0100", "message": "TSK-1991: rework of property names"}]}, {"oid": "62d58b32c908be3bf05b5068497e4be5a20002e6", "url": "https://github.com/Taskana/taskana/commit/62d58b32c908be3bf05b5068497e4be5a20002e6", "message": "TSK-1160 - terminate/cancel task more comments from Holger", "committedDate": "2020-03-27T14:36:46Z", "type": "commit"}]}