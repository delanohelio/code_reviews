{"pr_number": 988, "pr_title": "Tsk 1160", "pr_author": "BerndBreier", "pr_createdAt": "2020-03-24T14:33:10Z", "pr_url": "https://github.com/Taskana/taskana/pull/988", "timeline": [{"oid": "6cefb1a7f9612688d2315571fc14b9af5245c751", "url": "https://github.com/Taskana/taskana/commit/6cefb1a7f9612688d2315571fc14b9af5245c751", "message": "TSK-1143C mismatch between forward and backward calculation between planned and due", "committedDate": "2020-03-26T10:10:36Z", "type": "commit"}, {"oid": "47c87cd6ba012fca2c3651e69420d2498aefa88f", "url": "https://github.com/Taskana/taskana/commit/47c87cd6ba012fca2c3651e69420d2498aefa88f", "message": "TSK-1143 UpdateTask with Planned sometimes fails", "committedDate": "2020-03-26T10:10:37Z", "type": "commit"}, {"oid": "9b9335f41566846d89ba5723b8f6735e2a8db341", "url": "https://github.com/Taskana/taskana/commit/9b9335f41566846d89ba5723b8f6735e2a8db341", "message": "TSK-442 improve task refresh on classification update", "committedDate": "2020-03-26T10:10:37Z", "type": "commit"}, {"oid": "900aa2c5821f1a153acbf6b7d7565660a1e34623", "url": "https://github.com/Taskana/taskana/commit/900aa2c5821f1a153acbf6b7d7565660a1e34623", "message": "TSK-1143b - fix error in testcase UpdateObjectsUseUtcTimeStampsAccTest.", "committedDate": "2020-03-26T10:10:37Z", "type": "commit"}, {"oid": "7bfa207d0836a1bb71ba650ae969af708d3853f7", "url": "https://github.com/Taskana/taskana/commit/7bfa207d0836a1bb71ba650ae969af708d3853f7", "message": "TSK-442 improve task refresh on classification update", "committedDate": "2020-03-26T10:10:37Z", "type": "commit"}, {"oid": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "url": "https://github.com/Taskana/taskana/commit/bd4c775504f5e3a173976af21226bad2b2f0e02e", "message": "TSK-1160 TaskStates CANCELLED and TERMINATED", "committedDate": "2020-03-26T10:10:38Z", "type": "commit"}, {"oid": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "url": "https://github.com/Taskana/taskana/commit/bd4c775504f5e3a173976af21226bad2b2f0e02e", "message": "TSK-1160 TaskStates CANCELLED and TERMINATED", "committedDate": "2020-03-26T10:10:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1MDc3Nw==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398650777", "body": "Cancels a task.\r\nCancellation means a task is obsolete from a business perspective an does not need to be completed anymore.", "bodyText": "Cancels a task.\nCancellation means a task is obsolete from a business perspective an does not need to be completed anymore.", "bodyHTML": "<p dir=\"auto\">Cancels a task.<br>\nCancellation means a task is obsolete from a business perspective an does not need to be completed anymore.</p>", "author": "holgerhagen", "createdAt": "2020-03-26T15:12:02Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java", "diffHunk": "@@ -490,4 +490,28 @@ TaskComment getTaskComment(String taskCommentId)\n    */\n   BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n       Instant planned, List<String> taskIds);\n+\n+  /**\n+   * Cancels a task.", "originalCommit": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODcxNTk1Mw==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398715953", "bodyText": "I added the description", "author": "BerndBreier", "createdAt": "2020-03-26T16:33:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1MDc3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "3b13b9a95e4d7d1cf172f22fa0f2679ff1c5f79b", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 15b67f6fe..7d96879c1 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -468,50 +369,4 @@ public interface TaskService {\n    */\n   BulkOperationResults<String, TaskanaException> setCallbackStateForTasks(\n       List<String> externalIds, CallbackState state);\n-\n-  /**\n-   * Sets the owner on a list of tasks. The owner will only be set on tasks that are in state READY.\n-   *\n-   * @param owner the new owner of the tasks\n-   * @param taskIds the IDs of the tasks on which the owner is to be set.\n-   * @return the result of the operations with Id and Exception for each failed task update.\n-   */\n-  BulkOperationResults<String, TaskanaException> setOwnerOfTasks(\n-      String owner, List<String> taskIds);\n-\n-  /**\n-   * Sets the planned property on a list of tasks. Only tasks in state READY and CLAIMED will be\n-   * affected by this method. On each task, the corresponding due date is set according to the\n-   * shortest service level in the classifications of the task and the task's attachments.\n-   *\n-   * @param planned the new 'PLANNED\" property of the tasks\n-   * @param taskIds the IDs of the tasks on which the new planned property is to be set.\n-   * @return the result of the operations with Id and Exception for each failed task update.\n-   */\n-  BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n-      Instant planned, List<String> taskIds);\n-\n-  /**\n-   * Cancels a task.\n-   *\n-   * @param taskId the id of the task to cancel.\n-   * @return the updated task.\n-   * @throws TaskNotFoundException if the Task with Id TaskId is not found\n-   * @throws InvalidStateException if the task is not in state READY or CLAIMED\n-   * @throws NotAuthorizedException if the current user is not authorized to see the task\n-   */\n-  Task cancelTask(String taskId)\n-      throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n-\n-  /**\n-   * Terminates a task.\n-   *\n-   * @param taskId the id of the task to cancel.\n-   * @return the updated task.\n-   * @throws TaskNotFoundException if the Task with Id TaskId is not found\n-   * @throws InvalidStateException if the task is not in state READY or CLAIMED\n-   * @throws NotAuthorizedException if the current user is not authorized to see the task\n-   */\n-  Task terminateTask(String taskId)\n-      throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n }\n", "next_change": {"commit": "20bd0922dbc332efcf4e94a0d487b077c95c5a85", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 7d96879c1..ae908e0c9 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -369,4 +375,14 @@ public interface TaskService {\n    */\n   BulkOperationResults<String, TaskanaException> setCallbackStateForTasks(\n       List<String> externalIds, CallbackState state);\n+\n+  /**\n+   * Sets the owner on a list of tasks. The owner will only be set on tasks that are in state READY.\n+   *\n+   * @param owner the new owner of the tasks\n+   * @param taskIds the IDs of the tasks on which the owner is to be set.\n+   * @return the result of the operations with Id and Exception for each failed task deletion.\n+   */\n+  BulkOperationResults<String, TaskanaException> setOwnerOfTasks(\n+      String owner, List<String> taskIds);\n }\n", "next_change": {"commit": "02a6df6f73622e86684c6c30d8f320c84078b237", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex ae908e0c9..8640a8b26 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -381,8 +382,20 @@ public interface TaskService {\n    *\n    * @param owner the new owner of the tasks\n    * @param taskIds the IDs of the tasks on which the owner is to be set.\n-   * @return the result of the operations with Id and Exception for each failed task deletion.\n+   * @return the result of the operations with Id and Exception for each failed task update.\n    */\n   BulkOperationResults<String, TaskanaException> setOwnerOfTasks(\n       String owner, List<String> taskIds);\n+\n+  /**\n+   * Sets the planned property on a list of tasks. Only tasks in state READY and CLAIMED will be\n+   * affected by this method. On each task, the corresponding due date is set according to the due\n+   * dates in the classification() of the task and the task's attachments.\n+   *\n+   * @param planned   the new 'PLANNED\" property of the tasks\n+   * @param taskIds the IDs of the tasks on which the new planned property is to be set.\n+   * @return the result of the operations with Id and Exception for each failed task update.\n+   */\n+  BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n+      Instant planned, List<String> taskIds);\n }\n", "next_change": {"commit": "3b7da72d24beb1e0f6d528f575b1ae7029f10e7f", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 8640a8b26..7951634cb 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -392,7 +467,7 @@ public interface TaskService {\n    * affected by this method. On each task, the corresponding due date is set according to the due\n    * dates in the classification() of the task and the task's attachments.\n    *\n-   * @param planned   the new 'PLANNED\" property of the tasks\n+   * @param planned the new 'PLANNED\" property of the tasks\n    * @param taskIds the IDs of the tasks on which the new planned property is to be set.\n    * @return the result of the operations with Id and Exception for each failed task update.\n    */\n", "next_change": {"commit": "7deb9254113278ccf5872283c2abd202c3cf7af0", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 7951634cb..73e0e0ce4 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -464,8 +479,8 @@ public interface TaskService {\n \n   /**\n    * Sets the planned property on a list of tasks. Only tasks in state READY and CLAIMED will be\n-   * affected by this method. On each task, the corresponding due date is set according to the due\n-   * dates in the classification() of the task and the task's attachments.\n+   * affected by this method. On each task, the corresponding due date is set according to the\n+   * shortest service level in the classifications of the task and the task's attachments.\n    *\n    * @param planned the new 'PLANNED\" property of the tasks\n    * @param taskIds the IDs of the tasks on which the new planned property is to be set.\n", "next_change": {"commit": "2ce7f86456f99d522e001080e9504ae4cd6a80f4", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 73e0e0ce4..15b67f6fe 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -488,4 +490,28 @@ public interface TaskService {\n    */\n   BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n       Instant planned, List<String> taskIds);\n+\n+  /**\n+   * Cancels a task.\n+   *\n+   * @param taskId the id of the task to cancel.\n+   * @return the updated task.\n+   * @throws TaskNotFoundException if the Task with Id TaskId is not found\n+   * @throws InvalidStateException if the task is not in state READY or CLAIMED\n+   * @throws NotAuthorizedException if the current user is not authorized to see the task\n+   */\n+  Task cancelTask(String taskId)\n+      throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n+\n+  /**\n+   * Terminates a task.\n+   *\n+   * @param taskId the id of the task to cancel.\n+   * @return the updated task.\n+   * @throws TaskNotFoundException if the Task with Id TaskId is not found\n+   * @throws InvalidStateException if the task is not in state READY or CLAIMED\n+   * @throws NotAuthorizedException if the current user is not authorized to see the task\n+   */\n+  Task terminateTask(String taskId)\n+      throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n }\n", "next_change": {"commit": "b4e1f9bc315eb701d0dec0e34c38651672239566", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 15b67f6fe..48bac1ed4 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -21,496 +24,695 @@ import pro.taskana.task.api.models.Attachment;\n import pro.taskana.task.api.models.ObjectReference;\n import pro.taskana.task.api.models.Task;\n import pro.taskana.task.api.models.TaskComment;\n+import pro.taskana.workbasket.api.WorkbasketPermission;\n import pro.taskana.workbasket.api.exceptions.WorkbasketNotFoundException;\n+import pro.taskana.workbasket.api.models.Workbasket;\n \n /** The Task Service manages all operations on tasks. */\n public interface TaskService {\n \n   /**\n-   * Claim an existing task for the current user.\n+   * Claim an existing {@linkplain Task} for the current user.\n    *\n-   * @param taskId the id of the task to be claimed\n-   * @return claimed Task\n-   * @throws TaskNotFoundException if the task with taskId was not found\n-   * @throws InvalidStateException if the state of the task with taskId is not READY\n-   * @throws InvalidOwnerException if the task with taskId is claimed by some else\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to be claimed\n+   * @return claimed {@linkplain Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} with taskId was not found\n+   * @throws InvalidStateException if the {@linkplain Task#getState() state} of the {@linkplain\n+   *     Task} with taskId is not {@linkplain TaskState#READY READY}\n+   * @throws InvalidOwnerException if the {@linkplain Task} with taskId is claimed by some else\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task claim(String taskId)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException;\n \n   /**\n-   * Claim an existing task for the current user even if it is already claimed by someone else.\n+   * Claim an existing {@linkplain Task} for the current user even if it is already claimed by\n+   * someone else.\n    *\n-   * @param taskId the id of the task to be claimed\n-   * @return claimed Task\n-   * @throws TaskNotFoundException if the task with taskId was not found\n-   * @throws InvalidStateException if the state of the task with taskId is not READY\n-   * @throws InvalidOwnerException if the task with taskId is claimed by someone else\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to be claimed\n+   * @return claimed {@linkplain Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} with taskId was not found\n+   * @throws InvalidStateException if the {@linkplain Task#getState() state} of the {@linkplain\n+   *     Task} with taskId is not READY\n+   * @throws InvalidOwnerException if the {@linkplain Task} with taskId is claimed by someone else\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task forceClaim(String taskId)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException;\n \n   /**\n-   * Cancel the claim of an existing task if it was claimed by the current user before.\n+   * Cancel the claim of an existing {@linkplain Task} if it was claimed by the current user before.\n    *\n-   * @param taskId id of the task which should be unclaimed.\n+   * @param taskId {@linkplain Task#getId() id} of the task which should be unclaimed.\n    * @return updated unclaimed task\n-   * @throws TaskNotFoundException if the task can\u00b4t be found or does not exist\n-   * @throws InvalidStateException when the task is already completed.\n-   * @throws InvalidOwnerException when the task is claimed by another user.\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @throws TaskNotFoundException if the {@linkplain Task} can't be found or does not exist\n+   * @throws InvalidStateException if the {@linkplain Task} is already in an end {@linkplain\n+   *     Task#getState() state}.\n+   * @throws InvalidOwnerException if the {@linkplain Task} is claimed by another user.\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the task is in\n    */\n   Task cancelClaim(String taskId)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException;\n \n   /**\n-   * Cancel the claim of an existing task even if it was claimed by another user.\n+   * Cancel the claim of an existing {@linkplain Task} even if it was claimed by another user.\n    *\n-   * @param taskId id of the task which should be unclaimed.\n-   * @return updated unclaimed task\n-   * @throws TaskNotFoundException if the task can\u00b4t be found or does not exist\n-   * @throws InvalidStateException when the task is already completed.\n-   * @throws InvalidOwnerException when forceCancel is false and the task is claimed by another\n-   *     user.\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @param taskId id of the {@linkplain Task} which should be unclaimed.\n+   * @return updated unclaimed {@linkplain Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} can't be found or does not exist\n+   * @throws InvalidStateException if the {@linkplain Task} is already in an end {@linkplain\n+   *     Task#getState() state}\n+   * @throws InvalidOwnerException if forceCancel is false and the {@linkplain Task} is claimed by\n+   *     another user.\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task forceCancelClaim(String taskId)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException;\n \n   /**\n-   * Complete a claimed Task as owner/admin and update State and Timestamps. If task is already\n-   * completed, the task is returned as itself.\n+   * Complete a claimed {@linkplain Task} as owner/admin and update {@linkplain Task#getState()\n+   * state} and Timestamps. If {@linkplain Task} is already completed, the {@linkplain Task} is\n+   * returned as itself.\n    *\n-   * @param taskId - Id of the Task which should be completed.\n-   * @return Task - updated task after completion.\n-   * @throws InvalidStateException when Task wasn\u00b4t claimed before.\n-   * @throws TaskNotFoundException if the given Task can\u00b4t be found in DB.\n+   * @param taskId - {@linkplain Task#getId() id} of the {@linkplain Task} which should be\n+   *     completed.\n+   * @return Task - updated {@linkplain Task} after completion.\n+   * @throws InvalidStateException if {@linkplain Task} wasn't claimed before.\n+   * @throws TaskNotFoundException if the given {@linkplain Task} can't be found in DB.\n    * @throws InvalidOwnerException if current user is not the task-owner or administrator.\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task completeTask(String taskId)\n       throws TaskNotFoundException, InvalidOwnerException, InvalidStateException,\n           NotAuthorizedException;\n \n   /**\n-   * Complete a Task and update State and Timestamps in every case if the Task exists. If task is\n-   * already completed, the task is returned as itself.\n+   * Completes a {@linkplain Task} and updates {@linkplain Task#getState() state} and Timestamps in\n+   * every case if the {@linkplain Task} exists. If {@linkplain Task} is already completed, the\n+   * {@linkplain Task} is returned as itself.\n    *\n-   * @param taskId - Id of the Task which should be completed.\n-   * @return Task - updated task after completion.\n-   * @throws InvalidStateException when Task wasn\u00b4t claimed before.\n-   * @throws TaskNotFoundException if the given Task can\u00b4t be found in DB.\n+   * @param taskId - {@linkplain Task#getId() id} of the {@linkplain Task} which should be\n+   *     completed.\n+   * @return Task - updated {@linkplain Task} after completion.\n+   * @throws InvalidStateException if {@linkplain Task} wasn't claimed before.\n+   * @throws TaskNotFoundException if the given {@linkplain Task} can't be found in DB.\n    * @throws InvalidOwnerException if current user is not the task-owner or administrator.\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task forceCompleteTask(String taskId)\n       throws TaskNotFoundException, InvalidOwnerException, InvalidStateException,\n           NotAuthorizedException;\n \n   /**\n-   * Persists a not persisted Task which does not exist already.\n-   *\n-   * @param taskToCreate the transient task object to be persisted\n-   * @return the created and persisted task\n-   * @throws TaskAlreadyExistException when the Task does already exist.\n-   * @throws NotAuthorizedException thrown if the current user is not authorized to create that task\n-   * @throws WorkbasketNotFoundException thrown if the work basket referenced by the task is not\n-   *     found\n-   * @throws ClassificationNotFoundException thrown if the {@link Classification} referenced by the\n-   *     task is not found\n+   * Inserts a not existing {@linkplain Task}. <br>\n+   * The default values of the created {@linkplain Task} are:\n+   *\n+   * <ul>\n+   *   <li><b>{@linkplain Task#getId() id}</b> - generated by {@linkplain IdGenerator}\n+   *   <li><b>{@linkplain Task#getExternalId() externalId}</b> - generated by IdGenerator\n+   *   <li><b>{@linkplain Task#getBusinessProcessId() businessProcessId}</b> - generated by\n+   *       IdGenerator\n+   *   <li><b>{@linkplain Task#getName() name}</b> - name of its Classification\n+   *   <li><b>{@linkplain Task#getDescription() description}</b> - description of its Classification\n+   *   <li><b>{@linkplain Task#getCreator() creator}</b> - id of current user\n+   *   <li><b>{@linkplain Task#getState() state}</b> - 'READY'\n+   *   <li><b>{@linkplain Task#isRead() isRead}</b> - {@code false}\n+   *   <li><b>{@linkplain Task#isTransferred() isTransferred}</b> - {@code false}\n+   * </ul>\n+   *\n+   * @param taskToCreate the transient {@linkplain Task} object to be inserted\n+   * @return the created and inserted {@linkplain Task}\n+   * @throws TaskAlreadyExistException if the {@linkplain Task} does already exist.\n+   * @throws NotAuthorizedException thrown if the current user is not authorized to create that\n+   *     {@linkplain Task}\n+   * @throws WorkbasketNotFoundException thrown if the workbasket referenced by the {@linkplain\n+   *     Task} is not found\n+   * @throws ClassificationNotFoundException thrown if the Classification referenced by the\n+   *     {@linkplain Task} is not found\n    * @throws InvalidArgumentException thrown if the primary ObjectReference is invalid\n+   * @throws AttachmentPersistenceException if an Attachment with ID will be added multiple times\n+   *     without using the task-methods\n+   * @throws ObjectReferencePersistenceException if an ObjectReference with ID will be added\n+   *     multiple times without using the task-methods\n    */\n   Task createTask(Task taskToCreate)\n       throws NotAuthorizedException, WorkbasketNotFoundException, ClassificationNotFoundException,\n-          TaskAlreadyExistException, InvalidArgumentException;\n+          TaskAlreadyExistException, InvalidArgumentException, AttachmentPersistenceException,\n+          ObjectReferencePersistenceException;\n \n   /**\n-   * Get the details of a task by Id without checking permissions.\n+   * Gets the details of a {@linkplain Task} by {@linkplain Task#getId() id} without checking\n+   * permissions.\n    *\n-   * @param taskId the id of the task\n-   * @return the Task\n-   * @throws TaskNotFoundException thrown of the {@link Task} with taskId is not found\n-   * @throws NotAuthorizedException if the current user has no READ permission for the workbasket\n-   *     the task is in.\n+   * @param taskId the {@linkplain Task#getId()} of the {@linkplain Task}\n+   * @return the {@linkplain Task}\n+   * @throws TaskNotFoundException thrown of the {@linkplain Task} with taskId is not found\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in.\n    */\n   Task getTask(String taskId) throws TaskNotFoundException, NotAuthorizedException;\n \n   /**\n-   * Transfer a task to another work basket. The transfer sets the transferred flag and resets the\n-   * read flag.\n+   * Transfers a {@linkplain Task} to another {@linkplain Workbasket} while always setting the\n+   * {@linkplain Task#isTransferred transfer} flag.\n    *\n-   * @param taskId The id of the {@link Task} to be transferred\n-   * @param destinationWorkbasketId The Id of the target work basket\n-   * @return the transferred task\n-   * @throws TaskNotFoundException Thrown if the {@link Task} with taskId was not found.\n-   * @throws WorkbasketNotFoundException Thrown if the target work basket was not found.\n+   * @see #transfer(String, String, boolean)\n+   */\n+  @SuppressWarnings(\"checkstyle:JavadocMethod\")\n+  default Task transfer(String taskId, String destinationWorkbasketId)\n+      throws TaskNotFoundException, WorkbasketNotFoundException, NotAuthorizedException,\n+          InvalidStateException {\n+    return transfer(taskId, destinationWorkbasketId, true);\n+  }\n+\n+  /**\n+   * Transfers a {@linkplain Task} to another {@linkplain Workbasket}.\n+   *\n+   * <p>The transfer resets the {@linkplain Task#isRead() read} flag and sets the {@linkplain\n+   * Task#isTransferred() transfer} flag if {@code setTransferFlag} is {@code true}.\n+   *\n+   * @param taskId the {@linkplain Task#getId()} of the {@linkplain Task} which should be\n+   *     transferred\n+   * @param destinationWorkbasketId the {@linkplain Workbasket#getId() id} of the target {@linkplain\n+   *     Workbasket}\n+   * @param setTransferFlag the control about whether to set the {@linkplain Task#isTransferred()}\n+   *     flag or not\n+   * @return the transferred {@linkplain Task}\n+   * @throws TaskNotFoundException Thrown if the {@linkplain Task} with taskId was not found.\n+   * @throws WorkbasketNotFoundException Thrown if the target {@linkplain Workbasket} was not found.\n    * @throws NotAuthorizedException Thrown if the current user is not authorized to transfer this\n-   *     {@link Task} to the target work basket\n-   * @throws InvalidStateException Thrown if the task is in a state which does not allow\n-   *     transferring\n+   *     {@linkplain Task} to the target {@linkplain Workbasket}\n+   * @throws InvalidStateException Thrown if the {@linkplain Task} is in a {@linkplain\n+   *     Task#getState() state} which does not allow transferring\n    */\n-  Task transfer(String taskId, String destinationWorkbasketId)\n+  Task transfer(String taskId, String destinationWorkbasketId, boolean setTransferFlag)\n       throws TaskNotFoundException, WorkbasketNotFoundException, NotAuthorizedException,\n           InvalidStateException;\n \n   /**\n-   * Transfer a task to another work basket. The transfer sets the transferred flag and resets the\n-   * read flag.\n+   * Transfers a {@linkplain Task} to another {@linkplain Workbasket} while always setting the\n+   * {@linkplain Task#isTransferred transfer} flag.\n+   *\n+   * @see #transfer(String, String, String, boolean)\n+   */\n+  @SuppressWarnings(\"checkstyle:JavadocMethod\")\n+  default Task transfer(String taskId, String workbasketKey, String domain)\n+      throws TaskNotFoundException, WorkbasketNotFoundException, NotAuthorizedException,\n+          InvalidStateException {\n+    return transfer(taskId, workbasketKey, domain, true);\n+  }\n+\n+  /**\n+   * Transfers a {@linkplain Task} to another {@linkplain Workbasket}.\n    *\n-   * @param taskId The id of the {@link Task} to be transferred\n-   * @param workbasketKey The key of the target work basket\n-   * @param domain The domain of the target work basket\n-   * @return the transferred task\n-   * @throws TaskNotFoundException Thrown if the {@link Task} with taskId was not found.\n-   * @throws WorkbasketNotFoundException Thrown if the target work basket was not found.\n+   * <p>The transfer resets the {@linkplain Task#isRead() read} flag and sets the transfer flag if\n+   * {@code setTransferFlag} is {@code true}.\n+   *\n+   * @param taskId the id of the {@linkplain Task} which should be transferred\n+   * @param workbasketKey the key of the target {@linkplain Workbasket}\n+   * @param domain the domain of the target {@linkplain Workbasket}\n+   * @param setTransferFlag the control about whether to set the {@linkplain Task#isTransferred()}\n+   *     flag or not\n+   * @return the transferred {@linkplain Task}\n+   * @throws TaskNotFoundException Thrown if the {@linkplain Task} with taskId was not found.\n+   * @throws WorkbasketNotFoundException Thrown if the target {@linkplain Workbasket} was not found.\n    * @throws NotAuthorizedException Thrown if the current user is not authorized to transfer this\n-   *     {@link Task} to the target work basket\n-   * @throws InvalidStateException Thrown if the task is in a state which does not allow\n-   *     transferring\n+   *     {@linkplain Task} to the target {@linkplain Workbasket}\n+   * @throws InvalidStateException Thrown if the {@linkplain Task} is in a {@linkplain\n+   *     Task#getState()} which does not allow transferring\n    */\n-  Task transfer(String taskId, String workbasketKey, String domain)\n+  Task transfer(String taskId, String workbasketKey, String domain, boolean setTransferFlag)\n       throws TaskNotFoundException, WorkbasketNotFoundException, NotAuthorizedException,\n           InvalidStateException;\n \n   /**\n-   * Marks a task as read.\n+   * Marks a {@linkplain Task} as read.\n    *\n-   * @param taskId the id of the task to be updated\n-   * @param isRead the new status of the read flag.\n-   * @return the updated Task\n-   * @throws TaskNotFoundException Thrown if the {@link Task} with taskId was not found\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to be updated\n+   * @param isRead the new status of the {@linkplain Task#isRead() read} flag\n+   * @return the updated {@linkplain Task}\n+   * @throws TaskNotFoundException Thrown if the {@linkplain Task} with taskId was not found\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task setTaskRead(String taskId, boolean isRead)\n       throws TaskNotFoundException, NotAuthorizedException;\n \n   /**\n-   * This method provides a query builder for quering the database.\n+   * Provides a query builder for querying the database.\n    *\n-   * @return a {@link TaskQuery}\n+   * @return a {@linkplain TaskQuery}\n    */\n   TaskQuery createTaskQuery();\n \n   /**\n-   * Returns a not persisted instance of {@link Task}. The returned task has no workbasket Id set.\n-   * When createTask() is invoked for this task, TaskService will call the TaskRouting SPI to\n-   * determine a workbasket for the task. If the TaskRouting API is not active, e.g. because no\n-   * TaskRouter is registered, or the TaskRouter(s) don't find a workbasket, the task will not be\n-   * persisted.\n+   * This method provides a query builder for querying the database.\n+   *\n+   * @return a {@linkplain TaskCommentQuery}\n+   */\n+  TaskCommentQuery createTaskCommentQuery();\n+\n+  /**\n+   * Returns a not inserted instance of {@linkplain Task}. The returned {@linkplain Task} has no\n+   * {@linkplain Task#getWorkbasketSummary() w} set. When createTask() is invoked for this task,\n+   * TaskService will call the TaskRouting SPI to determine a workbasket for the task. If the\n+   * TaskRouting API is not active, e.g. because no TaskRouter is registered, or the TaskRouter(s)\n+   * don't find a workbasket, the task will not be inserted.\n    *\n    * @return an empty new Task\n    */\n   Task newTask();\n \n   /**\n-   * Returns a not persisted instance of {@link Task}.\n+   * Returns a not inserted instance of {@linkplain Task}.\n    *\n-   * @param workbasketId the id of the workbasket to which the task belongs\n-   * @return an empty new Task\n+   * @param workbasketId the {@linkplain Workbasket#getId() id} of the {@linkplain Workbasket} to\n+   *     which the task belongs\n+   * @return an empty new {@linkplain Task}\n    */\n   Task newTask(String workbasketId);\n \n   /**\n-   * Returns a not persisted instance of {@link Task}.\n+   * Returns a not inserted instance of {@linkplain Task}.\n    *\n-   * @param workbasketKey the key of the workbasket to which the task belongs\n-   * @param domain the domain of the workbasket to which the task belongs\n-   * @return an empty new Task\n+   * @param workbasketKey the {@linkplain Workbasket#getKey() key} of the {@linkplain Workbasket} to\n+   *     which the {@linkplain Task} belongs\n+   * @param domain the {@linkplain Workbasket#getDomain() domain} of the {@linkplain Workbasket} to\n+   *     which the {@linkplain Task} belongs\n+   * @return an empty new {@linkplain Task}\n    */\n   Task newTask(String workbasketKey, String domain);\n \n   /**\n-   * Returns a not persisted instance of {@link TaskComment}.\n+   * Returns a not inserted instance of {@linkplain TaskComment}.\n    *\n-   * @param taskId The id of the task to which the task comment belongs\n-   * @return an empty new TaskComment\n+   * @param taskId The {@linkplain Task#getId() id} of the {@linkplain Task} to which the task\n+   *     comment belongs\n+   * @return an empty new {@linkplain TaskComment}\n    */\n   TaskComment newTaskComment(String taskId);\n \n   /**\n-   * Returns a not persisted instance of {@link Attachment}.\n+   * Returns a not inserted instance of {@linkplain Attachment}.\n    *\n-   * @return an empty new Attachment\n+   * @return an empty new {@linkplain Attachment}\n    */\n   Attachment newAttachment();\n \n   /**\n-   * Update a task.\n+   * Returns a not inserted instance of {@linkplain ObjectReference}.\n    *\n-   * @param task the task to be updated in the database\n-   * @return the updated task\n-   * @throws InvalidArgumentException if the task to be updated contains invalid properties like\n-   *     e.g. invalid object references\n-   * @throws TaskNotFoundException if the id of the task is not found in the database\n-   * @throws ConcurrencyException if the task has already been updated by another user\n-   * @throws ClassificationNotFoundException if the updated task refers to a classification that\n-   *     cannot be found\n-   * @throws NotAuthorizedException if the current user is not authorized to update the task\n-   * @throws AttachmentPersistenceException if an Attachment with ID will be added multiple times\n-   *     without using the task-methods\n-   * @throws InvalidStateException if an attempt is made to change the owner of the task and the\n-   *     task is not in state READY .\n+   * @return an empty new {@linkplain ObjectReference}\n+   */\n+  ObjectReference newObjectReference();\n+\n+  ObjectReference newObjectReference(\n+      String company, String system, String systemInstance, String type, String value);\n+\n+  /**\n+   * Update a {@linkplain Task}.\n+   *\n+   * @param task the {@linkplain Task} to be updated in the database\n+   * @return the updated {@linkplain Task}\n+   * @throws InvalidArgumentException if the {@linkplain Task} to be updated contains invalid\n+   *     properties like e.g. invalid {@linkplain ObjectReference}s\n+   * @throws TaskNotFoundException if the id of the {@linkplain Task} is not found in the database\n+   * @throws ConcurrencyException if the {@linkplain Task} has been updated by another user in the\n+   *     meantime; that's the case if the given modified timestamp differs from the one in the\n+   *     database\n+   * @throws ClassificationNotFoundException if the updated {@linkplain Task} refers to a {@link\n+   *     Classification} that cannot be found\n+   * @throws NotAuthorizedException if the current user is not authorized to update the {@linkplain\n+   *     Task}\n+   * @throws AttachmentPersistenceException if an {@linkplain Attachment} with ID will be added\n+   *     multiple times without using the Task-methods\n+   * @throws ObjectReferencePersistenceException if an {@linkplain ObjectReference} with ID will be\n+   *     added multiple times without using the Task-methods\n+   * @throws InvalidStateException if an attempt is made to change the owner of the {@linkplain\n+   *     Task} that state isn't READY.\n    */\n   Task updateTask(Task task)\n       throws InvalidArgumentException, TaskNotFoundException, ConcurrencyException,\n           ClassificationNotFoundException, NotAuthorizedException, AttachmentPersistenceException,\n-          InvalidStateException;\n+          ObjectReferencePersistenceException, InvalidStateException;\n \n   /**\n-   * Transfers a list of tasks to an other workbasket. Exceptions will be thrown if the caller got\n-   * no permissions on the target or it doesn\u00b4t exist. Other Exceptions will be stored and returned\n-   * in the end.\n+   * Transfers a list of {@linkplain Task Tasks} to another {@linkplain Workbasket} while always\n+   * setting the {@linkplain Task#isTransferred transfer} flag.\n    *\n-   * @param destinationWorkbasketId target workbasket id\n-   * @param taskIds source task which will be moved\n-   * @return Bulkresult with ID and Error in it for failed transactions.\n-   * @throws NotAuthorizedException if the caller hasn\u00b4t permissions on tarket WB.\n-   * @throws InvalidArgumentException if the method paramesters are EMPTY or NULL.\n-   * @throws WorkbasketNotFoundException if the target WB can\u00b4t be found.\n+   * @see #transferTasks(String, List, boolean)\n    */\n-  BulkOperationResults<String, TaskanaException> transferTasks(\n+  @SuppressWarnings(\"checkstyle:JavadocMethod\")\n+  default BulkOperationResults<String, TaskanaException> transferTasks(\n       String destinationWorkbasketId, List<String> taskIds)\n+      throws NotAuthorizedException, InvalidArgumentException, WorkbasketNotFoundException {\n+    return transferTasks(destinationWorkbasketId, taskIds, true);\n+  }\n+\n+  /**\n+   * Transfers a list of {@linkplain Task Tasks} to another {@linkplain Workbasket}.\n+   *\n+   * <p>The transfer resets the {@linkplain Task#isRead() read flag} and sets the {@linkplain\n+   * Task#isTransferred() transfer flag} if {@code setTransferFlag} is {@code true}. Exceptions will\n+   * be thrown if the caller got no {@linkplain WorkbasketPermission} on the target or if the target\n+   * {@linkplain Workbasket} does not exist. Other Exceptions will be stored and returned in the\n+   * end.\n+   *\n+   * @param destinationWorkbasketId {@linkplain Workbasket#getId() id} of the target {@linkplain\n+   *     Workbasket}\n+   * @param taskIds list of source {@linkplain Task Tasks} which will be moved\n+   * @param setTransferFlag the control about whether to set the {@linkplain Task#isTransferred()}\n+   *     flag or not\n+   * @return Bulkresult with {@linkplain Task#getId() ids} and Error in it for failed transactions\n+   * @throws NotAuthorizedException if the caller has no permissions on target {@linkplain\n+   *     Workbasket}\n+   * @throws InvalidArgumentException if the method parameters are EMPTY or NULL\n+   * @throws WorkbasketNotFoundException if the target {@linkplain Workbasket} can not be found\n+   */\n+  BulkOperationResults<String, TaskanaException> transferTasks(\n+      String destinationWorkbasketId, List<String> taskIds, boolean setTransferFlag)\n       throws NotAuthorizedException, InvalidArgumentException, WorkbasketNotFoundException;\n \n   /**\n-   * Transfers a list of tasks to an other workbasket. Exceptions will be thrown if the caller got\n-   * no permissions on the target or it doesn\u00b4t exist. Other Exceptions will be stored and returned\n+   * Transfers a list of {@linkplain Task Tasks} to another {@linkplain Workbasket} while always\n+   * setting the {@linkplain Task#isTransferred} flag.\n+   *\n+   * @see #transferTasks(String, String, List, boolean)\n+   */\n+  @SuppressWarnings(\"checkstyle:JavadocMethod\")\n+  default BulkOperationResults<String, TaskanaException> transferTasks(\n+      String destinationWorkbasketKey, String destinationWorkbasketDomain, List<String> taskIds)\n+      throws NotAuthorizedException, InvalidArgumentException, WorkbasketNotFoundException {\n+    return transferTasks(destinationWorkbasketKey, destinationWorkbasketDomain, taskIds, true);\n+  }\n+\n+  /**\n+   * Transfers a list of {@linkplain Task Tasks} to another {@linkplain Workbasket}.\n+   *\n+   * <p>The transfer resets the {@linkplain Task#isRead() read flag} and sets the {@linkplain\n+   * Task#isTransferred() transfer flag} if {@code setTransferFlag} is {@code true}. Exceptions will\n+   * be thrown if the caller got no {@linkplain WorkbasketPermission Permission} on the target\n+   * {@linkplain Workbasket} or if it does not exist. Other Exceptions will be stored and returned\n    * in the end.\n    *\n-   * @param destinationWorkbasketKey target workbasket key\n-   * @param destinationWorkbasketDomain target workbasket domain\n-   * @param taskIds source task which will be moved\n-   * @return Bulkresult with ID and Error in it for failed transactions.\n-   * @throws NotAuthorizedException if the caller hasn\u00b4t permissions on tarket WB.\n-   * @throws InvalidArgumentException if the method paramesters are EMPTY or NULL.\n-   * @throws WorkbasketNotFoundException if the target WB can\u00b4t be found.\n+   * @param destinationWorkbasketKey target {@linkplain Workbasket#getKey()} Workbasket}\n+   * @param destinationWorkbasketDomain target {@linkplain Workbasket#getDomain() domain}\n+   * @param taskIds List of source {@linkplain Task Tasks} which will be moved\n+   * @param setTransferFlag the control about whether to set the {@linkplain Task#isTransferred()}\n+   *     flag or not\n+   * @return BulkResult with {@linkplain Task#getId() id} and Error in it for failed transactions.\n+   * @throws NotAuthorizedException if the caller has no {@linkplain WorkbasketPermission} on target\n+   *     {@linkplain Workbasket}.\n+   * @throws InvalidArgumentException if the method parameters are EMPTY or NULL.\n+   * @throws WorkbasketNotFoundException if the target {@linkplain Workbasket} can not be found.\n    */\n   BulkOperationResults<String, TaskanaException> transferTasks(\n-      String destinationWorkbasketKey, String destinationWorkbasketDomain, List<String> taskIds)\n+      String destinationWorkbasketKey,\n+      String destinationWorkbasketDomain,\n+      List<String> taskIds,\n+      boolean setTransferFlag)\n       throws NotAuthorizedException, InvalidArgumentException, WorkbasketNotFoundException;\n \n   /**\n-   * Deletes the task with the given Id.\n+   * Deletes the {@linkplain Task} with the given {@linkplain Task#getId() id}.\n    *\n-   * @param taskId The Id of the task to delete.\n-   * @throws TaskNotFoundException If the given Id does not refer to an existing task.\n-   * @throws InvalidStateException If the state of the referenced task is not Completed.\n-   * @throws NotAuthorizedException if the current user is not member of role ADMIN\n+   * @param taskId The {@linkplain Task#getId() id} of the {@linkplain Task} to delete.\n+   * @throws TaskNotFoundException If the given {@linkplain Task#getId() id} does not refer to an\n+   *     existing {@linkplain Task}.\n+   * @throws InvalidStateException If the {@linkplain Task#getState() state} of the referenced\n+   *     {@linkplain Task} is not an end state.\n+   * @throws NotAuthorizedException if the current user is not member of role {@linkplain\n+   *     TaskanaRole#ADMIN}\n    */\n   void deleteTask(String taskId)\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n \n   /**\n-   * Deletes the task with the given Id even if it is not completed.\n+   * Deletes the {@linkplain Task} with the given {@linkplain Task#getId() id} even if it is not\n+   * completed.\n    *\n-   * @param taskId The Id of the task to delete.\n-   * @throws TaskNotFoundException If the given Id does not refer to an existing task.\n-   * @throws InvalidStateException If the state of the referenced task is not Completed and\n-   *     forceDelet is false.\n-   * @throws NotAuthorizedException if the current user is not member of role ADMIN\n+   * @param taskId The {@linkplain Task#getId() id} of the {@linkplain Task} to delete.\n+   * @throws TaskNotFoundException If the given {@linkplain Task#getId() id} does not refer to an\n+   *     existing {@linkplain Task}.\n+   * @throws InvalidStateException If the state of the referenced {@linkplain Task} is not an end\n+   *     state and forceDelete is false.\n+   * @throws NotAuthorizedException if the current user is not member of role {@linkplain\n+   *     TaskanaRole#ADMIN}\n    */\n   void forceDeleteTask(String taskId)\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n \n   /**\n-   * Deletes a list of tasks.\n+   * Selects and claims the first {@linkplain Task} which is returned by the {@linkplain TaskQuery}.\n    *\n-   * @param tasks the ids of the tasks to delete.\n-   * @return the result of the operations with Id and Exception for each failed task deletion.\n+   * @param taskQuery the {@linkplain TaskQuery}.\n+   * @return the {@linkplain Task} that got selected and claimed\n+   * @throws InvalidOwnerException if the {@linkplain Task} is claimed by someone else\n+   * @throws NotAuthorizedException if the current user has no read permission for the Workbasket\n+   *     the {@linkplain Task} is in\n+   */\n+  Task selectAndClaim(TaskQuery taskQuery) throws NotAuthorizedException, InvalidOwnerException;\n+\n+  /**\n+   * Deletes a list of {@linkplain Task Tasks}.\n+   *\n+   * @param tasks the {@linkplain Task#getId() ids} of the tasks to delete.\n+   * @return the result of the operations with each {@linkplain Task#getId() id} and Exception for\n+   *     each failed task deletion.\n    * @throws InvalidArgumentException if the TaskIds parameter is NULL\n+   * @throws NotAuthorizedException if the current user is not member of role ADMIN\n    */\n   BulkOperationResults<String, TaskanaException> deleteTasks(List<String> tasks)\n-      throws InvalidArgumentException;\n+      throws InvalidArgumentException, NotAuthorizedException;\n \n   /**\n-   * Completes a list of tasks.\n+   * Completes a list of {@linkplain Task Tasks}.\n    *\n-   * @param taskIds of the tasks which should be completed.\n-   * @return the result of the operations with Id and Exception for each failed task completion.\n-   * @throws InvalidArgumentException If the taskId parameter is NULL.\n+   * @param taskIds {@linkplain Task#getId() ids} of the {@linkplain Task Tasks} which should be\n+   *     completed\n+   * @return the result of the operations with each {@linkplain Task#getId() id} and Exception for\n+   *     each failed completion\n+   * @throws InvalidArgumentException If the taskIds parameter is NULL\n    */\n   BulkOperationResults<String, TaskanaException> completeTasks(List<String> taskIds)\n       throws InvalidArgumentException;\n \n   /**\n-   * Updates tasks with a matching {@link ObjectReference}.\n+   * Completes each existing {@linkplain Task} in the given List in every case, independent of the\n+   * {@linkplain Task#getOwner() owner} or {@linkplain Task#getState() state} of the {@linkplain\n+   * Task}. If the {@linkplain Task} is already {@linkplain TaskState#COMPLETED completed}, the\n+   * {@linkplain Task} stays unchanged.\n+   *\n+   * @see TaskService#forceCompleteTask\n+   * @param taskIds {@linkplain Task#getId() id} of the {@linkplain Task Tasks} which should be\n+   *     completed\n+   * @return the result of the operations with {@linkplain Task#getId() id} and Exception for each\n+   *     failed completion\n+   * @throws InvalidArgumentException If the taskIds parameter is NULL\n+   */\n+  BulkOperationResults<String, TaskanaException> forceCompleteTasks(List<String> taskIds)\n+      throws InvalidArgumentException;\n+\n+  /**\n+   * Updates specified {@linkplain TaskCustomField TaskCustomFields} of {@linkplain Task Tasks}\n+   * associated with the given {@linkplain ObjectReference}.\n    *\n-   * @param selectionCriteria the {@link ObjectReference} that is used to select the tasks.\n-   * @param customFieldsToUpdate a {@link Map} that contains as key the identification of the custom\n-   *     field and as value the corresponding new value of that custom field. The key for\n-   *     identification of the custom field must be a String with value \"1\", \"2\" ... \"16\" as in the\n-   *     setCustomAttribute or getCustomAttribute method of {@link Task}\n-   * @return a list of the Ids of all modified tasks\n-   * @throws InvalidArgumentException If the customFieldsToUpdate map contains an invalid key or if\n-   *     the selectionCriteria is invalid\n+   * @param selectionCriteria the {@linkplain ObjectReference} that is used to select the tasks\n+   * @param customFieldsToUpdate a Map that contains as key the identification of the {@linkplain\n+   *     TaskCustomField} and as value the corresponding new value of that field\n+   * @return a list of the {@linkplain Task#getId() ids} of all modified {@linkplain Task Tasks}\n+   * @throws InvalidArgumentException if the given selectionCriteria is invalid or the given\n+   *     customFieldsToUpdate are NULL or empty\n    */\n   List<String> updateTasks(\n-      ObjectReference selectionCriteria, Map<String, String> customFieldsToUpdate)\n+      ObjectReference selectionCriteria, Map<TaskCustomField, String> customFieldsToUpdate)\n       throws InvalidArgumentException;\n \n   /**\n-   * Updates tasks with matching taskIds.\n+   * Updates specified {@linkplain TaskCustomField TaskCustomFields} for all given {@linkplain Task\n+   * Tasks}.\n    *\n-   * @param taskIds the taskIds that are used to select the tasks.\n-   * @param customFieldsToUpdate a {@link Map} that contains as key the identification of the custom\n-   *     field and as value the corresponding new value of that custom field. The key for\n-   *     identification of the custom field must be a String with value \"1\", \"2\" ... \"16\" as in the\n-   *     setCustomAttribute or getCustomAttribute method of {@link Task}\n-   * @return a list of the Ids of all modified tasks\n-   * @throws InvalidArgumentException If the customFieldsToUpdate map contains an invalid key or if\n-   *     the selectionCriteria is invalid\n+   * @param taskIds the {@linkplain Task#getId() taskIds} that are used to select the {@linkplain\n+   *     Task Tasks}.\n+   * @param customFieldsToUpdate a Map that contains as key the identification of the {@linkplain\n+   *     TaskCustomField} and as value the corresponding new value of that {@linkplain\n+   *     TaskCustomField}.\n+   * @return a list of the {@linkplain Task#getId() ids} of all modified {@linkplain Task Tasks}\n+   * @throws InvalidArgumentException if the given customFieldsToUpdate are NULL or empty.\n    */\n-  List<String> updateTasks(List<String> taskIds, Map<String, String> customFieldsToUpdate)\n+  List<String> updateTasks(List<String> taskIds, Map<TaskCustomField, String> customFieldsToUpdate)\n       throws InvalidArgumentException;\n \n   /**\n-   * Create a task comment.\n+   * Inserts the specified {@linkplain TaskComment} into the database.\n    *\n-   * @param taskComment the task comment to be created.\n-   * @return the created task comment.\n-   * @throws NotAuthorizedException If the current user has no authorization to create a task\n-   *     comment for the given taskId in the TaskComment or is not authorized to access the task.\n-   * @throws TaskNotFoundException If the given taskId in the TaskComment does not refer to an\n-   *     existing task.\n-   * @throws InvalidArgumentException If the given taskCommentId from the provided task comment is\n-   *     not null or empty\n+   * @param taskComment the {@linkplain TaskComment} to be created\n+   * @return the created {@linkplain TaskComment}\n+   * @throws NotAuthorizedException if the current user has no authorization to create a {@link\n+   *     TaskComment} for the given taskId or is not authorized to access the {@linkplain Task}\n+   * @throws TaskNotFoundException if the given {@linkplain TaskComment#getTaskId() taskId} does not\n+   *     refer to an existing {@linkplain Task}\n+   * @throws InvalidArgumentException if the {@linkplain TaskComment#getId() id} of the provided\n+   *     {@link TaskComment} is not NULL or empty\n    */\n   TaskComment createTaskComment(TaskComment taskComment)\n       throws NotAuthorizedException, TaskNotFoundException, InvalidArgumentException;\n \n   /**\n-   * Update a task comment.\n+   * Updates the specified {@linkplain TaskComment}.\n    *\n-   * @param taskComment the task comment to be updated in the database.\n-   * @return the updated task comment.\n-   * @throws NotAuthorizedException If the current user has no authorization to update a task\n-   *     comment or is not authorized to access the task.\n-   * @throws ConcurrencyException if an attempt is made to update the task comment and another user.\n-   *     updated it already.\n-   * @throws TaskCommentNotFoundException If the given taskCommentId in the TaskComment does not\n-   *     refer to an existing taskComment.\n-   * @throws TaskNotFoundException If the given taskId in the TaskComment does not refer to an\n-   *     existing task.\n-   * @throws InvalidArgumentException If the given taskCommentId from the provided task comment is\n-   *     null or empty\n+   * @param taskComment the {@linkplain TaskComment} to be updated in the database\n+   * @return the updated {@linkplain TaskComment}\n+   * @throws NotAuthorizedException if the current user has no authorization to update the\n+   *     {@linkplain TaskComment} or is not authorized to access the {@linkplain Task}\n+   * @throws ConcurrencyException if an attempt is made to update the {@linkplain TaskComment} and\n+   *     another user updated it already; that's the case if the given {} timestamp differs from the\n+   *     one in the database\n+   * @throws TaskCommentNotFoundException if the {@linkplain TaskComment#getId() is} of the\n+   *     specified {@linkplain TaskComment}does not refer to an existing {@linkplain TaskComment}\n+   * @throws TaskNotFoundException if the {@linkplain TaskComment#getTaskId() taskId} does not refer\n+   *     to an existing {@linkplain Task}\n+   * @throws InvalidArgumentException if the given {@linkplain TaskComment#getId() id} is NULL or\n+   *     empty\n    */\n   TaskComment updateTaskComment(TaskComment taskComment)\n       throws NotAuthorizedException, ConcurrencyException, TaskCommentNotFoundException,\n           TaskNotFoundException, InvalidArgumentException;\n \n   /**\n-   * Deletes the task comment with the given Id.\n+   * Deletes the {@linkplain TaskComment} with the given {@linkplain TaskComment#getId() id}.\n    *\n-   * @param taskCommentId The id of the task comment to delete.\n-   * @throws NotAuthorizedException If the current user has no authorization to delete a task\n+   * @param taskCommentId the {@linkplain TaskComment#getId() id} of the {@linkplain TaskComment} to\n+   *     delete\n+   * @throws NotAuthorizedException if the current user has no authorization to delete a task\n    *     comment or is not authorized to access the task.\n-   * @throws InvalidArgumentException If the taskCommentId is null/empty\n-   * @throws TaskCommentNotFoundException If the given taskCommentId in the TaskComment does not\n+   * @throws InvalidArgumentException if the taskCommentId is NULL or empty\n+   * @throws TaskCommentNotFoundException if the given taskCommentId in the TaskComment does not\n    *     refer to an existing taskComment.\n-   * @throws TaskNotFoundException If the given taskId in the TaskComment does not refer to an\n-   *     existing task.\n-   * @throws InvalidArgumentException If the given taskCommentId is null or empty\n+   * @throws TaskNotFoundException if the {@linkplain TaskComment#getTaskId() taskId} of the\n+   *     TaskComment does not refer to an existing {@linkplain Task}.\n+   * @throws InvalidArgumentException if the given taskCommentId is NULL or empty\n    */\n   void deleteTaskComment(String taskCommentId)\n       throws NotAuthorizedException, TaskCommentNotFoundException, TaskNotFoundException,\n           InvalidArgumentException;\n \n   /**\n-   * Retrieves a task comment for a given taskCommentId.\n+   * Retrieves the {@linkplain TaskComment} with the given {@linkplain TaskComment#getId() id}.\n    *\n-   * @param taskCommentId The id of the task comment which should be retrieved\n-   * @return the task comment identified by taskCommentId\n-   * @throws TaskCommentNotFoundException If the given taskCommentId in the TaskComment does not\n-   *     refer to an existing taskComment.\n-   * @throws NotAuthorizedException If the current user has no authorization to retrieve a\n-   *     taskComment from a certain task or is not authorized to access the task.\n-   * @throws TaskNotFoundException If the given taskId in the TaskComment does not refer to an\n-   *     existing task.\n-   * @throws InvalidArgumentException If the given taskCommentId is null or empty\n+   * @param taskCommentId the {@linkplain TaskComment#getId() id} of the {@linkplain TaskComment}\n+   *     which should be retrieved\n+   * @return the {@linkplain TaskComment} identified by taskCommentId\n+   * @throws TaskCommentNotFoundException if the given taskCommentId does not refer to an existing\n+   *     {@linkplain TaskComment}\n+   * @throws NotAuthorizedException if the current user has no authorization to retrieve a\n+   *     {@linkplain TaskComment} from a certain {@linkplain Task} or is not authorized to access\n+   *     the {@linkplain Task}\n+   * @throws TaskNotFoundException if the {@linkplain TaskComment#getTaskId() taskId} of the\n+   *     TaskComment does not refer to an existing {@linkplain Task}\n+   * @throws InvalidArgumentException if the given taskCommentId is NULL or empty\n    */\n   TaskComment getTaskComment(String taskCommentId)\n       throws TaskCommentNotFoundException, NotAuthorizedException, TaskNotFoundException,\n           InvalidArgumentException;\n \n   /**\n-   * Retrieves a list of task comments for a given taskId.\n+   * Retrieves the List of {@linkplain TaskComment TaskComments} for the Task with given {@linkplain\n+   * Task#getId() id}.\n    *\n-   * @param taskId The id of the task for which all task comments should be retrieved\n-   * @return the list of task comments attached to task with id taskId\n-   * @throws NotAuthorizedException If the current user has no authorization to retrieve a\n-   *     taskComment from a certain task or is not authorized to access the task.\n-   * @throws TaskNotFoundException If the given taskId in the TaskComment does not refer to an\n-   *     existing task.\n+   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} for which all task\n+   *     comments should be retrieved\n+   * @return the List of task comments attached to the specified {@linkplain Task}\n+   * @throws NotAuthorizedException if the current user has no authorization to retrieve a\n+   *     taskComment from the {@linkplain Task} or is not authorized to access the {@linkplain Task}\n+   * @throws TaskNotFoundException if the given taskId does not refer to an existing {@linkplain\n+   *     Task}\n    */\n   List<TaskComment> getTaskComments(String taskId)\n       throws NotAuthorizedException, TaskNotFoundException;\n \n   /**\n-   * Sets the callback state on a list of tasks. Note: this method is primarily intended to be used\n-   * by the TaskanaAdapter\n+   * Sets the specified {@linkplain CallbackState} on a list of {@linkplain Task Tasks}. Note: this\n+   * method is primarily intended to be used by the TaskanaAdapter\n    *\n-   * @param externalIds the EXTERNAL_IDs of the tasks on which the callback state is set.\n-   * @param state the callback state that is to be set on the tasks\n-   * @return the result of the operations with Id and Exception for each failed task deletion.\n+   * @param externalIds the {@linkplain Task#getExternalId() externalIds} of the {@linkplain Task\n+   *     Tasks} on which the {@linkplain CallbackState} is set\n+   * @param state the {@linkplain CallbackState} that is to be set on the {@linkplain Task Tasks}\n+   * @return the result of the operations with {@linkplain Task#getId() id} and Exception for each\n+   *     failed operation\n    */\n   BulkOperationResults<String, TaskanaException> setCallbackStateForTasks(\n       List<String> externalIds, CallbackState state);\n \n   /**\n-   * Sets the owner on a list of tasks. The owner will only be set on tasks that are in state READY.\n+   * Sets the {@linkplain Task#getOwner() owner} on a List of {@linkplain Task Tasks}. The\n+   * {@linkplain Task#getOwner() owner} will only be set on {@linkplain Task Tasks} that are in\n+   * state {@linkplain TaskState#READY}.\n    *\n-   * @param owner the new owner of the tasks\n-   * @param taskIds the IDs of the tasks on which the owner is to be set.\n-   * @return the result of the operations with Id and Exception for each failed task update.\n+   * @param owner the new {@linkplain Task#getOwner() owner} of the {@linkplain Task Tasks}\n+   * @param taskIds the {@linkplain Task#getId() ids} of the {@linkplain Task Tasks} on which the\n+   *     {@linkplain Task#getOwner() owner} is to be set\n+   * @return the result of the operations with {@linkplain Task#getId() id} and Exception for each\n+   *     failed {@linkplain Task}-update\n    */\n   BulkOperationResults<String, TaskanaException> setOwnerOfTasks(\n       String owner, List<String> taskIds);\n \n   /**\n-   * Sets the planned property on a list of tasks. Only tasks in state READY and CLAIMED will be\n-   * affected by this method. On each task, the corresponding due date is set according to the\n-   * shortest service level in the classifications of the task and the task's attachments.\n+   * Sets the {@linkplain Task#getPlanned() planned} Instant on a List of {@linkplain Task Tasks}.\n+   * Only {@linkplain Task Tasks} in state {@linkplain TaskState#READY} and {@linkplain\n+   * TaskState#CLAIMED} will be affected by this method. On each {@linkplain Task}, the\n+   * corresponding {@linkplain Task#getDue() due date} is set according to the shortest serviceLevel\n+   * in the {@linkplain Task#getClassificationSummary() Classification} of the {@linkplain Task} and\n+   * its {@linkplain Task#getAttachments() Attachments}.\n    *\n-   * @param planned the new 'PLANNED\" property of the tasks\n-   * @param taskIds the IDs of the tasks on which the new planned property is to be set.\n-   * @return the result of the operations with Id and Exception for each failed task update.\n+   * @param planned the new {@linkplain Task#getPlanned() planned} Instant of the {@linkplain Task\n+   *     Tasks}\n+   * @param taskIds the {@linkplain Task#getId() ids} of the {@linkplain Task Tasks} on which the\n+   *     new {@linkplain Task#getPlanned() planned} Instant is to be set\n+   * @return the result of the operations with {@linkplain Task#getId() id} and Exception for each\n+   *     failed {@linkplain Task Task} update.\n    */\n   BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n       Instant planned, List<String> taskIds);\n \n   /**\n-   * Cancels a task.\n+   * Cancels the {@linkplain Task} with the given {@linkplain Task#getId() id}. Cancellation means a\n+   * {@linkplain Task} is obsolete from a business perspective and does not need to be completed\n+   * anymore.\n    *\n-   * @param taskId the id of the task to cancel.\n-   * @return the updated task.\n-   * @throws TaskNotFoundException if the Task with Id TaskId is not found\n-   * @throws InvalidStateException if the task is not in state READY or CLAIMED\n-   * @throws NotAuthorizedException if the current user is not authorized to see the task\n+   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to cancel\n+   * @return the updated {@linkplain Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} with taskId is not found\n+   * @throws InvalidStateException if the {@linkplain Task} is not in state {@linkplain\n+   *     TaskState#READY} or {@linkplain TaskState#CLAIMED}\n+   * @throws NotAuthorizedException if the current user is not authorized to see the {@linkplain\n+   *     Task}\n    */\n   Task cancelTask(String taskId)\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n \n   /**\n-   * Terminates a task.\n+   * Terminates a {@linkplain Task}. Termination is an administrative action to complete a\n+   * {@linkplain Task}. This is typically done by administration to correct any technical issue.\n    *\n-   * @param taskId the id of the task to cancel.\n-   * @return the updated task.\n-   * @throws TaskNotFoundException if the Task with Id TaskId is not found\n-   * @throws InvalidStateException if the task is not in state READY or CLAIMED\n-   * @throws NotAuthorizedException if the current user is not authorized to see the task\n+   * @param taskId the id of the {@linkplain Task} to cancel\n+   * @return the updated {@linkplain Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} with taskId is not found\n+   * @throws InvalidStateException if the {@linkplain Task} is not in state {@linkplain\n+   *     TaskState#READY} or {@linkplain TaskState#CLAIMED}\n+   * @throws NotAuthorizedException if the current user is not authorized to see the {@linkplain\n+   *     Task}\n    */\n   Task terminateTask(String taskId)\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n", "next_change": {"commit": "a2e068119042fd305c3f494e43cd41fec80f1a30", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 48bac1ed4..a58ce2866 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -670,49 +744,53 @@ public interface TaskService {\n \n   /**\n    * Sets the {@linkplain Task#getPlanned() planned} Instant on a List of {@linkplain Task Tasks}.\n-   * Only {@linkplain Task Tasks} in state {@linkplain TaskState#READY} and {@linkplain\n+   *\n+   * <p>Only {@linkplain Task Tasks} in state {@linkplain TaskState#READY} and {@linkplain\n    * TaskState#CLAIMED} will be affected by this method. On each {@linkplain Task}, the\n-   * corresponding {@linkplain Task#getDue() due date} is set according to the shortest serviceLevel\n-   * in the {@linkplain Task#getClassificationSummary() Classification} of the {@linkplain Task} and\n-   * its {@linkplain Task#getAttachments() Attachments}.\n+   * corresponding {@linkplain Task#getDue() due} Instant is set according to the shortest\n+   * serviceLevel in the {@linkplain Task#getClassificationSummary() Classification} of the\n+   * {@linkplain Task} and its {@linkplain Task#getAttachments() Attachments}.\n    *\n    * @param planned the new {@linkplain Task#getPlanned() planned} Instant of the {@linkplain Task\n    *     Tasks}\n    * @param taskIds the {@linkplain Task#getId() ids} of the {@linkplain Task Tasks} on which the\n    *     new {@linkplain Task#getPlanned() planned} Instant is to be set\n-   * @return the result of the operations with {@linkplain Task#getId() id} and Exception for each\n-   *     failed {@linkplain Task Task} update.\n+   * @return the result of the operations with {@linkplain Task#getId() ids} and Exception for each\n+   *     failed {@linkplain Task} update\n    */\n   BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n       Instant planned, List<String> taskIds);\n \n   /**\n-   * Cancels the {@linkplain Task} with the given {@linkplain Task#getId() id}. Cancellation means a\n-   * {@linkplain Task} is obsolete from a business perspective and does not need to be completed\n-   * anymore.\n+   * Cancels the {@linkplain Task} with the given {@linkplain Task#getId() id}.\n+   *\n+   * <p>Cancellation means a {@linkplain Task} is obsolete from a business perspective and doesn't\n+   * need to be completed anymore.\n    *\n    * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to cancel\n    * @return the updated {@linkplain Task}\n-   * @throws TaskNotFoundException if the {@linkplain Task} with taskId is not found\n-   * @throws InvalidStateException if the {@linkplain Task} is not in state {@linkplain\n-   *     TaskState#READY} or {@linkplain TaskState#CLAIMED}\n-   * @throws NotAuthorizedException if the current user is not authorized to see the {@linkplain\n-   *     Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} with taskId wasn't found\n+   * @throws InvalidStateException if the {@linkplain Task} isn't in {@linkplain TaskState#READY} or\n+   *     {@linkplain TaskState#CLAIMED}\n+   * @throws NotAuthorizedException if the current user has no {@linkplain\n+   *     WorkbasketPermission#READ} for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task cancelTask(String taskId)\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n \n   /**\n    * Terminates a {@linkplain Task}. Termination is an administrative action to complete a\n-   * {@linkplain Task}. This is typically done by administration to correct any technical issue.\n+   * {@linkplain Task}.\n+   *\n+   * <p>This is typically done by administration to correct any technical issue.\n    *\n-   * @param taskId the id of the {@linkplain Task} to cancel\n+   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to cancel\n    * @return the updated {@linkplain Task}\n-   * @throws TaskNotFoundException if the {@linkplain Task} with taskId is not found\n-   * @throws InvalidStateException if the {@linkplain Task} is not in state {@linkplain\n-   *     TaskState#READY} or {@linkplain TaskState#CLAIMED}\n-   * @throws NotAuthorizedException if the current user is not authorized to see the {@linkplain\n-   *     Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} with taskId wasn't found\n+   * @throws InvalidStateException if the {@linkplain Task} isn't in {@linkplain TaskState#READY} or\n+   *     {@linkplain TaskState#CLAIMED}\n+   * @throws NotAuthorizedException if the current user isn't member of {@linkplain\n+   *     TaskanaRole#ADMIN} or {@linkplain TaskanaRole#BUSINESS_ADMIN}\n    */\n   Task terminateTask(String taskId)\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n", "next_change": {"commit": "33a88529954a490d2a042a34319cbf394ee15e9d", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex a58ce2866..6e357fdf2 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -677,121 +853,55 @@ public interface TaskService {\n       throws NotAuthorizedException, TaskCommentNotFoundException, TaskNotFoundException,\n           InvalidArgumentException;\n \n-  /**\n-   * Retrieves the {@linkplain TaskComment} with the given {@linkplain TaskComment#getId() id}.\n-   *\n-   * @param taskCommentId the {@linkplain TaskComment#getId() id} of the {@linkplain TaskComment}\n-   *     which should be retrieved\n-   * @return the {@linkplain TaskComment} identified by taskCommentId\n-   * @throws TaskCommentNotFoundException if the given taskCommentId doesn't refer to an existing\n-   *     {@linkplain TaskComment}\n-   * @throws NotAuthorizedException if the current user has no {@linkplain\n-   *     WorkbasketPermission#READ} for the {@linkplain Workbasket} of the commented {@linkplain\n-   *     Task}\n-   * @throws TaskNotFoundException if the {@linkplain TaskComment#getTaskId() taskId} of the\n-   *     TaskComment doesn't refer to an existing {@linkplain Task}\n-   * @throws InvalidArgumentException if the given taskCommentId is NULL or empty\n-   */\n-  TaskComment getTaskComment(String taskCommentId)\n-      throws TaskCommentNotFoundException, NotAuthorizedException, TaskNotFoundException,\n-          InvalidArgumentException;\n+  // endregion\n \n-  /**\n-   * Retrieves the List of {@linkplain TaskComment TaskComments} for the {@linkplain Task} with\n-   * given {@linkplain Task#getId() id}.\n-   *\n-   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} for which all\n-   *     {@linkplain TaskComment TaskComments} should be retrieved\n-   * @return the List of {@linkplain TaskComment TaskComments} attached to the specified {@linkplain\n-   *     Task}\n-   * @throws NotAuthorizedException if the current user has no {@linkplain\n-   *     WorkbasketPermission#READ} for the {@linkplain Workbasket} of the commented {@linkplain\n-   *     Task}\n-   * @throws TaskNotFoundException if the given taskId doesn't refer to an existing {@linkplain\n-   *     Task}\n-   */\n-  List<TaskComment> getTaskComments(String taskId)\n-      throws NotAuthorizedException, TaskNotFoundException;\n+  // endregion\n \n   /**\n-   * Sets the specified {@linkplain CallbackState} on a List of {@linkplain Task Tasks}.\n-   *\n-   * <p>Note: this method is primarily intended to be used by the TaskanaAdapter\n+   * Instantiates a non-persistent/non-inserted {@linkplain Attachment}.\n    *\n-   * @param externalIds the {@linkplain Task#getExternalId() externalIds} of the {@linkplain Task\n-   *     Tasks} on which the {@linkplain CallbackState} is set\n-   * @param state the {@linkplain CallbackState} that is to be set on the {@linkplain Task Tasks}\n-   * @return the result of the operations with {@linkplain Task#getId() ids} and Exception for each\n-   *     failed operation\n+   * @return the instantiated {@linkplain Attachment}\n    */\n-  BulkOperationResults<String, TaskanaException> setCallbackStateForTasks(\n-      List<String> externalIds, CallbackState state);\n+  Attachment newAttachment();\n \n   /**\n-   * Sets the {@linkplain Task#getOwner() owner} on a List of {@linkplain Task Tasks}.\n-   *\n-   * <p>The {@linkplain Task#getOwner() owner} will only be set on {@linkplain Task Tasks} that are\n-   * in {@linkplain TaskState#READY}.\n+   * Instantiates a non-persistent/non-inserted {@linkplain ObjectReference}.\n    *\n-   * @param owner the new {@linkplain Task#getOwner() owner} of the {@linkplain Task Tasks}\n-   * @param taskIds the {@linkplain Task#getId() ids} of the {@linkplain Task Tasks} on which the\n-   *     {@linkplain Task#getOwner() owner} is to be set\n-   * @return the result of the operations with {@linkplain Task#getId() ids} and Exception for each\n-   *     failed {@linkplain Task}-update\n+   * @return the instantiated {@linkplain ObjectReference}\n+   * @see #newObjectReference(String, String, String, String, String)\n    */\n-  BulkOperationResults<String, TaskanaException> setOwnerOfTasks(\n-      String owner, List<String> taskIds);\n+  ObjectReference newObjectReference();\n \n   /**\n-   * Sets the {@linkplain Task#getPlanned() planned} Instant on a List of {@linkplain Task Tasks}.\n-   *\n-   * <p>Only {@linkplain Task Tasks} in state {@linkplain TaskState#READY} and {@linkplain\n-   * TaskState#CLAIMED} will be affected by this method. On each {@linkplain Task}, the\n-   * corresponding {@linkplain Task#getDue() due} Instant is set according to the shortest\n-   * serviceLevel in the {@linkplain Task#getClassificationSummary() Classification} of the\n-   * {@linkplain Task} and its {@linkplain Task#getAttachments() Attachments}.\n+   * Instantiates a non-persistent/non-inserted {@linkplain ObjectReference}.\n    *\n-   * @param planned the new {@linkplain Task#getPlanned() planned} Instant of the {@linkplain Task\n-   *     Tasks}\n-   * @param taskIds the {@linkplain Task#getId() ids} of the {@linkplain Task Tasks} on which the\n-   *     new {@linkplain Task#getPlanned() planned} Instant is to be set\n-   * @return the result of the operations with {@linkplain Task#getId() ids} and Exception for each\n-   *     failed {@linkplain Task} update\n+   * @param company the {@linkplain ObjectReference#getCompany() company} of the new {@linkplain\n+   *     ObjectReference}\n+   * @param system the {@linkplain ObjectReference#getSystem() system} of the new {@linkplain\n+   *     ObjectReference}\n+   * @param systemInstance the {@linkplain ObjectReference#getSystemInstance() systemInstance} of\n+   *     the new {@linkplain ObjectReference}\n+   * @param type the {@linkplain ObjectReference#getType() type} of the new {@linkplain\n+   *     ObjectReference}\n+   * @param value the {@linkplain ObjectReference#getValue() value} of the new {@linkplain\n+   *     ObjectReference}\n+   * @return the instantiated {@linkplain ObjectReference}\n+   * @see #newObjectReference()\n    */\n-  BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n-      Instant planned, List<String> taskIds);\n+  ObjectReference newObjectReference(\n+      String company, String system, String systemInstance, String type, String value);\n \n   /**\n-   * Cancels the {@linkplain Task} with the given {@linkplain Task#getId() id}.\n-   *\n-   * <p>Cancellation means a {@linkplain Task} is obsolete from a business perspective and doesn't\n-   * need to be completed anymore.\n+   * Creates an empty {@linkplain TaskQuery}.\n    *\n-   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to cancel\n-   * @return the updated {@linkplain Task}\n-   * @throws TaskNotFoundException if the {@linkplain Task} with taskId wasn't found\n-   * @throws InvalidStateException if the {@linkplain Task} isn't in {@linkplain TaskState#READY} or\n-   *     {@linkplain TaskState#CLAIMED}\n-   * @throws NotAuthorizedException if the current user has no {@linkplain\n-   *     WorkbasketPermission#READ} for the {@linkplain Workbasket} the {@linkplain Task} is in\n+   * @return a {@linkplain TaskQuery}\n    */\n-  Task cancelTask(String taskId)\n-      throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n+  TaskQuery createTaskQuery();\n \n   /**\n-   * Terminates a {@linkplain Task}. Termination is an administrative action to complete a\n-   * {@linkplain Task}.\n-   *\n-   * <p>This is typically done by administration to correct any technical issue.\n+   * Creates an empty {@linkplain TaskCommentQuery}.\n    *\n-   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to cancel\n-   * @return the updated {@linkplain Task}\n-   * @throws TaskNotFoundException if the {@linkplain Task} with taskId wasn't found\n-   * @throws InvalidStateException if the {@linkplain Task} isn't in {@linkplain TaskState#READY} or\n-   *     {@linkplain TaskState#CLAIMED}\n-   * @throws NotAuthorizedException if the current user isn't member of {@linkplain\n-   *     TaskanaRole#ADMIN} or {@linkplain TaskanaRole#BUSINESS_ADMIN}\n+   * @return a {@linkplain TaskCommentQuery}\n    */\n-  Task terminateTask(String taskId)\n-      throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n+  TaskCommentQuery createTaskCommentQuery();\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1MjU4Ng==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398652586", "body": "Terminates a task.\r\nTermination is a administrative action to complete a task. This is typically done by an administration to correct any technical issue. ", "bodyText": "Terminates a task.\nTermination is a administrative action to complete a task. This is typically done by an administration to correct any technical issue.", "bodyHTML": "<p dir=\"auto\">Terminates a task.<br>\nTermination is a administrative action to complete a task. This is typically done by an administration to correct any technical issue.</p>", "author": "holgerhagen", "createdAt": "2020-03-26T15:14:16Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java", "diffHunk": "@@ -490,4 +490,28 @@ TaskComment getTaskComment(String taskCommentId)\n    */\n   BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n       Instant planned, List<String> taskIds);\n+\n+  /**\n+   * Cancels a task.\n+   *\n+   * @param taskId the id of the task to cancel.\n+   * @return the updated task.\n+   * @throws TaskNotFoundException if the Task with Id TaskId is not found\n+   * @throws InvalidStateException if the task is not in state READY or CLAIMED\n+   * @throws NotAuthorizedException if the current user is not authorized to see the task\n+   */\n+  Task cancelTask(String taskId)\n+      throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n+\n+  /**\n+   * Terminates a task.", "originalCommit": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODcxNjA1NA==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398716054", "bodyText": "I added the description", "author": "BerndBreier", "createdAt": "2020-03-26T16:33:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1MjU4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "3b13b9a95e4d7d1cf172f22fa0f2679ff1c5f79b", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 15b67f6fe..7d96879c1 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -468,50 +369,4 @@ public interface TaskService {\n    */\n   BulkOperationResults<String, TaskanaException> setCallbackStateForTasks(\n       List<String> externalIds, CallbackState state);\n-\n-  /**\n-   * Sets the owner on a list of tasks. The owner will only be set on tasks that are in state READY.\n-   *\n-   * @param owner the new owner of the tasks\n-   * @param taskIds the IDs of the tasks on which the owner is to be set.\n-   * @return the result of the operations with Id and Exception for each failed task update.\n-   */\n-  BulkOperationResults<String, TaskanaException> setOwnerOfTasks(\n-      String owner, List<String> taskIds);\n-\n-  /**\n-   * Sets the planned property on a list of tasks. Only tasks in state READY and CLAIMED will be\n-   * affected by this method. On each task, the corresponding due date is set according to the\n-   * shortest service level in the classifications of the task and the task's attachments.\n-   *\n-   * @param planned the new 'PLANNED\" property of the tasks\n-   * @param taskIds the IDs of the tasks on which the new planned property is to be set.\n-   * @return the result of the operations with Id and Exception for each failed task update.\n-   */\n-  BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n-      Instant planned, List<String> taskIds);\n-\n-  /**\n-   * Cancels a task.\n-   *\n-   * @param taskId the id of the task to cancel.\n-   * @return the updated task.\n-   * @throws TaskNotFoundException if the Task with Id TaskId is not found\n-   * @throws InvalidStateException if the task is not in state READY or CLAIMED\n-   * @throws NotAuthorizedException if the current user is not authorized to see the task\n-   */\n-  Task cancelTask(String taskId)\n-      throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n-\n-  /**\n-   * Terminates a task.\n-   *\n-   * @param taskId the id of the task to cancel.\n-   * @return the updated task.\n-   * @throws TaskNotFoundException if the Task with Id TaskId is not found\n-   * @throws InvalidStateException if the task is not in state READY or CLAIMED\n-   * @throws NotAuthorizedException if the current user is not authorized to see the task\n-   */\n-  Task terminateTask(String taskId)\n-      throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n }\n", "next_change": {"commit": "20bd0922dbc332efcf4e94a0d487b077c95c5a85", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 7d96879c1..ae908e0c9 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -369,4 +375,14 @@ public interface TaskService {\n    */\n   BulkOperationResults<String, TaskanaException> setCallbackStateForTasks(\n       List<String> externalIds, CallbackState state);\n+\n+  /**\n+   * Sets the owner on a list of tasks. The owner will only be set on tasks that are in state READY.\n+   *\n+   * @param owner the new owner of the tasks\n+   * @param taskIds the IDs of the tasks on which the owner is to be set.\n+   * @return the result of the operations with Id and Exception for each failed task deletion.\n+   */\n+  BulkOperationResults<String, TaskanaException> setOwnerOfTasks(\n+      String owner, List<String> taskIds);\n }\n", "next_change": {"commit": "02a6df6f73622e86684c6c30d8f320c84078b237", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex ae908e0c9..8640a8b26 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -381,8 +382,20 @@ public interface TaskService {\n    *\n    * @param owner the new owner of the tasks\n    * @param taskIds the IDs of the tasks on which the owner is to be set.\n-   * @return the result of the operations with Id and Exception for each failed task deletion.\n+   * @return the result of the operations with Id and Exception for each failed task update.\n    */\n   BulkOperationResults<String, TaskanaException> setOwnerOfTasks(\n       String owner, List<String> taskIds);\n+\n+  /**\n+   * Sets the planned property on a list of tasks. Only tasks in state READY and CLAIMED will be\n+   * affected by this method. On each task, the corresponding due date is set according to the due\n+   * dates in the classification() of the task and the task's attachments.\n+   *\n+   * @param planned   the new 'PLANNED\" property of the tasks\n+   * @param taskIds the IDs of the tasks on which the new planned property is to be set.\n+   * @return the result of the operations with Id and Exception for each failed task update.\n+   */\n+  BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n+      Instant planned, List<String> taskIds);\n }\n", "next_change": {"commit": "3b7da72d24beb1e0f6d528f575b1ae7029f10e7f", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 8640a8b26..7951634cb 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -392,7 +467,7 @@ public interface TaskService {\n    * affected by this method. On each task, the corresponding due date is set according to the due\n    * dates in the classification() of the task and the task's attachments.\n    *\n-   * @param planned   the new 'PLANNED\" property of the tasks\n+   * @param planned the new 'PLANNED\" property of the tasks\n    * @param taskIds the IDs of the tasks on which the new planned property is to be set.\n    * @return the result of the operations with Id and Exception for each failed task update.\n    */\n", "next_change": {"commit": "7deb9254113278ccf5872283c2abd202c3cf7af0", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 7951634cb..73e0e0ce4 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -464,8 +479,8 @@ public interface TaskService {\n \n   /**\n    * Sets the planned property on a list of tasks. Only tasks in state READY and CLAIMED will be\n-   * affected by this method. On each task, the corresponding due date is set according to the due\n-   * dates in the classification() of the task and the task's attachments.\n+   * affected by this method. On each task, the corresponding due date is set according to the\n+   * shortest service level in the classifications of the task and the task's attachments.\n    *\n    * @param planned the new 'PLANNED\" property of the tasks\n    * @param taskIds the IDs of the tasks on which the new planned property is to be set.\n", "next_change": {"commit": "2ce7f86456f99d522e001080e9504ae4cd6a80f4", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 73e0e0ce4..15b67f6fe 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -488,4 +490,28 @@ public interface TaskService {\n    */\n   BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n       Instant planned, List<String> taskIds);\n+\n+  /**\n+   * Cancels a task.\n+   *\n+   * @param taskId the id of the task to cancel.\n+   * @return the updated task.\n+   * @throws TaskNotFoundException if the Task with Id TaskId is not found\n+   * @throws InvalidStateException if the task is not in state READY or CLAIMED\n+   * @throws NotAuthorizedException if the current user is not authorized to see the task\n+   */\n+  Task cancelTask(String taskId)\n+      throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n+\n+  /**\n+   * Terminates a task.\n+   *\n+   * @param taskId the id of the task to cancel.\n+   * @return the updated task.\n+   * @throws TaskNotFoundException if the Task with Id TaskId is not found\n+   * @throws InvalidStateException if the task is not in state READY or CLAIMED\n+   * @throws NotAuthorizedException if the current user is not authorized to see the task\n+   */\n+  Task terminateTask(String taskId)\n+      throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n }\n", "next_change": {"commit": "b4e1f9bc315eb701d0dec0e34c38651672239566", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 15b67f6fe..48bac1ed4 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -21,496 +24,695 @@ import pro.taskana.task.api.models.Attachment;\n import pro.taskana.task.api.models.ObjectReference;\n import pro.taskana.task.api.models.Task;\n import pro.taskana.task.api.models.TaskComment;\n+import pro.taskana.workbasket.api.WorkbasketPermission;\n import pro.taskana.workbasket.api.exceptions.WorkbasketNotFoundException;\n+import pro.taskana.workbasket.api.models.Workbasket;\n \n /** The Task Service manages all operations on tasks. */\n public interface TaskService {\n \n   /**\n-   * Claim an existing task for the current user.\n+   * Claim an existing {@linkplain Task} for the current user.\n    *\n-   * @param taskId the id of the task to be claimed\n-   * @return claimed Task\n-   * @throws TaskNotFoundException if the task with taskId was not found\n-   * @throws InvalidStateException if the state of the task with taskId is not READY\n-   * @throws InvalidOwnerException if the task with taskId is claimed by some else\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to be claimed\n+   * @return claimed {@linkplain Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} with taskId was not found\n+   * @throws InvalidStateException if the {@linkplain Task#getState() state} of the {@linkplain\n+   *     Task} with taskId is not {@linkplain TaskState#READY READY}\n+   * @throws InvalidOwnerException if the {@linkplain Task} with taskId is claimed by some else\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task claim(String taskId)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException;\n \n   /**\n-   * Claim an existing task for the current user even if it is already claimed by someone else.\n+   * Claim an existing {@linkplain Task} for the current user even if it is already claimed by\n+   * someone else.\n    *\n-   * @param taskId the id of the task to be claimed\n-   * @return claimed Task\n-   * @throws TaskNotFoundException if the task with taskId was not found\n-   * @throws InvalidStateException if the state of the task with taskId is not READY\n-   * @throws InvalidOwnerException if the task with taskId is claimed by someone else\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to be claimed\n+   * @return claimed {@linkplain Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} with taskId was not found\n+   * @throws InvalidStateException if the {@linkplain Task#getState() state} of the {@linkplain\n+   *     Task} with taskId is not READY\n+   * @throws InvalidOwnerException if the {@linkplain Task} with taskId is claimed by someone else\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task forceClaim(String taskId)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException;\n \n   /**\n-   * Cancel the claim of an existing task if it was claimed by the current user before.\n+   * Cancel the claim of an existing {@linkplain Task} if it was claimed by the current user before.\n    *\n-   * @param taskId id of the task which should be unclaimed.\n+   * @param taskId {@linkplain Task#getId() id} of the task which should be unclaimed.\n    * @return updated unclaimed task\n-   * @throws TaskNotFoundException if the task can\u00b4t be found or does not exist\n-   * @throws InvalidStateException when the task is already completed.\n-   * @throws InvalidOwnerException when the task is claimed by another user.\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @throws TaskNotFoundException if the {@linkplain Task} can't be found or does not exist\n+   * @throws InvalidStateException if the {@linkplain Task} is already in an end {@linkplain\n+   *     Task#getState() state}.\n+   * @throws InvalidOwnerException if the {@linkplain Task} is claimed by another user.\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the task is in\n    */\n   Task cancelClaim(String taskId)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException;\n \n   /**\n-   * Cancel the claim of an existing task even if it was claimed by another user.\n+   * Cancel the claim of an existing {@linkplain Task} even if it was claimed by another user.\n    *\n-   * @param taskId id of the task which should be unclaimed.\n-   * @return updated unclaimed task\n-   * @throws TaskNotFoundException if the task can\u00b4t be found or does not exist\n-   * @throws InvalidStateException when the task is already completed.\n-   * @throws InvalidOwnerException when forceCancel is false and the task is claimed by another\n-   *     user.\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @param taskId id of the {@linkplain Task} which should be unclaimed.\n+   * @return updated unclaimed {@linkplain Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} can't be found or does not exist\n+   * @throws InvalidStateException if the {@linkplain Task} is already in an end {@linkplain\n+   *     Task#getState() state}\n+   * @throws InvalidOwnerException if forceCancel is false and the {@linkplain Task} is claimed by\n+   *     another user.\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task forceCancelClaim(String taskId)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException;\n \n   /**\n-   * Complete a claimed Task as owner/admin and update State and Timestamps. If task is already\n-   * completed, the task is returned as itself.\n+   * Complete a claimed {@linkplain Task} as owner/admin and update {@linkplain Task#getState()\n+   * state} and Timestamps. If {@linkplain Task} is already completed, the {@linkplain Task} is\n+   * returned as itself.\n    *\n-   * @param taskId - Id of the Task which should be completed.\n-   * @return Task - updated task after completion.\n-   * @throws InvalidStateException when Task wasn\u00b4t claimed before.\n-   * @throws TaskNotFoundException if the given Task can\u00b4t be found in DB.\n+   * @param taskId - {@linkplain Task#getId() id} of the {@linkplain Task} which should be\n+   *     completed.\n+   * @return Task - updated {@linkplain Task} after completion.\n+   * @throws InvalidStateException if {@linkplain Task} wasn't claimed before.\n+   * @throws TaskNotFoundException if the given {@linkplain Task} can't be found in DB.\n    * @throws InvalidOwnerException if current user is not the task-owner or administrator.\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task completeTask(String taskId)\n       throws TaskNotFoundException, InvalidOwnerException, InvalidStateException,\n           NotAuthorizedException;\n \n   /**\n-   * Complete a Task and update State and Timestamps in every case if the Task exists. If task is\n-   * already completed, the task is returned as itself.\n+   * Completes a {@linkplain Task} and updates {@linkplain Task#getState() state} and Timestamps in\n+   * every case if the {@linkplain Task} exists. If {@linkplain Task} is already completed, the\n+   * {@linkplain Task} is returned as itself.\n    *\n-   * @param taskId - Id of the Task which should be completed.\n-   * @return Task - updated task after completion.\n-   * @throws InvalidStateException when Task wasn\u00b4t claimed before.\n-   * @throws TaskNotFoundException if the given Task can\u00b4t be found in DB.\n+   * @param taskId - {@linkplain Task#getId() id} of the {@linkplain Task} which should be\n+   *     completed.\n+   * @return Task - updated {@linkplain Task} after completion.\n+   * @throws InvalidStateException if {@linkplain Task} wasn't claimed before.\n+   * @throws TaskNotFoundException if the given {@linkplain Task} can't be found in DB.\n    * @throws InvalidOwnerException if current user is not the task-owner or administrator.\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task forceCompleteTask(String taskId)\n       throws TaskNotFoundException, InvalidOwnerException, InvalidStateException,\n           NotAuthorizedException;\n \n   /**\n-   * Persists a not persisted Task which does not exist already.\n-   *\n-   * @param taskToCreate the transient task object to be persisted\n-   * @return the created and persisted task\n-   * @throws TaskAlreadyExistException when the Task does already exist.\n-   * @throws NotAuthorizedException thrown if the current user is not authorized to create that task\n-   * @throws WorkbasketNotFoundException thrown if the work basket referenced by the task is not\n-   *     found\n-   * @throws ClassificationNotFoundException thrown if the {@link Classification} referenced by the\n-   *     task is not found\n+   * Inserts a not existing {@linkplain Task}. <br>\n+   * The default values of the created {@linkplain Task} are:\n+   *\n+   * <ul>\n+   *   <li><b>{@linkplain Task#getId() id}</b> - generated by {@linkplain IdGenerator}\n+   *   <li><b>{@linkplain Task#getExternalId() externalId}</b> - generated by IdGenerator\n+   *   <li><b>{@linkplain Task#getBusinessProcessId() businessProcessId}</b> - generated by\n+   *       IdGenerator\n+   *   <li><b>{@linkplain Task#getName() name}</b> - name of its Classification\n+   *   <li><b>{@linkplain Task#getDescription() description}</b> - description of its Classification\n+   *   <li><b>{@linkplain Task#getCreator() creator}</b> - id of current user\n+   *   <li><b>{@linkplain Task#getState() state}</b> - 'READY'\n+   *   <li><b>{@linkplain Task#isRead() isRead}</b> - {@code false}\n+   *   <li><b>{@linkplain Task#isTransferred() isTransferred}</b> - {@code false}\n+   * </ul>\n+   *\n+   * @param taskToCreate the transient {@linkplain Task} object to be inserted\n+   * @return the created and inserted {@linkplain Task}\n+   * @throws TaskAlreadyExistException if the {@linkplain Task} does already exist.\n+   * @throws NotAuthorizedException thrown if the current user is not authorized to create that\n+   *     {@linkplain Task}\n+   * @throws WorkbasketNotFoundException thrown if the workbasket referenced by the {@linkplain\n+   *     Task} is not found\n+   * @throws ClassificationNotFoundException thrown if the Classification referenced by the\n+   *     {@linkplain Task} is not found\n    * @throws InvalidArgumentException thrown if the primary ObjectReference is invalid\n+   * @throws AttachmentPersistenceException if an Attachment with ID will be added multiple times\n+   *     without using the task-methods\n+   * @throws ObjectReferencePersistenceException if an ObjectReference with ID will be added\n+   *     multiple times without using the task-methods\n    */\n   Task createTask(Task taskToCreate)\n       throws NotAuthorizedException, WorkbasketNotFoundException, ClassificationNotFoundException,\n-          TaskAlreadyExistException, InvalidArgumentException;\n+          TaskAlreadyExistException, InvalidArgumentException, AttachmentPersistenceException,\n+          ObjectReferencePersistenceException;\n \n   /**\n-   * Get the details of a task by Id without checking permissions.\n+   * Gets the details of a {@linkplain Task} by {@linkplain Task#getId() id} without checking\n+   * permissions.\n    *\n-   * @param taskId the id of the task\n-   * @return the Task\n-   * @throws TaskNotFoundException thrown of the {@link Task} with taskId is not found\n-   * @throws NotAuthorizedException if the current user has no READ permission for the workbasket\n-   *     the task is in.\n+   * @param taskId the {@linkplain Task#getId()} of the {@linkplain Task}\n+   * @return the {@linkplain Task}\n+   * @throws TaskNotFoundException thrown of the {@linkplain Task} with taskId is not found\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in.\n    */\n   Task getTask(String taskId) throws TaskNotFoundException, NotAuthorizedException;\n \n   /**\n-   * Transfer a task to another work basket. The transfer sets the transferred flag and resets the\n-   * read flag.\n+   * Transfers a {@linkplain Task} to another {@linkplain Workbasket} while always setting the\n+   * {@linkplain Task#isTransferred transfer} flag.\n    *\n-   * @param taskId The id of the {@link Task} to be transferred\n-   * @param destinationWorkbasketId The Id of the target work basket\n-   * @return the transferred task\n-   * @throws TaskNotFoundException Thrown if the {@link Task} with taskId was not found.\n-   * @throws WorkbasketNotFoundException Thrown if the target work basket was not found.\n+   * @see #transfer(String, String, boolean)\n+   */\n+  @SuppressWarnings(\"checkstyle:JavadocMethod\")\n+  default Task transfer(String taskId, String destinationWorkbasketId)\n+      throws TaskNotFoundException, WorkbasketNotFoundException, NotAuthorizedException,\n+          InvalidStateException {\n+    return transfer(taskId, destinationWorkbasketId, true);\n+  }\n+\n+  /**\n+   * Transfers a {@linkplain Task} to another {@linkplain Workbasket}.\n+   *\n+   * <p>The transfer resets the {@linkplain Task#isRead() read} flag and sets the {@linkplain\n+   * Task#isTransferred() transfer} flag if {@code setTransferFlag} is {@code true}.\n+   *\n+   * @param taskId the {@linkplain Task#getId()} of the {@linkplain Task} which should be\n+   *     transferred\n+   * @param destinationWorkbasketId the {@linkplain Workbasket#getId() id} of the target {@linkplain\n+   *     Workbasket}\n+   * @param setTransferFlag the control about whether to set the {@linkplain Task#isTransferred()}\n+   *     flag or not\n+   * @return the transferred {@linkplain Task}\n+   * @throws TaskNotFoundException Thrown if the {@linkplain Task} with taskId was not found.\n+   * @throws WorkbasketNotFoundException Thrown if the target {@linkplain Workbasket} was not found.\n    * @throws NotAuthorizedException Thrown if the current user is not authorized to transfer this\n-   *     {@link Task} to the target work basket\n-   * @throws InvalidStateException Thrown if the task is in a state which does not allow\n-   *     transferring\n+   *     {@linkplain Task} to the target {@linkplain Workbasket}\n+   * @throws InvalidStateException Thrown if the {@linkplain Task} is in a {@linkplain\n+   *     Task#getState() state} which does not allow transferring\n    */\n-  Task transfer(String taskId, String destinationWorkbasketId)\n+  Task transfer(String taskId, String destinationWorkbasketId, boolean setTransferFlag)\n       throws TaskNotFoundException, WorkbasketNotFoundException, NotAuthorizedException,\n           InvalidStateException;\n \n   /**\n-   * Transfer a task to another work basket. The transfer sets the transferred flag and resets the\n-   * read flag.\n+   * Transfers a {@linkplain Task} to another {@linkplain Workbasket} while always setting the\n+   * {@linkplain Task#isTransferred transfer} flag.\n+   *\n+   * @see #transfer(String, String, String, boolean)\n+   */\n+  @SuppressWarnings(\"checkstyle:JavadocMethod\")\n+  default Task transfer(String taskId, String workbasketKey, String domain)\n+      throws TaskNotFoundException, WorkbasketNotFoundException, NotAuthorizedException,\n+          InvalidStateException {\n+    return transfer(taskId, workbasketKey, domain, true);\n+  }\n+\n+  /**\n+   * Transfers a {@linkplain Task} to another {@linkplain Workbasket}.\n    *\n-   * @param taskId The id of the {@link Task} to be transferred\n-   * @param workbasketKey The key of the target work basket\n-   * @param domain The domain of the target work basket\n-   * @return the transferred task\n-   * @throws TaskNotFoundException Thrown if the {@link Task} with taskId was not found.\n-   * @throws WorkbasketNotFoundException Thrown if the target work basket was not found.\n+   * <p>The transfer resets the {@linkplain Task#isRead() read} flag and sets the transfer flag if\n+   * {@code setTransferFlag} is {@code true}.\n+   *\n+   * @param taskId the id of the {@linkplain Task} which should be transferred\n+   * @param workbasketKey the key of the target {@linkplain Workbasket}\n+   * @param domain the domain of the target {@linkplain Workbasket}\n+   * @param setTransferFlag the control about whether to set the {@linkplain Task#isTransferred()}\n+   *     flag or not\n+   * @return the transferred {@linkplain Task}\n+   * @throws TaskNotFoundException Thrown if the {@linkplain Task} with taskId was not found.\n+   * @throws WorkbasketNotFoundException Thrown if the target {@linkplain Workbasket} was not found.\n    * @throws NotAuthorizedException Thrown if the current user is not authorized to transfer this\n-   *     {@link Task} to the target work basket\n-   * @throws InvalidStateException Thrown if the task is in a state which does not allow\n-   *     transferring\n+   *     {@linkplain Task} to the target {@linkplain Workbasket}\n+   * @throws InvalidStateException Thrown if the {@linkplain Task} is in a {@linkplain\n+   *     Task#getState()} which does not allow transferring\n    */\n-  Task transfer(String taskId, String workbasketKey, String domain)\n+  Task transfer(String taskId, String workbasketKey, String domain, boolean setTransferFlag)\n       throws TaskNotFoundException, WorkbasketNotFoundException, NotAuthorizedException,\n           InvalidStateException;\n \n   /**\n-   * Marks a task as read.\n+   * Marks a {@linkplain Task} as read.\n    *\n-   * @param taskId the id of the task to be updated\n-   * @param isRead the new status of the read flag.\n-   * @return the updated Task\n-   * @throws TaskNotFoundException Thrown if the {@link Task} with taskId was not found\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to be updated\n+   * @param isRead the new status of the {@linkplain Task#isRead() read} flag\n+   * @return the updated {@linkplain Task}\n+   * @throws TaskNotFoundException Thrown if the {@linkplain Task} with taskId was not found\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task setTaskRead(String taskId, boolean isRead)\n       throws TaskNotFoundException, NotAuthorizedException;\n \n   /**\n-   * This method provides a query builder for quering the database.\n+   * Provides a query builder for querying the database.\n    *\n-   * @return a {@link TaskQuery}\n+   * @return a {@linkplain TaskQuery}\n    */\n   TaskQuery createTaskQuery();\n \n   /**\n-   * Returns a not persisted instance of {@link Task}. The returned task has no workbasket Id set.\n-   * When createTask() is invoked for this task, TaskService will call the TaskRouting SPI to\n-   * determine a workbasket for the task. If the TaskRouting API is not active, e.g. because no\n-   * TaskRouter is registered, or the TaskRouter(s) don't find a workbasket, the task will not be\n-   * persisted.\n+   * This method provides a query builder for querying the database.\n+   *\n+   * @return a {@linkplain TaskCommentQuery}\n+   */\n+  TaskCommentQuery createTaskCommentQuery();\n+\n+  /**\n+   * Returns a not inserted instance of {@linkplain Task}. The returned {@linkplain Task} has no\n+   * {@linkplain Task#getWorkbasketSummary() w} set. When createTask() is invoked for this task,\n+   * TaskService will call the TaskRouting SPI to determine a workbasket for the task. If the\n+   * TaskRouting API is not active, e.g. because no TaskRouter is registered, or the TaskRouter(s)\n+   * don't find a workbasket, the task will not be inserted.\n    *\n    * @return an empty new Task\n    */\n   Task newTask();\n \n   /**\n-   * Returns a not persisted instance of {@link Task}.\n+   * Returns a not inserted instance of {@linkplain Task}.\n    *\n-   * @param workbasketId the id of the workbasket to which the task belongs\n-   * @return an empty new Task\n+   * @param workbasketId the {@linkplain Workbasket#getId() id} of the {@linkplain Workbasket} to\n+   *     which the task belongs\n+   * @return an empty new {@linkplain Task}\n    */\n   Task newTask(String workbasketId);\n \n   /**\n-   * Returns a not persisted instance of {@link Task}.\n+   * Returns a not inserted instance of {@linkplain Task}.\n    *\n-   * @param workbasketKey the key of the workbasket to which the task belongs\n-   * @param domain the domain of the workbasket to which the task belongs\n-   * @return an empty new Task\n+   * @param workbasketKey the {@linkplain Workbasket#getKey() key} of the {@linkplain Workbasket} to\n+   *     which the {@linkplain Task} belongs\n+   * @param domain the {@linkplain Workbasket#getDomain() domain} of the {@linkplain Workbasket} to\n+   *     which the {@linkplain Task} belongs\n+   * @return an empty new {@linkplain Task}\n    */\n   Task newTask(String workbasketKey, String domain);\n \n   /**\n-   * Returns a not persisted instance of {@link TaskComment}.\n+   * Returns a not inserted instance of {@linkplain TaskComment}.\n    *\n-   * @param taskId The id of the task to which the task comment belongs\n-   * @return an empty new TaskComment\n+   * @param taskId The {@linkplain Task#getId() id} of the {@linkplain Task} to which the task\n+   *     comment belongs\n+   * @return an empty new {@linkplain TaskComment}\n    */\n   TaskComment newTaskComment(String taskId);\n \n   /**\n-   * Returns a not persisted instance of {@link Attachment}.\n+   * Returns a not inserted instance of {@linkplain Attachment}.\n    *\n-   * @return an empty new Attachment\n+   * @return an empty new {@linkplain Attachment}\n    */\n   Attachment newAttachment();\n \n   /**\n-   * Update a task.\n+   * Returns a not inserted instance of {@linkplain ObjectReference}.\n    *\n-   * @param task the task to be updated in the database\n-   * @return the updated task\n-   * @throws InvalidArgumentException if the task to be updated contains invalid properties like\n-   *     e.g. invalid object references\n-   * @throws TaskNotFoundException if the id of the task is not found in the database\n-   * @throws ConcurrencyException if the task has already been updated by another user\n-   * @throws ClassificationNotFoundException if the updated task refers to a classification that\n-   *     cannot be found\n-   * @throws NotAuthorizedException if the current user is not authorized to update the task\n-   * @throws AttachmentPersistenceException if an Attachment with ID will be added multiple times\n-   *     without using the task-methods\n-   * @throws InvalidStateException if an attempt is made to change the owner of the task and the\n-   *     task is not in state READY .\n+   * @return an empty new {@linkplain ObjectReference}\n+   */\n+  ObjectReference newObjectReference();\n+\n+  ObjectReference newObjectReference(\n+      String company, String system, String systemInstance, String type, String value);\n+\n+  /**\n+   * Update a {@linkplain Task}.\n+   *\n+   * @param task the {@linkplain Task} to be updated in the database\n+   * @return the updated {@linkplain Task}\n+   * @throws InvalidArgumentException if the {@linkplain Task} to be updated contains invalid\n+   *     properties like e.g. invalid {@linkplain ObjectReference}s\n+   * @throws TaskNotFoundException if the id of the {@linkplain Task} is not found in the database\n+   * @throws ConcurrencyException if the {@linkplain Task} has been updated by another user in the\n+   *     meantime; that's the case if the given modified timestamp differs from the one in the\n+   *     database\n+   * @throws ClassificationNotFoundException if the updated {@linkplain Task} refers to a {@link\n+   *     Classification} that cannot be found\n+   * @throws NotAuthorizedException if the current user is not authorized to update the {@linkplain\n+   *     Task}\n+   * @throws AttachmentPersistenceException if an {@linkplain Attachment} with ID will be added\n+   *     multiple times without using the Task-methods\n+   * @throws ObjectReferencePersistenceException if an {@linkplain ObjectReference} with ID will be\n+   *     added multiple times without using the Task-methods\n+   * @throws InvalidStateException if an attempt is made to change the owner of the {@linkplain\n+   *     Task} that state isn't READY.\n    */\n   Task updateTask(Task task)\n       throws InvalidArgumentException, TaskNotFoundException, ConcurrencyException,\n           ClassificationNotFoundException, NotAuthorizedException, AttachmentPersistenceException,\n-          InvalidStateException;\n+          ObjectReferencePersistenceException, InvalidStateException;\n \n   /**\n-   * Transfers a list of tasks to an other workbasket. Exceptions will be thrown if the caller got\n-   * no permissions on the target or it doesn\u00b4t exist. Other Exceptions will be stored and returned\n-   * in the end.\n+   * Transfers a list of {@linkplain Task Tasks} to another {@linkplain Workbasket} while always\n+   * setting the {@linkplain Task#isTransferred transfer} flag.\n    *\n-   * @param destinationWorkbasketId target workbasket id\n-   * @param taskIds source task which will be moved\n-   * @return Bulkresult with ID and Error in it for failed transactions.\n-   * @throws NotAuthorizedException if the caller hasn\u00b4t permissions on tarket WB.\n-   * @throws InvalidArgumentException if the method paramesters are EMPTY or NULL.\n-   * @throws WorkbasketNotFoundException if the target WB can\u00b4t be found.\n+   * @see #transferTasks(String, List, boolean)\n    */\n-  BulkOperationResults<String, TaskanaException> transferTasks(\n+  @SuppressWarnings(\"checkstyle:JavadocMethod\")\n+  default BulkOperationResults<String, TaskanaException> transferTasks(\n       String destinationWorkbasketId, List<String> taskIds)\n+      throws NotAuthorizedException, InvalidArgumentException, WorkbasketNotFoundException {\n+    return transferTasks(destinationWorkbasketId, taskIds, true);\n+  }\n+\n+  /**\n+   * Transfers a list of {@linkplain Task Tasks} to another {@linkplain Workbasket}.\n+   *\n+   * <p>The transfer resets the {@linkplain Task#isRead() read flag} and sets the {@linkplain\n+   * Task#isTransferred() transfer flag} if {@code setTransferFlag} is {@code true}. Exceptions will\n+   * be thrown if the caller got no {@linkplain WorkbasketPermission} on the target or if the target\n+   * {@linkplain Workbasket} does not exist. Other Exceptions will be stored and returned in the\n+   * end.\n+   *\n+   * @param destinationWorkbasketId {@linkplain Workbasket#getId() id} of the target {@linkplain\n+   *     Workbasket}\n+   * @param taskIds list of source {@linkplain Task Tasks} which will be moved\n+   * @param setTransferFlag the control about whether to set the {@linkplain Task#isTransferred()}\n+   *     flag or not\n+   * @return Bulkresult with {@linkplain Task#getId() ids} and Error in it for failed transactions\n+   * @throws NotAuthorizedException if the caller has no permissions on target {@linkplain\n+   *     Workbasket}\n+   * @throws InvalidArgumentException if the method parameters are EMPTY or NULL\n+   * @throws WorkbasketNotFoundException if the target {@linkplain Workbasket} can not be found\n+   */\n+  BulkOperationResults<String, TaskanaException> transferTasks(\n+      String destinationWorkbasketId, List<String> taskIds, boolean setTransferFlag)\n       throws NotAuthorizedException, InvalidArgumentException, WorkbasketNotFoundException;\n \n   /**\n-   * Transfers a list of tasks to an other workbasket. Exceptions will be thrown if the caller got\n-   * no permissions on the target or it doesn\u00b4t exist. Other Exceptions will be stored and returned\n+   * Transfers a list of {@linkplain Task Tasks} to another {@linkplain Workbasket} while always\n+   * setting the {@linkplain Task#isTransferred} flag.\n+   *\n+   * @see #transferTasks(String, String, List, boolean)\n+   */\n+  @SuppressWarnings(\"checkstyle:JavadocMethod\")\n+  default BulkOperationResults<String, TaskanaException> transferTasks(\n+      String destinationWorkbasketKey, String destinationWorkbasketDomain, List<String> taskIds)\n+      throws NotAuthorizedException, InvalidArgumentException, WorkbasketNotFoundException {\n+    return transferTasks(destinationWorkbasketKey, destinationWorkbasketDomain, taskIds, true);\n+  }\n+\n+  /**\n+   * Transfers a list of {@linkplain Task Tasks} to another {@linkplain Workbasket}.\n+   *\n+   * <p>The transfer resets the {@linkplain Task#isRead() read flag} and sets the {@linkplain\n+   * Task#isTransferred() transfer flag} if {@code setTransferFlag} is {@code true}. Exceptions will\n+   * be thrown if the caller got no {@linkplain WorkbasketPermission Permission} on the target\n+   * {@linkplain Workbasket} or if it does not exist. Other Exceptions will be stored and returned\n    * in the end.\n    *\n-   * @param destinationWorkbasketKey target workbasket key\n-   * @param destinationWorkbasketDomain target workbasket domain\n-   * @param taskIds source task which will be moved\n-   * @return Bulkresult with ID and Error in it for failed transactions.\n-   * @throws NotAuthorizedException if the caller hasn\u00b4t permissions on tarket WB.\n-   * @throws InvalidArgumentException if the method paramesters are EMPTY or NULL.\n-   * @throws WorkbasketNotFoundException if the target WB can\u00b4t be found.\n+   * @param destinationWorkbasketKey target {@linkplain Workbasket#getKey()} Workbasket}\n+   * @param destinationWorkbasketDomain target {@linkplain Workbasket#getDomain() domain}\n+   * @param taskIds List of source {@linkplain Task Tasks} which will be moved\n+   * @param setTransferFlag the control about whether to set the {@linkplain Task#isTransferred()}\n+   *     flag or not\n+   * @return BulkResult with {@linkplain Task#getId() id} and Error in it for failed transactions.\n+   * @throws NotAuthorizedException if the caller has no {@linkplain WorkbasketPermission} on target\n+   *     {@linkplain Workbasket}.\n+   * @throws InvalidArgumentException if the method parameters are EMPTY or NULL.\n+   * @throws WorkbasketNotFoundException if the target {@linkplain Workbasket} can not be found.\n    */\n   BulkOperationResults<String, TaskanaException> transferTasks(\n-      String destinationWorkbasketKey, String destinationWorkbasketDomain, List<String> taskIds)\n+      String destinationWorkbasketKey,\n+      String destinationWorkbasketDomain,\n+      List<String> taskIds,\n+      boolean setTransferFlag)\n       throws NotAuthorizedException, InvalidArgumentException, WorkbasketNotFoundException;\n \n   /**\n-   * Deletes the task with the given Id.\n+   * Deletes the {@linkplain Task} with the given {@linkplain Task#getId() id}.\n    *\n-   * @param taskId The Id of the task to delete.\n-   * @throws TaskNotFoundException If the given Id does not refer to an existing task.\n-   * @throws InvalidStateException If the state of the referenced task is not Completed.\n-   * @throws NotAuthorizedException if the current user is not member of role ADMIN\n+   * @param taskId The {@linkplain Task#getId() id} of the {@linkplain Task} to delete.\n+   * @throws TaskNotFoundException If the given {@linkplain Task#getId() id} does not refer to an\n+   *     existing {@linkplain Task}.\n+   * @throws InvalidStateException If the {@linkplain Task#getState() state} of the referenced\n+   *     {@linkplain Task} is not an end state.\n+   * @throws NotAuthorizedException if the current user is not member of role {@linkplain\n+   *     TaskanaRole#ADMIN}\n    */\n   void deleteTask(String taskId)\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n \n   /**\n-   * Deletes the task with the given Id even if it is not completed.\n+   * Deletes the {@linkplain Task} with the given {@linkplain Task#getId() id} even if it is not\n+   * completed.\n    *\n-   * @param taskId The Id of the task to delete.\n-   * @throws TaskNotFoundException If the given Id does not refer to an existing task.\n-   * @throws InvalidStateException If the state of the referenced task is not Completed and\n-   *     forceDelet is false.\n-   * @throws NotAuthorizedException if the current user is not member of role ADMIN\n+   * @param taskId The {@linkplain Task#getId() id} of the {@linkplain Task} to delete.\n+   * @throws TaskNotFoundException If the given {@linkplain Task#getId() id} does not refer to an\n+   *     existing {@linkplain Task}.\n+   * @throws InvalidStateException If the state of the referenced {@linkplain Task} is not an end\n+   *     state and forceDelete is false.\n+   * @throws NotAuthorizedException if the current user is not member of role {@linkplain\n+   *     TaskanaRole#ADMIN}\n    */\n   void forceDeleteTask(String taskId)\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n \n   /**\n-   * Deletes a list of tasks.\n+   * Selects and claims the first {@linkplain Task} which is returned by the {@linkplain TaskQuery}.\n    *\n-   * @param tasks the ids of the tasks to delete.\n-   * @return the result of the operations with Id and Exception for each failed task deletion.\n+   * @param taskQuery the {@linkplain TaskQuery}.\n+   * @return the {@linkplain Task} that got selected and claimed\n+   * @throws InvalidOwnerException if the {@linkplain Task} is claimed by someone else\n+   * @throws NotAuthorizedException if the current user has no read permission for the Workbasket\n+   *     the {@linkplain Task} is in\n+   */\n+  Task selectAndClaim(TaskQuery taskQuery) throws NotAuthorizedException, InvalidOwnerException;\n+\n+  /**\n+   * Deletes a list of {@linkplain Task Tasks}.\n+   *\n+   * @param tasks the {@linkplain Task#getId() ids} of the tasks to delete.\n+   * @return the result of the operations with each {@linkplain Task#getId() id} and Exception for\n+   *     each failed task deletion.\n    * @throws InvalidArgumentException if the TaskIds parameter is NULL\n+   * @throws NotAuthorizedException if the current user is not member of role ADMIN\n    */\n   BulkOperationResults<String, TaskanaException> deleteTasks(List<String> tasks)\n-      throws InvalidArgumentException;\n+      throws InvalidArgumentException, NotAuthorizedException;\n \n   /**\n-   * Completes a list of tasks.\n+   * Completes a list of {@linkplain Task Tasks}.\n    *\n-   * @param taskIds of the tasks which should be completed.\n-   * @return the result of the operations with Id and Exception for each failed task completion.\n-   * @throws InvalidArgumentException If the taskId parameter is NULL.\n+   * @param taskIds {@linkplain Task#getId() ids} of the {@linkplain Task Tasks} which should be\n+   *     completed\n+   * @return the result of the operations with each {@linkplain Task#getId() id} and Exception for\n+   *     each failed completion\n+   * @throws InvalidArgumentException If the taskIds parameter is NULL\n    */\n   BulkOperationResults<String, TaskanaException> completeTasks(List<String> taskIds)\n       throws InvalidArgumentException;\n \n   /**\n-   * Updates tasks with a matching {@link ObjectReference}.\n+   * Completes each existing {@linkplain Task} in the given List in every case, independent of the\n+   * {@linkplain Task#getOwner() owner} or {@linkplain Task#getState() state} of the {@linkplain\n+   * Task}. If the {@linkplain Task} is already {@linkplain TaskState#COMPLETED completed}, the\n+   * {@linkplain Task} stays unchanged.\n+   *\n+   * @see TaskService#forceCompleteTask\n+   * @param taskIds {@linkplain Task#getId() id} of the {@linkplain Task Tasks} which should be\n+   *     completed\n+   * @return the result of the operations with {@linkplain Task#getId() id} and Exception for each\n+   *     failed completion\n+   * @throws InvalidArgumentException If the taskIds parameter is NULL\n+   */\n+  BulkOperationResults<String, TaskanaException> forceCompleteTasks(List<String> taskIds)\n+      throws InvalidArgumentException;\n+\n+  /**\n+   * Updates specified {@linkplain TaskCustomField TaskCustomFields} of {@linkplain Task Tasks}\n+   * associated with the given {@linkplain ObjectReference}.\n    *\n-   * @param selectionCriteria the {@link ObjectReference} that is used to select the tasks.\n-   * @param customFieldsToUpdate a {@link Map} that contains as key the identification of the custom\n-   *     field and as value the corresponding new value of that custom field. The key for\n-   *     identification of the custom field must be a String with value \"1\", \"2\" ... \"16\" as in the\n-   *     setCustomAttribute or getCustomAttribute method of {@link Task}\n-   * @return a list of the Ids of all modified tasks\n-   * @throws InvalidArgumentException If the customFieldsToUpdate map contains an invalid key or if\n-   *     the selectionCriteria is invalid\n+   * @param selectionCriteria the {@linkplain ObjectReference} that is used to select the tasks\n+   * @param customFieldsToUpdate a Map that contains as key the identification of the {@linkplain\n+   *     TaskCustomField} and as value the corresponding new value of that field\n+   * @return a list of the {@linkplain Task#getId() ids} of all modified {@linkplain Task Tasks}\n+   * @throws InvalidArgumentException if the given selectionCriteria is invalid or the given\n+   *     customFieldsToUpdate are NULL or empty\n    */\n   List<String> updateTasks(\n-      ObjectReference selectionCriteria, Map<String, String> customFieldsToUpdate)\n+      ObjectReference selectionCriteria, Map<TaskCustomField, String> customFieldsToUpdate)\n       throws InvalidArgumentException;\n \n   /**\n-   * Updates tasks with matching taskIds.\n+   * Updates specified {@linkplain TaskCustomField TaskCustomFields} for all given {@linkplain Task\n+   * Tasks}.\n    *\n-   * @param taskIds the taskIds that are used to select the tasks.\n-   * @param customFieldsToUpdate a {@link Map} that contains as key the identification of the custom\n-   *     field and as value the corresponding new value of that custom field. The key for\n-   *     identification of the custom field must be a String with value \"1\", \"2\" ... \"16\" as in the\n-   *     setCustomAttribute or getCustomAttribute method of {@link Task}\n-   * @return a list of the Ids of all modified tasks\n-   * @throws InvalidArgumentException If the customFieldsToUpdate map contains an invalid key or if\n-   *     the selectionCriteria is invalid\n+   * @param taskIds the {@linkplain Task#getId() taskIds} that are used to select the {@linkplain\n+   *     Task Tasks}.\n+   * @param customFieldsToUpdate a Map that contains as key the identification of the {@linkplain\n+   *     TaskCustomField} and as value the corresponding new value of that {@linkplain\n+   *     TaskCustomField}.\n+   * @return a list of the {@linkplain Task#getId() ids} of all modified {@linkplain Task Tasks}\n+   * @throws InvalidArgumentException if the given customFieldsToUpdate are NULL or empty.\n    */\n-  List<String> updateTasks(List<String> taskIds, Map<String, String> customFieldsToUpdate)\n+  List<String> updateTasks(List<String> taskIds, Map<TaskCustomField, String> customFieldsToUpdate)\n       throws InvalidArgumentException;\n \n   /**\n-   * Create a task comment.\n+   * Inserts the specified {@linkplain TaskComment} into the database.\n    *\n-   * @param taskComment the task comment to be created.\n-   * @return the created task comment.\n-   * @throws NotAuthorizedException If the current user has no authorization to create a task\n-   *     comment for the given taskId in the TaskComment or is not authorized to access the task.\n-   * @throws TaskNotFoundException If the given taskId in the TaskComment does not refer to an\n-   *     existing task.\n-   * @throws InvalidArgumentException If the given taskCommentId from the provided task comment is\n-   *     not null or empty\n+   * @param taskComment the {@linkplain TaskComment} to be created\n+   * @return the created {@linkplain TaskComment}\n+   * @throws NotAuthorizedException if the current user has no authorization to create a {@link\n+   *     TaskComment} for the given taskId or is not authorized to access the {@linkplain Task}\n+   * @throws TaskNotFoundException if the given {@linkplain TaskComment#getTaskId() taskId} does not\n+   *     refer to an existing {@linkplain Task}\n+   * @throws InvalidArgumentException if the {@linkplain TaskComment#getId() id} of the provided\n+   *     {@link TaskComment} is not NULL or empty\n    */\n   TaskComment createTaskComment(TaskComment taskComment)\n       throws NotAuthorizedException, TaskNotFoundException, InvalidArgumentException;\n \n   /**\n-   * Update a task comment.\n+   * Updates the specified {@linkplain TaskComment}.\n    *\n-   * @param taskComment the task comment to be updated in the database.\n-   * @return the updated task comment.\n-   * @throws NotAuthorizedException If the current user has no authorization to update a task\n-   *     comment or is not authorized to access the task.\n-   * @throws ConcurrencyException if an attempt is made to update the task comment and another user.\n-   *     updated it already.\n-   * @throws TaskCommentNotFoundException If the given taskCommentId in the TaskComment does not\n-   *     refer to an existing taskComment.\n-   * @throws TaskNotFoundException If the given taskId in the TaskComment does not refer to an\n-   *     existing task.\n-   * @throws InvalidArgumentException If the given taskCommentId from the provided task comment is\n-   *     null or empty\n+   * @param taskComment the {@linkplain TaskComment} to be updated in the database\n+   * @return the updated {@linkplain TaskComment}\n+   * @throws NotAuthorizedException if the current user has no authorization to update the\n+   *     {@linkplain TaskComment} or is not authorized to access the {@linkplain Task}\n+   * @throws ConcurrencyException if an attempt is made to update the {@linkplain TaskComment} and\n+   *     another user updated it already; that's the case if the given {} timestamp differs from the\n+   *     one in the database\n+   * @throws TaskCommentNotFoundException if the {@linkplain TaskComment#getId() is} of the\n+   *     specified {@linkplain TaskComment}does not refer to an existing {@linkplain TaskComment}\n+   * @throws TaskNotFoundException if the {@linkplain TaskComment#getTaskId() taskId} does not refer\n+   *     to an existing {@linkplain Task}\n+   * @throws InvalidArgumentException if the given {@linkplain TaskComment#getId() id} is NULL or\n+   *     empty\n    */\n   TaskComment updateTaskComment(TaskComment taskComment)\n       throws NotAuthorizedException, ConcurrencyException, TaskCommentNotFoundException,\n           TaskNotFoundException, InvalidArgumentException;\n \n   /**\n-   * Deletes the task comment with the given Id.\n+   * Deletes the {@linkplain TaskComment} with the given {@linkplain TaskComment#getId() id}.\n    *\n-   * @param taskCommentId The id of the task comment to delete.\n-   * @throws NotAuthorizedException If the current user has no authorization to delete a task\n+   * @param taskCommentId the {@linkplain TaskComment#getId() id} of the {@linkplain TaskComment} to\n+   *     delete\n+   * @throws NotAuthorizedException if the current user has no authorization to delete a task\n    *     comment or is not authorized to access the task.\n-   * @throws InvalidArgumentException If the taskCommentId is null/empty\n-   * @throws TaskCommentNotFoundException If the given taskCommentId in the TaskComment does not\n+   * @throws InvalidArgumentException if the taskCommentId is NULL or empty\n+   * @throws TaskCommentNotFoundException if the given taskCommentId in the TaskComment does not\n    *     refer to an existing taskComment.\n-   * @throws TaskNotFoundException If the given taskId in the TaskComment does not refer to an\n-   *     existing task.\n-   * @throws InvalidArgumentException If the given taskCommentId is null or empty\n+   * @throws TaskNotFoundException if the {@linkplain TaskComment#getTaskId() taskId} of the\n+   *     TaskComment does not refer to an existing {@linkplain Task}.\n+   * @throws InvalidArgumentException if the given taskCommentId is NULL or empty\n    */\n   void deleteTaskComment(String taskCommentId)\n       throws NotAuthorizedException, TaskCommentNotFoundException, TaskNotFoundException,\n           InvalidArgumentException;\n \n   /**\n-   * Retrieves a task comment for a given taskCommentId.\n+   * Retrieves the {@linkplain TaskComment} with the given {@linkplain TaskComment#getId() id}.\n    *\n-   * @param taskCommentId The id of the task comment which should be retrieved\n-   * @return the task comment identified by taskCommentId\n-   * @throws TaskCommentNotFoundException If the given taskCommentId in the TaskComment does not\n-   *     refer to an existing taskComment.\n-   * @throws NotAuthorizedException If the current user has no authorization to retrieve a\n-   *     taskComment from a certain task or is not authorized to access the task.\n-   * @throws TaskNotFoundException If the given taskId in the TaskComment does not refer to an\n-   *     existing task.\n-   * @throws InvalidArgumentException If the given taskCommentId is null or empty\n+   * @param taskCommentId the {@linkplain TaskComment#getId() id} of the {@linkplain TaskComment}\n+   *     which should be retrieved\n+   * @return the {@linkplain TaskComment} identified by taskCommentId\n+   * @throws TaskCommentNotFoundException if the given taskCommentId does not refer to an existing\n+   *     {@linkplain TaskComment}\n+   * @throws NotAuthorizedException if the current user has no authorization to retrieve a\n+   *     {@linkplain TaskComment} from a certain {@linkplain Task} or is not authorized to access\n+   *     the {@linkplain Task}\n+   * @throws TaskNotFoundException if the {@linkplain TaskComment#getTaskId() taskId} of the\n+   *     TaskComment does not refer to an existing {@linkplain Task}\n+   * @throws InvalidArgumentException if the given taskCommentId is NULL or empty\n    */\n   TaskComment getTaskComment(String taskCommentId)\n       throws TaskCommentNotFoundException, NotAuthorizedException, TaskNotFoundException,\n           InvalidArgumentException;\n \n   /**\n-   * Retrieves a list of task comments for a given taskId.\n+   * Retrieves the List of {@linkplain TaskComment TaskComments} for the Task with given {@linkplain\n+   * Task#getId() id}.\n    *\n-   * @param taskId The id of the task for which all task comments should be retrieved\n-   * @return the list of task comments attached to task with id taskId\n-   * @throws NotAuthorizedException If the current user has no authorization to retrieve a\n-   *     taskComment from a certain task or is not authorized to access the task.\n-   * @throws TaskNotFoundException If the given taskId in the TaskComment does not refer to an\n-   *     existing task.\n+   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} for which all task\n+   *     comments should be retrieved\n+   * @return the List of task comments attached to the specified {@linkplain Task}\n+   * @throws NotAuthorizedException if the current user has no authorization to retrieve a\n+   *     taskComment from the {@linkplain Task} or is not authorized to access the {@linkplain Task}\n+   * @throws TaskNotFoundException if the given taskId does not refer to an existing {@linkplain\n+   *     Task}\n    */\n   List<TaskComment> getTaskComments(String taskId)\n       throws NotAuthorizedException, TaskNotFoundException;\n \n   /**\n-   * Sets the callback state on a list of tasks. Note: this method is primarily intended to be used\n-   * by the TaskanaAdapter\n+   * Sets the specified {@linkplain CallbackState} on a list of {@linkplain Task Tasks}. Note: this\n+   * method is primarily intended to be used by the TaskanaAdapter\n    *\n-   * @param externalIds the EXTERNAL_IDs of the tasks on which the callback state is set.\n-   * @param state the callback state that is to be set on the tasks\n-   * @return the result of the operations with Id and Exception for each failed task deletion.\n+   * @param externalIds the {@linkplain Task#getExternalId() externalIds} of the {@linkplain Task\n+   *     Tasks} on which the {@linkplain CallbackState} is set\n+   * @param state the {@linkplain CallbackState} that is to be set on the {@linkplain Task Tasks}\n+   * @return the result of the operations with {@linkplain Task#getId() id} and Exception for each\n+   *     failed operation\n    */\n   BulkOperationResults<String, TaskanaException> setCallbackStateForTasks(\n       List<String> externalIds, CallbackState state);\n \n   /**\n-   * Sets the owner on a list of tasks. The owner will only be set on tasks that are in state READY.\n+   * Sets the {@linkplain Task#getOwner() owner} on a List of {@linkplain Task Tasks}. The\n+   * {@linkplain Task#getOwner() owner} will only be set on {@linkplain Task Tasks} that are in\n+   * state {@linkplain TaskState#READY}.\n    *\n-   * @param owner the new owner of the tasks\n-   * @param taskIds the IDs of the tasks on which the owner is to be set.\n-   * @return the result of the operations with Id and Exception for each failed task update.\n+   * @param owner the new {@linkplain Task#getOwner() owner} of the {@linkplain Task Tasks}\n+   * @param taskIds the {@linkplain Task#getId() ids} of the {@linkplain Task Tasks} on which the\n+   *     {@linkplain Task#getOwner() owner} is to be set\n+   * @return the result of the operations with {@linkplain Task#getId() id} and Exception for each\n+   *     failed {@linkplain Task}-update\n    */\n   BulkOperationResults<String, TaskanaException> setOwnerOfTasks(\n       String owner, List<String> taskIds);\n \n   /**\n-   * Sets the planned property on a list of tasks. Only tasks in state READY and CLAIMED will be\n-   * affected by this method. On each task, the corresponding due date is set according to the\n-   * shortest service level in the classifications of the task and the task's attachments.\n+   * Sets the {@linkplain Task#getPlanned() planned} Instant on a List of {@linkplain Task Tasks}.\n+   * Only {@linkplain Task Tasks} in state {@linkplain TaskState#READY} and {@linkplain\n+   * TaskState#CLAIMED} will be affected by this method. On each {@linkplain Task}, the\n+   * corresponding {@linkplain Task#getDue() due date} is set according to the shortest serviceLevel\n+   * in the {@linkplain Task#getClassificationSummary() Classification} of the {@linkplain Task} and\n+   * its {@linkplain Task#getAttachments() Attachments}.\n    *\n-   * @param planned the new 'PLANNED\" property of the tasks\n-   * @param taskIds the IDs of the tasks on which the new planned property is to be set.\n-   * @return the result of the operations with Id and Exception for each failed task update.\n+   * @param planned the new {@linkplain Task#getPlanned() planned} Instant of the {@linkplain Task\n+   *     Tasks}\n+   * @param taskIds the {@linkplain Task#getId() ids} of the {@linkplain Task Tasks} on which the\n+   *     new {@linkplain Task#getPlanned() planned} Instant is to be set\n+   * @return the result of the operations with {@linkplain Task#getId() id} and Exception for each\n+   *     failed {@linkplain Task Task} update.\n    */\n   BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n       Instant planned, List<String> taskIds);\n \n   /**\n-   * Cancels a task.\n+   * Cancels the {@linkplain Task} with the given {@linkplain Task#getId() id}. Cancellation means a\n+   * {@linkplain Task} is obsolete from a business perspective and does not need to be completed\n+   * anymore.\n    *\n-   * @param taskId the id of the task to cancel.\n-   * @return the updated task.\n-   * @throws TaskNotFoundException if the Task with Id TaskId is not found\n-   * @throws InvalidStateException if the task is not in state READY or CLAIMED\n-   * @throws NotAuthorizedException if the current user is not authorized to see the task\n+   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to cancel\n+   * @return the updated {@linkplain Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} with taskId is not found\n+   * @throws InvalidStateException if the {@linkplain Task} is not in state {@linkplain\n+   *     TaskState#READY} or {@linkplain TaskState#CLAIMED}\n+   * @throws NotAuthorizedException if the current user is not authorized to see the {@linkplain\n+   *     Task}\n    */\n   Task cancelTask(String taskId)\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n \n   /**\n-   * Terminates a task.\n+   * Terminates a {@linkplain Task}. Termination is an administrative action to complete a\n+   * {@linkplain Task}. This is typically done by administration to correct any technical issue.\n    *\n-   * @param taskId the id of the task to cancel.\n-   * @return the updated task.\n-   * @throws TaskNotFoundException if the Task with Id TaskId is not found\n-   * @throws InvalidStateException if the task is not in state READY or CLAIMED\n-   * @throws NotAuthorizedException if the current user is not authorized to see the task\n+   * @param taskId the id of the {@linkplain Task} to cancel\n+   * @return the updated {@linkplain Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} with taskId is not found\n+   * @throws InvalidStateException if the {@linkplain Task} is not in state {@linkplain\n+   *     TaskState#READY} or {@linkplain TaskState#CLAIMED}\n+   * @throws NotAuthorizedException if the current user is not authorized to see the {@linkplain\n+   *     Task}\n    */\n   Task terminateTask(String taskId)\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n", "next_change": {"commit": "a2e068119042fd305c3f494e43cd41fec80f1a30", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 48bac1ed4..a58ce2866 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -670,49 +744,53 @@ public interface TaskService {\n \n   /**\n    * Sets the {@linkplain Task#getPlanned() planned} Instant on a List of {@linkplain Task Tasks}.\n-   * Only {@linkplain Task Tasks} in state {@linkplain TaskState#READY} and {@linkplain\n+   *\n+   * <p>Only {@linkplain Task Tasks} in state {@linkplain TaskState#READY} and {@linkplain\n    * TaskState#CLAIMED} will be affected by this method. On each {@linkplain Task}, the\n-   * corresponding {@linkplain Task#getDue() due date} is set according to the shortest serviceLevel\n-   * in the {@linkplain Task#getClassificationSummary() Classification} of the {@linkplain Task} and\n-   * its {@linkplain Task#getAttachments() Attachments}.\n+   * corresponding {@linkplain Task#getDue() due} Instant is set according to the shortest\n+   * serviceLevel in the {@linkplain Task#getClassificationSummary() Classification} of the\n+   * {@linkplain Task} and its {@linkplain Task#getAttachments() Attachments}.\n    *\n    * @param planned the new {@linkplain Task#getPlanned() planned} Instant of the {@linkplain Task\n    *     Tasks}\n    * @param taskIds the {@linkplain Task#getId() ids} of the {@linkplain Task Tasks} on which the\n    *     new {@linkplain Task#getPlanned() planned} Instant is to be set\n-   * @return the result of the operations with {@linkplain Task#getId() id} and Exception for each\n-   *     failed {@linkplain Task Task} update.\n+   * @return the result of the operations with {@linkplain Task#getId() ids} and Exception for each\n+   *     failed {@linkplain Task} update\n    */\n   BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n       Instant planned, List<String> taskIds);\n \n   /**\n-   * Cancels the {@linkplain Task} with the given {@linkplain Task#getId() id}. Cancellation means a\n-   * {@linkplain Task} is obsolete from a business perspective and does not need to be completed\n-   * anymore.\n+   * Cancels the {@linkplain Task} with the given {@linkplain Task#getId() id}.\n+   *\n+   * <p>Cancellation means a {@linkplain Task} is obsolete from a business perspective and doesn't\n+   * need to be completed anymore.\n    *\n    * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to cancel\n    * @return the updated {@linkplain Task}\n-   * @throws TaskNotFoundException if the {@linkplain Task} with taskId is not found\n-   * @throws InvalidStateException if the {@linkplain Task} is not in state {@linkplain\n-   *     TaskState#READY} or {@linkplain TaskState#CLAIMED}\n-   * @throws NotAuthorizedException if the current user is not authorized to see the {@linkplain\n-   *     Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} with taskId wasn't found\n+   * @throws InvalidStateException if the {@linkplain Task} isn't in {@linkplain TaskState#READY} or\n+   *     {@linkplain TaskState#CLAIMED}\n+   * @throws NotAuthorizedException if the current user has no {@linkplain\n+   *     WorkbasketPermission#READ} for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task cancelTask(String taskId)\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n \n   /**\n    * Terminates a {@linkplain Task}. Termination is an administrative action to complete a\n-   * {@linkplain Task}. This is typically done by administration to correct any technical issue.\n+   * {@linkplain Task}.\n+   *\n+   * <p>This is typically done by administration to correct any technical issue.\n    *\n-   * @param taskId the id of the {@linkplain Task} to cancel\n+   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to cancel\n    * @return the updated {@linkplain Task}\n-   * @throws TaskNotFoundException if the {@linkplain Task} with taskId is not found\n-   * @throws InvalidStateException if the {@linkplain Task} is not in state {@linkplain\n-   *     TaskState#READY} or {@linkplain TaskState#CLAIMED}\n-   * @throws NotAuthorizedException if the current user is not authorized to see the {@linkplain\n-   *     Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} with taskId wasn't found\n+   * @throws InvalidStateException if the {@linkplain Task} isn't in {@linkplain TaskState#READY} or\n+   *     {@linkplain TaskState#CLAIMED}\n+   * @throws NotAuthorizedException if the current user isn't member of {@linkplain\n+   *     TaskanaRole#ADMIN} or {@linkplain TaskanaRole#BUSINESS_ADMIN}\n    */\n   Task terminateTask(String taskId)\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n", "next_change": {"commit": "33a88529954a490d2a042a34319cbf394ee15e9d", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex a58ce2866..6e357fdf2 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -677,121 +853,55 @@ public interface TaskService {\n       throws NotAuthorizedException, TaskCommentNotFoundException, TaskNotFoundException,\n           InvalidArgumentException;\n \n-  /**\n-   * Retrieves the {@linkplain TaskComment} with the given {@linkplain TaskComment#getId() id}.\n-   *\n-   * @param taskCommentId the {@linkplain TaskComment#getId() id} of the {@linkplain TaskComment}\n-   *     which should be retrieved\n-   * @return the {@linkplain TaskComment} identified by taskCommentId\n-   * @throws TaskCommentNotFoundException if the given taskCommentId doesn't refer to an existing\n-   *     {@linkplain TaskComment}\n-   * @throws NotAuthorizedException if the current user has no {@linkplain\n-   *     WorkbasketPermission#READ} for the {@linkplain Workbasket} of the commented {@linkplain\n-   *     Task}\n-   * @throws TaskNotFoundException if the {@linkplain TaskComment#getTaskId() taskId} of the\n-   *     TaskComment doesn't refer to an existing {@linkplain Task}\n-   * @throws InvalidArgumentException if the given taskCommentId is NULL or empty\n-   */\n-  TaskComment getTaskComment(String taskCommentId)\n-      throws TaskCommentNotFoundException, NotAuthorizedException, TaskNotFoundException,\n-          InvalidArgumentException;\n+  // endregion\n \n-  /**\n-   * Retrieves the List of {@linkplain TaskComment TaskComments} for the {@linkplain Task} with\n-   * given {@linkplain Task#getId() id}.\n-   *\n-   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} for which all\n-   *     {@linkplain TaskComment TaskComments} should be retrieved\n-   * @return the List of {@linkplain TaskComment TaskComments} attached to the specified {@linkplain\n-   *     Task}\n-   * @throws NotAuthorizedException if the current user has no {@linkplain\n-   *     WorkbasketPermission#READ} for the {@linkplain Workbasket} of the commented {@linkplain\n-   *     Task}\n-   * @throws TaskNotFoundException if the given taskId doesn't refer to an existing {@linkplain\n-   *     Task}\n-   */\n-  List<TaskComment> getTaskComments(String taskId)\n-      throws NotAuthorizedException, TaskNotFoundException;\n+  // endregion\n \n   /**\n-   * Sets the specified {@linkplain CallbackState} on a List of {@linkplain Task Tasks}.\n-   *\n-   * <p>Note: this method is primarily intended to be used by the TaskanaAdapter\n+   * Instantiates a non-persistent/non-inserted {@linkplain Attachment}.\n    *\n-   * @param externalIds the {@linkplain Task#getExternalId() externalIds} of the {@linkplain Task\n-   *     Tasks} on which the {@linkplain CallbackState} is set\n-   * @param state the {@linkplain CallbackState} that is to be set on the {@linkplain Task Tasks}\n-   * @return the result of the operations with {@linkplain Task#getId() ids} and Exception for each\n-   *     failed operation\n+   * @return the instantiated {@linkplain Attachment}\n    */\n-  BulkOperationResults<String, TaskanaException> setCallbackStateForTasks(\n-      List<String> externalIds, CallbackState state);\n+  Attachment newAttachment();\n \n   /**\n-   * Sets the {@linkplain Task#getOwner() owner} on a List of {@linkplain Task Tasks}.\n-   *\n-   * <p>The {@linkplain Task#getOwner() owner} will only be set on {@linkplain Task Tasks} that are\n-   * in {@linkplain TaskState#READY}.\n+   * Instantiates a non-persistent/non-inserted {@linkplain ObjectReference}.\n    *\n-   * @param owner the new {@linkplain Task#getOwner() owner} of the {@linkplain Task Tasks}\n-   * @param taskIds the {@linkplain Task#getId() ids} of the {@linkplain Task Tasks} on which the\n-   *     {@linkplain Task#getOwner() owner} is to be set\n-   * @return the result of the operations with {@linkplain Task#getId() ids} and Exception for each\n-   *     failed {@linkplain Task}-update\n+   * @return the instantiated {@linkplain ObjectReference}\n+   * @see #newObjectReference(String, String, String, String, String)\n    */\n-  BulkOperationResults<String, TaskanaException> setOwnerOfTasks(\n-      String owner, List<String> taskIds);\n+  ObjectReference newObjectReference();\n \n   /**\n-   * Sets the {@linkplain Task#getPlanned() planned} Instant on a List of {@linkplain Task Tasks}.\n-   *\n-   * <p>Only {@linkplain Task Tasks} in state {@linkplain TaskState#READY} and {@linkplain\n-   * TaskState#CLAIMED} will be affected by this method. On each {@linkplain Task}, the\n-   * corresponding {@linkplain Task#getDue() due} Instant is set according to the shortest\n-   * serviceLevel in the {@linkplain Task#getClassificationSummary() Classification} of the\n-   * {@linkplain Task} and its {@linkplain Task#getAttachments() Attachments}.\n+   * Instantiates a non-persistent/non-inserted {@linkplain ObjectReference}.\n    *\n-   * @param planned the new {@linkplain Task#getPlanned() planned} Instant of the {@linkplain Task\n-   *     Tasks}\n-   * @param taskIds the {@linkplain Task#getId() ids} of the {@linkplain Task Tasks} on which the\n-   *     new {@linkplain Task#getPlanned() planned} Instant is to be set\n-   * @return the result of the operations with {@linkplain Task#getId() ids} and Exception for each\n-   *     failed {@linkplain Task} update\n+   * @param company the {@linkplain ObjectReference#getCompany() company} of the new {@linkplain\n+   *     ObjectReference}\n+   * @param system the {@linkplain ObjectReference#getSystem() system} of the new {@linkplain\n+   *     ObjectReference}\n+   * @param systemInstance the {@linkplain ObjectReference#getSystemInstance() systemInstance} of\n+   *     the new {@linkplain ObjectReference}\n+   * @param type the {@linkplain ObjectReference#getType() type} of the new {@linkplain\n+   *     ObjectReference}\n+   * @param value the {@linkplain ObjectReference#getValue() value} of the new {@linkplain\n+   *     ObjectReference}\n+   * @return the instantiated {@linkplain ObjectReference}\n+   * @see #newObjectReference()\n    */\n-  BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n-      Instant planned, List<String> taskIds);\n+  ObjectReference newObjectReference(\n+      String company, String system, String systemInstance, String type, String value);\n \n   /**\n-   * Cancels the {@linkplain Task} with the given {@linkplain Task#getId() id}.\n-   *\n-   * <p>Cancellation means a {@linkplain Task} is obsolete from a business perspective and doesn't\n-   * need to be completed anymore.\n+   * Creates an empty {@linkplain TaskQuery}.\n    *\n-   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to cancel\n-   * @return the updated {@linkplain Task}\n-   * @throws TaskNotFoundException if the {@linkplain Task} with taskId wasn't found\n-   * @throws InvalidStateException if the {@linkplain Task} isn't in {@linkplain TaskState#READY} or\n-   *     {@linkplain TaskState#CLAIMED}\n-   * @throws NotAuthorizedException if the current user has no {@linkplain\n-   *     WorkbasketPermission#READ} for the {@linkplain Workbasket} the {@linkplain Task} is in\n+   * @return a {@linkplain TaskQuery}\n    */\n-  Task cancelTask(String taskId)\n-      throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n+  TaskQuery createTaskQuery();\n \n   /**\n-   * Terminates a {@linkplain Task}. Termination is an administrative action to complete a\n-   * {@linkplain Task}.\n-   *\n-   * <p>This is typically done by administration to correct any technical issue.\n+   * Creates an empty {@linkplain TaskCommentQuery}.\n    *\n-   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to cancel\n-   * @return the updated {@linkplain Task}\n-   * @throws TaskNotFoundException if the {@linkplain Task} with taskId wasn't found\n-   * @throws InvalidStateException if the {@linkplain Task} isn't in {@linkplain TaskState#READY} or\n-   *     {@linkplain TaskState#CLAIMED}\n-   * @throws NotAuthorizedException if the current user isn't member of {@linkplain\n-   *     TaskanaRole#ADMIN} or {@linkplain TaskanaRole#BUSINESS_ADMIN}\n+   * @return a {@linkplain TaskCommentQuery}\n    */\n-  Task terminateTask(String taskId)\n-      throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n+  TaskCommentQuery createTaskCommentQuery();\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1NDI1Ng==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398654256", "body": "Maybe just \"in\" as it is a well known operator for this? Just an idea.", "bodyText": "Maybe just \"in\" as it is a well known operator for this? Just an idea.", "bodyHTML": "<p dir=\"auto\">Maybe just \"in\" as it is a well known operator for this? Just an idea.</p>", "author": "holgerhagen", "createdAt": "2020-03-26T15:16:25Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java", "diffHunk": "@@ -4,5 +4,20 @@\n public enum TaskState {\n   READY,\n   CLAIMED,\n-  COMPLETED\n+  COMPLETED,\n+  CANCELLED,\n+  TERMINATED;\n+\n+  public boolean isInStates(TaskState... states) {", "originalCommit": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE2MTM3OA==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r399161378", "bodyText": "You don't like that? Or you has overseen this ons?", "author": "holgerhagen", "createdAt": "2020-03-27T10:15:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1NDI1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI4NzI0Nw==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r399287247", "bodyText": "Ok, I didn't see this one. No problem, I'll change it to 'in'", "author": "BerndBreier", "createdAt": "2020-03-27T14:04:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1NDI1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "3b13b9a95e4d7d1cf172f22fa0f2679ff1c5f79b", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\nindex fd7b87a38..d4aba71ba 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\n", "chunk": "@@ -4,20 +4,5 @@ package pro.taskana.task.api;\n public enum TaskState {\n   READY,\n   CLAIMED,\n-  COMPLETED,\n-  CANCELLED,\n-  TERMINATED;\n-\n-  public boolean isInStates(TaskState... states) {\n-    for (TaskState currState : states) {\n-      if (this.equals(currState)) {\n-        return true;\n-      }\n-    }\n-    return false;\n-  }\n-\n-  public boolean isEndState() {\n-    return this.equals(COMPLETED) || this.equals(CANCELLED) || this.equals(TERMINATED);\n-  }\n+  COMPLETED\n }\n", "next_change": {"commit": "2ce7f86456f99d522e001080e9504ae4cd6a80f4", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\nindex d4aba71ba..fd7b87a38 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\n", "chunk": "@@ -4,5 +4,20 @@ package pro.taskana.task.api;\n public enum TaskState {\n   READY,\n   CLAIMED,\n-  COMPLETED\n+  COMPLETED,\n+  CANCELLED,\n+  TERMINATED;\n+\n+  public boolean isInStates(TaskState... states) {\n+    for (TaskState currState : states) {\n+      if (this.equals(currState)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  public boolean isEndState() {\n+    return this.equals(COMPLETED) || this.equals(CANCELLED) || this.equals(TERMINATED);\n+  }\n }\n", "next_change": {"commit": "bd116d4c2e02b853dd336e3f2efdcd6b330f2fe1", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\nindex fd7b87a38..522351e8e 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\n", "chunk": "@@ -8,16 +10,11 @@ public enum TaskState {\n   CANCELLED,\n   TERMINATED;\n \n-  public boolean isInStates(TaskState... states) {\n-    for (TaskState currState : states) {\n-      if (this.equals(currState)) {\n-        return true;\n-      }\n-    }\n-    return false;\n+  public boolean in(TaskState... states) {\n+    return Arrays.stream(states).anyMatch(state -> state == this);\n   }\n \n   public boolean isEndState() {\n-    return this.equals(COMPLETED) || this.equals(CANCELLED) || this.equals(TERMINATED);\n+    return this == COMPLETED || this == CANCELLED || this == TERMINATED;\n   }\n }\n", "next_change": {"commit": "fe0ce092feaa1830e115de2d1cacdc9bf79705d6", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\nindex 522351e8e..e883a54d0 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\n", "chunk": "@@ -10,11 +10,13 @@ public enum TaskState {\n   CANCELLED,\n   TERMINATED;\n \n+  public static final TaskState[] END_STATES = {COMPLETED, CANCELLED, TERMINATED};\n+\n   public boolean in(TaskState... states) {\n     return Arrays.stream(states).anyMatch(state -> state == this);\n   }\n \n   public boolean isEndState() {\n-    return this == COMPLETED || this == CANCELLED || this == TERMINATED;\n+    return in(END_STATES);\n   }\n }\n", "next_change": {"commit": "34d2bbfa929ccaa9e9b93c173b8fa867154330bb", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\nindex e883a54d0..750fb6a01 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\n", "chunk": "@@ -13,7 +13,7 @@ public enum TaskState {\n   public static final TaskState[] END_STATES = {COMPLETED, CANCELLED, TERMINATED};\n \n   public boolean in(TaskState... states) {\n-    return Arrays.stream(states).anyMatch(state -> state == this);\n+    return Arrays.asList(states).contains(this);\n   }\n \n   public boolean isEndState() {\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1NTM4Mg==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398655382", "body": "Why don't we provide the converter on engine level and initialize it during startup according to the configuration?", "bodyText": "Why don't we provide the converter on engine level and initialize it during startup according to the configuration?", "bodyHTML": "<p dir=\"auto\">Why don't we provide the converter on engine level and initialize it during startup according to the configuration?</p>", "author": "holgerhagen", "createdAt": "2020-03-26T15:17:49Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java", "diffHunk": "@@ -48,14 +46,9 @@\n     this.taskanaEngine = taskanaEngine;\n     this.taskMapper = taskMapper;\n     this.attachmentMapper = attachmentMapper;\n-    DaysToWorkingDaysConverter.setGermanPublicHolidaysEnabled(\n-        taskanaEngine.getEngine().getConfiguration().isGermanPublicHolidaysEnabled());\n-    try {\n-      converter = DaysToWorkingDaysConverter.initialize();\n-    } catch (InvalidArgumentException e) {\n-      LOGGER.error(ERROR_CANNOT_INITIALIZE_DAYS_TO_WORKING_DAYS_CONVERTER);\n-      throw new SystemException(\n-          ERROR_CANNOT_INITIALIZE_DAYS_TO_WORKING_DAYS_CONVERTER, e.getCause());\n+    this.converter = WorkingDaysToDaysConverter.initialize();\n+    if (taskanaEngine.getEngine().getConfiguration().isGermanPublicHolidaysEnabled()) {", "originalCommit": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc0NzQ0OA==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398747448", "bodyText": "Apart from the DaysToWorkingDaysReportConverter, the converter is only needed in ServiceLevelHandler. I think, we should maintain and supply classes / objects there where they are needed. But if you insist to provide it on engine level, I can do that.\nWith respect to configuration: I introduce the configuration property taskana.german.holidays.enabled and set it to true in taskana.properties. Then I initialize this property in TaskanaEngineConfiguration and use it in the constructor of TaskanaEngineImpl to set that (static) property on WorkingDaysToDaysConverter.", "author": "BerndBreier", "createdAt": "2020-03-26T17:15:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1NTM4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "02a6df6f73622e86684c6c30d8f320c84078b237", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\nindex 743dbd9be..d6f999501 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n", "chunk": "@@ -33,44 +34,28 @@ import pro.taskana.task.internal.models.TaskImpl;\n class ServiceLevelHandler {\n \n   private static final Logger LOGGER = LoggerFactory.getLogger(ServiceLevelHandler.class);\n+  private static final String ERROR_CANNOT_INITIALIZE_DAYS_TO_WORKING_DAYS_CONVERTER =\n+      \"Internal error. Cannot initialize DaysToWorkingDaysConverter\";\n   private static final Duration MAX_DURATION = Duration.ofSeconds(Long.MAX_VALUE, 999_999_999);\n   private final InternalTaskanaEngine taskanaEngine;\n   private final TaskMapper taskMapper;\n   private final AttachmentMapper attachmentMapper;\n-  private WorkingDaysToDaysConverter converter;\n+  private DaysToWorkingDaysConverter converter;\n \n-  ServiceLevelHandler(\n+  public ServiceLevelHandler(\n       InternalTaskanaEngine taskanaEngine,\n       TaskMapper taskMapper,\n       AttachmentMapper attachmentMapper) {\n+    super();\n     this.taskanaEngine = taskanaEngine;\n     this.taskMapper = taskMapper;\n     this.attachmentMapper = attachmentMapper;\n-    this.converter = WorkingDaysToDaysConverter.initialize();\n-    if (taskanaEngine.getEngine().getConfiguration().isGermanPublicHolidaysEnabled()) {\n-      WorkingDaysToDaysConverter.setGermanPublicHolidaysEnabled(true);\n-    }\n-  }\n-\n-  // use the same algorithm as setPlannedPropertyOfTasksImpl to refresh\n-  // priority and duration of affected tasks, just don't use a fix\n-  // planned date but the individual planned date of the tasks\n-  public void refreshPriorityAndDueDatesOfTasks(\n-      List<MinimalTaskSummary> tasks, boolean serviceLevelChanged, boolean priorityChanged) {\n-\n-    List<AttachmentSummaryImpl> attachments = getAttachmentSummaries(tasks);\n-    List<ClassificationSummary> allInvolvedClassifications =\n-        findAllClassificationsReferencedByTasksAndAttachments(tasks, attachments);\n-\n-    if (serviceLevelChanged) {\n-      List<ClassificationWithServiceLevelResolved> allInvolvedClassificationsWithDuration =\n-          resolveDurationsInClassifications(allInvolvedClassifications);\n-\n-      updateTaskDueDatesOnClassificationUpdate(\n-          tasks, attachments, allInvolvedClassificationsWithDuration);\n-    }\n-    if (priorityChanged) {\n-      updateTaskPriorityOnClassificationUpdate(tasks, attachments, allInvolvedClassifications);\n+    try {\n+      this.converter = DaysToWorkingDaysConverter.initialize();\n+    } catch (InvalidArgumentException e) {\n+      LOGGER.error(ERROR_CANNOT_INITIALIZE_DAYS_TO_WORKING_DAYS_CONVERTER);\n+      throw new SystemException(\n+          ERROR_CANNOT_INITIALIZE_DAYS_TO_WORKING_DAYS_CONVERTER, e.getCause());\n     }\n   }\n \n", "next_change": {"commit": "fa429cef97db829102f746731f4dd966358c531e", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\nindex d6f999501..617e31aae 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n", "chunk": "@@ -59,6 +58,28 @@ class ServiceLevelHandler {\n     }\n   }\n \n+  // use the same algorithm as setPlannedPropertyOfTasksImpl to refresh\n+  // priority and duration of affected tasks, just don't use a fix\n+  // planned date but the individual planned date of the tasks\n+  public void refreshPriorityAndDueDatesOfTasks(\n+      List<MinimalTaskSummary> tasks, boolean serviceLevelChanged, boolean priorityChanged) {\n+\n+    List<AttachmentSummaryImpl> attachments = getAttachmentSummaries(tasks);\n+    List<ClassificationSummary> allInvolvedClassifications =\n+        findAllClassificationsReferencedByTasksAndAttachments(tasks, attachments);\n+\n+    if (serviceLevelChanged) {\n+      List<ClassificationWithServiceLevelResolved> allInvolvedClassificationsWithDuration =\n+          resolveDurationsInClassifications(allInvolvedClassifications);\n+\n+      updateTaskDueDatesOnClassificationUpdate(\n+          tasks, attachments, allInvolvedClassificationsWithDuration);\n+    }\n+    if (priorityChanged) {\n+      updateTaskPriorityOnClassificationUpdate(tasks, attachments, allInvolvedClassifications);\n+    }\n+  }\n+\n   // Algorithm:\n   // - load all relevant tasks and their attachmentSummaries\n   // - load all classifications referenced by these tasks / attachments\n", "next_change": {"commit": "f70d84579386fa560e6013485f276d0ebb19386a", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\nindex 617e31aae..f1c982557 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n", "chunk": "@@ -76,7 +70,10 @@ class ServiceLevelHandler {\n           tasks, attachments, allInvolvedClassificationsWithDuration);\n     }\n     if (priorityChanged) {\n-      updateTaskPriorityOnClassificationUpdate(tasks, attachments, allInvolvedClassifications);\n+      List<MinimalTaskSummary> tasksWithoutManualPriority =\n+          tasks.stream().filter(t -> !t.isManualPriorityActive()).collect(Collectors.toList());\n+      updateTaskPriorityOnClassificationUpdate(\n+          tasksWithoutManualPriority, attachments, allInvolvedClassifications);\n     }\n   }\n \n", "next_change": {"commit": "93d0b27bb058a4f47218177136bce81f99103345", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\nindex f1c982557..eb18ba692 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n", "chunk": "@@ -71,7 +72,9 @@ class ServiceLevelHandler {\n     }\n     if (priorityChanged) {\n       List<MinimalTaskSummary> tasksWithoutManualPriority =\n-          tasks.stream().filter(t -> !t.isManualPriorityActive()).collect(Collectors.toList());\n+          tasks.stream()\n+              .filter(not(MinimalTaskSummary::isManualPriorityActive))\n+              .collect(Collectors.toList());\n       updateTaskPriorityOnClassificationUpdate(\n           tasksWithoutManualPriority, attachments, allInvolvedClassifications);\n     }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1NzQ0Nw==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398657447", "body": "We should retain this timestamp even if the task is terminated/cancelled.", "bodyText": "We should retain this timestamp even if the task is terminated/cancelled.", "bodyHTML": "<p dir=\"auto\">We should retain this timestamp even if the task is terminated/cancelled.</p>", "author": "holgerhagen", "createdAt": "2020-03-26T15:20:22Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java", "diffHunk": "@@ -951,6 +979,29 @@ private TaskImpl checkConcurrencyAndSetModified(TaskImpl newTaskImpl, TaskImpl o\n     return newTaskImpl;\n   }\n \n+  private TaskImpl terminateCancelCommonActions(String taskId, TaskState targetState)\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n+    if (taskId == null || taskId.isEmpty()) {\n+      throw new TaskNotFoundException(taskId, String.format(TASK_WITH_ID_WAS_NOT_FOUND, taskId));\n+    }\n+    TaskImpl task = (TaskImpl) getTask(taskId);\n+    TaskState state = task.getState();\n+    if (state.isEndState()) {\n+      throw new InvalidStateException(String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n+    }\n+\n+    Instant now = Instant.now();\n+    task.setOwner(null);\n+    task.setModified(now);\n+    task.setCompleted(now);\n+    task.setClaimed(null);", "originalCommit": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc0ODU5Ng==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398748596", "bodyText": "ok, retained the claimed timestamp", "author": "BerndBreier", "createdAt": "2020-03-26T17:17:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1NzQ0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "3b13b9a95e4d7d1cf172f22fa0f2679ff1c5f79b", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 382c3861a..e4e8b398d 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -963,88 +755,23 @@ public class TaskServiceImpl implements TaskService {\n     return result;\n   }\n \n-  private TaskImpl checkConcurrencyAndSetModified(TaskImpl newTaskImpl, TaskImpl oldTaskImpl)\n-      throws ConcurrencyException {\n-    // TODO: not safe to rely only on different timestamps.\n-    // With fast execution below 1ms there will be no concurrencyException\n-    if (oldTaskImpl.getModified() != null\n-            && !oldTaskImpl.getModified().equals(newTaskImpl.getModified())\n-        || oldTaskImpl.getClaimed() != null\n-            && !oldTaskImpl.getClaimed().equals(newTaskImpl.getClaimed())\n-        || oldTaskImpl.getState() != null\n-            && !oldTaskImpl.getState().equals(newTaskImpl.getState())) {\n-      throw new ConcurrencyException(\"The task has already been updated by another user\");\n-    }\n-    newTaskImpl.setModified(Instant.now());\n-    return newTaskImpl;\n-  }\n-\n-  private TaskImpl terminateCancelCommonActions(String taskId, TaskState targetState)\n-      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n-    if (taskId == null || taskId.isEmpty()) {\n-      throw new TaskNotFoundException(taskId, String.format(TASK_WITH_ID_WAS_NOT_FOUND, taskId));\n-    }\n-    TaskImpl task = (TaskImpl) getTask(taskId);\n-    TaskState state = task.getState();\n-    if (state.isEndState()) {\n-      throw new InvalidStateException(String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n-    }\n-\n-    Instant now = Instant.now();\n-    task.setOwner(null);\n-    task.setModified(now);\n-    task.setCompleted(now);\n-    task.setClaimed(null);\n-    task.setRead(true);\n-    task.setState(targetState);\n-    taskMapper.update(task);\n-    LOGGER.debug(\"Task '{}' cancelled by user '{}'.\", taskId, CurrentUserContext.getUserid());\n-    return task;\n-  }\n-\n-  private BulkOperationResults<String, TaskanaException> addExceptionsForTasksWhoseOwnerWasNotSet(\n-      String owner, List<MinimalTaskSummary> existingMinimalTaskSummaries) {\n-    BulkOperationResults<String, TaskanaException> bulkLog = new BulkOperationResults<>();\n-\n-    for (MinimalTaskSummary taskSummary : existingMinimalTaskSummaries) {\n-      if (!owner.equals(taskSummary.getOwner())) { // owner was not set\n-        if (!TaskState.READY.equals(taskSummary.getTaskState())) { // due to invalid state\n-          bulkLog.addError(\n-              taskSummary.getTaskId(),\n-              new InvalidStateException(\n-                  String.format(\n-                      TASK_WITH_ID_IS_NOT_READY,\n-                      taskSummary.getTaskId(),\n-                      taskSummary.getTaskState())));\n-        } else { // due to unknown reason\n-          bulkLog.addError(\n-              taskSummary.getTaskId(),\n-              new UpdateFailedException(\n-                  String.format(\"Could not set owner of Task %s .\", taskSummary.getTaskId())));\n-        }\n-      }\n-    }\n-    return bulkLog;\n-  }\n-\n   private Task claim(String taskId, boolean forceClaim)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException {\n     String userId = CurrentUserContext.getUserid();\n     LOGGER.debug(\n         \"entry to claim(id = {}, userId = {}, forceClaim = {})\", taskId, userId, forceClaim);\n-    TaskImpl task;\n+    TaskImpl task = null;\n     try {\n       taskanaEngine.openConnection();\n       task = (TaskImpl) getTask(taskId);\n       TaskState state = task.getState();\n-      if (!state.isInStates(TaskState.READY, TaskState.CLAIMED)) {\n-        throw new InvalidStateException(\n-            String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n+      if (state == TaskState.COMPLETED) {\n+        throw new InvalidStateException(TASK_WITH_ID + taskId + IS_ALREADY_COMPLETED);\n       }\n       if (state == TaskState.CLAIMED && !forceClaim && !task.getOwner().equals(userId)) {\n         throw new InvalidOwnerException(\n-            String.format(TASK_WITH_ID_IS_ALREADY_CLAIMED_BY, taskId, task.getOwner()));\n+            TASK_WITH_ID + taskId + IS_ALREADY_CLAIMED_BY + task.getOwner() + \".\");\n       }\n       Instant now = Instant.now();\n       task.setOwner(userId);\n", "next_change": {"commit": "2ce7f86456f99d522e001080e9504ae4cd6a80f4", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex e4e8b398d..382c3861a 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -755,23 +963,88 @@ public class TaskServiceImpl implements TaskService {\n     return result;\n   }\n \n+  private TaskImpl checkConcurrencyAndSetModified(TaskImpl newTaskImpl, TaskImpl oldTaskImpl)\n+      throws ConcurrencyException {\n+    // TODO: not safe to rely only on different timestamps.\n+    // With fast execution below 1ms there will be no concurrencyException\n+    if (oldTaskImpl.getModified() != null\n+            && !oldTaskImpl.getModified().equals(newTaskImpl.getModified())\n+        || oldTaskImpl.getClaimed() != null\n+            && !oldTaskImpl.getClaimed().equals(newTaskImpl.getClaimed())\n+        || oldTaskImpl.getState() != null\n+            && !oldTaskImpl.getState().equals(newTaskImpl.getState())) {\n+      throw new ConcurrencyException(\"The task has already been updated by another user\");\n+    }\n+    newTaskImpl.setModified(Instant.now());\n+    return newTaskImpl;\n+  }\n+\n+  private TaskImpl terminateCancelCommonActions(String taskId, TaskState targetState)\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n+    if (taskId == null || taskId.isEmpty()) {\n+      throw new TaskNotFoundException(taskId, String.format(TASK_WITH_ID_WAS_NOT_FOUND, taskId));\n+    }\n+    TaskImpl task = (TaskImpl) getTask(taskId);\n+    TaskState state = task.getState();\n+    if (state.isEndState()) {\n+      throw new InvalidStateException(String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n+    }\n+\n+    Instant now = Instant.now();\n+    task.setOwner(null);\n+    task.setModified(now);\n+    task.setCompleted(now);\n+    task.setClaimed(null);\n+    task.setRead(true);\n+    task.setState(targetState);\n+    taskMapper.update(task);\n+    LOGGER.debug(\"Task '{}' cancelled by user '{}'.\", taskId, CurrentUserContext.getUserid());\n+    return task;\n+  }\n+\n+  private BulkOperationResults<String, TaskanaException> addExceptionsForTasksWhoseOwnerWasNotSet(\n+      String owner, List<MinimalTaskSummary> existingMinimalTaskSummaries) {\n+    BulkOperationResults<String, TaskanaException> bulkLog = new BulkOperationResults<>();\n+\n+    for (MinimalTaskSummary taskSummary : existingMinimalTaskSummaries) {\n+      if (!owner.equals(taskSummary.getOwner())) { // owner was not set\n+        if (!TaskState.READY.equals(taskSummary.getTaskState())) { // due to invalid state\n+          bulkLog.addError(\n+              taskSummary.getTaskId(),\n+              new InvalidStateException(\n+                  String.format(\n+                      TASK_WITH_ID_IS_NOT_READY,\n+                      taskSummary.getTaskId(),\n+                      taskSummary.getTaskState())));\n+        } else { // due to unknown reason\n+          bulkLog.addError(\n+              taskSummary.getTaskId(),\n+              new UpdateFailedException(\n+                  String.format(\"Could not set owner of Task %s .\", taskSummary.getTaskId())));\n+        }\n+      }\n+    }\n+    return bulkLog;\n+  }\n+\n   private Task claim(String taskId, boolean forceClaim)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException {\n     String userId = CurrentUserContext.getUserid();\n     LOGGER.debug(\n         \"entry to claim(id = {}, userId = {}, forceClaim = {})\", taskId, userId, forceClaim);\n-    TaskImpl task = null;\n+    TaskImpl task;\n     try {\n       taskanaEngine.openConnection();\n       task = (TaskImpl) getTask(taskId);\n       TaskState state = task.getState();\n-      if (state == TaskState.COMPLETED) {\n-        throw new InvalidStateException(TASK_WITH_ID + taskId + IS_ALREADY_COMPLETED);\n+      if (!state.isInStates(TaskState.READY, TaskState.CLAIMED)) {\n+        throw new InvalidStateException(\n+            String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n       }\n       if (state == TaskState.CLAIMED && !forceClaim && !task.getOwner().equals(userId)) {\n         throw new InvalidOwnerException(\n-            TASK_WITH_ID + taskId + IS_ALREADY_CLAIMED_BY + task.getOwner() + \".\");\n+            String.format(TASK_WITH_ID_IS_ALREADY_CLAIMED_BY, taskId, task.getOwner()));\n       }\n       Instant now = Instant.now();\n       task.setOwner(userId);\n", "next_change": {"commit": "6f12677b74a36ec04e282def79e8b549d48c1988", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 382c3861a..5285ea062 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1037,21 +1182,10 @@ public class TaskServiceImpl implements TaskService {\n     try {\n       taskanaEngine.openConnection();\n       task = (TaskImpl) getTask(taskId);\n-      TaskState state = task.getState();\n-      if (!state.isInStates(TaskState.READY, TaskState.CLAIMED)) {\n-        throw new InvalidStateException(\n-            String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n-      }\n-      if (state == TaskState.CLAIMED && !forceClaim && !task.getOwner().equals(userId)) {\n-        throw new InvalidOwnerException(\n-            String.format(TASK_WITH_ID_IS_ALREADY_CLAIMED_BY, taskId, task.getOwner()));\n-      }\n       Instant now = Instant.now();\n-      task.setOwner(userId);\n-      task.setModified(now);\n-      task.setClaimed(now);\n-      task.setRead(true);\n-      task.setState(TaskState.CLAIMED);\n+\n+      checkPreconditionsForClaimTask(task, forceClaim);\n+      claimActionsOnTask(task, userId, now);\n       taskMapper.update(task);\n       LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n       if (HistoryEventProducer.isHistoryEnabled()) {\n", "next_change": {"commit": "d8ad7a7fb96e7d07e5f93e202cd84e03e5c1944a", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 5285ea062..f6299c27e 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1188,8 +1217,12 @@ public class TaskServiceImpl implements TaskService {\n       claimActionsOnTask(task, userId, now);\n       taskMapper.update(task);\n       LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n-      if (HistoryEventProducer.isHistoryEnabled()) {\n-        historyEventProducer.createEvent(new ClaimedEvent(task, CurrentUserContext.getUserid()));\n+      if (HistoryEventManager.isHistoryEnabled()) {\n+        historyEventManager.createEvent(\n+            new ClaimedEvent(\n+                IdGenerator.generateWithPrefix(ID_PREFIX_HISTORY_EVENT),\n+                task,\n+                CurrentUserContext.getUserid()));\n       }\n     } finally {\n       taskanaEngine.returnConnection();\n", "next_change": {"commit": "29ba5fe418ad6702648d7427d5c18b3fd06bbe83", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex f6299c27e..e11e382dc 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1219,7 +1186,7 @@ public class TaskServiceImpl implements TaskService {\n       LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n       if (HistoryEventManager.isHistoryEnabled()) {\n         historyEventManager.createEvent(\n-            new ClaimedEvent(\n+            new TaskClaimedEvent(\n                 IdGenerator.generateWithPrefix(ID_PREFIX_HISTORY_EVENT),\n                 task,\n                 CurrentUserContext.getUserid()));\n", "next_change": {"commit": "44cb21b5aec13e6548a0546dc8eb221fb1cd29ad", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex e11e382dc..5504cb522 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1189,7 +1200,7 @@ public class TaskServiceImpl implements TaskService {\n             new TaskClaimedEvent(\n                 IdGenerator.generateWithPrefix(ID_PREFIX_HISTORY_EVENT),\n                 task,\n-                CurrentUserContext.getUserid()));\n+                taskanaEngine.getEngine().getCurrentUserContext().getUserid()));\n       }\n     } finally {\n       taskanaEngine.returnConnection();\n", "next_change": {"commit": "b23c6873db22e24a0b713441317fec405db55708", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 5504cb522..fd50b0ae2 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1198,7 +1181,7 @@ public class TaskServiceImpl implements TaskService {\n       if (HistoryEventManager.isHistoryEnabled()) {\n         historyEventManager.createEvent(\n             new TaskClaimedEvent(\n-                IdGenerator.generateWithPrefix(ID_PREFIX_HISTORY_EVENT),\n+                IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n                 task,\n                 taskanaEngine.getEngine().getCurrentUserContext().getUserid()));\n       }\n", "next_change": {"commit": "bfcabea61048ccb21a591e0c4f1f8efecc7636b4", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex fd50b0ae2..ad45e047c 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1177,7 +1143,9 @@ public class TaskServiceImpl implements TaskService {\n       checkPreconditionsForClaimTask(task, forceClaim);\n       claimActionsOnTask(task, userId, now);\n       taskMapper.update(task);\n-      LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n+      if (LOGGER.isDebugEnabled()) {\n+        LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n+      }\n       if (HistoryEventManager.isHistoryEnabled()) {\n         historyEventManager.createEvent(\n             new TaskClaimedEvent(\n", "next_change": {"commit": "fb4234b6f180423c4789ba904709fd78edf7bf4f", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex ad45e047c..adc9804fa 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1146,7 +1115,7 @@ public class TaskServiceImpl implements TaskService {\n       if (LOGGER.isDebugEnabled()) {\n         LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n       }\n-      if (HistoryEventManager.isHistoryEnabled()) {\n+      if (historyEventManager.isEnabled()) {\n         historyEventManager.createEvent(\n             new TaskClaimedEvent(\n                 IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n", "next_change": {"commit": "43ed441daf60d22a579d93fde840861770b4ede5", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex adc9804fa..96da61dd7 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1116,11 +1175,15 @@ public class TaskServiceImpl implements TaskService {\n         LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n       }\n       if (historyEventManager.isEnabled()) {\n+        String changeDetails =\n+            ObjectAttributeChangeDetector.determineChangesInAttributes(oldTask, task);\n+\n         historyEventManager.createEvent(\n             new TaskClaimedEvent(\n                 IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n                 task,\n-                taskanaEngine.getEngine().getCurrentUserContext().getUserid()));\n+                taskanaEngine.getEngine().getCurrentUserContext().getUserid(),\n+                changeDetails));\n       }\n     } finally {\n       taskanaEngine.returnConnection();\n", "next_change": {"commit": "ef875dd42a58b55bace25fb4f599d84e4d06b59b", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 96da61dd7..0b2c71e16 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1191,12 +1204,63 @@ public class TaskServiceImpl implements TaskService {\n     return task;\n   }\n \n+  private Task requestReview(String taskId, boolean force)\n+      throws TaskNotFoundException, NotAuthorizedException, InvalidTaskStateException,\n+          InvalidOwnerException {\n+    String userId = taskanaEngine.getEngine().getCurrentUserContext().getUserid();\n+    TaskImpl task;\n+    try {\n+      taskanaEngine.openConnection();\n+      task = (TaskImpl) getTask(taskId);\n+\n+      TaskImpl oldTask = duplicateTaskExactly(task);\n+\n+      if (force && task.getState().isEndState()) {\n+        throw new InvalidTaskStateException(\n+            task.getId(), task.getState(), EnumUtil.allValuesExceptFor(TaskState.END_STATES));\n+      }\n+      if (!force && task.getState() != TaskState.CLAIMED) {\n+        throw new InvalidTaskStateException(task.getId(), task.getState(), TaskState.CLAIMED);\n+      }\n+      if (!force && !task.getOwner().equals(userId)) {\n+        throw new InvalidOwnerException(userId, task.getId());\n+      }\n+\n+      task.setState(TaskState.READY_FOR_REVIEW);\n+      task.setOwner(null);\n+      task.setModified(Instant.now());\n+\n+      taskMapper.update(task);\n+      if (LOGGER.isDebugEnabled()) {\n+        LOGGER.debug(\"Requested review for Task '{}' by user '{}'.\", taskId, userId);\n+      }\n+      if (historyEventManager.isEnabled()) {\n+        String changeDetails =\n+            ObjectAttributeChangeDetector.determineChangesInAttributes(oldTask, task);\n+\n+        historyEventManager.createEvent(\n+            new TaskRequestReviewEvent(\n+                IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n+                task,\n+                taskanaEngine.getEngine().getCurrentUserContext().getUserid(),\n+                changeDetails));\n+      }\n+    } finally {\n+      taskanaEngine.returnConnection();\n+    }\n+    return task;\n+  }\n+\n   private static void claimActionsOnTask(TaskSummaryImpl task, String userId, Instant now) {\n     task.setOwner(userId);\n     task.setModified(now);\n     task.setClaimed(now);\n     task.setRead(true);\n-    task.setState(TaskState.CLAIMED);\n+    if (Set.of(TaskState.READY_FOR_REVIEW, TaskState.IN_REVIEW).contains(task.getState())) {\n+      task.setState(TaskState.IN_REVIEW);\n+    } else {\n+      task.setState(TaskState.CLAIMED);\n+    }\n   }\n \n   private static void cancelClaimActionsOnTask(TaskSummaryImpl task, Instant now) {\n", "next_change": null}]}}]}}]}}, {"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex fd50b0ae2..ad45e047c 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1187,7 +1155,6 @@ public class TaskServiceImpl implements TaskService {\n       }\n     } finally {\n       taskanaEngine.returnConnection();\n-      LOGGER.debug(\"exit from claim()\");\n     }\n     return task;\n   }\n", "next_change": {"commit": "43ed441daf60d22a579d93fde840861770b4ede5", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex ad45e047c..96da61dd7 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1146,12 +1174,16 @@ public class TaskServiceImpl implements TaskService {\n       if (LOGGER.isDebugEnabled()) {\n         LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n       }\n-      if (HistoryEventManager.isHistoryEnabled()) {\n+      if (historyEventManager.isEnabled()) {\n+        String changeDetails =\n+            ObjectAttributeChangeDetector.determineChangesInAttributes(oldTask, task);\n+\n         historyEventManager.createEvent(\n             new TaskClaimedEvent(\n                 IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n                 task,\n-                taskanaEngine.getEngine().getCurrentUserContext().getUserid()));\n+                taskanaEngine.getEngine().getCurrentUserContext().getUserid(),\n+                changeDetails));\n       }\n     } finally {\n       taskanaEngine.returnConnection();\n", "next_change": {"commit": "ef875dd42a58b55bace25fb4f599d84e4d06b59b", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 96da61dd7..0b2c71e16 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1191,12 +1204,63 @@ public class TaskServiceImpl implements TaskService {\n     return task;\n   }\n \n+  private Task requestReview(String taskId, boolean force)\n+      throws TaskNotFoundException, NotAuthorizedException, InvalidTaskStateException,\n+          InvalidOwnerException {\n+    String userId = taskanaEngine.getEngine().getCurrentUserContext().getUserid();\n+    TaskImpl task;\n+    try {\n+      taskanaEngine.openConnection();\n+      task = (TaskImpl) getTask(taskId);\n+\n+      TaskImpl oldTask = duplicateTaskExactly(task);\n+\n+      if (force && task.getState().isEndState()) {\n+        throw new InvalidTaskStateException(\n+            task.getId(), task.getState(), EnumUtil.allValuesExceptFor(TaskState.END_STATES));\n+      }\n+      if (!force && task.getState() != TaskState.CLAIMED) {\n+        throw new InvalidTaskStateException(task.getId(), task.getState(), TaskState.CLAIMED);\n+      }\n+      if (!force && !task.getOwner().equals(userId)) {\n+        throw new InvalidOwnerException(userId, task.getId());\n+      }\n+\n+      task.setState(TaskState.READY_FOR_REVIEW);\n+      task.setOwner(null);\n+      task.setModified(Instant.now());\n+\n+      taskMapper.update(task);\n+      if (LOGGER.isDebugEnabled()) {\n+        LOGGER.debug(\"Requested review for Task '{}' by user '{}'.\", taskId, userId);\n+      }\n+      if (historyEventManager.isEnabled()) {\n+        String changeDetails =\n+            ObjectAttributeChangeDetector.determineChangesInAttributes(oldTask, task);\n+\n+        historyEventManager.createEvent(\n+            new TaskRequestReviewEvent(\n+                IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n+                task,\n+                taskanaEngine.getEngine().getCurrentUserContext().getUserid(),\n+                changeDetails));\n+      }\n+    } finally {\n+      taskanaEngine.returnConnection();\n+    }\n+    return task;\n+  }\n+\n   private static void claimActionsOnTask(TaskSummaryImpl task, String userId, Instant now) {\n     task.setOwner(userId);\n     task.setModified(now);\n     task.setClaimed(now);\n     task.setRead(true);\n-    task.setState(TaskState.CLAIMED);\n+    if (Set.of(TaskState.READY_FOR_REVIEW, TaskState.IN_REVIEW).contains(task.getState())) {\n+      task.setState(TaskState.IN_REVIEW);\n+    } else {\n+      task.setState(TaskState.CLAIMED);\n+    }\n   }\n \n   private static void cancelClaimActionsOnTask(TaskSummaryImpl task, Instant now) {\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1Nzc5Mw==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398657793", "body": "Why this. We don't know if the task has been read, do we?", "bodyText": "Why this. We don't know if the task has been read, do we?", "bodyHTML": "<p dir=\"auto\">Why this. We don't know if the task has been read, do we?</p>", "author": "holgerhagen", "createdAt": "2020-03-26T15:20:47Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java", "diffHunk": "@@ -951,6 +979,29 @@ private TaskImpl checkConcurrencyAndSetModified(TaskImpl newTaskImpl, TaskImpl o\n     return newTaskImpl;\n   }\n \n+  private TaskImpl terminateCancelCommonActions(String taskId, TaskState targetState)\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n+    if (taskId == null || taskId.isEmpty()) {\n+      throw new TaskNotFoundException(taskId, String.format(TASK_WITH_ID_WAS_NOT_FOUND, taskId));\n+    }\n+    TaskImpl task = (TaskImpl) getTask(taskId);\n+    TaskState state = task.getState();\n+    if (state.isEndState()) {\n+      throw new InvalidStateException(String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n+    }\n+\n+    Instant now = Instant.now();\n+    task.setOwner(null);\n+    task.setModified(now);\n+    task.setCompleted(now);\n+    task.setClaimed(null);\n+    task.setRead(true);", "originalCommit": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc0OTM3Mw==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398749373", "bodyText": "ok, retained also the read timestamp", "author": "BerndBreier", "createdAt": "2020-03-26T17:18:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1Nzc5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "3b13b9a95e4d7d1cf172f22fa0f2679ff1c5f79b", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 382c3861a..e4e8b398d 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -963,88 +755,23 @@ public class TaskServiceImpl implements TaskService {\n     return result;\n   }\n \n-  private TaskImpl checkConcurrencyAndSetModified(TaskImpl newTaskImpl, TaskImpl oldTaskImpl)\n-      throws ConcurrencyException {\n-    // TODO: not safe to rely only on different timestamps.\n-    // With fast execution below 1ms there will be no concurrencyException\n-    if (oldTaskImpl.getModified() != null\n-            && !oldTaskImpl.getModified().equals(newTaskImpl.getModified())\n-        || oldTaskImpl.getClaimed() != null\n-            && !oldTaskImpl.getClaimed().equals(newTaskImpl.getClaimed())\n-        || oldTaskImpl.getState() != null\n-            && !oldTaskImpl.getState().equals(newTaskImpl.getState())) {\n-      throw new ConcurrencyException(\"The task has already been updated by another user\");\n-    }\n-    newTaskImpl.setModified(Instant.now());\n-    return newTaskImpl;\n-  }\n-\n-  private TaskImpl terminateCancelCommonActions(String taskId, TaskState targetState)\n-      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n-    if (taskId == null || taskId.isEmpty()) {\n-      throw new TaskNotFoundException(taskId, String.format(TASK_WITH_ID_WAS_NOT_FOUND, taskId));\n-    }\n-    TaskImpl task = (TaskImpl) getTask(taskId);\n-    TaskState state = task.getState();\n-    if (state.isEndState()) {\n-      throw new InvalidStateException(String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n-    }\n-\n-    Instant now = Instant.now();\n-    task.setOwner(null);\n-    task.setModified(now);\n-    task.setCompleted(now);\n-    task.setClaimed(null);\n-    task.setRead(true);\n-    task.setState(targetState);\n-    taskMapper.update(task);\n-    LOGGER.debug(\"Task '{}' cancelled by user '{}'.\", taskId, CurrentUserContext.getUserid());\n-    return task;\n-  }\n-\n-  private BulkOperationResults<String, TaskanaException> addExceptionsForTasksWhoseOwnerWasNotSet(\n-      String owner, List<MinimalTaskSummary> existingMinimalTaskSummaries) {\n-    BulkOperationResults<String, TaskanaException> bulkLog = new BulkOperationResults<>();\n-\n-    for (MinimalTaskSummary taskSummary : existingMinimalTaskSummaries) {\n-      if (!owner.equals(taskSummary.getOwner())) { // owner was not set\n-        if (!TaskState.READY.equals(taskSummary.getTaskState())) { // due to invalid state\n-          bulkLog.addError(\n-              taskSummary.getTaskId(),\n-              new InvalidStateException(\n-                  String.format(\n-                      TASK_WITH_ID_IS_NOT_READY,\n-                      taskSummary.getTaskId(),\n-                      taskSummary.getTaskState())));\n-        } else { // due to unknown reason\n-          bulkLog.addError(\n-              taskSummary.getTaskId(),\n-              new UpdateFailedException(\n-                  String.format(\"Could not set owner of Task %s .\", taskSummary.getTaskId())));\n-        }\n-      }\n-    }\n-    return bulkLog;\n-  }\n-\n   private Task claim(String taskId, boolean forceClaim)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException {\n     String userId = CurrentUserContext.getUserid();\n     LOGGER.debug(\n         \"entry to claim(id = {}, userId = {}, forceClaim = {})\", taskId, userId, forceClaim);\n-    TaskImpl task;\n+    TaskImpl task = null;\n     try {\n       taskanaEngine.openConnection();\n       task = (TaskImpl) getTask(taskId);\n       TaskState state = task.getState();\n-      if (!state.isInStates(TaskState.READY, TaskState.CLAIMED)) {\n-        throw new InvalidStateException(\n-            String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n+      if (state == TaskState.COMPLETED) {\n+        throw new InvalidStateException(TASK_WITH_ID + taskId + IS_ALREADY_COMPLETED);\n       }\n       if (state == TaskState.CLAIMED && !forceClaim && !task.getOwner().equals(userId)) {\n         throw new InvalidOwnerException(\n-            String.format(TASK_WITH_ID_IS_ALREADY_CLAIMED_BY, taskId, task.getOwner()));\n+            TASK_WITH_ID + taskId + IS_ALREADY_CLAIMED_BY + task.getOwner() + \".\");\n       }\n       Instant now = Instant.now();\n       task.setOwner(userId);\n", "next_change": {"commit": "2ce7f86456f99d522e001080e9504ae4cd6a80f4", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex e4e8b398d..382c3861a 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -755,23 +963,88 @@ public class TaskServiceImpl implements TaskService {\n     return result;\n   }\n \n+  private TaskImpl checkConcurrencyAndSetModified(TaskImpl newTaskImpl, TaskImpl oldTaskImpl)\n+      throws ConcurrencyException {\n+    // TODO: not safe to rely only on different timestamps.\n+    // With fast execution below 1ms there will be no concurrencyException\n+    if (oldTaskImpl.getModified() != null\n+            && !oldTaskImpl.getModified().equals(newTaskImpl.getModified())\n+        || oldTaskImpl.getClaimed() != null\n+            && !oldTaskImpl.getClaimed().equals(newTaskImpl.getClaimed())\n+        || oldTaskImpl.getState() != null\n+            && !oldTaskImpl.getState().equals(newTaskImpl.getState())) {\n+      throw new ConcurrencyException(\"The task has already been updated by another user\");\n+    }\n+    newTaskImpl.setModified(Instant.now());\n+    return newTaskImpl;\n+  }\n+\n+  private TaskImpl terminateCancelCommonActions(String taskId, TaskState targetState)\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n+    if (taskId == null || taskId.isEmpty()) {\n+      throw new TaskNotFoundException(taskId, String.format(TASK_WITH_ID_WAS_NOT_FOUND, taskId));\n+    }\n+    TaskImpl task = (TaskImpl) getTask(taskId);\n+    TaskState state = task.getState();\n+    if (state.isEndState()) {\n+      throw new InvalidStateException(String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n+    }\n+\n+    Instant now = Instant.now();\n+    task.setOwner(null);\n+    task.setModified(now);\n+    task.setCompleted(now);\n+    task.setClaimed(null);\n+    task.setRead(true);\n+    task.setState(targetState);\n+    taskMapper.update(task);\n+    LOGGER.debug(\"Task '{}' cancelled by user '{}'.\", taskId, CurrentUserContext.getUserid());\n+    return task;\n+  }\n+\n+  private BulkOperationResults<String, TaskanaException> addExceptionsForTasksWhoseOwnerWasNotSet(\n+      String owner, List<MinimalTaskSummary> existingMinimalTaskSummaries) {\n+    BulkOperationResults<String, TaskanaException> bulkLog = new BulkOperationResults<>();\n+\n+    for (MinimalTaskSummary taskSummary : existingMinimalTaskSummaries) {\n+      if (!owner.equals(taskSummary.getOwner())) { // owner was not set\n+        if (!TaskState.READY.equals(taskSummary.getTaskState())) { // due to invalid state\n+          bulkLog.addError(\n+              taskSummary.getTaskId(),\n+              new InvalidStateException(\n+                  String.format(\n+                      TASK_WITH_ID_IS_NOT_READY,\n+                      taskSummary.getTaskId(),\n+                      taskSummary.getTaskState())));\n+        } else { // due to unknown reason\n+          bulkLog.addError(\n+              taskSummary.getTaskId(),\n+              new UpdateFailedException(\n+                  String.format(\"Could not set owner of Task %s .\", taskSummary.getTaskId())));\n+        }\n+      }\n+    }\n+    return bulkLog;\n+  }\n+\n   private Task claim(String taskId, boolean forceClaim)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException {\n     String userId = CurrentUserContext.getUserid();\n     LOGGER.debug(\n         \"entry to claim(id = {}, userId = {}, forceClaim = {})\", taskId, userId, forceClaim);\n-    TaskImpl task = null;\n+    TaskImpl task;\n     try {\n       taskanaEngine.openConnection();\n       task = (TaskImpl) getTask(taskId);\n       TaskState state = task.getState();\n-      if (state == TaskState.COMPLETED) {\n-        throw new InvalidStateException(TASK_WITH_ID + taskId + IS_ALREADY_COMPLETED);\n+      if (!state.isInStates(TaskState.READY, TaskState.CLAIMED)) {\n+        throw new InvalidStateException(\n+            String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n       }\n       if (state == TaskState.CLAIMED && !forceClaim && !task.getOwner().equals(userId)) {\n         throw new InvalidOwnerException(\n-            TASK_WITH_ID + taskId + IS_ALREADY_CLAIMED_BY + task.getOwner() + \".\");\n+            String.format(TASK_WITH_ID_IS_ALREADY_CLAIMED_BY, taskId, task.getOwner()));\n       }\n       Instant now = Instant.now();\n       task.setOwner(userId);\n", "next_change": {"commit": "6f12677b74a36ec04e282def79e8b549d48c1988", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 382c3861a..5285ea062 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1037,21 +1182,10 @@ public class TaskServiceImpl implements TaskService {\n     try {\n       taskanaEngine.openConnection();\n       task = (TaskImpl) getTask(taskId);\n-      TaskState state = task.getState();\n-      if (!state.isInStates(TaskState.READY, TaskState.CLAIMED)) {\n-        throw new InvalidStateException(\n-            String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n-      }\n-      if (state == TaskState.CLAIMED && !forceClaim && !task.getOwner().equals(userId)) {\n-        throw new InvalidOwnerException(\n-            String.format(TASK_WITH_ID_IS_ALREADY_CLAIMED_BY, taskId, task.getOwner()));\n-      }\n       Instant now = Instant.now();\n-      task.setOwner(userId);\n-      task.setModified(now);\n-      task.setClaimed(now);\n-      task.setRead(true);\n-      task.setState(TaskState.CLAIMED);\n+\n+      checkPreconditionsForClaimTask(task, forceClaim);\n+      claimActionsOnTask(task, userId, now);\n       taskMapper.update(task);\n       LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n       if (HistoryEventProducer.isHistoryEnabled()) {\n", "next_change": {"commit": "d8ad7a7fb96e7d07e5f93e202cd84e03e5c1944a", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 5285ea062..f6299c27e 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1188,8 +1217,12 @@ public class TaskServiceImpl implements TaskService {\n       claimActionsOnTask(task, userId, now);\n       taskMapper.update(task);\n       LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n-      if (HistoryEventProducer.isHistoryEnabled()) {\n-        historyEventProducer.createEvent(new ClaimedEvent(task, CurrentUserContext.getUserid()));\n+      if (HistoryEventManager.isHistoryEnabled()) {\n+        historyEventManager.createEvent(\n+            new ClaimedEvent(\n+                IdGenerator.generateWithPrefix(ID_PREFIX_HISTORY_EVENT),\n+                task,\n+                CurrentUserContext.getUserid()));\n       }\n     } finally {\n       taskanaEngine.returnConnection();\n", "next_change": {"commit": "29ba5fe418ad6702648d7427d5c18b3fd06bbe83", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex f6299c27e..e11e382dc 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1219,7 +1186,7 @@ public class TaskServiceImpl implements TaskService {\n       LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n       if (HistoryEventManager.isHistoryEnabled()) {\n         historyEventManager.createEvent(\n-            new ClaimedEvent(\n+            new TaskClaimedEvent(\n                 IdGenerator.generateWithPrefix(ID_PREFIX_HISTORY_EVENT),\n                 task,\n                 CurrentUserContext.getUserid()));\n", "next_change": {"commit": "44cb21b5aec13e6548a0546dc8eb221fb1cd29ad", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex e11e382dc..5504cb522 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1189,7 +1200,7 @@ public class TaskServiceImpl implements TaskService {\n             new TaskClaimedEvent(\n                 IdGenerator.generateWithPrefix(ID_PREFIX_HISTORY_EVENT),\n                 task,\n-                CurrentUserContext.getUserid()));\n+                taskanaEngine.getEngine().getCurrentUserContext().getUserid()));\n       }\n     } finally {\n       taskanaEngine.returnConnection();\n", "next_change": {"commit": "b23c6873db22e24a0b713441317fec405db55708", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 5504cb522..fd50b0ae2 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1198,7 +1181,7 @@ public class TaskServiceImpl implements TaskService {\n       if (HistoryEventManager.isHistoryEnabled()) {\n         historyEventManager.createEvent(\n             new TaskClaimedEvent(\n-                IdGenerator.generateWithPrefix(ID_PREFIX_HISTORY_EVENT),\n+                IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n                 task,\n                 taskanaEngine.getEngine().getCurrentUserContext().getUserid()));\n       }\n", "next_change": {"commit": "bfcabea61048ccb21a591e0c4f1f8efecc7636b4", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex fd50b0ae2..ad45e047c 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1177,7 +1143,9 @@ public class TaskServiceImpl implements TaskService {\n       checkPreconditionsForClaimTask(task, forceClaim);\n       claimActionsOnTask(task, userId, now);\n       taskMapper.update(task);\n-      LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n+      if (LOGGER.isDebugEnabled()) {\n+        LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n+      }\n       if (HistoryEventManager.isHistoryEnabled()) {\n         historyEventManager.createEvent(\n             new TaskClaimedEvent(\n", "next_change": {"commit": "fb4234b6f180423c4789ba904709fd78edf7bf4f", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex ad45e047c..adc9804fa 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1146,7 +1115,7 @@ public class TaskServiceImpl implements TaskService {\n       if (LOGGER.isDebugEnabled()) {\n         LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n       }\n-      if (HistoryEventManager.isHistoryEnabled()) {\n+      if (historyEventManager.isEnabled()) {\n         historyEventManager.createEvent(\n             new TaskClaimedEvent(\n                 IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n", "next_change": {"commit": "43ed441daf60d22a579d93fde840861770b4ede5", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex adc9804fa..96da61dd7 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1116,11 +1175,15 @@ public class TaskServiceImpl implements TaskService {\n         LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n       }\n       if (historyEventManager.isEnabled()) {\n+        String changeDetails =\n+            ObjectAttributeChangeDetector.determineChangesInAttributes(oldTask, task);\n+\n         historyEventManager.createEvent(\n             new TaskClaimedEvent(\n                 IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n                 task,\n-                taskanaEngine.getEngine().getCurrentUserContext().getUserid()));\n+                taskanaEngine.getEngine().getCurrentUserContext().getUserid(),\n+                changeDetails));\n       }\n     } finally {\n       taskanaEngine.returnConnection();\n", "next_change": {"commit": "ef875dd42a58b55bace25fb4f599d84e4d06b59b", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 96da61dd7..0b2c71e16 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1191,12 +1204,63 @@ public class TaskServiceImpl implements TaskService {\n     return task;\n   }\n \n+  private Task requestReview(String taskId, boolean force)\n+      throws TaskNotFoundException, NotAuthorizedException, InvalidTaskStateException,\n+          InvalidOwnerException {\n+    String userId = taskanaEngine.getEngine().getCurrentUserContext().getUserid();\n+    TaskImpl task;\n+    try {\n+      taskanaEngine.openConnection();\n+      task = (TaskImpl) getTask(taskId);\n+\n+      TaskImpl oldTask = duplicateTaskExactly(task);\n+\n+      if (force && task.getState().isEndState()) {\n+        throw new InvalidTaskStateException(\n+            task.getId(), task.getState(), EnumUtil.allValuesExceptFor(TaskState.END_STATES));\n+      }\n+      if (!force && task.getState() != TaskState.CLAIMED) {\n+        throw new InvalidTaskStateException(task.getId(), task.getState(), TaskState.CLAIMED);\n+      }\n+      if (!force && !task.getOwner().equals(userId)) {\n+        throw new InvalidOwnerException(userId, task.getId());\n+      }\n+\n+      task.setState(TaskState.READY_FOR_REVIEW);\n+      task.setOwner(null);\n+      task.setModified(Instant.now());\n+\n+      taskMapper.update(task);\n+      if (LOGGER.isDebugEnabled()) {\n+        LOGGER.debug(\"Requested review for Task '{}' by user '{}'.\", taskId, userId);\n+      }\n+      if (historyEventManager.isEnabled()) {\n+        String changeDetails =\n+            ObjectAttributeChangeDetector.determineChangesInAttributes(oldTask, task);\n+\n+        historyEventManager.createEvent(\n+            new TaskRequestReviewEvent(\n+                IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n+                task,\n+                taskanaEngine.getEngine().getCurrentUserContext().getUserid(),\n+                changeDetails));\n+      }\n+    } finally {\n+      taskanaEngine.returnConnection();\n+    }\n+    return task;\n+  }\n+\n   private static void claimActionsOnTask(TaskSummaryImpl task, String userId, Instant now) {\n     task.setOwner(userId);\n     task.setModified(now);\n     task.setClaimed(now);\n     task.setRead(true);\n-    task.setState(TaskState.CLAIMED);\n+    if (Set.of(TaskState.READY_FOR_REVIEW, TaskState.IN_REVIEW).contains(task.getState())) {\n+      task.setState(TaskState.IN_REVIEW);\n+    } else {\n+      task.setState(TaskState.CLAIMED);\n+    }\n   }\n \n   private static void cancelClaimActionsOnTask(TaskSummaryImpl task, Instant now) {\n", "next_change": null}]}}]}}]}}, {"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex fd50b0ae2..ad45e047c 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1187,7 +1155,6 @@ public class TaskServiceImpl implements TaskService {\n       }\n     } finally {\n       taskanaEngine.returnConnection();\n-      LOGGER.debug(\"exit from claim()\");\n     }\n     return task;\n   }\n", "next_change": {"commit": "43ed441daf60d22a579d93fde840861770b4ede5", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex ad45e047c..96da61dd7 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1146,12 +1174,16 @@ public class TaskServiceImpl implements TaskService {\n       if (LOGGER.isDebugEnabled()) {\n         LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n       }\n-      if (HistoryEventManager.isHistoryEnabled()) {\n+      if (historyEventManager.isEnabled()) {\n+        String changeDetails =\n+            ObjectAttributeChangeDetector.determineChangesInAttributes(oldTask, task);\n+\n         historyEventManager.createEvent(\n             new TaskClaimedEvent(\n                 IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n                 task,\n-                taskanaEngine.getEngine().getCurrentUserContext().getUserid()));\n+                taskanaEngine.getEngine().getCurrentUserContext().getUserid(),\n+                changeDetails));\n       }\n     } finally {\n       taskanaEngine.returnConnection();\n", "next_change": {"commit": "ef875dd42a58b55bace25fb4f599d84e4d06b59b", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 96da61dd7..0b2c71e16 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1191,12 +1204,63 @@ public class TaskServiceImpl implements TaskService {\n     return task;\n   }\n \n+  private Task requestReview(String taskId, boolean force)\n+      throws TaskNotFoundException, NotAuthorizedException, InvalidTaskStateException,\n+          InvalidOwnerException {\n+    String userId = taskanaEngine.getEngine().getCurrentUserContext().getUserid();\n+    TaskImpl task;\n+    try {\n+      taskanaEngine.openConnection();\n+      task = (TaskImpl) getTask(taskId);\n+\n+      TaskImpl oldTask = duplicateTaskExactly(task);\n+\n+      if (force && task.getState().isEndState()) {\n+        throw new InvalidTaskStateException(\n+            task.getId(), task.getState(), EnumUtil.allValuesExceptFor(TaskState.END_STATES));\n+      }\n+      if (!force && task.getState() != TaskState.CLAIMED) {\n+        throw new InvalidTaskStateException(task.getId(), task.getState(), TaskState.CLAIMED);\n+      }\n+      if (!force && !task.getOwner().equals(userId)) {\n+        throw new InvalidOwnerException(userId, task.getId());\n+      }\n+\n+      task.setState(TaskState.READY_FOR_REVIEW);\n+      task.setOwner(null);\n+      task.setModified(Instant.now());\n+\n+      taskMapper.update(task);\n+      if (LOGGER.isDebugEnabled()) {\n+        LOGGER.debug(\"Requested review for Task '{}' by user '{}'.\", taskId, userId);\n+      }\n+      if (historyEventManager.isEnabled()) {\n+        String changeDetails =\n+            ObjectAttributeChangeDetector.determineChangesInAttributes(oldTask, task);\n+\n+        historyEventManager.createEvent(\n+            new TaskRequestReviewEvent(\n+                IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n+                task,\n+                taskanaEngine.getEngine().getCurrentUserContext().getUserid(),\n+                changeDetails));\n+      }\n+    } finally {\n+      taskanaEngine.returnConnection();\n+    }\n+    return task;\n+  }\n+\n   private static void claimActionsOnTask(TaskSummaryImpl task, String userId, Instant now) {\n     task.setOwner(userId);\n     task.setModified(now);\n     task.setClaimed(now);\n     task.setRead(true);\n-    task.setState(TaskState.CLAIMED);\n+    if (Set.of(TaskState.READY_FOR_REVIEW, TaskState.IN_REVIEW).contains(task.getState())) {\n+      task.setState(TaskState.IN_REVIEW);\n+    } else {\n+      task.setState(TaskState.CLAIMED);\n+    }\n   }\n \n   private static void cancelClaimActionsOnTask(TaskSummaryImpl task, Instant now) {\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2MzMyMQ==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398663321", "body": "Maybe we should add an assertion isEqualTo(5) before cancelTask to make it more clear?", "bodyText": "Maybe we should add an assertion isEqualTo(5) before cancelTask to make it more clear?", "bodyHTML": "<p dir=\"auto\">Maybe we should add an assertion isEqualTo(5) before cancelTask to make it more clear?</p>", "author": "holgerhagen", "createdAt": "2020-03-26T15:27:45Z", "path": "lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package acceptance.task;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import acceptance.AbstractAccTest;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import pro.taskana.common.api.exceptions.NotAuthorizedException;\n+import pro.taskana.security.JaasExtension;\n+import pro.taskana.security.WithAccessId;\n+import pro.taskana.task.api.TaskService;\n+import pro.taskana.task.api.TaskState;\n+import pro.taskana.task.api.exceptions.InvalidStateException;\n+import pro.taskana.task.api.exceptions.TaskNotFoundException;\n+import pro.taskana.task.api.models.Task;\n+import pro.taskana.task.api.models.TaskSummary;\n+\n+\n+/** Acceptance tests for all claim and complete scenarios. */\n+@ExtendWith(JaasExtension.class)\n+class CancelTaskAccTest extends AbstractAccTest {\n+  private TaskService taskService;\n+\n+  CancelTaskAccTest() {\n+    super();\n+    taskService = taskanaEngine.getTaskService();\n+  }\n+\n+  @BeforeEach\n+  public static void setupTest() throws Exception {\n+    resetDb(false);\n+  }\n+\n+  @WithAccessId(\n+      userName = \"user_1_1\",\n+      groupNames = {\"group_1\"})\n+  @Test\n+  void testQeryCancelledTasks() {\n+    List<TaskSummary> taskSummaries =\n+        taskService.createTaskQuery().stateIn(TaskState.CANCELLED).list();\n+    assertThat(taskSummaries.size()).isEqualTo(5);\n+  }\n+\n+  @WithAccessId(\n+      userName = \"admin\",\n+      groupNames = {\"group_1\"})\n+  @Test\n+  void testCancelReadyTask()\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n+    List<TaskSummary> taskSummaries = taskService.createTaskQuery().stateIn(TaskState.READY).list();\n+    assertThat(taskSummaries.size()).isEqualTo(47);\n+    Task task = taskService.getTask(taskSummaries.get(0).getId());\n+    taskService.cancelTask(taskSummaries.get(0).getId());\n+    long numTasks = taskService.createTaskQuery().stateIn(TaskState.READY).count();\n+    assertThat(numTasks).isEqualTo(46);\n+    numTasks = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n+    assertThat(numTasks).isEqualTo(6);\n+  }\n+\n+  @WithAccessId(\n+      userName = \"admin\",\n+      groupNames = {\"group_1\"})\n+  @Test\n+  void testCancelClaimedTask()\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n+    List<TaskSummary> taskSummaries =\n+        taskService.createTaskQuery().stateIn(TaskState.CLAIMED).list();\n+    assertThat(taskSummaries.size()).isEqualTo(19);\n+    Task task = taskService.getTask(taskSummaries.get(0).getId());\n+    taskService.cancelTask(taskSummaries.get(0).getId());\n+    long numTasks = taskService.createTaskQuery().stateIn(TaskState.CLAIMED).count();\n+    assertThat(numTasks).isEqualTo(18);\n+    numTasks = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n+    assertThat(numTasks).isEqualTo(6);", "originalCommit": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc1NDgzNQ==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398754835", "bodyText": "Done", "author": "BerndBreier", "createdAt": "2020-03-26T17:25:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2MzMyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "d6505284f780ec7a804adf7d6156726e85ddd4ef", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex 0c9a90579..97d4bda87 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -62,20 +60,23 @@ class CancelTaskAccTest extends AbstractAccTest {\n   }\n \n   @WithAccessId(\n-      userName = \"admin\",\n+      userName = \"user_1_2\",\n       groupNames = {\"group_1\"})\n   @Test\n   void testCancelClaimedTask()\n       throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n     List<TaskSummary> taskSummaries =\n         taskService.createTaskQuery().stateIn(TaskState.CLAIMED).list();\n-    assertThat(taskSummaries.size()).isEqualTo(19);\n-    Task task = taskService.getTask(taskSummaries.get(0).getId());\n+    assertThat(taskSummaries.size()).isEqualTo(16);\n+\n+    long numTasksCancelled = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n+    assertThat(numTasksCancelled).isEqualTo(5);\n+\n     taskService.cancelTask(taskSummaries.get(0).getId());\n-    long numTasks = taskService.createTaskQuery().stateIn(TaskState.CLAIMED).count();\n-    assertThat(numTasks).isEqualTo(18);\n-    numTasks = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n-    assertThat(numTasks).isEqualTo(6);\n+    long numTasksClaimed = taskService.createTaskQuery().stateIn(TaskState.CLAIMED).count();\n+    assertThat(numTasksClaimed).isEqualTo(15);\n+    numTasksCancelled = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n+    assertThat(numTasksCancelled).isEqualTo(6);\n   }\n \n   @WithAccessId(\n", "next_change": {"commit": "2c5634c917e2246d56aff6472f7d7abc0a12a96b", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex 97d4bda87..cb1fdadce 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -83,16 +83,12 @@ class CancelTaskAccTest extends AbstractAccTest {\n       userName = \"admin\",\n       groupNames = {\"group_1\"})\n   @Test\n-  void testCancelCompletedTask()\n-      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n+  void testCancelCompletedTask() {\n     List<TaskSummary> taskSummaries =\n         taskService.createTaskQuery().stateIn(TaskState.COMPLETED).list();\n-    assertThat(taskSummaries.size()).isEqualTo(7);\n+    assertThat(taskSummaries).hasSize(7);\n \n-    ThrowingCallable taskanaCall =\n-        () -> {\n-          taskService.cancelTask(taskSummaries.get(0).getId());\n-        };\n+    ThrowingCallable taskanaCall = () -> taskService.cancelTask(taskSummaries.get(0).getId());\n \n     assertThatThrownBy(taskanaCall).isInstanceOf(InvalidStateException.class);\n   }\n", "next_change": {"commit": "ac5f04ff3bce8c8b933c0720ec2ca814f2a9fb17", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex cb1fdadce..631ad4817 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -93,9 +85,7 @@ class CancelTaskAccTest extends AbstractAccTest {\n     assertThatThrownBy(taskanaCall).isInstanceOf(InvalidStateException.class);\n   }\n \n-  @WithAccessId(\n-      userName = \"user_1_2\",\n-      groupNames = {\"group_1\"})\n+  @WithAccessId(user = \"user_1_2\", groups = \"group_1\")\n   @Test\n   void testCancelTerminatedTask() {\n     List<TaskSummary> taskSummaries =\n", "next_change": {"commit": "cc4efaa1cdd708366adea79d631b8aa5ccc013a8", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex 631ad4817..91e8d26d1 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -85,7 +103,7 @@ class CancelTaskAccTest extends AbstractAccTest {\n     assertThatThrownBy(taskanaCall).isInstanceOf(InvalidStateException.class);\n   }\n \n-  @WithAccessId(user = \"user_1_2\", groups = \"group_1\")\n+  @WithAccessId(user = \"user-1-2\", groups = \"group_1\")\n   @Test\n   void testCancelTerminatedTask() {\n     List<TaskSummary> taskSummaries =\n", "next_change": {"commit": "6952ce8959a8711f72c6319565edbee90a8b1cbd", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex 91e8d26d1..6c1fe7ff9 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -103,7 +103,7 @@ class CancelTaskAccTest extends AbstractAccTest {\n     assertThatThrownBy(taskanaCall).isInstanceOf(InvalidStateException.class);\n   }\n \n-  @WithAccessId(user = \"user-1-2\", groups = \"group_1\")\n+  @WithAccessId(user = \"user-1-2\", groups = \"group-1\")\n   @Test\n   void testCancelTerminatedTask() {\n     List<TaskSummary> taskSummaries =\n", "next_change": {"commit": "c57bbe07c7ca3ee56366c22de2375645a6371747", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex 6c1fe7ff9..a014e1dae 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -103,7 +101,7 @@ class CancelTaskAccTest extends AbstractAccTest {\n     assertThatThrownBy(taskanaCall).isInstanceOf(InvalidStateException.class);\n   }\n \n-  @WithAccessId(user = \"user-1-2\", groups = \"group-1\")\n+  @WithAccessId(user = \"user-1-2\")\n   @Test\n   void testCancelTerminatedTask() {\n     List<TaskSummary> taskSummaries =\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2NDU5OA==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398664598", "body": "Is it a good idea to do all these tests as admin?", "bodyText": "Is it a good idea to do all these tests as admin?", "bodyHTML": "<p dir=\"auto\">Is it a good idea to do all these tests as admin?</p>", "author": "holgerhagen", "createdAt": "2020-03-26T15:29:16Z", "path": "lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package acceptance.task;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import acceptance.AbstractAccTest;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import pro.taskana.common.api.exceptions.NotAuthorizedException;\n+import pro.taskana.security.JaasExtension;\n+import pro.taskana.security.WithAccessId;\n+import pro.taskana.task.api.TaskService;\n+import pro.taskana.task.api.TaskState;\n+import pro.taskana.task.api.exceptions.InvalidStateException;\n+import pro.taskana.task.api.exceptions.TaskNotFoundException;\n+import pro.taskana.task.api.models.Task;\n+import pro.taskana.task.api.models.TaskSummary;\n+\n+\n+/** Acceptance tests for all claim and complete scenarios. */\n+@ExtendWith(JaasExtension.class)\n+class CancelTaskAccTest extends AbstractAccTest {\n+  private TaskService taskService;\n+\n+  CancelTaskAccTest() {\n+    super();\n+    taskService = taskanaEngine.getTaskService();\n+  }\n+\n+  @BeforeEach\n+  public static void setupTest() throws Exception {\n+    resetDb(false);\n+  }\n+\n+  @WithAccessId(\n+      userName = \"user_1_1\",\n+      groupNames = {\"group_1\"})\n+  @Test\n+  void testQeryCancelledTasks() {\n+    List<TaskSummary> taskSummaries =\n+        taskService.createTaskQuery().stateIn(TaskState.CANCELLED).list();\n+    assertThat(taskSummaries.size()).isEqualTo(5);\n+  }\n+\n+  @WithAccessId(\n+      userName = \"admin\",", "originalCommit": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc2NjMwMQ==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398766301", "bodyText": "Changed it ...", "author": "BerndBreier", "createdAt": "2020-03-26T17:41:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2NDU5OA=="}], "type": "inlineReview", "revised_code": {"commit": "2c5634c917e2246d56aff6472f7d7abc0a12a96b", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex 0c9a90579..cb1fdadce 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -42,7 +41,7 @@ class CancelTaskAccTest extends AbstractAccTest {\n   void testQeryCancelledTasks() {\n     List<TaskSummary> taskSummaries =\n         taskService.createTaskQuery().stateIn(TaskState.CANCELLED).list();\n-    assertThat(taskSummaries.size()).isEqualTo(5);\n+    assertThat(taskSummaries).hasSize(5);\n   }\n \n   @WithAccessId(\n", "next_change": {"commit": "ac5f04ff3bce8c8b933c0720ec2ca814f2a9fb17", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex cb1fdadce..631ad4817 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -44,9 +42,7 @@ class CancelTaskAccTest extends AbstractAccTest {\n     assertThat(taskSummaries).hasSize(5);\n   }\n \n-  @WithAccessId(\n-      userName = \"admin\",\n-      groupNames = {\"group_1\"})\n+  @WithAccessId(user = \"admin\", groups = \"group_1\")\n   @Test\n   void testCancelReadyTask()\n       throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n", "next_change": {"commit": "6952ce8959a8711f72c6319565edbee90a8b1cbd", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex 631ad4817..6c1fe7ff9 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -42,7 +46,7 @@ class CancelTaskAccTest extends AbstractAccTest {\n     assertThat(taskSummaries).hasSize(5);\n   }\n \n-  @WithAccessId(user = \"admin\", groups = \"group_1\")\n+  @WithAccessId(user = \"admin\", groups = \"group-1\")\n   @Test\n   void testCancelReadyTask()\n       throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n", "next_change": {"commit": "c57bbe07c7ca3ee56366c22de2375645a6371747", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex 6c1fe7ff9..a014e1dae 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -46,7 +46,7 @@ class CancelTaskAccTest extends AbstractAccTest {\n     assertThat(taskSummaries).hasSize(5);\n   }\n \n-  @WithAccessId(user = \"admin\", groups = \"group-1\")\n+  @WithAccessId(user = \"admin\")\n   @Test\n   void testCancelReadyTask()\n       throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n", "next_change": {"commit": "ec483ab21cbe35f0e0ec608b109c47a3438abb48", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex a014e1dae..f2290a179 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -48,8 +45,7 @@ class CancelTaskAccTest extends AbstractAccTest {\n \n   @WithAccessId(user = \"admin\")\n   @Test\n-  void testCancelReadyTask()\n-      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n+  void testCancelReadyTask() throws Exception {\n     List<TaskSummary> taskSummaries = taskService.createTaskQuery().stateIn(TaskState.READY).list();\n     assertThat(taskSummaries).hasSize(47);\n     taskService.cancelTask(taskSummaries.get(0).getId());\n", "next_change": {"commit": "7636ec0b2a8e12ea5b3cff48f7b702472b603e5d", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex f2290a179..c8d5b5d50 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -47,10 +47,10 @@ class CancelTaskAccTest extends AbstractAccTest {\n   @Test\n   void testCancelReadyTask() throws Exception {\n     List<TaskSummary> taskSummaries = taskService.createTaskQuery().stateIn(TaskState.READY).list();\n-    assertThat(taskSummaries).hasSize(47);\n+    assertThat(taskSummaries).hasSize(48);\n     taskService.cancelTask(taskSummaries.get(0).getId());\n     long numTasks = taskService.createTaskQuery().stateIn(TaskState.READY).count();\n-    assertThat(numTasks).isEqualTo(46);\n+    assertThat(numTasks).isEqualTo(47);\n     numTasks = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n     assertThat(numTasks).isEqualTo(6);\n   }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2Njg1NQ==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398666855", "body": "Did we decide that everybody is allowed to cancel a claimed task? I wonder if it would be better to allow only the owner to cancel claimed tasks.", "bodyText": "Did we decide that everybody is allowed to cancel a claimed task? I wonder if it would be better to allow only the owner to cancel claimed tasks.", "bodyHTML": "<p dir=\"auto\">Did we decide that everybody is allowed to cancel a claimed task? I wonder if it would be better to allow only the owner to cancel claimed tasks.</p>", "author": "holgerhagen", "createdAt": "2020-03-26T15:32:00Z", "path": "lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package acceptance.task;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import acceptance.AbstractAccTest;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import pro.taskana.common.api.exceptions.NotAuthorizedException;\n+import pro.taskana.security.JaasExtension;\n+import pro.taskana.security.WithAccessId;\n+import pro.taskana.task.api.TaskService;\n+import pro.taskana.task.api.TaskState;\n+import pro.taskana.task.api.exceptions.InvalidStateException;\n+import pro.taskana.task.api.exceptions.TaskNotFoundException;\n+import pro.taskana.task.api.models.Task;\n+import pro.taskana.task.api.models.TaskSummary;\n+\n+\n+/** Acceptance tests for all claim and complete scenarios. */\n+@ExtendWith(JaasExtension.class)\n+class CancelTaskAccTest extends AbstractAccTest {\n+  private TaskService taskService;\n+\n+  CancelTaskAccTest() {\n+    super();\n+    taskService = taskanaEngine.getTaskService();\n+  }\n+\n+  @BeforeEach\n+  public static void setupTest() throws Exception {\n+    resetDb(false);\n+  }\n+\n+  @WithAccessId(\n+      userName = \"user_1_1\",\n+      groupNames = {\"group_1\"})\n+  @Test\n+  void testQeryCancelledTasks() {\n+    List<TaskSummary> taskSummaries =\n+        taskService.createTaskQuery().stateIn(TaskState.CANCELLED).list();\n+    assertThat(taskSummaries.size()).isEqualTo(5);\n+  }\n+\n+  @WithAccessId(\n+      userName = \"admin\",\n+      groupNames = {\"group_1\"})\n+  @Test\n+  void testCancelReadyTask()\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n+    List<TaskSummary> taskSummaries = taskService.createTaskQuery().stateIn(TaskState.READY).list();\n+    assertThat(taskSummaries.size()).isEqualTo(47);\n+    Task task = taskService.getTask(taskSummaries.get(0).getId());\n+    taskService.cancelTask(taskSummaries.get(0).getId());\n+    long numTasks = taskService.createTaskQuery().stateIn(TaskState.READY).count();\n+    assertThat(numTasks).isEqualTo(46);\n+    numTasks = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n+    assertThat(numTasks).isEqualTo(6);\n+  }\n+\n+  @WithAccessId(\n+      userName = \"admin\",", "originalCommit": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc2OTk5MA==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398769990", "bodyText": "The ticket says : \" terminateTask() and cancelTask bay be called by every user that is allowed to see the task \"\nI agree, that it is strange that everybody is allowed to cancel / terminate a task. On the other hand, if you think about the adapter scenario: if a task has been cancelled / terminated in camunda, the adapter should be able to cancel / terminate it in taskana. And this without being the owner. And probably also without having admin authority. So before I change anything with respect to this, we should carefully think about what is the correct solution ....", "author": "BerndBreier", "createdAt": "2020-03-26T17:46:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2Njg1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "d6505284f780ec7a804adf7d6156726e85ddd4ef", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex 0c9a90579..97d4bda87 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -62,20 +60,23 @@ class CancelTaskAccTest extends AbstractAccTest {\n   }\n \n   @WithAccessId(\n-      userName = \"admin\",\n+      userName = \"user_1_2\",\n       groupNames = {\"group_1\"})\n   @Test\n   void testCancelClaimedTask()\n       throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n     List<TaskSummary> taskSummaries =\n         taskService.createTaskQuery().stateIn(TaskState.CLAIMED).list();\n-    assertThat(taskSummaries.size()).isEqualTo(19);\n-    Task task = taskService.getTask(taskSummaries.get(0).getId());\n+    assertThat(taskSummaries.size()).isEqualTo(16);\n+\n+    long numTasksCancelled = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n+    assertThat(numTasksCancelled).isEqualTo(5);\n+\n     taskService.cancelTask(taskSummaries.get(0).getId());\n-    long numTasks = taskService.createTaskQuery().stateIn(TaskState.CLAIMED).count();\n-    assertThat(numTasks).isEqualTo(18);\n-    numTasks = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n-    assertThat(numTasks).isEqualTo(6);\n+    long numTasksClaimed = taskService.createTaskQuery().stateIn(TaskState.CLAIMED).count();\n+    assertThat(numTasksClaimed).isEqualTo(15);\n+    numTasksCancelled = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n+    assertThat(numTasksCancelled).isEqualTo(6);\n   }\n \n   @WithAccessId(\n", "next_change": {"commit": "2c5634c917e2246d56aff6472f7d7abc0a12a96b", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex 97d4bda87..cb1fdadce 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -83,16 +83,12 @@ class CancelTaskAccTest extends AbstractAccTest {\n       userName = \"admin\",\n       groupNames = {\"group_1\"})\n   @Test\n-  void testCancelCompletedTask()\n-      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n+  void testCancelCompletedTask() {\n     List<TaskSummary> taskSummaries =\n         taskService.createTaskQuery().stateIn(TaskState.COMPLETED).list();\n-    assertThat(taskSummaries.size()).isEqualTo(7);\n+    assertThat(taskSummaries).hasSize(7);\n \n-    ThrowingCallable taskanaCall =\n-        () -> {\n-          taskService.cancelTask(taskSummaries.get(0).getId());\n-        };\n+    ThrowingCallable taskanaCall = () -> taskService.cancelTask(taskSummaries.get(0).getId());\n \n     assertThatThrownBy(taskanaCall).isInstanceOf(InvalidStateException.class);\n   }\n", "next_change": {"commit": "ac5f04ff3bce8c8b933c0720ec2ca814f2a9fb17", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex cb1fdadce..631ad4817 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -93,9 +85,7 @@ class CancelTaskAccTest extends AbstractAccTest {\n     assertThatThrownBy(taskanaCall).isInstanceOf(InvalidStateException.class);\n   }\n \n-  @WithAccessId(\n-      userName = \"user_1_2\",\n-      groupNames = {\"group_1\"})\n+  @WithAccessId(user = \"user_1_2\", groups = \"group_1\")\n   @Test\n   void testCancelTerminatedTask() {\n     List<TaskSummary> taskSummaries =\n", "next_change": {"commit": "cc4efaa1cdd708366adea79d631b8aa5ccc013a8", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex 631ad4817..91e8d26d1 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -85,7 +103,7 @@ class CancelTaskAccTest extends AbstractAccTest {\n     assertThatThrownBy(taskanaCall).isInstanceOf(InvalidStateException.class);\n   }\n \n-  @WithAccessId(user = \"user_1_2\", groups = \"group_1\")\n+  @WithAccessId(user = \"user-1-2\", groups = \"group_1\")\n   @Test\n   void testCancelTerminatedTask() {\n     List<TaskSummary> taskSummaries =\n", "next_change": {"commit": "6952ce8959a8711f72c6319565edbee90a8b1cbd", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex 91e8d26d1..6c1fe7ff9 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -103,7 +103,7 @@ class CancelTaskAccTest extends AbstractAccTest {\n     assertThatThrownBy(taskanaCall).isInstanceOf(InvalidStateException.class);\n   }\n \n-  @WithAccessId(user = \"user-1-2\", groups = \"group_1\")\n+  @WithAccessId(user = \"user-1-2\", groups = \"group-1\")\n   @Test\n   void testCancelTerminatedTask() {\n     List<TaskSummary> taskSummaries =\n", "next_change": {"commit": "c57bbe07c7ca3ee56366c22de2375645a6371747", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex 6c1fe7ff9..a014e1dae 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -103,7 +101,7 @@ class CancelTaskAccTest extends AbstractAccTest {\n     assertThatThrownBy(taskanaCall).isInstanceOf(InvalidStateException.class);\n   }\n \n-  @WithAccessId(user = \"user-1-2\", groups = \"group-1\")\n+  @WithAccessId(user = \"user-1-2\")\n   @Test\n   void testCancelTerminatedTask() {\n     List<TaskSummary> taskSummaries =\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2ODA2Ng==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398668066", "body": "See comments on cancel task test.", "bodyText": "See comments on cancel task test.", "bodyHTML": "<p dir=\"auto\">See comments on cancel task test.</p>", "author": "holgerhagen", "createdAt": "2020-03-26T15:33:35Z", "path": "lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package acceptance.task;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import acceptance.AbstractAccTest;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import pro.taskana.common.api.exceptions.NotAuthorizedException;\n+import pro.taskana.security.JaasExtension;\n+import pro.taskana.security.WithAccessId;\n+import pro.taskana.task.api.TaskService;\n+import pro.taskana.task.api.TaskState;\n+import pro.taskana.task.api.exceptions.InvalidStateException;\n+import pro.taskana.task.api.exceptions.TaskNotFoundException;\n+import pro.taskana.task.api.models.Task;\n+import pro.taskana.task.api.models.TaskSummary;\n+\n+/** Acceptance tests for all claim and complete scenarios. */\n+@ExtendWith(JaasExtension.class)\n+class TerminateTaskAccTest extends AbstractAccTest {", "originalCommit": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc4MjcwMQ==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398782701", "bodyText": "done", "author": "BerndBreier", "createdAt": "2020-03-26T18:04:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2ODA2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "d6505284f780ec7a804adf7d6156726e85ddd4ef", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\nindex 50eca5337..f53402b4b 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n", "chunk": "@@ -16,7 +17,6 @@ import pro.taskana.task.api.TaskService;\n import pro.taskana.task.api.TaskState;\n import pro.taskana.task.api.exceptions.InvalidStateException;\n import pro.taskana.task.api.exceptions.TaskNotFoundException;\n-import pro.taskana.task.api.models.Task;\n import pro.taskana.task.api.models.TaskSummary;\n \n /** Acceptance tests for all claim and complete scenarios. */\n", "next_change": {"commit": "2c5634c917e2246d56aff6472f7d7abc0a12a96b", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\nindex f53402b4b..23ea6d76a 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n", "chunk": "@@ -22,10 +23,10 @@ import pro.taskana.task.api.models.TaskSummary;\n /** Acceptance tests for all claim and complete scenarios. */\n @ExtendWith(JaasExtension.class)\n class TerminateTaskAccTest extends AbstractAccTest {\n-  private TaskService taskService;\n+  private static TaskService taskService;\n \n-  TerminateTaskAccTest() {\n-    super();\n+  @BeforeAll\n+  static void setup() {\n     taskService = taskanaEngine.getTaskService();\n   }\n \n", "next_change": {"commit": "35705ddb02fddbade31cb2e1892040ecf8e5bbab", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\nindex 23ea6d76a..fbb980e3f 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n", "chunk": "@@ -25,16 +25,16 @@ import pro.taskana.task.api.models.TaskSummary;\n class TerminateTaskAccTest extends AbstractAccTest {\n   private static TaskService taskService;\n \n-  @BeforeAll\n-  static void setup() {\n-    taskService = taskanaEngine.getTaskService();\n-  }\n-\n   @BeforeEach\n   public void setupIndividualTest() throws Exception {\n     resetDb(false);\n   }\n \n+  @BeforeAll\n+  static void setup() {\n+    taskService = taskanaEngine.getTaskService();\n+  }\n+\n   @WithAccessId(\n       userName = \"user_1_1\",\n       groupNames = {\"group_1\"})\n", "next_change": {"commit": "ac5f04ff3bce8c8b933c0720ec2ca814f2a9fb17", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\nindex fbb980e3f..6ffd9afb1 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n", "chunk": "@@ -35,9 +35,7 @@ class TerminateTaskAccTest extends AbstractAccTest {\n     taskService = taskanaEngine.getTaskService();\n   }\n \n-  @WithAccessId(\n-      userName = \"user_1_1\",\n-      groupNames = {\"group_1\"})\n+  @WithAccessId(user = \"user_1_1\", groups = \"group_1\")\n   @Test\n   void testQueryTerminatedTasks() {\n     List<TaskSummary> taskSummaries =\n", "next_change": {"commit": "eb73c0670f522b6d1936b4323cf940640f504775", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\nindex 6ffd9afb1..03dbf0c13 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n", "chunk": "@@ -37,7 +37,7 @@ class TerminateTaskAccTest extends AbstractAccTest {\n \n   @WithAccessId(user = \"user_1_1\", groups = \"group_1\")\n   @Test\n-  void testQueryTerminatedTasks() {\n+  void should_ReturnAllTerminatedTasks_When_QueryTerminatedState() {\n     List<TaskSummary> taskSummaries =\n         taskService.createTaskQuery().stateIn(TaskState.TERMINATED).list();\n     assertThat(taskSummaries).hasSize(5);\n", "next_change": {"commit": "baf794518cbc494b85c190c05af97bd8b84ddb02", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\nindex 03dbf0c13..8621b73e3 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n", "chunk": "@@ -44,7 +45,8 @@ class TerminateTaskAccTest extends AbstractAccTest {\n   }\n \n   @WithAccessId(user = \"admin\", groups = \"group_1\")\n-  @Test\n+  @WithAccessId(user = \"taskadmin\")\n+  @TestTemplate\n   void should_TerminateTask_When_TaskStateIsReady()\n       throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n     List<TaskSummary> taskSummaries = taskService.createTaskQuery().stateIn(TaskState.READY).list();\n", "next_change": {"commit": "6952ce8959a8711f72c6319565edbee90a8b1cbd", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\nindex 8621b73e3..9e76083da 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n", "chunk": "@@ -44,7 +44,7 @@ class TerminateTaskAccTest extends AbstractAccTest {\n     assertThat(taskSummaries).hasSize(5);\n   }\n \n-  @WithAccessId(user = \"admin\", groups = \"group_1\")\n+  @WithAccessId(user = \"admin\", groups = \"group-1\")\n   @WithAccessId(user = \"taskadmin\")\n   @TestTemplate\n   void should_TerminateTask_When_TaskStateIsReady()\n", "next_change": {"commit": "c57bbe07c7ca3ee56366c22de2375645a6371747", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\nindex 9e76083da..e1ac7a25e 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n", "chunk": "@@ -44,7 +44,7 @@ class TerminateTaskAccTest extends AbstractAccTest {\n     assertThat(taskSummaries).hasSize(5);\n   }\n \n-  @WithAccessId(user = \"admin\", groups = \"group-1\")\n+  @WithAccessId(user = \"admin\")\n   @WithAccessId(user = \"taskadmin\")\n   @TestTemplate\n   void should_TerminateTask_When_TaskStateIsReady()\n", "next_change": {"commit": "ec483ab21cbe35f0e0ec608b109c47a3438abb48", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\nindex e1ac7a25e..704a1335a 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n", "chunk": "@@ -47,8 +46,7 @@ class TerminateTaskAccTest extends AbstractAccTest {\n   @WithAccessId(user = \"admin\")\n   @WithAccessId(user = \"taskadmin\")\n   @TestTemplate\n-  void should_TerminateTask_When_TaskStateIsReady()\n-      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n+  void should_TerminateTask_When_TaskStateIsReady() throws Exception {\n     List<TaskSummary> taskSummaries = taskService.createTaskQuery().stateIn(TaskState.READY).list();\n     assertThat(taskSummaries).hasSize(47);\n     taskService.terminateTask(taskSummaries.get(0).getId());\n", "next_change": {"commit": "7636ec0b2a8e12ea5b3cff48f7b702472b603e5d", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\nindex 704a1335a..f34c0a5db 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n", "chunk": "@@ -48,10 +48,10 @@ class TerminateTaskAccTest extends AbstractAccTest {\n   @TestTemplate\n   void should_TerminateTask_When_TaskStateIsReady() throws Exception {\n     List<TaskSummary> taskSummaries = taskService.createTaskQuery().stateIn(TaskState.READY).list();\n-    assertThat(taskSummaries).hasSize(47);\n+    assertThat(taskSummaries).hasSize(48);\n     taskService.terminateTask(taskSummaries.get(0).getId());\n     long numTasks = taskService.createTaskQuery().stateIn(TaskState.READY).count();\n-    assertThat(numTasks).isEqualTo(46);\n+    assertThat(numTasks).isEqualTo(47);\n     numTasks = taskService.createTaskQuery().stateIn(TaskState.TERMINATED).count();\n     assertThat(numTasks).isEqualTo(6);\n   }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"oid": "4c65a6087e83b85e44118a754cf749a23cac5250", "url": "https://github.com/Taskana/taskana/commit/4c65a6087e83b85e44118a754cf749a23cac5250", "message": "TSK-1160 - terminate/cancel task Holger's comments", "committedDate": "2020-03-26T18:22:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE2MTA2NA==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r399161064", "body": "Why don't we move this to the engine as well?", "bodyText": "Why don't we move this to the engine as well?", "bodyHTML": "<p dir=\"auto\">Why don't we move this to the engine as well?</p>", "author": "holgerhagen", "createdAt": "2020-03-27T10:15:24Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java", "diffHunk": "@@ -48,15 +46,7 @@\n     this.taskanaEngine = taskanaEngine;\n     this.taskMapper = taskMapper;\n     this.attachmentMapper = attachmentMapper;\n-    DaysToWorkingDaysConverter.setGermanPublicHolidaysEnabled(\n-        taskanaEngine.getEngine().getConfiguration().isGermanPublicHolidaysEnabled());\n-    try {\n-      converter = DaysToWorkingDaysConverter.initialize();\n-    } catch (InvalidArgumentException e) {\n-      LOGGER.error(ERROR_CANNOT_INITIALIZE_DAYS_TO_WORKING_DAYS_CONVERTER);\n-      throw new SystemException(\n-          ERROR_CANNOT_INITIALIZE_DAYS_TO_WORKING_DAYS_CONVERTER, e.getCause());\n-    }\n+    this.converter = WorkingDaysToDaysConverter.initialize();", "originalCommit": "4c65a6087e83b85e44118a754cf749a23cac5250", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMwNzYzOA==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r399307638", "bodyText": "The engine calls only WorkingDaysToDaysConverter.setGermanPublicHolidaysEnabled() which is a static method. The initialize() call is a factory method that creates an instance of WorkingDaysToDaysConverter.\nSince the WorkingDaysToDaysConverter is only needed inside ServiceLevelHandler, I made it an instance variable of this class.\nTo make things consistent, I'll also move the setGermanPublicHolidaysEnabled() call to the ctor of ServiceLevelHandler.", "author": "BerndBreier", "createdAt": "2020-03-27T14:32:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE2MTA2NA=="}], "type": "inlineReview", "revised_code": {"commit": "02a6df6f73622e86684c6c30d8f320c84078b237", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\nindex 83d237766..d6f999501 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n", "chunk": "@@ -33,41 +34,28 @@ import pro.taskana.task.internal.models.TaskImpl;\n class ServiceLevelHandler {\n \n   private static final Logger LOGGER = LoggerFactory.getLogger(ServiceLevelHandler.class);\n+  private static final String ERROR_CANNOT_INITIALIZE_DAYS_TO_WORKING_DAYS_CONVERTER =\n+      \"Internal error. Cannot initialize DaysToWorkingDaysConverter\";\n   private static final Duration MAX_DURATION = Duration.ofSeconds(Long.MAX_VALUE, 999_999_999);\n   private final InternalTaskanaEngine taskanaEngine;\n   private final TaskMapper taskMapper;\n   private final AttachmentMapper attachmentMapper;\n-  private WorkingDaysToDaysConverter converter;\n+  private DaysToWorkingDaysConverter converter;\n \n-  ServiceLevelHandler(\n+  public ServiceLevelHandler(\n       InternalTaskanaEngine taskanaEngine,\n       TaskMapper taskMapper,\n       AttachmentMapper attachmentMapper) {\n+    super();\n     this.taskanaEngine = taskanaEngine;\n     this.taskMapper = taskMapper;\n     this.attachmentMapper = attachmentMapper;\n-    this.converter = WorkingDaysToDaysConverter.initialize();\n-  }\n-\n-  // use the same algorithm as setPlannedPropertyOfTasksImpl to refresh\n-  // priority and duration of affected tasks, just don't use a fix\n-  // planned date but the individual planned date of the tasks\n-  public void refreshPriorityAndDueDatesOfTasks(\n-      List<MinimalTaskSummary> tasks, boolean serviceLevelChanged, boolean priorityChanged) {\n-\n-    List<AttachmentSummaryImpl> attachments = getAttachmentSummaries(tasks);\n-    List<ClassificationSummary> allInvolvedClassifications =\n-        findAllClassificationsReferencedByTasksAndAttachments(tasks, attachments);\n-\n-    if (serviceLevelChanged) {\n-      List<ClassificationWithServiceLevelResolved> allInvolvedClassificationsWithDuration =\n-          resolveDurationsInClassifications(allInvolvedClassifications);\n-\n-      updateTaskDueDatesOnClassificationUpdate(\n-          tasks, attachments, allInvolvedClassificationsWithDuration);\n-    }\n-    if (priorityChanged) {\n-      updateTaskPriorityOnClassificationUpdate(tasks, attachments, allInvolvedClassifications);\n+    try {\n+      this.converter = DaysToWorkingDaysConverter.initialize();\n+    } catch (InvalidArgumentException e) {\n+      LOGGER.error(ERROR_CANNOT_INITIALIZE_DAYS_TO_WORKING_DAYS_CONVERTER);\n+      throw new SystemException(\n+          ERROR_CANNOT_INITIALIZE_DAYS_TO_WORKING_DAYS_CONVERTER, e.getCause());\n     }\n   }\n \n", "next_change": {"commit": "fa429cef97db829102f746731f4dd966358c531e", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\nindex d6f999501..617e31aae 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n", "chunk": "@@ -59,6 +58,28 @@ class ServiceLevelHandler {\n     }\n   }\n \n+  // use the same algorithm as setPlannedPropertyOfTasksImpl to refresh\n+  // priority and duration of affected tasks, just don't use a fix\n+  // planned date but the individual planned date of the tasks\n+  public void refreshPriorityAndDueDatesOfTasks(\n+      List<MinimalTaskSummary> tasks, boolean serviceLevelChanged, boolean priorityChanged) {\n+\n+    List<AttachmentSummaryImpl> attachments = getAttachmentSummaries(tasks);\n+    List<ClassificationSummary> allInvolvedClassifications =\n+        findAllClassificationsReferencedByTasksAndAttachments(tasks, attachments);\n+\n+    if (serviceLevelChanged) {\n+      List<ClassificationWithServiceLevelResolved> allInvolvedClassificationsWithDuration =\n+          resolveDurationsInClassifications(allInvolvedClassifications);\n+\n+      updateTaskDueDatesOnClassificationUpdate(\n+          tasks, attachments, allInvolvedClassificationsWithDuration);\n+    }\n+    if (priorityChanged) {\n+      updateTaskPriorityOnClassificationUpdate(tasks, attachments, allInvolvedClassifications);\n+    }\n+  }\n+\n   // Algorithm:\n   // - load all relevant tasks and their attachmentSummaries\n   // - load all classifications referenced by these tasks / attachments\n", "next_change": {"commit": "f70d84579386fa560e6013485f276d0ebb19386a", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\nindex 617e31aae..f1c982557 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n", "chunk": "@@ -76,7 +70,10 @@ class ServiceLevelHandler {\n           tasks, attachments, allInvolvedClassificationsWithDuration);\n     }\n     if (priorityChanged) {\n-      updateTaskPriorityOnClassificationUpdate(tasks, attachments, allInvolvedClassifications);\n+      List<MinimalTaskSummary> tasksWithoutManualPriority =\n+          tasks.stream().filter(t -> !t.isManualPriorityActive()).collect(Collectors.toList());\n+      updateTaskPriorityOnClassificationUpdate(\n+          tasksWithoutManualPriority, attachments, allInvolvedClassifications);\n     }\n   }\n \n", "next_change": {"commit": "93d0b27bb058a4f47218177136bce81f99103345", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\nindex f1c982557..eb18ba692 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n", "chunk": "@@ -71,7 +72,9 @@ class ServiceLevelHandler {\n     }\n     if (priorityChanged) {\n       List<MinimalTaskSummary> tasksWithoutManualPriority =\n-          tasks.stream().filter(t -> !t.isManualPriorityActive()).collect(Collectors.toList());\n+          tasks.stream()\n+              .filter(not(MinimalTaskSummary::isManualPriorityActive))\n+              .collect(Collectors.toList());\n       updateTaskPriorityOnClassificationUpdate(\n           tasksWithoutManualPriority, attachments, allInvolvedClassifications);\n     }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE2MjAwOA==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r399162008", "body": "Sorry, haven't seen this one right away. As we don't reset the claimed timestamp, we shouldn't reset the owner as well.", "bodyText": "Sorry, haven't seen this one right away. As we don't reset the claimed timestamp, we shouldn't reset the owner as well.", "bodyHTML": "<p dir=\"auto\">Sorry, haven't seen this one right away. As we don't reset the claimed timestamp, we shouldn't reset the owner as well.</p>", "author": "holgerhagen", "createdAt": "2020-03-27T10:17:10Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java", "diffHunk": "@@ -951,6 +979,27 @@ private TaskImpl checkConcurrencyAndSetModified(TaskImpl newTaskImpl, TaskImpl o\n     return newTaskImpl;\n   }\n \n+  private TaskImpl terminateCancelCommonActions(String taskId, TaskState targetState)\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n+    if (taskId == null || taskId.isEmpty()) {\n+      throw new TaskNotFoundException(taskId, String.format(TASK_WITH_ID_WAS_NOT_FOUND, taskId));\n+    }\n+    TaskImpl task = (TaskImpl) getTask(taskId);\n+    TaskState state = task.getState();\n+    if (state.isEndState()) {\n+      throw new InvalidStateException(String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n+    }\n+\n+    Instant now = Instant.now();\n+    task.setOwner(null);", "originalCommit": "4c65a6087e83b85e44118a754cf749a23cac5250", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI5NTQxOA==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r399295418", "bodyText": "Done", "author": "BerndBreier", "createdAt": "2020-03-27T14:15:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE2MjAwOA=="}], "type": "inlineReview", "revised_code": {"commit": "3b13b9a95e4d7d1cf172f22fa0f2679ff1c5f79b", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 47a6735b9..e4e8b398d 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -963,86 +755,23 @@ public class TaskServiceImpl implements TaskService {\n     return result;\n   }\n \n-  private TaskImpl checkConcurrencyAndSetModified(TaskImpl newTaskImpl, TaskImpl oldTaskImpl)\n-      throws ConcurrencyException {\n-    // TODO: not safe to rely only on different timestamps.\n-    // With fast execution below 1ms there will be no concurrencyException\n-    if (oldTaskImpl.getModified() != null\n-            && !oldTaskImpl.getModified().equals(newTaskImpl.getModified())\n-        || oldTaskImpl.getClaimed() != null\n-            && !oldTaskImpl.getClaimed().equals(newTaskImpl.getClaimed())\n-        || oldTaskImpl.getState() != null\n-            && !oldTaskImpl.getState().equals(newTaskImpl.getState())) {\n-      throw new ConcurrencyException(\"The task has already been updated by another user\");\n-    }\n-    newTaskImpl.setModified(Instant.now());\n-    return newTaskImpl;\n-  }\n-\n-  private TaskImpl terminateCancelCommonActions(String taskId, TaskState targetState)\n-      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n-    if (taskId == null || taskId.isEmpty()) {\n-      throw new TaskNotFoundException(taskId, String.format(TASK_WITH_ID_WAS_NOT_FOUND, taskId));\n-    }\n-    TaskImpl task = (TaskImpl) getTask(taskId);\n-    TaskState state = task.getState();\n-    if (state.isEndState()) {\n-      throw new InvalidStateException(String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n-    }\n-\n-    Instant now = Instant.now();\n-    task.setOwner(null);\n-    task.setModified(now);\n-    task.setCompleted(now);\n-    task.setState(targetState);\n-    taskMapper.update(task);\n-    LOGGER.debug(\"Task '{}' cancelled by user '{}'.\", taskId, CurrentUserContext.getUserid());\n-    return task;\n-  }\n-\n-  private BulkOperationResults<String, TaskanaException> addExceptionsForTasksWhoseOwnerWasNotSet(\n-      String owner, List<MinimalTaskSummary> existingMinimalTaskSummaries) {\n-    BulkOperationResults<String, TaskanaException> bulkLog = new BulkOperationResults<>();\n-\n-    for (MinimalTaskSummary taskSummary : existingMinimalTaskSummaries) {\n-      if (!owner.equals(taskSummary.getOwner())) { // owner was not set\n-        if (!TaskState.READY.equals(taskSummary.getTaskState())) { // due to invalid state\n-          bulkLog.addError(\n-              taskSummary.getTaskId(),\n-              new InvalidStateException(\n-                  String.format(\n-                      TASK_WITH_ID_IS_NOT_READY,\n-                      taskSummary.getTaskId(),\n-                      taskSummary.getTaskState())));\n-        } else { // due to unknown reason\n-          bulkLog.addError(\n-              taskSummary.getTaskId(),\n-              new UpdateFailedException(\n-                  String.format(\"Could not set owner of Task %s .\", taskSummary.getTaskId())));\n-        }\n-      }\n-    }\n-    return bulkLog;\n-  }\n-\n   private Task claim(String taskId, boolean forceClaim)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException {\n     String userId = CurrentUserContext.getUserid();\n     LOGGER.debug(\n         \"entry to claim(id = {}, userId = {}, forceClaim = {})\", taskId, userId, forceClaim);\n-    TaskImpl task;\n+    TaskImpl task = null;\n     try {\n       taskanaEngine.openConnection();\n       task = (TaskImpl) getTask(taskId);\n       TaskState state = task.getState();\n-      if (!state.isInStates(TaskState.READY, TaskState.CLAIMED)) {\n-        throw new InvalidStateException(\n-            String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n+      if (state == TaskState.COMPLETED) {\n+        throw new InvalidStateException(TASK_WITH_ID + taskId + IS_ALREADY_COMPLETED);\n       }\n       if (state == TaskState.CLAIMED && !forceClaim && !task.getOwner().equals(userId)) {\n         throw new InvalidOwnerException(\n-            String.format(TASK_WITH_ID_IS_ALREADY_CLAIMED_BY, taskId, task.getOwner()));\n+            TASK_WITH_ID + taskId + IS_ALREADY_CLAIMED_BY + task.getOwner() + \".\");\n       }\n       Instant now = Instant.now();\n       task.setOwner(userId);\n", "next_change": {"commit": "2ce7f86456f99d522e001080e9504ae4cd6a80f4", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex e4e8b398d..382c3861a 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -755,23 +963,88 @@ public class TaskServiceImpl implements TaskService {\n     return result;\n   }\n \n+  private TaskImpl checkConcurrencyAndSetModified(TaskImpl newTaskImpl, TaskImpl oldTaskImpl)\n+      throws ConcurrencyException {\n+    // TODO: not safe to rely only on different timestamps.\n+    // With fast execution below 1ms there will be no concurrencyException\n+    if (oldTaskImpl.getModified() != null\n+            && !oldTaskImpl.getModified().equals(newTaskImpl.getModified())\n+        || oldTaskImpl.getClaimed() != null\n+            && !oldTaskImpl.getClaimed().equals(newTaskImpl.getClaimed())\n+        || oldTaskImpl.getState() != null\n+            && !oldTaskImpl.getState().equals(newTaskImpl.getState())) {\n+      throw new ConcurrencyException(\"The task has already been updated by another user\");\n+    }\n+    newTaskImpl.setModified(Instant.now());\n+    return newTaskImpl;\n+  }\n+\n+  private TaskImpl terminateCancelCommonActions(String taskId, TaskState targetState)\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n+    if (taskId == null || taskId.isEmpty()) {\n+      throw new TaskNotFoundException(taskId, String.format(TASK_WITH_ID_WAS_NOT_FOUND, taskId));\n+    }\n+    TaskImpl task = (TaskImpl) getTask(taskId);\n+    TaskState state = task.getState();\n+    if (state.isEndState()) {\n+      throw new InvalidStateException(String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n+    }\n+\n+    Instant now = Instant.now();\n+    task.setOwner(null);\n+    task.setModified(now);\n+    task.setCompleted(now);\n+    task.setClaimed(null);\n+    task.setRead(true);\n+    task.setState(targetState);\n+    taskMapper.update(task);\n+    LOGGER.debug(\"Task '{}' cancelled by user '{}'.\", taskId, CurrentUserContext.getUserid());\n+    return task;\n+  }\n+\n+  private BulkOperationResults<String, TaskanaException> addExceptionsForTasksWhoseOwnerWasNotSet(\n+      String owner, List<MinimalTaskSummary> existingMinimalTaskSummaries) {\n+    BulkOperationResults<String, TaskanaException> bulkLog = new BulkOperationResults<>();\n+\n+    for (MinimalTaskSummary taskSummary : existingMinimalTaskSummaries) {\n+      if (!owner.equals(taskSummary.getOwner())) { // owner was not set\n+        if (!TaskState.READY.equals(taskSummary.getTaskState())) { // due to invalid state\n+          bulkLog.addError(\n+              taskSummary.getTaskId(),\n+              new InvalidStateException(\n+                  String.format(\n+                      TASK_WITH_ID_IS_NOT_READY,\n+                      taskSummary.getTaskId(),\n+                      taskSummary.getTaskState())));\n+        } else { // due to unknown reason\n+          bulkLog.addError(\n+              taskSummary.getTaskId(),\n+              new UpdateFailedException(\n+                  String.format(\"Could not set owner of Task %s .\", taskSummary.getTaskId())));\n+        }\n+      }\n+    }\n+    return bulkLog;\n+  }\n+\n   private Task claim(String taskId, boolean forceClaim)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException {\n     String userId = CurrentUserContext.getUserid();\n     LOGGER.debug(\n         \"entry to claim(id = {}, userId = {}, forceClaim = {})\", taskId, userId, forceClaim);\n-    TaskImpl task = null;\n+    TaskImpl task;\n     try {\n       taskanaEngine.openConnection();\n       task = (TaskImpl) getTask(taskId);\n       TaskState state = task.getState();\n-      if (state == TaskState.COMPLETED) {\n-        throw new InvalidStateException(TASK_WITH_ID + taskId + IS_ALREADY_COMPLETED);\n+      if (!state.isInStates(TaskState.READY, TaskState.CLAIMED)) {\n+        throw new InvalidStateException(\n+            String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n       }\n       if (state == TaskState.CLAIMED && !forceClaim && !task.getOwner().equals(userId)) {\n         throw new InvalidOwnerException(\n-            TASK_WITH_ID + taskId + IS_ALREADY_CLAIMED_BY + task.getOwner() + \".\");\n+            String.format(TASK_WITH_ID_IS_ALREADY_CLAIMED_BY, taskId, task.getOwner()));\n       }\n       Instant now = Instant.now();\n       task.setOwner(userId);\n", "next_change": {"commit": "6f12677b74a36ec04e282def79e8b549d48c1988", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 382c3861a..5285ea062 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1037,21 +1182,10 @@ public class TaskServiceImpl implements TaskService {\n     try {\n       taskanaEngine.openConnection();\n       task = (TaskImpl) getTask(taskId);\n-      TaskState state = task.getState();\n-      if (!state.isInStates(TaskState.READY, TaskState.CLAIMED)) {\n-        throw new InvalidStateException(\n-            String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n-      }\n-      if (state == TaskState.CLAIMED && !forceClaim && !task.getOwner().equals(userId)) {\n-        throw new InvalidOwnerException(\n-            String.format(TASK_WITH_ID_IS_ALREADY_CLAIMED_BY, taskId, task.getOwner()));\n-      }\n       Instant now = Instant.now();\n-      task.setOwner(userId);\n-      task.setModified(now);\n-      task.setClaimed(now);\n-      task.setRead(true);\n-      task.setState(TaskState.CLAIMED);\n+\n+      checkPreconditionsForClaimTask(task, forceClaim);\n+      claimActionsOnTask(task, userId, now);\n       taskMapper.update(task);\n       LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n       if (HistoryEventProducer.isHistoryEnabled()) {\n", "next_change": {"commit": "d8ad7a7fb96e7d07e5f93e202cd84e03e5c1944a", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 5285ea062..f6299c27e 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1188,8 +1217,12 @@ public class TaskServiceImpl implements TaskService {\n       claimActionsOnTask(task, userId, now);\n       taskMapper.update(task);\n       LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n-      if (HistoryEventProducer.isHistoryEnabled()) {\n-        historyEventProducer.createEvent(new ClaimedEvent(task, CurrentUserContext.getUserid()));\n+      if (HistoryEventManager.isHistoryEnabled()) {\n+        historyEventManager.createEvent(\n+            new ClaimedEvent(\n+                IdGenerator.generateWithPrefix(ID_PREFIX_HISTORY_EVENT),\n+                task,\n+                CurrentUserContext.getUserid()));\n       }\n     } finally {\n       taskanaEngine.returnConnection();\n", "next_change": {"commit": "29ba5fe418ad6702648d7427d5c18b3fd06bbe83", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex f6299c27e..e11e382dc 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1219,7 +1186,7 @@ public class TaskServiceImpl implements TaskService {\n       LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n       if (HistoryEventManager.isHistoryEnabled()) {\n         historyEventManager.createEvent(\n-            new ClaimedEvent(\n+            new TaskClaimedEvent(\n                 IdGenerator.generateWithPrefix(ID_PREFIX_HISTORY_EVENT),\n                 task,\n                 CurrentUserContext.getUserid()));\n", "next_change": {"commit": "44cb21b5aec13e6548a0546dc8eb221fb1cd29ad", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex e11e382dc..5504cb522 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1189,7 +1200,7 @@ public class TaskServiceImpl implements TaskService {\n             new TaskClaimedEvent(\n                 IdGenerator.generateWithPrefix(ID_PREFIX_HISTORY_EVENT),\n                 task,\n-                CurrentUserContext.getUserid()));\n+                taskanaEngine.getEngine().getCurrentUserContext().getUserid()));\n       }\n     } finally {\n       taskanaEngine.returnConnection();\n", "next_change": {"commit": "b23c6873db22e24a0b713441317fec405db55708", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 5504cb522..fd50b0ae2 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1198,7 +1181,7 @@ public class TaskServiceImpl implements TaskService {\n       if (HistoryEventManager.isHistoryEnabled()) {\n         historyEventManager.createEvent(\n             new TaskClaimedEvent(\n-                IdGenerator.generateWithPrefix(ID_PREFIX_HISTORY_EVENT),\n+                IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n                 task,\n                 taskanaEngine.getEngine().getCurrentUserContext().getUserid()));\n       }\n", "next_change": {"commit": "bfcabea61048ccb21a591e0c4f1f8efecc7636b4", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex fd50b0ae2..ad45e047c 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1177,7 +1143,9 @@ public class TaskServiceImpl implements TaskService {\n       checkPreconditionsForClaimTask(task, forceClaim);\n       claimActionsOnTask(task, userId, now);\n       taskMapper.update(task);\n-      LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n+      if (LOGGER.isDebugEnabled()) {\n+        LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n+      }\n       if (HistoryEventManager.isHistoryEnabled()) {\n         historyEventManager.createEvent(\n             new TaskClaimedEvent(\n", "next_change": {"commit": "fb4234b6f180423c4789ba904709fd78edf7bf4f", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex ad45e047c..adc9804fa 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1146,7 +1115,7 @@ public class TaskServiceImpl implements TaskService {\n       if (LOGGER.isDebugEnabled()) {\n         LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n       }\n-      if (HistoryEventManager.isHistoryEnabled()) {\n+      if (historyEventManager.isEnabled()) {\n         historyEventManager.createEvent(\n             new TaskClaimedEvent(\n                 IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n", "next_change": {"commit": "43ed441daf60d22a579d93fde840861770b4ede5", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex adc9804fa..96da61dd7 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1116,11 +1175,15 @@ public class TaskServiceImpl implements TaskService {\n         LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n       }\n       if (historyEventManager.isEnabled()) {\n+        String changeDetails =\n+            ObjectAttributeChangeDetector.determineChangesInAttributes(oldTask, task);\n+\n         historyEventManager.createEvent(\n             new TaskClaimedEvent(\n                 IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n                 task,\n-                taskanaEngine.getEngine().getCurrentUserContext().getUserid()));\n+                taskanaEngine.getEngine().getCurrentUserContext().getUserid(),\n+                changeDetails));\n       }\n     } finally {\n       taskanaEngine.returnConnection();\n", "next_change": {"commit": "ef875dd42a58b55bace25fb4f599d84e4d06b59b", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 96da61dd7..0b2c71e16 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1191,12 +1204,63 @@ public class TaskServiceImpl implements TaskService {\n     return task;\n   }\n \n+  private Task requestReview(String taskId, boolean force)\n+      throws TaskNotFoundException, NotAuthorizedException, InvalidTaskStateException,\n+          InvalidOwnerException {\n+    String userId = taskanaEngine.getEngine().getCurrentUserContext().getUserid();\n+    TaskImpl task;\n+    try {\n+      taskanaEngine.openConnection();\n+      task = (TaskImpl) getTask(taskId);\n+\n+      TaskImpl oldTask = duplicateTaskExactly(task);\n+\n+      if (force && task.getState().isEndState()) {\n+        throw new InvalidTaskStateException(\n+            task.getId(), task.getState(), EnumUtil.allValuesExceptFor(TaskState.END_STATES));\n+      }\n+      if (!force && task.getState() != TaskState.CLAIMED) {\n+        throw new InvalidTaskStateException(task.getId(), task.getState(), TaskState.CLAIMED);\n+      }\n+      if (!force && !task.getOwner().equals(userId)) {\n+        throw new InvalidOwnerException(userId, task.getId());\n+      }\n+\n+      task.setState(TaskState.READY_FOR_REVIEW);\n+      task.setOwner(null);\n+      task.setModified(Instant.now());\n+\n+      taskMapper.update(task);\n+      if (LOGGER.isDebugEnabled()) {\n+        LOGGER.debug(\"Requested review for Task '{}' by user '{}'.\", taskId, userId);\n+      }\n+      if (historyEventManager.isEnabled()) {\n+        String changeDetails =\n+            ObjectAttributeChangeDetector.determineChangesInAttributes(oldTask, task);\n+\n+        historyEventManager.createEvent(\n+            new TaskRequestReviewEvent(\n+                IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n+                task,\n+                taskanaEngine.getEngine().getCurrentUserContext().getUserid(),\n+                changeDetails));\n+      }\n+    } finally {\n+      taskanaEngine.returnConnection();\n+    }\n+    return task;\n+  }\n+\n   private static void claimActionsOnTask(TaskSummaryImpl task, String userId, Instant now) {\n     task.setOwner(userId);\n     task.setModified(now);\n     task.setClaimed(now);\n     task.setRead(true);\n-    task.setState(TaskState.CLAIMED);\n+    if (Set.of(TaskState.READY_FOR_REVIEW, TaskState.IN_REVIEW).contains(task.getState())) {\n+      task.setState(TaskState.IN_REVIEW);\n+    } else {\n+      task.setState(TaskState.CLAIMED);\n+    }\n   }\n \n   private static void cancelClaimActionsOnTask(TaskSummaryImpl task, Instant now) {\n", "next_change": null}]}}]}}]}}, {"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex fd50b0ae2..ad45e047c 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1187,7 +1155,6 @@ public class TaskServiceImpl implements TaskService {\n       }\n     } finally {\n       taskanaEngine.returnConnection();\n-      LOGGER.debug(\"exit from claim()\");\n     }\n     return task;\n   }\n", "next_change": {"commit": "43ed441daf60d22a579d93fde840861770b4ede5", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex ad45e047c..96da61dd7 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1146,12 +1174,16 @@ public class TaskServiceImpl implements TaskService {\n       if (LOGGER.isDebugEnabled()) {\n         LOGGER.debug(\"Task '{}' claimed by user '{}'.\", taskId, userId);\n       }\n-      if (HistoryEventManager.isHistoryEnabled()) {\n+      if (historyEventManager.isEnabled()) {\n+        String changeDetails =\n+            ObjectAttributeChangeDetector.determineChangesInAttributes(oldTask, task);\n+\n         historyEventManager.createEvent(\n             new TaskClaimedEvent(\n                 IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n                 task,\n-                taskanaEngine.getEngine().getCurrentUserContext().getUserid()));\n+                taskanaEngine.getEngine().getCurrentUserContext().getUserid(),\n+                changeDetails));\n       }\n     } finally {\n       taskanaEngine.returnConnection();\n", "next_change": {"commit": "ef875dd42a58b55bace25fb4f599d84e4d06b59b", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 96da61dd7..0b2c71e16 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -1191,12 +1204,63 @@ public class TaskServiceImpl implements TaskService {\n     return task;\n   }\n \n+  private Task requestReview(String taskId, boolean force)\n+      throws TaskNotFoundException, NotAuthorizedException, InvalidTaskStateException,\n+          InvalidOwnerException {\n+    String userId = taskanaEngine.getEngine().getCurrentUserContext().getUserid();\n+    TaskImpl task;\n+    try {\n+      taskanaEngine.openConnection();\n+      task = (TaskImpl) getTask(taskId);\n+\n+      TaskImpl oldTask = duplicateTaskExactly(task);\n+\n+      if (force && task.getState().isEndState()) {\n+        throw new InvalidTaskStateException(\n+            task.getId(), task.getState(), EnumUtil.allValuesExceptFor(TaskState.END_STATES));\n+      }\n+      if (!force && task.getState() != TaskState.CLAIMED) {\n+        throw new InvalidTaskStateException(task.getId(), task.getState(), TaskState.CLAIMED);\n+      }\n+      if (!force && !task.getOwner().equals(userId)) {\n+        throw new InvalidOwnerException(userId, task.getId());\n+      }\n+\n+      task.setState(TaskState.READY_FOR_REVIEW);\n+      task.setOwner(null);\n+      task.setModified(Instant.now());\n+\n+      taskMapper.update(task);\n+      if (LOGGER.isDebugEnabled()) {\n+        LOGGER.debug(\"Requested review for Task '{}' by user '{}'.\", taskId, userId);\n+      }\n+      if (historyEventManager.isEnabled()) {\n+        String changeDetails =\n+            ObjectAttributeChangeDetector.determineChangesInAttributes(oldTask, task);\n+\n+        historyEventManager.createEvent(\n+            new TaskRequestReviewEvent(\n+                IdGenerator.generateWithPrefix(IdGenerator.ID_PREFIX_TASK_HISTORY_EVENT),\n+                task,\n+                taskanaEngine.getEngine().getCurrentUserContext().getUserid(),\n+                changeDetails));\n+      }\n+    } finally {\n+      taskanaEngine.returnConnection();\n+    }\n+    return task;\n+  }\n+\n   private static void claimActionsOnTask(TaskSummaryImpl task, String userId, Instant now) {\n     task.setOwner(userId);\n     task.setModified(now);\n     task.setClaimed(now);\n     task.setRead(true);\n-    task.setState(TaskState.CLAIMED);\n+    if (Set.of(TaskState.READY_FOR_REVIEW, TaskState.IN_REVIEW).contains(task.getState())) {\n+      task.setState(TaskState.IN_REVIEW);\n+    } else {\n+      task.setState(TaskState.CLAIMED);\n+    }\n   }\n \n   private static void cancelClaimActionsOnTask(TaskSummaryImpl task, Instant now) {\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"oid": "62d58b32c908be3bf05b5068497e4be5a20002e6", "url": "https://github.com/Taskana/taskana/commit/62d58b32c908be3bf05b5068497e4be5a20002e6", "message": "TSK-1160 - terminate/cancel task more comments from Holger", "committedDate": "2020-03-27T14:36:46Z", "type": "commit"}]}