{"pr_number": 1150, "pr_title": "TSK-1275: Support select and claim in one API call", "pr_author": "gitgoodjhe", "pr_createdAt": "2020-06-26T12:25:29Z", "pr_url": "https://github.com/Taskana/taskana/pull/1150", "merge_commit": "969d3eeff653d51eb7dcf5234aa4020333613ab3", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY0NDU4MQ==", "url": "https://github.com/Taskana/taskana/pull/1150#discussion_r446644581", "body": "Please rework the naming and clarify which taskId is meant. \r\ne.g. `@throws TaskNotFoundException if the taskQuery does not return any task`", "bodyText": "Please rework the naming and clarify which taskId is meant.\ne.g. @throws TaskNotFoundException if the taskQuery does not return any task", "bodyHTML": "<p dir=\"auto\">Please rework the naming and clarify which taskId is meant.<br>\ne.g. <code>@throws TaskNotFoundException if the taskQuery does not return any task</code></p>", "author": "mustaphazorgati", "createdAt": "2020-06-28T12:27:49Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java", "diffHunk": "@@ -325,6 +325,21 @@ void deleteTask(String taskId)\n   void forceDeleteTask(String taskId)\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n \n+  /**\n+   * Selects and claims the first task which is returned by the task query.\n+   *\n+   * @param taskQuery the task query.\n+   * @return the task that got selected and claimed\n+   * @throws TaskNotFoundException if the task with taskId was not found\n+   * @throws InvalidStateException if the state of the task with taskId is not READY\n+   * @throws InvalidOwnerException if the task with taskId is claimed by someone else\n+   * @throws NotAuthorizedException if the current user has no read permission for the\n+   *     workbasket the task is in", "originalCommit": "f1991ad4316cd8de239ba6cd0cc57caa70f1bddb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "808d5e604539f2f4e5e13e86b00c627a78e1b762", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 60090b74d..af39a662a 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -330,15 +330,11 @@ public interface TaskService {\n    *\n    * @param taskQuery the task query.\n    * @return the task that got selected and claimed\n-   * @throws TaskNotFoundException if the task with taskId was not found\n-   * @throws InvalidStateException if the state of the task with taskId is not READY\n-   * @throws InvalidOwnerException if the task with taskId is claimed by someone else\n-   * @throws NotAuthorizedException if the current user has no read permission for the\n-   *     workbasket the task is in\n+   * @throws InvalidOwnerException if the task is claimed by someone else\n+   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n+   *     the task is in\n    */\n-  Task selectAndClaim(TaskQuery taskQuery)\n-      throws TaskNotFoundException, NotAuthorizedException, InvalidStateException,\n-          InvalidOwnerException;\n+  Task selectAndClaim(TaskQuery taskQuery) throws NotAuthorizedException, InvalidOwnerException;\n \n   /**\n    * Deletes a list of tasks.\n", "next_change": null}]}, "revised_code_in_main": {"commit": "969d3eeff653d51eb7dcf5234aa4020333613ab3", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 60090b74d..af39a662a 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -330,15 +330,11 @@ public interface TaskService {\n    *\n    * @param taskQuery the task query.\n    * @return the task that got selected and claimed\n-   * @throws TaskNotFoundException if the task with taskId was not found\n-   * @throws InvalidStateException if the state of the task with taskId is not READY\n-   * @throws InvalidOwnerException if the task with taskId is claimed by someone else\n-   * @throws NotAuthorizedException if the current user has no read permission for the\n-   *     workbasket the task is in\n+   * @throws InvalidOwnerException if the task is claimed by someone else\n+   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n+   *     the task is in\n    */\n-  Task selectAndClaim(TaskQuery taskQuery)\n-      throws TaskNotFoundException, NotAuthorizedException, InvalidStateException,\n-          InvalidOwnerException;\n+  Task selectAndClaim(TaskQuery taskQuery) throws NotAuthorizedException, InvalidOwnerException;\n \n   /**\n    * Deletes a list of tasks.\n", "next_change": {"commit": "b4e1f9bc315eb701d0dec0e34c38651672239566", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex af39a662a..48bac1ed4 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -21,326 +24,471 @@ import pro.taskana.task.api.models.Attachment;\n import pro.taskana.task.api.models.ObjectReference;\n import pro.taskana.task.api.models.Task;\n import pro.taskana.task.api.models.TaskComment;\n+import pro.taskana.workbasket.api.WorkbasketPermission;\n import pro.taskana.workbasket.api.exceptions.WorkbasketNotFoundException;\n+import pro.taskana.workbasket.api.models.Workbasket;\n \n /** The Task Service manages all operations on tasks. */\n public interface TaskService {\n \n   /**\n-   * Claim an existing task for the current user.\n+   * Claim an existing {@linkplain Task} for the current user.\n    *\n-   * @param taskId the id of the task to be claimed\n-   * @return claimed Task\n-   * @throws TaskNotFoundException if the task with taskId was not found\n-   * @throws InvalidStateException if the state of the task with taskId is not READY\n-   * @throws InvalidOwnerException if the task with taskId is claimed by some else\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to be claimed\n+   * @return claimed {@linkplain Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} with taskId was not found\n+   * @throws InvalidStateException if the {@linkplain Task#getState() state} of the {@linkplain\n+   *     Task} with taskId is not {@linkplain TaskState#READY READY}\n+   * @throws InvalidOwnerException if the {@linkplain Task} with taskId is claimed by some else\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task claim(String taskId)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException;\n \n   /**\n-   * Claim an existing task for the current user even if it is already claimed by someone else.\n+   * Claim an existing {@linkplain Task} for the current user even if it is already claimed by\n+   * someone else.\n    *\n-   * @param taskId the id of the task to be claimed\n-   * @return claimed Task\n-   * @throws TaskNotFoundException if the task with taskId was not found\n-   * @throws InvalidStateException if the state of the task with taskId is not READY\n-   * @throws InvalidOwnerException if the task with taskId is claimed by someone else\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to be claimed\n+   * @return claimed {@linkplain Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} with taskId was not found\n+   * @throws InvalidStateException if the {@linkplain Task#getState() state} of the {@linkplain\n+   *     Task} with taskId is not READY\n+   * @throws InvalidOwnerException if the {@linkplain Task} with taskId is claimed by someone else\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task forceClaim(String taskId)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException;\n \n   /**\n-   * Cancel the claim of an existing task if it was claimed by the current user before.\n+   * Cancel the claim of an existing {@linkplain Task} if it was claimed by the current user before.\n    *\n-   * @param taskId id of the task which should be unclaimed.\n+   * @param taskId {@linkplain Task#getId() id} of the task which should be unclaimed.\n    * @return updated unclaimed task\n-   * @throws TaskNotFoundException if the task can\u00b4t be found or does not exist\n-   * @throws InvalidStateException when the task is already completed.\n-   * @throws InvalidOwnerException when the task is claimed by another user.\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @throws TaskNotFoundException if the {@linkplain Task} can't be found or does not exist\n+   * @throws InvalidStateException if the {@linkplain Task} is already in an end {@linkplain\n+   *     Task#getState() state}.\n+   * @throws InvalidOwnerException if the {@linkplain Task} is claimed by another user.\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the task is in\n    */\n   Task cancelClaim(String taskId)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException;\n \n   /**\n-   * Cancel the claim of an existing task even if it was claimed by another user.\n+   * Cancel the claim of an existing {@linkplain Task} even if it was claimed by another user.\n    *\n-   * @param taskId id of the task which should be unclaimed.\n-   * @return updated unclaimed task\n-   * @throws TaskNotFoundException if the task can\u00b4t be found or does not exist\n-   * @throws InvalidStateException when the task is already completed.\n-   * @throws InvalidOwnerException when forceCancel is false and the task is claimed by another\n-   *     user.\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @param taskId id of the {@linkplain Task} which should be unclaimed.\n+   * @return updated unclaimed {@linkplain Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} can't be found or does not exist\n+   * @throws InvalidStateException if the {@linkplain Task} is already in an end {@linkplain\n+   *     Task#getState() state}\n+   * @throws InvalidOwnerException if forceCancel is false and the {@linkplain Task} is claimed by\n+   *     another user.\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task forceCancelClaim(String taskId)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException;\n \n   /**\n-   * Complete a claimed Task as owner/admin and update State and Timestamps. If task is already\n-   * completed, the task is returned as itself.\n+   * Complete a claimed {@linkplain Task} as owner/admin and update {@linkplain Task#getState()\n+   * state} and Timestamps. If {@linkplain Task} is already completed, the {@linkplain Task} is\n+   * returned as itself.\n    *\n-   * @param taskId - Id of the Task which should be completed.\n-   * @return Task - updated task after completion.\n-   * @throws InvalidStateException when Task wasn\u00b4t claimed before.\n-   * @throws TaskNotFoundException if the given Task can\u00b4t be found in DB.\n+   * @param taskId - {@linkplain Task#getId() id} of the {@linkplain Task} which should be\n+   *     completed.\n+   * @return Task - updated {@linkplain Task} after completion.\n+   * @throws InvalidStateException if {@linkplain Task} wasn't claimed before.\n+   * @throws TaskNotFoundException if the given {@linkplain Task} can't be found in DB.\n    * @throws InvalidOwnerException if current user is not the task-owner or administrator.\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task completeTask(String taskId)\n       throws TaskNotFoundException, InvalidOwnerException, InvalidStateException,\n           NotAuthorizedException;\n \n   /**\n-   * Complete a Task and update State and Timestamps in every case if the Task exists. If task is\n-   * already completed, the task is returned as itself.\n+   * Completes a {@linkplain Task} and updates {@linkplain Task#getState() state} and Timestamps in\n+   * every case if the {@linkplain Task} exists. If {@linkplain Task} is already completed, the\n+   * {@linkplain Task} is returned as itself.\n    *\n-   * @param taskId - Id of the Task which should be completed.\n-   * @return Task - updated task after completion.\n-   * @throws InvalidStateException when Task wasn\u00b4t claimed before.\n-   * @throws TaskNotFoundException if the given Task can\u00b4t be found in DB.\n+   * @param taskId - {@linkplain Task#getId() id} of the {@linkplain Task} which should be\n+   *     completed.\n+   * @return Task - updated {@linkplain Task} after completion.\n+   * @throws InvalidStateException if {@linkplain Task} wasn't claimed before.\n+   * @throws TaskNotFoundException if the given {@linkplain Task} can't be found in DB.\n    * @throws InvalidOwnerException if current user is not the task-owner or administrator.\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task forceCompleteTask(String taskId)\n       throws TaskNotFoundException, InvalidOwnerException, InvalidStateException,\n           NotAuthorizedException;\n \n   /**\n-   * Persists a not persisted Task which does not exist already.\n-   *\n-   * @param taskToCreate the transient task object to be persisted\n-   * @return the created and persisted task\n-   * @throws TaskAlreadyExistException when the Task does already exist.\n-   * @throws NotAuthorizedException thrown if the current user is not authorized to create that task\n-   * @throws WorkbasketNotFoundException thrown if the work basket referenced by the task is not\n-   *     found\n-   * @throws ClassificationNotFoundException thrown if the {@link Classification} referenced by the\n-   *     task is not found\n+   * Inserts a not existing {@linkplain Task}. <br>\n+   * The default values of the created {@linkplain Task} are:\n+   *\n+   * <ul>\n+   *   <li><b>{@linkplain Task#getId() id}</b> - generated by {@linkplain IdGenerator}\n+   *   <li><b>{@linkplain Task#getExternalId() externalId}</b> - generated by IdGenerator\n+   *   <li><b>{@linkplain Task#getBusinessProcessId() businessProcessId}</b> - generated by\n+   *       IdGenerator\n+   *   <li><b>{@linkplain Task#getName() name}</b> - name of its Classification\n+   *   <li><b>{@linkplain Task#getDescription() description}</b> - description of its Classification\n+   *   <li><b>{@linkplain Task#getCreator() creator}</b> - id of current user\n+   *   <li><b>{@linkplain Task#getState() state}</b> - 'READY'\n+   *   <li><b>{@linkplain Task#isRead() isRead}</b> - {@code false}\n+   *   <li><b>{@linkplain Task#isTransferred() isTransferred}</b> - {@code false}\n+   * </ul>\n+   *\n+   * @param taskToCreate the transient {@linkplain Task} object to be inserted\n+   * @return the created and inserted {@linkplain Task}\n+   * @throws TaskAlreadyExistException if the {@linkplain Task} does already exist.\n+   * @throws NotAuthorizedException thrown if the current user is not authorized to create that\n+   *     {@linkplain Task}\n+   * @throws WorkbasketNotFoundException thrown if the workbasket referenced by the {@linkplain\n+   *     Task} is not found\n+   * @throws ClassificationNotFoundException thrown if the Classification referenced by the\n+   *     {@linkplain Task} is not found\n    * @throws InvalidArgumentException thrown if the primary ObjectReference is invalid\n+   * @throws AttachmentPersistenceException if an Attachment with ID will be added multiple times\n+   *     without using the task-methods\n+   * @throws ObjectReferencePersistenceException if an ObjectReference with ID will be added\n+   *     multiple times without using the task-methods\n    */\n   Task createTask(Task taskToCreate)\n       throws NotAuthorizedException, WorkbasketNotFoundException, ClassificationNotFoundException,\n-          TaskAlreadyExistException, InvalidArgumentException;\n+          TaskAlreadyExistException, InvalidArgumentException, AttachmentPersistenceException,\n+          ObjectReferencePersistenceException;\n \n   /**\n-   * Get the details of a task by Id without checking permissions.\n+   * Gets the details of a {@linkplain Task} by {@linkplain Task#getId() id} without checking\n+   * permissions.\n    *\n-   * @param taskId the id of the task\n-   * @return the Task\n-   * @throws TaskNotFoundException thrown of the {@link Task} with taskId is not found\n-   * @throws NotAuthorizedException if the current user has no READ permission for the workbasket\n-   *     the task is in.\n+   * @param taskId the {@linkplain Task#getId()} of the {@linkplain Task}\n+   * @return the {@linkplain Task}\n+   * @throws TaskNotFoundException thrown of the {@linkplain Task} with taskId is not found\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in.\n    */\n   Task getTask(String taskId) throws TaskNotFoundException, NotAuthorizedException;\n \n   /**\n-   * Transfer a task to another work basket. The transfer sets the transferred flag and resets the\n-   * read flag.\n+   * Transfers a {@linkplain Task} to another {@linkplain Workbasket} while always setting the\n+   * {@linkplain Task#isTransferred transfer} flag.\n+   *\n+   * @see #transfer(String, String, boolean)\n+   */\n+  @SuppressWarnings(\"checkstyle:JavadocMethod\")\n+  default Task transfer(String taskId, String destinationWorkbasketId)\n+      throws TaskNotFoundException, WorkbasketNotFoundException, NotAuthorizedException,\n+          InvalidStateException {\n+    return transfer(taskId, destinationWorkbasketId, true);\n+  }\n+\n+  /**\n+   * Transfers a {@linkplain Task} to another {@linkplain Workbasket}.\n    *\n-   * @param taskId The id of the {@link Task} to be transferred\n-   * @param destinationWorkbasketId The Id of the target work basket\n-   * @return the transferred task\n-   * @throws TaskNotFoundException Thrown if the {@link Task} with taskId was not found.\n-   * @throws WorkbasketNotFoundException Thrown if the target work basket was not found.\n+   * <p>The transfer resets the {@linkplain Task#isRead() read} flag and sets the {@linkplain\n+   * Task#isTransferred() transfer} flag if {@code setTransferFlag} is {@code true}.\n+   *\n+   * @param taskId the {@linkplain Task#getId()} of the {@linkplain Task} which should be\n+   *     transferred\n+   * @param destinationWorkbasketId the {@linkplain Workbasket#getId() id} of the target {@linkplain\n+   *     Workbasket}\n+   * @param setTransferFlag the control about whether to set the {@linkplain Task#isTransferred()}\n+   *     flag or not\n+   * @return the transferred {@linkplain Task}\n+   * @throws TaskNotFoundException Thrown if the {@linkplain Task} with taskId was not found.\n+   * @throws WorkbasketNotFoundException Thrown if the target {@linkplain Workbasket} was not found.\n    * @throws NotAuthorizedException Thrown if the current user is not authorized to transfer this\n-   *     {@link Task} to the target work basket\n-   * @throws InvalidStateException Thrown if the task is in a state which does not allow\n-   *     transferring\n+   *     {@linkplain Task} to the target {@linkplain Workbasket}\n+   * @throws InvalidStateException Thrown if the {@linkplain Task} is in a {@linkplain\n+   *     Task#getState() state} which does not allow transferring\n    */\n-  Task transfer(String taskId, String destinationWorkbasketId)\n+  Task transfer(String taskId, String destinationWorkbasketId, boolean setTransferFlag)\n       throws TaskNotFoundException, WorkbasketNotFoundException, NotAuthorizedException,\n           InvalidStateException;\n \n   /**\n-   * Transfer a task to another work basket. The transfer sets the transferred flag and resets the\n-   * read flag.\n+   * Transfers a {@linkplain Task} to another {@linkplain Workbasket} while always setting the\n+   * {@linkplain Task#isTransferred transfer} flag.\n    *\n-   * @param taskId The id of the {@link Task} to be transferred\n-   * @param workbasketKey The key of the target work basket\n-   * @param domain The domain of the target work basket\n-   * @return the transferred task\n-   * @throws TaskNotFoundException Thrown if the {@link Task} with taskId was not found.\n-   * @throws WorkbasketNotFoundException Thrown if the target work basket was not found.\n+   * @see #transfer(String, String, String, boolean)\n+   */\n+  @SuppressWarnings(\"checkstyle:JavadocMethod\")\n+  default Task transfer(String taskId, String workbasketKey, String domain)\n+      throws TaskNotFoundException, WorkbasketNotFoundException, NotAuthorizedException,\n+          InvalidStateException {\n+    return transfer(taskId, workbasketKey, domain, true);\n+  }\n+\n+  /**\n+   * Transfers a {@linkplain Task} to another {@linkplain Workbasket}.\n+   *\n+   * <p>The transfer resets the {@linkplain Task#isRead() read} flag and sets the transfer flag if\n+   * {@code setTransferFlag} is {@code true}.\n+   *\n+   * @param taskId the id of the {@linkplain Task} which should be transferred\n+   * @param workbasketKey the key of the target {@linkplain Workbasket}\n+   * @param domain the domain of the target {@linkplain Workbasket}\n+   * @param setTransferFlag the control about whether to set the {@linkplain Task#isTransferred()}\n+   *     flag or not\n+   * @return the transferred {@linkplain Task}\n+   * @throws TaskNotFoundException Thrown if the {@linkplain Task} with taskId was not found.\n+   * @throws WorkbasketNotFoundException Thrown if the target {@linkplain Workbasket} was not found.\n    * @throws NotAuthorizedException Thrown if the current user is not authorized to transfer this\n-   *     {@link Task} to the target work basket\n-   * @throws InvalidStateException Thrown if the task is in a state which does not allow\n-   *     transferring\n+   *     {@linkplain Task} to the target {@linkplain Workbasket}\n+   * @throws InvalidStateException Thrown if the {@linkplain Task} is in a {@linkplain\n+   *     Task#getState()} which does not allow transferring\n    */\n-  Task transfer(String taskId, String workbasketKey, String domain)\n+  Task transfer(String taskId, String workbasketKey, String domain, boolean setTransferFlag)\n       throws TaskNotFoundException, WorkbasketNotFoundException, NotAuthorizedException,\n           InvalidStateException;\n \n   /**\n-   * Marks a task as read.\n+   * Marks a {@linkplain Task} as read.\n    *\n-   * @param taskId the id of the task to be updated\n-   * @param isRead the new status of the read flag.\n-   * @return the updated Task\n-   * @throws TaskNotFoundException Thrown if the {@link Task} with taskId was not found\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to be updated\n+   * @param isRead the new status of the {@linkplain Task#isRead() read} flag\n+   * @return the updated {@linkplain Task}\n+   * @throws TaskNotFoundException Thrown if the {@linkplain Task} with taskId was not found\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task setTaskRead(String taskId, boolean isRead)\n       throws TaskNotFoundException, NotAuthorizedException;\n \n   /**\n-   * This method provides a query builder for quering the database.\n+   * Provides a query builder for querying the database.\n    *\n-   * @return a {@link TaskQuery}\n+   * @return a {@linkplain TaskQuery}\n    */\n   TaskQuery createTaskQuery();\n \n   /**\n-   * Returns a not persisted instance of {@link Task}. The returned task has no workbasket Id set.\n-   * When createTask() is invoked for this task, TaskService will call the TaskRouting SPI to\n-   * determine a workbasket for the task. If the TaskRouting API is not active, e.g. because no\n-   * TaskRouter is registered, or the TaskRouter(s) don't find a workbasket, the task will not be\n-   * persisted.\n+   * This method provides a query builder for querying the database.\n+   *\n+   * @return a {@linkplain TaskCommentQuery}\n+   */\n+  TaskCommentQuery createTaskCommentQuery();\n+\n+  /**\n+   * Returns a not inserted instance of {@linkplain Task}. The returned {@linkplain Task} has no\n+   * {@linkplain Task#getWorkbasketSummary() w} set. When createTask() is invoked for this task,\n+   * TaskService will call the TaskRouting SPI to determine a workbasket for the task. If the\n+   * TaskRouting API is not active, e.g. because no TaskRouter is registered, or the TaskRouter(s)\n+   * don't find a workbasket, the task will not be inserted.\n    *\n    * @return an empty new Task\n    */\n   Task newTask();\n \n   /**\n-   * Returns a not persisted instance of {@link Task}.\n+   * Returns a not inserted instance of {@linkplain Task}.\n    *\n-   * @param workbasketId the id of the workbasket to which the task belongs\n-   * @return an empty new Task\n+   * @param workbasketId the {@linkplain Workbasket#getId() id} of the {@linkplain Workbasket} to\n+   *     which the task belongs\n+   * @return an empty new {@linkplain Task}\n    */\n   Task newTask(String workbasketId);\n \n   /**\n-   * Returns a not persisted instance of {@link Task}.\n+   * Returns a not inserted instance of {@linkplain Task}.\n    *\n-   * @param workbasketKey the key of the workbasket to which the task belongs\n-   * @param domain the domain of the workbasket to which the task belongs\n-   * @return an empty new Task\n+   * @param workbasketKey the {@linkplain Workbasket#getKey() key} of the {@linkplain Workbasket} to\n+   *     which the {@linkplain Task} belongs\n+   * @param domain the {@linkplain Workbasket#getDomain() domain} of the {@linkplain Workbasket} to\n+   *     which the {@linkplain Task} belongs\n+   * @return an empty new {@linkplain Task}\n    */\n   Task newTask(String workbasketKey, String domain);\n \n   /**\n-   * Returns a not persisted instance of {@link TaskComment}.\n+   * Returns a not inserted instance of {@linkplain TaskComment}.\n    *\n-   * @param taskId The id of the task to which the task comment belongs\n-   * @return an empty new TaskComment\n+   * @param taskId The {@linkplain Task#getId() id} of the {@linkplain Task} to which the task\n+   *     comment belongs\n+   * @return an empty new {@linkplain TaskComment}\n    */\n   TaskComment newTaskComment(String taskId);\n \n   /**\n-   * Returns a not persisted instance of {@link Attachment}.\n+   * Returns a not inserted instance of {@linkplain Attachment}.\n    *\n-   * @return an empty new Attachment\n+   * @return an empty new {@linkplain Attachment}\n    */\n   Attachment newAttachment();\n \n   /**\n-   * Update a task.\n+   * Returns a not inserted instance of {@linkplain ObjectReference}.\n    *\n-   * @param task the task to be updated in the database\n-   * @return the updated task\n-   * @throws InvalidArgumentException if the task to be updated contains invalid properties like\n-   *     e.g. invalid object references\n-   * @throws TaskNotFoundException if the id of the task is not found in the database\n-   * @throws ConcurrencyException if the task has already been updated by another user\n-   * @throws ClassificationNotFoundException if the updated task refers to a classification that\n-   *     cannot be found\n-   * @throws NotAuthorizedException if the current user is not authorized to update the task\n-   * @throws AttachmentPersistenceException if an Attachment with ID will be added multiple times\n-   *     without using the task-methods\n-   * @throws InvalidStateException if an attempt is made to change the owner of the task and the\n-   *     task is not in state READY .\n+   * @return an empty new {@linkplain ObjectReference}\n+   */\n+  ObjectReference newObjectReference();\n+\n+  ObjectReference newObjectReference(\n+      String company, String system, String systemInstance, String type, String value);\n+\n+  /**\n+   * Update a {@linkplain Task}.\n+   *\n+   * @param task the {@linkplain Task} to be updated in the database\n+   * @return the updated {@linkplain Task}\n+   * @throws InvalidArgumentException if the {@linkplain Task} to be updated contains invalid\n+   *     properties like e.g. invalid {@linkplain ObjectReference}s\n+   * @throws TaskNotFoundException if the id of the {@linkplain Task} is not found in the database\n+   * @throws ConcurrencyException if the {@linkplain Task} has been updated by another user in the\n+   *     meantime; that's the case if the given modified timestamp differs from the one in the\n+   *     database\n+   * @throws ClassificationNotFoundException if the updated {@linkplain Task} refers to a {@link\n+   *     Classification} that cannot be found\n+   * @throws NotAuthorizedException if the current user is not authorized to update the {@linkplain\n+   *     Task}\n+   * @throws AttachmentPersistenceException if an {@linkplain Attachment} with ID will be added\n+   *     multiple times without using the Task-methods\n+   * @throws ObjectReferencePersistenceException if an {@linkplain ObjectReference} with ID will be\n+   *     added multiple times without using the Task-methods\n+   * @throws InvalidStateException if an attempt is made to change the owner of the {@linkplain\n+   *     Task} that state isn't READY.\n    */\n   Task updateTask(Task task)\n       throws InvalidArgumentException, TaskNotFoundException, ConcurrencyException,\n           ClassificationNotFoundException, NotAuthorizedException, AttachmentPersistenceException,\n-          InvalidStateException;\n+          ObjectReferencePersistenceException, InvalidStateException;\n \n   /**\n-   * Transfers a list of tasks to an other workbasket. Exceptions will be thrown if the caller got\n-   * no permissions on the target or it doesn\u00b4t exist. Other Exceptions will be stored and returned\n-   * in the end.\n+   * Transfers a list of {@linkplain Task Tasks} to another {@linkplain Workbasket} while always\n+   * setting the {@linkplain Task#isTransferred transfer} flag.\n    *\n-   * @param destinationWorkbasketId target workbasket id\n-   * @param taskIds source task which will be moved\n-   * @return Bulkresult with ID and Error in it for failed transactions.\n-   * @throws NotAuthorizedException if the caller hasn\u00b4t permissions on tarket WB.\n-   * @throws InvalidArgumentException if the method paramesters are EMPTY or NULL.\n-   * @throws WorkbasketNotFoundException if the target WB can\u00b4t be found.\n+   * @see #transferTasks(String, List, boolean)\n    */\n-  BulkOperationResults<String, TaskanaException> transferTasks(\n+  @SuppressWarnings(\"checkstyle:JavadocMethod\")\n+  default BulkOperationResults<String, TaskanaException> transferTasks(\n       String destinationWorkbasketId, List<String> taskIds)\n+      throws NotAuthorizedException, InvalidArgumentException, WorkbasketNotFoundException {\n+    return transferTasks(destinationWorkbasketId, taskIds, true);\n+  }\n+\n+  /**\n+   * Transfers a list of {@linkplain Task Tasks} to another {@linkplain Workbasket}.\n+   *\n+   * <p>The transfer resets the {@linkplain Task#isRead() read flag} and sets the {@linkplain\n+   * Task#isTransferred() transfer flag} if {@code setTransferFlag} is {@code true}. Exceptions will\n+   * be thrown if the caller got no {@linkplain WorkbasketPermission} on the target or if the target\n+   * {@linkplain Workbasket} does not exist. Other Exceptions will be stored and returned in the\n+   * end.\n+   *\n+   * @param destinationWorkbasketId {@linkplain Workbasket#getId() id} of the target {@linkplain\n+   *     Workbasket}\n+   * @param taskIds list of source {@linkplain Task Tasks} which will be moved\n+   * @param setTransferFlag the control about whether to set the {@linkplain Task#isTransferred()}\n+   *     flag or not\n+   * @return Bulkresult with {@linkplain Task#getId() ids} and Error in it for failed transactions\n+   * @throws NotAuthorizedException if the caller has no permissions on target {@linkplain\n+   *     Workbasket}\n+   * @throws InvalidArgumentException if the method parameters are EMPTY or NULL\n+   * @throws WorkbasketNotFoundException if the target {@linkplain Workbasket} can not be found\n+   */\n+  BulkOperationResults<String, TaskanaException> transferTasks(\n+      String destinationWorkbasketId, List<String> taskIds, boolean setTransferFlag)\n       throws NotAuthorizedException, InvalidArgumentException, WorkbasketNotFoundException;\n \n   /**\n-   * Transfers a list of tasks to an other workbasket. Exceptions will be thrown if the caller got\n-   * no permissions on the target or it doesn\u00b4t exist. Other Exceptions will be stored and returned\n+   * Transfers a list of {@linkplain Task Tasks} to another {@linkplain Workbasket} while always\n+   * setting the {@linkplain Task#isTransferred} flag.\n+   *\n+   * @see #transferTasks(String, String, List, boolean)\n+   */\n+  @SuppressWarnings(\"checkstyle:JavadocMethod\")\n+  default BulkOperationResults<String, TaskanaException> transferTasks(\n+      String destinationWorkbasketKey, String destinationWorkbasketDomain, List<String> taskIds)\n+      throws NotAuthorizedException, InvalidArgumentException, WorkbasketNotFoundException {\n+    return transferTasks(destinationWorkbasketKey, destinationWorkbasketDomain, taskIds, true);\n+  }\n+\n+  /**\n+   * Transfers a list of {@linkplain Task Tasks} to another {@linkplain Workbasket}.\n+   *\n+   * <p>The transfer resets the {@linkplain Task#isRead() read flag} and sets the {@linkplain\n+   * Task#isTransferred() transfer flag} if {@code setTransferFlag} is {@code true}. Exceptions will\n+   * be thrown if the caller got no {@linkplain WorkbasketPermission Permission} on the target\n+   * {@linkplain Workbasket} or if it does not exist. Other Exceptions will be stored and returned\n    * in the end.\n    *\n-   * @param destinationWorkbasketKey target workbasket key\n-   * @param destinationWorkbasketDomain target workbasket domain\n-   * @param taskIds source task which will be moved\n-   * @return Bulkresult with ID and Error in it for failed transactions.\n-   * @throws NotAuthorizedException if the caller hasn\u00b4t permissions on tarket WB.\n-   * @throws InvalidArgumentException if the method paramesters are EMPTY or NULL.\n-   * @throws WorkbasketNotFoundException if the target WB can\u00b4t be found.\n+   * @param destinationWorkbasketKey target {@linkplain Workbasket#getKey()} Workbasket}\n+   * @param destinationWorkbasketDomain target {@linkplain Workbasket#getDomain() domain}\n+   * @param taskIds List of source {@linkplain Task Tasks} which will be moved\n+   * @param setTransferFlag the control about whether to set the {@linkplain Task#isTransferred()}\n+   *     flag or not\n+   * @return BulkResult with {@linkplain Task#getId() id} and Error in it for failed transactions.\n+   * @throws NotAuthorizedException if the caller has no {@linkplain WorkbasketPermission} on target\n+   *     {@linkplain Workbasket}.\n+   * @throws InvalidArgumentException if the method parameters are EMPTY or NULL.\n+   * @throws WorkbasketNotFoundException if the target {@linkplain Workbasket} can not be found.\n    */\n   BulkOperationResults<String, TaskanaException> transferTasks(\n-      String destinationWorkbasketKey, String destinationWorkbasketDomain, List<String> taskIds)\n+      String destinationWorkbasketKey,\n+      String destinationWorkbasketDomain,\n+      List<String> taskIds,\n+      boolean setTransferFlag)\n       throws NotAuthorizedException, InvalidArgumentException, WorkbasketNotFoundException;\n \n   /**\n-   * Deletes the task with the given Id.\n+   * Deletes the {@linkplain Task} with the given {@linkplain Task#getId() id}.\n    *\n-   * @param taskId The Id of the task to delete.\n-   * @throws TaskNotFoundException If the given Id does not refer to an existing task.\n-   * @throws InvalidStateException If the state of the referenced task is not Completed.\n-   * @throws NotAuthorizedException if the current user is not member of role ADMIN\n+   * @param taskId The {@linkplain Task#getId() id} of the {@linkplain Task} to delete.\n+   * @throws TaskNotFoundException If the given {@linkplain Task#getId() id} does not refer to an\n+   *     existing {@linkplain Task}.\n+   * @throws InvalidStateException If the {@linkplain Task#getState() state} of the referenced\n+   *     {@linkplain Task} is not an end state.\n+   * @throws NotAuthorizedException if the current user is not member of role {@linkplain\n+   *     TaskanaRole#ADMIN}\n    */\n   void deleteTask(String taskId)\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n \n   /**\n-   * Deletes the task with the given Id even if it is not completed.\n+   * Deletes the {@linkplain Task} with the given {@linkplain Task#getId() id} even if it is not\n+   * completed.\n    *\n-   * @param taskId The Id of the task to delete.\n-   * @throws TaskNotFoundException If the given Id does not refer to an existing task.\n-   * @throws InvalidStateException If the state of the referenced task is not Completed and\n-   *     forceDelet is false.\n-   * @throws NotAuthorizedException if the current user is not member of role ADMIN\n+   * @param taskId The {@linkplain Task#getId() id} of the {@linkplain Task} to delete.\n+   * @throws TaskNotFoundException If the given {@linkplain Task#getId() id} does not refer to an\n+   *     existing {@linkplain Task}.\n+   * @throws InvalidStateException If the state of the referenced {@linkplain Task} is not an end\n+   *     state and forceDelete is false.\n+   * @throws NotAuthorizedException if the current user is not member of role {@linkplain\n+   *     TaskanaRole#ADMIN}\n    */\n   void forceDeleteTask(String taskId)\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n \n   /**\n-   * Selects and claims the first task which is returned by the task query.\n+   * Selects and claims the first {@linkplain Task} which is returned by the {@linkplain TaskQuery}.\n    *\n-   * @param taskQuery the task query.\n-   * @return the task that got selected and claimed\n-   * @throws InvalidOwnerException if the task is claimed by someone else\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @param taskQuery the {@linkplain TaskQuery}.\n+   * @return the {@linkplain Task} that got selected and claimed\n+   * @throws InvalidOwnerException if the {@linkplain Task} is claimed by someone else\n+   * @throws NotAuthorizedException if the current user has no read permission for the Workbasket\n+   *     the {@linkplain Task} is in\n    */\n   Task selectAndClaim(TaskQuery taskQuery) throws NotAuthorizedException, InvalidOwnerException;\n \n   /**\n-   * Deletes a list of tasks.\n+   * Deletes a list of {@linkplain Task Tasks}.\n    *\n-   * @param tasks the ids of the tasks to delete.\n-   * @return the result of the operations with Id and Exception for each failed task deletion.\n+   * @param tasks the {@linkplain Task#getId() ids} of the tasks to delete.\n+   * @return the result of the operations with each {@linkplain Task#getId() id} and Exception for\n+   *     each failed task deletion.\n    * @throws InvalidArgumentException if the TaskIds parameter is NULL\n    * @throws NotAuthorizedException if the current user is not member of role ADMIN\n    */\n", "next_change": {"commit": "a2e068119042fd305c3f494e43cd41fec80f1a30", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 48bac1ed4..a58ce2866 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -475,28 +535,29 @@ public interface TaskService {\n   /**\n    * Selects and claims the first {@linkplain Task} which is returned by the {@linkplain TaskQuery}.\n    *\n-   * @param taskQuery the {@linkplain TaskQuery}.\n+   * @param taskQuery the {@linkplain TaskQuery}\n    * @return the {@linkplain Task} that got selected and claimed\n    * @throws InvalidOwnerException if the {@linkplain Task} is claimed by someone else\n-   * @throws NotAuthorizedException if the current user has no read permission for the Workbasket\n-   *     the {@linkplain Task} is in\n+   * @throws NotAuthorizedException if the current user has no {@linkplain\n+   *     WorkbasketPermission#READ} for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task selectAndClaim(TaskQuery taskQuery) throws NotAuthorizedException, InvalidOwnerException;\n \n   /**\n-   * Deletes a list of {@linkplain Task Tasks}.\n+   * Deletes a List of {@linkplain Task Tasks}.\n    *\n-   * @param tasks the {@linkplain Task#getId() ids} of the tasks to delete.\n+   * @param tasks the {@linkplain Task#getId() ids} of the {@linkplain Task Tasks} to delete\n    * @return the result of the operations with each {@linkplain Task#getId() id} and Exception for\n-   *     each failed task deletion.\n-   * @throws InvalidArgumentException if the TaskIds parameter is NULL\n-   * @throws NotAuthorizedException if the current user is not member of role ADMIN\n+   *     each failed deletion\n+   * @throws InvalidArgumentException if the tasks parameter contains NULL values\n+   * @throws NotAuthorizedException if the current user isn't member of {@linkplain\n+   *     TaskanaRole#ADMIN}\n    */\n   BulkOperationResults<String, TaskanaException> deleteTasks(List<String> tasks)\n       throws InvalidArgumentException, NotAuthorizedException;\n \n   /**\n-   * Completes a list of {@linkplain Task Tasks}.\n+   * Completes a List of {@linkplain Task Tasks}.\n    *\n    * @param taskIds {@linkplain Task#getId() ids} of the {@linkplain Task Tasks} which should be\n    *     completed\n", "next_change": {"commit": "33a88529954a490d2a042a34319cbf394ee15e9d", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex a58ce2866..6e357fdf2 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -556,68 +731,21 @@ public interface TaskService {\n   BulkOperationResults<String, TaskanaException> deleteTasks(List<String> tasks)\n       throws InvalidArgumentException, NotAuthorizedException;\n \n-  /**\n-   * Completes a List of {@linkplain Task Tasks}.\n-   *\n-   * @param taskIds {@linkplain Task#getId() ids} of the {@linkplain Task Tasks} which should be\n-   *     completed\n-   * @return the result of the operations with each {@linkplain Task#getId() id} and Exception for\n-   *     each failed completion\n-   * @throws InvalidArgumentException If the taskIds parameter is NULL\n-   */\n-  BulkOperationResults<String, TaskanaException> completeTasks(List<String> taskIds)\n-      throws InvalidArgumentException;\n+  // endregion\n \n-  /**\n-   * Completes each existing {@linkplain Task} in the given List in every case, independent of the\n-   * {@linkplain Task#getOwner() owner} or {@linkplain Task#getState() state} of the {@linkplain\n-   * Task}.\n-   *\n-   * <p>If the {@linkplain Task} is already {@linkplain TaskState#COMPLETED completed}, the\n-   * {@linkplain Task} stays unchanged.\n-   *\n-   * @param taskIds {@linkplain Task#getId() id} of the {@linkplain Task Tasks} which should be\n-   *     completed\n-   * @return the result of the operations with {@linkplain Task#getId() ids} and Exception for each\n-   *     failed completion\n-   * @throws InvalidArgumentException If the taskIds parameter is NULL\n-   */\n-  BulkOperationResults<String, TaskanaException> forceCompleteTasks(List<String> taskIds)\n-      throws InvalidArgumentException;\n+  // endregion\n \n-  /**\n-   * Updates specified {@linkplain TaskCustomField TaskCustomFields} of {@linkplain Task Tasks}\n-   * associated with the given {@linkplain Task#getPrimaryObjRef() primaryObjRef}.\n-   *\n-   * @param selectionCriteria the {@linkplain Task#getPrimaryObjRef() primaryObjRef} of the\n-   *     searched-for {@linkplain Task Tasks}.\n-   * @param customFieldsToUpdate a Map that contains as key the identification of the {@linkplain\n-   *     TaskCustomField} and as value the corresponding new value of that {@linkplain\n-   *     TaskCustomField}\n-   * @return a List of the {@linkplain Task#getId() ids} of all modified {@linkplain Task Tasks}\n-   * @throws InvalidArgumentException if the given selectionCriteria is invalid or the given\n-   *     customFieldsToUpdate are NULL or empty\n-   * @see #updateTasks(List, Map)\n-   */\n-  List<String> updateTasks(\n-      ObjectReference selectionCriteria, Map<TaskCustomField, String> customFieldsToUpdate)\n-      throws InvalidArgumentException;\n+  // region TaskComment\n \n+  // region CREATE\n   /**\n-   * Updates specified {@linkplain TaskCustomField TaskCustomFields} for all given {@linkplain Task\n-   * Tasks}.\n+   * Instantiates a non-persistent/non-inserted {@linkplain TaskComment}.\n    *\n-   * @param taskIds the {@linkplain Task#getId() taskIds} that are used to select the {@linkplain\n-   *     Task Tasks}\n-   * @param customFieldsToUpdate a Map that contains as key the identification of the {@linkplain\n-   *     TaskCustomField} and as value the corresponding new value of that {@linkplain\n-   *     TaskCustomField}\n-   * @return a list of the {@linkplain Task#getId() ids} of all modified {@linkplain Task Tasks}\n-   * @throws InvalidArgumentException if the given customFieldsToUpdate are NULL or empty\n-   * @see #updateTasks(ObjectReference, Map)\n+   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to which the\n+   *     {@linkplain TaskComment} belongs\n+   * @return the instantiated {@linkplain TaskComment}\n    */\n-  List<String> updateTasks(List<String> taskIds, Map<TaskCustomField, String> customFieldsToUpdate)\n-      throws InvalidArgumentException;\n+  TaskComment newTaskComment(String taskId);\n \n   /**\n    * Inserts the specified {@linkplain TaskComment} into the database.\n", "next_change": {"commit": "20d389a7d524c156b063dfc91589bb22bebea0d7", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 6e357fdf2..634768e9f 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -752,7 +777,7 @@ public interface TaskService {\n    *\n    * @param taskComment the {@linkplain TaskComment} to be created\n    * @return the created {@linkplain TaskComment}\n-   * @throws NotAuthorizedException if the current user has no {@linkplain\n+   * @throws MismatchedWorkbasketPermissionException if the current user has no {@linkplain\n    *     WorkbasketPermission#READ} for the {@linkplain Workbasket} of the commented {@linkplain\n    *     Task}.\n    * @throws TaskNotFoundException if the given {@linkplain TaskComment#getTaskId() taskId} doesn't\n", "next_change": {"commit": "d21eb47ffea4c2c9fff8f1d3435b77b805d03508", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 634768e9f..26d27f3a7 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -777,7 +772,7 @@ public interface TaskService {\n    *\n    * @param taskComment the {@linkplain TaskComment} to be created\n    * @return the created {@linkplain TaskComment}\n-   * @throws MismatchedWorkbasketPermissionException if the current user has no {@linkplain\n+   * @throws NotAuthorizedOnWorkbasketException if the current user has no {@linkplain\n    *     WorkbasketPermission#READ} for the {@linkplain Workbasket} of the commented {@linkplain\n    *     Task}.\n    * @throws TaskNotFoundException if the given {@linkplain TaskComment#getTaskId() taskId} doesn't\n", "next_change": null}, {"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 634768e9f..26d27f3a7 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -786,8 +781,7 @@ public interface TaskService {\n    *     {@link TaskComment} is neither NULL nor empty\n    */\n   TaskComment createTaskComment(TaskComment taskComment)\n-      throws TaskNotFoundException, InvalidArgumentException,\n-          MismatchedWorkbasketPermissionException;\n+      throws TaskNotFoundException, InvalidArgumentException, NotAuthorizedOnWorkbasketException;\n \n   // endregion\n \n", "next_change": null}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "969d3eeff653d51eb7dcf5234aa4020333613ab3", "message": "Merge commit", "committedDate": null}, {"oid": "7cc5b00be617227dac2f8d1210554108d18bad4a", "committedDate": "2020-07-24 01:05:42 +0200", "message": "TSK-1345: replaced every customField API call with CustomField enums"}, {"oid": "3967e2900e8b35329b3675844ca3a8e059916c7e", "committedDate": "2020-12-18 11:29:10 +0100", "message": "TSK-1436: rest api documentation is now build with spring-auto-restdocs"}, {"oid": "de57596ba8e816d3e751b21c949a3fe132b314f0", "committedDate": "2020-12-18 11:29:10 +0100", "message": "TSK-1436: reworked review comments."}, {"oid": "d57aeb3219f45e962d6a05b175f4397d296e819b", "committedDate": "2021-03-01 10:03:04 +0100", "message": "TSK-1524: Set the default service level to \"P0D\" (#1496)"}, {"oid": "ec822c116855052b32ef98cc496e4876c7f52fa6", "committedDate": "2021-03-02 10:34:30 +0100", "message": "TSK-1555: Initialize due of Cleanup Job based on firstRun (#1488)"}, {"oid": "0119999380b40fdc0f69677f96650de5c81bd2a5", "committedDate": "2021-03-09 18:58:51 +0100", "message": "TSK-1538: Added transfer method with control setTransferFlag (#1513)"}, {"oid": "1c83b7871f144cd07a912639b942d5938219e101", "committedDate": "2021-06-22 16:14:09 +0200", "message": "TSK-1646: Bugfix for creation / update of Task with invalid Attachment"}, {"oid": "34d2bbfa929ccaa9e9b93c173b8fa867154330bb", "committedDate": "2021-07-14 10:49:34 +0200", "message": "TSK-1647: Implemented an error key for every exception"}, {"oid": "375a92291d41c6c90b403055ac5228ccd309621a", "committedDate": "2021-07-15 14:03:00 +0200", "message": "TSK-1658: Created TaskQueryMapperSqlProvider"}, {"oid": "e264a203892c6d2111df4645abf7f373bf4ca86a", "committedDate": "2021-10-08 08:38:21 +0200", "message": "TSK-1726: Implemented option to include long name on Task / TaskComment / TaskHistoryEvent"}, {"oid": "967e59e012f94e116f2b327b6c426f44ae1bcbee", "committedDate": "2022-02-25 10:23:40 +0100", "message": "TSK-1800: add secondary object references"}, {"oid": "b4e1f9bc315eb701d0dec0e34c38651672239566", "committedDate": "2022-04-15 11:43:57 +0200", "message": "TSK-1532: Refactor names of entities in REST-Doc by capitalizing them; refactor Java-doc according to guidelines"}, {"oid": "a2e068119042fd305c3f494e43cd41fec80f1a30", "committedDate": "2022-05-31 16:01:49 +0200", "message": "TSK-1852: refactor JavaDoc in TaskService"}, {"oid": "ef875dd42a58b55bace25fb4f599d84e4d06b59b", "committedDate": "2022-08-06 14:30:59 +0200", "message": "TSK-1915: Add requestReview functionality"}, {"oid": "cc32b10d82b7888ed2eae438100d2e26fb508f0c", "committedDate": "2022-08-09 13:19:02 +0200", "message": "TSK-1916: Add requestChanges functionality"}, {"oid": "6997d640834819d21fe0325178d73bbf70de68fc", "committedDate": "2022-08-11 17:08:10 +0200", "message": "TSK-1943: added REST endpoint for force requesting changes on a Task"}, {"oid": "33a88529954a490d2a042a34319cbf394ee15e9d", "committedDate": "2022-08-18 00:02:18 +0300", "message": "TSK-1864: Reorder methods in TaskService"}, {"oid": "b9b49f47a13e748be20bf73ed605f0dfde7fcf70", "committedDate": "2022-10-20 14:20:24 +0200", "message": "TSK-1965: create endpoints for all state transitions (#2024)"}, {"oid": "20d389a7d524c156b063dfc91589bb22bebea0d7", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-1992 remove unnecessary ParentExceptions"}, {"oid": "d21eb47ffea4c2c9fff8f1d3435b77b805d03508", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-2012: renamed Mismatched_Exceptions to NotAuthorizedExceptions"}, {"oid": "37280cc73b83e2d39ab4afddd40256719d64c50c", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-2013 selectAndClaim TasK return Optional and does not throw Exception if Task is notFound"}, {"oid": "55d939ca7b7720ab12f488ed8fc2a631ecc6f05c", "committedDate": "2023-03-13 19:02:53 +0100", "message": "format entire codebase with new google-java-format version"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY0NDY0NA==", "url": "https://github.com/Taskana/taskana/pull/1150#discussion_r446644644", "body": "selectAndClaim does not work on db2? I think this is worth commenting. Something like \"the optimized query for db2 does not work with selectAndClaim because ...\"", "bodyText": "selectAndClaim does not work on db2? I think this is worth commenting. Something like \"the optimized query for db2 does not work with selectAndClaim because ...\"", "bodyHTML": "<p dir=\"auto\">selectAndClaim does not work on db2? I think this is worth commenting. Something like \"the optimized query for db2 does not work with selectAndClaim because ...\"</p>", "author": "mustaphazorgati", "createdAt": "2020-06-28T12:28:26Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskQueryImpl.java", "diffHunk": "@@ -1112,7 +1111,11 @@ public long count() {\n   }\n \n   public String getLinkToMapperScript() {\n-    return DB.DB2.dbProductId.equals(getDatabaseId()) ? LINK_TO_MAPPER_DB2 : LINK_TO_MAPPER;\n+    if (DB.DB2.dbProductId.equals(getDatabaseId()) && !selectAndClaim) {\n+      return LINK_TO_MAPPER_DB2;", "originalCommit": "f1991ad4316cd8de239ba6cd0cc57caa70f1bddb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "808d5e604539f2f4e5e13e86b00c627a78e1b762", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskQueryImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskQueryImpl.java\nindex 4381d8cbd..f90afde63 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskQueryImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskQueryImpl.java\n", "chunk": "@@ -1110,6 +1110,8 @@ public class TaskQueryImpl implements TaskQuery {\n     }\n   }\n \n+  // optimized query for db2 can't be used for now in case of selectAndClaim because of temporary\n+  // tables and the \"for update\" clause clashing in db2\n   public String getLinkToMapperScript() {\n     if (DB.DB2.dbProductId.equals(getDatabaseId()) && !selectAndClaim) {\n       return LINK_TO_MAPPER_DB2;\n", "next_change": null}]}, "revised_code_in_main": {"commit": "969d3eeff653d51eb7dcf5234aa4020333613ab3", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskQueryImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskQueryImpl.java\nindex 4381d8cbd..f90afde63 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskQueryImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskQueryImpl.java\n", "chunk": "@@ -1110,6 +1110,8 @@ public class TaskQueryImpl implements TaskQuery {\n     }\n   }\n \n+  // optimized query for db2 can't be used for now in case of selectAndClaim because of temporary\n+  // tables and the \"for update\" clause clashing in db2\n   public String getLinkToMapperScript() {\n     if (DB.DB2.dbProductId.equals(getDatabaseId()) && !selectAndClaim) {\n       return LINK_TO_MAPPER_DB2;\n", "next_change": {"commit": "0dc26f5fe163763e03b22373dec4c22a5fb6e107", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskQueryImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskQueryImpl.java\nindex f90afde63..7bcaf7869 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskQueryImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskQueryImpl.java\n", "chunk": "@@ -1113,7 +1059,7 @@ public class TaskQueryImpl implements TaskQuery {\n   // optimized query for db2 can't be used for now in case of selectAndClaim because of temporary\n   // tables and the \"for update\" clause clashing in db2\n   public String getLinkToMapperScript() {\n-    if (DB.DB2.dbProductId.equals(getDatabaseId()) && !selectAndClaim) {\n+    if (DB.isDb2(getDatabaseId()) && !selectAndClaim) {\n       return LINK_TO_MAPPER_DB2;\n     } else {\n       return LINK_TO_MAPPER;\n", "next_change": {"commit": "1bab31e43c844b6808230cda86126cc933bdacb9", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskQueryImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskQueryImpl.java\nindex 7bcaf7869..54d794f12 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskQueryImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskQueryImpl.java\n", "chunk": "@@ -880,698 +1197,573 @@ public class TaskQueryImpl implements TaskQuery {\n         : addOrderCriteria(\"ac.NAME\", sortDirection);\n   }\n \n+  // endregion\n+  // region attachmentChannel\n+\n   @Override\n-  public TaskQuery orderByAttachmentClassificationId(SortDirection sortDirection) {\n+  public TaskQuery attachmentChannelIn(String... attachmentChannel) {\n     joinWithAttachments = true;\n-    addAttachmentColumnsToSelectClauseForOrdering = true;\n-    return DB.isDb2(getDatabaseId())\n-        ? addOrderCriteria(\"ACLASSIFICATION_ID\", sortDirection)\n-        : addOrderCriteria(\"a.CLASSIFICATION_ID\", sortDirection);\n+    this.attachmentChannelIn = attachmentChannel;\n+    return this;\n   }\n \n   @Override\n-  public TaskQuery orderByAttachmentChannel(SortDirection sortDirection) {\n+  public TaskQuery attachmentChannelNotIn(String... attachmentChannel) {\n     joinWithAttachments = true;\n-    addAttachmentColumnsToSelectClauseForOrdering = true;\n-    return addOrderCriteria(\"CHANNEL\", sortDirection);\n+    this.attachmentChannelNotIn = attachmentChannel;\n+    return this;\n   }\n \n   @Override\n-  public TaskQuery orderByAttachmentReference(SortDirection sortDirection) {\n+  public TaskQuery attachmentChannelLike(String... attachmentChannel) {\n     joinWithAttachments = true;\n-    addAttachmentColumnsToSelectClauseForOrdering = true;\n-    return addOrderCriteria(\"REF_VALUE\", sortDirection);\n+    this.attachmentChannelLike = toUpperCopy(attachmentChannel);\n+    return this;\n   }\n \n   @Override\n-  public TaskQuery orderByAttachmentReceived(SortDirection sortDirection) {\n+  public TaskQuery attachmentChannelNotLike(String... attachmentChannel) {\n+    joinWithAttachments = true;\n+    this.attachmentChannelNotLike = toUpperCopy(attachmentChannel);\n+    return this;\n+  }\n+\n+  @Override\n+  public TaskQuery orderByAttachmentChannel(SortDirection sortDirection) {\n     joinWithAttachments = true;\n     addAttachmentColumnsToSelectClauseForOrdering = true;\n-    return addOrderCriteria(\"RECEIVED\", sortDirection);\n+    return addOrderCriteria(\"CHANNEL\", sortDirection);\n   }\n \n-  public TaskQuery selectAndClaimEquals(boolean selectAndClaim) {\n-    this.selectAndClaim = selectAndClaim;\n+  // endregion\n+  // region attachmentReferenceValue\n+\n+  @Override\n+  public TaskQuery attachmentReferenceValueIn(String... referenceValue) {\n+    joinWithAttachments = true;\n+    this.attachmentReferenceIn = referenceValue;\n     return this;\n   }\n \n   @Override\n-  public List<TaskSummary> list() {\n-    List<TaskSummary> result = new ArrayList<>();\n-    try {\n-      LOGGER.debug(\"entry to list(), this = {}\", this);\n-      taskanaEngine.openConnection();\n-      checkForIllegalParamCombinations();\n-      checkOpenAndReadPermissionForSpecifiedWorkbaskets();\n-      setupJoinAndOrderParameters();\n-      setupAccessIds();\n-      List<TaskSummaryImpl> tasks =\n-          taskanaEngine.getSqlSession().selectList(getLinkToMapperScript(), this);\n-      if (LOGGER.isDebugEnabled()) {\n-        LOGGER.debug(\"mapper returned {} resulting Objects: {} \", tasks.size(), tasks);\n-      }\n-      result = taskService.augmentTaskSummariesByContainedSummaries(tasks);\n-      return result;\n-    } finally {\n-      taskanaEngine.returnConnection();\n-      if (LOGGER.isDebugEnabled()) {\n-        LOGGER.debug(\n-            \"exit from list(). Returning {} resulting Objects: {} \", result.size(), result);\n-      }\n-    }\n+  public TaskQuery attachmentReferenceValueNotIn(String... referenceValue) {\n+    joinWithAttachments = true;\n+    this.attachmentReferenceNotIn = referenceValue;\n+    return this;\n   }\n \n   @Override\n-  public List<TaskSummary> list(int offset, int limit) {\n-    LOGGER.debug(\"entry to list(offset = {}, limit = {}), this = {}\", offset, limit, this);\n-    List<TaskSummary> result = new ArrayList<>();\n-    try {\n-      taskanaEngine.openConnection();\n-      checkForIllegalParamCombinations();\n-      checkOpenAndReadPermissionForSpecifiedWorkbaskets();\n-      setupAccessIds();\n-      setupJoinAndOrderParameters();\n-      RowBounds rowBounds = new RowBounds(offset, limit);\n-      List<TaskSummaryImpl> tasks =\n-          taskanaEngine.getSqlSession().selectList(getLinkToMapperScript(), this, rowBounds);\n-      result = taskService.augmentTaskSummariesByContainedSummaries(tasks);\n-      return result;\n-    } catch (PersistenceException e) {\n-      if (e.getMessage().contains(\"ERRORCODE=-4470\")) {\n-        TaskanaRuntimeException ex =\n-            new TaskanaRuntimeException(\n-                \"The offset beginning was set over the amount of result-rows.\", e.getCause());\n-        ex.setStackTrace(e.getStackTrace());\n-        throw ex;\n-      }\n-      throw e;\n-    } finally {\n-      taskanaEngine.returnConnection();\n-      if (LOGGER.isDebugEnabled()) {\n-        LOGGER.debug(\n-            \"exit from list(offset,limit). Returning {} resulting Objects: {} \",\n-            result.size(),\n-            result);\n-      }\n-    }\n-  }\n-\n-  @Override\n-  public List<String> listValues(TaskQueryColumnName columnName, SortDirection sortDirection) {\n-    LOGGER.debug(\"Entry to listValues(dbColumnName={}) this = {}\", columnName, this);\n-    List<String> result = new ArrayList<>();\n-    try {\n-      taskanaEngine.openConnection();\n-      this.columnName = columnName;\n-      this.orderBy.clear();\n-      this.addOrderCriteria(columnName.toString(), sortDirection);\n-      checkForIllegalParamCombinations();\n-      checkOpenAndReadPermissionForSpecifiedWorkbaskets();\n-      setupAccessIds();\n-\n-      if (columnName.equals(TaskQueryColumnName.CLASSIFICATION_NAME)) {\n-        joinWithClassifications = true;\n-      }\n-\n-      if (columnName.equals(TaskQueryColumnName.A_CLASSIFICATION_NAME)) {\n-        joinWithAttachmentClassifications = true;\n-      }\n-\n-      if (columnName.isAttachmentColumn()) {\n-        joinWithAttachments = true;\n-      }\n-\n-      setupJoinAndOrderParameters();\n-      result = taskanaEngine.getSqlSession().selectList(LINK_TO_VALUE_MAPPER, this);\n-      return result;\n-    } finally {\n-      taskanaEngine.returnConnection();\n-      if (LOGGER.isDebugEnabled()) {\n-        LOGGER.debug(\n-            \"Exit from listValues. Returning {} resulting Objects: {} \", result.size(), result);\n-      }\n-    }\n+  public TaskQuery attachmentReferenceValueLike(String... referenceValue) {\n+    joinWithAttachments = true;\n+    this.attachmentReferenceLike = toUpperCopy(referenceValue);\n+    return this;\n   }\n \n   @Override\n-  public TaskSummary single() {\n-    LOGGER.debug(\"entry to single(), this = {}\", this);\n-    TaskSummary result = null;\n-    try {\n-      taskanaEngine.openConnection();\n-      checkOpenAndReadPermissionForSpecifiedWorkbaskets();\n-      setupAccessIds();\n-      setupJoinAndOrderParameters();\n-      TaskSummaryImpl taskSummaryImpl =\n-          taskanaEngine.getSqlSession().selectOne(getLinkToMapperScript(), this);\n-      if (taskSummaryImpl == null) {\n-        return null;\n-      }\n-      List<TaskSummaryImpl> tasks = new ArrayList<>();\n-      tasks.add(taskSummaryImpl);\n-      List<TaskSummary> augmentedList = taskService.augmentTaskSummariesByContainedSummaries(tasks);\n-      result = augmentedList.get(0);\n-\n-      return result;\n-    } finally {\n-      taskanaEngine.returnConnection();\n-      LOGGER.debug(\"exit from single(). Returning result {} \", result);\n-    }\n+  public TaskQuery attachmentReferenceValueNotLike(String... referenceValue) {\n+    joinWithAttachments = true;\n+    this.attachmentReferenceNotLike = toUpperCopy(referenceValue);\n+    return this;\n   }\n \n   @Override\n-  public long count() {\n-    LOGGER.debug(\"entry to count(), this = {}\", this);\n-    Long rowCount = null;\n-    try {\n-      taskanaEngine.openConnection();\n-      checkOpenAndReadPermissionForSpecifiedWorkbaskets();\n-      setupAccessIds();\n-      setupJoinAndOrderParameters();\n-      rowCount = taskanaEngine.getSqlSession().selectOne(getLinkToCounterTaskScript(), this);\n-      return (rowCount == null) ? 0L : rowCount;\n-    } finally {\n-      taskanaEngine.returnConnection();\n-      LOGGER.debug(\"exit from count(). Returning result {} \", rowCount);\n-    }\n-  }\n-\n-  // optimized query for db2 can't be used for now in case of selectAndClaim because of temporary\n-  // tables and the \"for update\" clause clashing in db2\n-  public String getLinkToMapperScript() {\n-    if (DB.isDb2(getDatabaseId()) && !selectAndClaim) {\n-      return LINK_TO_MAPPER_DB2;\n-    } else {\n-      return LINK_TO_MAPPER;\n-    }\n-  }\n-\n-  public String getLinkToCounterTaskScript() {\n-    return DB.isDb2(getDatabaseId()) ? LINK_TO_COUNTER_DB2 : LINK_TO_COUNTER;\n-  }\n-\n-  public boolean isUseDistinctKeyword() {\n-    return useDistinctKeyword;\n-  }\n-\n-  public void setUseDistinctKeyword(boolean useDistinctKeyword) {\n-    this.useDistinctKeyword = useDistinctKeyword;\n-  }\n-\n-  public boolean isJoinWithAttachments() {\n-    return joinWithAttachments;\n-  }\n-\n-  public void setJoinWithAttachments(boolean joinWithAttachments) {\n-    this.joinWithAttachments = joinWithAttachments;\n-  }\n-\n-  public boolean isJoinWithClassifications() {\n-    return joinWithClassifications;\n-  }\n-\n-  public void setJoinWithClassifications(boolean joinWithClassifications) {\n-    this.joinWithClassifications = joinWithClassifications;\n-  }\n-\n-  public boolean isJoinWithAttachmentsClassifications() {\n-    return joinWithAttachmentClassifications;\n-  }\n-\n-  public void setJoinWithAttachmentsClassifications(boolean joinWithAttachmentsClassifications) {\n-    this.joinWithAttachmentClassifications = joinWithAttachmentsClassifications;\n-  }\n-\n-  public boolean isAddAttachmentColumnsToSelectClauseForOrdering() {\n-    return addAttachmentColumnsToSelectClauseForOrdering;\n-  }\n-\n-  public void setAddAttachmentColumnsToSelectClauseForOrdering(\n-      boolean addAttachmentColumnsToSelectClauseForOrdering) {\n-    this.addAttachmentColumnsToSelectClauseForOrdering =\n-        addAttachmentColumnsToSelectClauseForOrdering;\n-  }\n-\n-  public String[] getTaskIds() {\n-    return taskIds;\n-  }\n-\n-  public String[] getNameIn() {\n-    return nameIn;\n-  }\n-\n-  public String[] getExternalIdIn() {\n-    return externalIdIn;\n-  }\n-\n-  public String[] getExternalIdLike() {\n-    return externalIdLike;\n-  }\n-\n-  public String[] getCreatorIn() {\n-    return creatorIn;\n-  }\n-\n-  public String[] getCreatorLike() {\n-    return creatorLike;\n-  }\n-\n-  public String[] getDescription() {\n-    return description;\n-  }\n-\n-  public int[] getPriority() {\n-    return priority;\n-  }\n-\n-  public TaskState[] getStateIn() {\n-    return stateIn;\n-  }\n-\n-  public String[] getOwnerIn() {\n-    return ownerIn;\n-  }\n-\n-  public String[] getOwnerLike() {\n-    return ownerLike;\n-  }\n-\n-  public Boolean getIsRead() {\n-    return isRead;\n-  }\n-\n-  public Boolean getIsTransferred() {\n-    return isTransferred;\n-  }\n-\n-  public boolean getIsSelectAndClaim() {\n-    return selectAndClaim;\n-  }\n-\n-  public String[] getPorCompanyIn() {\n-    return porCompanyIn;\n-  }\n-\n-  public String[] getPorCompanyLike() {\n-    return porCompanyLike;\n-  }\n-\n-  public String[] getPorSystemIn() {\n-    return porSystemIn;\n-  }\n-\n-  public String[] getPorSystemLike() {\n-    return porSystemLike;\n-  }\n-\n-  public String[] getPorSystemInstanceIn() {\n-    return porSystemInstanceIn;\n-  }\n-\n-  public String[] getPorSystemInstanceLike() {\n-    return porSystemInstanceLike;\n-  }\n-\n-  public String[] getPorTypeIn() {\n-    return porTypeIn;\n-  }\n-\n-  public String[] getPorTypeLike() {\n-    return porTypeLike;\n-  }\n-\n-  public String[] getPorValueIn() {\n-    return porValueIn;\n-  }\n-\n-  public String[] getPorValueLike() {\n-    return porValueLike;\n-  }\n-\n-  public List<String> getOrderBy() {\n-    return orderBy;\n-  }\n-\n-  public List<String> getOrderColumns() {\n-    return orderColumns;\n-  }\n-\n-  public TimeInterval[] getCreatedIn() {\n-    return createdIn;\n-  }\n-\n-  public TaskServiceImpl getTaskService() {\n-    return taskService;\n-  }\n-\n-  public String[] getNote() {\n-    return note;\n-  }\n-\n-  public String[] getNoteLike() {\n-    return noteLike;\n-  }\n-\n-  public String[] getParentBusinessProcessIdIn() {\n-    return parentBusinessProcessIdIn;\n-  }\n-\n-  public String[] getParentBusinessProcessIdLike() {\n-    return parentBusinessProcessIdLike;\n-  }\n-\n-  public String[] getBusinessProcessIdIn() {\n-    return businessProcessIdIn;\n-  }\n-\n-  public String[] getBusinessProcessIdLike() {\n-    return businessProcessIdLike;\n-  }\n-\n-  public String[] getCustom1In() {\n-    return custom1In;\n-  }\n-\n-  public String[] getCustom1Like() {\n-    return custom1Like;\n-  }\n-\n-  public String[] getCustom2In() {\n-    return custom2In;\n-  }\n-\n-  public String[] getCustom2Like() {\n-    return custom2Like;\n-  }\n-\n-  public String[] getCustom3In() {\n-    return custom3In;\n-  }\n-\n-  public String[] getCustom3Like() {\n-    return custom3Like;\n-  }\n-\n-  public String[] getCustom4In() {\n-    return custom4In;\n-  }\n-\n-  public String[] getCustom4Like() {\n-    return custom4Like;\n-  }\n-\n-  public String[] getCustom5In() {\n-    return custom5In;\n-  }\n-\n-  public String[] getCustom5Like() {\n-    return custom5Like;\n-  }\n-\n-  public String[] getCustom6In() {\n-    return custom6In;\n-  }\n-\n-  public String[] getCustom6Like() {\n-    return custom6Like;\n-  }\n-\n-  public String[] getCustom7In() {\n-    return custom7In;\n-  }\n-\n-  public String[] getCustom7Like() {\n-    return custom7Like;\n-  }\n-\n-  public String[] getCustom8In() {\n-    return custom8In;\n-  }\n-\n-  public String[] getCustom8Like() {\n-    return custom8Like;\n-  }\n-\n-  public String[] getCustom9In() {\n-    return custom9In;\n-  }\n-\n-  public String[] getCustom9Like() {\n-    return custom9Like;\n-  }\n-\n-  public String[] getCustom10In() {\n-    return custom10In;\n-  }\n-\n-  public String[] getCustom10Like() {\n-    return custom10Like;\n-  }\n-\n-  public String[] getCustom11In() {\n-    return custom11In;\n-  }\n-\n-  public String[] getCustom11Like() {\n-    return custom11Like;\n-  }\n-\n-  public String[] getCustom12In() {\n-    return custom12In;\n-  }\n-\n-  public String[] getCustom12Like() {\n-    return custom12Like;\n-  }\n-\n-  public String[] getCustom13In() {\n-    return custom13In;\n-  }\n-\n-  public String[] getCustom13Like() {\n-    return custom13Like;\n-  }\n-\n-  public String[] getCustom14In() {\n-    return custom14In;\n-  }\n-\n-  public String[] getCustom14Like() {\n-    return custom14Like;\n-  }\n-\n-  public String[] getCustom15In() {\n-    return custom15In;\n-  }\n-\n-  public String[] getCustom15Like() {\n-    return custom15Like;\n-  }\n-\n-  public String[] getCustom16In() {\n-    return custom16In;\n-  }\n-\n-  public String[] getCustom16Like() {\n-    return custom16Like;\n-  }\n-\n-  public String[] getClassificationCategoryIn() {\n-    return classificationCategoryIn;\n-  }\n-\n-  public String[] getClassificationCategoryLike() {\n-    return classificationCategoryLike;\n-  }\n-\n-  public TimeInterval[] getClaimedIn() {\n-    return claimedIn;\n-  }\n-\n-  public TimeInterval[] getCompletedIn() {\n-    return completedIn;\n-  }\n-\n-  public TimeInterval[] getModifiedIn() {\n-    return modifiedIn;\n+  public TaskQuery orderByAttachmentReference(SortDirection sortDirection) {\n+    joinWithAttachments = true;\n+    addAttachmentColumnsToSelectClauseForOrdering = true;\n+    return addOrderCriteria(\"REF_VALUE\", sortDirection);\n   }\n \n-  public TimeInterval[] getPlannedIn() {\n-    return plannedIn;\n-  }\n+  // endregion\n+  // region attachmentReceived\n \n-  public TimeInterval[] getDueIn() {\n-    return dueIn;\n+  @Override\n+  public TaskQuery attachmentReceivedWithin(TimeInterval... receivedIn) {\n+    validateAllIntervals(receivedIn);\n+    joinWithAttachments = true;\n+    this.attachmentReceivedWithin = receivedIn;\n+    return this;\n   }\n \n-  public String[] getNameLike() {\n-    return nameLike;\n+  @Override\n+  public TaskQuery attachmentNotReceivedWithin(TimeInterval... receivedNotIn) {\n+    validateAllIntervals(receivedNotIn);\n+    joinWithAttachments = true;\n+    this.attachmentReceivedNotWithin = receivedNotIn;\n+    return this;\n   }\n \n-  public String[] getClassificationKeyIn() {\n-    return classificationKeyIn;\n+  @Override\n+  public TaskQuery orderByAttachmentReceived(SortDirection sortDirection) {\n+    joinWithAttachments = true;\n+    addAttachmentColumnsToSelectClauseForOrdering = true;\n+    return DB.isDb2(getDatabaseId())\n+        ? addOrderCriteria(\"ARECEIVED\", sortDirection)\n+        : addOrderCriteria(\"a.RECEIVED\", sortDirection);\n   }\n \n-  public String[] getClassificationKeyNotIn() {\n-    return classificationKeyNotIn;\n-  }\n+  // endregion\n+  // region customAttributes\n \n-  public String[] getClassificationKeyLike() {\n-    return classificationKeyLike;\n-  }\n+  @Override\n+  public TaskQuery customAttributeIn(TaskCustomField customField, String... strings)\n+      throws InvalidArgumentException {\n+    if (strings.length == 0) {\n+      throw new InvalidArgumentException(\n+          \"At least one string has to be provided as a search parameter\");\n+    }\n+    switch (customField) {\n+      case CUSTOM_1:\n+        this.custom1In = strings;\n+        break;\n+      case CUSTOM_2:\n+        this.custom2In = strings;\n+        break;\n+      case CUSTOM_3:\n+        this.custom3In = strings;\n+        break;\n+      case CUSTOM_4:\n+        this.custom4In = strings;\n+        break;\n+      case CUSTOM_5:\n+        this.custom5In = strings;\n+        break;\n+      case CUSTOM_6:\n+        this.custom6In = strings;\n+        break;\n+      case CUSTOM_7:\n+        this.custom7In = strings;\n+        break;\n+      case CUSTOM_8:\n+        this.custom8In = strings;\n+        break;\n+      case CUSTOM_9:\n+        this.custom9In = strings;\n+        break;\n+      case CUSTOM_10:\n+        this.custom10In = strings;\n+        break;\n+      case CUSTOM_11:\n+        this.custom11In = strings;\n+        break;\n+      case CUSTOM_12:\n+        this.custom12In = strings;\n+        break;\n+      case CUSTOM_13:\n+        this.custom13In = strings;\n+        break;\n+      case CUSTOM_14:\n+        this.custom14In = strings;\n+        break;\n+      case CUSTOM_15:\n+        this.custom15In = strings;\n+        break;\n+      case CUSTOM_16:\n+        this.custom16In = strings;\n+        break;\n+      default:\n+        throw new SystemException(\"Unknown custom attribute '\" + customField + \"'\");\n+    }\n \n-  public String[] getClassificationIdIn() {\n-    return classificationIdIn;\n+    return this;\n   }\n \n-  public KeyDomain[] getWorkbasketKeyDomainIn() {\n-    return workbasketKeyDomainIn;\n-  }\n+  @Override\n+  public TaskQuery customAttributeNotIn(TaskCustomField customField, String... strings)\n+      throws InvalidArgumentException {\n+    if (strings.length == 0) {\n+      throw new InvalidArgumentException(\n+          \"At least one string has to be provided as a search parameter\");\n+    }\n+    switch (customField) {\n+      case CUSTOM_1:\n+        this.custom1NotIn = strings;\n+        break;\n+      case CUSTOM_2:\n+        this.custom2NotIn = strings;\n+        break;\n+      case CUSTOM_3:\n+        this.custom3NotIn = strings;\n+        break;\n+      case CUSTOM_4:\n+        this.custom4NotIn = strings;\n+        break;\n+      case CUSTOM_5:\n+        this.custom5NotIn = strings;\n+        break;\n+      case CUSTOM_6:\n+        this.custom6NotIn = strings;\n+        break;\n+      case CUSTOM_7:\n+        this.custom7NotIn = strings;\n+        break;\n+      case CUSTOM_8:\n+        this.custom8NotIn = strings;\n+        break;\n+      case CUSTOM_9:\n+        this.custom9NotIn = strings;\n+        break;\n+      case CUSTOM_10:\n+        this.custom10NotIn = strings;\n+        break;\n+      case CUSTOM_11:\n+        this.custom11NotIn = strings;\n+        break;\n+      case CUSTOM_12:\n+        this.custom12NotIn = strings;\n+        break;\n+      case CUSTOM_13:\n+        this.custom13NotIn = strings;\n+        break;\n+      case CUSTOM_14:\n+        this.custom14NotIn = strings;\n+        break;\n+      case CUSTOM_15:\n+        this.custom15NotIn = strings;\n+        break;\n+      case CUSTOM_16:\n+        this.custom16NotIn = strings;\n+        break;\n+      default:\n+        throw new SystemException(\"Unknown custom attribute '\" + customField + \"'\");\n+    }\n \n-  public String[] getWorkbasketIdIn() {\n-    return workbasketIdIn;\n+    return this;\n   }\n \n-  public TaskQueryColumnName getColumnName() {\n-    return columnName;\n-  }\n+  @Override\n+  public TaskQuery customAttributeLike(TaskCustomField customField, String... strings)\n+      throws InvalidArgumentException {\n+    if (strings.length == 0) {\n+      throw new InvalidArgumentException(\n+          \"At least one string has to be provided as a search parameter\");\n+    }\n \n-  public String[] getAttachmentClassificationKeyIn() {\n-    return attachmentClassificationKeyIn;\n-  }\n+    switch (customField) {\n+      case CUSTOM_1:\n+        this.custom1Like = toUpperCopy(strings);\n+        break;\n+      case CUSTOM_2:\n+        this.custom2Like = toUpperCopy(strings);\n+        break;\n+      case CUSTOM_3:\n+        this.custom3Like = toUpperCopy(strings);\n+        break;\n+      case CUSTOM_4:\n+        this.custom4Like = toUpperCopy(strings);\n+        break;\n+      case CUSTOM_5:\n+        this.custom5Like = toUpperCopy(strings);\n+        break;\n+      case CUSTOM_6:\n+        this.custom6Like = toUpperCopy(strings);\n+        break;\n+      case CUSTOM_7:\n+        this.custom7Like = toUpperCopy(strings);\n+        break;\n+      case CUSTOM_8:\n+        this.custom8Like = toUpperCopy(strings);\n+        break;\n+      case CUSTOM_9:\n+        this.custom9Like = toUpperCopy(strings);\n+        break;\n+      case CUSTOM_10:\n+        this.custom10Like = toUpperCopy(strings);\n+        break;\n+      case CUSTOM_11:\n+        this.custom11Like = toUpperCopy(strings);\n+        break;\n+      case CUSTOM_12:\n+        this.custom12Like = toUpperCopy(strings);\n+        break;\n+      case CUSTOM_13:\n+        this.custom13Like = toUpperCopy(strings);\n+        break;\n+      case CUSTOM_14:\n+        this.custom14Like = toUpperCopy(strings);\n+        break;\n+      case CUSTOM_15:\n+        this.custom15Like = toUpperCopy(strings);\n+        break;\n+      case CUSTOM_16:\n+        this.custom16Like = toUpperCopy(strings);\n+        break;\n+      default:\n+        throw new SystemException(\"Unknown custom field '\" + customField + \"'\");\n+    }\n \n-  public void setAttachmentClassificationKeyIn(String[] attachmentClassificationKeyIn) {\n-    this.attachmentClassificationKeyIn = attachmentClassificationKeyIn;\n+    return this;\n   }\n \n-  public String[] getAttachmentClassificationKeyLike() {\n-    return attachmentClassificationKeyLike;\n-  }\n+  @Override\n+  public TaskQuery customAttributeNotLike(TaskCustomField customField, String... strings)\n+      throws InvalidArgumentException {\n+    if (strings.length == 0) {\n+      throw new InvalidArgumentException(\n+          \"At least one string has to be provided as a search parameter\");\n+    }\n \n-  public void setAttachmentClassificationKeyLike(String[] attachmentClassificationKeyLike) {\n-    this.attachmentClassificationKeyLike = attachmentClassificationKeyLike;\n-  }\n+    switch (customField) {\n+      case CUSTOM_1:\n+        this.custom1NotLike = toUpperCopy(strings);\n+        break;\n+      case CUSTOM_2:\n+        this.custom2NotLike = toUpperCopy(strings);\n+        break;\n+      case CUSTOM_3:\n+        this.custom3NotLike = toUpperCopy(strings);\n+        break;\n+      case CUSTOM_4:\n+        this.custom4NotLike = toUpperCopy(strings);\n+        break;\n+      case CUSTOM_5:\n+        this.custom5NotLike = toUpperCopy(strings);\n+        break;\n+      case CUSTOM_6:\n+        this.custom6NotLike = toUpperCopy(strings);\n+        break;\n+      case CUSTOM_7:\n+        this.custom7NotLike = toUpperCopy(strings);\n+        break;\n+      case CUSTOM_8:\n+        this.custom8NotLike = toUpperCopy(strings);\n+        break;\n+      case CUSTOM_9:\n+        this.custom9NotLike = toUpperCopy(strings);\n+        break;\n+      case CUSTOM_10:\n+        this.custom10NotLike = toUpperCopy(strings);\n+        break;\n+      case CUSTOM_11:\n+        this.custom11NotLike = toUpperCopy(strings);\n+        break;\n+      case CUSTOM_12:\n+        this.custom12NotLike = toUpperCopy(strings);\n+        break;\n+      case CUSTOM_13:\n+        this.custom13NotLike = toUpperCopy(strings);\n+        break;\n+      case CUSTOM_14:\n+        this.custom14NotLike = toUpperCopy(strings);\n+        break;\n+      case CUSTOM_15:\n+        this.custom15NotLike = toUpperCopy(strings);\n+        break;\n+      case CUSTOM_16:\n+        this.custom16NotLike = toUpperCopy(strings);\n+        break;\n+      default:\n+        throw new SystemException(\"Unknown custom field '\" + customField + \"'\");\n+    }\n \n-  public String[] getAttachmentClassificationIdIn() {\n-    return attachmentClassificationIdIn;\n+    return this;\n   }\n \n-  public void setAttachmentClassificationIdIn(String[] attachmentClassificationIdIn) {\n-    this.attachmentClassificationIdIn = attachmentClassificationIdIn;\n+  @Override\n+  public TaskQuery orderByCustomAttribute(\n+      TaskCustomField customField, SortDirection sortDirection) {\n+    return addOrderCriteria(customField.name(), sortDirection);\n   }\n \n-  public String[] getAttachmentClassificationIdLike() {\n-    return attachmentClassificationIdLike;\n-  }\n+  // endregion\n+  // region callbackState\n \n-  public void setAttachmentClassificationIdLike(String[] attachmentclassificationIdLike) {\n-    this.attachmentClassificationIdLike = attachmentclassificationIdLike;\n+  @Override\n+  public TaskQuery callbackStateIn(CallbackState... states) {\n+    this.callbackStateIn = states;\n+    return this;\n   }\n \n-  public String[] getAttachmentChannelIn() {\n-    return attachmentChannelIn;\n+  @Override\n+  public TaskQuery callbackStateNotIn(CallbackState... states) {\n+    this.callbackStateNotIn = states;\n+    return this;\n   }\n \n-  public void setAttachmentChannelIn(String[] attachmentChannelIn) {\n-    this.attachmentChannelIn = attachmentChannelIn;\n-  }\n+  // endregion\n+  // region wildcardSearchValue\n \n-  public String[] getAttachmentChannelLike() {\n-    return attachmentChannelLike;\n+  @Override\n+  public TaskQuery wildcardSearchValueLike(String wildcardSearchValue) {\n+    this.wildcardSearchValueLike = wildcardSearchValue.toUpperCase();\n+    return this;\n   }\n \n-  public void setAttachmentChannelLike(String[] attachmentChannelLike) {\n-    this.attachmentChannelLike = attachmentChannelLike;\n+  @Override\n+  public TaskQuery wildcardSearchFieldsIn(WildcardSearchField... wildcardSearchFields) {\n+    this.wildcardSearchFieldIn = wildcardSearchFields;\n+    return this;\n   }\n \n-  public String[] getAttachmentReferenceIn() {\n-    return attachmentReferenceIn;\n-  }\n+  // endregion\n \n-  public void setAttachmentReferenceIn(String[] attachmentReferenceIn) {\n-    this.attachmentReferenceIn = attachmentReferenceIn;\n+  @Override\n+  public ObjectReferenceQuery createObjectReferenceQuery() {\n+    return new ObjectReferenceQueryImpl(taskanaEngine);\n   }\n \n-  public String[] getAttachmentReferenceLike() {\n-    return attachmentReferenceLike;\n+  @Override\n+  public TaskQuery orderByDomain(SortDirection sortDirection) {\n+    return addOrderCriteria(\"DOMAIN\", sortDirection);\n   }\n \n-  public void setAttachmentReferenceLike(String[] attachmentReferenceLike) {\n-    this.attachmentReferenceLike = attachmentReferenceLike;\n+  @Override\n+  public TaskQuery orderByWorkbasketKey(SortDirection sortDirection) {\n+    return addOrderCriteria(\"WORKBASKET_KEY\", sortDirection);\n   }\n \n-  public TimeInterval[] getAttachmentReceivedIn() {\n-    return attachmentReceivedIn;\n+  @Override\n+  public TaskQuery orderByWorkbasketName(SortDirection sortDirection) {\n+    joinWithWorkbaskets = true;\n+    addWorkbasketNameToSelectClauseForOrdering = true;\n+    return DB.DB2.dbProductId.equals(getDatabaseId())\n+        ? addOrderCriteria(\"WNAME\", sortDirection)\n+        : addOrderCriteria(\"w.NAME\", sortDirection);\n   }\n \n-  public void setAttachmentReceivedIn(TimeInterval[] attachmentReceivedIn) {\n-    this.attachmentReceivedIn = attachmentReceivedIn;\n-  }\n+  @Override\n+  public List<TaskSummary> list() {\n+    return taskanaEngine.executeInDatabaseConnection(\n+        () -> {\n+          checkForIllegalParamCombinations();\n+          checkOpenAndReadPermissionForSpecifiedWorkbaskets();\n+          setupJoinAndOrderParameters();\n+          setupAccessIds();\n+          List<TaskSummaryImpl> tasks =\n+              taskanaEngine.getSqlSession().selectList(getLinkToMapperScript(), this);\n \n-  public String[] getClassificationNameIn() {\n-    return classificationNameIn;\n+          return taskService.augmentTaskSummariesByContainedSummariesWithPartitioning(tasks);\n+        });\n   }\n \n-  public void setClassificationNameIn(String[] classificationNameIn) {\n-    this.classificationNameIn = classificationNameIn;\n+  @Override\n+  public List<TaskSummary> list(int offset, int limit) {\n+    List<TaskSummary> result;\n+    try {\n+      taskanaEngine.openConnection();\n+      checkForIllegalParamCombinations();\n+      checkOpenAndReadPermissionForSpecifiedWorkbaskets();\n+      setupAccessIds();\n+      setupJoinAndOrderParameters();\n+      RowBounds rowBounds = new RowBounds(offset, limit);\n+      List<TaskSummaryImpl> tasks =\n+          taskanaEngine.getSqlSession().selectList(getLinkToMapperScript(), this, rowBounds);\n+      result = taskService.augmentTaskSummariesByContainedSummariesWithPartitioning(tasks);\n+      return result;\n+    } catch (PersistenceException e) {\n+      if (e.getMessage().contains(\"ERRORCODE=-4470\")) {\n+        TaskanaRuntimeException ex =\n+            new SystemException(\n+                \"The offset beginning was set over the amount of result-rows.\", e.getCause());\n+        ex.setStackTrace(e.getStackTrace());\n+        throw ex;\n+      }\n+      throw e;\n+    } finally {\n+      taskanaEngine.returnConnection();\n+    }\n   }\n \n-  public String[] getClassificationNameLike() {\n-    return classificationNameLike;\n-  }\n+  @Override\n+  public List<String> listValues(TaskQueryColumnName columnName, SortDirection sortDirection) {\n+    List<String> result;\n+    try {\n+      taskanaEngine.openConnection();\n+      this.columnName = columnName;\n+      this.orderBy.clear();\n+      this.addOrderCriteria(columnName.toString(), sortDirection);\n+      checkForIllegalParamCombinations();\n+      checkOpenAndReadPermissionForSpecifiedWorkbaskets();\n+      setupAccessIds();\n \n-  public void setClassificationNameLike(String[] classificationNameLike) {\n-    this.classificationNameLike = classificationNameLike;\n-  }\n+      if (columnName.equals(TaskQueryColumnName.CLASSIFICATION_NAME)) {\n+        joinWithClassifications = true;\n+      }\n \n-  public String[] getAttachmentClassificationNameIn() {\n-    return attachmentClassificationNameIn;\n-  }\n+      if (columnName.equals(TaskQueryColumnName.A_CLASSIFICATION_NAME)) {\n+        joinWithAttachmentClassifications = true;\n+      }\n \n-  public void setAttachmentClassificationNameIn(String[] attachmentClassificationNameIn) {\n-    this.attachmentClassificationNameIn = attachmentClassificationNameIn;\n-  }\n+      if (columnName.isAttachmentColumn()) {\n+        joinWithAttachments = true;\n+      }\n \n-  public String[] getAttachmentClassificationNameLike() {\n-    return attachmentClassificationNameLike;\n+      setupJoinAndOrderParameters();\n+      result = taskanaEngine.getSqlSession().selectList(LINK_TO_VALUE_MAPPER, this);\n+      return result;\n+    } finally {\n+      taskanaEngine.returnConnection();\n+    }\n   }\n \n-  public void setAttachmentClassificationNameLike(String[] attachmentClassificationNameLike) {\n-    this.attachmentClassificationNameLike = attachmentClassificationNameLike;\n-  }\n+  @Override\n+  public TaskSummary single() {\n+    TaskSummary result;\n+    try {\n+      taskanaEngine.openConnection();\n+      checkOpenAndReadPermissionForSpecifiedWorkbaskets();\n+      setupAccessIds();\n+      setupJoinAndOrderParameters();\n+      TaskSummaryImpl taskSummaryImpl =\n+          taskanaEngine.getSqlSession().selectOne(getLinkToMapperScript(), this);\n+      if (taskSummaryImpl == null) {\n+        return null;\n+      }\n+      List<TaskSummaryImpl> tasks = new ArrayList<>();\n+      tasks.add(taskSummaryImpl);\n+      List<TaskSummary> augmentedList =\n+          taskService.augmentTaskSummariesByContainedSummariesWithPartitioning(tasks);\n+      result = augmentedList.get(0);\n \n-  public boolean isAddClassificationNameToSelectClauseForOrdering() {\n-    return addClassificationNameToSelectClauseForOrdering;\n+      return result;\n+    } finally {\n+      taskanaEngine.returnConnection();\n+    }\n   }\n \n-  public void setAddClassificationNameToSelectClauseForOrdering(\n-      boolean addClassificationNameToSelectClauseForOrdering) {\n-    this.addClassificationNameToSelectClauseForOrdering =\n-        addClassificationNameToSelectClauseForOrdering;\n+  @Override\n+  public long count() {\n+    Long rowCount;\n+    try {\n+      taskanaEngine.openConnection();\n+      checkOpenAndReadPermissionForSpecifiedWorkbaskets();\n+      setupAccessIds();\n+      setupJoinAndOrderParameters();\n+      rowCount = taskanaEngine.getSqlSession().selectOne(getLinkToCounterTaskScript(), this);\n+      return (rowCount == null) ? 0L : rowCount;\n+    } finally {\n+      taskanaEngine.returnConnection();\n+    }\n   }\n \n-  public boolean isAddAttachmentClassificationNameToSelectClauseForOrdering() {\n-    return addAttachmentClassificationNameToSelectClauseForOrdering;\n+  public TaskQuery selectAndClaimEquals(boolean selectAndClaim) {\n+    this.selectAndClaim = selectAndClaim;\n+    return this;\n   }\n \n-  public void setAddAttachmentClassificationNameToSelectClauseForOrdering(\n-      boolean addAttachmentClassificationNameToSelectClauseForOrdering) {\n-    this.addAttachmentClassificationNameToSelectClauseForOrdering =\n-        addAttachmentClassificationNameToSelectClauseForOrdering;\n+  // optimized query for db2 can't be used for now in case of selectAndClaim because of temporary\n+  // tables and the \"for update\" clause clashing in db2\n+  private String getLinkToMapperScript() {\n+    if (DB.isDb2(getDatabaseId()) && !selectAndClaim) {\n+      return LINK_TO_MAPPER_DB2;\n+    } else {\n+      return LINK_TO_MAPPER;\n+    }\n   }\n \n-  public WildcardSearchField[] getWildcardSearchFieldIn() {\n-    return wildcardSearchFieldIn;\n+  private String getLinkToCounterTaskScript() {\n+    return DB.isDb2(getDatabaseId()) ? LINK_TO_COUNTER_DB2 : LINK_TO_COUNTER;\n   }\n \n-  public String getWildcardSearchValueLike() {\n-    return wildcardSearchValueLike;\n+  private void validateAllIntervals(TimeInterval[] intervals) {\n+    for (TimeInterval ti : intervals) {\n+      if (!ti.isValid()) {\n+        throw new IllegalArgumentException(\"TimeInterval \" + ti + \" is invalid.\");\n+      }\n+    }\n   }\n \n   private void checkForIllegalParamCombinations() {\n-\n-    if ((wildcardSearchValueLike != null && wildcardSearchFieldIn == null)\n-        || (wildcardSearchValueLike == null && wildcardSearchFieldIn != null)) {\n+    if (wildcardSearchValueLike != null ^ wildcardSearchFieldIn != null) {\n       throw new IllegalArgumentException(\n           \"The params \\\"wildcardSearchFieldIn\\\" and \\\"wildcardSearchValueLike\\\"\"\n               + \" must be used together!\");\n", "next_change": {"commit": "a23060ba64e0e3873ccb558d174c364348342224", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskQueryImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskQueryImpl.java\nindex 54d794f12..8b12aeac5 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskQueryImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskQueryImpl.java\n", "chunk": "@@ -1768,6 +2096,31 @@ public class TaskQueryImpl implements TaskQuery {\n           \"The params \\\"wildcardSearchFieldIn\\\" and \\\"wildcardSearchValueLike\\\"\"\n               + \" must be used together!\");\n     }\n+    if (withoutAttachment\n+        && (attachmentChannelIn != null\n+            || attachmentChannelLike != null\n+            || attachmentChannelNotIn != null\n+            || attachmentChannelNotLike != null\n+            || attachmentClassificationIdIn != null\n+            || attachmentClassificationIdNotIn != null\n+            || attachmentClassificationKeyIn != null\n+            || attachmentClassificationKeyLike != null\n+            || attachmentClassificationKeyNotIn != null\n+            || attachmentClassificationKeyNotLike != null\n+            || attachmentClassificationNameIn != null\n+            || attachmentClassificationNameLike != null\n+            || attachmentClassificationNameNotIn != null\n+            || attachmentClassificationNameNotLike != null\n+            || attachmentReceivedWithin != null\n+            || attachmentReceivedNotWithin != null\n+            || attachmentReferenceIn != null\n+            || attachmentReferenceLike != null\n+            || attachmentReferenceNotIn != null\n+            || attachmentReferenceNotLike != null)) {\n+      throw new IllegalArgumentException(\n+          \"The param \\\"withoutAttachment\\\" can only be used \"\n+              + \"without adding attributes of attachment as filter parameter\");\n+    }\n   }\n \n   private String getDatabaseId() {\n", "next_change": {"commit": "b2be25e2ef99a816d60d66b7db335b8727b9effc", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskQueryImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskQueryImpl.java\nindex 8b12aeac5..06dc125ee 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskQueryImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskQueryImpl.java\n", "chunk": "@@ -2123,8 +2131,8 @@ public class TaskQueryImpl implements TaskQuery {\n     }\n   }\n \n-  private String getDatabaseId() {\n-    return this.taskanaEngine.getSqlSession().getConfiguration().getDatabaseId();\n+  private DB getDB() {\n+    return DB.getDB(this.taskanaEngine.getSqlSession().getConfiguration().getDatabaseId());\n   }\n \n   private void setupJoinAndOrderParameters() {\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "969d3eeff653d51eb7dcf5234aa4020333613ab3", "message": "Merge commit", "committedDate": null}, {"oid": "7cc5b00be617227dac2f8d1210554108d18bad4a", "committedDate": "2020-07-24 01:05:42 +0200", "message": "TSK-1345: replaced every customField API call with CustomField enums"}, {"oid": "41973183bcb5211ef940e834f81e74321323d996", "committedDate": "2020-08-07 14:59:19 +0200", "message": "TSK-1337: removed some code smells"}, {"oid": "fa19359795aa52f81bdd7b42d60a0b4b3e37eac1", "committedDate": "2020-09-15 15:59:00 +0200", "message": "TSK-1387: TaskQuery now supports combining multiple values for objectreference"}, {"oid": "44cb21b5aec13e6548a0546dc8eb221fb1cd29ad", "committedDate": "2020-10-09 10:25:54 +0200", "message": "TSK-1277: removed circular dependency between taskana-common and taskana-core"}, {"oid": "0c084dc3d86e62b54f3cbf8facd99d6a6a775d02", "committedDate": "2020-12-02 23:24:08 +0100", "message": "TSK-1443: Implemented an option to order the result of the TaskQuery by the Workbasket-Name."}, {"oid": "70a3ade7f23d12dc4a2bb4fdf7b7010c9423f493", "committedDate": "2020-12-02 23:24:08 +0100", "message": "TSK-1443: improvements after review"}, {"oid": "0dc26f5fe163763e03b22373dec4c22a5fb6e107", "committedDate": "2021-01-05 14:53:34 +0100", "message": "TSK-1472: Replaced the DB check with productName by productId (#1353)"}, {"oid": "c6e82c1368da17762918b1ef5102974a302124af", "committedDate": "2021-02-02 08:16:07 +0100", "message": "TSK-1506: Fixed bug for Cleanup Jobs with more than 32767 tasks (#1457)"}, {"oid": "330d6f9e195d0d599a11432020c38d7ee301c691", "committedDate": "2021-03-01 09:10:13 +0100", "message": "TSK-1565: Make Wildcard Queries Case insensitive"}, {"oid": "bfcabea61048ccb21a591e0c4f1f8efecc7636b4", "committedDate": "2021-05-20 09:41:58 +0200", "message": "TSK-1596: Automatic TraceLogging (#1577)"}, {"oid": "dd5bccc62ca2f97c28ec7bef9c9639635e8c8d7f", "committedDate": "2021-06-10 10:49:53 +0200", "message": "TSK-1654: fixed current code smells"}, {"oid": "34d2bbfa929ccaa9e9b93c173b8fa867154330bb", "committedDate": "2021-07-14 10:49:34 +0200", "message": "TSK-1647: Implemented an error key for every exception"}, {"oid": "375a92291d41c6c90b403055ac5228ccd309621a", "committedDate": "2021-07-15 14:03:00 +0200", "message": "TSK-1658: Created TaskQueryMapperSqlProvider"}, {"oid": "1eb3ccec7836b2eeb5eadce8ec759b8b6ab91078", "committedDate": "2021-07-15 14:03:00 +0200", "message": "TSK-1658: PR amends"}, {"oid": "99eba636a1ec363282153ae857f651d2c5d2e592", "committedDate": "2021-07-29 14:58:57 +0200", "message": "TSK-1674: Added received timestamp to task (#1638)"}, {"oid": "55d21a9e8b82b363e50140a6cec48ffe347e2fd9", "committedDate": "2021-08-02 16:42:09 +0200", "message": "TSK-1649: implemented database lock for resolution of jobs to run"}, {"oid": "e564778a9137bdb7cf7898a1bf5f200d22da39f5", "committedDate": "2021-08-31 13:00:00 +0200", "message": "TSK-1715: Implemented OwnerNotIn-Filter for TaskQuery."}, {"oid": "e57972071605d24b856ec03db3dc17e9ca0556c0", "committedDate": "2021-09-16 14:20:50 +0200", "message": "TSK-1731: Fix TaskQuery to order correctly by attachment received"}, {"oid": "1bab31e43c844b6808230cda86126cc933bdacb9", "committedDate": "2021-10-05 13:28:26 +0200", "message": "TSK-1727: + TSK-1624: Add notLike and notIn filter parameter to TaskQuery"}, {"oid": "e264a203892c6d2111df4645abf7f373bf4ca86a", "committedDate": "2021-10-08 08:38:21 +0200", "message": "TSK-1726: Implemented option to include long name on Task / TaskComment / TaskHistoryEvent"}, {"oid": "23919eb0a112f0fa6fefd13f39c59c5f78e7f0a5", "committedDate": "2021-11-03 15:22:56 +0100", "message": "TSK-1762: fixed some code smells"}, {"oid": "2c89353fc7ee964ec79367be4e7abe698fa271c3", "committedDate": "2021-11-22 10:03:56 +0100", "message": "TSK-1769: TaskQuery on CustomFields distinguishes between empty / null."}, {"oid": "967e59e012f94e116f2b327b6c426f44ae1bcbee", "committedDate": "2022-02-25 10:23:40 +0100", "message": "TSK-1800: add secondary object references"}, {"oid": "6dda569f1624cf3e0c6063375187e23f2c4214a3", "committedDate": "2022-02-28 11:26:53 +0100", "message": "TSK-1753: case insensitive queries are performed on lower case"}, {"oid": "a23060ba64e0e3873ccb558d174c364348342224", "committedDate": "2022-06-01 12:15:03 +0200", "message": "TSK-1836: add withoutAttachment as query parameter in REST and taskana-core"}, {"oid": "1f4c3ad5fbe4afdcc7e470d4ec7aee6773df5ff8", "committedDate": "2022-06-22 11:35:25 +0200", "message": "removed region comments from TaskQueryImpl"}, {"oid": "18ee26ba8065a8912eb23740e33a3e2652908d7c", "committedDate": "2022-08-02 14:35:13 +0200", "message": "TSK-1837: Add custom_int fields and standard operations on them"}, {"oid": "803b4b20a202439ac5c4b9c93ffbb22530e93d23", "committedDate": "2022-08-02 14:35:13 +0200", "message": "TSK-1837: Add within and notWithin filter criteria"}, {"oid": "70c64dd66e28d36bd7e8f38c88fcfbe70473ed0f", "committedDate": "2022-08-02 14:35:13 +0200", "message": "TSK-1837: Add custom-int-x-from and custom-int-x-to to rest"}, {"oid": "0b4445b97b221e199b92031eb58652a8f6b6c279", "committedDate": "2022-08-09 13:17:48 +0200", "message": "TSK-1923: clean parameter names in Query entities"}, {"oid": "291cc38ea671e3fd23d8296008192f63f9d73c32", "committedDate": "2023-02-13 08:00:43 +0100", "message": "TSK-1971 support for oracle databases (#2050)"}, {"oid": "3dbf98bf9209bd36b7ac7d3a0b74b7d0e422b66f", "committedDate": "2023-02-16 12:17:13 +0100", "message": "TSK-2000: add filtering by classification parent key"}, {"oid": "73fed96627a4de075df11e3ef0c85b6ce107e241", "committedDate": "2023-03-03 12:56:38 +0100", "message": "TSK-2001: add filtering by priorityWithin and notWithin"}, {"oid": "61a5e32865fcbbaafa0bc0a09cb4218132cfd4a9", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-1987 immutable TaskanaEngineConfiguration"}, {"oid": "20d389a7d524c156b063dfc91589bb22bebea0d7", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-1992 remove unnecessary ParentExceptions"}, {"oid": "b2be25e2ef99a816d60d66b7db335b8727b9effc", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-1997: refactoring DB Enum"}, {"oid": "d21eb47ffea4c2c9fff8f1d3435b77b805d03508", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-2012: renamed Mismatched_Exceptions to NotAuthorizedExceptions"}, {"oid": "55d939ca7b7720ab12f488ed8fc2a631ecc6f05c", "committedDate": "2023-03-13 19:02:53 +0100", "message": "format entire codebase with new google-java-format version"}, {"oid": "d96b1c392a0f9ecfe72e7d0bc0aadac17620133c", "committedDate": "2023-03-15 01:00:50 +0100", "message": "TSK-1991: rework of property names"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY1MjUyMw==", "url": "https://github.com/Taskana/taskana/pull/1150#discussion_r446652523", "body": "why SystemException? According to JavaDoc I expected a \"TaskNotFoundExeption\"", "bodyText": "why SystemException? According to JavaDoc I expected a \"TaskNotFoundExeption\"", "bodyHTML": "<p dir=\"auto\">why SystemException? According to JavaDoc I expected a \"TaskNotFoundExeption\"</p>", "author": "mustaphazorgati", "createdAt": "2020-06-28T13:40:30Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java", "diffHunk": "@@ -477,6 +477,37 @@ public void forceDeleteTask(String taskId)\n     deleteTask(taskId, true);\n   }\n \n+  @Override\n+  public Task selectAndClaim(TaskQuery taskQuery)\n+      throws TaskNotFoundException, NotAuthorizedException, InvalidStateException,\n+          InvalidOwnerException {\n+\n+    if (LOGGER.isDebugEnabled()) {\n+      LOGGER.debug(\"entry to selectAndClaim(taskQuery = {})\", taskQuery);\n+    }\n+\n+    try {\n+\n+      taskanaEngine.openConnection();\n+\n+      ((TaskQueryImpl) taskQuery).selectAndClaimEquals(true);\n+\n+      TaskSummary taskSummary = taskQuery.single();\n+\n+      if (taskSummary == null) {\n+        throw new SystemException(\n+            \"No tasks matched the specified filter and sorting options,\"\n+                + \" task query returned nothing!\");\n+      }", "originalCommit": "f1991ad4316cd8de239ba6cd0cc57caa70f1bddb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc4MTQ0MA==", "url": "https://github.com/Taskana/taskana/pull/1150#discussion_r446781440", "bodyText": "The TaskNotFoundException from JavaDoc is inherited from the claim() call. While I would agree that in case of a null return from the query a TaskNotFoundException seems logical, it needs an id, which we usually won't have here, we only got a query (assuming taskIdIn is not always set).", "author": "gitgoodjhe", "createdAt": "2020-06-29T05:33:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY1MjUyMw=="}], "type": "inlineReview", "revised_code": {"commit": "808d5e604539f2f4e5e13e86b00c627a78e1b762", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 985fd2b07..442074ec6 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -502,6 +501,8 @@ public class TaskServiceImpl implements TaskService {\n \n       return claim(taskSummary.getId());\n \n+    } catch (InvalidStateException | TaskNotFoundException e) {\n+      throw new SystemException(\"Caught exception \", e);\n     } finally {\n       LOGGER.debug(\"exit from selectAndClaim()\");\n       taskanaEngine.returnConnection();\n", "next_change": null}]}, "revised_code_in_main": {"commit": "969d3eeff653d51eb7dcf5234aa4020333613ab3", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 985fd2b07..442074ec6 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -502,6 +501,8 @@ public class TaskServiceImpl implements TaskService {\n \n       return claim(taskSummary.getId());\n \n+    } catch (InvalidStateException | TaskNotFoundException e) {\n+      throw new SystemException(\"Caught exception \", e);\n     } finally {\n       LOGGER.debug(\"exit from selectAndClaim()\");\n       taskanaEngine.returnConnection();\n", "next_change": {"commit": "bfcabea61048ccb21a591e0c4f1f8efecc7636b4", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 442074ec6..ad45e047c 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -504,7 +499,6 @@ public class TaskServiceImpl implements TaskService {\n     } catch (InvalidStateException | TaskNotFoundException e) {\n       throw new SystemException(\"Caught exception \", e);\n     } finally {\n-      LOGGER.debug(\"exit from selectAndClaim()\");\n       taskanaEngine.returnConnection();\n     }\n   }\n", "next_change": {"commit": "20d389a7d524c156b063dfc91589bb22bebea0d7", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex ad45e047c..8f78eb98d 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -496,7 +604,7 @@ public class TaskServiceImpl implements TaskService {\n \n       return claim(taskSummary.getId());\n \n-    } catch (InvalidStateException | TaskNotFoundException e) {\n+    } catch (TaskNotFoundException | InvalidTaskStateException e) {\n       throw new SystemException(\"Caught exception \", e);\n     } finally {\n       taskanaEngine.returnConnection();\n", "next_change": {"commit": "d21eb47ffea4c2c9fff8f1d3435b77b805d03508", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 8f78eb98d..3990c0591 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -613,7 +609,7 @@ public class TaskServiceImpl implements TaskService {\n \n   @Override\n   public BulkOperationResults<String, TaskanaException> deleteTasks(List<String> taskIds)\n-      throws InvalidArgumentException, MismatchedRoleException {\n+      throws InvalidArgumentException, NotAuthorizedException {\n \n     taskanaEngine.getEngine().checkRoleMembership(TaskanaRole.ADMIN);\n \n", "next_change": null}]}}, {"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex ad45e047c..8f78eb98d 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -505,7 +613,7 @@ public class TaskServiceImpl implements TaskService {\n \n   @Override\n   public BulkOperationResults<String, TaskanaException> deleteTasks(List<String> taskIds)\n-      throws InvalidArgumentException, NotAuthorizedException {\n+      throws InvalidArgumentException, MismatchedRoleException {\n \n     taskanaEngine.getEngine().checkRoleMembership(TaskanaRole.ADMIN);\n \n", "next_change": {"commit": "d21eb47ffea4c2c9fff8f1d3435b77b805d03508", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 8f78eb98d..3990c0591 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -613,7 +609,7 @@ public class TaskServiceImpl implements TaskService {\n \n   @Override\n   public BulkOperationResults<String, TaskanaException> deleteTasks(List<String> taskIds)\n-      throws InvalidArgumentException, MismatchedRoleException {\n+      throws InvalidArgumentException, NotAuthorizedException {\n \n     taskanaEngine.getEngine().checkRoleMembership(TaskanaRole.ADMIN);\n \n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "969d3eeff653d51eb7dcf5234aa4020333613ab3", "message": "Merge commit", "committedDate": null}, {"oid": "d8ad7a7fb96e7d07e5f93e202cd84e03e5c1944a", "committedDate": "2020-07-10 13:13:42 +0200", "message": "TSK-1250 On demand deletion of historical data"}, {"oid": "4bba93c5a98dcbe22dc86144b12507abce4b2be4", "committedDate": "2020-07-10 13:13:42 +0200", "message": "Review findings"}, {"oid": "abced36ecdc2edff824b2857da78581c94c40970", "committedDate": "2020-07-16 11:26:06 +0200", "message": "TSK-1336: Remove unnecessary warn logging in updateTask()"}, {"oid": "7cc5b00be617227dac2f8d1210554108d18bad4a", "committedDate": "2020-07-24 01:05:42 +0200", "message": "TSK-1345: replaced every customField API call with CustomField enums"}, {"oid": "b7237021e2e77fc0648e8117a725220d9560b3d2", "committedDate": "2020-08-05 16:48:33 +0200", "message": "TSK-1333: Add history events for cancelled/terminated tasks"}, {"oid": "29ba5fe418ad6702648d7427d5c18b3fd06bbe83", "committedDate": "2020-08-12 13:27:26 +0200", "message": "TSK-1335: Add workbasket history events"}, {"oid": "198572b6b15d375d99fd565d43cb99888b021e60", "committedDate": "2020-09-23 09:13:40 +0200", "message": "TSK-1390: Add SPI to allow task processing before creation"}, {"oid": "0e83abd0fda3d25585359a4655b1bc1e50429f39", "committedDate": "2020-09-23 09:13:40 +0200", "message": "TSK-1390: Review findings"}, {"oid": "44cb21b5aec13e6548a0546dc8eb221fb1cd29ad", "committedDate": "2020-10-09 10:25:54 +0200", "message": "TSK-1277: removed circular dependency between taskana-common and taskana-core"}, {"oid": "b23c6873db22e24a0b713441317fec405db55708", "committedDate": "2020-10-13 19:58:28 +0200", "message": "TSK-1335: removed last occurences of \"HEI\" prefix for history events"}, {"oid": "039dee4fb21035bcb9ca36e3c0becf59c03fed6c", "committedDate": "2020-11-02 09:41:48 +0100", "message": "TSK-1282: updated taskana-core to jdk11"}, {"oid": "28b3ce6f8a563bf74bf02382b77c3b817085f127", "committedDate": "2020-11-02 09:41:48 +0100", "message": "TSK-1282: replaced all usages of Arrays.asList with List.of"}, {"oid": "81b89e1c08b67fb383605fe061dec07fec4a557a", "committedDate": "2020-11-06 14:53:40 +0100", "message": "TSK-1441: Enable Admin to complete tasks already claimed by other users"}, {"oid": "ab672b27d4593dc7bf179d2e3c107a8a3ae0196f", "committedDate": "2021-01-05 15:27:27 +0100", "message": "TSK-1362: Fixed the test data to not include invalid owners for Workbaskets (#1379)"}, {"oid": "c6e82c1368da17762918b1ef5102974a302124af", "committedDate": "2021-02-02 08:16:07 +0100", "message": "TSK-1506: Fixed bug for Cleanup Jobs with more than 32767 tasks (#1457)"}, {"oid": "aa6d304b499a9df48d90ff3bfc375b25c5f00a71", "committedDate": "2021-02-03 09:34:22 +0100", "message": "TSK-1499: Fixed bug of also cleaning completed tasks with parentProcessId null/empty (#1394)"}, {"oid": "0119999380b40fdc0f69677f96650de5c81bd2a5", "committedDate": "2021-03-09 18:58:51 +0100", "message": "TSK-1538: Added transfer method with control setTransferFlag (#1513)"}, {"oid": "3ddcd2ae97ffea8bd479655e70d5182141d12220", "committedDate": "2021-04-23 17:28:11 +0200", "message": "TSK-1628: New DmnTaskRouter module"}, {"oid": "b8892020d98b905a2e4cbe12a344d93fcc68af25", "committedDate": "2021-05-19 10:29:13 +0200", "message": "TSK-795: Changed Exception when creating a Task with a non-empty taskId (#1575)"}, {"oid": "bfcabea61048ccb21a591e0c4f1f8efecc7636b4", "committedDate": "2021-05-20 09:41:58 +0200", "message": "TSK-1596: Automatic TraceLogging (#1577)"}, {"oid": "7636ec0b2a8e12ea5b3cff48f7b702472b603e5d", "committedDate": "2021-06-01 09:51:38 +0200", "message": "TSK-1501: TaskTransferrer cleaned and restructured (#1599)"}, {"oid": "b66e4d9f862a14fc740e1c25c00e80e81c74abe9", "committedDate": "2021-06-09 12:37:56 +0200", "message": "TSK-1642: now setting details attribute for TaskTransferHistoryEvent"}, {"oid": "1c83b7871f144cd07a912639b942d5938219e101", "committedDate": "2021-06-22 16:14:09 +0200", "message": "TSK-1646: Bugfix for creation / update of Task with invalid Attachment"}, {"oid": "34d2bbfa929ccaa9e9b93c173b8fa867154330bb", "committedDate": "2021-07-14 10:49:34 +0200", "message": "TSK-1647: Implemented an error key for every exception"}, {"oid": "8edb488bd3f854568dab1ee56c8d974fe63f95cd", "committedDate": "2021-07-14 10:49:34 +0200", "message": "TSK-1647: Implemented global frontend error handling using backend error keys"}, {"oid": "358e699f9f0bdf8505ff0f44ac0ad5803cdcb5c8", "committedDate": "2021-07-16 11:08:05 +0200", "message": "TSK-1664: fixed some code smells and redesigned RestHelper"}, {"oid": "99eba636a1ec363282153ae857f651d2c5d2e592", "committedDate": "2021-07-29 14:58:57 +0200", "message": "TSK-1674: Added received timestamp to task (#1638)"}, {"oid": "6da07b069aae2d41a5b9949ea69b249e9ff7903a", "committedDate": "2021-08-02 11:46:33 +0200", "message": "TSK-1647: minor improvements and fixes"}, {"oid": "dc9e3a25ce9aa317ace656ebe58bdcfefaa8c4b5", "committedDate": "2021-08-20 21:21:57 +0200", "message": "TSK-1686: Introduced an SPI for the individual calculation of priorities"}, {"oid": "54428045dd57a6d295c9a1529274b08246c731eb", "committedDate": "2021-08-30 14:18:38 +0200", "message": "TSK-1718: Performance optimization for TaskService#getTask and TaskQuery#list"}, {"oid": "e9a1f02c2e828a123b191cc031bd473ba0e51fe7", "committedDate": "2021-09-16 09:21:29 +0200", "message": "TSK-1633: created all new test API for improved test data generation"}, {"oid": "fb4234b6f180423c4789ba904709fd78edf7bf4f", "committedDate": "2021-09-21 16:35:58 +0200", "message": "TSK-1704: test API now restricting service providers to specific test"}, {"oid": "e264a203892c6d2111df4645abf7f373bf4ca86a", "committedDate": "2021-10-08 08:38:21 +0200", "message": "TSK-1726: Implemented option to include long name on Task / TaskComment / TaskHistoryEvent"}, {"oid": "c7742b3056f4c2d11ff4ddeef980e177bb82bd64", "committedDate": "2021-11-26 13:18:27 +0100", "message": "TSK-1775: reformatted entire backend code base"}, {"oid": "967e59e012f94e116f2b327b6c426f44ae1bcbee", "committedDate": "2022-02-25 10:23:40 +0100", "message": "TSK-1800: add secondary object references"}, {"oid": "4f48fe93c633e31304fa808a96c3477d78b33f2c", "committedDate": "2022-03-08 17:10:37 +0100", "message": "TSK-1807: renamed setCustomAttribute to setCustomField"}, {"oid": "93d0b27bb058a4f47218177136bce81f99103345", "committedDate": "2022-04-26 15:27:56 +0200", "message": "TSK-1831: dropped support for JDK8"}, {"oid": "1ae1df890848d22617cd10c611e5d496428db790", "committedDate": "2022-05-19 09:31:13 +0200", "message": "TSK-1889: create TASK_ROUTER role"}, {"oid": "43ed441daf60d22a579d93fde840861770b4ede5", "committedDate": "2022-05-31 16:54:29 +0300", "message": "TSK-1812: Added details in task-history for claim/cancel"}, {"oid": "83890ddd16249632546e83011cf41759ddccb7da", "committedDate": "2022-07-19 15:27:44 +0200", "message": "TSK-1914: introduce IN_REVIEW and READY_FOR_REVIEW Task status"}, {"oid": "ef875dd42a58b55bace25fb4f599d84e4d06b59b", "committedDate": "2022-08-06 14:30:59 +0200", "message": "TSK-1915: Add requestReview functionality"}, {"oid": "cc32b10d82b7888ed2eae438100d2e26fb508f0c", "committedDate": "2022-08-09 13:19:02 +0200", "message": "TSK-1916: Add requestChanges functionality"}, {"oid": "1f9d20f76f98974ec6fe5fcc4657277f6eaaf5ae", "committedDate": "2022-08-10 12:18:14 +0200", "message": "TSK-1937: implemented AfterRequestReviewProvider"}, {"oid": "340236c4a26c7f9e6ed01d9b0f88b539eced56e3", "committedDate": "2022-08-11 12:17:08 +0200", "message": "TSK-1938: Add RequestChangesProvider"}, {"oid": "cf690bf6b5d8533ab73cef4de923797a1701a5c3", "committedDate": "2022-08-11 12:36:39 +0200", "message": "TSK-1941: implemented ReviewRequired SPI"}, {"oid": "1188f6396c31c6dd2d9f0eae5e6b3f5689a38966", "committedDate": "2022-08-20 17:46:27 +0200", "message": "TSK-1945: implemented BeforeRequestReview SPI"}, {"oid": "151d23d98d598b4a8da946655519664c7b7b4490", "committedDate": "2022-08-20 17:46:27 +0200", "message": "TSK-1945: minor cleanup of TaskServiceImpl"}, {"oid": "d8ffdb1824ffb6d67e417e798ad4ad9f8ee3a866", "committedDate": "2022-08-20 18:16:23 +0200", "message": "TSK-1944: Implemented BeforeRequestChanges SPI"}, {"oid": "3575b8aa17cb4168776b0377f4df81938c24e7b4", "committedDate": "2022-08-24 12:32:26 +0200", "message": "TSK-1926: Remove duplicate from TaskServiceImpl"}, {"oid": "dc9e2e1d5fd04dda9bde2a7838f2e068e66db984", "committedDate": "2022-10-20 21:49:16 +0200", "message": "TSK-1967: make owner of Task updatable when Task is 'READY_FOR_REVIEW'"}, {"oid": "f25b6eb550bc0f9e56c9a7953d5f2d3fbfa3e0d0", "committedDate": "2023-02-09 14:18:56 +0100", "message": "fix resquestReview for an IN_REVIEW Task"}, {"oid": "291cc38ea671e3fd23d8296008192f63f9d73c32", "committedDate": "2023-02-13 08:00:43 +0100", "message": "TSK-1971 support for oracle databases (#2050)"}, {"oid": "8bfb7fae95ef4e4bf7609b6f8f552579f2f9fd2c", "committedDate": "2023-02-14 09:40:46 +0100", "message": "TSK-1977: fix setting ownerLongName while claiming"}, {"oid": "68eacbbc3e1ff9a0a6d667b25cb80ec88558bb06", "committedDate": "2023-02-14 13:57:06 +0100", "message": "TSK-1976: set ownerLongName during Task creation"}, {"oid": "61a5e32865fcbbaafa0bc0a09cb4218132cfd4a9", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-1987 immutable TaskanaEngineConfiguration"}, {"oid": "20d389a7d524c156b063dfc91589bb22bebea0d7", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-1992 remove unnecessary ParentExceptions"}, {"oid": "f9e6b268177eee452e04ef708d50a33be18305e7", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-1993 InvalidArgumentException extends TaskanaRuntimeException"}, {"oid": "4a42a35a212f6bd25839432f48ec813c106874fc", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-1972: calculates working time in any resolution"}, {"oid": "d21eb47ffea4c2c9fff8f1d3435b77b805d03508", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-2012: renamed Mismatched_Exceptions to NotAuthorizedExceptions"}, {"oid": "37280cc73b83e2d39ab4afddd40256719d64c50c", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-2013 selectAndClaim TasK return Optional and does not throw Exception if Task is notFound"}, {"oid": "55d939ca7b7720ab12f488ed8fc2a631ecc6f05c", "committedDate": "2023-03-13 19:02:53 +0100", "message": "format entire codebase with new google-java-format version"}, {"oid": "d96b1c392a0f9ecfe72e7d0bc0aadac17620133c", "committedDate": "2023-03-15 01:00:50 +0100", "message": "TSK-1991: rework of property names"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY1MjcxOQ==", "url": "https://github.com/Taskana/taskana/pull/1150#discussion_r446652719", "body": "```suggestion\r\n    assertThat(selectedAndClaimedTasks)\r\n        .extracting(Task::getId)\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assertThat(selectedAndClaimedTasks.stream().map(Task::getId))\n          \n          \n            \n                assertThat(selectedAndClaimedTasks)\n          \n          \n            \n                    .extracting(Task::getId)", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    assertThat(selectedAndClaimedTasks<span class=\"pl-k x x-first\">.</span><span class=\"x\">stream()</span><span class=\"pl-k x\">.</span><span class=\"x\">map(</span><span class=\"pl-smi x\">Task</span><span class=\"pl-k x\">::</span><span class=\"x x-last\">getId)</span>)</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    assertThat(selectedAndClaimedTasks)</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        .extracting(<span class=\"pl-smi\">Task</span><span class=\"pl-k\">::</span>getId)</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "mustaphazorgati", "createdAt": "2020-06-28T13:42:33Z", "path": "lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package acceptance.task;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import acceptance.AbstractAccTest;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.security.auth.Subject;\n+import org.assertj.core.api.ThrowableAssert.ThrowingCallable;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import pro.taskana.common.api.BaseQuery.SortDirection;\n+import pro.taskana.common.api.exceptions.SystemException;\n+import pro.taskana.common.internal.security.JaasExtension;\n+import pro.taskana.common.internal.security.UserPrincipal;\n+import pro.taskana.common.internal.security.WithAccessId;\n+import pro.taskana.common.internal.util.CheckedConsumer;\n+import pro.taskana.task.api.TaskQuery;\n+import pro.taskana.task.api.TaskService;\n+import pro.taskana.task.api.models.Task;\n+\n+@ExtendWith(JaasExtension.class)\n+class SelectAndClaimTaskAccTest extends AbstractAccTest {\n+\n+  @Test\n+  void should_claimDifferentTasks_For_ConcurrentSelectAndClaimCalls() throws Exception {\n+\n+    List<Task> selectedAndClaimedTasks = Collections.synchronizedList(new ArrayList<>());\n+\n+    List<String> accessIds =\n+        Collections.synchronizedList(\n+            Stream.of(\"admin\", \"teamlead-1\", \"teamlead-2\", \"taskadmin\")\n+                .collect(Collectors.toList()));\n+\n+    Runnable test = getRunnableTest(selectedAndClaimedTasks, accessIds);\n+\n+    Thread[] threads = new Thread[4];\n+    for (int i = 0; i < threads.length; i++) {\n+      threads[i] = new Thread(test);\n+      threads[i].start();\n+    }\n+    for (int i = 0; i < threads.length; i++) {\n+      threads[i].join();\n+    }\n+\n+    assertThat(selectedAndClaimedTasks.stream().map(Task::getId))", "originalCommit": "f1991ad4316cd8de239ba6cd0cc57caa70f1bddb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc4NDE5MA==", "url": "https://github.com/Taskana/taskana/pull/1150#discussion_r446784190", "bodyText": "thx :)", "author": "gitgoodjhe", "createdAt": "2020-06-29T05:43:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY1MjcxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "808d5e604539f2f4e5e13e86b00c627a78e1b762", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\nindex 01324d32a..9f065d506 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n", "chunk": "@@ -50,14 +50,14 @@ class SelectAndClaimTaskAccTest extends AbstractAccTest {\n       threads[i].join();\n     }\n \n-    assertThat(selectedAndClaimedTasks.stream().map(Task::getId))\n+    assertThat(selectedAndClaimedTasks).extracting(Task::getId)\n         .containsExactlyInAnyOrder(\n             \"TKI:000000000000000000000000000000000003\",\n             \"TKI:000000000000000000000000000000000004\",\n             \"TKI:000000000000000000000000000000000005\",\n             \"TKI:000000000000000000000000000000000006\");\n \n-    assertThat(selectedAndClaimedTasks.stream().map(Task::getOwner))\n+    assertThat(selectedAndClaimedTasks).extracting(Task::getOwner)\n         .containsExactlyInAnyOrder(\"admin\", \"taskadmin\", \"teamlead-1\", \"teamlead-2\");\n   }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "969d3eeff653d51eb7dcf5234aa4020333613ab3", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\nindex 01324d32a..9f065d506 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n", "chunk": "@@ -50,14 +50,14 @@ class SelectAndClaimTaskAccTest extends AbstractAccTest {\n       threads[i].join();\n     }\n \n-    assertThat(selectedAndClaimedTasks.stream().map(Task::getId))\n+    assertThat(selectedAndClaimedTasks).extracting(Task::getId)\n         .containsExactlyInAnyOrder(\n             \"TKI:000000000000000000000000000000000003\",\n             \"TKI:000000000000000000000000000000000004\",\n             \"TKI:000000000000000000000000000000000005\",\n             \"TKI:000000000000000000000000000000000006\");\n \n-    assertThat(selectedAndClaimedTasks.stream().map(Task::getOwner))\n+    assertThat(selectedAndClaimedTasks).extracting(Task::getOwner)\n         .containsExactlyInAnyOrder(\"admin\", \"taskadmin\", \"teamlead-1\", \"teamlead-2\");\n   }\n \n", "next_change": {"commit": "ec483ab21cbe35f0e0ec608b109c47a3438abb48", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\nindex 9f065d506..982880a5e 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n", "chunk": "@@ -50,14 +50,16 @@ class SelectAndClaimTaskAccTest extends AbstractAccTest {\n       threads[i].join();\n     }\n \n-    assertThat(selectedAndClaimedTasks).extracting(Task::getId)\n+    assertThat(selectedAndClaimedTasks)\n+        .extracting(Task::getId)\n         .containsExactlyInAnyOrder(\n             \"TKI:000000000000000000000000000000000003\",\n             \"TKI:000000000000000000000000000000000004\",\n             \"TKI:000000000000000000000000000000000005\",\n             \"TKI:000000000000000000000000000000000006\");\n \n-    assertThat(selectedAndClaimedTasks).extracting(Task::getOwner)\n+    assertThat(selectedAndClaimedTasks)\n+        .extracting(Task::getOwner)\n         .containsExactlyInAnyOrder(\"admin\", \"taskadmin\", \"teamlead-1\", \"teamlead-2\");\n   }\n \n", "next_change": {"commit": "770e1ff6feb6a1af2748a8c31cf758c6f796a41a", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\nindex 982880a5e..59fb62e6e 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n", "chunk": "@@ -65,7 +65,7 @@ class SelectAndClaimTaskAccTest extends AbstractAccTest {\n \n   @Test\n   @WithAccessId(user = \"admin\")\n-  void should_ThrowException_When_TryingToSelectAndClaimNonExistingTask() throws Exception {\n+  void should_ThrowException_When_TryingToSelectAndClaimNonExistingTask() {\n \n     TaskQuery query = taskanaEngine.getTaskService().createTaskQuery();\n     query.idIn(\"notexisting\");\n", "next_change": {"commit": "4f7b1fc8679b8c5cc2adff03b2e2db9b12083513", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\nindex 59fb62e6e..37c7100db 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n", "chunk": "@@ -67,12 +67,8 @@ class SelectAndClaimTaskAccTest extends AbstractAccTest {\n   @WithAccessId(user = \"admin\")\n   void should_ThrowException_When_TryingToSelectAndClaimNonExistingTask() {\n \n-    TaskQuery query = taskanaEngine.getTaskService().createTaskQuery();\n-    query.idIn(\"notexisting\");\n-    ThrowingCallable call =\n-        () -> {\n-          taskanaEngine.getTaskService().selectAndClaim(query);\n-        };\n+    TaskQuery query = taskanaEngine.getTaskService().createTaskQuery().idIn(\"notexisting\");\n+    ThrowingCallable call = () -> taskanaEngine.getTaskService().selectAndClaim(query);\n     assertThatThrownBy(call)\n         .isInstanceOf(SystemException.class)\n         .hasMessageContaining(\n", "next_change": {"commit": "55d21a9e8b82b363e50140a6cec48ffe347e2fd9", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\nindex 37c7100db..6e602c708 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n", "chunk": "@@ -76,6 +67,17 @@ class SelectAndClaimTaskAccTest extends AbstractAccTest {\n                 + \"task query returned nothing!\");\n   }\n \n+  private void runInThread(Runnable runnable, int threadCount) throws InterruptedException {\n+    Thread[] threads = new Thread[threadCount];\n+    for (int i = 0; i < threads.length; i++) {\n+      threads[i] = new Thread(runnable);\n+      threads[i].start();\n+    }\n+    for (Thread thread : threads) {\n+      thread.join();\n+    }\n+  }\n+\n   private Runnable getRunnableTest(List<Task> selectedAndClaimedTasks, List<String> accessIds) {\n     return () -> {\n       Subject subject = new Subject();\n", "next_change": {"commit": "1df190d1dae0cf8aee9795a112e8bea26e651828", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\nindex 6e602c708..709185866 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n", "chunk": "@@ -67,17 +69,6 @@ class SelectAndClaimTaskAccTest extends AbstractAccTest {\n                 + \"task query returned nothing!\");\n   }\n \n-  private void runInThread(Runnable runnable, int threadCount) throws InterruptedException {\n-    Thread[] threads = new Thread[threadCount];\n-    for (int i = 0; i < threads.length; i++) {\n-      threads[i] = new Thread(runnable);\n-      threads[i].start();\n-    }\n-    for (Thread thread : threads) {\n-      thread.join();\n-    }\n-  }\n-\n   private Runnable getRunnableTest(List<Task> selectedAndClaimedTasks, List<String> accessIds) {\n     return () -> {\n       Subject subject = new Subject();\n", "next_change": null}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "969d3eeff653d51eb7dcf5234aa4020333613ab3", "message": "Merge commit", "committedDate": null}, {"oid": "ec483ab21cbe35f0e0ec608b109c47a3438abb48", "committedDate": "2020-07-06 18:02:39 +0200", "message": "TSK-1318: replaced all declared Exceptions with Exception.class in all our test classes"}, {"oid": "770e1ff6feb6a1af2748a8c31cf758c6f796a41a", "committedDate": "2020-07-08 10:26:34 +0200", "message": "TSK-1326: removed unnecessary throws statements"}, {"oid": "83feab0955443f102345064d95e886281f76cef7", "committedDate": "2020-09-15 12:23:07 +0200", "message": "TSK-1386: made all our lower case test names upper case to match our naming convention"}, {"oid": "47aa60033faf81caaab930410972bdc7bf7d6e05", "committedDate": "2020-10-09 10:25:54 +0200", "message": "TSK-1277: moved JaasExtension and all its necessary classes to common modules"}, {"oid": "44cb21b5aec13e6548a0546dc8eb221fb1cd29ad", "committedDate": "2020-10-09 10:25:54 +0200", "message": "TSK-1277: removed circular dependency between taskana-common and taskana-core"}, {"oid": "4f7b1fc8679b8c5cc2adff03b2e2db9b12083513", "committedDate": "2020-11-02 09:41:48 +0100", "message": "TSK-1282: replaced Collections.emptyCollection with List/Map/Set.of"}, {"oid": "bfcabea61048ccb21a591e0c4f1f8efecc7636b4", "committedDate": "2021-05-20 09:41:58 +0200", "message": "TSK-1596: Automatic TraceLogging (#1577)"}, {"oid": "55d21a9e8b82b363e50140a6cec48ffe347e2fd9", "committedDate": "2021-08-02 16:42:09 +0200", "message": "TSK-1649: implemented database lock for resolution of jobs to run"}, {"oid": "1df190d1dae0cf8aee9795a112e8bea26e651828", "committedDate": "2021-11-04 10:10:46 +0100", "message": "TSK-1757: Added ParallelThreadHelper to support multi threaded tests."}, {"oid": "a0fe4ea468f273e2e96aab4cb40407a64a2263f0", "committedDate": "2022-04-05 12:32:50 +0200", "message": "TSK-1814: structured acceptance tests in packages"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY1Mjc3OA==", "url": "https://github.com/Taskana/taskana/pull/1150#discussion_r446652778", "body": "```suggestion\r\n    assertThat(selectedAndClaimedTasks)\r\n        .extracting(Task::getOwner)\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assertThat(selectedAndClaimedTasks.stream().map(Task::getOwner))\n          \n          \n            \n                assertThat(selectedAndClaimedTasks)\n          \n          \n            \n                    .extracting(Task::getOwner)", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    assertThat(selectedAndClaimedTasks<span class=\"pl-k x x-first\">.</span><span class=\"x\">stream()</span><span class=\"pl-k x\">.</span><span class=\"x\">map(</span><span class=\"pl-smi x\">Task</span><span class=\"pl-k x\">::</span><span class=\"x x-last\">getOwner)</span>)</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    assertThat(selectedAndClaimedTasks)</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        .extracting(<span class=\"pl-smi\">Task</span><span class=\"pl-k\">::</span>getOwner)</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "mustaphazorgati", "createdAt": "2020-06-28T13:43:01Z", "path": "lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package acceptance.task;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import acceptance.AbstractAccTest;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.security.auth.Subject;\n+import org.assertj.core.api.ThrowableAssert.ThrowingCallable;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import pro.taskana.common.api.BaseQuery.SortDirection;\n+import pro.taskana.common.api.exceptions.SystemException;\n+import pro.taskana.common.internal.security.JaasExtension;\n+import pro.taskana.common.internal.security.UserPrincipal;\n+import pro.taskana.common.internal.security.WithAccessId;\n+import pro.taskana.common.internal.util.CheckedConsumer;\n+import pro.taskana.task.api.TaskQuery;\n+import pro.taskana.task.api.TaskService;\n+import pro.taskana.task.api.models.Task;\n+\n+@ExtendWith(JaasExtension.class)\n+class SelectAndClaimTaskAccTest extends AbstractAccTest {\n+\n+  @Test\n+  void should_claimDifferentTasks_For_ConcurrentSelectAndClaimCalls() throws Exception {\n+\n+    List<Task> selectedAndClaimedTasks = Collections.synchronizedList(new ArrayList<>());\n+\n+    List<String> accessIds =\n+        Collections.synchronizedList(\n+            Stream.of(\"admin\", \"teamlead-1\", \"teamlead-2\", \"taskadmin\")\n+                .collect(Collectors.toList()));\n+\n+    Runnable test = getRunnableTest(selectedAndClaimedTasks, accessIds);\n+\n+    Thread[] threads = new Thread[4];\n+    for (int i = 0; i < threads.length; i++) {\n+      threads[i] = new Thread(test);\n+      threads[i].start();\n+    }\n+    for (int i = 0; i < threads.length; i++) {\n+      threads[i].join();\n+    }\n+\n+    assertThat(selectedAndClaimedTasks.stream().map(Task::getId))\n+        .containsExactlyInAnyOrder(\n+            \"TKI:000000000000000000000000000000000003\",\n+            \"TKI:000000000000000000000000000000000004\",\n+            \"TKI:000000000000000000000000000000000005\",\n+            \"TKI:000000000000000000000000000000000006\");\n+\n+    assertThat(selectedAndClaimedTasks.stream().map(Task::getOwner))", "originalCommit": "f1991ad4316cd8de239ba6cd0cc57caa70f1bddb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "808d5e604539f2f4e5e13e86b00c627a78e1b762", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\nindex 01324d32a..9f065d506 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n", "chunk": "@@ -50,14 +50,14 @@ class SelectAndClaimTaskAccTest extends AbstractAccTest {\n       threads[i].join();\n     }\n \n-    assertThat(selectedAndClaimedTasks.stream().map(Task::getId))\n+    assertThat(selectedAndClaimedTasks).extracting(Task::getId)\n         .containsExactlyInAnyOrder(\n             \"TKI:000000000000000000000000000000000003\",\n             \"TKI:000000000000000000000000000000000004\",\n             \"TKI:000000000000000000000000000000000005\",\n             \"TKI:000000000000000000000000000000000006\");\n \n-    assertThat(selectedAndClaimedTasks.stream().map(Task::getOwner))\n+    assertThat(selectedAndClaimedTasks).extracting(Task::getOwner)\n         .containsExactlyInAnyOrder(\"admin\", \"taskadmin\", \"teamlead-1\", \"teamlead-2\");\n   }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "969d3eeff653d51eb7dcf5234aa4020333613ab3", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\nindex 01324d32a..9f065d506 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n", "chunk": "@@ -50,14 +50,14 @@ class SelectAndClaimTaskAccTest extends AbstractAccTest {\n       threads[i].join();\n     }\n \n-    assertThat(selectedAndClaimedTasks.stream().map(Task::getId))\n+    assertThat(selectedAndClaimedTasks).extracting(Task::getId)\n         .containsExactlyInAnyOrder(\n             \"TKI:000000000000000000000000000000000003\",\n             \"TKI:000000000000000000000000000000000004\",\n             \"TKI:000000000000000000000000000000000005\",\n             \"TKI:000000000000000000000000000000000006\");\n \n-    assertThat(selectedAndClaimedTasks.stream().map(Task::getOwner))\n+    assertThat(selectedAndClaimedTasks).extracting(Task::getOwner)\n         .containsExactlyInAnyOrder(\"admin\", \"taskadmin\", \"teamlead-1\", \"teamlead-2\");\n   }\n \n", "next_change": {"commit": "ec483ab21cbe35f0e0ec608b109c47a3438abb48", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\nindex 9f065d506..982880a5e 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n", "chunk": "@@ -50,14 +50,16 @@ class SelectAndClaimTaskAccTest extends AbstractAccTest {\n       threads[i].join();\n     }\n \n-    assertThat(selectedAndClaimedTasks).extracting(Task::getId)\n+    assertThat(selectedAndClaimedTasks)\n+        .extracting(Task::getId)\n         .containsExactlyInAnyOrder(\n             \"TKI:000000000000000000000000000000000003\",\n             \"TKI:000000000000000000000000000000000004\",\n             \"TKI:000000000000000000000000000000000005\",\n             \"TKI:000000000000000000000000000000000006\");\n \n-    assertThat(selectedAndClaimedTasks).extracting(Task::getOwner)\n+    assertThat(selectedAndClaimedTasks)\n+        .extracting(Task::getOwner)\n         .containsExactlyInAnyOrder(\"admin\", \"taskadmin\", \"teamlead-1\", \"teamlead-2\");\n   }\n \n", "next_change": {"commit": "770e1ff6feb6a1af2748a8c31cf758c6f796a41a", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\nindex 982880a5e..59fb62e6e 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n", "chunk": "@@ -65,7 +65,7 @@ class SelectAndClaimTaskAccTest extends AbstractAccTest {\n \n   @Test\n   @WithAccessId(user = \"admin\")\n-  void should_ThrowException_When_TryingToSelectAndClaimNonExistingTask() throws Exception {\n+  void should_ThrowException_When_TryingToSelectAndClaimNonExistingTask() {\n \n     TaskQuery query = taskanaEngine.getTaskService().createTaskQuery();\n     query.idIn(\"notexisting\");\n", "next_change": {"commit": "4f7b1fc8679b8c5cc2adff03b2e2db9b12083513", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\nindex 59fb62e6e..37c7100db 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n", "chunk": "@@ -67,12 +67,8 @@ class SelectAndClaimTaskAccTest extends AbstractAccTest {\n   @WithAccessId(user = \"admin\")\n   void should_ThrowException_When_TryingToSelectAndClaimNonExistingTask() {\n \n-    TaskQuery query = taskanaEngine.getTaskService().createTaskQuery();\n-    query.idIn(\"notexisting\");\n-    ThrowingCallable call =\n-        () -> {\n-          taskanaEngine.getTaskService().selectAndClaim(query);\n-        };\n+    TaskQuery query = taskanaEngine.getTaskService().createTaskQuery().idIn(\"notexisting\");\n+    ThrowingCallable call = () -> taskanaEngine.getTaskService().selectAndClaim(query);\n     assertThatThrownBy(call)\n         .isInstanceOf(SystemException.class)\n         .hasMessageContaining(\n", "next_change": {"commit": "55d21a9e8b82b363e50140a6cec48ffe347e2fd9", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\nindex 37c7100db..6e602c708 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n", "chunk": "@@ -76,6 +67,17 @@ class SelectAndClaimTaskAccTest extends AbstractAccTest {\n                 + \"task query returned nothing!\");\n   }\n \n+  private void runInThread(Runnable runnable, int threadCount) throws InterruptedException {\n+    Thread[] threads = new Thread[threadCount];\n+    for (int i = 0; i < threads.length; i++) {\n+      threads[i] = new Thread(runnable);\n+      threads[i].start();\n+    }\n+    for (Thread thread : threads) {\n+      thread.join();\n+    }\n+  }\n+\n   private Runnable getRunnableTest(List<Task> selectedAndClaimedTasks, List<String> accessIds) {\n     return () -> {\n       Subject subject = new Subject();\n", "next_change": {"commit": "1df190d1dae0cf8aee9795a112e8bea26e651828", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\nindex 6e602c708..709185866 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n", "chunk": "@@ -67,17 +69,6 @@ class SelectAndClaimTaskAccTest extends AbstractAccTest {\n                 + \"task query returned nothing!\");\n   }\n \n-  private void runInThread(Runnable runnable, int threadCount) throws InterruptedException {\n-    Thread[] threads = new Thread[threadCount];\n-    for (int i = 0; i < threads.length; i++) {\n-      threads[i] = new Thread(runnable);\n-      threads[i].start();\n-    }\n-    for (Thread thread : threads) {\n-      thread.join();\n-    }\n-  }\n-\n   private Runnable getRunnableTest(List<Task> selectedAndClaimedTasks, List<String> accessIds) {\n     return () -> {\n       Subject subject = new Subject();\n", "next_change": null}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "969d3eeff653d51eb7dcf5234aa4020333613ab3", "message": "Merge commit", "committedDate": null}, {"oid": "ec483ab21cbe35f0e0ec608b109c47a3438abb48", "committedDate": "2020-07-06 18:02:39 +0200", "message": "TSK-1318: replaced all declared Exceptions with Exception.class in all our test classes"}, {"oid": "770e1ff6feb6a1af2748a8c31cf758c6f796a41a", "committedDate": "2020-07-08 10:26:34 +0200", "message": "TSK-1326: removed unnecessary throws statements"}, {"oid": "83feab0955443f102345064d95e886281f76cef7", "committedDate": "2020-09-15 12:23:07 +0200", "message": "TSK-1386: made all our lower case test names upper case to match our naming convention"}, {"oid": "47aa60033faf81caaab930410972bdc7bf7d6e05", "committedDate": "2020-10-09 10:25:54 +0200", "message": "TSK-1277: moved JaasExtension and all its necessary classes to common modules"}, {"oid": "44cb21b5aec13e6548a0546dc8eb221fb1cd29ad", "committedDate": "2020-10-09 10:25:54 +0200", "message": "TSK-1277: removed circular dependency between taskana-common and taskana-core"}, {"oid": "4f7b1fc8679b8c5cc2adff03b2e2db9b12083513", "committedDate": "2020-11-02 09:41:48 +0100", "message": "TSK-1282: replaced Collections.emptyCollection with List/Map/Set.of"}, {"oid": "bfcabea61048ccb21a591e0c4f1f8efecc7636b4", "committedDate": "2021-05-20 09:41:58 +0200", "message": "TSK-1596: Automatic TraceLogging (#1577)"}, {"oid": "55d21a9e8b82b363e50140a6cec48ffe347e2fd9", "committedDate": "2021-08-02 16:42:09 +0200", "message": "TSK-1649: implemented database lock for resolution of jobs to run"}, {"oid": "1df190d1dae0cf8aee9795a112e8bea26e651828", "committedDate": "2021-11-04 10:10:46 +0100", "message": "TSK-1757: Added ParallelThreadHelper to support multi threaded tests."}, {"oid": "a0fe4ea468f273e2e96aab4cb40407a64a2263f0", "committedDate": "2022-04-05 12:32:50 +0200", "message": "TSK-1814: structured acceptance tests in packages"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY1Mjg0OA==", "url": "https://github.com/Taskana/taskana/pull/1150#discussion_r446652848", "body": "Do we really want a system exception here?", "bodyText": "Do we really want a system exception here?", "bodyHTML": "<p dir=\"auto\">Do we really want a system exception here?</p>", "author": "mustaphazorgati", "createdAt": "2020-06-28T13:43:27Z", "path": "lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package acceptance.task;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import acceptance.AbstractAccTest;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.security.auth.Subject;\n+import org.assertj.core.api.ThrowableAssert.ThrowingCallable;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import pro.taskana.common.api.BaseQuery.SortDirection;\n+import pro.taskana.common.api.exceptions.SystemException;\n+import pro.taskana.common.internal.security.JaasExtension;\n+import pro.taskana.common.internal.security.UserPrincipal;\n+import pro.taskana.common.internal.security.WithAccessId;\n+import pro.taskana.common.internal.util.CheckedConsumer;\n+import pro.taskana.task.api.TaskQuery;\n+import pro.taskana.task.api.TaskService;\n+import pro.taskana.task.api.models.Task;\n+\n+@ExtendWith(JaasExtension.class)\n+class SelectAndClaimTaskAccTest extends AbstractAccTest {\n+\n+  @Test\n+  void should_claimDifferentTasks_For_ConcurrentSelectAndClaimCalls() throws Exception {\n+\n+    List<Task> selectedAndClaimedTasks = Collections.synchronizedList(new ArrayList<>());\n+\n+    List<String> accessIds =\n+        Collections.synchronizedList(\n+            Stream.of(\"admin\", \"teamlead-1\", \"teamlead-2\", \"taskadmin\")\n+                .collect(Collectors.toList()));\n+\n+    Runnable test = getRunnableTest(selectedAndClaimedTasks, accessIds);\n+\n+    Thread[] threads = new Thread[4];\n+    for (int i = 0; i < threads.length; i++) {\n+      threads[i] = new Thread(test);\n+      threads[i].start();\n+    }\n+    for (int i = 0; i < threads.length; i++) {\n+      threads[i].join();\n+    }\n+\n+    assertThat(selectedAndClaimedTasks.stream().map(Task::getId))\n+        .containsExactlyInAnyOrder(\n+            \"TKI:000000000000000000000000000000000003\",\n+            \"TKI:000000000000000000000000000000000004\",\n+            \"TKI:000000000000000000000000000000000005\",\n+            \"TKI:000000000000000000000000000000000006\");\n+\n+    assertThat(selectedAndClaimedTasks.stream().map(Task::getOwner))\n+        .containsExactlyInAnyOrder(\"admin\", \"taskadmin\", \"teamlead-1\", \"teamlead-2\");\n+  }\n+\n+  @Test\n+  @WithAccessId(user = \"admin\")\n+  void should_ThrowException_When_TryingToSelectAndClaimNonExistingTask() throws Exception {\n+\n+    TaskQuery query = taskanaEngine.getTaskService().createTaskQuery();\n+    query.idIn(\"notexisting\");\n+    ThrowingCallable call =\n+        () -> {\n+          taskanaEngine.getTaskService().selectAndClaim(query);\n+        };\n+    assertThatThrownBy(call)\n+        .isInstanceOf(SystemException.class)\n+        .hasMessageContaining(\n+            \"No tasks matched the specified filter and sorting options, \"\n+                + \"task query returned nothing!\");\n+  }", "originalCommit": "f1991ad4316cd8de239ba6cd0cc57caa70f1bddb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "4f7b1fc8679b8c5cc2adff03b2e2db9b12083513", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\nindex 01324d32a..37c7100db 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n", "chunk": "@@ -46,31 +46,29 @@ class SelectAndClaimTaskAccTest extends AbstractAccTest {\n       threads[i] = new Thread(test);\n       threads[i].start();\n     }\n-    for (int i = 0; i < threads.length; i++) {\n-      threads[i].join();\n+    for (Thread thread : threads) {\n+      thread.join();\n     }\n \n-    assertThat(selectedAndClaimedTasks.stream().map(Task::getId))\n+    assertThat(selectedAndClaimedTasks)\n+        .extracting(Task::getId)\n         .containsExactlyInAnyOrder(\n             \"TKI:000000000000000000000000000000000003\",\n             \"TKI:000000000000000000000000000000000004\",\n             \"TKI:000000000000000000000000000000000005\",\n             \"TKI:000000000000000000000000000000000006\");\n \n-    assertThat(selectedAndClaimedTasks.stream().map(Task::getOwner))\n+    assertThat(selectedAndClaimedTasks)\n+        .extracting(Task::getOwner)\n         .containsExactlyInAnyOrder(\"admin\", \"taskadmin\", \"teamlead-1\", \"teamlead-2\");\n   }\n \n   @Test\n   @WithAccessId(user = \"admin\")\n-  void should_ThrowException_When_TryingToSelectAndClaimNonExistingTask() throws Exception {\n-\n-    TaskQuery query = taskanaEngine.getTaskService().createTaskQuery();\n-    query.idIn(\"notexisting\");\n-    ThrowingCallable call =\n-        () -> {\n-          taskanaEngine.getTaskService().selectAndClaim(query);\n-        };\n+  void should_ThrowException_When_TryingToSelectAndClaimNonExistingTask() {\n+\n+    TaskQuery query = taskanaEngine.getTaskService().createTaskQuery().idIn(\"notexisting\");\n+    ThrowingCallable call = () -> taskanaEngine.getTaskService().selectAndClaim(query);\n     assertThatThrownBy(call)\n         .isInstanceOf(SystemException.class)\n         .hasMessageContaining(\n", "next_change": {"commit": "55d21a9e8b82b363e50140a6cec48ffe347e2fd9", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\nindex 37c7100db..6e602c708 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n", "chunk": "@@ -76,6 +67,17 @@ class SelectAndClaimTaskAccTest extends AbstractAccTest {\n                 + \"task query returned nothing!\");\n   }\n \n+  private void runInThread(Runnable runnable, int threadCount) throws InterruptedException {\n+    Thread[] threads = new Thread[threadCount];\n+    for (int i = 0; i < threads.length; i++) {\n+      threads[i] = new Thread(runnable);\n+      threads[i].start();\n+    }\n+    for (Thread thread : threads) {\n+      thread.join();\n+    }\n+  }\n+\n   private Runnable getRunnableTest(List<Task> selectedAndClaimedTasks, List<String> accessIds) {\n     return () -> {\n       Subject subject = new Subject();\n", "next_change": {"commit": "1df190d1dae0cf8aee9795a112e8bea26e651828", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\nindex 6e602c708..709185866 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n", "chunk": "@@ -67,17 +69,6 @@ class SelectAndClaimTaskAccTest extends AbstractAccTest {\n                 + \"task query returned nothing!\");\n   }\n \n-  private void runInThread(Runnable runnable, int threadCount) throws InterruptedException {\n-    Thread[] threads = new Thread[threadCount];\n-    for (int i = 0; i < threads.length; i++) {\n-      threads[i] = new Thread(runnable);\n-      threads[i].start();\n-    }\n-    for (Thread thread : threads) {\n-      thread.join();\n-    }\n-  }\n-\n   private Runnable getRunnableTest(List<Task> selectedAndClaimedTasks, List<String> accessIds) {\n     return () -> {\n       Subject subject = new Subject();\n", "next_change": null}]}}]}}, {"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\nindex 01324d32a..37c7100db 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/SelectAndClaimTaskAccTest.java\n", "chunk": "@@ -79,27 +77,23 @@ class SelectAndClaimTaskAccTest extends AbstractAccTest {\n   }\n \n   private Runnable getRunnableTest(List<Task> selectedAndClaimedTasks, List<String> accessIds) {\n-\n-    Runnable test =\n-        () -> {\n-          Subject subject = new Subject();\n-          subject.getPrincipals().add(new UserPrincipal(accessIds.remove(0)));\n-\n-          Consumer<TaskService> consumer =\n-              CheckedConsumer.wrap(\n-                  taskService -> {\n-                    Task task = taskService.selectAndClaim(getTaskQuery());\n-                    selectedAndClaimedTasks.add(task);\n-                  });\n-          PrivilegedAction<Void> action =\n-              () -> {\n-                consumer.accept(taskanaEngine.getTaskService());\n-                return null;\n-              };\n-          Subject.doAs(subject, action);\n-        };\n-\n-    return test;\n+    return () -> {\n+      Subject subject = new Subject();\n+      subject.getPrincipals().add(new UserPrincipal(accessIds.remove(0)));\n+\n+      Consumer<TaskService> consumer =\n+          CheckedConsumer.wrap(\n+              taskService -> {\n+                Task task = taskService.selectAndClaim(getTaskQuery());\n+                selectedAndClaimedTasks.add(task);\n+              });\n+      PrivilegedAction<Void> action =\n+          () -> {\n+            consumer.accept(taskanaEngine.getTaskService());\n+            return null;\n+          };\n+      Subject.doAs(subject, action);\n+    };\n   }\n \n   private TaskQuery getTaskQuery() {\n", "next_change": null}]}, "commits_in_main": [{"oid": "969d3eeff653d51eb7dcf5234aa4020333613ab3", "message": "Merge commit", "committedDate": null}, {"oid": "ec483ab21cbe35f0e0ec608b109c47a3438abb48", "committedDate": "2020-07-06 18:02:39 +0200", "message": "TSK-1318: replaced all declared Exceptions with Exception.class in all our test classes"}, {"oid": "770e1ff6feb6a1af2748a8c31cf758c6f796a41a", "committedDate": "2020-07-08 10:26:34 +0200", "message": "TSK-1326: removed unnecessary throws statements"}, {"oid": "83feab0955443f102345064d95e886281f76cef7", "committedDate": "2020-09-15 12:23:07 +0200", "message": "TSK-1386: made all our lower case test names upper case to match our naming convention"}, {"oid": "47aa60033faf81caaab930410972bdc7bf7d6e05", "committedDate": "2020-10-09 10:25:54 +0200", "message": "TSK-1277: moved JaasExtension and all its necessary classes to common modules"}, {"oid": "44cb21b5aec13e6548a0546dc8eb221fb1cd29ad", "committedDate": "2020-10-09 10:25:54 +0200", "message": "TSK-1277: removed circular dependency between taskana-common and taskana-core"}, {"oid": "4f7b1fc8679b8c5cc2adff03b2e2db9b12083513", "committedDate": "2020-11-02 09:41:48 +0100", "message": "TSK-1282: replaced Collections.emptyCollection with List/Map/Set.of"}, {"oid": "bfcabea61048ccb21a591e0c4f1f8efecc7636b4", "committedDate": "2021-05-20 09:41:58 +0200", "message": "TSK-1596: Automatic TraceLogging (#1577)"}, {"oid": "55d21a9e8b82b363e50140a6cec48ffe347e2fd9", "committedDate": "2021-08-02 16:42:09 +0200", "message": "TSK-1649: implemented database lock for resolution of jobs to run"}, {"oid": "1df190d1dae0cf8aee9795a112e8bea26e651828", "committedDate": "2021-11-04 10:10:46 +0100", "message": "TSK-1757: Added ParallelThreadHelper to support multi threaded tests."}, {"oid": "a0fe4ea468f273e2e96aab4cb40407a64a2263f0", "committedDate": "2022-04-05 12:32:50 +0200", "message": "TSK-1814: structured acceptance tests in packages"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY1MzA2NQ==", "url": "https://github.com/Taskana/taskana/pull/1150#discussion_r446653065", "body": "personally I think `<= 16` is more readable :)", "bodyText": "personally I think <= 16 is more readable :)", "bodyHTML": "<p dir=\"auto\">personally I think <code>&lt;= 16</code> is more readable :)</p>", "author": "mustaphazorgati", "createdAt": "2020-06-28T13:45:14Z", "path": "rest/taskana-rest-spring/src/main/java/pro/taskana/task/rest/TaskController.java", "diffHunk": "@@ -414,8 +439,15 @@ private TaskQuery applyFilterParams(TaskQuery taskQuery, MultiValueMap<String, S\n       params.remove(EXTERNAL_ID);\n     }\n \n-    if (LOGGER.isDebugEnabled()) {\n-      LOGGER.debug(\"Exit from applyFilterParams(), returning {}\", taskQuery);\n+    for (int i = 1; i < 17; i++) {", "originalCommit": "f1991ad4316cd8de239ba6cd0cc57caa70f1bddb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "808d5e604539f2f4e5e13e86b00c627a78e1b762", "changed_code": [{"header": "diff --git a/rest/taskana-rest-spring/src/main/java/pro/taskana/task/rest/TaskController.java b/rest/taskana-rest-spring/src/main/java/pro/taskana/task/rest/TaskController.java\nindex 116d4c5e7..d72909593 100644\n--- a/rest/taskana-rest-spring/src/main/java/pro/taskana/task/rest/TaskController.java\n+++ b/rest/taskana-rest-spring/src/main/java/pro/taskana/task/rest/TaskController.java\n", "chunk": "@@ -439,7 +439,7 @@ public class TaskController extends AbstractPagingController {\n       params.remove(EXTERNAL_ID);\n     }\n \n-    for (int i = 1; i < 17; i++) {\n+    for (int i = 1; i <= 16; i++) {\n       if (params.containsKey(CUSTOM + i)) {\n         String[] customValues = extractCommaSeparatedFields(params.get(CUSTOM + i));\n         taskQuery.customAttributeIn(String.valueOf(i), customValues);\n", "next_change": null}]}, "revised_code_in_main": {"commit": "969d3eeff653d51eb7dcf5234aa4020333613ab3", "changed_code": [{"header": "diff --git a/rest/taskana-rest-spring/src/main/java/pro/taskana/task/rest/TaskController.java b/rest/taskana-rest-spring/src/main/java/pro/taskana/task/rest/TaskController.java\nindex 116d4c5e7..d72909593 100644\n--- a/rest/taskana-rest-spring/src/main/java/pro/taskana/task/rest/TaskController.java\n+++ b/rest/taskana-rest-spring/src/main/java/pro/taskana/task/rest/TaskController.java\n", "chunk": "@@ -439,7 +439,7 @@ public class TaskController extends AbstractPagingController {\n       params.remove(EXTERNAL_ID);\n     }\n \n-    for (int i = 1; i < 17; i++) {\n+    for (int i = 1; i <= 16; i++) {\n       if (params.containsKey(CUSTOM + i)) {\n         String[] customValues = extractCommaSeparatedFields(params.get(CUSTOM + i));\n         taskQuery.customAttributeIn(String.valueOf(i), customValues);\n", "next_change": {"commit": "d8ad7a7fb96e7d07e5f93e202cd84e03e5c1944a", "changed_code": [{"header": "diff --git a/rest/taskana-rest-spring/src/main/java/pro/taskana/task/rest/TaskController.java b/rest/taskana-rest-spring/src/main/java/pro/taskana/task/rest/TaskController.java\nindex d72909593..829fb9804 100644\n--- a/rest/taskana-rest-spring/src/main/java/pro/taskana/task/rest/TaskController.java\n+++ b/rest/taskana-rest-spring/src/main/java/pro/taskana/task/rest/TaskController.java\n", "chunk": "@@ -439,6 +481,13 @@ public class TaskController extends AbstractPagingController {\n       params.remove(EXTERNAL_ID);\n     }\n \n+    for (int i = 1; i < 17; i++) {\n+      if (params.containsKey(CUSTOM + i)) {\n+        taskQuery.customAttributeIn(String.valueOf(i), params.get(CUSTOM + i).get(0));\n+        params.remove(CUSTOM + i);\n+      }\n+    }\n+\n     for (int i = 1; i <= 16; i++) {\n       if (params.containsKey(CUSTOM + i)) {\n         String[] customValues = extractCommaSeparatedFields(params.get(CUSTOM + i));\n", "next_change": {"commit": "4bba93c5a98dcbe22dc86144b12507abce4b2be4", "changed_code": [{"header": "diff --git a/rest/taskana-rest-spring/src/main/java/pro/taskana/task/rest/TaskController.java b/rest/taskana-rest-spring/src/main/java/pro/taskana/task/rest/TaskController.java\nindex 829fb9804..3022450f2 100644\n--- a/rest/taskana-rest-spring/src/main/java/pro/taskana/task/rest/TaskController.java\n+++ b/rest/taskana-rest-spring/src/main/java/pro/taskana/task/rest/TaskController.java\n", "chunk": "@@ -481,23 +481,16 @@ public class TaskController extends AbstractPagingController {\n       params.remove(EXTERNAL_ID);\n     }\n \n-    for (int i = 1; i < 17; i++) {\n-      if (params.containsKey(CUSTOM + i)) {\n-        taskQuery.customAttributeIn(String.valueOf(i), params.get(CUSTOM + i).get(0));\n-        params.remove(CUSTOM + i);\n-      }\n-    }\n-\n     for (int i = 1; i <= 16; i++) {\n       if (params.containsKey(CUSTOM + i)) {\n         String[] customValues = extractCommaSeparatedFields(params.get(CUSTOM + i));\n         taskQuery.customAttributeIn(String.valueOf(i), customValues);\n-        if (LOGGER.isDebugEnabled()) {\n-          params.remove(CUSTOM + i);\n-          LOGGER.debug(\"Exit from applyFilterParams(), returning {}\", taskQuery);\n-        }\n+        params.remove(CUSTOM + i);\n       }\n     }\n+    if (LOGGER.isDebugEnabled()) {\n+      LOGGER.debug(\"Exit from applyFilterParams(), returning {}\", taskQuery);\n+    }\n \n     return taskQuery;\n   }\n", "next_change": {"commit": "9e44ca614000475810e9c0aa214a1006e19d33e8", "changed_code": [{"header": "diff --git a/rest/taskana-rest-spring/src/main/java/pro/taskana/task/rest/TaskController.java b/rest/taskana-rest-spring/src/main/java/pro/taskana/task/rest/TaskController.java\nindex 3022450f2..8862bb598 100644\n--- a/rest/taskana-rest-spring/src/main/java/pro/taskana/task/rest/TaskController.java\n+++ b/rest/taskana-rest-spring/src/main/java/pro/taskana/task/rest/TaskController.java\n", "chunk": "@@ -492,6 +489,9 @@ public class TaskController extends AbstractPagingController {\n       LOGGER.debug(\"Exit from applyFilterParams(), returning {}\", taskQuery);\n     }\n \n+    if (LOGGER.isDebugEnabled()) {\n+      LOGGER.debug(\"Exit from applyFilterParams(), query: {}\", taskQuery);\n+    }\n     return taskQuery;\n   }\n \n", "next_change": {"commit": "7cc5b00be617227dac2f8d1210554108d18bad4a", "changed_code": [{"header": "diff --git a/rest/taskana-rest-spring/src/main/java/pro/taskana/task/rest/TaskController.java b/rest/taskana-rest-spring/src/main/java/pro/taskana/task/rest/TaskController.java\nindex 8862bb598..ec7c888cf 100644\n--- a/rest/taskana-rest-spring/src/main/java/pro/taskana/task/rest/TaskController.java\n+++ b/rest/taskana-rest-spring/src/main/java/pro/taskana/task/rest/TaskController.java\n", "chunk": "@@ -492,7 +494,6 @@ public class TaskController extends AbstractPagingController {\n     if (LOGGER.isDebugEnabled()) {\n       LOGGER.debug(\"Exit from applyFilterParams(), query: {}\", taskQuery);\n     }\n-    return taskQuery;\n   }\n \n   private WildcardSearchField[] createWildcardSearchFields(String[] wildcardFields) {\n", "next_change": {"commit": "3967e2900e8b35329b3675844ca3a8e059916c7e", "changed_code": [{"header": "diff --git a/rest/taskana-rest-spring/src/main/java/pro/taskana/task/rest/TaskController.java b/rest/taskana-rest-spring/src/main/java/pro/taskana/task/rest/TaskController.java\nindex ec7c888cf..f54c8f059 100644\n--- a/rest/taskana-rest-spring/src/main/java/pro/taskana/task/rest/TaskController.java\n+++ b/rest/taskana-rest-spring/src/main/java/pro/taskana/task/rest/TaskController.java\n", "chunk": "@@ -342,411 +428,43 @@ public class TaskController extends AbstractPagingController {\n     return result;\n   }\n \n-  private void applyFilterParams(TaskQuery taskQuery, MultiValueMap<String, String> params)\n-      throws InvalidArgumentException {\n-    if (LOGGER.isDebugEnabled()) {\n-      LOGGER.debug(\"Entry to applyFilterParams(taskQuery= {}, params= {})\", taskQuery, params);\n-    }\n-\n-    checkForIllegalParamCombinations(params);\n-\n-    // apply filters\n-    if (params.containsKey(NAME)) {\n-      String[] names = extractCommaSeparatedFields(params.get(NAME));\n-      taskQuery.nameIn(names);\n-      params.remove(NAME);\n-    }\n-    if (params.containsKey(NAME_LIKE)) {\n-      taskQuery.nameLike(LIKE + params.get(NAME_LIKE).get(0) + LIKE);\n-      params.remove(NAME_LIKE);\n-    }\n-    if (params.containsKey(PRIORITY)) {\n-      String[] prioritiesInString = extractCommaSeparatedFields(params.get(PRIORITY));\n-      int[] priorities = extractPriorities(prioritiesInString);\n-      taskQuery.priorityIn(priorities);\n-      params.remove(PRIORITY);\n-    }\n-    if (params.containsKey(STATE)) {\n-\n-      TaskState[] states = extractStates(params);\n-      taskQuery.stateIn(states);\n-      params.remove(STATE);\n-    }\n-    if (params.containsKey(CLASSIFICATION_KEY)) {\n-      String[] classificationKeys = extractCommaSeparatedFields(params.get(CLASSIFICATION_KEY));\n-      taskQuery.classificationKeyIn(classificationKeys);\n-      params.remove(CLASSIFICATION_KEY);\n-    }\n-    if (params.containsKey(TASK_ID)) {\n-      String[] taskIds = extractCommaSeparatedFields(params.get(TASK_ID));\n-      taskQuery.idIn(taskIds);\n-      params.remove(TASK_ID);\n-    }\n-    if (params.containsKey(WORKBASKET_ID)) {\n-      String[] workbaskets = extractCommaSeparatedFields(params.get(WORKBASKET_ID));\n-      taskQuery.workbasketIdIn(workbaskets);\n-      params.remove(WORKBASKET_ID);\n-    }\n-    if (params.containsKey(WORKBASKET_KEY)) {\n-      updateTaskQueryWithWorkbasketKey(taskQuery, params);\n-    }\n-    if (params.containsKey(OWNER)) {\n-      String[] owners = extractCommaSeparatedFields(params.get(OWNER));\n-      taskQuery.ownerIn(owners);\n-      params.remove(OWNER);\n-    }\n-    if (params.containsKey(OWNER_LIKE)) {\n-      taskQuery.ownerLike(LIKE + params.get(OWNER_LIKE).get(0) + LIKE);\n-      params.remove(OWNER_LIKE);\n-    }\n-    if (params.containsKey(POR_COMPANY)) {\n-      String[] companies = extractCommaSeparatedFields(params.get(POR_COMPANY));\n-      taskQuery.primaryObjectReferenceCompanyIn(companies);\n-      params.remove(POR_COMPANY);\n-    }\n-    if (params.containsKey(POR_SYSTEM)) {\n-      String[] systems = extractCommaSeparatedFields(params.get(POR_SYSTEM));\n-      taskQuery.primaryObjectReferenceSystemIn(systems);\n-      params.remove(POR_SYSTEM);\n-    }\n-    if (params.containsKey(POR_SYSTEM_INSTANCE)) {\n-      String[] systemInstances = extractCommaSeparatedFields(params.get(POR_SYSTEM_INSTANCE));\n-      taskQuery.primaryObjectReferenceSystemInstanceIn(systemInstances);\n-      params.remove(POR_SYSTEM_INSTANCE);\n-    }\n-    if (params.containsKey(POR_TYPE)) {\n-      taskQuery.primaryObjectReferenceTypeLike(LIKE + params.get(POR_TYPE).get(0) + LIKE);\n-      params.remove(POR_TYPE);\n-    }\n-    if (params.containsKey(POR_VALUE)) {\n-      taskQuery.primaryObjectReferenceValueLike(LIKE + params.get(POR_VALUE).get(0) + LIKE);\n-      params.remove(POR_VALUE);\n-    }\n-\n-    if (params.containsKey(PLANNED)) {\n-      updateTaskQueryWithPlannedOrDueTimeIntervals(taskQuery, params, PLANNED);\n-    }\n-\n-    if (params.containsKey(DUE)) {\n-      updateTaskQueryWithPlannedOrDueTimeIntervals(taskQuery, params, DUE);\n-    }\n-\n-    if (params.containsKey(PLANNED_FROM) && params.containsKey(PLANNED_UNTIL)) {\n-      updateTaskQueryWithPlannedOrDueTimeInterval(taskQuery, params, PLANNED_FROM, PLANNED_UNTIL);\n-\n-    } else if (params.containsKey(PLANNED_FROM) && !params.containsKey(PLANNED_UNTIL)) {\n-\n-      TimeInterval timeInterval = createIndefiniteTimeIntervalFromParam(params, PLANNED_FROM);\n-      updateTaskQueryWithIndefiniteTimeInterval(taskQuery, params, PLANNED_FROM, timeInterval);\n-\n-    } else if (!params.containsKey(PLANNED_FROM) && params.containsKey(PLANNED_UNTIL)) {\n-\n-      TimeInterval timeInterval = createIndefiniteTimeIntervalFromParam(params, PLANNED_UNTIL);\n-      updateTaskQueryWithIndefiniteTimeInterval(taskQuery, params, PLANNED_UNTIL, timeInterval);\n-    }\n-\n-    if (params.containsKey(DUE_FROM) && params.containsKey(DUE_TO)) {\n-      updateTaskQueryWithPlannedOrDueTimeInterval(taskQuery, params, DUE_FROM, DUE_TO);\n-\n-    } else if (params.containsKey(DUE_FROM) && !params.containsKey(DUE_TO)) {\n-\n-      TimeInterval indefiniteTimeInterval = createIndefiniteTimeIntervalFromParam(params, DUE_FROM);\n-      updateTaskQueryWithIndefiniteTimeInterval(\n-          taskQuery, params, DUE_FROM, indefiniteTimeInterval);\n-\n-    } else if (!params.containsKey(DUE_FROM) && params.containsKey(DUE_TO)) {\n-\n-      TimeInterval timeInterval = createIndefiniteTimeIntervalFromParam(params, DUE_TO);\n-      updateTaskQueryWithIndefiniteTimeInterval(taskQuery, params, DUE_TO, timeInterval);\n-    }\n-\n-    if (params.containsKey(WILDCARD_SEARCH_FIELDS) && params.containsKey(WILDCARD_SEARCH_VALUE)) {\n-\n-      String[] requestedWildcardSearchFields =\n-          extractCommaSeparatedFields(params.get(WILDCARD_SEARCH_FIELDS));\n-\n-      taskQuery.wildcardSearchFieldsIn(createWildcardSearchFields(requestedWildcardSearchFields));\n-\n-      taskQuery.wildcardSearchValueLike(params.getFirst(WILDCARD_SEARCH_VALUE));\n-      params.remove(WILDCARD_SEARCH_FIELDS);\n-      params.remove(WILDCARD_SEARCH_VALUE);\n-    }\n-\n-    if (params.containsKey(EXTERNAL_ID)) {\n-      String[] externalIds = extractCommaSeparatedFields(params.get(EXTERNAL_ID));\n-      taskQuery.externalIdIn(externalIds);\n-      params.remove(EXTERNAL_ID);\n-    }\n-\n-    for (TaskCustomField customField : TaskCustomField.values()) {\n-      List<String> customFieldParams =\n-          params.remove(customField.name().replace(\"_\", \"\").toLowerCase());\n-      if (customFieldParams != null) {\n-        String[] customValues = extractCommaSeparatedFields(customFieldParams);\n-        taskQuery.customAttributeIn(customField, customValues);\n-      }\n-    }\n-\n-    if (LOGGER.isDebugEnabled()) {\n-      LOGGER.debug(\"Exit from applyFilterParams(), returning {}\", taskQuery);\n-    }\n-\n-    if (LOGGER.isDebugEnabled()) {\n-      LOGGER.debug(\"Exit from applyFilterParams(), query: {}\", taskQuery);\n-    }\n-  }\n-\n-  private WildcardSearchField[] createWildcardSearchFields(String[] wildcardFields) {\n-\n-    return Stream.of(wildcardFields)\n-        .map(WildcardSearchField::fromString)\n-        .filter(Objects::nonNull)\n-        .toArray(WildcardSearchField[]::new);\n-  }\n-\n-  private void updateTaskQueryWithWorkbasketKey(\n-      TaskQuery taskQuery, MultiValueMap<String, String> params) throws InvalidArgumentException {\n-\n-    String[] domains = null;\n-    if (params.get(DOMAIN) != null) {\n-      domains = extractCommaSeparatedFields(params.get(DOMAIN));\n-    }\n-    if (domains == null || domains.length != 1) {\n-      throw new InvalidArgumentException(\n-          \"workbasket-key requires excactly one domain as second parameter.\");\n-    }\n-    String[] workbasketKeys = extractCommaSeparatedFields(params.get(WORKBASKET_KEY));\n-    KeyDomain[] keyDomains = new KeyDomain[workbasketKeys.length];\n-    for (int i = 0; i < workbasketKeys.length; i++) {\n-      keyDomains[i] = new KeyDomain(workbasketKeys[i], domains[0]);\n-    }\n-    taskQuery.workbasketKeyDomainIn(keyDomains);\n-    params.remove(WORKBASKET_KEY);\n-    params.remove(DOMAIN);\n-  }\n-\n-  private void checkForIllegalParamCombinations(MultiValueMap<String, String> params) {\n-\n-    if (params.containsKey(PLANNED)\n-        && (params.containsKey(PLANNED_FROM) || params.containsKey(PLANNED_UNTIL))) {\n-\n-      throw new IllegalArgumentException(\n-          \"It is prohibited to use the param \\\"\"\n-              + PLANNED\n-              + \"\\\" in combination with the params \\\"\"\n-              + PLANNED_FROM\n-              + \"\\\" and / or \\\"\"\n-              + PLANNED_UNTIL\n-              + \"\\\"\");\n-    }\n-\n-    if (params.containsKey(DUE) && (params.containsKey(DUE_FROM) || params.containsKey(DUE_TO))) {\n-\n-      throw new IllegalArgumentException(\n-          \"It is prohibited to use the param \\\"\"\n-              + DUE\n-              + \"\\\" in combination with the params \\\"\"\n-              + PLANNED_FROM\n-              + \"\\\" and / or \\\"\"\n-              + PLANNED_UNTIL\n-              + \"\\\"\");\n-    }\n+  public enum TaskQuerySortBy implements QuerySortBy<TaskQuery> {\n+    CLASSIFICATION_KEY(TaskQuery::orderByClassificationKey),\n+    POR_TYPE(TaskQuery::orderByPrimaryObjectReferenceType),\n+    POR_VALUE(TaskQuery::orderByPrimaryObjectReferenceValue),\n+    STATE(TaskQuery::orderByState),\n+    NAME(TaskQuery::orderByName),\n+    DUE(TaskQuery::orderByDue),\n+    PLANNED(TaskQuery::orderByPlanned),\n+    PRIORITY(TaskQuery::orderByPriority);\n \n-    if (params.containsKey(WILDCARD_SEARCH_FIELDS) && !params.containsKey(WILDCARD_SEARCH_VALUE)\n-        || !params.containsKey(WILDCARD_SEARCH_FIELDS)\n-            && params.containsKey(WILDCARD_SEARCH_VALUE)) {\n+    private final BiConsumer<TaskQuery, SortDirection> consumer;\n \n-      throw new IllegalArgumentException(\n-          \"The params \"\n-              + WILDCARD_SEARCH_FIELDS\n-              + \" and \"\n-              + WILDCARD_SEARCH_VALUE\n-              + \" must be used together!\");\n+    TaskQuerySortBy(BiConsumer<TaskQuery, SortDirection> consumer) {\n+      this.consumer = consumer;\n     }\n-  }\n-\n-  private void updateTaskQueryWithIndefiniteTimeInterval(\n-      TaskQuery taskQuery,\n-      MultiValueMap<String, String> params,\n-      String param,\n-      TimeInterval timeInterval) {\n-\n-    if (param.equals(PLANNED_FROM) || param.equals(PLANNED_UNTIL)) {\n-      taskQuery.plannedWithin(timeInterval);\n \n-    } else {\n-      taskQuery.dueWithin(timeInterval);\n+    @Override\n+    public void applySortByForQuery(TaskQuery query, SortDirection sortDirection) {\n+      consumer.accept(query, sortDirection);\n     }\n-    params.remove(param);\n   }\n \n-  private TimeInterval createIndefiniteTimeIntervalFromParam(\n-      MultiValueMap<String, String> params, String param) {\n-\n-    if (param.equals(PLANNED_FROM) || param.equals(DUE_FROM)) {\n+  // Unfortunately this class is necessary, since spring can not inject the generic 'sort-by'\n+  // parameter from the super class.\n+  public static class TaskQuerySortParameter\n+      extends QuerySortParameter<TaskQuery, TaskQuerySortBy> {\n \n-      return new TimeInterval(Instant.parse(params.get(param).get(0)), null);\n-\n-    } else {\n-\n-      return new TimeInterval(null, Instant.parse(params.get(param).get(0)));\n+    @ConstructorProperties({\"sort-by\", \"order\"})\n+    public TaskQuerySortParameter(List<TaskQuerySortBy> sortBy, List<SortDirection> order)\n+        throws InvalidArgumentException {\n+      super(sortBy, order);\n     }\n-  }\n \n-  private void updateTaskQueryWithPlannedOrDueTimeInterval(\n-      TaskQuery taskQuery,\n-      MultiValueMap<String, String> params,\n-      String plannedFromOrDueFrom,\n-      String plannedToOrDueTo) {\n-\n-    TimeInterval timeInterval =\n-        new TimeInterval(\n-            Instant.parse(params.get(plannedFromOrDueFrom).get(0)),\n-            Instant.parse(params.get(plannedToOrDueTo).get(0)));\n-\n-    taskQuery.plannedWithin(timeInterval);\n-\n-    params.remove(plannedToOrDueTo);\n-    params.remove(plannedFromOrDueFrom);\n-  }\n-\n-  private void updateTaskQueryWithPlannedOrDueTimeIntervals(\n-      TaskQuery taskQuery, MultiValueMap<String, String> params, String plannedOrDue) {\n-\n-    String[] instants = extractCommaSeparatedFields(params.get(plannedOrDue));\n-\n-    TimeInterval[] timeIntervals = extractTimeIntervals(instants);\n-\n-    taskQuery.plannedWithin(timeIntervals);\n-\n-    params.remove(plannedOrDue);\n-  }\n-\n-  private TimeInterval[] extractTimeIntervals(String[] instants) {\n-\n-    List<TimeInterval> timeIntervalsList = new ArrayList<>();\n-\n-    for (int i = 0; i < instants.length - 1; i += 2) {\n-\n-      TimeInterval timeInterval = determineTimeInterval(instants, i);\n-\n-      if (timeInterval != null) {\n-\n-        timeIntervalsList.add(timeInterval);\n-      }\n+    // this getter is necessary for the documentation!\n+    @Override\n+    public List<TaskQuerySortBy> getSortBy() {\n+      return super.getSortBy();\n     }\n-\n-    TimeInterval[] timeIntervalArray = new TimeInterval[timeIntervalsList.size()];\n-\n-    return timeIntervalsList.toArray(timeIntervalArray);\n-  }\n-\n-  private TimeInterval determineTimeInterval(String[] instants, int i) {\n-\n-    if (!instants[i].equals(INDEFINITE) && !instants[i + 1].equals(INDEFINITE)) {\n-\n-      return new TimeInterval(Instant.parse(instants[i]), Instant.parse(instants[i + 1]));\n-\n-    } else if (instants[i].equals(INDEFINITE) && !instants[i + 1].equals(INDEFINITE)) {\n-\n-      return new TimeInterval(null, Instant.parse(instants[i + 1]));\n-\n-    } else if (!instants[i].equals(INDEFINITE) && instants[i + 1].equals(INDEFINITE)) {\n-\n-      return new TimeInterval(Instant.parse(instants[i]), null);\n-    }\n-\n-    return null;\n-  }\n-\n-  private void applySortingParams(TaskQuery query, MultiValueMap<String, String> params)\n-      throws InvalidArgumentException {\n-    if (LOGGER.isDebugEnabled()) {\n-      LOGGER.debug(\"Entry to applySortingParams(query= {}, params= {})\", query, params);\n-    }\n-\n-    QueryHelper.applyAndRemoveSortingParams(\n-        params,\n-        (sortBy, sortDirection) -> {\n-          switch (sortBy) {\n-            case (CLASSIFICATION_KEY):\n-              query.orderByClassificationKey(sortDirection);\n-              break;\n-            case (POR_TYPE):\n-              query.orderByPrimaryObjectReferenceType(sortDirection);\n-              break;\n-            case (POR_VALUE):\n-              query.orderByPrimaryObjectReferenceValue(sortDirection);\n-              break;\n-            case (STATE):\n-              query.orderByState(sortDirection);\n-              break;\n-            case (NAME):\n-              query.orderByName(sortDirection);\n-              break;\n-            case (DUE):\n-              query.orderByDue(sortDirection);\n-              break;\n-            case (PLANNED):\n-              query.orderByPlanned(sortDirection);\n-              break;\n-            case (PRIORITY):\n-              query.orderByPriority(sortDirection);\n-              break;\n-            default:\n-              throw new InvalidArgumentException(\"Unknown filter attribute: \" + sortBy);\n-          }\n-        });\n-\n-    if (LOGGER.isDebugEnabled()) {\n-      LOGGER.debug(\"Exit from applySortingParams(), returning {}\", query);\n-    }\n-\n-  }\n-\n-  private int[] extractPriorities(String[] prioritiesInString) {\n-    if (LOGGER.isDebugEnabled()) {\n-      LOGGER.debug(\n-          \"Entry to extractPriorities(prioritiesInString= {})\", (Object[]) prioritiesInString);\n-    }\n-\n-    int[] priorities = new int[prioritiesInString.length];\n-    for (int i = 0; i < prioritiesInString.length; i++) {\n-      priorities[i] = Integer.parseInt(prioritiesInString[i]);\n-    }\n-    if (LOGGER.isDebugEnabled()) {\n-      LOGGER.debug(\"Exit from extractPriorities(), returning {}\", priorities);\n-    }\n-\n-    return priorities;\n-  }\n-\n-  private TaskState[] extractStates(MultiValueMap<String, String> params)\n-      throws InvalidArgumentException {\n-    if (LOGGER.isDebugEnabled()) {\n-      LOGGER.debug(\"Entry to extractStates(params= {})\", params);\n-    }\n-\n-    List<TaskState> states = new ArrayList<>();\n-    for (String item : params.get(STATE)) {\n-      for (String state : item.split(\",\")) {\n-        switch (state) {\n-          case STATE_VALUE_READY:\n-            states.add(TaskState.READY);\n-            break;\n-          case STATE_VALUE_COMPLETED:\n-            states.add(TaskState.COMPLETED);\n-            break;\n-          case STATE_VALUE_CLAIMED:\n-            states.add(TaskState.CLAIMED);\n-            break;\n-          default:\n-            throw new InvalidArgumentException(\"Unknown status '\" + state + \"'\");\n-        }\n-      }\n-    }\n-\n-    LOGGER.debug(\"Exit from extractStates()\");\n-    return states.toArray(new TaskState[0]);\n   }\n }\n", "next_change": {"commit": "b9b49f47a13e748be20bf73ed605f0dfde7fcf70", "changed_code": [{"header": "diff --git a/rest/taskana-rest-spring/src/main/java/pro/taskana/task/rest/TaskController.java b/rest/taskana-rest-spring/src/main/java/pro/taskana/task/rest/TaskController.java\nindex f54c8f059..d5da13b20 100644\n--- a/rest/taskana-rest-spring/src/main/java/pro/taskana/task/rest/TaskController.java\n+++ b/rest/taskana-rest-spring/src/main/java/pro/taskana/task/rest/TaskController.java\n", "chunk": "@@ -467,4 +734,7 @@ public class TaskController {\n       return super.getSortBy();\n     }\n   }\n+\n+  // endregion\n+\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "969d3eeff653d51eb7dcf5234aa4020333613ab3", "message": "Merge commit", "committedDate": null}, {"oid": "b321c495ba10f5d2b5137321809be857c825880e", "committedDate": "2020-07-01 10:39:53 +0200", "message": ".. and more code smells \ud83d\udca9 - it stinks"}, {"oid": "d8ad7a7fb96e7d07e5f93e202cd84e03e5c1944a", "committedDate": "2020-07-10 13:13:42 +0200", "message": "TSK-1250 On demand deletion of historical data"}, {"oid": "4bba93c5a98dcbe22dc86144b12507abce4b2be4", "committedDate": "2020-07-10 13:13:42 +0200", "message": "Review findings"}, {"oid": "9e44ca614000475810e9c0aa214a1006e19d33e8", "committedDate": "2020-07-10 14:33:32 +0200", "message": "TSK-1331: allowed multiple sortBy declarations in REST api"}, {"oid": "7cc5b00be617227dac2f8d1210554108d18bad4a", "committedDate": "2020-07-24 01:05:42 +0200", "message": "TSK-1345: replaced every customField API call with CustomField enums"}, {"oid": "231d009d8191466bf91f675667ed6cb0cd228aec", "committedDate": "2020-09-14 10:13:07 +0200", "message": "TSK-1379: Verify customAttributes format in taskRepresentationModel"}, {"oid": "333bef03bef6c30965aa0f888daa9b69b7397806", "committedDate": "2020-09-14 10:13:07 +0200", "message": "TSK-1379: Renamed test case"}, {"oid": "a64f8e14f35c760629f5de3feb45b1afba9efe3d", "committedDate": "2020-09-15 10:16:47 +0200", "message": "TSK-1382: Fix wildcard-search"}, {"oid": "3849ee385f2861c3bb58cc4cb4499f3cd1aaf87c", "committedDate": "2020-10-29 13:02:41 +0100", "message": "TSK-1429: automatically formatted all backend code"}, {"oid": "6dc782e37ac378b636daaef8d9134d17294845d2", "committedDate": "2020-10-30 01:36:27 +0100", "message": "TSK-1430: Rename Mapping to RestEndpoints, groups relevant endpoints together"}, {"oid": "3967e2900e8b35329b3675844ca3a8e059916c7e", "committedDate": "2020-12-18 11:29:10 +0100", "message": "TSK-1436: rest api documentation is now build with spring-auto-restdocs"}, {"oid": "de57596ba8e816d3e751b21c949a3fe132b314f0", "committedDate": "2020-12-18 11:29:10 +0100", "message": "TSK-1436: reworked review comments."}, {"oid": "727b3ba3b59da9a3c8b4abb8456be8027138e1eb", "committedDate": "2020-12-18 11:29:10 +0100", "message": "TSK-1436: integraded wording feedback from team"}, {"oid": "4c48ce4826adb6980bed7c07e4a9b71a82d496ba", "committedDate": "2021-02-03 15:39:51 +0100", "message": "TSK-1530: Add a REST endpoint to cancel a task"}, {"oid": "e7ac77cd39d2d02dcc8621448e6b5e36b0eb35dc", "committedDate": "2021-02-24 11:09:11 +0100", "message": "TSK-1544: Throw error for unknown query parameter"}, {"oid": "0119999380b40fdc0f69677f96650de5c81bd2a5", "committedDate": "2021-03-09 18:58:51 +0100", "message": "TSK-1538: Added transfer method with control setTransferFlag (#1513)"}, {"oid": "3d27f54e0f1f7d3751f8c78e7645b2f3603de9b4", "committedDate": "2021-05-10 09:11:10 +0200", "message": "TSK-1635: Make forceCancelClaim of a task available in the REST-API"}, {"oid": "bfcabea61048ccb21a591e0c4f1f8efecc7636b4", "committedDate": "2021-05-20 09:41:58 +0200", "message": "TSK-1596: Automatic TraceLogging (#1577)"}, {"oid": "1c83b7871f144cd07a912639b942d5938219e101", "committedDate": "2021-06-22 16:14:09 +0200", "message": "TSK-1646: Bugfix for creation / update of Task with invalid Attachment"}, {"oid": "039ec5a464720376f9bc8e059698275650e003f9", "committedDate": "2021-07-02 14:38:26 +0200", "message": "TSK-1661: Added sort-by parameters for all entities. (#1624)"}, {"oid": "99eba636a1ec363282153ae857f651d2c5d2e592", "committedDate": "2021-07-29 14:58:57 +0200", "message": "TSK-1674: Added received timestamp to task (#1638)"}, {"oid": "6dfb751bee7004db2363134157500b53f2d8bbc6", "committedDate": "2021-08-02 21:23:10 +0200", "message": "TSK-1659: Expanded TimeIntervalReportBuilder with custom-X filter"}, {"oid": "967e59e012f94e116f2b327b6c426f44ae1bcbee", "committedDate": "2022-02-25 10:23:40 +0100", "message": "TSK-1800: add secondary object references"}, {"oid": "4444816589a105a2278f39cf479613e147811351", "committedDate": "2022-03-25 10:31:52 +0100", "message": "TSK-1827: add sorting by ownerLongName"}, {"oid": "93d0b27bb058a4f47218177136bce81f99103345", "committedDate": "2022-04-26 15:27:56 +0200", "message": "TSK-1831: dropped support for JDK8"}, {"oid": "70c64dd66e28d36bd7e8f38c88fcfbe70473ed0f", "committedDate": "2022-08-02 14:35:13 +0200", "message": "TSK-1837: Add custom-int-x-from and custom-int-x-to to rest"}, {"oid": "42f7eea2f2d4ee89e6c499dae0e0aed006305370", "committedDate": "2022-08-11 17:08:10 +0200", "message": "TSK-1943: added REST endpoint for requesting a review on a Task"}, {"oid": "bbb01653f5a26ce2c324e6b90d9b274ad3d1da69", "committedDate": "2022-08-11 17:08:10 +0200", "message": "TSK-1943: added REST endpoint for requesting changes on a Task"}, {"oid": "6997d640834819d21fe0325178d73bbf70de68fc", "committedDate": "2022-08-11 17:08:10 +0200", "message": "TSK-1943: added REST endpoint for force requesting changes on a Task"}, {"oid": "5f4923fe0a931ec290a4025deda6ad0dcd85b239", "committedDate": "2022-08-11 17:08:10 +0200", "message": "TSK-1943: added REST endpoint for force requesting a review on a Task"}, {"oid": "b9b49f47a13e748be20bf73ed605f0dfde7fcf70", "committedDate": "2022-10-20 14:20:24 +0200", "message": "TSK-1965: create endpoints for all state transitions (#2024)"}, {"oid": "20d389a7d524c156b063dfc91589bb22bebea0d7", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-1992 remove unnecessary ParentExceptions"}, {"oid": "d21eb47ffea4c2c9fff8f1d3435b77b805d03508", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-2012: renamed Mismatched_Exceptions to NotAuthorizedExceptions"}, {"oid": "37280cc73b83e2d39ab4afddd40256719d64c50c", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-2013 selectAndClaim TasK return Optional and does not throw Exception if Task is notFound"}, {"oid": "55d939ca7b7720ab12f488ed8fc2a631ecc6f05c", "committedDate": "2023-03-13 19:02:53 +0100", "message": "format entire codebase with new google-java-format version"}]}, {"oid": "7d0edb6ba219885935b7bc1a69b5af8ebc9c5862", "url": "https://github.com/Taskana/taskana/commit/7d0edb6ba219885935b7bc1a69b5af8ebc9c5862", "message": "TSK-1275: Support select and claim in one API call", "committedDate": "2020-06-30T11:19:02Z", "type": "commit"}, {"oid": "808d5e604539f2f4e5e13e86b00c627a78e1b762", "url": "https://github.com/Taskana/taskana/commit/808d5e604539f2f4e5e13e86b00c627a78e1b762", "message": "review Findings", "committedDate": "2020-06-30T12:39:49Z", "type": "commit"}]}