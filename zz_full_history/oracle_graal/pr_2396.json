{"pr_number": 2396, "pr_title": "Windows debug information prototype", "pr_author": "stooke", "pr_createdAt": "2020-04-24T20:02:43Z", "pr_url": "https://github.com/oracle/graal/pull/2396", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc0ODk3Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r415748977", "body": "For that I'd use:\r\n```java\r\npublic static Range withLoHi(int lo, int hi) {\r\n    Range that = this.clone();\r\n    that.lo = lo;\r\n    that.hi = hi;\r\n}\r\n```", "bodyText": "For that I'd use:\npublic static Range withLoHi(int lo, int hi) {\n    Range that = this.clone();\n    that.lo = lo;\n    that.hi = hi;\n}", "bodyHTML": "<p dir=\"auto\">For that I'd use:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"public static Range withLoHi(int lo, int hi) {\n    Range that = this.clone();\n    that.lo = lo;\n    that.hi = hi;\n}\n\"><pre><span class=\"pl-k\">public</span> <span class=\"pl-k\">static</span> <span class=\"pl-smi\">Range</span> withLoHi(<span class=\"pl-k\">int</span> lo, <span class=\"pl-k\">int</span> hi) {\n    <span class=\"pl-smi\">Range</span> that <span class=\"pl-k\">=</span> <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>clone();\n    that<span class=\"pl-k\">.</span>lo <span class=\"pl-k\">=</span> lo;\n    that<span class=\"pl-k\">.</span>hi <span class=\"pl-k\">=</span> hi;\n}</pre></div>", "author": "olpaw", "createdAt": "2020-04-27T11:55:37Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java", "diffHunk": "@@ -79,6 +83,25 @@ public Range(String fileName, Path filePath, String className, String methodName\n         this.primary = primary;\n     }\n \n+    /*\n+     * Create a slightly different copy of a previously constructed range. Because the previous\n+     * range was constructed by one of the other constructors, a valid assumption is that all the\n+     * strings have previously been inserted int he stringTable, and we can avoid doing that again.\n+     */\n+    public Range(Range other, int lo, int hi) {", "originalCommit": "ae54dad6eebb244a96e6123cb61380f282cece47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA1MTU4OQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r418051589", "bodyText": "This is much cleaner.  My goal was to avoid modifying Range members after construction (I want to make them final), and to avoid calling uniqueString() multiple times.\nWhile your suggestion doesn't help with my goal of immutability, it is much more readable.\nI've adopted it, and may make immutability a separate PR after some discussion.", "author": "stooke", "createdAt": "2020-04-30T14:26:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc0ODk3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "ca3de5eafeddfb59dc7c8bf2ca2eb828d6c8b457", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 4f88f5fd930..489dafbb6a1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -83,25 +79,6 @@ public class Range {\n         this.primary = primary;\n     }\n \n-    /*\n-     * Create a slightly different copy of a previously constructed range. Because the previous\n-     * range was constructed by one of the other constructors, a valid assumption is that all the\n-     * strings have previously been inserted int he stringTable, and we can avoid doing that again.\n-     */\n-    public Range(Range other, int lo, int hi) {\n-        this.fileName = other.fileName;\n-        this.filePath = other.filePath;\n-        this.className = other.className;\n-        this.methodName = other.methodName;\n-        this.paramNames = other.paramNames;\n-        this.returnTypeName = other.returnTypeName;\n-        this.fullMethodName = other.fullMethodName;\n-        this.lo = lo;\n-        this.hi = hi;\n-        this.line = other.line;\n-        this.primary = other.primary;\n-    }\n-\n     public boolean contains(Range other) {\n         return (lo <= other.lo && hi >= other.hi);\n     }\n", "next_change": {"commit": "866605d71e3cc625c19cf37e097e7a3e5ce6a985", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 489dafbb6a1..8bd16b9a1ed 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -76,6 +83,7 @@ public class Range {\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n+        this.isDeoptTarget = isDeoptTarget;\n         this.primary = primary;\n     }\n \n", "next_change": {"commit": "b307ee84155fb340719a658a7be2cc9159c49c02", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 8bd16b9a1ed..6cdd3ed052a 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -55,35 +57,42 @@ public class Range {\n     /*\n      * Create a primary range.\n      */\n-    public Range(String fileName, Path filePath, String className, String methodName, String paramNames, String returnTypeName, StringTable stringTable, int lo, int hi, int line, boolean isDeoptTarget) {\n-        this(fileName, filePath, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, line, isDeoptTarget, null);\n+    public Range(String className, String methodName, String symbolName, String paramSignature, String returnTypeName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n+                    int modifiers, boolean isDeoptTarget) {\n+        this(className, methodName, symbolName, paramSignature, returnTypeName, stringTable, fileEntry, lo, hi, line, modifiers, isDeoptTarget, null);\n     }\n \n     /*\n      * Create a secondary range.\n      */\n-    public Range(String fileName, Path filePath, String className, String methodName, String paramNames, String returnTypeName, StringTable stringTable, int lo, int hi, int line, Range primary) {\n-        this(fileName, filePath, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, line, false, primary);\n+    public Range(String className, String methodName, String symbolName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n+                    Range primary) {\n+        this(className, methodName, symbolName, \"\", \"\", stringTable, fileEntry, lo, hi, line, 0, false, primary);\n     }\n+\n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(String fileName, Path filePath, String className, String methodName, String paramNames, String returnTypeName, StringTable stringTable, int lo, int hi, int line, boolean isDeoptTarget, Range primary) {\n-        /*\n-         * Currently file name and full method name need to go into the debug_str section other\n-         * strings just need to be deduplicated to save space.\n-         */\n-        this.fileName = (fileName == null ? null : stringTable.uniqueDebugString(fileName));\n-        this.filePath = filePath;\n+    private Range(String className, String methodName, String symbolName, String paramSignature, String returnTypeName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n+                    int modifiers, boolean isDeoptTarget, Range primary) {\n+        this.fileEntry = fileEntry;\n+        if (fileEntry != null) {\n+            stringTable.uniqueDebugString(fileEntry.getFileName());\n+            stringTable.uniqueDebugString(fileEntry.getPathName());\n+        }\n         this.className = stringTable.uniqueString(className);\n         this.methodName = stringTable.uniqueString(methodName);\n-        this.paramNames = stringTable.uniqueString(paramNames);\n+        this.symbolName = stringTable.uniqueString(symbolName);\n+        this.paramSignature = stringTable.uniqueString(paramSignature);\n         this.returnTypeName = stringTable.uniqueString(returnTypeName);\n-        this.fullMethodName = stringTable.uniqueDebugString(constructClassAndMethodNameWithParams());\n+        this.fullMethodName = stringTable.uniqueString(constructClassAndMethodName());\n+        this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n+        this.fullMethodNameWithParamsAndReturnType = stringTable.uniqueString(constructClassAndMethodNameWithParamsAndReturnType());\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n         this.isDeoptTarget = isDeoptTarget;\n+        this.modifiers = modifiers;\n         this.primary = primary;\n     }\n \n", "next_change": {"commit": "b384283b5ac0e455e66648c0d661ce5410bdd863", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 6cdd3ed052a..9bea361bef6 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -34,65 +34,52 @@ package com.oracle.objectfile.debugentry;\n \n public class Range {\n     private static final String CLASS_DELIMITER = \".\";\n-    private FileEntry fileEntry;\n-    private String className;\n-    private String methodName;\n-    private String symbolName;\n-    private String paramSignature;\n-    private String returnTypeName;\n-    private String methodNameWithParams;\n-    private String fullMethodName;\n-    private String fullMethodNameWithParams;\n-    private String fullMethodNameWithParamsAndReturnType;\n-    private int lo;\n-    private int hi;\n-    private int line;\n-    private boolean isDeoptTarget;\n-    private int modifiers;\n+    private final FileEntry fileEntry;\n+    private MethodEntry methodEntry;\n+    private final String symbolName;\n+    private final String fullMethodNameWithParams;\n+    private final int lo;\n+    private final int hi;\n+    private final int line;\n+    private final boolean isDeoptTarget;\n     /*\n      * This is null for a primary range.\n      */\n-    private Range primary;\n+    private final Range primary;\n \n     /*\n      * Create a primary range.\n      */\n-    public Range(String className, String methodName, String symbolName, String paramSignature, String returnTypeName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n-                    int modifiers, boolean isDeoptTarget) {\n-        this(className, methodName, symbolName, paramSignature, returnTypeName, stringTable, fileEntry, lo, hi, line, modifiers, isDeoptTarget, null);\n+    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n+                 boolean isDeoptTarget) {\n+        this(symbolName, stringTable, methodEntry, fileEntry, lo, hi, line, isDeoptTarget, null);\n     }\n \n     /*\n      * Create a secondary range.\n      */\n-    public Range(String className, String methodName, String symbolName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n-                    Range primary) {\n-        this(className, methodName, symbolName, \"\", \"\", stringTable, fileEntry, lo, hi, line, 0, false, primary);\n+    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n+        this(symbolName, stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, false, primary);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(String className, String methodName, String symbolName, String paramSignature, String returnTypeName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n-                    int modifiers, boolean isDeoptTarget, Range primary) {\n-        this.fileEntry = fileEntry;\n+    private Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n+                    boolean isDeoptTarget, Range primary) {\n+        this.fileEntry = fileEntry; // TODO remove and use fileEntry from MethodEntry\n         if (fileEntry != null) {\n             stringTable.uniqueDebugString(fileEntry.getFileName());\n             stringTable.uniqueDebugString(fileEntry.getPathName());\n         }\n-        this.className = stringTable.uniqueString(className);\n-        this.methodName = stringTable.uniqueString(methodName);\n+        assert methodEntry != null;\n+        this.methodEntry = methodEntry;\n         this.symbolName = stringTable.uniqueString(symbolName);\n-        this.paramSignature = stringTable.uniqueString(paramSignature);\n-        this.returnTypeName = stringTable.uniqueString(returnTypeName);\n-        this.fullMethodName = stringTable.uniqueString(constructClassAndMethodName());\n         this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n-        this.fullMethodNameWithParamsAndReturnType = stringTable.uniqueString(constructClassAndMethodNameWithParamsAndReturnType());\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n         this.isDeoptTarget = isDeoptTarget;\n-        this.modifiers = modifiers;\n         this.primary = primary;\n     }\n \n", "next_change": {"commit": "f485a3c15f5e29daf480657c0bfa22662f8005ae", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 9bea361bef6..a3d6e1c0db2 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -79,7 +77,6 @@ public class Range {\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n-        this.isDeoptTarget = isDeoptTarget;\n         this.primary = primary;\n     }\n \n", "next_change": {"commit": "dbb2c7607429817e58a1a9af8012e25e861368dc", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex a3d6e1c0db2..af465363bbf 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -49,30 +48,29 @@ public class Range {\n     /*\n      * Create a primary range.\n      */\n-    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n-        this(symbolName, stringTable, methodEntry, fileEntry, lo, hi, line, null);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n+        this(stringTable, methodEntry, fileEntry, lo, hi, line, null);\n     }\n \n     /*\n      * Create a secondary range.\n      */\n-    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n-        this(symbolName, stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n+        this(stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n+    private Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n                     Range primary) {\n-        this.fileEntry = fileEntry; // TODO remove and use fileEntry from MethodEntry\n+        this.fileEntry = fileEntry;\n         if (fileEntry != null) {\n             stringTable.uniqueDebugString(fileEntry.getFileName());\n             stringTable.uniqueDebugString(fileEntry.getPathName());\n         }\n         assert methodEntry != null;\n         this.methodEntry = methodEntry;\n-        this.symbolName = stringTable.uniqueString(symbolName);\n         this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n         this.lo = lo;\n         this.hi = hi;\n", "next_change": {"commit": "a658b95d63a93b1980e4ac81fd4c034c70b9d9cb", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex af465363bbf..5f7f3fe3bda 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -48,28 +47,19 @@ public class Range {\n     /*\n      * Create a primary range.\n      */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n-        this(stringTable, methodEntry, fileEntry, lo, hi, line, null);\n-    }\n-\n-    /*\n-     * Create a secondary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n-        this(stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line) {\n+        this(stringTable, methodEntry, lo, hi, line, null);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n-                    Range primary) {\n-        this.fileEntry = fileEntry;\n-        if (fileEntry != null) {\n-            stringTable.uniqueDebugString(fileEntry.getFileName());\n-            stringTable.uniqueDebugString(fileEntry.getPathName());\n-        }\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n         assert methodEntry != null;\n+        if (methodEntry.fileEntry != null) {\n+            stringTable.uniqueDebugString(methodEntry.fileEntry.getFileName());\n+            stringTable.uniqueDebugString(methodEntry.fileEntry.getPathName());\n+        }\n         this.methodEntry = methodEntry;\n         this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n         this.lo = lo;\n", "next_change": {"commit": "6fcf98378231f0e754061b683c3dba387ce8b0e9", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 5f7f3fe3bda..cc407a53acd 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -65,7 +68,10 @@ public class Range {\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n+        this.isInlined = isInline;\n         this.primary = primary;\n+        this.withChildren = withChildren;\n+        this.caller = caller;\n     }\n \n     public boolean contains(Range other) {\n", "next_change": {"commit": "abe98eaaa6dd772b7419b819fa342e810a0939e0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex cc407a53acd..037024f1755 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -71,6 +74,7 @@ public class Range {\n         this.isInlined = isInline;\n         this.primary = primary;\n         this.withChildren = withChildren;\n+        this.withInlinedChildren = false;\n         this.caller = caller;\n     }\n \n", "next_change": {"commit": "268c33256b26217c50339f452adea942fb48818f", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 037024f1755..1951241dda1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -73,9 +93,32 @@ public class Range {\n         this.line = line;\n         this.isInlined = isInline;\n         this.primary = primary;\n-        this.withChildren = withChildren;\n-        this.withInlinedChildren = false;\n+        this.firstCallee = null;\n+        this.lastCallee = null;\n+        this.nextCallee = null;\n         this.caller = caller;\n+        if (caller != null) {\n+            caller.addCallee(this);\n+        }\n+        if (this.isPrimary()) {\n+            this.depth = -1;\n+        } else {\n+            this.depth = caller.depth + 1;\n+        }\n+    }\n+\n+    private void addCallee(Range callee) {\n+        assert this.lo <= callee.lo;\n+        assert this.hi >= callee.hi;\n+        assert callee.caller == this;\n+        assert callee.nextCallee == null;\n+        if (this.firstCallee == null) {\n+            assert this.lastCallee == null;\n+            this.firstCallee = this.lastCallee = callee;\n+        } else {\n+            this.lastCallee.nextCallee = callee;\n+            this.lastCallee = callee;\n+        }\n     }\n \n     public boolean contains(Range other) {\n", "next_change": {"commit": "6ae5665ec0f5f89ff4a7804dbeec25c85d0982ea", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 1951241dda1..43c64a540e9 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -111,12 +111,12 @@ public class Range {\n         assert this.lo <= callee.lo;\n         assert this.hi >= callee.hi;\n         assert callee.caller == this;\n-        assert callee.nextCallee == null;\n+        assert callee.siblingCallee == null;\n         if (this.firstCallee == null) {\n             assert this.lastCallee == null;\n             this.firstCallee = this.lastCallee = callee;\n         } else {\n-            this.lastCallee.nextCallee = callee;\n+            this.lastCallee.siblingCallee = callee;\n             this.lastCallee = callee;\n         }\n     }\n", "next_change": {"commit": "9acf1c5d597e38f3e832360ce3f372ad94b16e9e", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\ndeleted file mode 100644\nindex 43c64a540e9..00000000000\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ /dev/null\n", "chunk": "@@ -1,339 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.objectfile.debugentry;\n-\n-import org.graalvm.compiler.debug.DebugContext;\n-\n-/**\n- * Details of a specific address range in a compiled method either a primary range identifying a\n- * whole method or a sub-range identifying a sequence of instructions that belong to an inlined\n- * method. Each sub-range is linked with its caller and its callees, forming a call tree.\n- */\n-public class Range {\n-    private static final String CLASS_DELIMITER = \".\";\n-    private Range caller;\n-    private final MethodEntry methodEntry;\n-    private final String fullMethodName;\n-    private final String fullMethodNameWithParams;\n-    private final int lo;\n-    private int hi;\n-    private final int line;\n-    private final boolean isInlined;\n-    private final int depth;\n-    /**\n-     * This is null for a primary range. For sub ranges it holds the root of the call tree they\n-     * belong to.\n-     */\n-    private final Range primary;\n-\n-    /*\n-     * Support for tree of nested inline callee ranges\n-     */\n-\n-    /**\n-     * The first direct callee whose range is wholly contained in this range.\n-     */\n-    private Range firstCallee;\n-\n-    /**\n-     * The last direct callee whose range is wholly contained in this range.\n-     */\n-    private Range lastCallee;\n-\n-    /**\n-     * A link to a sibling callee, i.e., a range sharing the same caller with this range.\n-     */\n-    private Range siblingCallee;\n-\n-    /*\n-     * Create a primary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line) {\n-        this(stringTable, methodEntry, lo, hi, line, null, false, null);\n-    }\n-\n-    /*\n-     * Create a primary or secondary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary, boolean isInline, Range caller) {\n-        assert methodEntry != null;\n-        if (methodEntry.fileEntry != null) {\n-            stringTable.uniqueDebugString(methodEntry.fileEntry.getFileName());\n-            stringTable.uniqueDebugString(methodEntry.fileEntry.getPathName());\n-        }\n-        this.methodEntry = methodEntry;\n-        this.fullMethodName = isInline ? stringTable.uniqueDebugString(constructClassAndMethodName()) : stringTable.uniqueString(constructClassAndMethodName());\n-        this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n-        this.lo = lo;\n-        this.hi = hi;\n-        this.line = line;\n-        this.isInlined = isInline;\n-        this.primary = primary;\n-        this.firstCallee = null;\n-        this.lastCallee = null;\n-        this.siblingCallee = null;\n-        this.caller = caller;\n-        if (caller != null) {\n-            caller.addCallee(this);\n-        }\n-        if (this.isPrimary()) {\n-            this.depth = -1;\n-        } else {\n-            this.depth = caller.depth + 1;\n-        }\n-    }\n-\n-    private void addCallee(Range callee) {\n-        assert this.lo <= callee.lo;\n-        assert this.hi >= callee.hi;\n-        assert callee.caller == this;\n-        assert callee.siblingCallee == null;\n-        if (this.firstCallee == null) {\n-            assert this.lastCallee == null;\n-            this.firstCallee = this.lastCallee = callee;\n-        } else {\n-            this.lastCallee.siblingCallee = callee;\n-            this.lastCallee = callee;\n-        }\n-    }\n-\n-    public boolean contains(Range other) {\n-        return (lo <= other.lo && hi >= other.hi);\n-    }\n-\n-    public boolean isPrimary() {\n-        return getPrimary() == null;\n-    }\n-\n-    public Range getPrimary() {\n-        return primary;\n-    }\n-\n-    public String getClassName() {\n-        return methodEntry.ownerType.typeName;\n-    }\n-\n-    public String getMethodName() {\n-        return methodEntry.memberName;\n-    }\n-\n-    public String getSymbolName() {\n-        return methodEntry.getSymbolName();\n-    }\n-\n-    public int getHi() {\n-        return hi;\n-    }\n-\n-    public int getLo() {\n-        return lo;\n-    }\n-\n-    public int getLine() {\n-        return line;\n-    }\n-\n-    public String getFullMethodName() {\n-        return fullMethodName;\n-    }\n-\n-    public String getFullMethodNameWithParams() {\n-        return fullMethodNameWithParams;\n-    }\n-\n-    public boolean isDeoptTarget() {\n-        return methodEntry.isDeopt();\n-    }\n-\n-    private String getExtendedMethodName(boolean includeClass, boolean includeParams, boolean includeReturnType) {\n-        StringBuilder builder = new StringBuilder();\n-        if (includeReturnType && methodEntry.valueType.typeName.length() > 0) {\n-            builder.append(methodEntry.valueType.typeName);\n-            builder.append(' ');\n-        }\n-        if (includeClass && getClassName() != null) {\n-            builder.append(getClassName());\n-            builder.append(CLASS_DELIMITER);\n-        }\n-        builder.append(getMethodName());\n-        if (includeParams) {\n-            builder.append('(');\n-            builder.append(String.join(\", \", methodEntry.paramNames));\n-            builder.append(')');\n-        }\n-        if (includeReturnType) {\n-            builder.append(\" \");\n-            builder.append(methodEntry.valueType.typeName);\n-        }\n-        return builder.toString();\n-    }\n-\n-    private String constructClassAndMethodName() {\n-        return getExtendedMethodName(true, false, false);\n-    }\n-\n-    private String constructClassAndMethodNameWithParams() {\n-        return getExtendedMethodName(true, true, false);\n-    }\n-\n-    public FileEntry getFileEntry() {\n-        return methodEntry.fileEntry;\n-    }\n-\n-    public int getModifiers() {\n-        return methodEntry.modifiers;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"Range(lo=0x%05x hi=0x%05x %s %s:%d)\", lo, hi, constructClassAndMethodNameWithParams(), methodEntry.getFullFileName(), line);\n-    }\n-\n-    public String getFileName() {\n-        return methodEntry.getFileName();\n-    }\n-\n-    public MethodEntry getMethodEntry() {\n-        return methodEntry;\n-    }\n-\n-    public boolean isInlined() {\n-        return isInlined;\n-    }\n-\n-    public Range getCaller() {\n-        return caller;\n-    }\n-\n-    public Range getFirstCallee() {\n-        return firstCallee;\n-    }\n-\n-    public Range getSiblingCallee() {\n-        return siblingCallee;\n-    }\n-\n-    public Range getLastCallee() {\n-        return lastCallee;\n-    }\n-\n-    public boolean isLeaf() {\n-        return firstCallee == null;\n-    }\n-\n-    public int getDepth() {\n-        return depth;\n-    }\n-\n-    /**\n-     * Minimizes the nodes in the tree that track the inline call hierarchy and associated code\n-     * ranges. The initial range tree models the call hierarchy as presented in the original debug\n-     * line info. It consists of a root node each of whose children is a sequence of linear call\n-     * chains, either a single leaf node for some given file and line or a series of inline calls to\n-     * such a leaf node. In this initial tree all node ranges in a given chain have the same lo and\n-     * hi address and chains are properly ordered by range The merge algorithm works across siblings\n-     * at successive depths starting at depth 1. Once all possible nodes at a given depth have been\n-     * merged their children can then be merged. A successor node may only be merged into its\n-     * predecessor if the nodes have contiguous ranges and idenitfy the same method, line and file.\n-     * The range and children of the merged node are, respectively, the union of the input ranges\n-     * and children. This preserves the invariant that child ranges lie within their parent range.\n-     *\n-     * @param debugContext\n-     */\n-    public void mergeSubranges(DebugContext debugContext) {\n-        Range next = getFirstCallee();\n-        if (next == null) {\n-            return;\n-        }\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Merge subranges [0x%x, 0x%x] %s\", lo, hi, getFullMethodNameWithParams());\n-        /* merge siblings together if possible, reparenting children to the merged node */\n-        while (next != null) {\n-            next = next.maybeMergeSibling(debugContext);\n-        }\n-        /* now recurse down to merge children of whatever nodes remain */\n-        next = getFirstCallee();\n-        /* now this level is merged recursively merge children of each child node. */\n-        while (next != null) {\n-            next.mergeSubranges(debugContext);\n-            next = next.getSiblingCallee();\n-        }\n-    }\n-\n-    /**\n-     * Removes and merges the next sibling returning the current node or it skips past the current\n-     * node as is and returns the next sibling or null if no sibling exists.\n-     */\n-    private Range maybeMergeSibling(DebugContext debugContext) {\n-        Range sibling = getSiblingCallee();\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Merge subrange (maybe) [0x%x, 0x%x] %s\", lo, hi, getFullMethodNameWithParams());\n-        if (sibling == null) {\n-            /* all child nodes at this level have been merged */\n-            return null;\n-        }\n-        if (hi < sibling.lo) {\n-            /* cannot merge non-contiguous ranges, move on. */\n-            return sibling;\n-        }\n-        if (getMethodEntry() != sibling.getMethodEntry()) {\n-            /* cannot merge distinct callers, move on. */\n-            return sibling;\n-        }\n-        if (getLine() != sibling.getLine()) {\n-            /* cannot merge callers with different line numbers, move on. */\n-            return sibling;\n-        }\n-        /* splice out the sibling from the chain and update this one to include it. */\n-        unlink(debugContext, sibling);\n-        /* relocate the siblings children to this node. */\n-        reparentChildren(debugContext, sibling);\n-        /* return the merged node so we can maybe merge it again. */\n-        return this;\n-    }\n-\n-    private void unlink(DebugContext debugContext, Range sibling) {\n-        assert hi == sibling.lo : String.format(\"gap in range [0x%x,0x%x] %s [0x%x,0x%x] %s\",\n-                        lo, hi, getFullMethodNameWithParams(), sibling.getLo(), sibling.getHi(), sibling.getFullMethodNameWithParams());\n-        assert this.isInlined == sibling.isInlined : String.format(\"change in inlined [0x%x,0x%x] %s %s [0x%x,0x%x] %s %s\",\n-                        lo, hi, getFullMethodNameWithParams(), Boolean.valueOf(this.isInlined), sibling.lo, sibling.hi, sibling.getFullMethodNameWithParams(), Boolean.valueOf(sibling.isInlined));\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Combining [0x%x, 0x%x] %s into [0x%x, 0x%x] %s\", sibling.lo, sibling.hi, sibling.getFullMethodName(), lo, hi, getFullMethodNameWithParams());\n-        this.hi = sibling.hi;\n-        this.siblingCallee = sibling.siblingCallee;\n-    }\n-\n-    private void reparentChildren(DebugContext debugContext, Range sibling) {\n-        Range siblingNext = sibling.getFirstCallee();\n-        while (siblingNext != null) {\n-            debugContext.log(DebugContext.INFO_LEVEL, \"Reparenting [0x%x, 0x%x] %s to [0x%x, 0x%x] %s\", siblingNext.lo, siblingNext.hi, siblingNext.getFullMethodName(), lo, hi,\n-                            getFullMethodNameWithParams());\n-            siblingNext.caller = this;\n-            Range newSiblingNext = siblingNext.siblingCallee;\n-            siblingNext.siblingCallee = null;\n-            addCallee(siblingNext);\n-            siblingNext = newSiblingNext;\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc1MDMwMQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r415750301", "body": "It would be great if we find a CLASS_DELIMITER that works for both platforms.", "bodyText": "It would be great if we find a CLASS_DELIMITER that works for both platforms.", "bodyHTML": "<p dir=\"auto\">It would be great if we find a CLASS_DELIMITER that works for both platforms.</p>", "author": "olpaw", "createdAt": "2020-04-27T11:57:39Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java", "diffHunk": "@@ -36,6 +36,10 @@\n  */\n \n public class Range {\n+\n+    /* Use '.' for PECOFF files */\n+    private static final String CLASS_DELIMITER = System.getProperty(\"os.name\").toLowerCase().contains(\"windows\") ? \".\" : \"::\";", "originalCommit": "ae54dad6eebb244a96e6123cb61380f282cece47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjcyOTcwMw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r416729703", "bodyText": "Well, I only used :: because I was mimicking the format used for C++ code (gdb doesn't really understand Java). Once we embed DWARF method info records into a DWARF type info record this ought not to be a concern. So, I am happy to go with '. as the separator.", "author": "adinn", "createdAt": "2020-04-28T15:55:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc1MDMwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEyMDUwMQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r417120501", "bodyText": "Yes. Please lets use . as CLASS_DELIMITER for all platforms.", "author": "olpaw", "createdAt": "2020-04-29T07:34:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc1MDMwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEwNDIyMg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r418104222", "bodyText": "@adinn, if I change this to always be '.' in this PR, is it too soon, or would you prefer to wait until there are DWARF MethodInfo records?", "author": "stooke", "createdAt": "2020-04-30T15:39:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc1MDMwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE1MDY3MQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r418150671", "bodyText": "No, please change it to use '.' for both.", "author": "adinn", "createdAt": "2020-04-30T16:51:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc1MDMwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "ca3de5eafeddfb59dc7c8bf2ca2eb828d6c8b457", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 4f88f5fd930..489dafbb6a1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -36,10 +36,6 @@ import java.nio.file.Paths;\n  */\n \n public class Range {\n-\n-    /* Use '.' for PECOFF files */\n-    private static final String CLASS_DELIMITER = System.getProperty(\"os.name\").toLowerCase().contains(\"windows\") ? \".\" : \"::\";\n-\n     private String fileName;\n     private Path filePath;\n     private String className;\n", "next_change": {"commit": "4f231abdcb1b44ea570aef3acfbbe2f3d34e4898", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 489dafbb6a1..635cb9a6ea1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -36,6 +36,7 @@ import java.nio.file.Paths;\n  */\n \n public class Range {\n+    private final String cachePath;\n     private String fileName;\n     private Path filePath;\n     private String className;\n", "next_change": {"commit": "75651ac3832de72b3360e6fd39f6e4c73860aa13", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 635cb9a6ea1..9bea9a86794 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -36,7 +36,7 @@ import java.nio.file.Paths;\n  */\n \n public class Range {\n-    private final String cachePath;\n+    private final Path cachePath;\n     private String fileName;\n     private Path filePath;\n     private String className;\n", "next_change": {"commit": "86b7f4ca17b527b0ef4fb4deaea3b8eddb832364", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 9bea9a86794..635cb9a6ea1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -36,7 +36,7 @@ import java.nio.file.Paths;\n  */\n \n public class Range {\n-    private final Path cachePath;\n+    private final String cachePath;\n     private String fileName;\n     private Path filePath;\n     private String className;\n", "next_change": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 635cb9a6ea1..d8166f2ddfa 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -36,11 +36,15 @@ import java.nio.file.Paths;\n  */\n \n public class Range {\n+\n+    private static final String CLASS_DELIMITER = \".\";\n+\n     private final String cachePath;\n     private String fileName;\n     private Path filePath;\n     private String className;\n     private String methodName;\n+    private String symbolName;\n     private String paramNames;\n     private String returnTypeName;\n     private String fullMethodName;\n", "next_change": {"commit": "b307ee84155fb340719a658a7be2cc9159c49c02", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex d8166f2ddfa..6cdd3ed052a 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -36,22 +33,22 @@ import java.nio.file.Paths;\n  */\n \n public class Range {\n-\n     private static final String CLASS_DELIMITER = \".\";\n-\n-    private final String cachePath;\n-    private String fileName;\n-    private Path filePath;\n+    private FileEntry fileEntry;\n     private String className;\n     private String methodName;\n     private String symbolName;\n-    private String paramNames;\n+    private String paramSignature;\n     private String returnTypeName;\n+    private String methodNameWithParams;\n     private String fullMethodName;\n+    private String fullMethodNameWithParams;\n+    private String fullMethodNameWithParamsAndReturnType;\n     private int lo;\n     private int hi;\n     private int line;\n     private boolean isDeoptTarget;\n+    private int modifiers;\n     /*\n      * This is null for a primary range.\n      */\n", "next_change": {"commit": "3974499ff4ec8343219a484fde479bb8d6fe3182", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 6cdd3ed052a..d2060e4afd6 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -35,24 +35,22 @@ package com.oracle.objectfile.debugentry;\n public class Range {\n     private static final String CLASS_DELIMITER = \".\";\n     private FileEntry fileEntry;\n-    private String className;\n-    private String methodName;\n-    private String symbolName;\n-    private String paramSignature;\n-    private String returnTypeName;\n-    private String methodNameWithParams;\n-    private String fullMethodName;\n-    private String fullMethodNameWithParams;\n-    private String fullMethodNameWithParamsAndReturnType;\n-    private int lo;\n-    private int hi;\n-    private int line;\n-    private boolean isDeoptTarget;\n-    private int modifiers;\n+    private final String className;\n+    private final String methodName;\n+    private final String symbolName;\n+    private final String paramSignature;\n+    private final String returnTypeName;\n+    private final String fullMethodName;\n+    private final String fullMethodNameWithParams;\n+    private final int lo;\n+    private final int hi;\n+    private final int line;\n+    private final boolean isDeoptTarget;\n+    private final int modifiers;\n     /*\n      * This is null for a primary range.\n      */\n-    private Range primary;\n+    private final Range primary;\n \n     /*\n      * Create a primary range.\n", "next_change": {"commit": "b384283b5ac0e455e66648c0d661ce5410bdd863", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex d2060e4afd6..9bea361bef6 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -34,19 +34,14 @@ package com.oracle.objectfile.debugentry;\n \n public class Range {\n     private static final String CLASS_DELIMITER = \".\";\n-    private FileEntry fileEntry;\n-    private final String className;\n-    private final String methodName;\n+    private final FileEntry fileEntry;\n+    private MethodEntry methodEntry;\n     private final String symbolName;\n-    private final String paramSignature;\n-    private final String returnTypeName;\n-    private final String fullMethodName;\n     private final String fullMethodNameWithParams;\n     private final int lo;\n     private final int hi;\n     private final int line;\n     private final boolean isDeoptTarget;\n-    private final int modifiers;\n     /*\n      * This is null for a primary range.\n      */\n", "next_change": {"commit": "f485a3c15f5e29daf480657c0bfa22662f8005ae", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 9bea361bef6..a3d6e1c0db2 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -41,7 +41,6 @@ public class Range {\n     private final int lo;\n     private final int hi;\n     private final int line;\n-    private final boolean isDeoptTarget;\n     /*\n      * This is null for a primary range.\n      */\n", "next_change": {"commit": "dbb2c7607429817e58a1a9af8012e25e861368dc", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex a3d6e1c0db2..af465363bbf 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -35,8 +35,7 @@ package com.oracle.objectfile.debugentry;\n public class Range {\n     private static final String CLASS_DELIMITER = \".\";\n     private final FileEntry fileEntry;\n-    private MethodEntry methodEntry;\n-    private final String symbolName;\n+    private final MethodEntry methodEntry;\n     private final String fullMethodNameWithParams;\n     private final int lo;\n     private final int hi;\n", "next_change": {"commit": "a658b95d63a93b1980e4ac81fd4c034c70b9d9cb", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex af465363bbf..5f7f3fe3bda 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -34,7 +34,6 @@ package com.oracle.objectfile.debugentry;\n \n public class Range {\n     private static final String CLASS_DELIMITER = \".\";\n-    private final FileEntry fileEntry;\n     private final MethodEntry methodEntry;\n     private final String fullMethodNameWithParams;\n     private final int lo;\n", "next_change": {"commit": "6fcf98378231f0e754061b683c3dba387ce8b0e9", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 5f7f3fe3bda..cc407a53acd 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -34,11 +34,14 @@ package com.oracle.objectfile.debugentry;\n \n public class Range {\n     private static final String CLASS_DELIMITER = \".\";\n+    private final Range caller;\n     private final MethodEntry methodEntry;\n     private final String fullMethodNameWithParams;\n     private final int lo;\n     private final int hi;\n     private final int line;\n+    private final boolean isInlined;\n+    private final boolean withChildren;\n     /*\n      * This is null for a primary range.\n      */\n", "next_change": {"commit": "abe98eaaa6dd772b7419b819fa342e810a0939e0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex cc407a53acd..037024f1755 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -36,12 +36,14 @@ public class Range {\n     private static final String CLASS_DELIMITER = \".\";\n     private final Range caller;\n     private final MethodEntry methodEntry;\n+    private final String fullMethodName;\n     private final String fullMethodNameWithParams;\n     private final int lo;\n     private final int hi;\n     private final int line;\n     private final boolean isInlined;\n     private final boolean withChildren;\n+    private boolean withInlinedChildren;\n     /*\n      * This is null for a primary range.\n      */\n", "next_change": {"commit": "268c33256b26217c50339f452adea942fb48818f", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 037024f1755..1951241dda1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -34,32 +36,50 @@ package com.oracle.objectfile.debugentry;\n \n public class Range {\n     private static final String CLASS_DELIMITER = \".\";\n-    private final Range caller;\n+    private Range caller;\n     private final MethodEntry methodEntry;\n     private final String fullMethodName;\n     private final String fullMethodNameWithParams;\n     private final int lo;\n-    private final int hi;\n+    private int hi;\n     private final int line;\n     private final boolean isInlined;\n-    private final boolean withChildren;\n-    private boolean withInlinedChildren;\n+    private final int depth;\n     /*\n      * This is null for a primary range.\n      */\n     private final Range primary;\n \n+    /*\n+     * Support for tree of nested inline callee ranges\n+     */\n+\n+    /**\n+     * The first callee whose range is wholly contained in this range.\n+     */\n+    private Range firstCallee;\n+\n+    /**\n+     * The last callee whose range is wholly contained in this range.\n+     */\n+    private Range lastCallee;\n+\n+    /**\n+     * A link to chain callees of a given parent.\n+     */\n+    private Range nextCallee;\n+\n     /*\n      * Create a primary range.\n      */\n     public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line) {\n-        this(stringTable, methodEntry, lo, hi, line, null, false, false, null);\n+        this(stringTable, methodEntry, lo, hi, line, null, false, null);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary, boolean isInline, boolean withChildren, Range caller) {\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary, boolean isInline, Range caller) {\n         assert methodEntry != null;\n         if (methodEntry.fileEntry != null) {\n             stringTable.uniqueDebugString(methodEntry.fileEntry.getFileName());\n", "next_change": {"commit": "d60cbae9a9120ee8c53c87c4188355ed1d570682", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 1951241dda1..5159d0c6dd4 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -87,7 +87,7 @@ public class Range {\n         }\n         this.methodEntry = methodEntry;\n         this.fullMethodName = isInline ? stringTable.uniqueDebugString(constructClassAndMethodName()) : stringTable.uniqueString(constructClassAndMethodName());\n-        this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n+        this.fullMethodNameWithParams = constructClassAndMethodNameWithParams();\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n", "next_change": {"commit": "aadeac97667d3c369b3358b682902cb515dae2d2", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 5159d0c6dd4..b4c3d2b4380 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -87,7 +87,7 @@ public class Range {\n         }\n         this.methodEntry = methodEntry;\n         this.fullMethodName = isInline ? stringTable.uniqueDebugString(constructClassAndMethodName()) : stringTable.uniqueString(constructClassAndMethodName());\n-        this.fullMethodNameWithParams = constructClassAndMethodNameWithParams();\n+        this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n", "next_change": {"commit": "dfcec107e9c56e9ed5587888711b6cd4bec2e341", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex b4c3d2b4380..c3f7e5ca594 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -87,7 +87,7 @@ public class Range {\n         }\n         this.methodEntry = methodEntry;\n         this.fullMethodName = isInline ? stringTable.uniqueDebugString(constructClassAndMethodName()) : stringTable.uniqueString(constructClassAndMethodName());\n-        this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n+        this.fullMethodNameWithParams = constructClassAndMethodNameWithParams();\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n", "next_change": {"commit": "2070ace4d658b9767e7502bf21d31fe7658d4c1d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex c3f7e5ca594..6bb1eb1d42e 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -73,30 +71,30 @@ public class Range {\n      * Create a primary range.\n      */\n     public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line) {\n-        this(stringTable, methodEntry, lo, hi, line, null, false, null);\n+        this(stringTable, methodEntry, lo, hi, line, null, false, null, false);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary, boolean isInline, Range caller) {\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary, boolean isTopLevel, Range caller, boolean isPrologueEnd) {\n         assert methodEntry != null;\n         if (methodEntry.fileEntry != null) {\n             stringTable.uniqueDebugString(methodEntry.fileEntry.getFileName());\n             stringTable.uniqueDebugString(methodEntry.fileEntry.getPathName());\n         }\n         this.methodEntry = methodEntry;\n-        this.fullMethodName = isInline ? stringTable.uniqueDebugString(constructClassAndMethodName()) : stringTable.uniqueString(constructClassAndMethodName());\n+        this.fullMethodName = isTopLevel ? stringTable.uniqueDebugString(constructClassAndMethodName()) : stringTable.uniqueString(constructClassAndMethodName());\n         this.fullMethodNameWithParams = constructClassAndMethodNameWithParams();\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n-        this.isInlined = isInline;\n         this.primary = primary;\n         this.firstCallee = null;\n         this.lastCallee = null;\n         this.siblingCallee = null;\n         this.caller = caller;\n+        this.isPrologueEnd = isPrologueEnd;\n         if (caller != null) {\n             caller.addCallee(this);\n         }\n", "next_change": {"commit": "93867a358383835002b334613e5e1b394f542a48", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 6bb1eb1d42e..6ba4e9aeacc 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -94,7 +162,6 @@ public class Range {\n         this.lastCallee = null;\n         this.siblingCallee = null;\n         this.caller = caller;\n-        this.isPrologueEnd = isPrologueEnd;\n         if (caller != null) {\n             caller.addCallee(this);\n         }\n", "next_change": {"commit": "9acf1c5d597e38f3e832360ce3f372ad94b16e9e", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/range/Range.java\nsimilarity index 53%\nrename from substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nrename to substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/range/Range.java\nindex 6ba4e9aeacc..0ddc82fe6f9 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/range/Range.java\n", "chunk": "@@ -66,144 +69,75 @@ import java.util.List;\n  * parameter values for separate sub-extents of an inline called method whose full extent is\n  * represented by the parent call range at level N.\n  */\n-public class Range {\n+public abstract class Range {\n     private static final String CLASS_DELIMITER = \".\";\n-    private final MethodEntry methodEntry;\n-    private final String fullMethodName;\n-    private final String fullMethodNameWithParams;\n-    private final int lo;\n-    private int hi;\n-    private final int line;\n-    private final int depth;\n-    /**\n-     * This is null for a primary range. For sub ranges it holds the root of the call tree they\n-     * belong to.\n-     */\n-    private final Range primary;\n-\n-    /**\n-     * The range for the caller or the primary range when this range if for top level method code.\n-     */\n-    private Range caller;\n-    /**\n-     * The first direct callee whose range is wholly contained in this range or null if this is a\n-     * leaf range.\n-     */\n-    private Range firstCallee;\n+    protected final MethodEntry methodEntry;\n+    protected final int lo;\n+    protected int hi;\n+    protected final int line;\n+    protected final int depth;\n \n     /**\n-     * The last direct callee whose range is wholly contained in this range.\n+     * Create a primary range representing the root of the subrange tree for a top level compiled\n+     * method.\n+     * \n+     * @param methodEntry the top level compiled method for this primary range.\n+     * @param lo the lowest address included in the range.\n+     * @param hi the first address above the highest address in the range.\n+     * @param line the line number associated with the range\n+     * @return a new primary range to serve as the root of the subrange tree.\n      */\n-    private Range lastCallee;\n-\n-    /**\n-     * A link to a sibling callee, i.e., a range sharing the same caller with this range.\n-     */\n-    private Range siblingCallee;\n-\n-    /**\n-     * Values for the associated method's local and parameter variables that are available or,\n-     * alternatively, marked as invalid in this range.\n-     */\n-    private DebugLocalValueInfo[] localValueInfos;\n-\n-    /**\n-     * The set of local or parameter variables with which each corresponding local value in field\n-     * localvalueInfos is associated. Local values which are associated with the same local or\n-     * parameter variable will share the same reference in the corresponding array entries. Local\n-     * values with which no local variable can be associated will have a null reference in the\n-     * corresponding array. The latter case can happen when a local value has an invalid slot or\n-     * when a local value that maps to a parameter slot has a different name or type to the\n-     * parameter.\n-     */\n-    private DebugLocalInfo[] localInfos;\n-\n-    public int getLocalValueCount() {\n-        assert !this.isPrimary() : \"primary range does not have local values\";\n-        return localValueInfos.length;\n-    }\n-\n-    public DebugLocalValueInfo getLocalValue(int i) {\n-        assert !this.isPrimary() : \"primary range does not have local values\";\n-        assert i >= 0 && i < localValueInfos.length : \"bad index\";\n-        return localValueInfos[i];\n-    }\n-\n-    public DebugLocalInfo getLocal(int i) {\n-        assert !this.isPrimary() : \"primary range does not have local vars\";\n-        assert i >= 0 && i < localInfos.length : \"bad index\";\n-        return localInfos[i];\n+    public static PrimaryRange createPrimary(MethodEntry methodEntry, int lo, int hi, int line) {\n+        return new PrimaryRange(methodEntry, lo, hi, line);\n     }\n \n-    /*\n-     * Create a primary range.\n+    /**\n+     * Create a subrange representing a segment of the address range for code of a top level or\n+     * inlined compiled method. The result will either be a call or a leaf range.\n+     * \n+     * @param methodEntry the method from which code in the subrange is derived.\n+     * @param lo the lowest address included in the range.\n+     * @param hi the first address above the highest address in the range.\n+     * @param line the line number associated with the range\n+     * @param primary the primary range to which this subrange belongs\n+     * @param caller the range for which this is a subrange, either an inlined call range or the\n+     *            primary range.\n+     * @param isLeaf true if this is a leaf range with no subranges\n+     * @return a new subrange to be linked into the range tree below the primary range.\n      */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line) {\n-        this(stringTable, methodEntry, lo, hi, line, null, false, null);\n+    public static SubRange createSubrange(MethodEntry methodEntry, int lo, int hi, int line, PrimaryRange primary, Range caller, boolean isLeaf) {\n+        assert primary != null;\n+        assert primary.isPrimary();\n+        if (isLeaf) {\n+            return new LeafRange(methodEntry, lo, hi, line, primary, caller);\n+        } else {\n+            return new CallRange(methodEntry, lo, hi, line, primary, caller);\n+        }\n     }\n \n-    /*\n-     * Create a primary or secondary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary, boolean isTopLevel, Range caller) {\n+    protected Range(MethodEntry methodEntry, int lo, int hi, int line, int depth) {\n         assert methodEntry != null;\n-        if (methodEntry.fileEntry != null) {\n-            stringTable.uniqueDebugString(methodEntry.fileEntry.getFileName());\n-            stringTable.uniqueDebugString(methodEntry.fileEntry.getPathName());\n-        }\n         this.methodEntry = methodEntry;\n-        this.fullMethodName = isTopLevel ? stringTable.uniqueDebugString(constructClassAndMethodName()) : stringTable.uniqueString(constructClassAndMethodName());\n-        this.fullMethodNameWithParams = constructClassAndMethodNameWithParams();\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n-        this.primary = primary;\n-        this.firstCallee = null;\n-        this.lastCallee = null;\n-        this.siblingCallee = null;\n-        this.caller = caller;\n-        if (caller != null) {\n-            caller.addCallee(this);\n-        }\n-        if (this.isPrimary()) {\n-            this.depth = -1;\n-        } else {\n-            this.depth = caller.depth + 1;\n-        }\n+        this.depth = depth;\n     }\n \n-    private void addCallee(Range callee) {\n-        assert this.lo <= callee.lo;\n-        assert this.hi >= callee.hi;\n-        assert callee.caller == this;\n-        assert callee.siblingCallee == null;\n-        if (this.firstCallee == null) {\n-            assert this.lastCallee == null;\n-            this.firstCallee = this.lastCallee = callee;\n-        } else {\n-            this.lastCallee.siblingCallee = callee;\n-            this.lastCallee = callee;\n-        }\n-    }\n+    protected abstract void addCallee(SubRange callee);\n \n     public boolean contains(Range other) {\n         return (lo <= other.lo && hi >= other.hi);\n     }\n \n-    public boolean isPrimary() {\n-        return getPrimary() == null;\n-    }\n-\n-    public Range getPrimary() {\n-        return primary;\n-    }\n+    public abstract boolean isPrimary();\n \n     public String getClassName() {\n-        return methodEntry.ownerType.typeName;\n+        return methodEntry.ownerType().getTypeName();\n     }\n \n     public String getMethodName() {\n-        return methodEntry.memberName;\n+        return methodEntry.methodName();\n     }\n \n     public String getSymbolName() {\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex a3d6e1c0db2..af465363bbf 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -49,30 +48,29 @@ public class Range {\n     /*\n      * Create a primary range.\n      */\n-    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n-        this(symbolName, stringTable, methodEntry, fileEntry, lo, hi, line, null);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n+        this(stringTable, methodEntry, fileEntry, lo, hi, line, null);\n     }\n \n     /*\n      * Create a secondary range.\n      */\n-    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n-        this(symbolName, stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n+        this(stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n+    private Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n                     Range primary) {\n-        this.fileEntry = fileEntry; // TODO remove and use fileEntry from MethodEntry\n+        this.fileEntry = fileEntry;\n         if (fileEntry != null) {\n             stringTable.uniqueDebugString(fileEntry.getFileName());\n             stringTable.uniqueDebugString(fileEntry.getPathName());\n         }\n         assert methodEntry != null;\n         this.methodEntry = methodEntry;\n-        this.symbolName = stringTable.uniqueString(symbolName);\n         this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n         this.lo = lo;\n         this.hi = hi;\n", "next_change": {"commit": "a658b95d63a93b1980e4ac81fd4c034c70b9d9cb", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex af465363bbf..5f7f3fe3bda 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -48,28 +47,19 @@ public class Range {\n     /*\n      * Create a primary range.\n      */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n-        this(stringTable, methodEntry, fileEntry, lo, hi, line, null);\n-    }\n-\n-    /*\n-     * Create a secondary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n-        this(stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line) {\n+        this(stringTable, methodEntry, lo, hi, line, null);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n-                    Range primary) {\n-        this.fileEntry = fileEntry;\n-        if (fileEntry != null) {\n-            stringTable.uniqueDebugString(fileEntry.getFileName());\n-            stringTable.uniqueDebugString(fileEntry.getPathName());\n-        }\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n         assert methodEntry != null;\n+        if (methodEntry.fileEntry != null) {\n+            stringTable.uniqueDebugString(methodEntry.fileEntry.getFileName());\n+            stringTable.uniqueDebugString(methodEntry.fileEntry.getPathName());\n+        }\n         this.methodEntry = methodEntry;\n         this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n         this.lo = lo;\n", "next_change": {"commit": "6fcf98378231f0e754061b683c3dba387ce8b0e9", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 5f7f3fe3bda..cc407a53acd 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -65,7 +68,10 @@ public class Range {\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n+        this.isInlined = isInline;\n         this.primary = primary;\n+        this.withChildren = withChildren;\n+        this.caller = caller;\n     }\n \n     public boolean contains(Range other) {\n", "next_change": {"commit": "abe98eaaa6dd772b7419b819fa342e810a0939e0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex cc407a53acd..037024f1755 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -71,6 +74,7 @@ public class Range {\n         this.isInlined = isInline;\n         this.primary = primary;\n         this.withChildren = withChildren;\n+        this.withInlinedChildren = false;\n         this.caller = caller;\n     }\n \n", "next_change": {"commit": "268c33256b26217c50339f452adea942fb48818f", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 037024f1755..1951241dda1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -73,9 +93,32 @@ public class Range {\n         this.line = line;\n         this.isInlined = isInline;\n         this.primary = primary;\n-        this.withChildren = withChildren;\n-        this.withInlinedChildren = false;\n+        this.firstCallee = null;\n+        this.lastCallee = null;\n+        this.nextCallee = null;\n         this.caller = caller;\n+        if (caller != null) {\n+            caller.addCallee(this);\n+        }\n+        if (this.isPrimary()) {\n+            this.depth = -1;\n+        } else {\n+            this.depth = caller.depth + 1;\n+        }\n+    }\n+\n+    private void addCallee(Range callee) {\n+        assert this.lo <= callee.lo;\n+        assert this.hi >= callee.hi;\n+        assert callee.caller == this;\n+        assert callee.nextCallee == null;\n+        if (this.firstCallee == null) {\n+            assert this.lastCallee == null;\n+            this.firstCallee = this.lastCallee = callee;\n+        } else {\n+            this.lastCallee.nextCallee = callee;\n+            this.lastCallee = callee;\n+        }\n     }\n \n     public boolean contains(Range other) {\n", "next_change": {"commit": "6ae5665ec0f5f89ff4a7804dbeec25c85d0982ea", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 1951241dda1..43c64a540e9 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -111,12 +111,12 @@ public class Range {\n         assert this.lo <= callee.lo;\n         assert this.hi >= callee.hi;\n         assert callee.caller == this;\n-        assert callee.nextCallee == null;\n+        assert callee.siblingCallee == null;\n         if (this.firstCallee == null) {\n             assert this.lastCallee == null;\n             this.firstCallee = this.lastCallee = callee;\n         } else {\n-            this.lastCallee.nextCallee = callee;\n+            this.lastCallee.siblingCallee = callee;\n             this.lastCallee = callee;\n         }\n     }\n", "next_change": {"commit": "9acf1c5d597e38f3e832360ce3f372ad94b16e9e", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\ndeleted file mode 100644\nindex 43c64a540e9..00000000000\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ /dev/null\n", "chunk": "@@ -1,339 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.objectfile.debugentry;\n-\n-import org.graalvm.compiler.debug.DebugContext;\n-\n-/**\n- * Details of a specific address range in a compiled method either a primary range identifying a\n- * whole method or a sub-range identifying a sequence of instructions that belong to an inlined\n- * method. Each sub-range is linked with its caller and its callees, forming a call tree.\n- */\n-public class Range {\n-    private static final String CLASS_DELIMITER = \".\";\n-    private Range caller;\n-    private final MethodEntry methodEntry;\n-    private final String fullMethodName;\n-    private final String fullMethodNameWithParams;\n-    private final int lo;\n-    private int hi;\n-    private final int line;\n-    private final boolean isInlined;\n-    private final int depth;\n-    /**\n-     * This is null for a primary range. For sub ranges it holds the root of the call tree they\n-     * belong to.\n-     */\n-    private final Range primary;\n-\n-    /*\n-     * Support for tree of nested inline callee ranges\n-     */\n-\n-    /**\n-     * The first direct callee whose range is wholly contained in this range.\n-     */\n-    private Range firstCallee;\n-\n-    /**\n-     * The last direct callee whose range is wholly contained in this range.\n-     */\n-    private Range lastCallee;\n-\n-    /**\n-     * A link to a sibling callee, i.e., a range sharing the same caller with this range.\n-     */\n-    private Range siblingCallee;\n-\n-    /*\n-     * Create a primary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line) {\n-        this(stringTable, methodEntry, lo, hi, line, null, false, null);\n-    }\n-\n-    /*\n-     * Create a primary or secondary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary, boolean isInline, Range caller) {\n-        assert methodEntry != null;\n-        if (methodEntry.fileEntry != null) {\n-            stringTable.uniqueDebugString(methodEntry.fileEntry.getFileName());\n-            stringTable.uniqueDebugString(methodEntry.fileEntry.getPathName());\n-        }\n-        this.methodEntry = methodEntry;\n-        this.fullMethodName = isInline ? stringTable.uniqueDebugString(constructClassAndMethodName()) : stringTable.uniqueString(constructClassAndMethodName());\n-        this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n-        this.lo = lo;\n-        this.hi = hi;\n-        this.line = line;\n-        this.isInlined = isInline;\n-        this.primary = primary;\n-        this.firstCallee = null;\n-        this.lastCallee = null;\n-        this.siblingCallee = null;\n-        this.caller = caller;\n-        if (caller != null) {\n-            caller.addCallee(this);\n-        }\n-        if (this.isPrimary()) {\n-            this.depth = -1;\n-        } else {\n-            this.depth = caller.depth + 1;\n-        }\n-    }\n-\n-    private void addCallee(Range callee) {\n-        assert this.lo <= callee.lo;\n-        assert this.hi >= callee.hi;\n-        assert callee.caller == this;\n-        assert callee.siblingCallee == null;\n-        if (this.firstCallee == null) {\n-            assert this.lastCallee == null;\n-            this.firstCallee = this.lastCallee = callee;\n-        } else {\n-            this.lastCallee.siblingCallee = callee;\n-            this.lastCallee = callee;\n-        }\n-    }\n-\n-    public boolean contains(Range other) {\n-        return (lo <= other.lo && hi >= other.hi);\n-    }\n-\n-    public boolean isPrimary() {\n-        return getPrimary() == null;\n-    }\n-\n-    public Range getPrimary() {\n-        return primary;\n-    }\n-\n-    public String getClassName() {\n-        return methodEntry.ownerType.typeName;\n-    }\n-\n-    public String getMethodName() {\n-        return methodEntry.memberName;\n-    }\n-\n-    public String getSymbolName() {\n-        return methodEntry.getSymbolName();\n-    }\n-\n-    public int getHi() {\n-        return hi;\n-    }\n-\n-    public int getLo() {\n-        return lo;\n-    }\n-\n-    public int getLine() {\n-        return line;\n-    }\n-\n-    public String getFullMethodName() {\n-        return fullMethodName;\n-    }\n-\n-    public String getFullMethodNameWithParams() {\n-        return fullMethodNameWithParams;\n-    }\n-\n-    public boolean isDeoptTarget() {\n-        return methodEntry.isDeopt();\n-    }\n-\n-    private String getExtendedMethodName(boolean includeClass, boolean includeParams, boolean includeReturnType) {\n-        StringBuilder builder = new StringBuilder();\n-        if (includeReturnType && methodEntry.valueType.typeName.length() > 0) {\n-            builder.append(methodEntry.valueType.typeName);\n-            builder.append(' ');\n-        }\n-        if (includeClass && getClassName() != null) {\n-            builder.append(getClassName());\n-            builder.append(CLASS_DELIMITER);\n-        }\n-        builder.append(getMethodName());\n-        if (includeParams) {\n-            builder.append('(');\n-            builder.append(String.join(\", \", methodEntry.paramNames));\n-            builder.append(')');\n-        }\n-        if (includeReturnType) {\n-            builder.append(\" \");\n-            builder.append(methodEntry.valueType.typeName);\n-        }\n-        return builder.toString();\n-    }\n-\n-    private String constructClassAndMethodName() {\n-        return getExtendedMethodName(true, false, false);\n-    }\n-\n-    private String constructClassAndMethodNameWithParams() {\n-        return getExtendedMethodName(true, true, false);\n-    }\n-\n-    public FileEntry getFileEntry() {\n-        return methodEntry.fileEntry;\n-    }\n-\n-    public int getModifiers() {\n-        return methodEntry.modifiers;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"Range(lo=0x%05x hi=0x%05x %s %s:%d)\", lo, hi, constructClassAndMethodNameWithParams(), methodEntry.getFullFileName(), line);\n-    }\n-\n-    public String getFileName() {\n-        return methodEntry.getFileName();\n-    }\n-\n-    public MethodEntry getMethodEntry() {\n-        return methodEntry;\n-    }\n-\n-    public boolean isInlined() {\n-        return isInlined;\n-    }\n-\n-    public Range getCaller() {\n-        return caller;\n-    }\n-\n-    public Range getFirstCallee() {\n-        return firstCallee;\n-    }\n-\n-    public Range getSiblingCallee() {\n-        return siblingCallee;\n-    }\n-\n-    public Range getLastCallee() {\n-        return lastCallee;\n-    }\n-\n-    public boolean isLeaf() {\n-        return firstCallee == null;\n-    }\n-\n-    public int getDepth() {\n-        return depth;\n-    }\n-\n-    /**\n-     * Minimizes the nodes in the tree that track the inline call hierarchy and associated code\n-     * ranges. The initial range tree models the call hierarchy as presented in the original debug\n-     * line info. It consists of a root node each of whose children is a sequence of linear call\n-     * chains, either a single leaf node for some given file and line or a series of inline calls to\n-     * such a leaf node. In this initial tree all node ranges in a given chain have the same lo and\n-     * hi address and chains are properly ordered by range The merge algorithm works across siblings\n-     * at successive depths starting at depth 1. Once all possible nodes at a given depth have been\n-     * merged their children can then be merged. A successor node may only be merged into its\n-     * predecessor if the nodes have contiguous ranges and idenitfy the same method, line and file.\n-     * The range and children of the merged node are, respectively, the union of the input ranges\n-     * and children. This preserves the invariant that child ranges lie within their parent range.\n-     *\n-     * @param debugContext\n-     */\n-    public void mergeSubranges(DebugContext debugContext) {\n-        Range next = getFirstCallee();\n-        if (next == null) {\n-            return;\n-        }\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Merge subranges [0x%x, 0x%x] %s\", lo, hi, getFullMethodNameWithParams());\n-        /* merge siblings together if possible, reparenting children to the merged node */\n-        while (next != null) {\n-            next = next.maybeMergeSibling(debugContext);\n-        }\n-        /* now recurse down to merge children of whatever nodes remain */\n-        next = getFirstCallee();\n-        /* now this level is merged recursively merge children of each child node. */\n-        while (next != null) {\n-            next.mergeSubranges(debugContext);\n-            next = next.getSiblingCallee();\n-        }\n-    }\n-\n-    /**\n-     * Removes and merges the next sibling returning the current node or it skips past the current\n-     * node as is and returns the next sibling or null if no sibling exists.\n-     */\n-    private Range maybeMergeSibling(DebugContext debugContext) {\n-        Range sibling = getSiblingCallee();\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Merge subrange (maybe) [0x%x, 0x%x] %s\", lo, hi, getFullMethodNameWithParams());\n-        if (sibling == null) {\n-            /* all child nodes at this level have been merged */\n-            return null;\n-        }\n-        if (hi < sibling.lo) {\n-            /* cannot merge non-contiguous ranges, move on. */\n-            return sibling;\n-        }\n-        if (getMethodEntry() != sibling.getMethodEntry()) {\n-            /* cannot merge distinct callers, move on. */\n-            return sibling;\n-        }\n-        if (getLine() != sibling.getLine()) {\n-            /* cannot merge callers with different line numbers, move on. */\n-            return sibling;\n-        }\n-        /* splice out the sibling from the chain and update this one to include it. */\n-        unlink(debugContext, sibling);\n-        /* relocate the siblings children to this node. */\n-        reparentChildren(debugContext, sibling);\n-        /* return the merged node so we can maybe merge it again. */\n-        return this;\n-    }\n-\n-    private void unlink(DebugContext debugContext, Range sibling) {\n-        assert hi == sibling.lo : String.format(\"gap in range [0x%x,0x%x] %s [0x%x,0x%x] %s\",\n-                        lo, hi, getFullMethodNameWithParams(), sibling.getLo(), sibling.getHi(), sibling.getFullMethodNameWithParams());\n-        assert this.isInlined == sibling.isInlined : String.format(\"change in inlined [0x%x,0x%x] %s %s [0x%x,0x%x] %s %s\",\n-                        lo, hi, getFullMethodNameWithParams(), Boolean.valueOf(this.isInlined), sibling.lo, sibling.hi, sibling.getFullMethodNameWithParams(), Boolean.valueOf(sibling.isInlined));\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Combining [0x%x, 0x%x] %s into [0x%x, 0x%x] %s\", sibling.lo, sibling.hi, sibling.getFullMethodName(), lo, hi, getFullMethodNameWithParams());\n-        this.hi = sibling.hi;\n-        this.siblingCallee = sibling.siblingCallee;\n-    }\n-\n-    private void reparentChildren(DebugContext debugContext, Range sibling) {\n-        Range siblingNext = sibling.getFirstCallee();\n-        while (siblingNext != null) {\n-            debugContext.log(DebugContext.INFO_LEVEL, \"Reparenting [0x%x, 0x%x] %s to [0x%x, 0x%x] %s\", siblingNext.lo, siblingNext.hi, siblingNext.getFullMethodName(), lo, hi,\n-                            getFullMethodNameWithParams());\n-            siblingNext.caller = this;\n-            Range newSiblingNext = siblingNext.siblingCallee;\n-            siblingNext.siblingCallee = null;\n-            addCallee(siblingNext);\n-            siblingNext = newSiblingNext;\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 9bea361bef6..a3d6e1c0db2 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -50,23 +49,22 @@ public class Range {\n     /*\n      * Create a primary range.\n      */\n-    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n-                 boolean isDeoptTarget) {\n-        this(symbolName, stringTable, methodEntry, fileEntry, lo, hi, line, isDeoptTarget, null);\n+    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n+        this(symbolName, stringTable, methodEntry, fileEntry, lo, hi, line, null);\n     }\n \n     /*\n      * Create a secondary range.\n      */\n     public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n-        this(symbolName, stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, false, primary);\n+        this(symbolName, stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n     private Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n-                    boolean isDeoptTarget, Range primary) {\n+                    Range primary) {\n         this.fileEntry = fileEntry; // TODO remove and use fileEntry from MethodEntry\n         if (fileEntry != null) {\n             stringTable.uniqueDebugString(fileEntry.getFileName());\n", "next_change": {"commit": "70792d9ae44148d55d1611662964c48b7f132e0a", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex a3d6e1c0db2..dd82d22565b 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -65,7 +65,7 @@ public class Range {\n      */\n     private Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n                     Range primary) {\n-        this.fileEntry = fileEntry; // TODO remove and use fileEntry from MethodEntry\n+        this.fileEntry = fileEntry;\n         if (fileEntry != null) {\n             stringTable.uniqueDebugString(fileEntry.getFileName());\n             stringTable.uniqueDebugString(fileEntry.getPathName());\n", "next_change": {"commit": "dbb2c7607429817e58a1a9af8012e25e861368dc", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex dd82d22565b..af465363bbf 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -49,21 +48,21 @@ public class Range {\n     /*\n      * Create a primary range.\n      */\n-    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n-        this(symbolName, stringTable, methodEntry, fileEntry, lo, hi, line, null);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n+        this(stringTable, methodEntry, fileEntry, lo, hi, line, null);\n     }\n \n     /*\n      * Create a secondary range.\n      */\n-    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n-        this(symbolName, stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n+        this(stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n+    private Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n                     Range primary) {\n         this.fileEntry = fileEntry;\n         if (fileEntry != null) {\n", "next_change": {"commit": "a658b95d63a93b1980e4ac81fd4c034c70b9d9cb", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex af465363bbf..5f7f3fe3bda 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -48,28 +47,19 @@ public class Range {\n     /*\n      * Create a primary range.\n      */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n-        this(stringTable, methodEntry, fileEntry, lo, hi, line, null);\n-    }\n-\n-    /*\n-     * Create a secondary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n-        this(stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line) {\n+        this(stringTable, methodEntry, lo, hi, line, null);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n-                    Range primary) {\n-        this.fileEntry = fileEntry;\n-        if (fileEntry != null) {\n-            stringTable.uniqueDebugString(fileEntry.getFileName());\n-            stringTable.uniqueDebugString(fileEntry.getPathName());\n-        }\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n         assert methodEntry != null;\n+        if (methodEntry.fileEntry != null) {\n+            stringTable.uniqueDebugString(methodEntry.fileEntry.getFileName());\n+            stringTable.uniqueDebugString(methodEntry.fileEntry.getPathName());\n+        }\n         this.methodEntry = methodEntry;\n         this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n         this.lo = lo;\n", "next_change": {"commit": "6fcf98378231f0e754061b683c3dba387ce8b0e9", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 5f7f3fe3bda..cc407a53acd 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -65,7 +68,10 @@ public class Range {\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n+        this.isInlined = isInline;\n         this.primary = primary;\n+        this.withChildren = withChildren;\n+        this.caller = caller;\n     }\n \n     public boolean contains(Range other) {\n", "next_change": {"commit": "abe98eaaa6dd772b7419b819fa342e810a0939e0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex cc407a53acd..037024f1755 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -71,6 +74,7 @@ public class Range {\n         this.isInlined = isInline;\n         this.primary = primary;\n         this.withChildren = withChildren;\n+        this.withInlinedChildren = false;\n         this.caller = caller;\n     }\n \n", "next_change": {"commit": "268c33256b26217c50339f452adea942fb48818f", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 037024f1755..1951241dda1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -73,9 +93,32 @@ public class Range {\n         this.line = line;\n         this.isInlined = isInline;\n         this.primary = primary;\n-        this.withChildren = withChildren;\n-        this.withInlinedChildren = false;\n+        this.firstCallee = null;\n+        this.lastCallee = null;\n+        this.nextCallee = null;\n         this.caller = caller;\n+        if (caller != null) {\n+            caller.addCallee(this);\n+        }\n+        if (this.isPrimary()) {\n+            this.depth = -1;\n+        } else {\n+            this.depth = caller.depth + 1;\n+        }\n+    }\n+\n+    private void addCallee(Range callee) {\n+        assert this.lo <= callee.lo;\n+        assert this.hi >= callee.hi;\n+        assert callee.caller == this;\n+        assert callee.nextCallee == null;\n+        if (this.firstCallee == null) {\n+            assert this.lastCallee == null;\n+            this.firstCallee = this.lastCallee = callee;\n+        } else {\n+            this.lastCallee.nextCallee = callee;\n+            this.lastCallee = callee;\n+        }\n     }\n \n     public boolean contains(Range other) {\n", "next_change": {"commit": "6ae5665ec0f5f89ff4a7804dbeec25c85d0982ea", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 1951241dda1..43c64a540e9 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -111,12 +111,12 @@ public class Range {\n         assert this.lo <= callee.lo;\n         assert this.hi >= callee.hi;\n         assert callee.caller == this;\n-        assert callee.nextCallee == null;\n+        assert callee.siblingCallee == null;\n         if (this.firstCallee == null) {\n             assert this.lastCallee == null;\n             this.firstCallee = this.lastCallee = callee;\n         } else {\n-            this.lastCallee.nextCallee = callee;\n+            this.lastCallee.siblingCallee = callee;\n             this.lastCallee = callee;\n         }\n     }\n", "next_change": {"commit": "9acf1c5d597e38f3e832360ce3f372ad94b16e9e", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\ndeleted file mode 100644\nindex 43c64a540e9..00000000000\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ /dev/null\n", "chunk": "@@ -1,339 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.objectfile.debugentry;\n-\n-import org.graalvm.compiler.debug.DebugContext;\n-\n-/**\n- * Details of a specific address range in a compiled method either a primary range identifying a\n- * whole method or a sub-range identifying a sequence of instructions that belong to an inlined\n- * method. Each sub-range is linked with its caller and its callees, forming a call tree.\n- */\n-public class Range {\n-    private static final String CLASS_DELIMITER = \".\";\n-    private Range caller;\n-    private final MethodEntry methodEntry;\n-    private final String fullMethodName;\n-    private final String fullMethodNameWithParams;\n-    private final int lo;\n-    private int hi;\n-    private final int line;\n-    private final boolean isInlined;\n-    private final int depth;\n-    /**\n-     * This is null for a primary range. For sub ranges it holds the root of the call tree they\n-     * belong to.\n-     */\n-    private final Range primary;\n-\n-    /*\n-     * Support for tree of nested inline callee ranges\n-     */\n-\n-    /**\n-     * The first direct callee whose range is wholly contained in this range.\n-     */\n-    private Range firstCallee;\n-\n-    /**\n-     * The last direct callee whose range is wholly contained in this range.\n-     */\n-    private Range lastCallee;\n-\n-    /**\n-     * A link to a sibling callee, i.e., a range sharing the same caller with this range.\n-     */\n-    private Range siblingCallee;\n-\n-    /*\n-     * Create a primary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line) {\n-        this(stringTable, methodEntry, lo, hi, line, null, false, null);\n-    }\n-\n-    /*\n-     * Create a primary or secondary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary, boolean isInline, Range caller) {\n-        assert methodEntry != null;\n-        if (methodEntry.fileEntry != null) {\n-            stringTable.uniqueDebugString(methodEntry.fileEntry.getFileName());\n-            stringTable.uniqueDebugString(methodEntry.fileEntry.getPathName());\n-        }\n-        this.methodEntry = methodEntry;\n-        this.fullMethodName = isInline ? stringTable.uniqueDebugString(constructClassAndMethodName()) : stringTable.uniqueString(constructClassAndMethodName());\n-        this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n-        this.lo = lo;\n-        this.hi = hi;\n-        this.line = line;\n-        this.isInlined = isInline;\n-        this.primary = primary;\n-        this.firstCallee = null;\n-        this.lastCallee = null;\n-        this.siblingCallee = null;\n-        this.caller = caller;\n-        if (caller != null) {\n-            caller.addCallee(this);\n-        }\n-        if (this.isPrimary()) {\n-            this.depth = -1;\n-        } else {\n-            this.depth = caller.depth + 1;\n-        }\n-    }\n-\n-    private void addCallee(Range callee) {\n-        assert this.lo <= callee.lo;\n-        assert this.hi >= callee.hi;\n-        assert callee.caller == this;\n-        assert callee.siblingCallee == null;\n-        if (this.firstCallee == null) {\n-            assert this.lastCallee == null;\n-            this.firstCallee = this.lastCallee = callee;\n-        } else {\n-            this.lastCallee.siblingCallee = callee;\n-            this.lastCallee = callee;\n-        }\n-    }\n-\n-    public boolean contains(Range other) {\n-        return (lo <= other.lo && hi >= other.hi);\n-    }\n-\n-    public boolean isPrimary() {\n-        return getPrimary() == null;\n-    }\n-\n-    public Range getPrimary() {\n-        return primary;\n-    }\n-\n-    public String getClassName() {\n-        return methodEntry.ownerType.typeName;\n-    }\n-\n-    public String getMethodName() {\n-        return methodEntry.memberName;\n-    }\n-\n-    public String getSymbolName() {\n-        return methodEntry.getSymbolName();\n-    }\n-\n-    public int getHi() {\n-        return hi;\n-    }\n-\n-    public int getLo() {\n-        return lo;\n-    }\n-\n-    public int getLine() {\n-        return line;\n-    }\n-\n-    public String getFullMethodName() {\n-        return fullMethodName;\n-    }\n-\n-    public String getFullMethodNameWithParams() {\n-        return fullMethodNameWithParams;\n-    }\n-\n-    public boolean isDeoptTarget() {\n-        return methodEntry.isDeopt();\n-    }\n-\n-    private String getExtendedMethodName(boolean includeClass, boolean includeParams, boolean includeReturnType) {\n-        StringBuilder builder = new StringBuilder();\n-        if (includeReturnType && methodEntry.valueType.typeName.length() > 0) {\n-            builder.append(methodEntry.valueType.typeName);\n-            builder.append(' ');\n-        }\n-        if (includeClass && getClassName() != null) {\n-            builder.append(getClassName());\n-            builder.append(CLASS_DELIMITER);\n-        }\n-        builder.append(getMethodName());\n-        if (includeParams) {\n-            builder.append('(');\n-            builder.append(String.join(\", \", methodEntry.paramNames));\n-            builder.append(')');\n-        }\n-        if (includeReturnType) {\n-            builder.append(\" \");\n-            builder.append(methodEntry.valueType.typeName);\n-        }\n-        return builder.toString();\n-    }\n-\n-    private String constructClassAndMethodName() {\n-        return getExtendedMethodName(true, false, false);\n-    }\n-\n-    private String constructClassAndMethodNameWithParams() {\n-        return getExtendedMethodName(true, true, false);\n-    }\n-\n-    public FileEntry getFileEntry() {\n-        return methodEntry.fileEntry;\n-    }\n-\n-    public int getModifiers() {\n-        return methodEntry.modifiers;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"Range(lo=0x%05x hi=0x%05x %s %s:%d)\", lo, hi, constructClassAndMethodNameWithParams(), methodEntry.getFullFileName(), line);\n-    }\n-\n-    public String getFileName() {\n-        return methodEntry.getFileName();\n-    }\n-\n-    public MethodEntry getMethodEntry() {\n-        return methodEntry;\n-    }\n-\n-    public boolean isInlined() {\n-        return isInlined;\n-    }\n-\n-    public Range getCaller() {\n-        return caller;\n-    }\n-\n-    public Range getFirstCallee() {\n-        return firstCallee;\n-    }\n-\n-    public Range getSiblingCallee() {\n-        return siblingCallee;\n-    }\n-\n-    public Range getLastCallee() {\n-        return lastCallee;\n-    }\n-\n-    public boolean isLeaf() {\n-        return firstCallee == null;\n-    }\n-\n-    public int getDepth() {\n-        return depth;\n-    }\n-\n-    /**\n-     * Minimizes the nodes in the tree that track the inline call hierarchy and associated code\n-     * ranges. The initial range tree models the call hierarchy as presented in the original debug\n-     * line info. It consists of a root node each of whose children is a sequence of linear call\n-     * chains, either a single leaf node for some given file and line or a series of inline calls to\n-     * such a leaf node. In this initial tree all node ranges in a given chain have the same lo and\n-     * hi address and chains are properly ordered by range The merge algorithm works across siblings\n-     * at successive depths starting at depth 1. Once all possible nodes at a given depth have been\n-     * merged their children can then be merged. A successor node may only be merged into its\n-     * predecessor if the nodes have contiguous ranges and idenitfy the same method, line and file.\n-     * The range and children of the merged node are, respectively, the union of the input ranges\n-     * and children. This preserves the invariant that child ranges lie within their parent range.\n-     *\n-     * @param debugContext\n-     */\n-    public void mergeSubranges(DebugContext debugContext) {\n-        Range next = getFirstCallee();\n-        if (next == null) {\n-            return;\n-        }\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Merge subranges [0x%x, 0x%x] %s\", lo, hi, getFullMethodNameWithParams());\n-        /* merge siblings together if possible, reparenting children to the merged node */\n-        while (next != null) {\n-            next = next.maybeMergeSibling(debugContext);\n-        }\n-        /* now recurse down to merge children of whatever nodes remain */\n-        next = getFirstCallee();\n-        /* now this level is merged recursively merge children of each child node. */\n-        while (next != null) {\n-            next.mergeSubranges(debugContext);\n-            next = next.getSiblingCallee();\n-        }\n-    }\n-\n-    /**\n-     * Removes and merges the next sibling returning the current node or it skips past the current\n-     * node as is and returns the next sibling or null if no sibling exists.\n-     */\n-    private Range maybeMergeSibling(DebugContext debugContext) {\n-        Range sibling = getSiblingCallee();\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Merge subrange (maybe) [0x%x, 0x%x] %s\", lo, hi, getFullMethodNameWithParams());\n-        if (sibling == null) {\n-            /* all child nodes at this level have been merged */\n-            return null;\n-        }\n-        if (hi < sibling.lo) {\n-            /* cannot merge non-contiguous ranges, move on. */\n-            return sibling;\n-        }\n-        if (getMethodEntry() != sibling.getMethodEntry()) {\n-            /* cannot merge distinct callers, move on. */\n-            return sibling;\n-        }\n-        if (getLine() != sibling.getLine()) {\n-            /* cannot merge callers with different line numbers, move on. */\n-            return sibling;\n-        }\n-        /* splice out the sibling from the chain and update this one to include it. */\n-        unlink(debugContext, sibling);\n-        /* relocate the siblings children to this node. */\n-        reparentChildren(debugContext, sibling);\n-        /* return the merged node so we can maybe merge it again. */\n-        return this;\n-    }\n-\n-    private void unlink(DebugContext debugContext, Range sibling) {\n-        assert hi == sibling.lo : String.format(\"gap in range [0x%x,0x%x] %s [0x%x,0x%x] %s\",\n-                        lo, hi, getFullMethodNameWithParams(), sibling.getLo(), sibling.getHi(), sibling.getFullMethodNameWithParams());\n-        assert this.isInlined == sibling.isInlined : String.format(\"change in inlined [0x%x,0x%x] %s %s [0x%x,0x%x] %s %s\",\n-                        lo, hi, getFullMethodNameWithParams(), Boolean.valueOf(this.isInlined), sibling.lo, sibling.hi, sibling.getFullMethodNameWithParams(), Boolean.valueOf(sibling.isInlined));\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Combining [0x%x, 0x%x] %s into [0x%x, 0x%x] %s\", sibling.lo, sibling.hi, sibling.getFullMethodName(), lo, hi, getFullMethodNameWithParams());\n-        this.hi = sibling.hi;\n-        this.siblingCallee = sibling.siblingCallee;\n-    }\n-\n-    private void reparentChildren(DebugContext debugContext, Range sibling) {\n-        Range siblingNext = sibling.getFirstCallee();\n-        while (siblingNext != null) {\n-            debugContext.log(DebugContext.INFO_LEVEL, \"Reparenting [0x%x, 0x%x] %s to [0x%x, 0x%x] %s\", siblingNext.lo, siblingNext.hi, siblingNext.getFullMethodName(), lo, hi,\n-                            getFullMethodNameWithParams());\n-            siblingNext.caller = this;\n-            Range newSiblingNext = siblingNext.siblingCallee;\n-            siblingNext.siblingCallee = null;\n-            addCallee(siblingNext);\n-            siblingNext = newSiblingNext;\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex dd82d22565b..af465363bbf 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -72,7 +71,6 @@ public class Range {\n         }\n         assert methodEntry != null;\n         this.methodEntry = methodEntry;\n-        this.symbolName = stringTable.uniqueString(symbolName);\n         this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n         this.lo = lo;\n         this.hi = hi;\n", "next_change": {"commit": "a658b95d63a93b1980e4ac81fd4c034c70b9d9cb", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex af465363bbf..5f7f3fe3bda 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -48,28 +47,19 @@ public class Range {\n     /*\n      * Create a primary range.\n      */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n-        this(stringTable, methodEntry, fileEntry, lo, hi, line, null);\n-    }\n-\n-    /*\n-     * Create a secondary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n-        this(stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line) {\n+        this(stringTable, methodEntry, lo, hi, line, null);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n-                    Range primary) {\n-        this.fileEntry = fileEntry;\n-        if (fileEntry != null) {\n-            stringTable.uniqueDebugString(fileEntry.getFileName());\n-            stringTable.uniqueDebugString(fileEntry.getPathName());\n-        }\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n         assert methodEntry != null;\n+        if (methodEntry.fileEntry != null) {\n+            stringTable.uniqueDebugString(methodEntry.fileEntry.getFileName());\n+            stringTable.uniqueDebugString(methodEntry.fileEntry.getPathName());\n+        }\n         this.methodEntry = methodEntry;\n         this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n         this.lo = lo;\n", "next_change": {"commit": "6fcf98378231f0e754061b683c3dba387ce8b0e9", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 5f7f3fe3bda..cc407a53acd 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -65,7 +68,10 @@ public class Range {\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n+        this.isInlined = isInline;\n         this.primary = primary;\n+        this.withChildren = withChildren;\n+        this.caller = caller;\n     }\n \n     public boolean contains(Range other) {\n", "next_change": {"commit": "abe98eaaa6dd772b7419b819fa342e810a0939e0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex cc407a53acd..037024f1755 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -71,6 +74,7 @@ public class Range {\n         this.isInlined = isInline;\n         this.primary = primary;\n         this.withChildren = withChildren;\n+        this.withInlinedChildren = false;\n         this.caller = caller;\n     }\n \n", "next_change": {"commit": "268c33256b26217c50339f452adea942fb48818f", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 037024f1755..1951241dda1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -73,9 +93,32 @@ public class Range {\n         this.line = line;\n         this.isInlined = isInline;\n         this.primary = primary;\n-        this.withChildren = withChildren;\n-        this.withInlinedChildren = false;\n+        this.firstCallee = null;\n+        this.lastCallee = null;\n+        this.nextCallee = null;\n         this.caller = caller;\n+        if (caller != null) {\n+            caller.addCallee(this);\n+        }\n+        if (this.isPrimary()) {\n+            this.depth = -1;\n+        } else {\n+            this.depth = caller.depth + 1;\n+        }\n+    }\n+\n+    private void addCallee(Range callee) {\n+        assert this.lo <= callee.lo;\n+        assert this.hi >= callee.hi;\n+        assert callee.caller == this;\n+        assert callee.nextCallee == null;\n+        if (this.firstCallee == null) {\n+            assert this.lastCallee == null;\n+            this.firstCallee = this.lastCallee = callee;\n+        } else {\n+            this.lastCallee.nextCallee = callee;\n+            this.lastCallee = callee;\n+        }\n     }\n \n     public boolean contains(Range other) {\n", "next_change": {"commit": "6ae5665ec0f5f89ff4a7804dbeec25c85d0982ea", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 1951241dda1..43c64a540e9 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -111,12 +111,12 @@ public class Range {\n         assert this.lo <= callee.lo;\n         assert this.hi >= callee.hi;\n         assert callee.caller == this;\n-        assert callee.nextCallee == null;\n+        assert callee.siblingCallee == null;\n         if (this.firstCallee == null) {\n             assert this.lastCallee == null;\n             this.firstCallee = this.lastCallee = callee;\n         } else {\n-            this.lastCallee.nextCallee = callee;\n+            this.lastCallee.siblingCallee = callee;\n             this.lastCallee = callee;\n         }\n     }\n", "next_change": {"commit": "9acf1c5d597e38f3e832360ce3f372ad94b16e9e", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\ndeleted file mode 100644\nindex 43c64a540e9..00000000000\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ /dev/null\n", "chunk": "@@ -1,339 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.objectfile.debugentry;\n-\n-import org.graalvm.compiler.debug.DebugContext;\n-\n-/**\n- * Details of a specific address range in a compiled method either a primary range identifying a\n- * whole method or a sub-range identifying a sequence of instructions that belong to an inlined\n- * method. Each sub-range is linked with its caller and its callees, forming a call tree.\n- */\n-public class Range {\n-    private static final String CLASS_DELIMITER = \".\";\n-    private Range caller;\n-    private final MethodEntry methodEntry;\n-    private final String fullMethodName;\n-    private final String fullMethodNameWithParams;\n-    private final int lo;\n-    private int hi;\n-    private final int line;\n-    private final boolean isInlined;\n-    private final int depth;\n-    /**\n-     * This is null for a primary range. For sub ranges it holds the root of the call tree they\n-     * belong to.\n-     */\n-    private final Range primary;\n-\n-    /*\n-     * Support for tree of nested inline callee ranges\n-     */\n-\n-    /**\n-     * The first direct callee whose range is wholly contained in this range.\n-     */\n-    private Range firstCallee;\n-\n-    /**\n-     * The last direct callee whose range is wholly contained in this range.\n-     */\n-    private Range lastCallee;\n-\n-    /**\n-     * A link to a sibling callee, i.e., a range sharing the same caller with this range.\n-     */\n-    private Range siblingCallee;\n-\n-    /*\n-     * Create a primary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line) {\n-        this(stringTable, methodEntry, lo, hi, line, null, false, null);\n-    }\n-\n-    /*\n-     * Create a primary or secondary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary, boolean isInline, Range caller) {\n-        assert methodEntry != null;\n-        if (methodEntry.fileEntry != null) {\n-            stringTable.uniqueDebugString(methodEntry.fileEntry.getFileName());\n-            stringTable.uniqueDebugString(methodEntry.fileEntry.getPathName());\n-        }\n-        this.methodEntry = methodEntry;\n-        this.fullMethodName = isInline ? stringTable.uniqueDebugString(constructClassAndMethodName()) : stringTable.uniqueString(constructClassAndMethodName());\n-        this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n-        this.lo = lo;\n-        this.hi = hi;\n-        this.line = line;\n-        this.isInlined = isInline;\n-        this.primary = primary;\n-        this.firstCallee = null;\n-        this.lastCallee = null;\n-        this.siblingCallee = null;\n-        this.caller = caller;\n-        if (caller != null) {\n-            caller.addCallee(this);\n-        }\n-        if (this.isPrimary()) {\n-            this.depth = -1;\n-        } else {\n-            this.depth = caller.depth + 1;\n-        }\n-    }\n-\n-    private void addCallee(Range callee) {\n-        assert this.lo <= callee.lo;\n-        assert this.hi >= callee.hi;\n-        assert callee.caller == this;\n-        assert callee.siblingCallee == null;\n-        if (this.firstCallee == null) {\n-            assert this.lastCallee == null;\n-            this.firstCallee = this.lastCallee = callee;\n-        } else {\n-            this.lastCallee.siblingCallee = callee;\n-            this.lastCallee = callee;\n-        }\n-    }\n-\n-    public boolean contains(Range other) {\n-        return (lo <= other.lo && hi >= other.hi);\n-    }\n-\n-    public boolean isPrimary() {\n-        return getPrimary() == null;\n-    }\n-\n-    public Range getPrimary() {\n-        return primary;\n-    }\n-\n-    public String getClassName() {\n-        return methodEntry.ownerType.typeName;\n-    }\n-\n-    public String getMethodName() {\n-        return methodEntry.memberName;\n-    }\n-\n-    public String getSymbolName() {\n-        return methodEntry.getSymbolName();\n-    }\n-\n-    public int getHi() {\n-        return hi;\n-    }\n-\n-    public int getLo() {\n-        return lo;\n-    }\n-\n-    public int getLine() {\n-        return line;\n-    }\n-\n-    public String getFullMethodName() {\n-        return fullMethodName;\n-    }\n-\n-    public String getFullMethodNameWithParams() {\n-        return fullMethodNameWithParams;\n-    }\n-\n-    public boolean isDeoptTarget() {\n-        return methodEntry.isDeopt();\n-    }\n-\n-    private String getExtendedMethodName(boolean includeClass, boolean includeParams, boolean includeReturnType) {\n-        StringBuilder builder = new StringBuilder();\n-        if (includeReturnType && methodEntry.valueType.typeName.length() > 0) {\n-            builder.append(methodEntry.valueType.typeName);\n-            builder.append(' ');\n-        }\n-        if (includeClass && getClassName() != null) {\n-            builder.append(getClassName());\n-            builder.append(CLASS_DELIMITER);\n-        }\n-        builder.append(getMethodName());\n-        if (includeParams) {\n-            builder.append('(');\n-            builder.append(String.join(\", \", methodEntry.paramNames));\n-            builder.append(')');\n-        }\n-        if (includeReturnType) {\n-            builder.append(\" \");\n-            builder.append(methodEntry.valueType.typeName);\n-        }\n-        return builder.toString();\n-    }\n-\n-    private String constructClassAndMethodName() {\n-        return getExtendedMethodName(true, false, false);\n-    }\n-\n-    private String constructClassAndMethodNameWithParams() {\n-        return getExtendedMethodName(true, true, false);\n-    }\n-\n-    public FileEntry getFileEntry() {\n-        return methodEntry.fileEntry;\n-    }\n-\n-    public int getModifiers() {\n-        return methodEntry.modifiers;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"Range(lo=0x%05x hi=0x%05x %s %s:%d)\", lo, hi, constructClassAndMethodNameWithParams(), methodEntry.getFullFileName(), line);\n-    }\n-\n-    public String getFileName() {\n-        return methodEntry.getFileName();\n-    }\n-\n-    public MethodEntry getMethodEntry() {\n-        return methodEntry;\n-    }\n-\n-    public boolean isInlined() {\n-        return isInlined;\n-    }\n-\n-    public Range getCaller() {\n-        return caller;\n-    }\n-\n-    public Range getFirstCallee() {\n-        return firstCallee;\n-    }\n-\n-    public Range getSiblingCallee() {\n-        return siblingCallee;\n-    }\n-\n-    public Range getLastCallee() {\n-        return lastCallee;\n-    }\n-\n-    public boolean isLeaf() {\n-        return firstCallee == null;\n-    }\n-\n-    public int getDepth() {\n-        return depth;\n-    }\n-\n-    /**\n-     * Minimizes the nodes in the tree that track the inline call hierarchy and associated code\n-     * ranges. The initial range tree models the call hierarchy as presented in the original debug\n-     * line info. It consists of a root node each of whose children is a sequence of linear call\n-     * chains, either a single leaf node for some given file and line or a series of inline calls to\n-     * such a leaf node. In this initial tree all node ranges in a given chain have the same lo and\n-     * hi address and chains are properly ordered by range The merge algorithm works across siblings\n-     * at successive depths starting at depth 1. Once all possible nodes at a given depth have been\n-     * merged their children can then be merged. A successor node may only be merged into its\n-     * predecessor if the nodes have contiguous ranges and idenitfy the same method, line and file.\n-     * The range and children of the merged node are, respectively, the union of the input ranges\n-     * and children. This preserves the invariant that child ranges lie within their parent range.\n-     *\n-     * @param debugContext\n-     */\n-    public void mergeSubranges(DebugContext debugContext) {\n-        Range next = getFirstCallee();\n-        if (next == null) {\n-            return;\n-        }\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Merge subranges [0x%x, 0x%x] %s\", lo, hi, getFullMethodNameWithParams());\n-        /* merge siblings together if possible, reparenting children to the merged node */\n-        while (next != null) {\n-            next = next.maybeMergeSibling(debugContext);\n-        }\n-        /* now recurse down to merge children of whatever nodes remain */\n-        next = getFirstCallee();\n-        /* now this level is merged recursively merge children of each child node. */\n-        while (next != null) {\n-            next.mergeSubranges(debugContext);\n-            next = next.getSiblingCallee();\n-        }\n-    }\n-\n-    /**\n-     * Removes and merges the next sibling returning the current node or it skips past the current\n-     * node as is and returns the next sibling or null if no sibling exists.\n-     */\n-    private Range maybeMergeSibling(DebugContext debugContext) {\n-        Range sibling = getSiblingCallee();\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Merge subrange (maybe) [0x%x, 0x%x] %s\", lo, hi, getFullMethodNameWithParams());\n-        if (sibling == null) {\n-            /* all child nodes at this level have been merged */\n-            return null;\n-        }\n-        if (hi < sibling.lo) {\n-            /* cannot merge non-contiguous ranges, move on. */\n-            return sibling;\n-        }\n-        if (getMethodEntry() != sibling.getMethodEntry()) {\n-            /* cannot merge distinct callers, move on. */\n-            return sibling;\n-        }\n-        if (getLine() != sibling.getLine()) {\n-            /* cannot merge callers with different line numbers, move on. */\n-            return sibling;\n-        }\n-        /* splice out the sibling from the chain and update this one to include it. */\n-        unlink(debugContext, sibling);\n-        /* relocate the siblings children to this node. */\n-        reparentChildren(debugContext, sibling);\n-        /* return the merged node so we can maybe merge it again. */\n-        return this;\n-    }\n-\n-    private void unlink(DebugContext debugContext, Range sibling) {\n-        assert hi == sibling.lo : String.format(\"gap in range [0x%x,0x%x] %s [0x%x,0x%x] %s\",\n-                        lo, hi, getFullMethodNameWithParams(), sibling.getLo(), sibling.getHi(), sibling.getFullMethodNameWithParams());\n-        assert this.isInlined == sibling.isInlined : String.format(\"change in inlined [0x%x,0x%x] %s %s [0x%x,0x%x] %s %s\",\n-                        lo, hi, getFullMethodNameWithParams(), Boolean.valueOf(this.isInlined), sibling.lo, sibling.hi, sibling.getFullMethodNameWithParams(), Boolean.valueOf(sibling.isInlined));\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Combining [0x%x, 0x%x] %s into [0x%x, 0x%x] %s\", sibling.lo, sibling.hi, sibling.getFullMethodName(), lo, hi, getFullMethodNameWithParams());\n-        this.hi = sibling.hi;\n-        this.siblingCallee = sibling.siblingCallee;\n-    }\n-\n-    private void reparentChildren(DebugContext debugContext, Range sibling) {\n-        Range siblingNext = sibling.getFirstCallee();\n-        while (siblingNext != null) {\n-            debugContext.log(DebugContext.INFO_LEVEL, \"Reparenting [0x%x, 0x%x] %s to [0x%x, 0x%x] %s\", siblingNext.lo, siblingNext.hi, siblingNext.getFullMethodName(), lo, hi,\n-                            getFullMethodNameWithParams());\n-            siblingNext.caller = this;\n-            Range newSiblingNext = siblingNext.siblingCallee;\n-            siblingNext.siblingCallee = null;\n-            addCallee(siblingNext);\n-            siblingNext = newSiblingNext;\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex d2060e4afd6..9bea361bef6 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -55,41 +50,36 @@ public class Range {\n     /*\n      * Create a primary range.\n      */\n-    public Range(String className, String methodName, String symbolName, String paramSignature, String returnTypeName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n-                    int modifiers, boolean isDeoptTarget) {\n-        this(className, methodName, symbolName, paramSignature, returnTypeName, stringTable, fileEntry, lo, hi, line, modifiers, isDeoptTarget, null);\n+    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n+                 boolean isDeoptTarget) {\n+        this(symbolName, stringTable, methodEntry, fileEntry, lo, hi, line, isDeoptTarget, null);\n     }\n \n     /*\n      * Create a secondary range.\n      */\n-    public Range(String className, String methodName, String symbolName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n-                    Range primary) {\n-        this(className, methodName, symbolName, \"\", \"\", stringTable, fileEntry, lo, hi, line, 0, false, primary);\n+    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n+        this(symbolName, stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, false, primary);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(String className, String methodName, String symbolName, String paramSignature, String returnTypeName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n-                    int modifiers, boolean isDeoptTarget, Range primary) {\n-        this.fileEntry = fileEntry;\n+    private Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n+                    boolean isDeoptTarget, Range primary) {\n+        this.fileEntry = fileEntry; // TODO remove and use fileEntry from MethodEntry\n         if (fileEntry != null) {\n             stringTable.uniqueDebugString(fileEntry.getFileName());\n             stringTable.uniqueDebugString(fileEntry.getPathName());\n         }\n-        this.className = stringTable.uniqueString(className);\n-        this.methodName = stringTable.uniqueString(methodName);\n+        assert methodEntry != null;\n+        this.methodEntry = methodEntry;\n         this.symbolName = stringTable.uniqueString(symbolName);\n-        this.paramSignature = stringTable.uniqueString(paramSignature);\n-        this.returnTypeName = stringTable.uniqueString(returnTypeName);\n-        this.fullMethodName = stringTable.uniqueString(constructClassAndMethodName());\n         this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n         this.isDeoptTarget = isDeoptTarget;\n-        this.modifiers = modifiers;\n         this.primary = primary;\n     }\n \n", "next_change": {"commit": "f485a3c15f5e29daf480657c0bfa22662f8005ae", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 9bea361bef6..a3d6e1c0db2 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -79,7 +77,6 @@ public class Range {\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n-        this.isDeoptTarget = isDeoptTarget;\n         this.primary = primary;\n     }\n \n", "next_change": {"commit": "dbb2c7607429817e58a1a9af8012e25e861368dc", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex a3d6e1c0db2..af465363bbf 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -49,30 +48,29 @@ public class Range {\n     /*\n      * Create a primary range.\n      */\n-    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n-        this(symbolName, stringTable, methodEntry, fileEntry, lo, hi, line, null);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n+        this(stringTable, methodEntry, fileEntry, lo, hi, line, null);\n     }\n \n     /*\n      * Create a secondary range.\n      */\n-    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n-        this(symbolName, stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n+        this(stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n+    private Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n                     Range primary) {\n-        this.fileEntry = fileEntry; // TODO remove and use fileEntry from MethodEntry\n+        this.fileEntry = fileEntry;\n         if (fileEntry != null) {\n             stringTable.uniqueDebugString(fileEntry.getFileName());\n             stringTable.uniqueDebugString(fileEntry.getPathName());\n         }\n         assert methodEntry != null;\n         this.methodEntry = methodEntry;\n-        this.symbolName = stringTable.uniqueString(symbolName);\n         this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n         this.lo = lo;\n         this.hi = hi;\n", "next_change": {"commit": "a658b95d63a93b1980e4ac81fd4c034c70b9d9cb", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex af465363bbf..5f7f3fe3bda 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -48,28 +47,19 @@ public class Range {\n     /*\n      * Create a primary range.\n      */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n-        this(stringTable, methodEntry, fileEntry, lo, hi, line, null);\n-    }\n-\n-    /*\n-     * Create a secondary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n-        this(stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line) {\n+        this(stringTable, methodEntry, lo, hi, line, null);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n-                    Range primary) {\n-        this.fileEntry = fileEntry;\n-        if (fileEntry != null) {\n-            stringTable.uniqueDebugString(fileEntry.getFileName());\n-            stringTable.uniqueDebugString(fileEntry.getPathName());\n-        }\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n         assert methodEntry != null;\n+        if (methodEntry.fileEntry != null) {\n+            stringTable.uniqueDebugString(methodEntry.fileEntry.getFileName());\n+            stringTable.uniqueDebugString(methodEntry.fileEntry.getPathName());\n+        }\n         this.methodEntry = methodEntry;\n         this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n         this.lo = lo;\n", "next_change": {"commit": "6fcf98378231f0e754061b683c3dba387ce8b0e9", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 5f7f3fe3bda..cc407a53acd 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -65,7 +68,10 @@ public class Range {\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n+        this.isInlined = isInline;\n         this.primary = primary;\n+        this.withChildren = withChildren;\n+        this.caller = caller;\n     }\n \n     public boolean contains(Range other) {\n", "next_change": {"commit": "abe98eaaa6dd772b7419b819fa342e810a0939e0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex cc407a53acd..037024f1755 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -71,6 +74,7 @@ public class Range {\n         this.isInlined = isInline;\n         this.primary = primary;\n         this.withChildren = withChildren;\n+        this.withInlinedChildren = false;\n         this.caller = caller;\n     }\n \n", "next_change": {"commit": "268c33256b26217c50339f452adea942fb48818f", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 037024f1755..1951241dda1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -73,9 +93,32 @@ public class Range {\n         this.line = line;\n         this.isInlined = isInline;\n         this.primary = primary;\n-        this.withChildren = withChildren;\n-        this.withInlinedChildren = false;\n+        this.firstCallee = null;\n+        this.lastCallee = null;\n+        this.nextCallee = null;\n         this.caller = caller;\n+        if (caller != null) {\n+            caller.addCallee(this);\n+        }\n+        if (this.isPrimary()) {\n+            this.depth = -1;\n+        } else {\n+            this.depth = caller.depth + 1;\n+        }\n+    }\n+\n+    private void addCallee(Range callee) {\n+        assert this.lo <= callee.lo;\n+        assert this.hi >= callee.hi;\n+        assert callee.caller == this;\n+        assert callee.nextCallee == null;\n+        if (this.firstCallee == null) {\n+            assert this.lastCallee == null;\n+            this.firstCallee = this.lastCallee = callee;\n+        } else {\n+            this.lastCallee.nextCallee = callee;\n+            this.lastCallee = callee;\n+        }\n     }\n \n     public boolean contains(Range other) {\n", "next_change": {"commit": "6ae5665ec0f5f89ff4a7804dbeec25c85d0982ea", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 1951241dda1..43c64a540e9 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -111,12 +111,12 @@ public class Range {\n         assert this.lo <= callee.lo;\n         assert this.hi >= callee.hi;\n         assert callee.caller == this;\n-        assert callee.nextCallee == null;\n+        assert callee.siblingCallee == null;\n         if (this.firstCallee == null) {\n             assert this.lastCallee == null;\n             this.firstCallee = this.lastCallee = callee;\n         } else {\n-            this.lastCallee.nextCallee = callee;\n+            this.lastCallee.siblingCallee = callee;\n             this.lastCallee = callee;\n         }\n     }\n", "next_change": {"commit": "9acf1c5d597e38f3e832360ce3f372ad94b16e9e", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\ndeleted file mode 100644\nindex 43c64a540e9..00000000000\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ /dev/null\n", "chunk": "@@ -1,339 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.objectfile.debugentry;\n-\n-import org.graalvm.compiler.debug.DebugContext;\n-\n-/**\n- * Details of a specific address range in a compiled method either a primary range identifying a\n- * whole method or a sub-range identifying a sequence of instructions that belong to an inlined\n- * method. Each sub-range is linked with its caller and its callees, forming a call tree.\n- */\n-public class Range {\n-    private static final String CLASS_DELIMITER = \".\";\n-    private Range caller;\n-    private final MethodEntry methodEntry;\n-    private final String fullMethodName;\n-    private final String fullMethodNameWithParams;\n-    private final int lo;\n-    private int hi;\n-    private final int line;\n-    private final boolean isInlined;\n-    private final int depth;\n-    /**\n-     * This is null for a primary range. For sub ranges it holds the root of the call tree they\n-     * belong to.\n-     */\n-    private final Range primary;\n-\n-    /*\n-     * Support for tree of nested inline callee ranges\n-     */\n-\n-    /**\n-     * The first direct callee whose range is wholly contained in this range.\n-     */\n-    private Range firstCallee;\n-\n-    /**\n-     * The last direct callee whose range is wholly contained in this range.\n-     */\n-    private Range lastCallee;\n-\n-    /**\n-     * A link to a sibling callee, i.e., a range sharing the same caller with this range.\n-     */\n-    private Range siblingCallee;\n-\n-    /*\n-     * Create a primary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line) {\n-        this(stringTable, methodEntry, lo, hi, line, null, false, null);\n-    }\n-\n-    /*\n-     * Create a primary or secondary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary, boolean isInline, Range caller) {\n-        assert methodEntry != null;\n-        if (methodEntry.fileEntry != null) {\n-            stringTable.uniqueDebugString(methodEntry.fileEntry.getFileName());\n-            stringTable.uniqueDebugString(methodEntry.fileEntry.getPathName());\n-        }\n-        this.methodEntry = methodEntry;\n-        this.fullMethodName = isInline ? stringTable.uniqueDebugString(constructClassAndMethodName()) : stringTable.uniqueString(constructClassAndMethodName());\n-        this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n-        this.lo = lo;\n-        this.hi = hi;\n-        this.line = line;\n-        this.isInlined = isInline;\n-        this.primary = primary;\n-        this.firstCallee = null;\n-        this.lastCallee = null;\n-        this.siblingCallee = null;\n-        this.caller = caller;\n-        if (caller != null) {\n-            caller.addCallee(this);\n-        }\n-        if (this.isPrimary()) {\n-            this.depth = -1;\n-        } else {\n-            this.depth = caller.depth + 1;\n-        }\n-    }\n-\n-    private void addCallee(Range callee) {\n-        assert this.lo <= callee.lo;\n-        assert this.hi >= callee.hi;\n-        assert callee.caller == this;\n-        assert callee.siblingCallee == null;\n-        if (this.firstCallee == null) {\n-            assert this.lastCallee == null;\n-            this.firstCallee = this.lastCallee = callee;\n-        } else {\n-            this.lastCallee.siblingCallee = callee;\n-            this.lastCallee = callee;\n-        }\n-    }\n-\n-    public boolean contains(Range other) {\n-        return (lo <= other.lo && hi >= other.hi);\n-    }\n-\n-    public boolean isPrimary() {\n-        return getPrimary() == null;\n-    }\n-\n-    public Range getPrimary() {\n-        return primary;\n-    }\n-\n-    public String getClassName() {\n-        return methodEntry.ownerType.typeName;\n-    }\n-\n-    public String getMethodName() {\n-        return methodEntry.memberName;\n-    }\n-\n-    public String getSymbolName() {\n-        return methodEntry.getSymbolName();\n-    }\n-\n-    public int getHi() {\n-        return hi;\n-    }\n-\n-    public int getLo() {\n-        return lo;\n-    }\n-\n-    public int getLine() {\n-        return line;\n-    }\n-\n-    public String getFullMethodName() {\n-        return fullMethodName;\n-    }\n-\n-    public String getFullMethodNameWithParams() {\n-        return fullMethodNameWithParams;\n-    }\n-\n-    public boolean isDeoptTarget() {\n-        return methodEntry.isDeopt();\n-    }\n-\n-    private String getExtendedMethodName(boolean includeClass, boolean includeParams, boolean includeReturnType) {\n-        StringBuilder builder = new StringBuilder();\n-        if (includeReturnType && methodEntry.valueType.typeName.length() > 0) {\n-            builder.append(methodEntry.valueType.typeName);\n-            builder.append(' ');\n-        }\n-        if (includeClass && getClassName() != null) {\n-            builder.append(getClassName());\n-            builder.append(CLASS_DELIMITER);\n-        }\n-        builder.append(getMethodName());\n-        if (includeParams) {\n-            builder.append('(');\n-            builder.append(String.join(\", \", methodEntry.paramNames));\n-            builder.append(')');\n-        }\n-        if (includeReturnType) {\n-            builder.append(\" \");\n-            builder.append(methodEntry.valueType.typeName);\n-        }\n-        return builder.toString();\n-    }\n-\n-    private String constructClassAndMethodName() {\n-        return getExtendedMethodName(true, false, false);\n-    }\n-\n-    private String constructClassAndMethodNameWithParams() {\n-        return getExtendedMethodName(true, true, false);\n-    }\n-\n-    public FileEntry getFileEntry() {\n-        return methodEntry.fileEntry;\n-    }\n-\n-    public int getModifiers() {\n-        return methodEntry.modifiers;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"Range(lo=0x%05x hi=0x%05x %s %s:%d)\", lo, hi, constructClassAndMethodNameWithParams(), methodEntry.getFullFileName(), line);\n-    }\n-\n-    public String getFileName() {\n-        return methodEntry.getFileName();\n-    }\n-\n-    public MethodEntry getMethodEntry() {\n-        return methodEntry;\n-    }\n-\n-    public boolean isInlined() {\n-        return isInlined;\n-    }\n-\n-    public Range getCaller() {\n-        return caller;\n-    }\n-\n-    public Range getFirstCallee() {\n-        return firstCallee;\n-    }\n-\n-    public Range getSiblingCallee() {\n-        return siblingCallee;\n-    }\n-\n-    public Range getLastCallee() {\n-        return lastCallee;\n-    }\n-\n-    public boolean isLeaf() {\n-        return firstCallee == null;\n-    }\n-\n-    public int getDepth() {\n-        return depth;\n-    }\n-\n-    /**\n-     * Minimizes the nodes in the tree that track the inline call hierarchy and associated code\n-     * ranges. The initial range tree models the call hierarchy as presented in the original debug\n-     * line info. It consists of a root node each of whose children is a sequence of linear call\n-     * chains, either a single leaf node for some given file and line or a series of inline calls to\n-     * such a leaf node. In this initial tree all node ranges in a given chain have the same lo and\n-     * hi address and chains are properly ordered by range The merge algorithm works across siblings\n-     * at successive depths starting at depth 1. Once all possible nodes at a given depth have been\n-     * merged their children can then be merged. A successor node may only be merged into its\n-     * predecessor if the nodes have contiguous ranges and idenitfy the same method, line and file.\n-     * The range and children of the merged node are, respectively, the union of the input ranges\n-     * and children. This preserves the invariant that child ranges lie within their parent range.\n-     *\n-     * @param debugContext\n-     */\n-    public void mergeSubranges(DebugContext debugContext) {\n-        Range next = getFirstCallee();\n-        if (next == null) {\n-            return;\n-        }\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Merge subranges [0x%x, 0x%x] %s\", lo, hi, getFullMethodNameWithParams());\n-        /* merge siblings together if possible, reparenting children to the merged node */\n-        while (next != null) {\n-            next = next.maybeMergeSibling(debugContext);\n-        }\n-        /* now recurse down to merge children of whatever nodes remain */\n-        next = getFirstCallee();\n-        /* now this level is merged recursively merge children of each child node. */\n-        while (next != null) {\n-            next.mergeSubranges(debugContext);\n-            next = next.getSiblingCallee();\n-        }\n-    }\n-\n-    /**\n-     * Removes and merges the next sibling returning the current node or it skips past the current\n-     * node as is and returns the next sibling or null if no sibling exists.\n-     */\n-    private Range maybeMergeSibling(DebugContext debugContext) {\n-        Range sibling = getSiblingCallee();\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Merge subrange (maybe) [0x%x, 0x%x] %s\", lo, hi, getFullMethodNameWithParams());\n-        if (sibling == null) {\n-            /* all child nodes at this level have been merged */\n-            return null;\n-        }\n-        if (hi < sibling.lo) {\n-            /* cannot merge non-contiguous ranges, move on. */\n-            return sibling;\n-        }\n-        if (getMethodEntry() != sibling.getMethodEntry()) {\n-            /* cannot merge distinct callers, move on. */\n-            return sibling;\n-        }\n-        if (getLine() != sibling.getLine()) {\n-            /* cannot merge callers with different line numbers, move on. */\n-            return sibling;\n-        }\n-        /* splice out the sibling from the chain and update this one to include it. */\n-        unlink(debugContext, sibling);\n-        /* relocate the siblings children to this node. */\n-        reparentChildren(debugContext, sibling);\n-        /* return the merged node so we can maybe merge it again. */\n-        return this;\n-    }\n-\n-    private void unlink(DebugContext debugContext, Range sibling) {\n-        assert hi == sibling.lo : String.format(\"gap in range [0x%x,0x%x] %s [0x%x,0x%x] %s\",\n-                        lo, hi, getFullMethodNameWithParams(), sibling.getLo(), sibling.getHi(), sibling.getFullMethodNameWithParams());\n-        assert this.isInlined == sibling.isInlined : String.format(\"change in inlined [0x%x,0x%x] %s %s [0x%x,0x%x] %s %s\",\n-                        lo, hi, getFullMethodNameWithParams(), Boolean.valueOf(this.isInlined), sibling.lo, sibling.hi, sibling.getFullMethodNameWithParams(), Boolean.valueOf(sibling.isInlined));\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Combining [0x%x, 0x%x] %s into [0x%x, 0x%x] %s\", sibling.lo, sibling.hi, sibling.getFullMethodName(), lo, hi, getFullMethodNameWithParams());\n-        this.hi = sibling.hi;\n-        this.siblingCallee = sibling.siblingCallee;\n-    }\n-\n-    private void reparentChildren(DebugContext debugContext, Range sibling) {\n-        Range siblingNext = sibling.getFirstCallee();\n-        while (siblingNext != null) {\n-            debugContext.log(DebugContext.INFO_LEVEL, \"Reparenting [0x%x, 0x%x] %s to [0x%x, 0x%x] %s\", siblingNext.lo, siblingNext.hi, siblingNext.getFullMethodName(), lo, hi,\n-                            getFullMethodNameWithParams());\n-            siblingNext.caller = this;\n-            Range newSiblingNext = siblingNext.siblingCallee;\n-            siblingNext.siblingCallee = null;\n-            addCallee(siblingNext);\n-            siblingNext = newSiblingNext;\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc1ODc5Ng==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r415758796", "body": "This looks a lot like java.nio.ByteBuffer", "bodyText": "This looks a lot like java.nio.ByteBuffer", "bodyHTML": "<p dir=\"auto\">This looks a lot like java.nio.ByteBuffer</p>", "author": "olpaw", "createdAt": "2020-04-27T12:11:45Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+abstract class CVUtil {", "originalCommit": "ae54dad6eebb244a96e6123cb61380f282cece47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc1NTk1Mg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r416755952", "bodyText": "Yes it does, modulo endianness.\nThere is a history as to why Simon is not using a ByteBuffer. I followed a similar path with the Dwarf sections implementation classes where the DwarfSectionsImpl.writeXXX methods bottom out at similar looking base DwarfSectionsImpl.putXXX methods.\nWhen trying to size a section the writeXXX methods are passed a null buffer and they compute the size by recursively writing the relevant contents using further writeXXX or putXXX calls and summing the number of bytes written. When a writeXXX method bottoms out at a putXXX method a scratch buffer is passed when the input buffer is null so the computed size reflects the precise number of bytes written. The same top level writeXXX method can then be used to write a buffer allocated with the required total. I thought about using a ByteBuffer when I wrote it this way but decided to keep the byte[] until I saw that there was no need to be able to do raw byte level peeks and pokes on the underlying array.\nIt would be fairly straightforward to achieve the same outcome by passing a ByteBuffer or null to the writeXXX calls and replacing the putXXX calls with invocations of the relevant ByteBuffer put method. However, what I was planning to do was create a new class, let's call it SectionByteBuffer, with two variants. A StandardSectionByteBuffer would recursively assemble the relevant data into a target byte[] via an encapsulated ByteBuffer. A SizingSectionByteBuffer would throw away the data and simply update a buffer offset to reflect the data written by a putXXX operation.\nI was thinking it would be better to fix this for both implementations as a separate patch. Would that be ok? Alternatively, we could make the change to both Linux and Windows debug code now?", "author": "adinn", "createdAt": "2020-04-28T16:31:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc1ODc5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java\nindex 49266b354e1..d825143c67d 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java\n", "chunk": "@@ -26,11 +26,12 @@\n \n package com.oracle.objectfile.pecoff.cv;\n \n+import com.oracle.objectfile.io.Utf8;\n+\n import static java.nio.charset.StandardCharsets.UTF_8;\n \n abstract class CVUtil {\n \n-    /* base level put methods that assume a non-null buffer */\n     static int putByte(byte b, byte[] buffer, int initialPos) {\n         if (buffer == null) {\n             return initialPos + Byte.BYTES;\n", "next_change": {"commit": "be97e8b0b377da7184398ae13748683d31424624", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java\nindex d825143c67d..f416e7bfc98 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java\n", "chunk": "@@ -32,51 +32,83 @@ import static java.nio.charset.StandardCharsets.UTF_8;\n \n abstract class CVUtil {\n \n-    static int putByte(byte b, byte[] buffer, int initialPos) {\n+    /**\n+     * Store a byte value in the buffer.\n+     *\n+     * @param value value to store\n+     * @param buffer buffer to store value in\n+     * @param initialPos initial position in buffer\n+     * @return position in buffer following stored value\n+     */\n+    static int putByte(byte value, byte[] buffer, int initialPos) {\n         if (buffer == null) {\n             return initialPos + Byte.BYTES;\n         }\n         int pos = initialPos;\n-        buffer[pos++] = b;\n+        buffer[pos++] = value;\n         return pos;\n     }\n \n-    static int putShort(short s, byte[] buffer, int initialPos) {\n+    /**\n+     * Store a short value in the buffer.\n+     *\n+     * @param value value to store\n+     * @param buffer buffer to store value in\n+     * @param initialPos initial position in buffer\n+     * @return position in buffer following stored value\n+     */\n+    static int putShort(short value, byte[] buffer, int initialPos) {\n         if (buffer == null) {\n             return initialPos + Short.BYTES;\n         }\n         int pos = initialPos;\n-        buffer[pos++] = (byte) (s & 0xff);\n-        buffer[pos++] = (byte) ((s >> 8) & 0xff);\n+        buffer[pos++] = (byte) (value & 0xff);\n+        buffer[pos++] = (byte) ((value >> 8) & 0xff);\n         return pos;\n     }\n \n-    static int putInt(int i, byte[] buffer, int initialPos) {\n+    /**\n+     * Store an integer value in the buffer.\n+     *\n+     * @param value value to store\n+     * @param buffer buffer to store value in\n+     * @param initialPos initial position in buffer\n+     * @return position in buffer following stored value\n+     */\n+    static int putInt(int value, byte[] buffer, int initialPos) {\n         if (buffer == null) {\n             return initialPos + Integer.BYTES;\n         }\n         int pos = initialPos;\n-        buffer[pos++] = (byte) (i & 0xff);\n-        buffer[pos++] = (byte) ((i >> 8) & 0xff);\n-        buffer[pos++] = (byte) ((i >> 16) & 0xff);\n-        buffer[pos++] = (byte) ((i >> 24) & 0xff);\n+        buffer[pos++] = (byte) (value & 0xff);\n+        buffer[pos++] = (byte) ((value >> 8) & 0xff);\n+        buffer[pos++] = (byte) ((value >> 16) & 0xff);\n+        buffer[pos++] = (byte) ((value >> 24) & 0xff);\n         return pos;\n     }\n \n+    /**\n+     * Store a long value in the buffer.\n+     *\n+     * @param value value to store\n+     * @param buffer buffer to store value in\n+     * @param initialPos initial position in buffer\n+     * @return position in buffer following stored value\n+     */\n     @SuppressWarnings(\"unused\")\n-    static int putLong(long l, byte[] buffer, int initialPos) {\n+    static int putLong(long value, byte[] buffer, int initialPos) {\n         if (buffer == null) {\n             return initialPos + Long.BYTES;\n         }\n         int pos = initialPos;\n-        buffer[pos++] = (byte) (l & 0xff);\n-        buffer[pos++] = (byte) ((l >> 8) & 0xff);\n-        buffer[pos++] = (byte) ((l >> 16) & 0xff);\n-        buffer[pos++] = (byte) ((l >> 24) & 0xff);\n-        buffer[pos++] = (byte) ((l >> 32) & 0xff);\n-        buffer[pos++] = (byte) ((l >> 40) & 0xff);\n-        buffer[pos++] = (byte) ((l >> 48) & 0xff);\n-        buffer[pos++] = (byte) ((l >> 56) & 0xff);\n+        buffer[pos++] = (byte) (value & 0xff);\n+        buffer[pos++] = (byte) ((value >> 8) & 0xff);\n+        buffer[pos++] = (byte) ((value >> 16) & 0xff);\n+        buffer[pos++] = (byte) ((value >> 24) & 0xff);\n+        buffer[pos++] = (byte) ((value >> 32) & 0xff);\n+        buffer[pos++] = (byte) ((value >> 40) & 0xff);\n+        buffer[pos++] = (byte) ((value >> 48) & 0xff);\n+        buffer[pos++] = (byte) ((value >> 56) & 0xff);\n         return pos;\n     }\n \n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIyNTEyNQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r417225125", "body": "Is there a reason why you want a toString for FileEntry but not for other elements of the debug info model?", "bodyText": "Is there a reason why you want a toString for FileEntry but not for other elements of the debug info model?", "bodyHTML": "<p dir=\"auto\">Is there a reason why you want a toString for FileEntry but not for other elements of the debug info model?</p>", "author": "adinn", "createdAt": "2020-04-29T10:48:31Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java", "diffHunk": "@@ -59,4 +59,14 @@ public String getFullName() {\n     public DirEntry getDirEntry() {\n         return dirEntry;\n     }\n+", "originalCommit": "ae54dad6eebb244a96e6123cb61380f282cece47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA1MTY3Mg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r418051672", "bodyText": "Originally, I had them everywhere; it saved much time while debugging. There's one on Range, too. I'm happy to get rid of them or add a couple more.  I think some were lost when we refactored these classes to be shared.", "author": "stooke", "createdAt": "2020-04-30T14:27:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIyNTEyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA5MDk5Mg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r418090992", "bodyText": "Well, if hey are not particularly important then I would say less code is better", "author": "adinn", "createdAt": "2020-04-30T15:20:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIyNTEyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA5MzAxMQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r418093011", "bodyText": "Gone.", "author": "stooke", "createdAt": "2020-04-30T15:23:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIyNTEyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "4f231abdcb1b44ea570aef3acfbbe2f3d34e4898", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java\nindex 4cad616912d..f9c5333d8a7 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java\n", "chunk": "@@ -60,13 +62,10 @@ public class FileEntry {\n         return dirEntry;\n     }\n \n-    @Override\n-    public String toString() {\n-        if (getDirEntry() == null) {\n-            return getFileName() == null ? \"-\" : getFileName();\n-        } else if (getFileName() == null) {\n-            return \"--\";\n-        }\n-        return String.format(\"FileEntry(%s)\", getFullName());\n+    /**\n+     * The compilation directory in which to look for source files as a {@link String}.\n+     */\n+    public String getCachePath() {\n+        return cachePath;\n     }\n }\n", "next_change": {"commit": "75651ac3832de72b3360e6fd39f6e4c73860aa13", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java\nindex f9c5333d8a7..67936c39b5e 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java\n", "chunk": "@@ -62,10 +60,4 @@ public class FileEntry {\n         return dirEntry;\n     }\n \n-    /**\n-     * The compilation directory in which to look for source files as a {@link String}.\n-     */\n-    public String getCachePath() {\n-        return cachePath;\n-    }\n }\n", "next_change": {"commit": "86b7f4ca17b527b0ef4fb4deaea3b8eddb832364", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java\nindex 67936c39b5e..f9c5333d8a7 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java\n", "chunk": "@@ -60,4 +62,10 @@ public class FileEntry {\n         return dirEntry;\n     }\n \n+    /**\n+     * The compilation directory in which to look for source files as a {@link String}.\n+     */\n+    public String getCachePath() {\n+        return cachePath;\n+    }\n }\n", "next_change": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java\nindex f9c5333d8a7..f81eadc6a30 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java\n", "chunk": "@@ -68,4 +68,14 @@ public class FileEntry {\n     public String getCachePath() {\n         return cachePath;\n     }\n+\n+    @Override\n+    public String toString() {\n+        if (getDirEntry() == null) {\n+            return getFileName() == null ? \"-\" : getFileName();\n+        } else if (getFileName() == null) {\n+            return \"--\";\n+        }\n+        return String.format(\"FileEntry(%s)\", getFullName());\n+    }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkxNTg1MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r417915850", "body": "I'm not clear why you need JDK_SOURCE_BASE or GRAAL_SOURCE_BASE. They are not used. Will they be needed?", "bodyText": "I'm not clear why you need JDK_SOURCE_BASE or GRAAL_SOURCE_BASE. They are not used. Will they be needed?", "bodyHTML": "<p dir=\"auto\">I'm not clear why you need JDK_SOURCE_BASE or GRAAL_SOURCE_BASE. They are not used. Will they be needed?</p>", "author": "adinn", "createdAt": "2020-04-30T10:36:59Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+public abstract class CVConstants {\n+\n+    /* names of relevant CodeView sections */\n+    static final String CV_SYMBOL_SECTION_NAME = \".debug$S\";\n+    static final String CV_TYPE_SECTION_NAME = \".debug$T\";\n+    // static final String CV_RDATA_SECTION_NAME = \".rdata\";\n+    // static final String CV_PDATA_SECTION_NAME = \".pdata\";\n+    // static final String CV_XDATA_SECTION_NAME = \".xdata\";\n+    // static final String TEXT_SECTION_NAME = \".text\";\n+    // static final String DATA_SECTION_NAME = \".data\";\n+\n+    /* CodeView section header signature */\n+    static final int CV_SIGNATURE_C13 = 4;\n+\n+    /*\n+     * Knobs\n+     *\n+     * (some may become Graal options in the future)\n+     */\n+\n+    /*", "originalCommit": "ae54dad6eebb244a96e6123cb61380f282cece47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA1Mzg0MQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r418053841", "bodyText": "They were temporary hooks that could have been turned into svm options; they predate the SourceCache.  Gone.", "author": "stooke", "createdAt": "2020-04-30T14:30:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkxNTg1MA=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java\nindex 5e1cd4d571a..5465da96716 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java\n", "chunk": "@@ -28,83 +28,11 @@ package com.oracle.objectfile.pecoff.cv;\n \n public abstract class CVConstants {\n \n-    /* names of relevant CodeView sections */\n-    static final String CV_SYMBOL_SECTION_NAME = \".debug$S\";\n-    static final String CV_TYPE_SECTION_NAME = \".debug$T\";\n-    // static final String CV_RDATA_SECTION_NAME = \".rdata\";\n-    // static final String CV_PDATA_SECTION_NAME = \".pdata\";\n-    // static final String CV_XDATA_SECTION_NAME = \".xdata\";\n-    // static final String TEXT_SECTION_NAME = \".text\";\n-    // static final String DATA_SECTION_NAME = \".data\";\n+    /* The names of relevant CodeView sections. */\n+    static final String CV_SECTION_NAME_PREFIX = \".debug$\";\n+    static final String CV_SYMBOL_SECTION_NAME = CV_SECTION_NAME_PREFIX + \"S\";\n+    static final String CV_TYPE_SECTION_NAME = CV_SECTION_NAME_PREFIX + \"T\";\n \n     /* CodeView section header signature */\n     static final int CV_SIGNATURE_C13 = 4;\n-\n-    /*\n-     * Knobs\n-     *\n-     * (some may become Graal options in the future)\n-     */\n-\n-    /*\n-     * path to JDK source code (for example unzipped src.zip) If set, source paths for JDK classes\n-     * in the object file will be $JDK_SOURCE_BASE/java/package/someclass.java instead of (cache\n-     * directory)/sources/jdk/java/package/someclass.java or (if source cache is disabled)\n-     * java/package/someclass.java\n-     *\n-     * example JDK_SOURCE_BASE = C:\\\\tmp\\\\graal-8\\\\jdk8_jvmci\\\\src\\\\\";\n-     */\n-    static final String JDK_SOURCE_BASE = \"\";\n-\n-    /*\n-     * path to Graal source code base (for examplke checked out Graal source repository) if set\n-     * source paths will be inferred from appropriate Graal package directories (behaves similarly\n-     * to JDK_SOURCE_BASE)\n-     *\n-     * Example: GRAAL_SOURCE_BASE = \"C:\\\\tmp\\\\graal-8\\\\graal8\\\\\";\n-     */\n-    static final String GRAAL_SOURCE_BASE = \"\";\n-\n-    /*\n-     * if true, don't emit debug code for Graal classes.\n-     */\n-    static final boolean skipGraalInternals = false;\n-\n-    /*\n-     * (unimplemented) if true, don't emit debug code for JDK classes.\n-     */\n-    static final boolean skipJDKInternals = false;\n-\n-    /*\n-     * if true, Graal inlined code treated as user generated code. (less complicated for user-level\n-     * debugging)\n-     */\n-    static final boolean skipGraalIntrinsics = false;\n-\n-    /*\n-     * if a line record is the same line in the same file as the previous record, merge them.\n-     */\n-    static final boolean mergeAdjacentLineRecords = true;\n-\n-    /*\n-     * if true, first main() does not have args in the debug name.\n-     */\n-    static final boolean emitUnadornedMain = true;\n-\n-    /*\n-     * if true, first main() becomes this name (with no class name or arg list at all) (set null to\n-     * disable).\n-     */\n-    static final String replaceMainFunctionName = null;\n-\n-    /*\n-     * The standard link.exe can't handle odd characters (parentheses or commas, for example) in\n-     * external names. Setting functionNamesHashArgs true replaces those names, so that\n-     * \"Foo.function(String[] args)\" becomes \"Foo.function_617849326\". If functionNamesHashArgs is\n-     * false, currently the linker will fail.\n-     *\n-     * if true, arg lists become obscure integers (and link.exe will work properly) TODO: strip\n-     * illegal characters from arg lists instead\n-     */\n-    static final boolean functionNamesHashArgs = true;\n }\n", "next_change": {"commit": "77e3a7479e429a3279d3061496d260e35f21f000", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java\nindex 5465da96716..9bea2634bbd 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java\n", "chunk": "@@ -35,4 +35,13 @@ public abstract class CVConstants {\n \n     /* CodeView section header signature */\n     static final int CV_SIGNATURE_C13 = 4;\n+\n+    static final int CV_AMD64_R8 = 336;\n+    static final int CV_AMD64_R9 = 337;\n+    static final int CV_AMD64_R10 = 338;\n+    static final int CV_AMD64_R11 = 339;\n+    static final int CV_AMD64_R12 = 340;\n+    static final int CV_AMD64_R13 = 341;\n+    static final int CV_AMD64_R14 = 342;\n+    static final int CV_AMD64_R15 = 343;\n }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyNDc0OQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r417924749", "body": "It is probably an interesting idea to play with most of the following options but in the end I think we need 1) to implement them uniformly for gdb and CV and 2) converge on a setting that works best rather than expand the already large numebr of config choices. @olpaw may want to chime in here.", "bodyText": "It is probably an interesting idea to play with most of the following options but in the end I think we need 1) to implement them uniformly for gdb and CV and 2) converge on a setting that works best rather than expand the already large numebr of config choices. @olpaw may want to chime in here.", "bodyHTML": "<p dir=\"auto\">It is probably an interesting idea to play with most of the following options but in the end I think we need 1) to implement them uniformly for gdb and CV and 2) converge on a setting that works best rather than expand the already large numebr of config choices. <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/olpaw/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/olpaw\">@olpaw</a> may want to chime in here.</p>", "author": "adinn", "createdAt": "2020-04-30T10:53:45Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+public abstract class CVConstants {\n+\n+    /* names of relevant CodeView sections */\n+    static final String CV_SYMBOL_SECTION_NAME = \".debug$S\";\n+    static final String CV_TYPE_SECTION_NAME = \".debug$T\";\n+    // static final String CV_RDATA_SECTION_NAME = \".rdata\";\n+    // static final String CV_PDATA_SECTION_NAME = \".pdata\";\n+    // static final String CV_XDATA_SECTION_NAME = \".xdata\";\n+    // static final String TEXT_SECTION_NAME = \".text\";\n+    // static final String DATA_SECTION_NAME = \".data\";\n+\n+    /* CodeView section header signature */\n+    static final int CV_SIGNATURE_C13 = 4;\n+\n+    /*\n+     * Knobs\n+     *\n+     * (some may become Graal options in the future)\n+     */\n+\n+    /*\n+     * path to JDK source code (for example unzipped src.zip) If set, source paths for JDK classes\n+     * in the object file will be $JDK_SOURCE_BASE/java/package/someclass.java instead of (cache\n+     * directory)/sources/jdk/java/package/someclass.java or (if source cache is disabled)\n+     * java/package/someclass.java\n+     *\n+     * example JDK_SOURCE_BASE = C:\\\\tmp\\\\graal-8\\\\jdk8_jvmci\\\\src\\\\\";\n+     */\n+    static final String JDK_SOURCE_BASE = \"\";\n+\n+    /*\n+     * path to Graal source code base (for examplke checked out Graal source repository) if set\n+     * source paths will be inferred from appropriate Graal package directories (behaves similarly\n+     * to JDK_SOURCE_BASE)\n+     *\n+     * Example: GRAAL_SOURCE_BASE = \"C:\\\\tmp\\\\graal-8\\\\graal8\\\\\";\n+     */\n+    static final String GRAAL_SOURCE_BASE = \"\";\n+\n+    /*\n+     * if true, don't emit debug code for Graal classes.\n+     */\n+    static final boolean skipGraalInternals = false;\n+\n+    /*\n+     * (unimplemented) if true, don't emit debug code for JDK classes.\n+     */\n+    static final boolean skipJDKInternals = false;\n+\n+    /*\n+     * if true, Graal inlined code treated as user generated code. (less complicated for user-level\n+     * debugging)\n+     */\n+    static final boolean skipGraalIntrinsics = false;\n+\n+    /*\n+     * if a line record is the same line in the same file as the previous record, merge them.\n+     */\n+    static final boolean mergeAdjacentLineRecords = true;", "originalCommit": "ae54dad6eebb244a96e6123cb61380f282cece47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkzODM3NA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r417938374", "bodyText": "Every option added increases the risk that any two consumers of debuginfo generated by native-image will see different data. Thus we have to be very careful with adding user adjustable options. Tools that consume our debuginfo (e.g. gdb python helpers) are much easier to write (and maintain) when there is less variability in its generation.", "author": "olpaw", "createdAt": "2020-04-30T11:21:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyNDc0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA1NjExNw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r418056117", "bodyText": "If two continuous Ranges reference the same source position, isn't it more efficient to merge them? This makes a significant difference in debug information size. Probably the appropriate place to do this would be when creating the Ranges; at one point I had it there.  This would make all debug information consistent.  I will take this out now and make it a separate PR later.", "author": "stooke", "createdAt": "2020-04-30T14:33:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyNDc0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA5MjI4NQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r418092285", "bodyText": "Yes, so no switch needed just always do it ... and we can make sure the Linux code does the same.", "author": "adinn", "createdAt": "2020-04-30T15:22:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyNDc0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java\nindex 5e1cd4d571a..5465da96716 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java\n", "chunk": "@@ -28,83 +28,11 @@ package com.oracle.objectfile.pecoff.cv;\n \n public abstract class CVConstants {\n \n-    /* names of relevant CodeView sections */\n-    static final String CV_SYMBOL_SECTION_NAME = \".debug$S\";\n-    static final String CV_TYPE_SECTION_NAME = \".debug$T\";\n-    // static final String CV_RDATA_SECTION_NAME = \".rdata\";\n-    // static final String CV_PDATA_SECTION_NAME = \".pdata\";\n-    // static final String CV_XDATA_SECTION_NAME = \".xdata\";\n-    // static final String TEXT_SECTION_NAME = \".text\";\n-    // static final String DATA_SECTION_NAME = \".data\";\n+    /* The names of relevant CodeView sections. */\n+    static final String CV_SECTION_NAME_PREFIX = \".debug$\";\n+    static final String CV_SYMBOL_SECTION_NAME = CV_SECTION_NAME_PREFIX + \"S\";\n+    static final String CV_TYPE_SECTION_NAME = CV_SECTION_NAME_PREFIX + \"T\";\n \n     /* CodeView section header signature */\n     static final int CV_SIGNATURE_C13 = 4;\n-\n-    /*\n-     * Knobs\n-     *\n-     * (some may become Graal options in the future)\n-     */\n-\n-    /*\n-     * path to JDK source code (for example unzipped src.zip) If set, source paths for JDK classes\n-     * in the object file will be $JDK_SOURCE_BASE/java/package/someclass.java instead of (cache\n-     * directory)/sources/jdk/java/package/someclass.java or (if source cache is disabled)\n-     * java/package/someclass.java\n-     *\n-     * example JDK_SOURCE_BASE = C:\\\\tmp\\\\graal-8\\\\jdk8_jvmci\\\\src\\\\\";\n-     */\n-    static final String JDK_SOURCE_BASE = \"\";\n-\n-    /*\n-     * path to Graal source code base (for examplke checked out Graal source repository) if set\n-     * source paths will be inferred from appropriate Graal package directories (behaves similarly\n-     * to JDK_SOURCE_BASE)\n-     *\n-     * Example: GRAAL_SOURCE_BASE = \"C:\\\\tmp\\\\graal-8\\\\graal8\\\\\";\n-     */\n-    static final String GRAAL_SOURCE_BASE = \"\";\n-\n-    /*\n-     * if true, don't emit debug code for Graal classes.\n-     */\n-    static final boolean skipGraalInternals = false;\n-\n-    /*\n-     * (unimplemented) if true, don't emit debug code for JDK classes.\n-     */\n-    static final boolean skipJDKInternals = false;\n-\n-    /*\n-     * if true, Graal inlined code treated as user generated code. (less complicated for user-level\n-     * debugging)\n-     */\n-    static final boolean skipGraalIntrinsics = false;\n-\n-    /*\n-     * if a line record is the same line in the same file as the previous record, merge them.\n-     */\n-    static final boolean mergeAdjacentLineRecords = true;\n-\n-    /*\n-     * if true, first main() does not have args in the debug name.\n-     */\n-    static final boolean emitUnadornedMain = true;\n-\n-    /*\n-     * if true, first main() becomes this name (with no class name or arg list at all) (set null to\n-     * disable).\n-     */\n-    static final String replaceMainFunctionName = null;\n-\n-    /*\n-     * The standard link.exe can't handle odd characters (parentheses or commas, for example) in\n-     * external names. Setting functionNamesHashArgs true replaces those names, so that\n-     * \"Foo.function(String[] args)\" becomes \"Foo.function_617849326\". If functionNamesHashArgs is\n-     * false, currently the linker will fail.\n-     *\n-     * if true, arg lists become obscure integers (and link.exe will work properly) TODO: strip\n-     * illegal characters from arg lists instead\n-     */\n-    static final boolean functionNamesHashArgs = true;\n }\n", "next_change": {"commit": "77e3a7479e429a3279d3061496d260e35f21f000", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java\nindex 5465da96716..9bea2634bbd 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java\n", "chunk": "@@ -35,4 +35,13 @@ public abstract class CVConstants {\n \n     /* CodeView section header signature */\n     static final int CV_SIGNATURE_C13 = 4;\n+\n+    static final int CV_AMD64_R8 = 336;\n+    static final int CV_AMD64_R9 = 337;\n+    static final int CV_AMD64_R10 = 338;\n+    static final int CV_AMD64_R11 = 339;\n+    static final int CV_AMD64_R12 = 340;\n+    static final int CV_AMD64_R13 = 341;\n+    static final int CV_AMD64_R14 = 342;\n+    static final int CV_AMD64_R15 = 343;\n }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyODg3NA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r417928874", "body": "I'm not sure this is going to be needed? is there a reason why debugging the native image in a project that uses the cached source bundle is going to be unsatisfactory?\r\nRemember once again that the target audience for this debug capability is not developers during developement of an app but developers trying to debug a problem in a deployed native app that has already been tested and shown to work on OpenJDK. So, trying to get the debug info back to refer back to an existing dev project source tree should not really be a concern?", "bodyText": "I'm not sure this is going to be needed? is there a reason why debugging the native image in a project that uses the cached source bundle is going to be unsatisfactory?\nRemember once again that the target audience for this debug capability is not developers during developement of an app but developers trying to debug a problem in a deployed native app that has already been tested and shown to work on OpenJDK. So, trying to get the debug info back to refer back to an existing dev project source tree should not really be a concern?", "bodyHTML": "<p dir=\"auto\">I'm not sure this is going to be needed? is there a reason why debugging the native image in a project that uses the cached source bundle is going to be unsatisfactory?<br>\nRemember once again that the target audience for this debug capability is not developers during developement of an app but developers trying to debug a problem in a deployed native app that has already been tested and shown to work on OpenJDK. So, trying to get the debug info back to refer back to an existing dev project source tree should not really be a concern?</p>", "author": "adinn", "createdAt": "2020-04-30T11:01:49Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVFileRecord.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+\n+import java.io.PrintStream;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Paths;\n+import java.security.MessageDigest;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+final class CVFileRecord extends CVSymbolRecord {\n+\n+    private static final byte CHECKSUM_NONE = 0x00;\n+    private static final byte CHECKSUM_MD5 = 0x01;\n+    private static final byte CB_VALUE = 0x10;\n+\n+    private static final int FILE_RECORD_LENGTH = 24;\n+\n+    private static final int CHECKSUM_LENGTH = 16;\n+    private static final byte[] EMPTY_CHECKSUM = new byte[CHECKSUM_LENGTH];\n+\n+    private static final int FILE_TABLE_INITIAL_SIZE = 200;\n+\n+    private final CVSymbolSectionImpl.CVStringTable strings;\n+\n+    private int currentOffset = 0;\n+    private Map<FileEntry, Integer> fileEntryToOffsetMap = new LinkedHashMap<>(FILE_TABLE_INITIAL_SIZE);\n+\n+    CVFileRecord(CVDebugInfo cvDebugInfo, CVSymbolSectionImpl.CVStringTable strings) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_FILECHKSMS);\n+        this.strings = strings;\n+    }\n+\n+    /*\n+     * Convert a simple path into an absolute path by determining if it's part of Graal, the JDK, or\n+     * use code.\n+     *\n+     * Currently, don't even try; use the SourceCache system\n+     */\n+    private static String fixPath(FileEntry fileEntry) {", "originalCommit": "ae54dad6eebb244a96e6123cb61380f282cece47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI1OTIxOQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r418259219", "bodyText": "I've rewritten the comment on this (and coded it better).  It protects against an NPE when there is no DirEntry in the FileEntry.  I don't remember the circumstances, but it happens in this code.", "author": "stooke", "createdAt": "2020-04-30T20:08:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyODg3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU0NzUzOA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r418547538", "bodyText": "Hmm, I was not expecting that to happen but I suppose it might occur for a class in the default package.\nI'm not sure this is the right place to fix it though. I think it would be better to fix FileEntry.getFullName to detect that dirEntry is null and in that case just return getFileName().", "author": "adinn", "createdAt": "2020-05-01T13:46:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyODg3NA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkzNDA3MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r417934070", "body": "This is very fragile in the face of future GraalVM development. You don't actually need to list every single Graal package just the package roots that can be guaranteed to cover all current packages (and are pretty sure to capture any future additions). If you look at GraalSourceCache it employs a much smaller set of package prefixes to determine that a class is GraalVM code (and hence needs its source located in a src.zip file rather than a jar). It's still fragile in but much less so. If all of this is really needed to allow the skipGraalInternals mode to work then I think maybe that's a good reason not to retain that mode.\r\nThe same issue arises with the list of intrinsic classes that follows.", "bodyText": "This is very fragile in the face of future GraalVM development. You don't actually need to list every single Graal package just the package roots that can be guaranteed to cover all current packages (and are pretty sure to capture any future additions). If you look at GraalSourceCache it employs a much smaller set of package prefixes to determine that a class is GraalVM code (and hence needs its source located in a src.zip file rather than a jar). It's still fragile in but much less so. If all of this is really needed to allow the skipGraalInternals mode to work then I think maybe that's a good reason not to retain that mode.\nThe same issue arises with the list of intrinsic classes that follows.", "bodyHTML": "<p dir=\"auto\">This is very fragile in the face of future GraalVM development. You don't actually need to list every single Graal package just the package roots that can be guaranteed to cover all current packages (and are pretty sure to capture any future additions). If you look at GraalSourceCache it employs a much smaller set of package prefixes to determine that a class is GraalVM code (and hence needs its source located in a src.zip file rather than a jar). It's still fragile in but much less so. If all of this is really needed to allow the skipGraalInternals mode to work then I think maybe that's a good reason not to retain that mode.<br>\nThe same issue arises with the list of intrinsic classes that follows.</p>", "author": "adinn", "createdAt": "2020-04-30T11:12:51Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVRootPackages.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+\n+abstract class CVRootPackages {", "originalCommit": "ae54dad6eebb244a96e6123cb61380f282cece47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI1ODI1NQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r418258255", "bodyText": "I know.  It hurt to write.  It's gone.", "author": "stooke", "createdAt": "2020-04-30T20:06:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkzNDA3MA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkzNzE3OQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r417937179", "body": "I think there may be a problem here that currently exists in the SourceCache code. As far as the source caches are concerned the package filter on \"javax.* packages\" is used to identify that a class belongs to the JDK runtime and that it's source can be found in the src.zip distributed with the JDK. I don't think that is strictly correct as I believe there are implementations of javax.* packages in Java EE components i.e. which ought to be treated as application classes. I'm not clear but I suspect the same problem applies with your test here. Anyway, I'm also still dubious as to why users might want to be able not to see JDK runtime code given the assumed use case for this debug capability.", "bodyText": "I think there may be a problem here that currently exists in the SourceCache code. As far as the source caches are concerned the package filter on \"javax.* packages\" is used to identify that a class belongs to the JDK runtime and that it's source can be found in the src.zip distributed with the JDK. I don't think that is strictly correct as I believe there are implementations of javax.* packages in Java EE components i.e. which ought to be treated as application classes. I'm not clear but I suspect the same problem applies with your test here. Anyway, I'm also still dubious as to why users might want to be able not to see JDK runtime code given the assumed use case for this debug capability.", "bodyHTML": "<p dir=\"auto\">I think there may be a problem here that currently exists in the SourceCache code. As far as the source caches are concerned the package filter on \"javax.* packages\" is used to identify that a class belongs to the JDK runtime and that it's source can be found in the src.zip distributed with the JDK. I don't think that is strictly correct as I believe there are implementations of javax.* packages in Java EE components i.e. which ought to be treated as application classes. I'm not clear but I suspect the same problem applies with your test here. Anyway, I'm also still dubious as to why users might want to be able not to see JDK runtime code given the assumed use case for this debug capability.</p>", "author": "adinn", "createdAt": "2020-04-30T11:19:28Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVRootPackages.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+\n+abstract class CVRootPackages {\n+    private static final String[] rootPackageNames = {\n+                    /* substrate root packages */\n+                    \"com.oracle.graal.pointsto\",\n+                    \"com.oracle.objectfile\",\n+                    \"com.oracle.svm.agent\",\n+                    \"com.oracle.svm.configure\",\n+                    \"com.oracle.svm.core\",\n+                    \"com.oracle.svm.core.genscavenge\",\n+                    \"com.oracle.svm.core.graal\",\n+                    \"com.oracle.svm.core.graal.aarch64\",\n+                    \"com.oracle.svm.core.graal.amd64\",\n+                    \"com.oracle.svm.core.graal.llvm\",\n+                    \"com.oracle.svm.core.jdk11\",\n+                    \"com.oracle.svm.core.jdk8\",\n+                    \"com.oracle.svm.core.posix\",\n+                    \"com.oracle.svm.core.posix.jdk11\",\n+                    \"com.oracle.svm.core.windows\",\n+                    \"com.oracle.svm.driver\",\n+                    \"com.oracle.svm.graal\",\n+                    \"com.oracle.svm.graal.hotspot.libgraal\",\n+                    \"com.oracle.svm.hosted\",\n+                    \"com.oracle.svm.jline\",\n+                    \"com.oracle.svm.jni\",\n+                    \"com.oracle.svm.junit\",\n+                    \"com.oracle.svm.libffi\",\n+                    \"com.oracle.svm.native.jvm.posix\",\n+                    \"com.oracle.svm.native.jvm.windows\",\n+                    \"com.oracle.svm.native.libchelper\",\n+                    \"com.oracle.svm.native.strictmath\",\n+                    \"com.oracle.svm.polyglot\",\n+                    \"com.oracle.svm.reflect\",\n+                    \"com.oracle.svm.test\",\n+                    \"com.oracle.svm.test.jdk11\",\n+                    \"com.oracle.svm.thirdparty\",\n+                    \"com.oracle.svm.truffle\",\n+                    \"com.oracle.svm.truffle.nfi\",\n+                    \"com.oracle.svm.truffle.nfi.posix\",\n+                    \"com.oracle.svm.truffle.nfi.windows\",\n+                    \"com.oracle.svm.tutorial\",\n+                    \"com.oracle.svm.util\",\n+                    \"com.oracle.svm.util.jdk11\",\n+                    \"org.graalvm.polyglot.nativeapi\",\n+                    /* compiler root packages */\n+                    \"jdk.tools.jaotc\",\n+                    \"jdk.tools.jaotc.binformat\",\n+                    \"jdk.tools.jaotc\",\n+                    \"org.graalvm.compiler.api.directives\",\n+                    \"org.graalvm.compiler.api.replacements\",\n+                    \"org.graalvm.compiler.api.runtime\",\n+                    \"org.graalvm.compiler.asm\",\n+                    \"org.graalvm.compiler.asm.aarch64\",\n+                    \"org.graalvm.compiler.asm.amd64\",\n+                    \"org.graalvm.compiler.asm.sparc\",\n+                    \"org.graalvm.compiler.bytecode\",\n+                    \"org.graalvm.compiler.code\",\n+                    \"org.graalvm.compiler.core\",\n+                    \"org.graalvm.compiler.core.aarch64\",\n+                    \"org.graalvm.compiler.core.amd64\",\n+                    \"org.graalvm.compiler.core.common\",\n+                    \"org.graalvm.compiler.core.llvm\",\n+                    \"org.graalvm.compiler.core.match.processor\",\n+                    \"org.graalvm.compiler.core.sparc\",\n+                    \"org.graalvm.compiler.debug\",\n+                    \"org.graalvm.compiler.graph\",\n+                    \"org.graalvm.compiler.hotspot\",\n+                    \"org.graalvm.compiler.hotspot.aarch64\",\n+                    \"org.graalvm.compiler.hotspot.amd64\",\n+                    \"org.graalvm.compiler.hotspot.jdk8\",\n+                    \"org.graalvm.compiler.hotspot.management\",\n+                    \"org.graalvm.compiler.hotspot.sparc\",\n+                    \"org.graalvm.compiler.java\",\n+                    \"org.graalvm.compiler.jtt\",\n+                    \"org.graalvm.compiler.lir\",\n+                    \"org.graalvm.compiler.lir.aarch64\",\n+                    \"org.graalvm.compiler.lir.amd64\",\n+                    \"org.graalvm.compiler.lir.jtt\",\n+                    \"org.graalvm.compiler.lir.sparc\",\n+                    \"org.graalvm.compiler.loop\",\n+                    \"org.graalvm.compiler.loop.phases\",\n+                    \"org.graalvm.compiler.microbenchmarks\",\n+                    \"org.graalvm.compiler.nodeinfo\",\n+                    \"org.graalvm.compiler.nodeinfo.processor\",\n+                    \"org.graalvm.compiler.nodes\",\n+                    \"org.graalvm.compiler.options\",\n+                    \"org.graalvm.compiler.options.processor\",\n+                    \"org.graalvm.compiler.phases\",\n+                    \"org.graalvm.compiler.phases.common\",\n+                    \"org.graalvm.compiler.printer\",\n+                    \"org.graalvm.compiler.processor\",\n+                    \"org.graalvm.compiler.replacements\",\n+                    \"org.graalvm.compiler.replacements.aarch64\",\n+                    \"org.graalvm.compiler.replacements.amd64\",\n+                    \"org.graalvm.compiler.replacements.processor\",\n+                    \"org.graalvm.compiler.replacements.sparc\",\n+                    \"org.graalvm.compiler.runtime\",\n+                    \"org.graalvm.compiler.serviceprovider\",\n+                    \"org.graalvm.compiler.serviceprovider.jdk8\",\n+                    \"org.graalvm.compiler.serviceprovider.processor\",\n+                    \"org.graalvm.compiler.truffle.common\",\n+                    \"org.graalvm.compiler.truffle.common.hotspot\",\n+                    \"org.graalvm.compiler.truffle.common.hotspot.libgraal\",\n+                    \"org.graalvm.compiler.truffle.common.processor\",\n+                    \"org.graalvm.compiler.truffle.compiler\",\n+                    \"org.graalvm.compiler.truffle.compiler.amd64\",\n+                    \"org.graalvm.compiler.truffle.compiler.hotspot\",\n+                    \"org.graalvm.compiler.truffle.compiler.hotspot.aarch64\",\n+                    \"org.graalvm.compiler.truffle.compiler.hotspot.amd64\",\n+                    \"org.graalvm.compiler.truffle.compiler.hotspot.libgraal\",\n+                    \"org.graalvm.compiler.truffle.compiler.hotspot.libgraal.processor\",\n+                    \"org.graalvm.compiler.truffle.compiler.hotspot.sparc\",\n+                    \"org.graalvm.compiler.truffle.runtime\",\n+                    \"org.graalvm.compiler.truffle.runtime.hotspot\",\n+                    \"org.graalvm.compiler.truffle.runtime.hotspot.java\",\n+                    \"org.graalvm.compiler.truffle.runtime.hotspot.jdk8+13\",\n+                    \"org.graalvm.compiler.truffle.runtime.hotspot.libgraal\",\n+                    \"org.graalvm.compiler.truffle.runtime.serviceprovider\",\n+                    \"org.graalvm.compiler.truffle.runtime.serviceprovider.jdk8\",\n+                    \"org.graalvm.compiler.virtual\",\n+                    \"org.graalvm.compiler.virtual.bench\",\n+                    \"org.graalvm.compiler.word\",\n+                    \"org.graalvm.graphio\",\n+                    \"org.graalvm.libgraal\",\n+                    \"org.graalvm.libgraal.jdk8\",\n+                    \"org.graalvm.micro.benchmarks\",\n+                    \"org.graalvm.util\",\n+    };\n+\n+    private static final String[] intrinsicClassNames = {\n+                    \"com.oracle.svm.core.genscavenge.AlignedHeapChunk\",\n+                    \"com.oracle.svm.core.genscavenge.CardTable\",\n+                    \"com.oracle.svm.core.genscavenge.ObjectHeaderImpl\",\n+                    \"com.oracle.svm.core.genscavenge.graal.GenScavengeAllocationSnippets\",\n+                    \"com.oracle.svm.core.genscavenge.graal.BarrierSnippets\",\n+                    \"com.oracle.svm.core.snippets.KnownIntrinsics\",\n+                    \"com.oracle.svm.core.graal.snippets.SubstrateAllocationSnippets\",\n+                    \"com.oracle.svm.core.threadlocal.FastThreadLocalBytes\",\n+                    \"org.graalvm.compiler.replacements.AllocationSnippets\",\n+                    \"org.graalvm.compiler.nodes.PrefetchAllocateNode\",\n+                    \"com.oracle.svm.core.os.CopyingImageHeapProvider\"\n+    };\n+\n+    private static final HashSet<String> rootPackageSet;\n+    private static final HashSet<String> intrinsicClassNameSet;\n+\n+    static {\n+        rootPackageSet = new HashSet<>(rootPackageNames.length);\n+        Collections.addAll(rootPackageSet, rootPackageNames);\n+        intrinsicClassNameSet = new HashSet<>(intrinsicClassNames.length);\n+        Collections.addAll(intrinsicClassNameSet, intrinsicClassNames);\n+    }\n+\n+    static boolean isGraalPackage(String pn) {\n+        return rootPackageSet.contains(pn);\n+    }\n+\n+    private static String getPackagename(String className) {\n+        return className.contains(\".\") ? className.substring(0, className.lastIndexOf('.')) : className;\n+    }\n+\n+    static boolean isGraalClass(String cn) {\n+        final String pn = getPackagename(cn);\n+        return isGraalPackage(pn);\n+    }\n+\n+    /**\n+     * is class a Graal intrinsic class?\n+     *\n+     * @param cn class name of code\n+     * @return true if this is Graal intrinsic code\n+     */\n+    static boolean isGraalIntrinsic(String cn) {\n+        return intrinsicClassNameSet.contains(cn);\n+    }\n+\n+    static boolean isJavaPackage(String pn) {", "originalCommit": "ae54dad6eebb244a96e6123cb61380f282cece47", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk5OTcwOQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r417999709", "body": "I'm not clear where the need for making this public this arose? Can you point at where this is used?", "bodyText": "I'm not clear where the need for making this public this arose? Can you point at where this is used?", "bodyHTML": "<p dir=\"auto\">I'm not clear where the need for making this public this arose? Can you point at where this is used?</p>", "author": "adinn", "createdAt": "2020-04-30T13:14:48Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageOptions.java", "diffHunk": "@@ -60,7 +60,7 @@\n     public static final HostedOptionKey<Boolean> NativeArchitecture = new HostedOptionKey<>(false);\n \n     @Option(help = \"Define PageSize of a machine that runs the image. The default = 0 (== same as host machine page size)\")//\n-    protected static final HostedOptionKey<Integer> PageSize = new HostedOptionKey<>(0);\n+    public static final HostedOptionKey<Integer> PageSize = new HostedOptionKey<>(0);", "originalCommit": "ae54dad6eebb244a96e6123cb61380f282cece47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA1ODkxOA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r418058918", "bodyText": "This doesn't belong in this PR, sorry.  At the time it seemed inconsistent, but this isn't the place for it.  Removed.", "author": "stooke", "createdAt": "2020-04-30T14:36:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk5OTcwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "1a323e92e24aefdecedad5edf4668e09ed230e97", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageOptions.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageOptions.java\nindex c3e22932cfc..4f2694e2c88 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageOptions.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageOptions.java\n", "chunk": "@@ -53,14 +53,14 @@ public class NativeImageOptions {\n                     \"BMI2, RTM, ADX, AVX512F, AVX512DQ, AVX512PF, AVX512ER, AVX512CD, AVX512BW. \" +\n                     \"On AArch64, no features are enabled by default. Available features are: \" +\n                     \"FP, ASIMD, EVTSTRM, AES, PMULL, SHA1, SHA2, CRC32, LSE, STXR_PREFETCH, \" +\n-                    \"A53MAC, DMB_ATOMICS\", type = User)//\n+                    \"A53MAC\", type = User)//\n     public static final HostedOptionKey<String[]> CPUFeatures = new HostedOptionKey<>(null);\n \n     @Option(help = \"Overrides CPUFeatures and uses the native architecture, i.e., the architecture of a machine that builds an image. NativeArchitecture takes precedence over CPUFeatures\", type = User)//\n     public static final HostedOptionKey<Boolean> NativeArchitecture = new HostedOptionKey<>(false);\n \n     @Option(help = \"Define PageSize of a machine that runs the image. The default = 0 (== same as host machine page size)\")//\n-    public static final HostedOptionKey<Integer> PageSize = new HostedOptionKey<>(0);\n+    protected static final HostedOptionKey<Integer> PageSize = new HostedOptionKey<>(0);\n \n     @Option(help = \"Print information about classes, methods, and fields that are present in the native image\")//\n     public static final HostedOptionKey<Boolean> PrintUniverse = new HostedOptionKey<>(false);\n", "next_change": {"commit": "abf19a3f3065b94f44ba5271adb394f2fdfb489b", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageOptions.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageOptions.java\nindex 4f2694e2c88..2ae9cb8e22a 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageOptions.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageOptions.java\n", "chunk": "@@ -27,41 +27,38 @@ package com.oracle.svm.hosted;\n import static org.graalvm.compiler.options.OptionType.Debug;\n import static org.graalvm.compiler.options.OptionType.User;\n \n+import java.nio.file.Paths;\n import java.util.Arrays;\n \n import org.graalvm.collections.EconomicMap;\n import org.graalvm.compiler.options.Option;\n import org.graalvm.compiler.options.OptionKey;\n import org.graalvm.compiler.options.OptionValues;\n-import org.graalvm.compiler.serviceprovider.GraalUnsafeAccess;\n \n import com.oracle.graal.pointsto.api.PointstoOptions;\n+import com.oracle.graal.pointsto.reports.ReportUtils;\n import com.oracle.graal.pointsto.util.CompletionExecutor;\n+import com.oracle.svm.core.SubstrateOptions;\n import com.oracle.svm.core.option.APIOption;\n import com.oracle.svm.core.option.HostedOptionKey;\n+import com.oracle.svm.core.option.LocatableMultiOptionValue;\n import com.oracle.svm.core.util.UserError;\n+import com.oracle.svm.hosted.classinitialization.ClassInitializationOptions;\n \n public class NativeImageOptions {\n \n     public static final int DEFAULT_MAX_ANALYSIS_SCALING = 16;\n \n-    @Option(help = \"Comma separated list of CPU features that will be used for image generation. \" +\n-                    \"The specific options available are platform dependent. \" +\n-                    \"For AMD64, SSE and SSE2 are enabled by default. Available features are: \" +\n-                    \"CX8, CMOV, FXSR, HT, MMX, AMD_3DNOW_PREFETCH, SSE3, SSSE3, SSE4A, SSE4_1, \" +\n-                    \"SSE4_2, POPCNT, LZCNT, TSC, TSCINV, AVX, AVX2, AES, ERMS, CLMUL, BMI1, \" +\n-                    \"BMI2, RTM, ADX, AVX512F, AVX512DQ, AVX512PF, AVX512ER, AVX512CD, AVX512BW. \" +\n-                    \"On AArch64, no features are enabled by default. Available features are: \" +\n-                    \"FP, ASIMD, EVTSTRM, AES, PMULL, SHA1, SHA2, CRC32, LSE, STXR_PREFETCH, \" +\n-                    \"A53MAC\", type = User)//\n-    public static final HostedOptionKey<String[]> CPUFeatures = new HostedOptionKey<>(null);\n+    @Option(help = \"Comma separated list of CPU features that will be enabled while building the \" +\n+                    \"target executable, irrespective of whether they are supported by the hosted \" +\n+                    \"environment. Note that enabling features not present within the target environment \" +\n+                    \"may result in application crashes. The specific options available are target \" +\n+                    \"platform dependent. See --list-cpu-features for feature list.\", type = User)//\n+    public static final HostedOptionKey<LocatableMultiOptionValue.Strings> CPUFeatures = new HostedOptionKey<>(new LocatableMultiOptionValue.Strings());\n \n     @Option(help = \"Overrides CPUFeatures and uses the native architecture, i.e., the architecture of a machine that builds an image. NativeArchitecture takes precedence over CPUFeatures\", type = User)//\n     public static final HostedOptionKey<Boolean> NativeArchitecture = new HostedOptionKey<>(false);\n \n-    @Option(help = \"Define PageSize of a machine that runs the image. The default = 0 (== same as host machine page size)\")//\n-    protected static final HostedOptionKey<Integer> PageSize = new HostedOptionKey<>(0);\n-\n     @Option(help = \"Print information about classes, methods, and fields that are present in the native image\")//\n     public static final HostedOptionKey<Boolean> PrintUniverse = new HostedOptionKey<>(false);\n \n", "next_change": {"commit": "ecf7cad9f00d45e3f467d62d7c36d07a561cc906", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageOptions.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageOptions.java\nindex 2ae9cb8e22a..5bae0521750 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageOptions.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageOptions.java\n", "chunk": "@@ -56,6 +56,10 @@ public class NativeImageOptions {\n                     \"platform dependent. See --list-cpu-features for feature list.\", type = User)//\n     public static final HostedOptionKey<LocatableMultiOptionValue.Strings> CPUFeatures = new HostedOptionKey<>(new LocatableMultiOptionValue.Strings());\n \n+    @APIOption(name = \"list-cpu-features\")//\n+    @Option(help = \"Show CPU features specific to the target platform and exit.\", type = User)//\n+    public static final HostedOptionKey<Boolean> ListCPUFeatures = new HostedOptionKey<>(false);\n+\n     @Option(help = \"Overrides CPUFeatures and uses the native architecture, i.e., the architecture of a machine that builds an image. NativeArchitecture takes precedence over CPUFeatures\", type = User)//\n     public static final HostedOptionKey<Boolean> NativeArchitecture = new HostedOptionKey<>(false);\n \n", "next_change": {"commit": "28fc6f7c7043fa0f7fd9fbac490d9ac55b37adc9", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageOptions.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageOptions.java\nindex 5bae0521750..e5d42e731b6 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageOptions.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageOptions.java\n", "chunk": "@@ -60,6 +60,16 @@ public class NativeImageOptions {\n     @Option(help = \"Show CPU features specific to the target platform and exit.\", type = User)//\n     public static final HostedOptionKey<Boolean> ListCPUFeatures = new HostedOptionKey<>(false);\n \n+    @Option(help = \"Comma separated list of CPU features that will be dynamically enabled while \" +\n+                    \"building the target executable. 'Dynamically enabled' means that the code that \" +\n+                    \"uses certain features is guarded with a dynamic check whether they are supported \" +\n+                    \"by the hosted environment. If a feature is not supported, a fallback variant that \" +\n+                    \"adheres to CPUFeatures, will be executed. Because of this fallback code, enabling \" +\n+                    \"dynamic features can result in larger executables. To completely turn off dynamic \" +\n+                    \"CPU features, set this option to the empty string. The specific options available \" +\n+                    \"are target platform dependent. See --list-cpu-features for feature list. \", type = User)//\n+    public static final HostedOptionKey<LocatableMultiOptionValue.Strings> DynamicCPUFeatures = new HostedOptionKey<>(new LocatableMultiOptionValue.Strings());\n+\n     @Option(help = \"Overrides CPUFeatures and uses the native architecture, i.e., the architecture of a machine that builds an image. NativeArchitecture takes precedence over CPUFeatures\", type = User)//\n     public static final HostedOptionKey<Boolean> NativeArchitecture = new HostedOptionKey<>(false);\n \n", "next_change": {"commit": "f9070a8cac52be84e252801a1af01e4819bcc3aa", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageOptions.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageOptions.java\nindex e5d42e731b6..49a4abddaf5 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageOptions.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageOptions.java\n", "chunk": "@@ -60,15 +60,16 @@ public class NativeImageOptions {\n     @Option(help = \"Show CPU features specific to the target platform and exit.\", type = User)//\n     public static final HostedOptionKey<Boolean> ListCPUFeatures = new HostedOptionKey<>(false);\n \n-    @Option(help = \"Comma separated list of CPU features that will be dynamically enabled while \" +\n-                    \"building the target executable. 'Dynamically enabled' means that the code that \" +\n-                    \"uses certain features is guarded with a dynamic check whether they are supported \" +\n-                    \"by the hosted environment. If a feature is not supported, a fallback variant that \" +\n-                    \"adheres to CPUFeatures, will be executed. Because of this fallback code, enabling \" +\n-                    \"dynamic features can result in larger executables. To completely turn off dynamic \" +\n-                    \"CPU features, set this option to the empty string. The specific options available \" +\n-                    \"are target platform dependent. See --list-cpu-features for feature list. \", type = User)//\n-    public static final HostedOptionKey<LocatableMultiOptionValue.Strings> DynamicCPUFeatures = new HostedOptionKey<>(new LocatableMultiOptionValue.Strings());\n+    @Option(help = \"Comma separated list of CPU features that will be enabled for runtime checks. The \" +\n+                    \"native image may check at run time if such features are supported by the target \" +\n+                    \"CPU, and can optimize certain operations based on this information. If a feature \" +\n+                    \"is not supported at run time, a less optimized variant will be executed. Because of \" +\n+                    \"the presence of multiple code variants, enabling runtime features can result in \" +\n+                    \"larger executables. To completely turn off runtime checked CPU features, set this \" +\n+                    \"option to the empty string. The specific options available are target platform \" +\n+                    \"dependent. See --list-cpu-features for feature list. The default values are: \" +\n+                    \"AMD64: 'AVX,AVX2'; AArch64: ''\", type = User)//\n+    public static final HostedOptionKey<LocatableMultiOptionValue.Strings> RuntimeCheckedCPUFeatures = new HostedOptionKey<>(new LocatableMultiOptionValue.Strings());\n \n     @Option(help = \"Overrides CPUFeatures and uses the native architecture, i.e., the architecture of a machine that builds an image. NativeArchitecture takes precedence over CPUFeatures\", type = User)//\n     public static final HostedOptionKey<Boolean> NativeArchitecture = new HostedOptionKey<>(false);\n", "next_change": {"commit": "e665713fffc3429553f80161423972c33fb157ed", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageOptions.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageOptions.java\nindex 49a4abddaf5..087407fbb72 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageOptions.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageOptions.java\n", "chunk": "@@ -69,7 +68,7 @@ public class NativeImageOptions {\n                     \"option to the empty string. The specific options available are target platform \" +\n                     \"dependent. See --list-cpu-features for feature list. The default values are: \" +\n                     \"AMD64: 'AVX,AVX2'; AArch64: ''\", type = User)//\n-    public static final HostedOptionKey<LocatableMultiOptionValue.Strings> RuntimeCheckedCPUFeatures = new HostedOptionKey<>(new LocatableMultiOptionValue.Strings());\n+    public static final HostedOptionKey<LocatableMultiOptionValue.Strings> RuntimeCheckedCPUFeatures = new HostedOptionKey<>(LocatableMultiOptionValue.Strings.commaSeparated());\n \n     @Option(help = \"Overrides CPUFeatures and uses the native architecture, i.e., the architecture of a machine that builds an image. NativeArchitecture takes precedence over CPUFeatures\", type = User)//\n     public static final HostedOptionKey<Boolean> NativeArchitecture = new HostedOptionKey<>(false);\n", "next_change": {"commit": "a6ade3ff7ccaf657732a433f8c9db4ac59c92606", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageOptions.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageOptions.java\nindex 087407fbb72..03565b59cb0 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageOptions.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageOptions.java\n", "chunk": "@@ -68,7 +72,7 @@ public class NativeImageOptions {\n                     \"option to the empty string. The specific options available are target platform \" +\n                     \"dependent. See --list-cpu-features for feature list. The default values are: \" +\n                     \"AMD64: 'AVX,AVX2'; AArch64: ''\", type = User)//\n-    public static final HostedOptionKey<LocatableMultiOptionValue.Strings> RuntimeCheckedCPUFeatures = new HostedOptionKey<>(LocatableMultiOptionValue.Strings.commaSeparated());\n+    public static final HostedOptionKey<LocatableMultiOptionValue.Strings> RuntimeCheckedCPUFeatures = new HostedOptionKey<>(LocatableMultiOptionValue.Strings.buildWithCommaDelimiter());\n \n     @Option(help = \"Overrides CPUFeatures and uses the native architecture, i.e., the architecture of a machine that builds an image. NativeArchitecture takes precedence over CPUFeatures\", type = User)//\n     public static final HostedOptionKey<Boolean> NativeArchitecture = new HostedOptionKey<>(false);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU2Mjk5NQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r432562995", "body": "This and all other Red Hat copyright lines need to specify \"2020, 2020,\" as per the Oracle copyright line", "bodyText": "This and all other Red Hat copyright lines need to specify \"2020, 2020,\" as per the Oracle copyright line", "bodyHTML": "<p dir=\"auto\">This and all other Red Hat copyright lines need to specify \"2020, 2020,\" as per the Oracle copyright line</p>", "author": "adinn", "createdAt": "2020-05-29T15:27:57Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.", "originalCommit": "f3fb7861b5c0ca257b5893a8ec59164e78acaf9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk0ODAxMg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r438948012", "bodyText": "Done, for the contents of this PR.  Should I fix other Red Hat copyright lines?", "author": "stooke", "createdAt": "2020-06-11T17:23:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU2Mjk5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java\nindex a318f146e1d..5465da96716 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java\n", "chunk": "@@ -1,6 +1,6 @@\n /*\n  * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n  *\n  * This code is free software; you can redistribute it and/or modify it\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU2NDM4Mg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r432564382", "body": "I think this argument ought to be CV_SYMBOL_SECTION_NAME from class CVConstants", "bodyText": "I think this argument ought to be CV_SYMBOL_SECTION_NAME from class CVConstants", "bodyHTML": "<p dir=\"auto\">I think this argument ought to be CV_SYMBOL_SECTION_NAME from class CVConstants</p>", "author": "adinn", "createdAt": "2020-05-29T15:30:10Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+abstract class CVSectionImpl extends BasicProgbitsSectionImpl {\n+\n+    boolean debug = false;\n+    long debugTextBase = 0;\n+    long debugAddress = 0;\n+    int debugBase = 0;\n+\n+    CVSectionImpl() {\n+    }\n+\n+    @Override\n+    public void setElement(ObjectFile.Element e) {\n+        super.setElement(e);\n+        /* define the section as a COFF symbol */\n+        getOwner().createDefinedSymbol(getSectionName(), getElement(), 0, 0, false, false);\n+    }\n+\n+    private String debugSectionLogName() {\n+        /*\n+         * Use prefix cv4 plus the section name (which already includes a dot separator) for the\n+         * context key. For example messages for type section will be keyed using \"cv4.debug$T\".\n+         * Other info formats use their own format-specific prefix.\n+         */\n+        assert getSectionName().startsWith(\".debug$\");", "originalCommit": "f3fb7861b5c0ca257b5893a8ec59164e78acaf9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzIxNjY2OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r433216668", "bodyText": "Actually, it's just the prefix, because there are (at least) several section names used by CV4 (I currently implement only two - symbols and types).  I have added a prefix constant in CVConstants and will use it here.", "author": "stooke", "createdAt": "2020-06-01T12:55:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU2NDM4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzIzNTE4Mw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r433235183", "bodyText": "Ah yes, sorry. I missed the extra S at the end of CV_SYMBOL_SECTION_NAME and likewise CV_TYPE_SECTION_NAME ending with T. Adding a final static field for the prefix and using it here as well as to define the other symbols is a good idea.", "author": "adinn", "createdAt": "2020-06-01T13:31:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU2NDM4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java\nindex 2822fcf6842..a149e38c99c 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java\n", "chunk": "@@ -40,48 +39,29 @@ import java.util.Set;\n abstract class CVSectionImpl extends BasicProgbitsSectionImpl {\n \n     boolean debug = false;\n-    long debugTextBase = 0;\n-    long debugAddress = 0;\n-    int debugBase = 0;\n \n     CVSectionImpl() {\n     }\n \n-    @Override\n-    public void setElement(ObjectFile.Element e) {\n-        super.setElement(e);\n-        /* define the section as a COFF symbol */\n-        getOwner().createDefinedSymbol(getSectionName(), getElement(), 0, 0, false, false);\n-    }\n-\n     private String debugSectionLogName() {\n         /*\n-         * Use prefix cv4 plus the section name (which already includes a dot separator) for the\n-         * context key. For example messages for type section will be keyed using \"cv4.debug$T\".\n-         * Other info formats use their own format-specific prefix.\n+         * Log messages for the symbol section will be enabled using \"PeCoffdebug$S\". Log messages\n+         * for the type section will be enabled using \"PeCoffdebug$T\".\n          */\n-        assert getSectionName().startsWith(\".debug$\");\n+        assert getSectionName().startsWith(CVConstants.CV_SECTION_NAME_PREFIX);\n         return \"PeCoff\" + getSectionName().replace(\".\", \"\");\n     }\n \n-    protected void enableLog(DebugContext context, int pos) {\n+    protected void enableLog(DebugContext context) {\n         /*\n          * Unlike in the Dwarf debug code, debug output may be enabled in both the sizing and\n-         * writing phases. (Currently turned off in the sizing state) At this time, debugBase and\n-         * debugAddress aren't used but are there for the future.\n+         * writing phases. (Currently turned off in the sizing state)\n          */\n         if (context.areScopesEnabled()) {\n             debug = true;\n-            debugBase = pos;\n-            debugAddress = debugTextBase;\n         }\n     }\n \n-    @Override\n-    public int getAlignment() {\n-        return 1;\n-    }\n-\n     protected void log(DebugContext context, String format, Object... args) {\n         if (debug) {\n             context.logv(DebugContext.INFO_LEVEL, format, args);\n", "next_change": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java\nindex a149e38c99c..945111fc4c3 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java\n", "chunk": "@@ -52,25 +62,26 @@ abstract class CVSectionImpl extends BasicProgbitsSectionImpl {\n         return \"PeCoff\" + getSectionName().replace(\".\", \"\");\n     }\n \n-    protected void enableLog(DebugContext context) {\n+    protected void enableLog(DebugContext debugContext) {\n         /*\n          * Unlike in the Dwarf debug code, debug output may be enabled in both the sizing and\n          * writing phases. (Currently turned off in the sizing state)\n          */\n-        if (context.areScopesEnabled()) {\n+        cvDebugInfo.setDebugContext(debugContext);\n+        if (debugContext.areScopesEnabled()) {\n             debug = true;\n         }\n     }\n \n-    protected void log(DebugContext context, String format, Object... args) {\n+    protected void log(String format, Object... args) {\n         if (debug) {\n-            context.logv(DebugContext.INFO_LEVEL, format, args);\n+            getDebugContext().logv(DebugContext.INFO_LEVEL, format, args);\n         }\n     }\n \n-    protected void verboseLog(DebugContext context, String format, Object... args) {\n+    protected void verboseLog(String format, Object... args) {\n         if (debug) {\n-            context.logv(DebugContext.VERBOSE_LEVEL, format, args);\n+            getDebugContext().logv(DebugContext.VERBOSE_LEVEL, format, args);\n         }\n     }\n \n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU2NTI3Mw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r432565273", "body": "This is not called so ought to be deleted", "bodyText": "This is not called so ought to be deleted", "bodyHTML": "<p dir=\"auto\">This is not called so ought to be deleted</p>", "author": "adinn", "createdAt": "2020-05-29T15:31:38Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVStringTableRecord.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import java.io.PrintStream;\n+\n+final class CVStringTableRecord extends CVSymbolRecord {\n+\n+    private final CVSymbolSectionImpl.CVStringTable stringTable;\n+\n+    CVStringTableRecord(CVDebugInfo cvDebugInfo, CVSymbolSectionImpl.CVStringTable stringTable) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_STRINGTABLE);\n+        this.stringTable = stringTable;\n+    }\n+\n+    int add(String string) {\n+        return stringTable.add(string);\n+    }\n+\n+    @Override\n+    public int computeSize(int pos) {\n+        return computeContents(null, pos);\n+    }\n+\n+    @Override\n+    public int computeContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        for (CVSymbolSectionImpl.CVStringTable.StringTableEntry entry : stringTable.values()) {\n+            pos = CVUtil.putUTF8StringBytes(entry.text, buffer, pos);\n+        }\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVStringTableRecord(type=0x%04x pos=0x%06x count=%d)\", type, recordStartPosition, stringTable.size());\n+    }\n+\n+    public void dump(PrintStream out) {", "originalCommit": "f3fb7861b5c0ca257b5893a8ec59164e78acaf9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4MDYxOQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r438980619", "bodyText": "Unclear if this comments refers to dump() or toString(); I've assumed the former and deleted it.", "author": "stooke", "createdAt": "2020-06-11T18:13:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU2NTI3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVStringTableRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVStringTableRecord.java\nindex 5824d28de87..d0fa57c82c0 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVStringTableRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVStringTableRecord.java\n", "chunk": "@@ -59,13 +53,4 @@ final class CVStringTableRecord extends CVSymbolRecord {\n     public String toString() {\n         return String.format(\"CVStringTableRecord(type=0x%04x pos=0x%06x count=%d)\", type, recordStartPosition, stringTable.size());\n     }\n-\n-    public void dump(PrintStream out) {\n-        int idx = 0;\n-        out.format(\"%s:\\n\", this);\n-        for (CVSymbolSectionImpl.CVStringTable.StringTableEntry entry : stringTable.values()) {\n-            out.format(\"%4d 0x%08x %s\\n\", idx, entry.offset, entry.text);\n-            idx += 1;\n-        }\n-    }\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU3Njc1NA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r432576754", "body": "If you pass the debugContext either to the constructor or the build method you can make this debug method do some useful logging. If not then you need to remove it and the debug calls.", "bodyText": "If you pass the debugContext either to the constructor or the build method you can make this debug method do some useful logging. If not then you need to remove it and the debug calls.", "bodyHTML": "<p dir=\"auto\">If you pass the debugContext either to the constructor or the build method you can make this debug method do some useful logging. If not then you need to remove it and the debug calls.</p>", "author": "adinn", "createdAt": "2020-05-29T15:50:34Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+\n+public class CVLineRecordBuilder {\n+\n+    private static final boolean HAS_COLUMNS = false;\n+\n+    private CVDebugInfo cvDebugInfo;\n+    private CVLineRecord lineRecord;\n+    private PrimaryEntry primaryEntry;\n+\n+    CVLineRecordBuilder(CVDebugInfo cvDebugInfo) {\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    public static void debug(@SuppressWarnings(\"unused\") String format, @SuppressWarnings(\"unused\") Object... args) {", "originalCommit": "f3fb7861b5c0ca257b5893a8ec59164e78acaf9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI2MzU2NQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r433263565", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-06-01T14:21:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU3Njc1NA=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\nindex 955c882d137..1156522fb8e 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n", "chunk": "@@ -26,152 +26,84 @@\n \n package com.oracle.objectfile.pecoff.cv;\n \n+import org.graalvm.compiler.debug.DebugContext;\n import com.oracle.objectfile.debugentry.FileEntry;\n import com.oracle.objectfile.debugentry.PrimaryEntry;\n import com.oracle.objectfile.debugentry.Range;\n \n+/*\n+ * In CV4, the line table consists of a series of file headers followed by line number entries.\n+ * If this is a different file, then update the length of the previous file header, write the\n+ * new file header and write the new range At the very end, make sure we update the last file header.\n+ */\n public class CVLineRecordBuilder {\n \n-    private static final boolean HAS_COLUMNS = false;\n-\n     private CVDebugInfo cvDebugInfo;\n+    private DebugContext debugContext;\n     private CVLineRecord lineRecord;\n     private PrimaryEntry primaryEntry;\n \n-    CVLineRecordBuilder(CVDebugInfo cvDebugInfo) {\n+    CVLineRecordBuilder(DebugContext theDebugContext, CVDebugInfo cvDebugInfo) {\n+        this.debugContext = theDebugContext;\n         this.cvDebugInfo = cvDebugInfo;\n     }\n \n-    public static void debug(@SuppressWarnings(\"unused\") String format, @SuppressWarnings(\"unused\") Object... args) {\n-        // System.out.format(format, args);\n+    public void debug(String format, Object... args) {\n+        cvDebugInfo.getCVSymbolSection().verboseLog(debugContext, format, args);\n     }\n \n-    /*\n-     * In CV4, the line table consists of a series of file headers followed by line number entries\n-     * to handle this, first we decide if we want to merge this with the previous range (only if\n-     * same file and start of this range is end of previous range) if we are emitting a new range to\n-     * the same file, write the range, save it as the previous range and go on If this is a\n-     * different file, then update the length of the previous file header, write the new file header\n-     * and write the new range At the very end, make sure we update the last file header.\n-     *\n-     * In addition, optionally ignore Ranges that point into Graal innards, just adding them to the\n-     * current enclosing range\n-     */\n-\n     /**\n      * Build line number records for a function.\n      *\n      * @param entry function to build line number table for\n      * @return CVLineRecord containing any entries generated, or null if no entries generated\n      */\n-    @SuppressWarnings(\"unused\")\n-    CVLineRecord build(PrimaryEntry entry, String methodName) {\n-        // long lowAddr = Long.MAX_VALUE;\n-        // long highAddr = 0;\n+    CVLineRecord build(PrimaryEntry entry) {\n         this.primaryEntry = entry;\n-\n-        assert (!HAS_COLUMNS); /* can't handle columns yet */\n-\n         Range primaryRange = primaryEntry.getPrimary();\n-        Range previousRange = null;\n \n         debug(\"DEBUG_S_LINES linerecord for 0x%05x file: %s:%d\\n\", primaryRange.getLo(), primaryRange.getFileName(), primaryRange.getLine());\n-        this.lineRecord = new CVLineRecord(cvDebugInfo, methodName, primaryEntry);\n+        this.lineRecord = new CVLineRecord(cvDebugInfo, primaryRange.getSymbolName());\n         debug(\"CVLineRecord.computeContents: processing primary range %s\\n\", primaryRange);\n-        previousRange = processRange(primaryRange, previousRange);\n-        // lowAddr = Math.min(lowAddr, primaryRange.getLo());\n-        // highAddr = Math.max(highAddr, primaryRange.getHi());\n \n+        processRange(primaryRange);\n         for (Range subRange : primaryEntry.getSubranges()) {\n             debug(\"CVLineRecord.computeContents: processing range %s\\n\", subRange);\n-            FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subRange);\n-            if (subFileEntry == null) {\n-                continue;\n-            }\n-            previousRange = processRange(subRange, previousRange);\n-            // lowAddr = Math.min(lowAddr, subRange.getLo());\n-            // highAddr = Math.max(highAddr, subRange.getHi());\n+            processRange(subRange);\n         }\n         return lineRecord;\n     }\n \n     /**\n      * Merge input Range structures into line number table. The Range structures are assumed to be\n-     * ordered by ascending address merge with previous line entry if: - if a Range has a negative\n-     * linenumber - if a range is part of Graal or the JDK, and skipGraalOption is true - if a range\n-     * has the same line number, source file and function\n+     * ordered by ascending address.\n      *\n      * @param range to be merged or added to line number record\n-     * @param oldPreviousRange the previously processed Range\n-     * @return new value for previousRange in caller\n      */\n-    private Range processRange(Range range, Range oldPreviousRange) {\n-\n-        Range previousRange = oldPreviousRange;\n+    private void processRange(Range range) {\n \n-        if (range.getLine() == -1) {\n-            debug(\"     processRange: ignoring: bad line number\\n\");\n-            return previousRange;\n+        FileEntry file = cvDebugInfo.findFile(range.getFileAsPath());\n+        if (file == null) {\n+            debug(\"processRange: range has no file: %s\\n\", range);\n+            return;\n         }\n \n-        /* is this a new file? if so we emit a new file record */\n-        boolean wantNewFile = previousRange == null || !previousRange.getFileAsPath().equals(range.getFileAsPath());\n-        if (wantNewFile) {\n-            FileEntry file = cvDebugInfo.findFile(range.getFileAsPath());\n-            if (file != null && file.getFileName() != null) {\n-                previousRange = null;\n-                debug(\"processRange: addNewFile: %s\\n\", file);\n-                lineRecord.addNewFile(file);\n-            } else {\n-                debug(\"processRange: range has no file: %s\\n\", range);\n-                return previousRange;\n-            }\n+        if (range.getLine() == -1) {\n+            debug(\"processRange: ignoring: bad line number\\n\");\n+            return;\n         }\n \n-        if (wantNewRange(range, previousRange)) {\n-            previousRange = range;\n-            int lineLoAddr = range.getLo() - primaryEntry.getPrimary().getLo();\n-            int line = Math.max(range.getLine(), 1);\n-            debug(\"processRange:   addNewLine: 0x%05x %s\\n\", lineLoAddr, line);\n-            lineRecord.addNewLine(lineLoAddr, line);\n+        int fileId = cvDebugInfo.getCVSymbolSection().getFileTableRecord().addFile(file);\n+        if (lineRecord.isEmpty() || lineRecord.getCurrentFileId() != fileId) {\n+            debug(\"processRange: addNewFile: %s\\n\", file);\n+            lineRecord.addNewFile(fileId);\n         }\n-        return previousRange;\n-    }\n \n-    /**\n-     * Test to see if a new line record should be emitted.\n-     *\n-     * @param previousRange previous range\n-     * @param range current range\n-     * @return true if the current range is on a different line or file from the previous one\n-     */\n-    private static boolean wantNewRange(@SuppressWarnings(\"unused\") Range range, @SuppressWarnings(\"unused\") Range previousRange) {\n-        /* return true for now; this will be a further optimization (see unused_wantNewRange) */\n-        return true;\n-    }\n-\n-    /**\n-     * Test to see if a new line record should be emitted.\n-     *\n-     * @param previousRange previous range\n-     * @param range current range\n-     * @return true if the current range is on a different line or file from the previous one\n-     */\n-    @SuppressWarnings(\"unused\")\n-    private static boolean unusedWantNewRange(@SuppressWarnings(\"unused\") Range range, @SuppressWarnings(\"unused\") Range previousRange) {\n-        if (previousRange == null) {\n-            return true;\n-        }\n-        if (previousRange.getLine() != range.getLine()) {\n-            return true;\n-        }\n-        if (previousRange.getFilePath() != range.getFilePath()) {\n-            return true;\n-        }\n-        /* it might actually be fine to merge if there's a gap between ranges */\n-        // if (previousRange.getHi() < range.getLo()) {\n-        // return true;\n-        // }\n-        return false;\n+        /* Add line record. */\n+        /* An optimization would be to merge adjacent line records. */\n+        int lineLoAddr = range.getLo() - primaryEntry.getPrimary().getLo();\n+        int line = Math.max(range.getLine(), 1);\n+        debug(\"processRange:   addNewLine: 0x%05x %s\\n\", lineLoAddr, line);\n+        lineRecord.addNewLine(lineLoAddr, line);\n     }\n }\n", "next_change": {"commit": "6d209109480ecec08ebf137288371d4c56064ba0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\nindex 1156522fb8e..2e83cf343d2 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n", "chunk": "@@ -103,7 +104,7 @@ public class CVLineRecordBuilder {\n         /* An optimization would be to merge adjacent line records. */\n         int lineLoAddr = range.getLo() - primaryEntry.getPrimary().getLo();\n         int line = Math.max(range.getLine(), 1);\n-        debug(\"processRange:   addNewLine: 0x%05x %s\\n\", lineLoAddr, line);\n+        debug(\"  processRange:   addNewLine: 0x%05x-0x%05x %s\", lineLoAddr, range.getLo() - primaryEntry.getPrimary().getHi(), line);\n         lineRecord.addNewLine(lineLoAddr, line);\n     }\n }\n", "next_change": {"commit": "20496a00704b8c5b6445a353f1bd114181ae7d91", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\nindex 2e83cf343d2..714f0194fc8 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n", "chunk": "@@ -101,10 +101,9 @@ public class CVLineRecordBuilder {\n         }\n \n         /* Add line record. */\n-        /* An optimization would be to merge adjacent line records. */\n         int lineLoAddr = range.getLo() - primaryEntry.getPrimary().getLo();\n         int line = Math.max(range.getLine(), 1);\n-        debug(\"  processRange:   addNewLine: 0x%05x-0x%05x %s\", lineLoAddr, range.getLo() - primaryEntry.getPrimary().getHi(), line);\n+        debug(\"  processRange:   addNewLine: 0x%05x-0x%05x %s\", lineLoAddr, range.getHi() - primaryEntry.getPrimary().getLo(), line);\n         lineRecord.addNewLine(lineLoAddr, line);\n     }\n }\n", "next_change": {"commit": "4caf93deee510084247c88599752478fc53bd73d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\nindex 714f0194fc8..34598cf5e9f 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n", "chunk": "@@ -101,9 +101,9 @@ public class CVLineRecordBuilder {\n         }\n \n         /* Add line record. */\n-        int lineLoAddr = range.getLo() - primaryEntry.getPrimary().getLo();\n+        int lineLoAddr = range.getLo() - compiledEntry.getPrimary().getLo();\n         int line = Math.max(range.getLine(), 1);\n-        debug(\"  processRange:   addNewLine: 0x%05x-0x%05x %s\", lineLoAddr, range.getHi() - primaryEntry.getPrimary().getLo(), line);\n+        debug(\"  processRange:   addNewLine: 0x%05x-0x%05x %s\", lineLoAddr, range.getHi() - compiledEntry.getPrimary().getLo(), line);\n         lineRecord.addNewLine(lineLoAddr, line);\n     }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4MDQ4NQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r432580485", "body": "Same thing here with this debug call. If you pass the DebugContext to the builder constructor or build method then you can actually generate debug trace. If not then delete the comments.", "bodyText": "Same thing here with this debug call. If you pass the DebugContext to the builder constructor or build method then you can actually generate debug trace. If not then delete the comments.", "bodyHTML": "<p dir=\"auto\">Same thing here with this debug call. If you pass the DebugContext to the builder constructor or build method then you can actually generate debug trace. If not then delete the comments.</p>", "author": "adinn", "createdAt": "2020-05-29T15:55:15Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolRecordBuilder.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.functionNamesHashArgs;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.replaceMainFunctionName;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.emitUnadornedMain;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_NOTYPE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_VOID;\n+\n+final class CVSymbolRecordBuilder {\n+\n+    private final CVDebugInfo cvDebugInfo;\n+    private final CVSymbolSubsection symbolRecord;\n+    @SuppressWarnings(\"unused\") private DebugContext debugContext = null;\n+\n+    CVSymbolRecordBuilder(CVDebugInfo cvDebugInfo) {\n+        this.symbolRecord = new CVSymbolSubsection(cvDebugInfo);\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    /**\n+     * build DEBUG_S_SYMBOLS record from all classEntries. (could probably build one per class or\n+     * one per function)\n+     */\n+    void build(DebugContext theDebugContext) {\n+        this.debugContext = theDebugContext;\n+        for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+            build(classEntry);\n+        }\n+        cvDebugInfo.getCVSymbolSection().addRecord(symbolRecord);\n+    }\n+\n+    /**\n+     * build all debug info for a classEntry. (does not yet handle member variables)\n+     *\n+     * @param classEntry current class\n+     */\n+    private void build(ClassEntry classEntry) {\n+        String previousMethodName = \"\";\n+        for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+            Range primaryRange = primaryEntry.getPrimary();\n+            if (primaryRange.getFileName() != null) {\n+                // for each function\n+                String newMethodName = fixMethodName(primaryRange);\n+                if (!newMethodName.equals(previousMethodName)) {\n+                    previousMethodName = newMethodName;\n+                    build(primaryEntry, newMethodName);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * emit records for each function: PROC32 S_FRAMEPROC S_END and line number records. (later:\n+     * type records as required)\n+     *\n+     * @param primaryEntry primary entry for this function\n+     * @param methodName method name alias as it will be seen by the user\n+     */\n+    private void build(PrimaryEntry primaryEntry, String methodName) {\n+        final Range primaryRange = primaryEntry.getPrimary();\n+        // debug(\"addfunc(\" + methodName + \") numtypes = %d\\n\",", "originalCommit": "f3fb7861b5c0ca257b5893a8ec59164e78acaf9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4MDUzMw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r438980533", "bodyText": "I deleted these commented out logging statements.", "author": "stooke", "createdAt": "2020-06-11T18:13:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4MDQ4NQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4NDU0Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r432584547", "body": "There is no point calling verboseLog when you have set debug = false directly above.\r\n\r\nn.b. In the ELF create/writeContent methods that field stops shared utility methods logging data at both createContent and writeContent time. But your create/write methods just cut and pastes the same inline code. So, you should either omit the log call under createContent or put the common code into a utility method called from both.", "bodyText": "There is no point calling verboseLog when you have set debug = false directly above.\nn.b. In the ELF create/writeContent methods that field stops shared utility methods logging data at both createContent and writeContent time. But your create/write methods just cut and pastes the same inline code. So, you should either omit the log call under createContent or put the common code into a utility method called from both.", "bodyHTML": "<p dir=\"auto\">There is no point calling verboseLog when you have set debug = false directly above.</p>\n<p dir=\"auto\">n.b. In the ELF create/writeContent methods that field stops shared utility methods logging data at both createContent and writeContent time. But your create/write methods just cut and pastes the same inline code. So, you should either omit the log call under createContent or put the common code into a utility method called from both.</p>", "author": "adinn", "createdAt": "2020-05-29T16:01:54Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SIGNATURE_C13;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SYMBOL_SECTION_NAME;\n+\n+public final class CVSymbolSectionImpl extends CVSectionImpl {\n+\n+    private static final int CV_VECTOR_DEFAULT_SIZE = 200;\n+    private static final int CV_STRINGTABLE_DEFAULT_SIZE = 200;\n+\n+    private CVDebugInfo cvDebugInfo;\n+    private CVFileRecord fileRecord;\n+\n+    private ArrayList<CVSymbolRecord> cvRecords = new ArrayList<>(CV_VECTOR_DEFAULT_SIZE);\n+    private CVStringTable stringTable = new CVStringTable(CV_STRINGTABLE_DEFAULT_SIZE);\n+\n+    CVSymbolSectionImpl(CVDebugInfo cvDebugInfo) {\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    @Override\n+    public String getSectionName() {\n+        return CV_SYMBOL_SECTION_NAME;\n+    }\n+\n+    /*\n+     * the CodeView symbol section (\"debug$S\") is actually a list of records containing sub-records\n+     */\n+    @Override\n+    public void createContent(DebugContext debugContext) {\n+        int pos = 0;\n+        // enableLog(debugContext, pos);\n+        debug = false;\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() adding records\");\n+        addRecords(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() start\");\n+        /* add header size */\n+        pos += Integer.BYTES;\n+        /* add sum of all record sizes */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            verboseLog(debugContext, \"  [0x%08x] %s\", pos, record.toString());", "originalCommit": "f3fb7861b5c0ca257b5893a8ec59164e78acaf9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk3NzIxNA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r438977214", "bodyText": "the variable 'debug' can be unset at development time; some decisions are made then, so I need a way to see what's happening while working on this code. Logging in createContent() is uninteresting to the end user, but very interesting to the developer.  I've cleaned it up a bit, and I'm open to suggestions that allow me to turn logging during the createContent() phase on and off, but I'm going to need to log this phase until the type information code has been added.", "author": "stooke", "createdAt": "2020-06-11T18:06:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4NDU0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE2MzY3MQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r440163671", "bodyText": "Well, logging stuff of interest only to the developer is part of what the debug context code is meant to do. That's why it supports a hierarchical naming scheme for identifying the context. If I want to enable debug during content creation I pass\n-H:Log=DebugCodeInfo:3 -Dgraal.LogFile=$PWD/out.log\n\nLevel 3 enables verbose logging. Keyword DebugCodeInfo matches every log context created under the call to installDebugInfo. If I only wanted log output for processing a specific method I could append the specific method name to the installDebugInfo keyword (with '.' separator).", "author": "adinn", "createdAt": "2020-06-15T13:10:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4NDU0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE2Nzg4Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r444167887", "bodyText": "I've simplified the log enablement code to be entirely controlled by the debugContext, and if finer-grained control over loggin ends up being required, will ensure it only uses that mechanism, not compile-time contants.", "author": "stooke", "createdAt": "2020-06-23T11:58:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4NDU0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\nindex ae3fe107d8b..ecf1a17c870 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n", "chunk": "@@ -59,25 +61,24 @@ public final class CVSymbolSectionImpl extends CVSectionImpl {\n     }\n \n     /*\n-     * the CodeView symbol section (\"debug$S\") is actually a list of records containing sub-records\n+     * Any (there may be sewveral) CodeView symbol section (\"debug$S\") is actually a list of\n+     * records, some of which containing sub-records.\n      */\n     @Override\n     public void createContent(DebugContext debugContext) {\n         int pos = 0;\n-        // enableLog(debugContext, pos);\n-        debug = false;\n+        enableLog(debugContext);\n         log(debugContext, \"CVSymbolSectionImpl.createContent() adding records\");\n         addRecords(debugContext);\n         log(debugContext, \"CVSymbolSectionImpl.createContent() start\");\n-        /* add header size */\n+        /* Add header size. */\n         pos += Integer.BYTES;\n-        /* add sum of all record sizes */\n+        /* Add sum of all record sizes. */\n         for (CVSymbolRecord record : cvRecords) {\n             pos = CVUtil.align4(pos);\n-            verboseLog(debugContext, \"  [0x%08x] %s\", pos, record.toString());\n             pos = record.computeFullSize(pos);\n         }\n-        /* create a buffer that holds it all */\n+        /* Create a buffer that holds it all. */\n         byte[] buffer = new byte[pos];\n         super.setContent(buffer);\n         log(debugContext, \"CVSymbolSectionImpl.createContent() end\");\n", "next_change": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\nindex ecf1a17c870..694e3bf7c7d 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n", "chunk": "@@ -81,49 +81,49 @@ public final class CVSymbolSectionImpl extends CVSectionImpl {\n         /* Create a buffer that holds it all. */\n         byte[] buffer = new byte[pos];\n         super.setContent(buffer);\n-        log(debugContext, \"CVSymbolSectionImpl.createContent() end\");\n+        log(\"CVSymbolSectionImpl.createContent() end\");\n     }\n \n     @Override\n     public void writeContent(DebugContext debugContext) {\n         int pos = 0;\n         enableLog(debugContext);\n-        log(debugContext, \"CVSymbolSectionImpl.writeContent() start recordcount=%d\", cvRecords.size());\n+        log(\"CVSymbolSectionImpl.writeContent() start recordcount=%d\", cvRecords.size());\n         byte[] buffer = getContent();\n         /* Write section header. */\n-        log(debugContext, \"  [0x%08x] CV_SIGNATURE_C13\", pos);\n+        log(\"  [0x%08x] CV_SIGNATURE_C13\", pos);\n         pos = CVUtil.putInt(CV_SIGNATURE_C13, buffer, pos);\n         /* Write all records. */\n         for (CVSymbolRecord record : cvRecords) {\n             pos = CVUtil.align4(pos);\n-            log(debugContext, \"  [0x%08x] %s\", pos, record.toString());\n+            log(\"  [0x%08x] %s\", pos, record.toString());\n             record.logContents(debugContext);\n             pos = record.computeFullContents(buffer, pos);\n         }\n-        log(debugContext, \"CVSymbolSectionImpl.writeContent() end\");\n+        log(\"CVSymbolSectionImpl.writeContent() end\");\n     }\n \n-    private void addRecords(DebugContext debugContext) {\n+    private void addRecords() {\n         addPrologueRecord();\n-        addFunctionRecords(debugContext);\n+        addFunctionRecords();\n         addFileRecord();\n         addStringTableRecord();\n     }\n \n     private void addPrologueRecord() {\n-        CVSymbolSubsection prologue = new CVSymbolSubsection(cvDebugInfo);\n-        CVSymbolSubrecord.CVObjectNameRecord objectNameRecord = new CVSymbolSubrecord.CVObjectNameRecord(cvDebugInfo);\n+        CVSymbolSubsection prologue = new CVSymbolSubsection(getCvDebugInfo());\n+        CVSymbolSubrecord.CVObjectNameRecord objectNameRecord = new CVSymbolSubrecord.CVObjectNameRecord(getCvDebugInfo());\n         if (objectNameRecord.isValid()) {\n             prologue.addRecord(objectNameRecord);\n         }\n-        prologue.addRecord(new CVSymbolSubrecord.CVCompile3Record(cvDebugInfo));\n-        prologue.addRecord(new CVSymbolSubrecord.CVEnvBlockRecord(cvDebugInfo));\n+        prologue.addRecord(new CVSymbolSubrecord.CVCompile3Record(getCvDebugInfo()));\n+        prologue.addRecord(new CVSymbolSubrecord.CVEnvBlockRecord(getCvDebugInfo()));\n         addRecord(prologue);\n     }\n \n-    private void addFunctionRecords(DebugContext debugContext) {\n+    private void addFunctionRecords() {\n         /* This will build and add many records for each function. */\n-        new CVSymbolSubsectionBuilder(cvDebugInfo).build(debugContext);\n+        new CVSymbolSubsectionBuilder(getCvDebugInfo()).build();\n     }\n \n     private void addFileRecord() {\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4NjU1MQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r432586551", "body": "Is there really a need for this? If not delete it. If so the maybe mark it as unused because the commented out code won't pass the style formatter without getting munged into a syntactic mess.", "bodyText": "Is there really a need for this? If not delete it. If so the maybe mark it as unused because the commented out code won't pass the style formatter without getting munged into a syntactic mess.", "bodyHTML": "<p dir=\"auto\">Is there really a need for this? If not delete it. If so the maybe mark it as unused because the commented out code won't pass the style formatter without getting munged into a syntactic mess.</p>", "author": "adinn", "createdAt": "2020-05-29T16:05:26Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,648 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.subrecordStartPosition = initialPos;\n+        int prologueLength = Short.BYTES * 2; /* room for length and subcommand */\n+        return computeSize(initialPos + prologueLength);\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* save room for length (no including length bytes) */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(cmd=0x%04x pos=0x%06x)\", cmd, subrecordStartPosition);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeSize(int pos);\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* TODO: how to find the full path to object file we will produce */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Get file from first class object */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            int pos = initialPos + Integer.BYTES; /* signature = 0; */\n+            pos += objName.getBytes(UTF_8).length + 1; /* inline null terminated */\n+            return pos;\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* signature = 0 */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos); /* inline null terminated */\n+            return pos;\n+        }\n+    }\n+\n+    public static final class CVCompile3Record extends CVSymbolSubrecord {\n+\n+        private static final byte HAS_DEBUG_FLAG = 0;\n+        // private static final byte HAS_NO_DEBUG_FLAG = (byte)0x80;\n+\n+        private byte language;\n+        private byte cf1;\n+        private byte cf2;\n+        private byte padding;\n+        private short machine;\n+        private short feMajor;\n+        private short feMinor;\n+        private short feBuild;\n+        private short feQFE;\n+        private short beMajor;\n+        private short beMinor;\n+        private short beBuild;\n+        private short beQFE;\n+        private String compiler;\n+\n+        CVCompile3Record(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_COMPILE3);\n+            language = 0;\n+            cf1 = HAS_DEBUG_FLAG;\n+            cf2 = (byte) 0;\n+            padding = (byte) 0;\n+            machine = (short) 208;\n+            feMajor = (short) 2;\n+            feMinor = (short) 3;\n+            feBuild = (short) 4;\n+            feQFE = (short) 5;\n+            beMajor = (short) 6;\n+            beMinor = (short) 7;\n+            beBuild = (short) 8;\n+            beQFE = (short) 9;\n+            compiler = \"graal\";\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putByte(language, buffer, initialPos);\n+            pos = CVUtil.putByte(cf1, buffer, pos);\n+            pos = CVUtil.putByte(cf2, buffer, pos);\n+            pos = CVUtil.putByte(padding, buffer, pos);\n+            pos = CVUtil.putShort(machine, buffer, pos);\n+            pos = CVUtil.putShort(feMajor, buffer, pos);\n+            pos = CVUtil.putShort(feMinor, buffer, pos);\n+            pos = CVUtil.putShort(feBuild, buffer, pos);\n+            pos = CVUtil.putShort(feQFE, buffer, pos);\n+            pos = CVUtil.putShort(beMajor, buffer, pos);\n+            pos = CVUtil.putShort(beMinor, buffer, pos);\n+            pos = CVUtil.putShort(beBuild, buffer, pos);\n+            pos = CVUtil.putShort(beQFE, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(compiler, buffer, pos);  // inline null terminated\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_COMPILE3 machine=%d fe=%d.%d.%d.%d be=%d.%d.%d%d compiler=%s\", machine, feMajor, feMinor, feBuild, feQFE, beMajor, beMinor, beBuild, beQFE, compiler);\n+        }\n+    }\n+\n+    public static final class CVEnvBlockRecord extends CVSymbolSubrecord {\n+\n+        private static final int ENVMAP_INITIAL_CAPACITY = 10;\n+\n+        private Map<String, String> map = new HashMap<>(ENVMAP_INITIAL_CAPACITY);\n+\n+        /*-\n+         * Example contents of the environment block:\n+         *   cwd = C:\\tmp\\graal-8\n+         *   cl = C:\\tmp\\graal-8\\ojdkbuild\\tools\\toolchain\\vs2010e\\VC\\Bin\\x86_amd64\\cl.exe\n+         *   cmd = -Zi -MT -IC:\\tmp\\graal-8\\tools\\toolchain\\vs2010e\\VC\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE\\gl -TC -X\n+         *   src = helloworld.c\n+         *   pdb = C:\\tmp\\graal-8\\vc100.pdb\n+         */\n+        CVEnvBlockRecord(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_ENVBLOCK);\n+\n+            /* current directory */\n+            map.put(\"cwd\", System.getProperty(\"user.dir\"));\n+\n+            /* compiler executable */\n+            // map.put(\"cl\", \"cl.exe\");\n+\n+            /* argument list */\n+            // map.put(\"cmd\", \"-Zi -MT -wishfulthinking\");\n+\n+            /*\n+             * find first source file - which, for Graal would be a class file on the command line\n+             */\n+            String fn = findFirstFile(cvDebugInfo);\n+            if (fn != null) {\n+                map.put(\"src\", fn);\n+            }\n+\n+            /* Graal doesn't yet create PDB files; all type info is stored in object file */\n+            // map.put(\"pdb\", System.getProperty(\"user.dir\") + File.separator + \"vc100.pdb\");\n+        }\n+\n+        private static String findFirstFile(CVDebugInfo cvDebugInfo) {\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            /* flags */\n+            int pos = CVUtil.putByte((byte) 0, buffer, initialPos);\n+\n+            /* key/value pairs */\n+            for (Map.Entry<String, String> entry : map.entrySet()) {\n+                pos = CVUtil.putUTF8StringBytes(entry.getKey(), buffer, pos);\n+                pos = CVUtil.putUTF8StringBytes(entry.getValue(), buffer, pos);\n+            }\n+\n+            /* end marker */\n+            pos = CVUtil.putUTF8StringBytes(\"\", buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"S_ENVBLOCK \" + map.size() + \" entries\";\n+        }\n+    }\n+\n+    /*\n+     * creating a proc32 record has side effects. - a global symbol is added to the COFF symbol\n+     * section - two relocation entries are added to the section relocation table, they refer to the\n+     * global symbol\n+     */\n+    public static class CVSymbolGProc32Record extends CVSymbolSubrecord {\n+\n+        private static ObjectFile.Element textSection;\n+\n+        int pparent;\n+        int pend;\n+        int pnext;\n+        int proclen;\n+        int debugStart;\n+        int debugEnd;\n+        int typeIndex;\n+        int offset;\n+        short segment;\n+        byte flags;\n+        String name;\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, short cmd, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment,\n+                        byte flags) {\n+            super(cvDebugInfo, cmd);\n+            this.name = name;\n+            this.pparent = pparent;\n+            this.pend = pend;\n+            this.pnext = pnext;\n+            this.proclen = proclen;\n+            this.debugStart = debugStart;\n+            this.debugEnd = debugEnd;\n+            this.typeIndex = typeIndex;\n+            this.offset = offset;\n+            this.segment = segment;\n+            this.flags = flags;\n+        }\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment, byte flags) {\n+            this(cvDebugInfo, CVDebugConstants.S_GPROC32, name, pparent, pend, pnext, proclen, debugStart, debugEnd, typeIndex, offset, segment, flags);\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(pparent, buffer, initialPos);\n+            pos = CVUtil.putInt(pend, buffer, pos);\n+            pos = CVUtil.putInt(pnext, buffer, pos);\n+            pos = CVUtil.putInt(proclen, buffer, pos);\n+            pos = CVUtil.putInt(debugStart, buffer, pos);\n+            pos = CVUtil.putInt(debugEnd, buffer, pos);\n+            pos = CVUtil.putInt(typeIndex, buffer, pos);\n+            if (buffer == null) {\n+                cvDebugInfo.getCVSymbolSection().getOwner().createDefinedSymbol(name, getTextSection(), offset, proclen, true, true);\n+            }\n+            if (buffer != null) {\n+                // CVUtil.debug(\"CVSymbolGProc32Record() adding SECREL reloc at pos=0x%x for func=%s\n+                // addr=0x%x\\n\", pos, name, offset);\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 4, ObjectFile.RelocationKind.SECREL, name, false, 1L);\n+            }\n+            pos = CVUtil.putInt(0, buffer, pos);\n+            if (buffer != null) {\n+                // CVUtil.debug(\"CVSymbolGProc32Record() adding SECTION reloc at pos=0x%x for\n+                // func=%s addr=0x%x\\n\", pos, name, offset);\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 2, ObjectFile.RelocationKind.SECTION, name, false, 1L);\n+            }\n+            pos = CVUtil.putShort((short) 0, buffer, pos);\n+            pos = CVUtil.putByte(flags, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(name, buffer, pos);\n+            return pos;\n+        }\n+\n+        private ObjectFile.Element getTextSection() {\n+            if (textSection == null) {\n+                textSection = cvDebugInfo.getCVSymbolSection().getOwner().elementForName(SectionName.TEXT.getFormatDependentName(ObjectFile.Format.PECOFF));\n+            }\n+            return textSection;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            cvDebugInfo.getCVSymbolSection().debugAddress = offset;\n+            return String.format(\"S_GPROC32   name=%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", name, pparent, debugStart, debugEnd, proclen, offset,\n+                            typeIndex,\n+                            flags);\n+        }\n+    }\n+\n+    /*-", "originalCommit": "f3fb7861b5c0ca257b5893a8ec59164e78acaf9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI3NjUyOA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r433276528", "bodyText": "These commented out sections implement records that will probably be used once type information is added.  I can mark them unused if that's preferable.\nTIP: Prefixing the command block with \"/*-\" (as seen here) avoids the munging.\nhttps://www.oracle.com/java/technologies/javase/codeconventions-comments.html#680", "author": "stooke", "createdAt": "2020-06-01T14:43:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4NjU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMxNTMxNQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r433315315", "bodyText": "Oh, that tip is good to know. Thanks!\nI think it would be better to leave this marked unused with a comment to explain why it will eventually be needed.", "author": "adinn", "createdAt": "2020-06-01T15:40:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4NjU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4MDE4MQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r438980181", "bodyText": "I've added a comment.", "author": "stooke", "createdAt": "2020-06-11T18:12:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4NjU1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex e08bb5245ad..ddb43d1039c 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -328,60 +296,25 @@ abstract class CVSymbolSubrecord {\n             pos = CVUtil.putInt(debugStart, buffer, pos);\n             pos = CVUtil.putInt(debugEnd, buffer, pos);\n             pos = CVUtil.putInt(typeIndex, buffer, pos);\n-            if (buffer == null) {\n-                cvDebugInfo.getCVSymbolSection().getOwner().createDefinedSymbol(name, getTextSection(), offset, proclen, true, true);\n-            }\n             if (buffer != null) {\n-                // CVUtil.debug(\"CVSymbolGProc32Record() adding SECREL reloc at pos=0x%x for func=%s\n-                // addr=0x%x\\n\", pos, name, offset);\n-                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 4, ObjectFile.RelocationKind.SECREL, name, false, 1L);\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, externalName, false, 1L);\n             }\n             pos = CVUtil.putInt(0, buffer, pos);\n             if (buffer != null) {\n-                // CVUtil.debug(\"CVSymbolGProc32Record() adding SECTION reloc at pos=0x%x for\n-                // func=%s addr=0x%x\\n\", pos, name, offset);\n-                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 2, ObjectFile.RelocationKind.SECTION, name, false, 1L);\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, externalName, false, 1L);\n             }\n             pos = CVUtil.putShort((short) 0, buffer, pos);\n             pos = CVUtil.putByte(flags, buffer, pos);\n-            pos = CVUtil.putUTF8StringBytes(name, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(debuggerName, buffer, pos);\n             return pos;\n         }\n \n-        private ObjectFile.Element getTextSection() {\n-            if (textSection == null) {\n-                textSection = cvDebugInfo.getCVSymbolSection().getOwner().elementForName(SectionName.TEXT.getFormatDependentName(ObjectFile.Format.PECOFF));\n-            }\n-            return textSection;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            cvDebugInfo.getCVSymbolSection().debugAddress = offset;\n-            return String.format(\"S_GPROC32   name=%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", name, pparent, debugStart, debugEnd, proclen, offset,\n-                            typeIndex,\n-                            flags);\n-        }\n-    }\n-\n-    /*-\n-    public static final class CVSymbolGProc32IDRecord extends CVSymbolGProc32Record {\n-\n-        CVSymbolGProc32IDRecord(CVDebugInfo cvDebugInfo, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment, byte flags) {\n-            super(cvDebugInfo, CVDebugConstants.S_GPROC32_ID, name, pparent, pend, pnext, proclen, debugStart, debugEnd, typeIndex, offset, segment, flags);\n-        }\n-\n-        /* this is almost certainly bad (not enough information); use only for debugging *\n-        CVSymbolGProc32IDRecord(CVDebugInfo cvDebugInfo, String name, int offset, int proclen) {\n-            super(cvDebugInfo, CVDebugConstants.S_GPROC32_ID, name, 0, 0, 0, proclen, 0, 0, 0, offset, (short)0, (byte)0);\n-        }\n-\n         @Override\n         public String toString() {\n-            return String.format(\"S_GPROC32_ID(name=%s parent=%d startaddr=0x%x end=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", name, pparent, debugStart, debugEnd, proclen, offset, typeIndex, flags);\n+            return String.format(\"S_GPROC32   name=%s/%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", debuggerName, externalName, pparent, debugStart, debugEnd,\n+                            proclen, offset, typeIndex, flags);\n         }\n     }\n-    */\n \n     public static final class CVSymbolFrameProcRecord extends CVSymbolSubrecord {\n \n", "next_change": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex ddb43d1039c..0a30db69e94 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -296,35 +295,28 @@ abstract class CVSymbolSubrecord {\n             pos = CVUtil.putInt(debugStart, buffer, pos);\n             pos = CVUtil.putInt(debugEnd, buffer, pos);\n             pos = CVUtil.putInt(typeIndex, buffer, pos);\n-            if (buffer != null) {\n-                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, externalName, false, 1L);\n-            }\n-            pos = CVUtil.putInt(0, buffer, pos);\n-            if (buffer != null) {\n-                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, externalName, false, 1L);\n-            }\n-            pos = CVUtil.putShort((short) 0, buffer, pos);\n+            pos = cvDebugInfo.getCVSymbolSection().markRelocationSite(buffer, pos, symbolName, (long) 0);\n             pos = CVUtil.putByte(flags, buffer, pos);\n-            pos = CVUtil.putUTF8StringBytes(debuggerName, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(displayName, buffer, pos);\n             return pos;\n         }\n \n         @Override\n         public String toString() {\n-            return String.format(\"S_GPROC32   name=%s/%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", debuggerName, externalName, pparent, debugStart, debugEnd,\n-                            proclen, offset, typeIndex, flags);\n+            return String.format(\"S_GPROC32   name=%s/%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x seg:offset=0x%x:0x%x type=0x%x flags=0x%x)\", displayName, symbolName, pparent, debugStart, debugEnd,\n+                            proclen, segment, offset, typeIndex, flags);\n         }\n     }\n \n     public static final class CVSymbolFrameProcRecord extends CVSymbolSubrecord {\n \n-        int framelen;\n-        int padLen;\n-        int padOffset;\n-        int saveRegsCount;\n-        int ehOffset;\n-        short ehSection;\n-        int flags;\n+        private final int framelen;\n+        private final int padLen;\n+        private final int padOffset;\n+        private final int saveRegsCount;\n+        private final int ehOffset;\n+        private final short ehSection;\n+        private final int flags;\n \n         CVSymbolFrameProcRecord(CVDebugInfo cvDebugInfo, int framelen, int padLen, int padOffset, int saveRegsCount, int ehOffset, short ehSection, int flags) {\n             super(cvDebugInfo, CVDebugConstants.S_FRAMEPROC);\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU5MjYyMQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r432592621", "body": "This change is fine but it is going to change the way both VS and ELF debug info is generated. In the latter case that will cause the mx command mx testdebuginfo and the gate test which drives it to fail. Fixing this requires changing the test script mx.substartevm/testhello.py that drives a gdb session to also expect this separator. Occurrences of :: in both the input commands and the regular expressions used to match debugger output must be modified to a '.' character. n.b. That requires escaping the '.' in the regular expressions and attention needs to be paid to the type of string (raw or normall) in order to get the right number of backslashes (yeah using '.' is a pain in this regard even though it is better from a Java user point of view). I'll do this offline and forward you the edited version to try once you have reworked the code to address the latest round of review feedback.", "bodyText": "This change is fine but it is going to change the way both VS and ELF debug info is generated. In the latter case that will cause the mx command mx testdebuginfo and the gate test which drives it to fail. Fixing this requires changing the test script mx.substartevm/testhello.py that drives a gdb session to also expect this separator. Occurrences of :: in both the input commands and the regular expressions used to match debugger output must be modified to a '.' character. n.b. That requires escaping the '.' in the regular expressions and attention needs to be paid to the type of string (raw or normall) in order to get the right number of backslashes (yeah using '.' is a pain in this regard even though it is better from a Java user point of view). I'll do this offline and forward you the edited version to try once you have reworked the code to address the latest round of review feedback.", "bodyHTML": "<p dir=\"auto\">This change is fine but it is going to change the way both VS and ELF debug info is generated. In the latter case that will cause the mx command mx testdebuginfo and the gate test which drives it to fail. Fixing this requires changing the test script mx.substartevm/testhello.py that drives a gdb session to also expect this separator. Occurrences of :: in both the input commands and the regular expressions used to match debugger output must be modified to a '.' character. n.b. That requires escaping the '.' in the regular expressions and attention needs to be paid to the type of string (raw or normall) in order to get the right number of backslashes (yeah using '.' is a pain in this regard even though it is better from a Java user point of view). I'll do this offline and forward you the edited version to try once you have reworked the code to address the latest round of review feedback.</p>", "author": "adinn", "createdAt": "2020-05-29T16:16:08Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java", "diffHunk": "@@ -36,6 +36,9 @@\n  */\n \n public class Range {\n+\n+    private static final char CLASS_DELIMITER = '.';", "originalCommit": "f3fb7861b5c0ca257b5893a8ec59164e78acaf9a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ca3de5eafeddfb59dc7c8bf2ca2eb828d6c8b457", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex f3e25d8b709..489dafbb6a1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -36,9 +36,6 @@ import java.nio.file.Paths;\n  */\n \n public class Range {\n-\n-    private static final char CLASS_DELIMITER = '.';\n-\n     private String fileName;\n     private Path filePath;\n     private String className;\n", "next_change": {"commit": "4f231abdcb1b44ea570aef3acfbbe2f3d34e4898", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 489dafbb6a1..635cb9a6ea1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -36,6 +36,7 @@ import java.nio.file.Paths;\n  */\n \n public class Range {\n+    private final String cachePath;\n     private String fileName;\n     private Path filePath;\n     private String className;\n", "next_change": {"commit": "75651ac3832de72b3360e6fd39f6e4c73860aa13", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 635cb9a6ea1..9bea9a86794 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -36,7 +36,7 @@ import java.nio.file.Paths;\n  */\n \n public class Range {\n-    private final String cachePath;\n+    private final Path cachePath;\n     private String fileName;\n     private Path filePath;\n     private String className;\n", "next_change": {"commit": "86b7f4ca17b527b0ef4fb4deaea3b8eddb832364", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 9bea9a86794..635cb9a6ea1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -36,7 +36,7 @@ import java.nio.file.Paths;\n  */\n \n public class Range {\n-    private final Path cachePath;\n+    private final String cachePath;\n     private String fileName;\n     private Path filePath;\n     private String className;\n", "next_change": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 635cb9a6ea1..d8166f2ddfa 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -36,11 +36,15 @@ import java.nio.file.Paths;\n  */\n \n public class Range {\n+\n+    private static final String CLASS_DELIMITER = \".\";\n+\n     private final String cachePath;\n     private String fileName;\n     private Path filePath;\n     private String className;\n     private String methodName;\n+    private String symbolName;\n     private String paramNames;\n     private String returnTypeName;\n     private String fullMethodName;\n", "next_change": {"commit": "b307ee84155fb340719a658a7be2cc9159c49c02", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex d8166f2ddfa..6cdd3ed052a 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -36,22 +33,22 @@ import java.nio.file.Paths;\n  */\n \n public class Range {\n-\n     private static final String CLASS_DELIMITER = \".\";\n-\n-    private final String cachePath;\n-    private String fileName;\n-    private Path filePath;\n+    private FileEntry fileEntry;\n     private String className;\n     private String methodName;\n     private String symbolName;\n-    private String paramNames;\n+    private String paramSignature;\n     private String returnTypeName;\n+    private String methodNameWithParams;\n     private String fullMethodName;\n+    private String fullMethodNameWithParams;\n+    private String fullMethodNameWithParamsAndReturnType;\n     private int lo;\n     private int hi;\n     private int line;\n     private boolean isDeoptTarget;\n+    private int modifiers;\n     /*\n      * This is null for a primary range.\n      */\n", "next_change": {"commit": "3974499ff4ec8343219a484fde479bb8d6fe3182", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 6cdd3ed052a..d2060e4afd6 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -35,24 +35,22 @@ package com.oracle.objectfile.debugentry;\n public class Range {\n     private static final String CLASS_DELIMITER = \".\";\n     private FileEntry fileEntry;\n-    private String className;\n-    private String methodName;\n-    private String symbolName;\n-    private String paramSignature;\n-    private String returnTypeName;\n-    private String methodNameWithParams;\n-    private String fullMethodName;\n-    private String fullMethodNameWithParams;\n-    private String fullMethodNameWithParamsAndReturnType;\n-    private int lo;\n-    private int hi;\n-    private int line;\n-    private boolean isDeoptTarget;\n-    private int modifiers;\n+    private final String className;\n+    private final String methodName;\n+    private final String symbolName;\n+    private final String paramSignature;\n+    private final String returnTypeName;\n+    private final String fullMethodName;\n+    private final String fullMethodNameWithParams;\n+    private final int lo;\n+    private final int hi;\n+    private final int line;\n+    private final boolean isDeoptTarget;\n+    private final int modifiers;\n     /*\n      * This is null for a primary range.\n      */\n-    private Range primary;\n+    private final Range primary;\n \n     /*\n      * Create a primary range.\n", "next_change": {"commit": "b384283b5ac0e455e66648c0d661ce5410bdd863", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex d2060e4afd6..9bea361bef6 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -34,19 +34,14 @@ package com.oracle.objectfile.debugentry;\n \n public class Range {\n     private static final String CLASS_DELIMITER = \".\";\n-    private FileEntry fileEntry;\n-    private final String className;\n-    private final String methodName;\n+    private final FileEntry fileEntry;\n+    private MethodEntry methodEntry;\n     private final String symbolName;\n-    private final String paramSignature;\n-    private final String returnTypeName;\n-    private final String fullMethodName;\n     private final String fullMethodNameWithParams;\n     private final int lo;\n     private final int hi;\n     private final int line;\n     private final boolean isDeoptTarget;\n-    private final int modifiers;\n     /*\n      * This is null for a primary range.\n      */\n", "next_change": {"commit": "f485a3c15f5e29daf480657c0bfa22662f8005ae", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 9bea361bef6..a3d6e1c0db2 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -41,7 +41,6 @@ public class Range {\n     private final int lo;\n     private final int hi;\n     private final int line;\n-    private final boolean isDeoptTarget;\n     /*\n      * This is null for a primary range.\n      */\n", "next_change": {"commit": "dbb2c7607429817e58a1a9af8012e25e861368dc", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex a3d6e1c0db2..af465363bbf 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -35,8 +35,7 @@ package com.oracle.objectfile.debugentry;\n public class Range {\n     private static final String CLASS_DELIMITER = \".\";\n     private final FileEntry fileEntry;\n-    private MethodEntry methodEntry;\n-    private final String symbolName;\n+    private final MethodEntry methodEntry;\n     private final String fullMethodNameWithParams;\n     private final int lo;\n     private final int hi;\n", "next_change": {"commit": "a658b95d63a93b1980e4ac81fd4c034c70b9d9cb", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex af465363bbf..5f7f3fe3bda 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -34,7 +34,6 @@ package com.oracle.objectfile.debugentry;\n \n public class Range {\n     private static final String CLASS_DELIMITER = \".\";\n-    private final FileEntry fileEntry;\n     private final MethodEntry methodEntry;\n     private final String fullMethodNameWithParams;\n     private final int lo;\n", "next_change": {"commit": "6fcf98378231f0e754061b683c3dba387ce8b0e9", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 5f7f3fe3bda..cc407a53acd 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -34,11 +34,14 @@ package com.oracle.objectfile.debugentry;\n \n public class Range {\n     private static final String CLASS_DELIMITER = \".\";\n+    private final Range caller;\n     private final MethodEntry methodEntry;\n     private final String fullMethodNameWithParams;\n     private final int lo;\n     private final int hi;\n     private final int line;\n+    private final boolean isInlined;\n+    private final boolean withChildren;\n     /*\n      * This is null for a primary range.\n      */\n", "next_change": {"commit": "abe98eaaa6dd772b7419b819fa342e810a0939e0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex cc407a53acd..037024f1755 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -36,12 +36,14 @@ public class Range {\n     private static final String CLASS_DELIMITER = \".\";\n     private final Range caller;\n     private final MethodEntry methodEntry;\n+    private final String fullMethodName;\n     private final String fullMethodNameWithParams;\n     private final int lo;\n     private final int hi;\n     private final int line;\n     private final boolean isInlined;\n     private final boolean withChildren;\n+    private boolean withInlinedChildren;\n     /*\n      * This is null for a primary range.\n      */\n", "next_change": {"commit": "268c33256b26217c50339f452adea942fb48818f", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 037024f1755..1951241dda1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -34,32 +36,50 @@ package com.oracle.objectfile.debugentry;\n \n public class Range {\n     private static final String CLASS_DELIMITER = \".\";\n-    private final Range caller;\n+    private Range caller;\n     private final MethodEntry methodEntry;\n     private final String fullMethodName;\n     private final String fullMethodNameWithParams;\n     private final int lo;\n-    private final int hi;\n+    private int hi;\n     private final int line;\n     private final boolean isInlined;\n-    private final boolean withChildren;\n-    private boolean withInlinedChildren;\n+    private final int depth;\n     /*\n      * This is null for a primary range.\n      */\n     private final Range primary;\n \n+    /*\n+     * Support for tree of nested inline callee ranges\n+     */\n+\n+    /**\n+     * The first callee whose range is wholly contained in this range.\n+     */\n+    private Range firstCallee;\n+\n+    /**\n+     * The last callee whose range is wholly contained in this range.\n+     */\n+    private Range lastCallee;\n+\n+    /**\n+     * A link to chain callees of a given parent.\n+     */\n+    private Range nextCallee;\n+\n     /*\n      * Create a primary range.\n      */\n     public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line) {\n-        this(stringTable, methodEntry, lo, hi, line, null, false, false, null);\n+        this(stringTable, methodEntry, lo, hi, line, null, false, null);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary, boolean isInline, boolean withChildren, Range caller) {\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary, boolean isInline, Range caller) {\n         assert methodEntry != null;\n         if (methodEntry.fileEntry != null) {\n             stringTable.uniqueDebugString(methodEntry.fileEntry.getFileName());\n", "next_change": {"commit": "d60cbae9a9120ee8c53c87c4188355ed1d570682", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 1951241dda1..5159d0c6dd4 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -87,7 +87,7 @@ public class Range {\n         }\n         this.methodEntry = methodEntry;\n         this.fullMethodName = isInline ? stringTable.uniqueDebugString(constructClassAndMethodName()) : stringTable.uniqueString(constructClassAndMethodName());\n-        this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n+        this.fullMethodNameWithParams = constructClassAndMethodNameWithParams();\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n", "next_change": {"commit": "aadeac97667d3c369b3358b682902cb515dae2d2", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 5159d0c6dd4..b4c3d2b4380 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -87,7 +87,7 @@ public class Range {\n         }\n         this.methodEntry = methodEntry;\n         this.fullMethodName = isInline ? stringTable.uniqueDebugString(constructClassAndMethodName()) : stringTable.uniqueString(constructClassAndMethodName());\n-        this.fullMethodNameWithParams = constructClassAndMethodNameWithParams();\n+        this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n", "next_change": {"commit": "dfcec107e9c56e9ed5587888711b6cd4bec2e341", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex b4c3d2b4380..c3f7e5ca594 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -87,7 +87,7 @@ public class Range {\n         }\n         this.methodEntry = methodEntry;\n         this.fullMethodName = isInline ? stringTable.uniqueDebugString(constructClassAndMethodName()) : stringTable.uniqueString(constructClassAndMethodName());\n-        this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n+        this.fullMethodNameWithParams = constructClassAndMethodNameWithParams();\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n", "next_change": {"commit": "2070ace4d658b9767e7502bf21d31fe7658d4c1d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex c3f7e5ca594..6bb1eb1d42e 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -73,30 +71,30 @@ public class Range {\n      * Create a primary range.\n      */\n     public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line) {\n-        this(stringTable, methodEntry, lo, hi, line, null, false, null);\n+        this(stringTable, methodEntry, lo, hi, line, null, false, null, false);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary, boolean isInline, Range caller) {\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary, boolean isTopLevel, Range caller, boolean isPrologueEnd) {\n         assert methodEntry != null;\n         if (methodEntry.fileEntry != null) {\n             stringTable.uniqueDebugString(methodEntry.fileEntry.getFileName());\n             stringTable.uniqueDebugString(methodEntry.fileEntry.getPathName());\n         }\n         this.methodEntry = methodEntry;\n-        this.fullMethodName = isInline ? stringTable.uniqueDebugString(constructClassAndMethodName()) : stringTable.uniqueString(constructClassAndMethodName());\n+        this.fullMethodName = isTopLevel ? stringTable.uniqueDebugString(constructClassAndMethodName()) : stringTable.uniqueString(constructClassAndMethodName());\n         this.fullMethodNameWithParams = constructClassAndMethodNameWithParams();\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n-        this.isInlined = isInline;\n         this.primary = primary;\n         this.firstCallee = null;\n         this.lastCallee = null;\n         this.siblingCallee = null;\n         this.caller = caller;\n+        this.isPrologueEnd = isPrologueEnd;\n         if (caller != null) {\n             caller.addCallee(this);\n         }\n", "next_change": {"commit": "93867a358383835002b334613e5e1b394f542a48", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 6bb1eb1d42e..6ba4e9aeacc 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -94,7 +162,6 @@ public class Range {\n         this.lastCallee = null;\n         this.siblingCallee = null;\n         this.caller = caller;\n-        this.isPrologueEnd = isPrologueEnd;\n         if (caller != null) {\n             caller.addCallee(this);\n         }\n", "next_change": {"commit": "9acf1c5d597e38f3e832360ce3f372ad94b16e9e", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/range/Range.java\nsimilarity index 53%\nrename from substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nrename to substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/range/Range.java\nindex 6ba4e9aeacc..0ddc82fe6f9 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/range/Range.java\n", "chunk": "@@ -66,144 +69,75 @@ import java.util.List;\n  * parameter values for separate sub-extents of an inline called method whose full extent is\n  * represented by the parent call range at level N.\n  */\n-public class Range {\n+public abstract class Range {\n     private static final String CLASS_DELIMITER = \".\";\n-    private final MethodEntry methodEntry;\n-    private final String fullMethodName;\n-    private final String fullMethodNameWithParams;\n-    private final int lo;\n-    private int hi;\n-    private final int line;\n-    private final int depth;\n-    /**\n-     * This is null for a primary range. For sub ranges it holds the root of the call tree they\n-     * belong to.\n-     */\n-    private final Range primary;\n-\n-    /**\n-     * The range for the caller or the primary range when this range if for top level method code.\n-     */\n-    private Range caller;\n-    /**\n-     * The first direct callee whose range is wholly contained in this range or null if this is a\n-     * leaf range.\n-     */\n-    private Range firstCallee;\n+    protected final MethodEntry methodEntry;\n+    protected final int lo;\n+    protected int hi;\n+    protected final int line;\n+    protected final int depth;\n \n     /**\n-     * The last direct callee whose range is wholly contained in this range.\n+     * Create a primary range representing the root of the subrange tree for a top level compiled\n+     * method.\n+     * \n+     * @param methodEntry the top level compiled method for this primary range.\n+     * @param lo the lowest address included in the range.\n+     * @param hi the first address above the highest address in the range.\n+     * @param line the line number associated with the range\n+     * @return a new primary range to serve as the root of the subrange tree.\n      */\n-    private Range lastCallee;\n-\n-    /**\n-     * A link to a sibling callee, i.e., a range sharing the same caller with this range.\n-     */\n-    private Range siblingCallee;\n-\n-    /**\n-     * Values for the associated method's local and parameter variables that are available or,\n-     * alternatively, marked as invalid in this range.\n-     */\n-    private DebugLocalValueInfo[] localValueInfos;\n-\n-    /**\n-     * The set of local or parameter variables with which each corresponding local value in field\n-     * localvalueInfos is associated. Local values which are associated with the same local or\n-     * parameter variable will share the same reference in the corresponding array entries. Local\n-     * values with which no local variable can be associated will have a null reference in the\n-     * corresponding array. The latter case can happen when a local value has an invalid slot or\n-     * when a local value that maps to a parameter slot has a different name or type to the\n-     * parameter.\n-     */\n-    private DebugLocalInfo[] localInfos;\n-\n-    public int getLocalValueCount() {\n-        assert !this.isPrimary() : \"primary range does not have local values\";\n-        return localValueInfos.length;\n-    }\n-\n-    public DebugLocalValueInfo getLocalValue(int i) {\n-        assert !this.isPrimary() : \"primary range does not have local values\";\n-        assert i >= 0 && i < localValueInfos.length : \"bad index\";\n-        return localValueInfos[i];\n-    }\n-\n-    public DebugLocalInfo getLocal(int i) {\n-        assert !this.isPrimary() : \"primary range does not have local vars\";\n-        assert i >= 0 && i < localInfos.length : \"bad index\";\n-        return localInfos[i];\n+    public static PrimaryRange createPrimary(MethodEntry methodEntry, int lo, int hi, int line) {\n+        return new PrimaryRange(methodEntry, lo, hi, line);\n     }\n \n-    /*\n-     * Create a primary range.\n+    /**\n+     * Create a subrange representing a segment of the address range for code of a top level or\n+     * inlined compiled method. The result will either be a call or a leaf range.\n+     * \n+     * @param methodEntry the method from which code in the subrange is derived.\n+     * @param lo the lowest address included in the range.\n+     * @param hi the first address above the highest address in the range.\n+     * @param line the line number associated with the range\n+     * @param primary the primary range to which this subrange belongs\n+     * @param caller the range for which this is a subrange, either an inlined call range or the\n+     *            primary range.\n+     * @param isLeaf true if this is a leaf range with no subranges\n+     * @return a new subrange to be linked into the range tree below the primary range.\n      */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line) {\n-        this(stringTable, methodEntry, lo, hi, line, null, false, null);\n+    public static SubRange createSubrange(MethodEntry methodEntry, int lo, int hi, int line, PrimaryRange primary, Range caller, boolean isLeaf) {\n+        assert primary != null;\n+        assert primary.isPrimary();\n+        if (isLeaf) {\n+            return new LeafRange(methodEntry, lo, hi, line, primary, caller);\n+        } else {\n+            return new CallRange(methodEntry, lo, hi, line, primary, caller);\n+        }\n     }\n \n-    /*\n-     * Create a primary or secondary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary, boolean isTopLevel, Range caller) {\n+    protected Range(MethodEntry methodEntry, int lo, int hi, int line, int depth) {\n         assert methodEntry != null;\n-        if (methodEntry.fileEntry != null) {\n-            stringTable.uniqueDebugString(methodEntry.fileEntry.getFileName());\n-            stringTable.uniqueDebugString(methodEntry.fileEntry.getPathName());\n-        }\n         this.methodEntry = methodEntry;\n-        this.fullMethodName = isTopLevel ? stringTable.uniqueDebugString(constructClassAndMethodName()) : stringTable.uniqueString(constructClassAndMethodName());\n-        this.fullMethodNameWithParams = constructClassAndMethodNameWithParams();\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n-        this.primary = primary;\n-        this.firstCallee = null;\n-        this.lastCallee = null;\n-        this.siblingCallee = null;\n-        this.caller = caller;\n-        if (caller != null) {\n-            caller.addCallee(this);\n-        }\n-        if (this.isPrimary()) {\n-            this.depth = -1;\n-        } else {\n-            this.depth = caller.depth + 1;\n-        }\n+        this.depth = depth;\n     }\n \n-    private void addCallee(Range callee) {\n-        assert this.lo <= callee.lo;\n-        assert this.hi >= callee.hi;\n-        assert callee.caller == this;\n-        assert callee.siblingCallee == null;\n-        if (this.firstCallee == null) {\n-            assert this.lastCallee == null;\n-            this.firstCallee = this.lastCallee = callee;\n-        } else {\n-            this.lastCallee.siblingCallee = callee;\n-            this.lastCallee = callee;\n-        }\n-    }\n+    protected abstract void addCallee(SubRange callee);\n \n     public boolean contains(Range other) {\n         return (lo <= other.lo && hi >= other.hi);\n     }\n \n-    public boolean isPrimary() {\n-        return getPrimary() == null;\n-    }\n-\n-    public Range getPrimary() {\n-        return primary;\n-    }\n+    public abstract boolean isPrimary();\n \n     public String getClassName() {\n-        return methodEntry.ownerType.typeName;\n+        return methodEntry.ownerType().getTypeName();\n     }\n \n     public String getMethodName() {\n-        return methodEntry.memberName;\n+        return methodEntry.methodName();\n     }\n \n     public String getSymbolName() {\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex a3d6e1c0db2..af465363bbf 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -49,30 +48,29 @@ public class Range {\n     /*\n      * Create a primary range.\n      */\n-    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n-        this(symbolName, stringTable, methodEntry, fileEntry, lo, hi, line, null);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n+        this(stringTable, methodEntry, fileEntry, lo, hi, line, null);\n     }\n \n     /*\n      * Create a secondary range.\n      */\n-    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n-        this(symbolName, stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n+        this(stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n+    private Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n                     Range primary) {\n-        this.fileEntry = fileEntry; // TODO remove and use fileEntry from MethodEntry\n+        this.fileEntry = fileEntry;\n         if (fileEntry != null) {\n             stringTable.uniqueDebugString(fileEntry.getFileName());\n             stringTable.uniqueDebugString(fileEntry.getPathName());\n         }\n         assert methodEntry != null;\n         this.methodEntry = methodEntry;\n-        this.symbolName = stringTable.uniqueString(symbolName);\n         this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n         this.lo = lo;\n         this.hi = hi;\n", "next_change": {"commit": "a658b95d63a93b1980e4ac81fd4c034c70b9d9cb", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex af465363bbf..5f7f3fe3bda 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -48,28 +47,19 @@ public class Range {\n     /*\n      * Create a primary range.\n      */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n-        this(stringTable, methodEntry, fileEntry, lo, hi, line, null);\n-    }\n-\n-    /*\n-     * Create a secondary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n-        this(stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line) {\n+        this(stringTable, methodEntry, lo, hi, line, null);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n-                    Range primary) {\n-        this.fileEntry = fileEntry;\n-        if (fileEntry != null) {\n-            stringTable.uniqueDebugString(fileEntry.getFileName());\n-            stringTable.uniqueDebugString(fileEntry.getPathName());\n-        }\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n         assert methodEntry != null;\n+        if (methodEntry.fileEntry != null) {\n+            stringTable.uniqueDebugString(methodEntry.fileEntry.getFileName());\n+            stringTable.uniqueDebugString(methodEntry.fileEntry.getPathName());\n+        }\n         this.methodEntry = methodEntry;\n         this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n         this.lo = lo;\n", "next_change": {"commit": "6fcf98378231f0e754061b683c3dba387ce8b0e9", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 5f7f3fe3bda..cc407a53acd 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -65,7 +68,10 @@ public class Range {\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n+        this.isInlined = isInline;\n         this.primary = primary;\n+        this.withChildren = withChildren;\n+        this.caller = caller;\n     }\n \n     public boolean contains(Range other) {\n", "next_change": {"commit": "abe98eaaa6dd772b7419b819fa342e810a0939e0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex cc407a53acd..037024f1755 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -71,6 +74,7 @@ public class Range {\n         this.isInlined = isInline;\n         this.primary = primary;\n         this.withChildren = withChildren;\n+        this.withInlinedChildren = false;\n         this.caller = caller;\n     }\n \n", "next_change": {"commit": "268c33256b26217c50339f452adea942fb48818f", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 037024f1755..1951241dda1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -73,9 +93,32 @@ public class Range {\n         this.line = line;\n         this.isInlined = isInline;\n         this.primary = primary;\n-        this.withChildren = withChildren;\n-        this.withInlinedChildren = false;\n+        this.firstCallee = null;\n+        this.lastCallee = null;\n+        this.nextCallee = null;\n         this.caller = caller;\n+        if (caller != null) {\n+            caller.addCallee(this);\n+        }\n+        if (this.isPrimary()) {\n+            this.depth = -1;\n+        } else {\n+            this.depth = caller.depth + 1;\n+        }\n+    }\n+\n+    private void addCallee(Range callee) {\n+        assert this.lo <= callee.lo;\n+        assert this.hi >= callee.hi;\n+        assert callee.caller == this;\n+        assert callee.nextCallee == null;\n+        if (this.firstCallee == null) {\n+            assert this.lastCallee == null;\n+            this.firstCallee = this.lastCallee = callee;\n+        } else {\n+            this.lastCallee.nextCallee = callee;\n+            this.lastCallee = callee;\n+        }\n     }\n \n     public boolean contains(Range other) {\n", "next_change": {"commit": "6ae5665ec0f5f89ff4a7804dbeec25c85d0982ea", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 1951241dda1..43c64a540e9 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -111,12 +111,12 @@ public class Range {\n         assert this.lo <= callee.lo;\n         assert this.hi >= callee.hi;\n         assert callee.caller == this;\n-        assert callee.nextCallee == null;\n+        assert callee.siblingCallee == null;\n         if (this.firstCallee == null) {\n             assert this.lastCallee == null;\n             this.firstCallee = this.lastCallee = callee;\n         } else {\n-            this.lastCallee.nextCallee = callee;\n+            this.lastCallee.siblingCallee = callee;\n             this.lastCallee = callee;\n         }\n     }\n", "next_change": {"commit": "9acf1c5d597e38f3e832360ce3f372ad94b16e9e", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\ndeleted file mode 100644\nindex 43c64a540e9..00000000000\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ /dev/null\n", "chunk": "@@ -1,339 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.objectfile.debugentry;\n-\n-import org.graalvm.compiler.debug.DebugContext;\n-\n-/**\n- * Details of a specific address range in a compiled method either a primary range identifying a\n- * whole method or a sub-range identifying a sequence of instructions that belong to an inlined\n- * method. Each sub-range is linked with its caller and its callees, forming a call tree.\n- */\n-public class Range {\n-    private static final String CLASS_DELIMITER = \".\";\n-    private Range caller;\n-    private final MethodEntry methodEntry;\n-    private final String fullMethodName;\n-    private final String fullMethodNameWithParams;\n-    private final int lo;\n-    private int hi;\n-    private final int line;\n-    private final boolean isInlined;\n-    private final int depth;\n-    /**\n-     * This is null for a primary range. For sub ranges it holds the root of the call tree they\n-     * belong to.\n-     */\n-    private final Range primary;\n-\n-    /*\n-     * Support for tree of nested inline callee ranges\n-     */\n-\n-    /**\n-     * The first direct callee whose range is wholly contained in this range.\n-     */\n-    private Range firstCallee;\n-\n-    /**\n-     * The last direct callee whose range is wholly contained in this range.\n-     */\n-    private Range lastCallee;\n-\n-    /**\n-     * A link to a sibling callee, i.e., a range sharing the same caller with this range.\n-     */\n-    private Range siblingCallee;\n-\n-    /*\n-     * Create a primary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line) {\n-        this(stringTable, methodEntry, lo, hi, line, null, false, null);\n-    }\n-\n-    /*\n-     * Create a primary or secondary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary, boolean isInline, Range caller) {\n-        assert methodEntry != null;\n-        if (methodEntry.fileEntry != null) {\n-            stringTable.uniqueDebugString(methodEntry.fileEntry.getFileName());\n-            stringTable.uniqueDebugString(methodEntry.fileEntry.getPathName());\n-        }\n-        this.methodEntry = methodEntry;\n-        this.fullMethodName = isInline ? stringTable.uniqueDebugString(constructClassAndMethodName()) : stringTable.uniqueString(constructClassAndMethodName());\n-        this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n-        this.lo = lo;\n-        this.hi = hi;\n-        this.line = line;\n-        this.isInlined = isInline;\n-        this.primary = primary;\n-        this.firstCallee = null;\n-        this.lastCallee = null;\n-        this.siblingCallee = null;\n-        this.caller = caller;\n-        if (caller != null) {\n-            caller.addCallee(this);\n-        }\n-        if (this.isPrimary()) {\n-            this.depth = -1;\n-        } else {\n-            this.depth = caller.depth + 1;\n-        }\n-    }\n-\n-    private void addCallee(Range callee) {\n-        assert this.lo <= callee.lo;\n-        assert this.hi >= callee.hi;\n-        assert callee.caller == this;\n-        assert callee.siblingCallee == null;\n-        if (this.firstCallee == null) {\n-            assert this.lastCallee == null;\n-            this.firstCallee = this.lastCallee = callee;\n-        } else {\n-            this.lastCallee.siblingCallee = callee;\n-            this.lastCallee = callee;\n-        }\n-    }\n-\n-    public boolean contains(Range other) {\n-        return (lo <= other.lo && hi >= other.hi);\n-    }\n-\n-    public boolean isPrimary() {\n-        return getPrimary() == null;\n-    }\n-\n-    public Range getPrimary() {\n-        return primary;\n-    }\n-\n-    public String getClassName() {\n-        return methodEntry.ownerType.typeName;\n-    }\n-\n-    public String getMethodName() {\n-        return methodEntry.memberName;\n-    }\n-\n-    public String getSymbolName() {\n-        return methodEntry.getSymbolName();\n-    }\n-\n-    public int getHi() {\n-        return hi;\n-    }\n-\n-    public int getLo() {\n-        return lo;\n-    }\n-\n-    public int getLine() {\n-        return line;\n-    }\n-\n-    public String getFullMethodName() {\n-        return fullMethodName;\n-    }\n-\n-    public String getFullMethodNameWithParams() {\n-        return fullMethodNameWithParams;\n-    }\n-\n-    public boolean isDeoptTarget() {\n-        return methodEntry.isDeopt();\n-    }\n-\n-    private String getExtendedMethodName(boolean includeClass, boolean includeParams, boolean includeReturnType) {\n-        StringBuilder builder = new StringBuilder();\n-        if (includeReturnType && methodEntry.valueType.typeName.length() > 0) {\n-            builder.append(methodEntry.valueType.typeName);\n-            builder.append(' ');\n-        }\n-        if (includeClass && getClassName() != null) {\n-            builder.append(getClassName());\n-            builder.append(CLASS_DELIMITER);\n-        }\n-        builder.append(getMethodName());\n-        if (includeParams) {\n-            builder.append('(');\n-            builder.append(String.join(\", \", methodEntry.paramNames));\n-            builder.append(')');\n-        }\n-        if (includeReturnType) {\n-            builder.append(\" \");\n-            builder.append(methodEntry.valueType.typeName);\n-        }\n-        return builder.toString();\n-    }\n-\n-    private String constructClassAndMethodName() {\n-        return getExtendedMethodName(true, false, false);\n-    }\n-\n-    private String constructClassAndMethodNameWithParams() {\n-        return getExtendedMethodName(true, true, false);\n-    }\n-\n-    public FileEntry getFileEntry() {\n-        return methodEntry.fileEntry;\n-    }\n-\n-    public int getModifiers() {\n-        return methodEntry.modifiers;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"Range(lo=0x%05x hi=0x%05x %s %s:%d)\", lo, hi, constructClassAndMethodNameWithParams(), methodEntry.getFullFileName(), line);\n-    }\n-\n-    public String getFileName() {\n-        return methodEntry.getFileName();\n-    }\n-\n-    public MethodEntry getMethodEntry() {\n-        return methodEntry;\n-    }\n-\n-    public boolean isInlined() {\n-        return isInlined;\n-    }\n-\n-    public Range getCaller() {\n-        return caller;\n-    }\n-\n-    public Range getFirstCallee() {\n-        return firstCallee;\n-    }\n-\n-    public Range getSiblingCallee() {\n-        return siblingCallee;\n-    }\n-\n-    public Range getLastCallee() {\n-        return lastCallee;\n-    }\n-\n-    public boolean isLeaf() {\n-        return firstCallee == null;\n-    }\n-\n-    public int getDepth() {\n-        return depth;\n-    }\n-\n-    /**\n-     * Minimizes the nodes in the tree that track the inline call hierarchy and associated code\n-     * ranges. The initial range tree models the call hierarchy as presented in the original debug\n-     * line info. It consists of a root node each of whose children is a sequence of linear call\n-     * chains, either a single leaf node for some given file and line or a series of inline calls to\n-     * such a leaf node. In this initial tree all node ranges in a given chain have the same lo and\n-     * hi address and chains are properly ordered by range The merge algorithm works across siblings\n-     * at successive depths starting at depth 1. Once all possible nodes at a given depth have been\n-     * merged their children can then be merged. A successor node may only be merged into its\n-     * predecessor if the nodes have contiguous ranges and idenitfy the same method, line and file.\n-     * The range and children of the merged node are, respectively, the union of the input ranges\n-     * and children. This preserves the invariant that child ranges lie within their parent range.\n-     *\n-     * @param debugContext\n-     */\n-    public void mergeSubranges(DebugContext debugContext) {\n-        Range next = getFirstCallee();\n-        if (next == null) {\n-            return;\n-        }\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Merge subranges [0x%x, 0x%x] %s\", lo, hi, getFullMethodNameWithParams());\n-        /* merge siblings together if possible, reparenting children to the merged node */\n-        while (next != null) {\n-            next = next.maybeMergeSibling(debugContext);\n-        }\n-        /* now recurse down to merge children of whatever nodes remain */\n-        next = getFirstCallee();\n-        /* now this level is merged recursively merge children of each child node. */\n-        while (next != null) {\n-            next.mergeSubranges(debugContext);\n-            next = next.getSiblingCallee();\n-        }\n-    }\n-\n-    /**\n-     * Removes and merges the next sibling returning the current node or it skips past the current\n-     * node as is and returns the next sibling or null if no sibling exists.\n-     */\n-    private Range maybeMergeSibling(DebugContext debugContext) {\n-        Range sibling = getSiblingCallee();\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Merge subrange (maybe) [0x%x, 0x%x] %s\", lo, hi, getFullMethodNameWithParams());\n-        if (sibling == null) {\n-            /* all child nodes at this level have been merged */\n-            return null;\n-        }\n-        if (hi < sibling.lo) {\n-            /* cannot merge non-contiguous ranges, move on. */\n-            return sibling;\n-        }\n-        if (getMethodEntry() != sibling.getMethodEntry()) {\n-            /* cannot merge distinct callers, move on. */\n-            return sibling;\n-        }\n-        if (getLine() != sibling.getLine()) {\n-            /* cannot merge callers with different line numbers, move on. */\n-            return sibling;\n-        }\n-        /* splice out the sibling from the chain and update this one to include it. */\n-        unlink(debugContext, sibling);\n-        /* relocate the siblings children to this node. */\n-        reparentChildren(debugContext, sibling);\n-        /* return the merged node so we can maybe merge it again. */\n-        return this;\n-    }\n-\n-    private void unlink(DebugContext debugContext, Range sibling) {\n-        assert hi == sibling.lo : String.format(\"gap in range [0x%x,0x%x] %s [0x%x,0x%x] %s\",\n-                        lo, hi, getFullMethodNameWithParams(), sibling.getLo(), sibling.getHi(), sibling.getFullMethodNameWithParams());\n-        assert this.isInlined == sibling.isInlined : String.format(\"change in inlined [0x%x,0x%x] %s %s [0x%x,0x%x] %s %s\",\n-                        lo, hi, getFullMethodNameWithParams(), Boolean.valueOf(this.isInlined), sibling.lo, sibling.hi, sibling.getFullMethodNameWithParams(), Boolean.valueOf(sibling.isInlined));\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Combining [0x%x, 0x%x] %s into [0x%x, 0x%x] %s\", sibling.lo, sibling.hi, sibling.getFullMethodName(), lo, hi, getFullMethodNameWithParams());\n-        this.hi = sibling.hi;\n-        this.siblingCallee = sibling.siblingCallee;\n-    }\n-\n-    private void reparentChildren(DebugContext debugContext, Range sibling) {\n-        Range siblingNext = sibling.getFirstCallee();\n-        while (siblingNext != null) {\n-            debugContext.log(DebugContext.INFO_LEVEL, \"Reparenting [0x%x, 0x%x] %s to [0x%x, 0x%x] %s\", siblingNext.lo, siblingNext.hi, siblingNext.getFullMethodName(), lo, hi,\n-                            getFullMethodNameWithParams());\n-            siblingNext.caller = this;\n-            Range newSiblingNext = siblingNext.siblingCallee;\n-            siblingNext.siblingCallee = null;\n-            addCallee(siblingNext);\n-            siblingNext = newSiblingNext;\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 9bea361bef6..a3d6e1c0db2 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -50,23 +49,22 @@ public class Range {\n     /*\n      * Create a primary range.\n      */\n-    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n-                 boolean isDeoptTarget) {\n-        this(symbolName, stringTable, methodEntry, fileEntry, lo, hi, line, isDeoptTarget, null);\n+    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n+        this(symbolName, stringTable, methodEntry, fileEntry, lo, hi, line, null);\n     }\n \n     /*\n      * Create a secondary range.\n      */\n     public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n-        this(symbolName, stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, false, primary);\n+        this(symbolName, stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n     private Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n-                    boolean isDeoptTarget, Range primary) {\n+                    Range primary) {\n         this.fileEntry = fileEntry; // TODO remove and use fileEntry from MethodEntry\n         if (fileEntry != null) {\n             stringTable.uniqueDebugString(fileEntry.getFileName());\n", "next_change": {"commit": "70792d9ae44148d55d1611662964c48b7f132e0a", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex a3d6e1c0db2..dd82d22565b 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -65,7 +65,7 @@ public class Range {\n      */\n     private Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n                     Range primary) {\n-        this.fileEntry = fileEntry; // TODO remove and use fileEntry from MethodEntry\n+        this.fileEntry = fileEntry;\n         if (fileEntry != null) {\n             stringTable.uniqueDebugString(fileEntry.getFileName());\n             stringTable.uniqueDebugString(fileEntry.getPathName());\n", "next_change": {"commit": "dbb2c7607429817e58a1a9af8012e25e861368dc", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex dd82d22565b..af465363bbf 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -49,21 +48,21 @@ public class Range {\n     /*\n      * Create a primary range.\n      */\n-    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n-        this(symbolName, stringTable, methodEntry, fileEntry, lo, hi, line, null);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n+        this(stringTable, methodEntry, fileEntry, lo, hi, line, null);\n     }\n \n     /*\n      * Create a secondary range.\n      */\n-    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n-        this(symbolName, stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n+        this(stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n+    private Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n                     Range primary) {\n         this.fileEntry = fileEntry;\n         if (fileEntry != null) {\n", "next_change": {"commit": "a658b95d63a93b1980e4ac81fd4c034c70b9d9cb", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex af465363bbf..5f7f3fe3bda 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -48,28 +47,19 @@ public class Range {\n     /*\n      * Create a primary range.\n      */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n-        this(stringTable, methodEntry, fileEntry, lo, hi, line, null);\n-    }\n-\n-    /*\n-     * Create a secondary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n-        this(stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line) {\n+        this(stringTable, methodEntry, lo, hi, line, null);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n-                    Range primary) {\n-        this.fileEntry = fileEntry;\n-        if (fileEntry != null) {\n-            stringTable.uniqueDebugString(fileEntry.getFileName());\n-            stringTable.uniqueDebugString(fileEntry.getPathName());\n-        }\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n         assert methodEntry != null;\n+        if (methodEntry.fileEntry != null) {\n+            stringTable.uniqueDebugString(methodEntry.fileEntry.getFileName());\n+            stringTable.uniqueDebugString(methodEntry.fileEntry.getPathName());\n+        }\n         this.methodEntry = methodEntry;\n         this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n         this.lo = lo;\n", "next_change": {"commit": "6fcf98378231f0e754061b683c3dba387ce8b0e9", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 5f7f3fe3bda..cc407a53acd 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -65,7 +68,10 @@ public class Range {\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n+        this.isInlined = isInline;\n         this.primary = primary;\n+        this.withChildren = withChildren;\n+        this.caller = caller;\n     }\n \n     public boolean contains(Range other) {\n", "next_change": {"commit": "abe98eaaa6dd772b7419b819fa342e810a0939e0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex cc407a53acd..037024f1755 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -71,6 +74,7 @@ public class Range {\n         this.isInlined = isInline;\n         this.primary = primary;\n         this.withChildren = withChildren;\n+        this.withInlinedChildren = false;\n         this.caller = caller;\n     }\n \n", "next_change": {"commit": "268c33256b26217c50339f452adea942fb48818f", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 037024f1755..1951241dda1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -73,9 +93,32 @@ public class Range {\n         this.line = line;\n         this.isInlined = isInline;\n         this.primary = primary;\n-        this.withChildren = withChildren;\n-        this.withInlinedChildren = false;\n+        this.firstCallee = null;\n+        this.lastCallee = null;\n+        this.nextCallee = null;\n         this.caller = caller;\n+        if (caller != null) {\n+            caller.addCallee(this);\n+        }\n+        if (this.isPrimary()) {\n+            this.depth = -1;\n+        } else {\n+            this.depth = caller.depth + 1;\n+        }\n+    }\n+\n+    private void addCallee(Range callee) {\n+        assert this.lo <= callee.lo;\n+        assert this.hi >= callee.hi;\n+        assert callee.caller == this;\n+        assert callee.nextCallee == null;\n+        if (this.firstCallee == null) {\n+            assert this.lastCallee == null;\n+            this.firstCallee = this.lastCallee = callee;\n+        } else {\n+            this.lastCallee.nextCallee = callee;\n+            this.lastCallee = callee;\n+        }\n     }\n \n     public boolean contains(Range other) {\n", "next_change": {"commit": "6ae5665ec0f5f89ff4a7804dbeec25c85d0982ea", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 1951241dda1..43c64a540e9 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -111,12 +111,12 @@ public class Range {\n         assert this.lo <= callee.lo;\n         assert this.hi >= callee.hi;\n         assert callee.caller == this;\n-        assert callee.nextCallee == null;\n+        assert callee.siblingCallee == null;\n         if (this.firstCallee == null) {\n             assert this.lastCallee == null;\n             this.firstCallee = this.lastCallee = callee;\n         } else {\n-            this.lastCallee.nextCallee = callee;\n+            this.lastCallee.siblingCallee = callee;\n             this.lastCallee = callee;\n         }\n     }\n", "next_change": {"commit": "9acf1c5d597e38f3e832360ce3f372ad94b16e9e", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\ndeleted file mode 100644\nindex 43c64a540e9..00000000000\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ /dev/null\n", "chunk": "@@ -1,339 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.objectfile.debugentry;\n-\n-import org.graalvm.compiler.debug.DebugContext;\n-\n-/**\n- * Details of a specific address range in a compiled method either a primary range identifying a\n- * whole method or a sub-range identifying a sequence of instructions that belong to an inlined\n- * method. Each sub-range is linked with its caller and its callees, forming a call tree.\n- */\n-public class Range {\n-    private static final String CLASS_DELIMITER = \".\";\n-    private Range caller;\n-    private final MethodEntry methodEntry;\n-    private final String fullMethodName;\n-    private final String fullMethodNameWithParams;\n-    private final int lo;\n-    private int hi;\n-    private final int line;\n-    private final boolean isInlined;\n-    private final int depth;\n-    /**\n-     * This is null for a primary range. For sub ranges it holds the root of the call tree they\n-     * belong to.\n-     */\n-    private final Range primary;\n-\n-    /*\n-     * Support for tree of nested inline callee ranges\n-     */\n-\n-    /**\n-     * The first direct callee whose range is wholly contained in this range.\n-     */\n-    private Range firstCallee;\n-\n-    /**\n-     * The last direct callee whose range is wholly contained in this range.\n-     */\n-    private Range lastCallee;\n-\n-    /**\n-     * A link to a sibling callee, i.e., a range sharing the same caller with this range.\n-     */\n-    private Range siblingCallee;\n-\n-    /*\n-     * Create a primary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line) {\n-        this(stringTable, methodEntry, lo, hi, line, null, false, null);\n-    }\n-\n-    /*\n-     * Create a primary or secondary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary, boolean isInline, Range caller) {\n-        assert methodEntry != null;\n-        if (methodEntry.fileEntry != null) {\n-            stringTable.uniqueDebugString(methodEntry.fileEntry.getFileName());\n-            stringTable.uniqueDebugString(methodEntry.fileEntry.getPathName());\n-        }\n-        this.methodEntry = methodEntry;\n-        this.fullMethodName = isInline ? stringTable.uniqueDebugString(constructClassAndMethodName()) : stringTable.uniqueString(constructClassAndMethodName());\n-        this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n-        this.lo = lo;\n-        this.hi = hi;\n-        this.line = line;\n-        this.isInlined = isInline;\n-        this.primary = primary;\n-        this.firstCallee = null;\n-        this.lastCallee = null;\n-        this.siblingCallee = null;\n-        this.caller = caller;\n-        if (caller != null) {\n-            caller.addCallee(this);\n-        }\n-        if (this.isPrimary()) {\n-            this.depth = -1;\n-        } else {\n-            this.depth = caller.depth + 1;\n-        }\n-    }\n-\n-    private void addCallee(Range callee) {\n-        assert this.lo <= callee.lo;\n-        assert this.hi >= callee.hi;\n-        assert callee.caller == this;\n-        assert callee.siblingCallee == null;\n-        if (this.firstCallee == null) {\n-            assert this.lastCallee == null;\n-            this.firstCallee = this.lastCallee = callee;\n-        } else {\n-            this.lastCallee.siblingCallee = callee;\n-            this.lastCallee = callee;\n-        }\n-    }\n-\n-    public boolean contains(Range other) {\n-        return (lo <= other.lo && hi >= other.hi);\n-    }\n-\n-    public boolean isPrimary() {\n-        return getPrimary() == null;\n-    }\n-\n-    public Range getPrimary() {\n-        return primary;\n-    }\n-\n-    public String getClassName() {\n-        return methodEntry.ownerType.typeName;\n-    }\n-\n-    public String getMethodName() {\n-        return methodEntry.memberName;\n-    }\n-\n-    public String getSymbolName() {\n-        return methodEntry.getSymbolName();\n-    }\n-\n-    public int getHi() {\n-        return hi;\n-    }\n-\n-    public int getLo() {\n-        return lo;\n-    }\n-\n-    public int getLine() {\n-        return line;\n-    }\n-\n-    public String getFullMethodName() {\n-        return fullMethodName;\n-    }\n-\n-    public String getFullMethodNameWithParams() {\n-        return fullMethodNameWithParams;\n-    }\n-\n-    public boolean isDeoptTarget() {\n-        return methodEntry.isDeopt();\n-    }\n-\n-    private String getExtendedMethodName(boolean includeClass, boolean includeParams, boolean includeReturnType) {\n-        StringBuilder builder = new StringBuilder();\n-        if (includeReturnType && methodEntry.valueType.typeName.length() > 0) {\n-            builder.append(methodEntry.valueType.typeName);\n-            builder.append(' ');\n-        }\n-        if (includeClass && getClassName() != null) {\n-            builder.append(getClassName());\n-            builder.append(CLASS_DELIMITER);\n-        }\n-        builder.append(getMethodName());\n-        if (includeParams) {\n-            builder.append('(');\n-            builder.append(String.join(\", \", methodEntry.paramNames));\n-            builder.append(')');\n-        }\n-        if (includeReturnType) {\n-            builder.append(\" \");\n-            builder.append(methodEntry.valueType.typeName);\n-        }\n-        return builder.toString();\n-    }\n-\n-    private String constructClassAndMethodName() {\n-        return getExtendedMethodName(true, false, false);\n-    }\n-\n-    private String constructClassAndMethodNameWithParams() {\n-        return getExtendedMethodName(true, true, false);\n-    }\n-\n-    public FileEntry getFileEntry() {\n-        return methodEntry.fileEntry;\n-    }\n-\n-    public int getModifiers() {\n-        return methodEntry.modifiers;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"Range(lo=0x%05x hi=0x%05x %s %s:%d)\", lo, hi, constructClassAndMethodNameWithParams(), methodEntry.getFullFileName(), line);\n-    }\n-\n-    public String getFileName() {\n-        return methodEntry.getFileName();\n-    }\n-\n-    public MethodEntry getMethodEntry() {\n-        return methodEntry;\n-    }\n-\n-    public boolean isInlined() {\n-        return isInlined;\n-    }\n-\n-    public Range getCaller() {\n-        return caller;\n-    }\n-\n-    public Range getFirstCallee() {\n-        return firstCallee;\n-    }\n-\n-    public Range getSiblingCallee() {\n-        return siblingCallee;\n-    }\n-\n-    public Range getLastCallee() {\n-        return lastCallee;\n-    }\n-\n-    public boolean isLeaf() {\n-        return firstCallee == null;\n-    }\n-\n-    public int getDepth() {\n-        return depth;\n-    }\n-\n-    /**\n-     * Minimizes the nodes in the tree that track the inline call hierarchy and associated code\n-     * ranges. The initial range tree models the call hierarchy as presented in the original debug\n-     * line info. It consists of a root node each of whose children is a sequence of linear call\n-     * chains, either a single leaf node for some given file and line or a series of inline calls to\n-     * such a leaf node. In this initial tree all node ranges in a given chain have the same lo and\n-     * hi address and chains are properly ordered by range The merge algorithm works across siblings\n-     * at successive depths starting at depth 1. Once all possible nodes at a given depth have been\n-     * merged their children can then be merged. A successor node may only be merged into its\n-     * predecessor if the nodes have contiguous ranges and idenitfy the same method, line and file.\n-     * The range and children of the merged node are, respectively, the union of the input ranges\n-     * and children. This preserves the invariant that child ranges lie within their parent range.\n-     *\n-     * @param debugContext\n-     */\n-    public void mergeSubranges(DebugContext debugContext) {\n-        Range next = getFirstCallee();\n-        if (next == null) {\n-            return;\n-        }\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Merge subranges [0x%x, 0x%x] %s\", lo, hi, getFullMethodNameWithParams());\n-        /* merge siblings together if possible, reparenting children to the merged node */\n-        while (next != null) {\n-            next = next.maybeMergeSibling(debugContext);\n-        }\n-        /* now recurse down to merge children of whatever nodes remain */\n-        next = getFirstCallee();\n-        /* now this level is merged recursively merge children of each child node. */\n-        while (next != null) {\n-            next.mergeSubranges(debugContext);\n-            next = next.getSiblingCallee();\n-        }\n-    }\n-\n-    /**\n-     * Removes and merges the next sibling returning the current node or it skips past the current\n-     * node as is and returns the next sibling or null if no sibling exists.\n-     */\n-    private Range maybeMergeSibling(DebugContext debugContext) {\n-        Range sibling = getSiblingCallee();\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Merge subrange (maybe) [0x%x, 0x%x] %s\", lo, hi, getFullMethodNameWithParams());\n-        if (sibling == null) {\n-            /* all child nodes at this level have been merged */\n-            return null;\n-        }\n-        if (hi < sibling.lo) {\n-            /* cannot merge non-contiguous ranges, move on. */\n-            return sibling;\n-        }\n-        if (getMethodEntry() != sibling.getMethodEntry()) {\n-            /* cannot merge distinct callers, move on. */\n-            return sibling;\n-        }\n-        if (getLine() != sibling.getLine()) {\n-            /* cannot merge callers with different line numbers, move on. */\n-            return sibling;\n-        }\n-        /* splice out the sibling from the chain and update this one to include it. */\n-        unlink(debugContext, sibling);\n-        /* relocate the siblings children to this node. */\n-        reparentChildren(debugContext, sibling);\n-        /* return the merged node so we can maybe merge it again. */\n-        return this;\n-    }\n-\n-    private void unlink(DebugContext debugContext, Range sibling) {\n-        assert hi == sibling.lo : String.format(\"gap in range [0x%x,0x%x] %s [0x%x,0x%x] %s\",\n-                        lo, hi, getFullMethodNameWithParams(), sibling.getLo(), sibling.getHi(), sibling.getFullMethodNameWithParams());\n-        assert this.isInlined == sibling.isInlined : String.format(\"change in inlined [0x%x,0x%x] %s %s [0x%x,0x%x] %s %s\",\n-                        lo, hi, getFullMethodNameWithParams(), Boolean.valueOf(this.isInlined), sibling.lo, sibling.hi, sibling.getFullMethodNameWithParams(), Boolean.valueOf(sibling.isInlined));\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Combining [0x%x, 0x%x] %s into [0x%x, 0x%x] %s\", sibling.lo, sibling.hi, sibling.getFullMethodName(), lo, hi, getFullMethodNameWithParams());\n-        this.hi = sibling.hi;\n-        this.siblingCallee = sibling.siblingCallee;\n-    }\n-\n-    private void reparentChildren(DebugContext debugContext, Range sibling) {\n-        Range siblingNext = sibling.getFirstCallee();\n-        while (siblingNext != null) {\n-            debugContext.log(DebugContext.INFO_LEVEL, \"Reparenting [0x%x, 0x%x] %s to [0x%x, 0x%x] %s\", siblingNext.lo, siblingNext.hi, siblingNext.getFullMethodName(), lo, hi,\n-                            getFullMethodNameWithParams());\n-            siblingNext.caller = this;\n-            Range newSiblingNext = siblingNext.siblingCallee;\n-            siblingNext.siblingCallee = null;\n-            addCallee(siblingNext);\n-            siblingNext = newSiblingNext;\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex dd82d22565b..af465363bbf 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -72,7 +71,6 @@ public class Range {\n         }\n         assert methodEntry != null;\n         this.methodEntry = methodEntry;\n-        this.symbolName = stringTable.uniqueString(symbolName);\n         this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n         this.lo = lo;\n         this.hi = hi;\n", "next_change": {"commit": "a658b95d63a93b1980e4ac81fd4c034c70b9d9cb", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex af465363bbf..5f7f3fe3bda 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -48,28 +47,19 @@ public class Range {\n     /*\n      * Create a primary range.\n      */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n-        this(stringTable, methodEntry, fileEntry, lo, hi, line, null);\n-    }\n-\n-    /*\n-     * Create a secondary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n-        this(stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line) {\n+        this(stringTable, methodEntry, lo, hi, line, null);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n-                    Range primary) {\n-        this.fileEntry = fileEntry;\n-        if (fileEntry != null) {\n-            stringTable.uniqueDebugString(fileEntry.getFileName());\n-            stringTable.uniqueDebugString(fileEntry.getPathName());\n-        }\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n         assert methodEntry != null;\n+        if (methodEntry.fileEntry != null) {\n+            stringTable.uniqueDebugString(methodEntry.fileEntry.getFileName());\n+            stringTable.uniqueDebugString(methodEntry.fileEntry.getPathName());\n+        }\n         this.methodEntry = methodEntry;\n         this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n         this.lo = lo;\n", "next_change": {"commit": "6fcf98378231f0e754061b683c3dba387ce8b0e9", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 5f7f3fe3bda..cc407a53acd 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -65,7 +68,10 @@ public class Range {\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n+        this.isInlined = isInline;\n         this.primary = primary;\n+        this.withChildren = withChildren;\n+        this.caller = caller;\n     }\n \n     public boolean contains(Range other) {\n", "next_change": {"commit": "abe98eaaa6dd772b7419b819fa342e810a0939e0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex cc407a53acd..037024f1755 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -71,6 +74,7 @@ public class Range {\n         this.isInlined = isInline;\n         this.primary = primary;\n         this.withChildren = withChildren;\n+        this.withInlinedChildren = false;\n         this.caller = caller;\n     }\n \n", "next_change": {"commit": "268c33256b26217c50339f452adea942fb48818f", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 037024f1755..1951241dda1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -73,9 +93,32 @@ public class Range {\n         this.line = line;\n         this.isInlined = isInline;\n         this.primary = primary;\n-        this.withChildren = withChildren;\n-        this.withInlinedChildren = false;\n+        this.firstCallee = null;\n+        this.lastCallee = null;\n+        this.nextCallee = null;\n         this.caller = caller;\n+        if (caller != null) {\n+            caller.addCallee(this);\n+        }\n+        if (this.isPrimary()) {\n+            this.depth = -1;\n+        } else {\n+            this.depth = caller.depth + 1;\n+        }\n+    }\n+\n+    private void addCallee(Range callee) {\n+        assert this.lo <= callee.lo;\n+        assert this.hi >= callee.hi;\n+        assert callee.caller == this;\n+        assert callee.nextCallee == null;\n+        if (this.firstCallee == null) {\n+            assert this.lastCallee == null;\n+            this.firstCallee = this.lastCallee = callee;\n+        } else {\n+            this.lastCallee.nextCallee = callee;\n+            this.lastCallee = callee;\n+        }\n     }\n \n     public boolean contains(Range other) {\n", "next_change": {"commit": "6ae5665ec0f5f89ff4a7804dbeec25c85d0982ea", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 1951241dda1..43c64a540e9 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -111,12 +111,12 @@ public class Range {\n         assert this.lo <= callee.lo;\n         assert this.hi >= callee.hi;\n         assert callee.caller == this;\n-        assert callee.nextCallee == null;\n+        assert callee.siblingCallee == null;\n         if (this.firstCallee == null) {\n             assert this.lastCallee == null;\n             this.firstCallee = this.lastCallee = callee;\n         } else {\n-            this.lastCallee.nextCallee = callee;\n+            this.lastCallee.siblingCallee = callee;\n             this.lastCallee = callee;\n         }\n     }\n", "next_change": {"commit": "9acf1c5d597e38f3e832360ce3f372ad94b16e9e", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\ndeleted file mode 100644\nindex 43c64a540e9..00000000000\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ /dev/null\n", "chunk": "@@ -1,339 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.objectfile.debugentry;\n-\n-import org.graalvm.compiler.debug.DebugContext;\n-\n-/**\n- * Details of a specific address range in a compiled method either a primary range identifying a\n- * whole method or a sub-range identifying a sequence of instructions that belong to an inlined\n- * method. Each sub-range is linked with its caller and its callees, forming a call tree.\n- */\n-public class Range {\n-    private static final String CLASS_DELIMITER = \".\";\n-    private Range caller;\n-    private final MethodEntry methodEntry;\n-    private final String fullMethodName;\n-    private final String fullMethodNameWithParams;\n-    private final int lo;\n-    private int hi;\n-    private final int line;\n-    private final boolean isInlined;\n-    private final int depth;\n-    /**\n-     * This is null for a primary range. For sub ranges it holds the root of the call tree they\n-     * belong to.\n-     */\n-    private final Range primary;\n-\n-    /*\n-     * Support for tree of nested inline callee ranges\n-     */\n-\n-    /**\n-     * The first direct callee whose range is wholly contained in this range.\n-     */\n-    private Range firstCallee;\n-\n-    /**\n-     * The last direct callee whose range is wholly contained in this range.\n-     */\n-    private Range lastCallee;\n-\n-    /**\n-     * A link to a sibling callee, i.e., a range sharing the same caller with this range.\n-     */\n-    private Range siblingCallee;\n-\n-    /*\n-     * Create a primary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line) {\n-        this(stringTable, methodEntry, lo, hi, line, null, false, null);\n-    }\n-\n-    /*\n-     * Create a primary or secondary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary, boolean isInline, Range caller) {\n-        assert methodEntry != null;\n-        if (methodEntry.fileEntry != null) {\n-            stringTable.uniqueDebugString(methodEntry.fileEntry.getFileName());\n-            stringTable.uniqueDebugString(methodEntry.fileEntry.getPathName());\n-        }\n-        this.methodEntry = methodEntry;\n-        this.fullMethodName = isInline ? stringTable.uniqueDebugString(constructClassAndMethodName()) : stringTable.uniqueString(constructClassAndMethodName());\n-        this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n-        this.lo = lo;\n-        this.hi = hi;\n-        this.line = line;\n-        this.isInlined = isInline;\n-        this.primary = primary;\n-        this.firstCallee = null;\n-        this.lastCallee = null;\n-        this.siblingCallee = null;\n-        this.caller = caller;\n-        if (caller != null) {\n-            caller.addCallee(this);\n-        }\n-        if (this.isPrimary()) {\n-            this.depth = -1;\n-        } else {\n-            this.depth = caller.depth + 1;\n-        }\n-    }\n-\n-    private void addCallee(Range callee) {\n-        assert this.lo <= callee.lo;\n-        assert this.hi >= callee.hi;\n-        assert callee.caller == this;\n-        assert callee.siblingCallee == null;\n-        if (this.firstCallee == null) {\n-            assert this.lastCallee == null;\n-            this.firstCallee = this.lastCallee = callee;\n-        } else {\n-            this.lastCallee.siblingCallee = callee;\n-            this.lastCallee = callee;\n-        }\n-    }\n-\n-    public boolean contains(Range other) {\n-        return (lo <= other.lo && hi >= other.hi);\n-    }\n-\n-    public boolean isPrimary() {\n-        return getPrimary() == null;\n-    }\n-\n-    public Range getPrimary() {\n-        return primary;\n-    }\n-\n-    public String getClassName() {\n-        return methodEntry.ownerType.typeName;\n-    }\n-\n-    public String getMethodName() {\n-        return methodEntry.memberName;\n-    }\n-\n-    public String getSymbolName() {\n-        return methodEntry.getSymbolName();\n-    }\n-\n-    public int getHi() {\n-        return hi;\n-    }\n-\n-    public int getLo() {\n-        return lo;\n-    }\n-\n-    public int getLine() {\n-        return line;\n-    }\n-\n-    public String getFullMethodName() {\n-        return fullMethodName;\n-    }\n-\n-    public String getFullMethodNameWithParams() {\n-        return fullMethodNameWithParams;\n-    }\n-\n-    public boolean isDeoptTarget() {\n-        return methodEntry.isDeopt();\n-    }\n-\n-    private String getExtendedMethodName(boolean includeClass, boolean includeParams, boolean includeReturnType) {\n-        StringBuilder builder = new StringBuilder();\n-        if (includeReturnType && methodEntry.valueType.typeName.length() > 0) {\n-            builder.append(methodEntry.valueType.typeName);\n-            builder.append(' ');\n-        }\n-        if (includeClass && getClassName() != null) {\n-            builder.append(getClassName());\n-            builder.append(CLASS_DELIMITER);\n-        }\n-        builder.append(getMethodName());\n-        if (includeParams) {\n-            builder.append('(');\n-            builder.append(String.join(\", \", methodEntry.paramNames));\n-            builder.append(')');\n-        }\n-        if (includeReturnType) {\n-            builder.append(\" \");\n-            builder.append(methodEntry.valueType.typeName);\n-        }\n-        return builder.toString();\n-    }\n-\n-    private String constructClassAndMethodName() {\n-        return getExtendedMethodName(true, false, false);\n-    }\n-\n-    private String constructClassAndMethodNameWithParams() {\n-        return getExtendedMethodName(true, true, false);\n-    }\n-\n-    public FileEntry getFileEntry() {\n-        return methodEntry.fileEntry;\n-    }\n-\n-    public int getModifiers() {\n-        return methodEntry.modifiers;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"Range(lo=0x%05x hi=0x%05x %s %s:%d)\", lo, hi, constructClassAndMethodNameWithParams(), methodEntry.getFullFileName(), line);\n-    }\n-\n-    public String getFileName() {\n-        return methodEntry.getFileName();\n-    }\n-\n-    public MethodEntry getMethodEntry() {\n-        return methodEntry;\n-    }\n-\n-    public boolean isInlined() {\n-        return isInlined;\n-    }\n-\n-    public Range getCaller() {\n-        return caller;\n-    }\n-\n-    public Range getFirstCallee() {\n-        return firstCallee;\n-    }\n-\n-    public Range getSiblingCallee() {\n-        return siblingCallee;\n-    }\n-\n-    public Range getLastCallee() {\n-        return lastCallee;\n-    }\n-\n-    public boolean isLeaf() {\n-        return firstCallee == null;\n-    }\n-\n-    public int getDepth() {\n-        return depth;\n-    }\n-\n-    /**\n-     * Minimizes the nodes in the tree that track the inline call hierarchy and associated code\n-     * ranges. The initial range tree models the call hierarchy as presented in the original debug\n-     * line info. It consists of a root node each of whose children is a sequence of linear call\n-     * chains, either a single leaf node for some given file and line or a series of inline calls to\n-     * such a leaf node. In this initial tree all node ranges in a given chain have the same lo and\n-     * hi address and chains are properly ordered by range The merge algorithm works across siblings\n-     * at successive depths starting at depth 1. Once all possible nodes at a given depth have been\n-     * merged their children can then be merged. A successor node may only be merged into its\n-     * predecessor if the nodes have contiguous ranges and idenitfy the same method, line and file.\n-     * The range and children of the merged node are, respectively, the union of the input ranges\n-     * and children. This preserves the invariant that child ranges lie within their parent range.\n-     *\n-     * @param debugContext\n-     */\n-    public void mergeSubranges(DebugContext debugContext) {\n-        Range next = getFirstCallee();\n-        if (next == null) {\n-            return;\n-        }\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Merge subranges [0x%x, 0x%x] %s\", lo, hi, getFullMethodNameWithParams());\n-        /* merge siblings together if possible, reparenting children to the merged node */\n-        while (next != null) {\n-            next = next.maybeMergeSibling(debugContext);\n-        }\n-        /* now recurse down to merge children of whatever nodes remain */\n-        next = getFirstCallee();\n-        /* now this level is merged recursively merge children of each child node. */\n-        while (next != null) {\n-            next.mergeSubranges(debugContext);\n-            next = next.getSiblingCallee();\n-        }\n-    }\n-\n-    /**\n-     * Removes and merges the next sibling returning the current node or it skips past the current\n-     * node as is and returns the next sibling or null if no sibling exists.\n-     */\n-    private Range maybeMergeSibling(DebugContext debugContext) {\n-        Range sibling = getSiblingCallee();\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Merge subrange (maybe) [0x%x, 0x%x] %s\", lo, hi, getFullMethodNameWithParams());\n-        if (sibling == null) {\n-            /* all child nodes at this level have been merged */\n-            return null;\n-        }\n-        if (hi < sibling.lo) {\n-            /* cannot merge non-contiguous ranges, move on. */\n-            return sibling;\n-        }\n-        if (getMethodEntry() != sibling.getMethodEntry()) {\n-            /* cannot merge distinct callers, move on. */\n-            return sibling;\n-        }\n-        if (getLine() != sibling.getLine()) {\n-            /* cannot merge callers with different line numbers, move on. */\n-            return sibling;\n-        }\n-        /* splice out the sibling from the chain and update this one to include it. */\n-        unlink(debugContext, sibling);\n-        /* relocate the siblings children to this node. */\n-        reparentChildren(debugContext, sibling);\n-        /* return the merged node so we can maybe merge it again. */\n-        return this;\n-    }\n-\n-    private void unlink(DebugContext debugContext, Range sibling) {\n-        assert hi == sibling.lo : String.format(\"gap in range [0x%x,0x%x] %s [0x%x,0x%x] %s\",\n-                        lo, hi, getFullMethodNameWithParams(), sibling.getLo(), sibling.getHi(), sibling.getFullMethodNameWithParams());\n-        assert this.isInlined == sibling.isInlined : String.format(\"change in inlined [0x%x,0x%x] %s %s [0x%x,0x%x] %s %s\",\n-                        lo, hi, getFullMethodNameWithParams(), Boolean.valueOf(this.isInlined), sibling.lo, sibling.hi, sibling.getFullMethodNameWithParams(), Boolean.valueOf(sibling.isInlined));\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Combining [0x%x, 0x%x] %s into [0x%x, 0x%x] %s\", sibling.lo, sibling.hi, sibling.getFullMethodName(), lo, hi, getFullMethodNameWithParams());\n-        this.hi = sibling.hi;\n-        this.siblingCallee = sibling.siblingCallee;\n-    }\n-\n-    private void reparentChildren(DebugContext debugContext, Range sibling) {\n-        Range siblingNext = sibling.getFirstCallee();\n-        while (siblingNext != null) {\n-            debugContext.log(DebugContext.INFO_LEVEL, \"Reparenting [0x%x, 0x%x] %s to [0x%x, 0x%x] %s\", siblingNext.lo, siblingNext.hi, siblingNext.getFullMethodName(), lo, hi,\n-                            getFullMethodNameWithParams());\n-            siblingNext.caller = this;\n-            Range newSiblingNext = siblingNext.siblingCallee;\n-            siblingNext.siblingCallee = null;\n-            addCallee(siblingNext);\n-            siblingNext = newSiblingNext;\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex d2060e4afd6..9bea361bef6 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -55,41 +50,36 @@ public class Range {\n     /*\n      * Create a primary range.\n      */\n-    public Range(String className, String methodName, String symbolName, String paramSignature, String returnTypeName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n-                    int modifiers, boolean isDeoptTarget) {\n-        this(className, methodName, symbolName, paramSignature, returnTypeName, stringTable, fileEntry, lo, hi, line, modifiers, isDeoptTarget, null);\n+    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n+                 boolean isDeoptTarget) {\n+        this(symbolName, stringTable, methodEntry, fileEntry, lo, hi, line, isDeoptTarget, null);\n     }\n \n     /*\n      * Create a secondary range.\n      */\n-    public Range(String className, String methodName, String symbolName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n-                    Range primary) {\n-        this(className, methodName, symbolName, \"\", \"\", stringTable, fileEntry, lo, hi, line, 0, false, primary);\n+    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n+        this(symbolName, stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, false, primary);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(String className, String methodName, String symbolName, String paramSignature, String returnTypeName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n-                    int modifiers, boolean isDeoptTarget, Range primary) {\n-        this.fileEntry = fileEntry;\n+    private Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n+                    boolean isDeoptTarget, Range primary) {\n+        this.fileEntry = fileEntry; // TODO remove and use fileEntry from MethodEntry\n         if (fileEntry != null) {\n             stringTable.uniqueDebugString(fileEntry.getFileName());\n             stringTable.uniqueDebugString(fileEntry.getPathName());\n         }\n-        this.className = stringTable.uniqueString(className);\n-        this.methodName = stringTable.uniqueString(methodName);\n+        assert methodEntry != null;\n+        this.methodEntry = methodEntry;\n         this.symbolName = stringTable.uniqueString(symbolName);\n-        this.paramSignature = stringTable.uniqueString(paramSignature);\n-        this.returnTypeName = stringTable.uniqueString(returnTypeName);\n-        this.fullMethodName = stringTable.uniqueString(constructClassAndMethodName());\n         this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n         this.isDeoptTarget = isDeoptTarget;\n-        this.modifiers = modifiers;\n         this.primary = primary;\n     }\n \n", "next_change": {"commit": "f485a3c15f5e29daf480657c0bfa22662f8005ae", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 9bea361bef6..a3d6e1c0db2 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -79,7 +77,6 @@ public class Range {\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n-        this.isDeoptTarget = isDeoptTarget;\n         this.primary = primary;\n     }\n \n", "next_change": {"commit": "dbb2c7607429817e58a1a9af8012e25e861368dc", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex a3d6e1c0db2..af465363bbf 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -49,30 +48,29 @@ public class Range {\n     /*\n      * Create a primary range.\n      */\n-    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n-        this(symbolName, stringTable, methodEntry, fileEntry, lo, hi, line, null);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n+        this(stringTable, methodEntry, fileEntry, lo, hi, line, null);\n     }\n \n     /*\n      * Create a secondary range.\n      */\n-    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n-        this(symbolName, stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n+        this(stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n+    private Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n                     Range primary) {\n-        this.fileEntry = fileEntry; // TODO remove and use fileEntry from MethodEntry\n+        this.fileEntry = fileEntry;\n         if (fileEntry != null) {\n             stringTable.uniqueDebugString(fileEntry.getFileName());\n             stringTable.uniqueDebugString(fileEntry.getPathName());\n         }\n         assert methodEntry != null;\n         this.methodEntry = methodEntry;\n-        this.symbolName = stringTable.uniqueString(symbolName);\n         this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n         this.lo = lo;\n         this.hi = hi;\n", "next_change": {"commit": "a658b95d63a93b1980e4ac81fd4c034c70b9d9cb", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex af465363bbf..5f7f3fe3bda 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -48,28 +47,19 @@ public class Range {\n     /*\n      * Create a primary range.\n      */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n-        this(stringTable, methodEntry, fileEntry, lo, hi, line, null);\n-    }\n-\n-    /*\n-     * Create a secondary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n-        this(stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line) {\n+        this(stringTable, methodEntry, lo, hi, line, null);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n-                    Range primary) {\n-        this.fileEntry = fileEntry;\n-        if (fileEntry != null) {\n-            stringTable.uniqueDebugString(fileEntry.getFileName());\n-            stringTable.uniqueDebugString(fileEntry.getPathName());\n-        }\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n         assert methodEntry != null;\n+        if (methodEntry.fileEntry != null) {\n+            stringTable.uniqueDebugString(methodEntry.fileEntry.getFileName());\n+            stringTable.uniqueDebugString(methodEntry.fileEntry.getPathName());\n+        }\n         this.methodEntry = methodEntry;\n         this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n         this.lo = lo;\n", "next_change": {"commit": "6fcf98378231f0e754061b683c3dba387ce8b0e9", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 5f7f3fe3bda..cc407a53acd 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -65,7 +68,10 @@ public class Range {\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n+        this.isInlined = isInline;\n         this.primary = primary;\n+        this.withChildren = withChildren;\n+        this.caller = caller;\n     }\n \n     public boolean contains(Range other) {\n", "next_change": {"commit": "abe98eaaa6dd772b7419b819fa342e810a0939e0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex cc407a53acd..037024f1755 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -71,6 +74,7 @@ public class Range {\n         this.isInlined = isInline;\n         this.primary = primary;\n         this.withChildren = withChildren;\n+        this.withInlinedChildren = false;\n         this.caller = caller;\n     }\n \n", "next_change": {"commit": "268c33256b26217c50339f452adea942fb48818f", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 037024f1755..1951241dda1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -73,9 +93,32 @@ public class Range {\n         this.line = line;\n         this.isInlined = isInline;\n         this.primary = primary;\n-        this.withChildren = withChildren;\n-        this.withInlinedChildren = false;\n+        this.firstCallee = null;\n+        this.lastCallee = null;\n+        this.nextCallee = null;\n         this.caller = caller;\n+        if (caller != null) {\n+            caller.addCallee(this);\n+        }\n+        if (this.isPrimary()) {\n+            this.depth = -1;\n+        } else {\n+            this.depth = caller.depth + 1;\n+        }\n+    }\n+\n+    private void addCallee(Range callee) {\n+        assert this.lo <= callee.lo;\n+        assert this.hi >= callee.hi;\n+        assert callee.caller == this;\n+        assert callee.nextCallee == null;\n+        if (this.firstCallee == null) {\n+            assert this.lastCallee == null;\n+            this.firstCallee = this.lastCallee = callee;\n+        } else {\n+            this.lastCallee.nextCallee = callee;\n+            this.lastCallee = callee;\n+        }\n     }\n \n     public boolean contains(Range other) {\n", "next_change": {"commit": "6ae5665ec0f5f89ff4a7804dbeec25c85d0982ea", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 1951241dda1..43c64a540e9 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -111,12 +111,12 @@ public class Range {\n         assert this.lo <= callee.lo;\n         assert this.hi >= callee.hi;\n         assert callee.caller == this;\n-        assert callee.nextCallee == null;\n+        assert callee.siblingCallee == null;\n         if (this.firstCallee == null) {\n             assert this.lastCallee == null;\n             this.firstCallee = this.lastCallee = callee;\n         } else {\n-            this.lastCallee.nextCallee = callee;\n+            this.lastCallee.siblingCallee = callee;\n             this.lastCallee = callee;\n         }\n     }\n", "next_change": {"commit": "9acf1c5d597e38f3e832360ce3f372ad94b16e9e", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\ndeleted file mode 100644\nindex 43c64a540e9..00000000000\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ /dev/null\n", "chunk": "@@ -1,339 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.objectfile.debugentry;\n-\n-import org.graalvm.compiler.debug.DebugContext;\n-\n-/**\n- * Details of a specific address range in a compiled method either a primary range identifying a\n- * whole method or a sub-range identifying a sequence of instructions that belong to an inlined\n- * method. Each sub-range is linked with its caller and its callees, forming a call tree.\n- */\n-public class Range {\n-    private static final String CLASS_DELIMITER = \".\";\n-    private Range caller;\n-    private final MethodEntry methodEntry;\n-    private final String fullMethodName;\n-    private final String fullMethodNameWithParams;\n-    private final int lo;\n-    private int hi;\n-    private final int line;\n-    private final boolean isInlined;\n-    private final int depth;\n-    /**\n-     * This is null for a primary range. For sub ranges it holds the root of the call tree they\n-     * belong to.\n-     */\n-    private final Range primary;\n-\n-    /*\n-     * Support for tree of nested inline callee ranges\n-     */\n-\n-    /**\n-     * The first direct callee whose range is wholly contained in this range.\n-     */\n-    private Range firstCallee;\n-\n-    /**\n-     * The last direct callee whose range is wholly contained in this range.\n-     */\n-    private Range lastCallee;\n-\n-    /**\n-     * A link to a sibling callee, i.e., a range sharing the same caller with this range.\n-     */\n-    private Range siblingCallee;\n-\n-    /*\n-     * Create a primary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line) {\n-        this(stringTable, methodEntry, lo, hi, line, null, false, null);\n-    }\n-\n-    /*\n-     * Create a primary or secondary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary, boolean isInline, Range caller) {\n-        assert methodEntry != null;\n-        if (methodEntry.fileEntry != null) {\n-            stringTable.uniqueDebugString(methodEntry.fileEntry.getFileName());\n-            stringTable.uniqueDebugString(methodEntry.fileEntry.getPathName());\n-        }\n-        this.methodEntry = methodEntry;\n-        this.fullMethodName = isInline ? stringTable.uniqueDebugString(constructClassAndMethodName()) : stringTable.uniqueString(constructClassAndMethodName());\n-        this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n-        this.lo = lo;\n-        this.hi = hi;\n-        this.line = line;\n-        this.isInlined = isInline;\n-        this.primary = primary;\n-        this.firstCallee = null;\n-        this.lastCallee = null;\n-        this.siblingCallee = null;\n-        this.caller = caller;\n-        if (caller != null) {\n-            caller.addCallee(this);\n-        }\n-        if (this.isPrimary()) {\n-            this.depth = -1;\n-        } else {\n-            this.depth = caller.depth + 1;\n-        }\n-    }\n-\n-    private void addCallee(Range callee) {\n-        assert this.lo <= callee.lo;\n-        assert this.hi >= callee.hi;\n-        assert callee.caller == this;\n-        assert callee.siblingCallee == null;\n-        if (this.firstCallee == null) {\n-            assert this.lastCallee == null;\n-            this.firstCallee = this.lastCallee = callee;\n-        } else {\n-            this.lastCallee.siblingCallee = callee;\n-            this.lastCallee = callee;\n-        }\n-    }\n-\n-    public boolean contains(Range other) {\n-        return (lo <= other.lo && hi >= other.hi);\n-    }\n-\n-    public boolean isPrimary() {\n-        return getPrimary() == null;\n-    }\n-\n-    public Range getPrimary() {\n-        return primary;\n-    }\n-\n-    public String getClassName() {\n-        return methodEntry.ownerType.typeName;\n-    }\n-\n-    public String getMethodName() {\n-        return methodEntry.memberName;\n-    }\n-\n-    public String getSymbolName() {\n-        return methodEntry.getSymbolName();\n-    }\n-\n-    public int getHi() {\n-        return hi;\n-    }\n-\n-    public int getLo() {\n-        return lo;\n-    }\n-\n-    public int getLine() {\n-        return line;\n-    }\n-\n-    public String getFullMethodName() {\n-        return fullMethodName;\n-    }\n-\n-    public String getFullMethodNameWithParams() {\n-        return fullMethodNameWithParams;\n-    }\n-\n-    public boolean isDeoptTarget() {\n-        return methodEntry.isDeopt();\n-    }\n-\n-    private String getExtendedMethodName(boolean includeClass, boolean includeParams, boolean includeReturnType) {\n-        StringBuilder builder = new StringBuilder();\n-        if (includeReturnType && methodEntry.valueType.typeName.length() > 0) {\n-            builder.append(methodEntry.valueType.typeName);\n-            builder.append(' ');\n-        }\n-        if (includeClass && getClassName() != null) {\n-            builder.append(getClassName());\n-            builder.append(CLASS_DELIMITER);\n-        }\n-        builder.append(getMethodName());\n-        if (includeParams) {\n-            builder.append('(');\n-            builder.append(String.join(\", \", methodEntry.paramNames));\n-            builder.append(')');\n-        }\n-        if (includeReturnType) {\n-            builder.append(\" \");\n-            builder.append(methodEntry.valueType.typeName);\n-        }\n-        return builder.toString();\n-    }\n-\n-    private String constructClassAndMethodName() {\n-        return getExtendedMethodName(true, false, false);\n-    }\n-\n-    private String constructClassAndMethodNameWithParams() {\n-        return getExtendedMethodName(true, true, false);\n-    }\n-\n-    public FileEntry getFileEntry() {\n-        return methodEntry.fileEntry;\n-    }\n-\n-    public int getModifiers() {\n-        return methodEntry.modifiers;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"Range(lo=0x%05x hi=0x%05x %s %s:%d)\", lo, hi, constructClassAndMethodNameWithParams(), methodEntry.getFullFileName(), line);\n-    }\n-\n-    public String getFileName() {\n-        return methodEntry.getFileName();\n-    }\n-\n-    public MethodEntry getMethodEntry() {\n-        return methodEntry;\n-    }\n-\n-    public boolean isInlined() {\n-        return isInlined;\n-    }\n-\n-    public Range getCaller() {\n-        return caller;\n-    }\n-\n-    public Range getFirstCallee() {\n-        return firstCallee;\n-    }\n-\n-    public Range getSiblingCallee() {\n-        return siblingCallee;\n-    }\n-\n-    public Range getLastCallee() {\n-        return lastCallee;\n-    }\n-\n-    public boolean isLeaf() {\n-        return firstCallee == null;\n-    }\n-\n-    public int getDepth() {\n-        return depth;\n-    }\n-\n-    /**\n-     * Minimizes the nodes in the tree that track the inline call hierarchy and associated code\n-     * ranges. The initial range tree models the call hierarchy as presented in the original debug\n-     * line info. It consists of a root node each of whose children is a sequence of linear call\n-     * chains, either a single leaf node for some given file and line or a series of inline calls to\n-     * such a leaf node. In this initial tree all node ranges in a given chain have the same lo and\n-     * hi address and chains are properly ordered by range The merge algorithm works across siblings\n-     * at successive depths starting at depth 1. Once all possible nodes at a given depth have been\n-     * merged their children can then be merged. A successor node may only be merged into its\n-     * predecessor if the nodes have contiguous ranges and idenitfy the same method, line and file.\n-     * The range and children of the merged node are, respectively, the union of the input ranges\n-     * and children. This preserves the invariant that child ranges lie within their parent range.\n-     *\n-     * @param debugContext\n-     */\n-    public void mergeSubranges(DebugContext debugContext) {\n-        Range next = getFirstCallee();\n-        if (next == null) {\n-            return;\n-        }\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Merge subranges [0x%x, 0x%x] %s\", lo, hi, getFullMethodNameWithParams());\n-        /* merge siblings together if possible, reparenting children to the merged node */\n-        while (next != null) {\n-            next = next.maybeMergeSibling(debugContext);\n-        }\n-        /* now recurse down to merge children of whatever nodes remain */\n-        next = getFirstCallee();\n-        /* now this level is merged recursively merge children of each child node. */\n-        while (next != null) {\n-            next.mergeSubranges(debugContext);\n-            next = next.getSiblingCallee();\n-        }\n-    }\n-\n-    /**\n-     * Removes and merges the next sibling returning the current node or it skips past the current\n-     * node as is and returns the next sibling or null if no sibling exists.\n-     */\n-    private Range maybeMergeSibling(DebugContext debugContext) {\n-        Range sibling = getSiblingCallee();\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Merge subrange (maybe) [0x%x, 0x%x] %s\", lo, hi, getFullMethodNameWithParams());\n-        if (sibling == null) {\n-            /* all child nodes at this level have been merged */\n-            return null;\n-        }\n-        if (hi < sibling.lo) {\n-            /* cannot merge non-contiguous ranges, move on. */\n-            return sibling;\n-        }\n-        if (getMethodEntry() != sibling.getMethodEntry()) {\n-            /* cannot merge distinct callers, move on. */\n-            return sibling;\n-        }\n-        if (getLine() != sibling.getLine()) {\n-            /* cannot merge callers with different line numbers, move on. */\n-            return sibling;\n-        }\n-        /* splice out the sibling from the chain and update this one to include it. */\n-        unlink(debugContext, sibling);\n-        /* relocate the siblings children to this node. */\n-        reparentChildren(debugContext, sibling);\n-        /* return the merged node so we can maybe merge it again. */\n-        return this;\n-    }\n-\n-    private void unlink(DebugContext debugContext, Range sibling) {\n-        assert hi == sibling.lo : String.format(\"gap in range [0x%x,0x%x] %s [0x%x,0x%x] %s\",\n-                        lo, hi, getFullMethodNameWithParams(), sibling.getLo(), sibling.getHi(), sibling.getFullMethodNameWithParams());\n-        assert this.isInlined == sibling.isInlined : String.format(\"change in inlined [0x%x,0x%x] %s %s [0x%x,0x%x] %s %s\",\n-                        lo, hi, getFullMethodNameWithParams(), Boolean.valueOf(this.isInlined), sibling.lo, sibling.hi, sibling.getFullMethodNameWithParams(), Boolean.valueOf(sibling.isInlined));\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Combining [0x%x, 0x%x] %s into [0x%x, 0x%x] %s\", sibling.lo, sibling.hi, sibling.getFullMethodName(), lo, hi, getFullMethodNameWithParams());\n-        this.hi = sibling.hi;\n-        this.siblingCallee = sibling.siblingCallee;\n-    }\n-\n-    private void reparentChildren(DebugContext debugContext, Range sibling) {\n-        Range siblingNext = sibling.getFirstCallee();\n-        while (siblingNext != null) {\n-            debugContext.log(DebugContext.INFO_LEVEL, \"Reparenting [0x%x, 0x%x] %s to [0x%x, 0x%x] %s\", siblingNext.lo, siblingNext.hi, siblingNext.getFullMethodName(), lo, hi,\n-                            getFullMethodNameWithParams());\n-            siblingNext.caller = this;\n-            Range newSiblingNext = siblingNext.siblingCallee;\n-            siblingNext.siblingCallee = null;\n-            addCallee(siblingNext);\n-            siblingNext = newSiblingNext;\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE3NTU3Mw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457175573", "body": "@stooke please fix all your comments.\r\n\r\n- Use of `//` is discouraged.\r\n- Comments almost always start with an uppercase letter in our codebase\r\n- Merge consecutive comment blocks (like this one) (no `*/` immediately followed by `/*`)\r\nIf you want to prevent eclipseformat  to mess with your comment formatting start your comments with `/*-`.\r\n\r\nPlease clean up your commit log.\r\n- Squash commits together were possible (use `git rebase --interactive origin/master`)\r\n- Commit messages should start with an uppercase letter and should not contain spelling errors.", "bodyText": "@stooke please fix all your comments.\n\nUse of // is discouraged.\nComments almost always start with an uppercase letter in our codebase\nMerge consecutive comment blocks (like this one) (no */ immediately followed by /*)\nIf you want to prevent eclipseformat  to mess with your comment formatting start your comments with /*-.\n\nPlease clean up your commit log.\n\nSquash commits together were possible (use git rebase --interactive origin/master)\nCommit messages should start with an uppercase letter and should not contain spelling errors.", "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/stooke/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/stooke\">@stooke</a> please fix all your comments.</p>\n<ul dir=\"auto\">\n<li>Use of <code>//</code> is discouraged.</li>\n<li>Comments almost always start with an uppercase letter in our codebase</li>\n<li>Merge consecutive comment blocks (like this one) (no <code>*/</code> immediately followed by <code>/*</code>)<br>\nIf you want to prevent eclipseformat  to mess with your comment formatting start your comments with <code>/*-</code>.</li>\n</ul>\n<p dir=\"auto\">Please clean up your commit log.</p>\n<ul dir=\"auto\">\n<li>Squash commits together were possible (use <code>git rebase --interactive origin/master</code>)</li>\n<li>Commit messages should start with an uppercase letter and should not contain spelling errors.</li>\n</ul>", "author": "olpaw", "createdAt": "2020-07-20T08:32:23Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVFileRecord.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+\n+import java.io.PrintStream;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Paths;\n+import java.security.MessageDigest;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+final class CVFileRecord extends CVSymbolRecord {\n+\n+    private static final byte CHECKSUM_NONE = 0x00;\n+    private static final byte CHECKSUM_MD5 = 0x01;\n+    private static final byte CB_VALUE = 0x10;\n+\n+    private static final int FILE_RECORD_LENGTH = 24;\n+\n+    private static final int CHECKSUM_LENGTH = 16;\n+    private static final byte[] EMPTY_CHECKSUM = new byte[CHECKSUM_LENGTH];\n+\n+    private static final int FILE_TABLE_INITIAL_SIZE = 200;\n+\n+    private final CVSymbolSectionImpl.CVStringTable strings;\n+\n+    private int currentOffset = 0;\n+    private Map<FileEntry, Integer> fileEntryToOffsetMap = new LinkedHashMap<>(FILE_TABLE_INITIAL_SIZE);\n+\n+    CVFileRecord(CVDebugInfo cvDebugInfo, CVSymbolSectionImpl.CVStringTable strings) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_FILECHKSMS);\n+        this.strings = strings;\n+    }\n+\n+    /**\n+     * Convert a FileEntry to a path. Avoid an NPE if there's no DirEntry.\n+     *\n+     * @param fileEntry\n+     * @return path string, including directory if it exists.\n+     */\n+    private static String fixPath(FileEntry fileEntry) {\n+        return fileEntry.getDirEntry() != null ? fileEntry.getFullName() : fileEntry.getFileName();\n+    }\n+\n+    int addFile(FileEntry entry) {\n+        if (fileEntryToOffsetMap.containsKey(entry)) {\n+            return fileEntryToOffsetMap.get(entry);\n+        } else {\n+            fileEntryToOffsetMap.put(entry, currentOffset);\n+            /* create required stringtable entry */\n+            strings.add(fixPath(entry));\n+            currentOffset += FILE_RECORD_LENGTH;\n+            return currentOffset - FILE_RECORD_LENGTH;\n+        }\n+    }\n+\n+    @Override\n+    public int computeSize(int initialPos) {\n+        /* add all fileEntries; duplicates are ignored */", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYzODM3Mw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456638373", "body": "These don't seem to be used anywhere but in the `myValues` array below.", "bodyText": "These don't seem to be used anywhere but in the myValues array below.", "bodyHTML": "<p dir=\"auto\">These don't seem to be used anywhere but in the <code>myValues</code> array below.</p>", "author": "pejovica", "createdAt": "2020-07-17T19:38:50Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/SectionName.java", "diffHunk": "@@ -94,11 +94,14 @@ public String getFormatDependentName(Format f) {\n     public static final SectionName APPLE_NAMESPACE = new ProgbitsSectionName(\"apple_namespac\");\n     public static final SectionName APPLE_OBJC = new ProgbitsSectionName(\"apple_objc\");\n     public static final SectionName LLVM_STACKMAPS = new ProgbitsSectionName(\"llvm_stackmaps\");\n+    // Windows PECOFF CodeView 4 debug sections\n+    public static final SectionName CV4_DEBUG_SYMBOLS = new ProgbitsSectionName(\"debug$S\");\n+    public static final SectionName CV4_DEBUG_TYPES = new ProgbitsSectionName(\"debug$T\");", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5MzY2Mw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457693663", "bodyText": "These constants are removed.  (The Apple constants have the same issue so I thought this was appropriate).\nIf PECOFF on arm64 is ever implemented, they'll go back and be used elsewhere.\nIf you have specific TODOs you'd like to see implemented before this is pushed, please let me know.  A number need to wait until I implement type records.", "author": "stooke", "createdAt": "2020-07-20T21:10:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYzODM3Mw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY0NDY2Ng==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456644666", "body": "Unused method.", "bodyText": "Unused method.", "bodyHTML": "<p dir=\"auto\">Unused method.</p>", "author": "pejovica", "createdAt": "2020-07-17T19:52:53Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java", "diffHunk": "@@ -93,6 +94,16 @@ private Range(String fileName, Path filePath, Path cachePath, String className,\n         this.primary = primary;\n     }\n \n+    /*\n+     * Create a copy of a Range with a different lo/hi code range.\n+     */\n+    public static Range withLoHi(Range other, int lo, int hi) throws CloneNotSupportedException {", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75651ac3832de72b3360e6fd39f6e4c73860aa13", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 339c4367118..9bea9a86794 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -94,16 +93,6 @@ public class Range {\n         this.primary = primary;\n     }\n \n-    /*\n-     * Create a copy of a Range with a different lo/hi code range.\n-     */\n-    public static Range withLoHi(Range other, int lo, int hi) throws CloneNotSupportedException {\n-        Range that = (Range) other.clone();\n-        that.lo = lo;\n-        that.hi = hi;\n-        return that;\n-    }\n-\n     public boolean contains(Range other) {\n         return (lo <= other.lo && hi >= other.hi);\n     }\n", "next_change": {"commit": "b307ee84155fb340719a658a7be2cc9159c49c02", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 9bea9a86794..6cdd3ed052a 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -56,40 +57,42 @@ public class Range {\n     /*\n      * Create a primary range.\n      */\n-    public Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String paramNames, String returnTypeName, StringTable stringTable, int lo, int hi, int line,\n-                    boolean isDeoptTarget) {\n-        this(fileName, filePath, cachePath, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, line, isDeoptTarget, null);\n+    public Range(String className, String methodName, String symbolName, String paramSignature, String returnTypeName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n+                    int modifiers, boolean isDeoptTarget) {\n+        this(className, methodName, symbolName, paramSignature, returnTypeName, stringTable, fileEntry, lo, hi, line, modifiers, isDeoptTarget, null);\n     }\n \n     /*\n      * Create a secondary range.\n      */\n-    public Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String paramNames, String returnTypeName, StringTable stringTable, int lo, int hi, int line,\n+    public Range(String className, String methodName, String symbolName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n                     Range primary) {\n-        this(fileName, filePath, cachePath, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, line, false, primary);\n+        this(className, methodName, symbolName, \"\", \"\", stringTable, fileEntry, lo, hi, line, 0, false, primary);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String paramNames, String returnTypeName, StringTable stringTable, int lo, int hi, int line,\n-                    boolean isDeoptTarget, Range primary) {\n-        /*\n-         * Currently file name and full method name need to go into the debug_str section other\n-         * strings just need to be deduplicated to save space.\n-         */\n-        this.fileName = (fileName == null ? null : stringTable.uniqueDebugString(fileName));\n-        this.filePath = filePath;\n-        this.cachePath = cachePath;\n+    private Range(String className, String methodName, String symbolName, String paramSignature, String returnTypeName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n+                    int modifiers, boolean isDeoptTarget, Range primary) {\n+        this.fileEntry = fileEntry;\n+        if (fileEntry != null) {\n+            stringTable.uniqueDebugString(fileEntry.getFileName());\n+            stringTable.uniqueDebugString(fileEntry.getPathName());\n+        }\n         this.className = stringTable.uniqueString(className);\n         this.methodName = stringTable.uniqueString(methodName);\n-        this.paramNames = stringTable.uniqueString(paramNames);\n+        this.symbolName = stringTable.uniqueString(symbolName);\n+        this.paramSignature = stringTable.uniqueString(paramSignature);\n         this.returnTypeName = stringTable.uniqueString(returnTypeName);\n-        this.fullMethodName = stringTable.uniqueDebugString(constructClassAndMethodNameWithParams());\n+        this.fullMethodName = stringTable.uniqueString(constructClassAndMethodName());\n+        this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n+        this.fullMethodNameWithParamsAndReturnType = stringTable.uniqueString(constructClassAndMethodNameWithParamsAndReturnType());\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n         this.isDeoptTarget = isDeoptTarget;\n+        this.modifiers = modifiers;\n         this.primary = primary;\n     }\n \n", "next_change": {"commit": "b384283b5ac0e455e66648c0d661ce5410bdd863", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 6cdd3ed052a..9bea361bef6 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -34,65 +34,52 @@ package com.oracle.objectfile.debugentry;\n \n public class Range {\n     private static final String CLASS_DELIMITER = \".\";\n-    private FileEntry fileEntry;\n-    private String className;\n-    private String methodName;\n-    private String symbolName;\n-    private String paramSignature;\n-    private String returnTypeName;\n-    private String methodNameWithParams;\n-    private String fullMethodName;\n-    private String fullMethodNameWithParams;\n-    private String fullMethodNameWithParamsAndReturnType;\n-    private int lo;\n-    private int hi;\n-    private int line;\n-    private boolean isDeoptTarget;\n-    private int modifiers;\n+    private final FileEntry fileEntry;\n+    private MethodEntry methodEntry;\n+    private final String symbolName;\n+    private final String fullMethodNameWithParams;\n+    private final int lo;\n+    private final int hi;\n+    private final int line;\n+    private final boolean isDeoptTarget;\n     /*\n      * This is null for a primary range.\n      */\n-    private Range primary;\n+    private final Range primary;\n \n     /*\n      * Create a primary range.\n      */\n-    public Range(String className, String methodName, String symbolName, String paramSignature, String returnTypeName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n-                    int modifiers, boolean isDeoptTarget) {\n-        this(className, methodName, symbolName, paramSignature, returnTypeName, stringTable, fileEntry, lo, hi, line, modifiers, isDeoptTarget, null);\n+    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n+                 boolean isDeoptTarget) {\n+        this(symbolName, stringTable, methodEntry, fileEntry, lo, hi, line, isDeoptTarget, null);\n     }\n \n     /*\n      * Create a secondary range.\n      */\n-    public Range(String className, String methodName, String symbolName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n-                    Range primary) {\n-        this(className, methodName, symbolName, \"\", \"\", stringTable, fileEntry, lo, hi, line, 0, false, primary);\n+    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n+        this(symbolName, stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, false, primary);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(String className, String methodName, String symbolName, String paramSignature, String returnTypeName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n-                    int modifiers, boolean isDeoptTarget, Range primary) {\n-        this.fileEntry = fileEntry;\n+    private Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n+                    boolean isDeoptTarget, Range primary) {\n+        this.fileEntry = fileEntry; // TODO remove and use fileEntry from MethodEntry\n         if (fileEntry != null) {\n             stringTable.uniqueDebugString(fileEntry.getFileName());\n             stringTable.uniqueDebugString(fileEntry.getPathName());\n         }\n-        this.className = stringTable.uniqueString(className);\n-        this.methodName = stringTable.uniqueString(methodName);\n+        assert methodEntry != null;\n+        this.methodEntry = methodEntry;\n         this.symbolName = stringTable.uniqueString(symbolName);\n-        this.paramSignature = stringTable.uniqueString(paramSignature);\n-        this.returnTypeName = stringTable.uniqueString(returnTypeName);\n-        this.fullMethodName = stringTable.uniqueString(constructClassAndMethodName());\n         this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n-        this.fullMethodNameWithParamsAndReturnType = stringTable.uniqueString(constructClassAndMethodNameWithParamsAndReturnType());\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n         this.isDeoptTarget = isDeoptTarget;\n-        this.modifiers = modifiers;\n         this.primary = primary;\n     }\n \n", "next_change": {"commit": "f485a3c15f5e29daf480657c0bfa22662f8005ae", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 9bea361bef6..a3d6e1c0db2 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -79,7 +77,6 @@ public class Range {\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n-        this.isDeoptTarget = isDeoptTarget;\n         this.primary = primary;\n     }\n \n", "next_change": {"commit": "dbb2c7607429817e58a1a9af8012e25e861368dc", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex a3d6e1c0db2..af465363bbf 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -49,30 +48,29 @@ public class Range {\n     /*\n      * Create a primary range.\n      */\n-    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n-        this(symbolName, stringTable, methodEntry, fileEntry, lo, hi, line, null);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n+        this(stringTable, methodEntry, fileEntry, lo, hi, line, null);\n     }\n \n     /*\n      * Create a secondary range.\n      */\n-    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n-        this(symbolName, stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n+        this(stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n+    private Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n                     Range primary) {\n-        this.fileEntry = fileEntry; // TODO remove and use fileEntry from MethodEntry\n+        this.fileEntry = fileEntry;\n         if (fileEntry != null) {\n             stringTable.uniqueDebugString(fileEntry.getFileName());\n             stringTable.uniqueDebugString(fileEntry.getPathName());\n         }\n         assert methodEntry != null;\n         this.methodEntry = methodEntry;\n-        this.symbolName = stringTable.uniqueString(symbolName);\n         this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n         this.lo = lo;\n         this.hi = hi;\n", "next_change": {"commit": "a658b95d63a93b1980e4ac81fd4c034c70b9d9cb", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex af465363bbf..5f7f3fe3bda 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -48,28 +47,19 @@ public class Range {\n     /*\n      * Create a primary range.\n      */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n-        this(stringTable, methodEntry, fileEntry, lo, hi, line, null);\n-    }\n-\n-    /*\n-     * Create a secondary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n-        this(stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line) {\n+        this(stringTable, methodEntry, lo, hi, line, null);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n-                    Range primary) {\n-        this.fileEntry = fileEntry;\n-        if (fileEntry != null) {\n-            stringTable.uniqueDebugString(fileEntry.getFileName());\n-            stringTable.uniqueDebugString(fileEntry.getPathName());\n-        }\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n         assert methodEntry != null;\n+        if (methodEntry.fileEntry != null) {\n+            stringTable.uniqueDebugString(methodEntry.fileEntry.getFileName());\n+            stringTable.uniqueDebugString(methodEntry.fileEntry.getPathName());\n+        }\n         this.methodEntry = methodEntry;\n         this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n         this.lo = lo;\n", "next_change": {"commit": "6fcf98378231f0e754061b683c3dba387ce8b0e9", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 5f7f3fe3bda..cc407a53acd 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -65,7 +68,10 @@ public class Range {\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n+        this.isInlined = isInline;\n         this.primary = primary;\n+        this.withChildren = withChildren;\n+        this.caller = caller;\n     }\n \n     public boolean contains(Range other) {\n", "next_change": {"commit": "abe98eaaa6dd772b7419b819fa342e810a0939e0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex cc407a53acd..037024f1755 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -71,6 +74,7 @@ public class Range {\n         this.isInlined = isInline;\n         this.primary = primary;\n         this.withChildren = withChildren;\n+        this.withInlinedChildren = false;\n         this.caller = caller;\n     }\n \n", "next_change": {"commit": "268c33256b26217c50339f452adea942fb48818f", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 037024f1755..1951241dda1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -73,9 +93,32 @@ public class Range {\n         this.line = line;\n         this.isInlined = isInline;\n         this.primary = primary;\n-        this.withChildren = withChildren;\n-        this.withInlinedChildren = false;\n+        this.firstCallee = null;\n+        this.lastCallee = null;\n+        this.nextCallee = null;\n         this.caller = caller;\n+        if (caller != null) {\n+            caller.addCallee(this);\n+        }\n+        if (this.isPrimary()) {\n+            this.depth = -1;\n+        } else {\n+            this.depth = caller.depth + 1;\n+        }\n+    }\n+\n+    private void addCallee(Range callee) {\n+        assert this.lo <= callee.lo;\n+        assert this.hi >= callee.hi;\n+        assert callee.caller == this;\n+        assert callee.nextCallee == null;\n+        if (this.firstCallee == null) {\n+            assert this.lastCallee == null;\n+            this.firstCallee = this.lastCallee = callee;\n+        } else {\n+            this.lastCallee.nextCallee = callee;\n+            this.lastCallee = callee;\n+        }\n     }\n \n     public boolean contains(Range other) {\n", "next_change": {"commit": "6ae5665ec0f5f89ff4a7804dbeec25c85d0982ea", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 1951241dda1..43c64a540e9 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -111,12 +111,12 @@ public class Range {\n         assert this.lo <= callee.lo;\n         assert this.hi >= callee.hi;\n         assert callee.caller == this;\n-        assert callee.nextCallee == null;\n+        assert callee.siblingCallee == null;\n         if (this.firstCallee == null) {\n             assert this.lastCallee == null;\n             this.firstCallee = this.lastCallee = callee;\n         } else {\n-            this.lastCallee.nextCallee = callee;\n+            this.lastCallee.siblingCallee = callee;\n             this.lastCallee = callee;\n         }\n     }\n", "next_change": {"commit": "9acf1c5d597e38f3e832360ce3f372ad94b16e9e", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\ndeleted file mode 100644\nindex 43c64a540e9..00000000000\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ /dev/null\n", "chunk": "@@ -1,339 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.objectfile.debugentry;\n-\n-import org.graalvm.compiler.debug.DebugContext;\n-\n-/**\n- * Details of a specific address range in a compiled method either a primary range identifying a\n- * whole method or a sub-range identifying a sequence of instructions that belong to an inlined\n- * method. Each sub-range is linked with its caller and its callees, forming a call tree.\n- */\n-public class Range {\n-    private static final String CLASS_DELIMITER = \".\";\n-    private Range caller;\n-    private final MethodEntry methodEntry;\n-    private final String fullMethodName;\n-    private final String fullMethodNameWithParams;\n-    private final int lo;\n-    private int hi;\n-    private final int line;\n-    private final boolean isInlined;\n-    private final int depth;\n-    /**\n-     * This is null for a primary range. For sub ranges it holds the root of the call tree they\n-     * belong to.\n-     */\n-    private final Range primary;\n-\n-    /*\n-     * Support for tree of nested inline callee ranges\n-     */\n-\n-    /**\n-     * The first direct callee whose range is wholly contained in this range.\n-     */\n-    private Range firstCallee;\n-\n-    /**\n-     * The last direct callee whose range is wholly contained in this range.\n-     */\n-    private Range lastCallee;\n-\n-    /**\n-     * A link to a sibling callee, i.e., a range sharing the same caller with this range.\n-     */\n-    private Range siblingCallee;\n-\n-    /*\n-     * Create a primary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line) {\n-        this(stringTable, methodEntry, lo, hi, line, null, false, null);\n-    }\n-\n-    /*\n-     * Create a primary or secondary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary, boolean isInline, Range caller) {\n-        assert methodEntry != null;\n-        if (methodEntry.fileEntry != null) {\n-            stringTable.uniqueDebugString(methodEntry.fileEntry.getFileName());\n-            stringTable.uniqueDebugString(methodEntry.fileEntry.getPathName());\n-        }\n-        this.methodEntry = methodEntry;\n-        this.fullMethodName = isInline ? stringTable.uniqueDebugString(constructClassAndMethodName()) : stringTable.uniqueString(constructClassAndMethodName());\n-        this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n-        this.lo = lo;\n-        this.hi = hi;\n-        this.line = line;\n-        this.isInlined = isInline;\n-        this.primary = primary;\n-        this.firstCallee = null;\n-        this.lastCallee = null;\n-        this.siblingCallee = null;\n-        this.caller = caller;\n-        if (caller != null) {\n-            caller.addCallee(this);\n-        }\n-        if (this.isPrimary()) {\n-            this.depth = -1;\n-        } else {\n-            this.depth = caller.depth + 1;\n-        }\n-    }\n-\n-    private void addCallee(Range callee) {\n-        assert this.lo <= callee.lo;\n-        assert this.hi >= callee.hi;\n-        assert callee.caller == this;\n-        assert callee.siblingCallee == null;\n-        if (this.firstCallee == null) {\n-            assert this.lastCallee == null;\n-            this.firstCallee = this.lastCallee = callee;\n-        } else {\n-            this.lastCallee.siblingCallee = callee;\n-            this.lastCallee = callee;\n-        }\n-    }\n-\n-    public boolean contains(Range other) {\n-        return (lo <= other.lo && hi >= other.hi);\n-    }\n-\n-    public boolean isPrimary() {\n-        return getPrimary() == null;\n-    }\n-\n-    public Range getPrimary() {\n-        return primary;\n-    }\n-\n-    public String getClassName() {\n-        return methodEntry.ownerType.typeName;\n-    }\n-\n-    public String getMethodName() {\n-        return methodEntry.memberName;\n-    }\n-\n-    public String getSymbolName() {\n-        return methodEntry.getSymbolName();\n-    }\n-\n-    public int getHi() {\n-        return hi;\n-    }\n-\n-    public int getLo() {\n-        return lo;\n-    }\n-\n-    public int getLine() {\n-        return line;\n-    }\n-\n-    public String getFullMethodName() {\n-        return fullMethodName;\n-    }\n-\n-    public String getFullMethodNameWithParams() {\n-        return fullMethodNameWithParams;\n-    }\n-\n-    public boolean isDeoptTarget() {\n-        return methodEntry.isDeopt();\n-    }\n-\n-    private String getExtendedMethodName(boolean includeClass, boolean includeParams, boolean includeReturnType) {\n-        StringBuilder builder = new StringBuilder();\n-        if (includeReturnType && methodEntry.valueType.typeName.length() > 0) {\n-            builder.append(methodEntry.valueType.typeName);\n-            builder.append(' ');\n-        }\n-        if (includeClass && getClassName() != null) {\n-            builder.append(getClassName());\n-            builder.append(CLASS_DELIMITER);\n-        }\n-        builder.append(getMethodName());\n-        if (includeParams) {\n-            builder.append('(');\n-            builder.append(String.join(\", \", methodEntry.paramNames));\n-            builder.append(')');\n-        }\n-        if (includeReturnType) {\n-            builder.append(\" \");\n-            builder.append(methodEntry.valueType.typeName);\n-        }\n-        return builder.toString();\n-    }\n-\n-    private String constructClassAndMethodName() {\n-        return getExtendedMethodName(true, false, false);\n-    }\n-\n-    private String constructClassAndMethodNameWithParams() {\n-        return getExtendedMethodName(true, true, false);\n-    }\n-\n-    public FileEntry getFileEntry() {\n-        return methodEntry.fileEntry;\n-    }\n-\n-    public int getModifiers() {\n-        return methodEntry.modifiers;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"Range(lo=0x%05x hi=0x%05x %s %s:%d)\", lo, hi, constructClassAndMethodNameWithParams(), methodEntry.getFullFileName(), line);\n-    }\n-\n-    public String getFileName() {\n-        return methodEntry.getFileName();\n-    }\n-\n-    public MethodEntry getMethodEntry() {\n-        return methodEntry;\n-    }\n-\n-    public boolean isInlined() {\n-        return isInlined;\n-    }\n-\n-    public Range getCaller() {\n-        return caller;\n-    }\n-\n-    public Range getFirstCallee() {\n-        return firstCallee;\n-    }\n-\n-    public Range getSiblingCallee() {\n-        return siblingCallee;\n-    }\n-\n-    public Range getLastCallee() {\n-        return lastCallee;\n-    }\n-\n-    public boolean isLeaf() {\n-        return firstCallee == null;\n-    }\n-\n-    public int getDepth() {\n-        return depth;\n-    }\n-\n-    /**\n-     * Minimizes the nodes in the tree that track the inline call hierarchy and associated code\n-     * ranges. The initial range tree models the call hierarchy as presented in the original debug\n-     * line info. It consists of a root node each of whose children is a sequence of linear call\n-     * chains, either a single leaf node for some given file and line or a series of inline calls to\n-     * such a leaf node. In this initial tree all node ranges in a given chain have the same lo and\n-     * hi address and chains are properly ordered by range The merge algorithm works across siblings\n-     * at successive depths starting at depth 1. Once all possible nodes at a given depth have been\n-     * merged their children can then be merged. A successor node may only be merged into its\n-     * predecessor if the nodes have contiguous ranges and idenitfy the same method, line and file.\n-     * The range and children of the merged node are, respectively, the union of the input ranges\n-     * and children. This preserves the invariant that child ranges lie within their parent range.\n-     *\n-     * @param debugContext\n-     */\n-    public void mergeSubranges(DebugContext debugContext) {\n-        Range next = getFirstCallee();\n-        if (next == null) {\n-            return;\n-        }\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Merge subranges [0x%x, 0x%x] %s\", lo, hi, getFullMethodNameWithParams());\n-        /* merge siblings together if possible, reparenting children to the merged node */\n-        while (next != null) {\n-            next = next.maybeMergeSibling(debugContext);\n-        }\n-        /* now recurse down to merge children of whatever nodes remain */\n-        next = getFirstCallee();\n-        /* now this level is merged recursively merge children of each child node. */\n-        while (next != null) {\n-            next.mergeSubranges(debugContext);\n-            next = next.getSiblingCallee();\n-        }\n-    }\n-\n-    /**\n-     * Removes and merges the next sibling returning the current node or it skips past the current\n-     * node as is and returns the next sibling or null if no sibling exists.\n-     */\n-    private Range maybeMergeSibling(DebugContext debugContext) {\n-        Range sibling = getSiblingCallee();\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Merge subrange (maybe) [0x%x, 0x%x] %s\", lo, hi, getFullMethodNameWithParams());\n-        if (sibling == null) {\n-            /* all child nodes at this level have been merged */\n-            return null;\n-        }\n-        if (hi < sibling.lo) {\n-            /* cannot merge non-contiguous ranges, move on. */\n-            return sibling;\n-        }\n-        if (getMethodEntry() != sibling.getMethodEntry()) {\n-            /* cannot merge distinct callers, move on. */\n-            return sibling;\n-        }\n-        if (getLine() != sibling.getLine()) {\n-            /* cannot merge callers with different line numbers, move on. */\n-            return sibling;\n-        }\n-        /* splice out the sibling from the chain and update this one to include it. */\n-        unlink(debugContext, sibling);\n-        /* relocate the siblings children to this node. */\n-        reparentChildren(debugContext, sibling);\n-        /* return the merged node so we can maybe merge it again. */\n-        return this;\n-    }\n-\n-    private void unlink(DebugContext debugContext, Range sibling) {\n-        assert hi == sibling.lo : String.format(\"gap in range [0x%x,0x%x] %s [0x%x,0x%x] %s\",\n-                        lo, hi, getFullMethodNameWithParams(), sibling.getLo(), sibling.getHi(), sibling.getFullMethodNameWithParams());\n-        assert this.isInlined == sibling.isInlined : String.format(\"change in inlined [0x%x,0x%x] %s %s [0x%x,0x%x] %s %s\",\n-                        lo, hi, getFullMethodNameWithParams(), Boolean.valueOf(this.isInlined), sibling.lo, sibling.hi, sibling.getFullMethodNameWithParams(), Boolean.valueOf(sibling.isInlined));\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Combining [0x%x, 0x%x] %s into [0x%x, 0x%x] %s\", sibling.lo, sibling.hi, sibling.getFullMethodName(), lo, hi, getFullMethodNameWithParams());\n-        this.hi = sibling.hi;\n-        this.siblingCallee = sibling.siblingCallee;\n-    }\n-\n-    private void reparentChildren(DebugContext debugContext, Range sibling) {\n-        Range siblingNext = sibling.getFirstCallee();\n-        while (siblingNext != null) {\n-            debugContext.log(DebugContext.INFO_LEVEL, \"Reparenting [0x%x, 0x%x] %s to [0x%x, 0x%x] %s\", siblingNext.lo, siblingNext.hi, siblingNext.getFullMethodName(), lo, hi,\n-                            getFullMethodNameWithParams());\n-            siblingNext.caller = this;\n-            Range newSiblingNext = siblingNext.siblingCallee;\n-            siblingNext.siblingCallee = null;\n-            addCallee(siblingNext);\n-            siblingNext = newSiblingNext;\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY5NzExMw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456697113", "body": "Any reason to keep the `machine` field?", "bodyText": "Any reason to keep the machine field?", "bodyHTML": "<p dir=\"auto\">Any reason to keep the <code>machine</code> field?</p>", "author": "pejovica", "createdAt": "2020-07-17T22:18:02Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVDebugInfo.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.DebugInfoBase;\n+import com.oracle.objectfile.pecoff.PECoffMachine;\n+\n+import java.nio.ByteOrder;\n+\n+/**\n+ * CVDebugInfo is a container class for all the CodeView sections to be emitted in the object file.\n+ * Currently, that is .debug$S (CVSymbolSectionImpl) and .debug$T (CVTypeSectionImpl) Common data\n+ * (useful to more than one CodeView section) goes here\n+ */\n+public final class CVDebugInfo extends DebugInfoBase {\n+\n+    @SuppressWarnings(\"unused\") private PECoffMachine machine;", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5Mzk5Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457693997", "bodyText": "Gone.", "author": "stooke", "createdAt": "2020-07-20T21:11:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY5NzExMw=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVDebugInfo.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVDebugInfo.java\nindex c3f8228b6bc..635f084fff1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVDebugInfo.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVDebugInfo.java\n", "chunk": "@@ -27,24 +27,20 @@\n package com.oracle.objectfile.pecoff.cv;\n \n import com.oracle.objectfile.debugentry.DebugInfoBase;\n-import com.oracle.objectfile.pecoff.PECoffMachine;\n \n import java.nio.ByteOrder;\n \n /**\n  * CVDebugInfo is a container class for all the CodeView sections to be emitted in the object file.\n- * Currently, that is .debug$S (CVSymbolSectionImpl) and .debug$T (CVTypeSectionImpl) Common data\n- * (useful to more than one CodeView section) goes here\n+ * Currently, those are.debug$S (CVSymbolSectionImpl) and .debug$T (CVTypeSectionImpl).\n  */\n public final class CVDebugInfo extends DebugInfoBase {\n \n-    @SuppressWarnings(\"unused\") private PECoffMachine machine;\n     private CVSymbolSectionImpl cvSymbolSection;\n     private CVTypeSectionImpl cvTypeSection;\n \n-    public CVDebugInfo(PECoffMachine targetMachine, ByteOrder byteOrder) {\n+    public CVDebugInfo(ByteOrder byteOrder) {\n         super(byteOrder);\n-        machine = targetMachine;\n         cvSymbolSection = new CVSymbolSectionImpl(this);\n         cvTypeSection = new CVTypeSectionImpl();\n     }\n", "next_change": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVDebugInfo.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVDebugInfo.java\nindex 635f084fff1..67d50ceb3ba 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVDebugInfo.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVDebugInfo.java\n", "chunk": "@@ -36,13 +39,18 @@ import java.nio.ByteOrder;\n  */\n public final class CVDebugInfo extends DebugInfoBase {\n \n-    private CVSymbolSectionImpl cvSymbolSection;\n-    private CVTypeSectionImpl cvTypeSection;\n+    private final CVSymbolSectionImpl cvSymbolSection;\n+    private final CVTypeSectionImpl cvTypeSection;\n+    private DebugContext debugContext;\n \n-    public CVDebugInfo(ByteOrder byteOrder) {\n+    public CVDebugInfo(PECoffMachine machine, ByteOrder byteOrder) {\n         super(byteOrder);\n         cvSymbolSection = new CVSymbolSectionImpl(this);\n-        cvTypeSection = new CVTypeSectionImpl();\n+        cvTypeSection = new CVTypeSectionImpl(this);\n+        if (machine != PECoffMachine.X86_64) {\n+            /* room for future aarch64 port */\n+            throw GraalError.shouldNotReachHere(\"Unsupported architecture on Windows\");\n+        }\n     }\n \n     public CVSymbolSectionImpl getCVSymbolSection() {\n", "next_change": {"commit": "77e3a7479e429a3279d3061496d260e35f21f000", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVDebugInfo.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVDebugInfo.java\nindex 67d50ceb3ba..bcca177caca 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVDebugInfo.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVDebugInfo.java\n", "chunk": "@@ -43,12 +43,23 @@ public final class CVDebugInfo extends DebugInfoBase {\n     private final CVTypeSectionImpl cvTypeSection;\n     private DebugContext debugContext;\n \n+    /* Register constants for Windows x86_64 */\n+    /* See AMD64ReservedRegisters.java. */\n+    public static final byte RHEAPBASE_X86 = (byte) 14;\n+    public static final byte RTHREAD_X86 = (byte) 15;\n+\n+    private final byte heapbaseRegister;\n+    private final byte threadRegister;\n+\n     public CVDebugInfo(PECoffMachine machine, ByteOrder byteOrder) {\n         super(byteOrder);\n         cvSymbolSection = new CVSymbolSectionImpl(this);\n         cvTypeSection = new CVTypeSectionImpl(this);\n-        if (machine != PECoffMachine.X86_64) {\n-            /* room for future aarch64 port */\n+        if (machine == PECoffMachine.X86_64) {\n+            this.heapbaseRegister = RHEAPBASE_X86;\n+            this.threadRegister = RTHREAD_X86;\n+        } else {\n+            /* room for future aach64 port */\n             throw GraalError.shouldNotReachHere(\"Unsupported architecture on Windows\");\n         }\n     }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcwMjAwNA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456702004", "body": "This could be simplified to\r\n```suggestion\r\n        if (newValue > 0 && !TrackNodeSourcePosition.getValueOrDefault(values)) {\r\n            TrackNodeSourcePosition.update(values, true);\r\n        }\r\n        if (newValue > 0 && DeleteLocalSymbols.getValueOrDefault(values)) {\r\n            DeleteLocalSymbols.update(values, false);\r\n        }\r\n```\r\nor maybe even just to\r\n```suggestion\r\n        TrackNodeSourcePosition.update(values, newValue > 0);\r\n        DeleteLocalSymbols.update(values, newValue == 0);\r\n```", "bodyText": "This could be simplified to\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (newValue > 0 && !Boolean.TRUE.equals(values.get(TrackNodeSourcePosition))) {\n          \n          \n            \n                        TrackNodeSourcePosition.update(values, true);\n          \n          \n            \n                    }\n          \n          \n            \n                    if (newValue > 0 && !Boolean.FALSE.equals(values.get(DeleteLocalSymbols))) {\n          \n          \n            \n                        DeleteLocalSymbols.update(values, false);\n          \n          \n            \n                    }\n          \n          \n            \n                    if (newValue > 0 && !TrackNodeSourcePosition.getValueOrDefault(values)) {\n          \n          \n            \n                        TrackNodeSourcePosition.update(values, true);\n          \n          \n            \n                    }\n          \n          \n            \n                    if (newValue > 0 && DeleteLocalSymbols.getValueOrDefault(values)) {\n          \n          \n            \n                        DeleteLocalSymbols.update(values, false);\n          \n          \n            \n                    }\n          \n      \n    \n    \n  \n\nor maybe even just to\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (newValue > 0 && !Boolean.TRUE.equals(values.get(TrackNodeSourcePosition))) {\n          \n          \n            \n                        TrackNodeSourcePosition.update(values, true);\n          \n          \n            \n                    }\n          \n          \n            \n                    if (newValue > 0 && !Boolean.FALSE.equals(values.get(DeleteLocalSymbols))) {\n          \n          \n            \n                        DeleteLocalSymbols.update(values, false);\n          \n          \n            \n                    }\n          \n          \n            \n                    TrackNodeSourcePosition.update(values, newValue > 0);\n          \n          \n            \n                    DeleteLocalSymbols.update(values, newValue == 0);", "bodyHTML": "<p dir=\"auto\">This could be simplified to</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">if</span> (newValue <span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">0</span> <span class=\"pl-k\">&amp;&amp;</span> <span class=\"pl-k\">!</span><span class=\"pl-smi x x-first\">Boolean</span><span class=\"pl-c1\"><span class=\"pl-k x\">.</span><span class=\"x\">TRUE</span></span><span class=\"pl-k x\">.</span><span class=\"x x-last\">equals</span>(values<span class=\"pl-k x x-first\">.</span><span class=\"x\">get(</span><span class=\"pl-smi x\">TrackNodeSourcePosition</span><span class=\"x x-last\">)</span>)) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-smi\">TrackNodeSourcePosition</span><span class=\"pl-k\">.</span>update(values, <span class=\"pl-c1\">true</span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">if</span> (newValue <span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">0</span> <span class=\"pl-k\">&amp;&amp;</span> <span class=\"pl-k x x-first\">!</span><span class=\"pl-smi x\">Boolean</span><span class=\"pl-c1\"><span class=\"pl-k x\">.</span><span class=\"x\">FALSE</span></span><span class=\"pl-k x\">.</span><span class=\"x x-last\">equals</span>(values<span class=\"pl-k x x-first\">.</span><span class=\"x\">get(</span><span class=\"pl-smi x\">DeleteLocalSymbols</span><span class=\"x x-last\">)</span>)) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-smi\">DeleteLocalSymbols</span><span class=\"pl-k\">.</span>update(values, <span class=\"pl-c1\">false</span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">if</span> (newValue <span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">0</span> <span class=\"pl-k\">&amp;&amp;</span> <span class=\"pl-k\">!</span><span class=\"pl-smi x x-first\">TrackNodeSourcePosition</span><span class=\"pl-k x\">.</span><span class=\"x x-last\">getValueOrDefault</span>(values)) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            <span class=\"pl-smi\">TrackNodeSourcePosition</span><span class=\"pl-k\">.</span>update(values, <span class=\"pl-c1\">true</span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">if</span> (newValue <span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">0</span> <span class=\"pl-k\">&amp;&amp;</span> <span class=\"pl-smi x x-first\">DeleteLocalSymbols</span><span class=\"pl-k x\">.</span><span class=\"x x-last\">getValueOrDefault</span>(values)) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            <span class=\"pl-smi\">DeleteLocalSymbols</span><span class=\"pl-k\">.</span>update(values, <span class=\"pl-c1\">false</span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        }</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n\n<p dir=\"auto\">or maybe even just to</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">if</span> (newValue <span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">0</span> <span class=\"pl-k\">&amp;&amp;</span> <span class=\"pl-k\">!</span><span class=\"pl-smi\">Boolean</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>TRUE</span><span class=\"pl-k\">.</span>equals(values<span class=\"pl-k\">.</span>get(<span class=\"pl-smi\">TrackNodeSourcePosition</span>))) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-smi\">TrackNodeSourcePosition</span><span class=\"pl-k\">.</span>update(values, <span class=\"pl-c1\">true</span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">if</span> (newValue <span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">0</span> <span class=\"pl-k\">&amp;&amp;</span> <span class=\"pl-k\">!</span><span class=\"pl-smi\">Boolean</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>FALSE</span><span class=\"pl-k\">.</span>equals(values<span class=\"pl-k\">.</span>get(<span class=\"pl-smi\">DeleteLocalSymbols</span>))) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-smi\">DeleteLocalSymbols</span><span class=\"pl-k\">.</span>update(values, <span class=\"pl-c1\">false</span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-smi\">TrackNodeSourcePosition</span><span class=\"pl-k\">.</span>update(values, newValue <span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">0</span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-smi\">DeleteLocalSymbols</span><span class=\"pl-k\">.</span>update(values, newValue <span class=\"pl-k\">==</span> <span class=\"pl-c1\">0</span>);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pejovica", "createdAt": "2020-07-17T22:36:45Z", "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java", "diffHunk": "@@ -492,6 +492,9 @@ private static void defaultDebugInfoValueUpdateHandler(EconomicMap<OptionKey<?>,\n         if (newValue > 0 && !Boolean.TRUE.equals(values.get(TrackNodeSourcePosition))) {\n             TrackNodeSourcePosition.update(values, true);\n         }\n+        if (newValue > 0 && !Boolean.FALSE.equals(values.get(DeleteLocalSymbols))) {\n+            DeleteLocalSymbols.update(values, false);\n+        }", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NDI1Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457694257", "bodyText": "I went for the second choice.", "author": "stooke", "createdAt": "2020-07-20T21:11:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcwMjAwNA=="}], "type": "inlineReview", "revised_code": {"commit": "47bac957b8a6a28f024756a6d0b9667c50dd206f", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java\nindex bc23d0ae4b5..6f53fcdbfd5 100644\n--- a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java\n+++ b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java\n", "chunk": "@@ -492,9 +492,6 @@ public class SubstrateOptions {\n         if (newValue > 0 && !Boolean.TRUE.equals(values.get(TrackNodeSourcePosition))) {\n             TrackNodeSourcePosition.update(values, true);\n         }\n-        if (newValue > 0 && !Boolean.FALSE.equals(values.get(DeleteLocalSymbols))) {\n-            DeleteLocalSymbols.update(values, false);\n-        }\n     }\n \n     @Option(help = \"Search path for source files for Application or GraalVM classes (list of comma-separated directories or jar files)\")//\n", "next_change": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java\nindex 6f53fcdbfd5..510640cd7de 100644\n--- a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java\n+++ b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java\n", "chunk": "@@ -488,15 +444,15 @@ public class SubstrateOptions {\n     };\n \n     private static void defaultDebugInfoValueUpdateHandler(EconomicMap<OptionKey<?>, Object> values, @SuppressWarnings(\"unused\") Integer oldValue, Integer newValue) {\n-        // force update of TrackNodeSourcePosition\n-        if (newValue > 0 && !Boolean.TRUE.equals(values.get(TrackNodeSourcePosition))) {\n-            TrackNodeSourcePosition.update(values, true);\n-        }\n+        // force update of TrackNodeSourcePosition and DeleteLocalSymbols\n+        TrackNodeSourcePosition.update(values, newValue > 0);\n+        DeleteLocalSymbols.update(values, newValue == 0);\n     }\n \n     @Option(help = \"Search path for source files for Application or GraalVM classes (list of comma-separated directories or jar files)\")//\n     public static final HostedOptionKey<String[]> DebugInfoSourceSearchPath = new HostedOptionKey<String[]>(null) {\n     };\n+\n     @Option(help = \"Directory under which to create source file cache for Application or GraalVM classes\")//\n     public static final HostedOptionKey<String> DebugInfoSourceCacheRoot = new HostedOptionKey<>(\"sources\");\n \n", "next_change": {"commit": "cb793452f5241c9bc3101e610dc1ad2d5917b4e0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java\nindex 510640cd7de..55dfe8d033d 100644\n--- a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java\n+++ b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java\n", "chunk": "@@ -450,8 +458,7 @@ public class SubstrateOptions {\n     }\n \n     @Option(help = \"Search path for source files for Application or GraalVM classes (list of comma-separated directories or jar files)\")//\n-    public static final HostedOptionKey<String[]> DebugInfoSourceSearchPath = new HostedOptionKey<String[]>(null) {\n-    };\n+    public static final HostedOptionKey<LocatableMultiOptionValue.Strings> DebugInfoSourceSearchPath = new HostedOptionKey<>(new LocatableMultiOptionValue.Strings());\n \n     @Option(help = \"Directory under which to create source file cache for Application or GraalVM classes\")//\n     public static final HostedOptionKey<String> DebugInfoSourceCacheRoot = new HostedOptionKey<>(\"sources\");\n", "next_change": {"commit": "dee66ca6e28fd519cef061130d20e28ec35d1a1f", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java\nindex 55dfe8d033d..0e111ab848d 100644\n--- a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java\n+++ b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java\n", "chunk": "@@ -465,13 +465,15 @@ public class SubstrateOptions {\n \n     public static Path getDebugInfoSourceCacheRoot() {\n         try {\n-            Path sourceRoot = Paths.get(DebugInfoSourceCacheRoot.getValue());\n-            return sourceRoot;\n+            return Paths.get(Path.getValue()).resolve(DebugInfoSourceCacheRoot.getValue());\n         } catch (InvalidPathException ipe) {\n             throw UserError.abort(\"Invalid path provided for option DebugInfoSourceCacheRoot %s\", DebugInfoSourceCacheRoot.getValue());\n         }\n     }\n \n+    @Option(help = \"Omit generation of DebugLineInfo originating from inlined methods\") //\n+    public static final HostedOptionKey<Boolean> OmitInlinedMethodDebugLineInfo = new HostedOptionKey<>(true);\n+\n     /** Command line option to disable image build server. */\n     public static final String NO_SERVER = \"--no-server\";\n \n", "next_change": {"commit": "0debaec470bf80c00208df889b824b68f9eaaacf", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java\nindex 0e111ab848d..6cca86f12e1 100644\n--- a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java\n+++ b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java\n", "chunk": "@@ -474,9 +487,6 @@ public class SubstrateOptions {\n     @Option(help = \"Omit generation of DebugLineInfo originating from inlined methods\") //\n     public static final HostedOptionKey<Boolean> OmitInlinedMethodDebugLineInfo = new HostedOptionKey<>(true);\n \n-    /** Command line option to disable image build server. */\n-    public static final String NO_SERVER = \"--no-server\";\n-\n     @Fold\n     public static boolean supportCompileInIsolates() {\n         UserError.guarantee(!ConcealedOptions.SupportCompileInIsolates.getValue() || SpawnIsolates.getValue(),\n", "next_change": {"commit": "51983a83e9051b0c9f93dc4c8afb8c30018eda8d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java\nindex 6cca86f12e1..739d5a98d93 100644\n--- a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java\n+++ b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java\n", "chunk": "@@ -487,6 +487,9 @@ public class SubstrateOptions {\n     @Option(help = \"Omit generation of DebugLineInfo originating from inlined methods\") //\n     public static final HostedOptionKey<Boolean> OmitInlinedMethodDebugLineInfo = new HostedOptionKey<>(true);\n \n+    /** Command line option to disable image build server. */\n+    public static final String NO_SERVER = \"--no-server\";\n+\n     @Fold\n     public static boolean supportCompileInIsolates() {\n         UserError.guarantee(!ConcealedOptions.SupportCompileInIsolates.getValue() || SpawnIsolates.getValue(),\n", "next_change": {"commit": "bd34f5a08d476c909a42c7b2b860f85573a088a9", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java\nindex 739d5a98d93..8561e00c2a5 100644\n--- a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java\n+++ b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java\n", "chunk": "@@ -487,9 +487,6 @@ public class SubstrateOptions {\n     @Option(help = \"Omit generation of DebugLineInfo originating from inlined methods\") //\n     public static final HostedOptionKey<Boolean> OmitInlinedMethodDebugLineInfo = new HostedOptionKey<>(true);\n \n-    /** Command line option to disable image build server. */\n-    public static final String NO_SERVER = \"--no-server\";\n-\n     @Fold\n     public static boolean supportCompileInIsolates() {\n         UserError.guarantee(!ConcealedOptions.SupportCompileInIsolates.getValue() || SpawnIsolates.getValue(),\n", "next_change": {"commit": "4a82835c9a5f5cd30eb4abeb84fab8cd9967d149", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java\nindex 8561e00c2a5..695598e2fdc 100644\n--- a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java\n+++ b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java\n", "chunk": "@@ -487,6 +487,9 @@ public class SubstrateOptions {\n     @Option(help = \"Omit generation of DebugLineInfo originating from inlined methods\") //\n     public static final HostedOptionKey<Boolean> OmitInlinedMethodDebugLineInfo = new HostedOptionKey<>(true);\n \n+    /** Command line option to disable image build server. */\n+    public static final String NO_SERVER = \"--no-server\";\n+\n     @Fold\n     public static boolean supportCompileInIsolates() {\n         UserError.guarantee(!ConcealedOptions.SupportCompileInIsolates.getValue() || SpawnIsolates.getValue(),\n", "next_change": {"commit": "5afa4d0514270d3801f77fd758e0e6954d582c36", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java\nindex 695598e2fdc..b9b51ad3b6c 100644\n--- a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java\n+++ b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java\n", "chunk": "@@ -487,9 +487,6 @@ public class SubstrateOptions {\n     @Option(help = \"Omit generation of DebugLineInfo originating from inlined methods\") //\n     public static final HostedOptionKey<Boolean> OmitInlinedMethodDebugLineInfo = new HostedOptionKey<>(true);\n \n-    /** Command line option to disable image build server. */\n-    public static final String NO_SERVER = \"--no-server\";\n-\n     @Fold\n     public static boolean supportCompileInIsolates() {\n         UserError.guarantee(!ConcealedOptions.SupportCompileInIsolates.getValue() || SpawnIsolates.getValue(),\n", "next_change": {"commit": "faa75d540b85cadb3aa7ffc30a9abe0b56ecb6de", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java\nindex b9b51ad3b6c..e5a15741de3 100644\n--- a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java\n+++ b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java\n", "chunk": "@@ -487,6 +665,9 @@ public class SubstrateOptions {\n     @Option(help = \"Omit generation of DebugLineInfo originating from inlined methods\") //\n     public static final HostedOptionKey<Boolean> OmitInlinedMethodDebugLineInfo = new HostedOptionKey<>(true);\n \n+    @Option(help = \"Emit debuginfo debug.svm.imagebuild.* sections with detailed image-build options.\")//\n+    public static final HostedOptionKey<Boolean> UseImagebuildDebugSections = new HostedOptionKey<>(true);\n+\n     @Fold\n     public static boolean supportCompileInIsolates() {\n         UserError.guarantee(!ConcealedOptions.SupportCompileInIsolates.getValue() || SpawnIsolates.getValue(),\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcxMjcxMA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456712710", "body": "You could introduce a constant, e.g. `HEADER_SIZE = Integer.BYTES * 2`.", "bodyText": "You could introduce a constant, e.g. HEADER_SIZE = Integer.BYTES * 2.", "bodyHTML": "<p dir=\"auto\">You could introduce a constant, e.g. <code>HEADER_SIZE = Integer.BYTES * 2</code>.</p>", "author": "pejovica", "createdAt": "2020-07-17T23:23:44Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolRecord.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+/*\n+ * A Symbol record is a top-level record in the CodeView .debug$S section\n+ */\n+abstract class CVSymbolRecord {\n+\n+    protected CVDebugInfo cvDebugInfo;\n+    protected int recordStartPosition;\n+    protected final int type;\n+\n+    CVSymbolRecord(CVDebugInfo cvDebugInfo, int type) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.type = type;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.recordStartPosition = initialPos;\n+        int pos = initialPos + Integer.BYTES * 2;", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NDM3MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457694370", "bodyText": "True.  I've added constants (with explanations) for a few of the more complex headers, but not all.", "author": "stooke", "createdAt": "2020-07-20T21:12:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcxMjcxMA=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolRecord.java\nindex c5b78a6508a..38b263649a3 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolRecord.java\n", "chunk": "@@ -29,31 +29,34 @@ package com.oracle.objectfile.pecoff.cv;\n import org.graalvm.compiler.debug.DebugContext;\n \n /*\n- * A Symbol record is a top-level record in the CodeView .debug$S section\n+ * A Symbol record is a top-level record in the CodeView .debug$S section.\n  */\n abstract class CVSymbolRecord {\n \n-    protected CVDebugInfo cvDebugInfo;\n-    protected int recordStartPosition;\n+    /* Symbol record header: record type (4 bytes), length (4 bytes). */\n+    private static final int SYMBOL_RECORD_HEADER_SIZE = Integer.BYTES * 2;\n+\n+    protected final CVDebugInfo cvDebugInfo;\n     protected final int type;\n+    protected int recordStartPosition;\n \n     CVSymbolRecord(CVDebugInfo cvDebugInfo, int type) {\n         this.cvDebugInfo = cvDebugInfo;\n         this.type = type;\n     }\n \n-    int computeFullSize(int initialPos) {\n+    final int computeFullSize(int initialPos) {\n         this.recordStartPosition = initialPos;\n-        int pos = initialPos + Integer.BYTES * 2;\n+        int pos = initialPos + SYMBOL_RECORD_HEADER_SIZE;\n         return computeSize(pos);\n     }\n \n-    int computeFullContents(byte[] buffer, int initialPos) {\n+    final int computeFullContents(byte[] buffer, int initialPos) {\n         int pos = CVUtil.putInt(type, buffer, initialPos);\n         int lenPos = pos;\n-        pos = computeContents(buffer, pos + Integer.BYTES);\n-        /* length does not include debug record header (4 bytes record id + 4 bytes length) */\n-        CVUtil.putInt(pos - lenPos - Integer.BYTES, buffer, lenPos);\n+        pos = computeContents(buffer, initialPos + SYMBOL_RECORD_HEADER_SIZE);\n+        /* Length does not include debug record header (4 bytes record id + 4 bytes length). */\n+        CVUtil.putInt(pos - initialPos - SYMBOL_RECORD_HEADER_SIZE, buffer, lenPos);\n         return pos;\n     }\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcxMzQwMQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456713401", "body": "With `HEADER_SIZE`, this could then become\r\n```suggestion\r\n        pos = computeContents(buffer, initialPos + HEADER_SIZE);\r\n        /* length does not include debug record header (4 bytes record id + 4 bytes length) */\r\n        CVUtil.putInt(pos - HEADER_SIZE, buffer, lenPos);\r\n```", "bodyText": "With HEADER_SIZE, this could then become\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    pos = computeContents(buffer, pos + Integer.BYTES);\n          \n          \n            \n                    /* length does not include debug record header (4 bytes record id + 4 bytes length) */\n          \n          \n            \n                    CVUtil.putInt(pos - lenPos - Integer.BYTES, buffer, lenPos);\n          \n          \n            \n                    pos = computeContents(buffer, initialPos + HEADER_SIZE);\n          \n          \n            \n                    /* length does not include debug record header (4 bytes record id + 4 bytes length) */\n          \n          \n            \n                    CVUtil.putInt(pos - HEADER_SIZE, buffer, lenPos);", "bodyHTML": "<p dir=\"auto\">With <code>HEADER_SIZE</code>, this could then become</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        pos <span class=\"pl-k\">=</span> computeContents(buffer, <span class=\"x x-first x-last\">pos</span> <span class=\"pl-k\">+</span> <span class=\"pl-smi x x-first\">Integer</span><span class=\"pl-c1\"><span class=\"pl-k x\">.</span><span class=\"x x-last\">BYTES</span></span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-c\"><span class=\"pl-c\">/*</span> length does not include debug record header (4 bytes record id + 4 bytes length) <span class=\"pl-c\">*/</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-smi\">CVUtil</span><span class=\"pl-k\">.</span>putInt(pos <span class=\"pl-k\">-</span> <span class=\"x x-first\">lenPos </span><span class=\"pl-k x\">-</span><span class=\"x\"> </span><span class=\"pl-smi x\">Integer</span><span class=\"pl-c1\"><span class=\"pl-k x\">.</span><span class=\"x x-last\">BYTES</span></span>, buffer, lenPos);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        pos <span class=\"pl-k\">=</span> computeContents(buffer, <span class=\"x x-first x-last\">initialPos</span> <span class=\"pl-k\">+</span> <span class=\"pl-c1 x x-first x-last\">HEADER_SIZE</span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-c\"><span class=\"pl-c\">/*</span> length does not include debug record header (4 bytes record id + 4 bytes length) <span class=\"pl-c\">*/</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-smi\">CVUtil</span><span class=\"pl-k\">.</span>putInt(pos <span class=\"pl-k\">-</span> <span class=\"pl-c1 x x-first x-last\">HEADER_SIZE</span>, buffer, lenPos);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pejovica", "createdAt": "2020-07-17T23:26:57Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolRecord.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+/*\n+ * A Symbol record is a top-level record in the CodeView .debug$S section\n+ */\n+abstract class CVSymbolRecord {\n+\n+    protected CVDebugInfo cvDebugInfo;\n+    protected int recordStartPosition;\n+    protected final int type;\n+\n+    CVSymbolRecord(CVDebugInfo cvDebugInfo, int type) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.type = type;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.recordStartPosition = initialPos;\n+        int pos = initialPos + Integer.BYTES * 2;\n+        return computeSize(pos);\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = CVUtil.putInt(type, buffer, initialPos);\n+        int lenPos = pos;\n+        pos = computeContents(buffer, pos + Integer.BYTES);\n+        /* length does not include debug record header (4 bytes record id + 4 bytes length) */\n+        CVUtil.putInt(pos - lenPos - Integer.BYTES, buffer, lenPos);", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgyNzcyNA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458827724", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-07-22T14:18:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcxMzQwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolRecord.java\nindex c5b78a6508a..38b263649a3 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolRecord.java\n", "chunk": "@@ -29,31 +29,34 @@ package com.oracle.objectfile.pecoff.cv;\n import org.graalvm.compiler.debug.DebugContext;\n \n /*\n- * A Symbol record is a top-level record in the CodeView .debug$S section\n+ * A Symbol record is a top-level record in the CodeView .debug$S section.\n  */\n abstract class CVSymbolRecord {\n \n-    protected CVDebugInfo cvDebugInfo;\n-    protected int recordStartPosition;\n+    /* Symbol record header: record type (4 bytes), length (4 bytes). */\n+    private static final int SYMBOL_RECORD_HEADER_SIZE = Integer.BYTES * 2;\n+\n+    protected final CVDebugInfo cvDebugInfo;\n     protected final int type;\n+    protected int recordStartPosition;\n \n     CVSymbolRecord(CVDebugInfo cvDebugInfo, int type) {\n         this.cvDebugInfo = cvDebugInfo;\n         this.type = type;\n     }\n \n-    int computeFullSize(int initialPos) {\n+    final int computeFullSize(int initialPos) {\n         this.recordStartPosition = initialPos;\n-        int pos = initialPos + Integer.BYTES * 2;\n+        int pos = initialPos + SYMBOL_RECORD_HEADER_SIZE;\n         return computeSize(pos);\n     }\n \n-    int computeFullContents(byte[] buffer, int initialPos) {\n+    final int computeFullContents(byte[] buffer, int initialPos) {\n         int pos = CVUtil.putInt(type, buffer, initialPos);\n         int lenPos = pos;\n-        pos = computeContents(buffer, pos + Integer.BYTES);\n-        /* length does not include debug record header (4 bytes record id + 4 bytes length) */\n-        CVUtil.putInt(pos - lenPos - Integer.BYTES, buffer, lenPos);\n+        pos = computeContents(buffer, initialPos + SYMBOL_RECORD_HEADER_SIZE);\n+        /* Length does not include debug record header (4 bytes record id + 4 bytes length). */\n+        CVUtil.putInt(pos - initialPos - SYMBOL_RECORD_HEADER_SIZE, buffer, lenPos);\n         return pos;\n     }\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNjEwNA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456726104", "body": "Unused method.", "bodyText": "Unused method.", "bodyHTML": "<p dir=\"auto\">Unused method.</p>", "author": "pejovica", "createdAt": "2020-07-18T00:38:03Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVStringTableRecord.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+final class CVStringTableRecord extends CVSymbolRecord {\n+\n+    private final CVSymbolSectionImpl.CVStringTable stringTable;\n+\n+    CVStringTableRecord(CVDebugInfo cvDebugInfo, CVSymbolSectionImpl.CVStringTable stringTable) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_STRINGTABLE);\n+        this.stringTable = stringTable;\n+    }\n+\n+    int add(String string) {", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NDQ4OQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457694489", "bodyText": "Gone", "author": "stooke", "createdAt": "2020-07-20T21:12:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNjEwNA=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVStringTableRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVStringTableRecord.java\nindex ce9940abfea..d0fa57c82c0 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVStringTableRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVStringTableRecord.java\n", "chunk": "@@ -35,13 +35,9 @@ final class CVStringTableRecord extends CVSymbolRecord {\n         this.stringTable = stringTable;\n     }\n \n-    int add(String string) {\n-        return stringTable.add(string);\n-    }\n-\n     @Override\n     public int computeSize(int pos) {\n-        return computeContents(null, pos);\n+        return pos + stringTable.getCurrentOffset();\n     }\n \n     @Override\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc4MTEzNA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456781134", "body": "When called to compute the size, won't it compute the same value that is already in the `CVStringTable.currentOffset` field?", "bodyText": "When called to compute the size, won't it compute the same value that is already in the CVStringTable.currentOffset field?", "bodyHTML": "<p dir=\"auto\">When called to compute the size, won't it compute the same value that is already in the <code>CVStringTable.currentOffset</code> field?</p>", "author": "pejovica", "createdAt": "2020-07-18T11:37:25Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVStringTableRecord.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+final class CVStringTableRecord extends CVSymbolRecord {\n+\n+    private final CVSymbolSectionImpl.CVStringTable stringTable;\n+\n+    CVStringTableRecord(CVDebugInfo cvDebugInfo, CVSymbolSectionImpl.CVStringTable stringTable) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_STRINGTABLE);\n+        this.stringTable = stringTable;\n+    }\n+\n+    int add(String string) {\n+        return stringTable.add(string);\n+    }\n+\n+    @Override\n+    public int computeSize(int pos) {\n+        return computeContents(null, pos);\n+    }\n+\n+    @Override\n+    public int computeContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        for (CVSymbolSectionImpl.CVStringTable.StringTableEntry entry : stringTable.values()) {\n+            pos = CVUtil.putUTF8StringBytes(entry.text, buffer, pos);\n+        }", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NDU0MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457694540", "bodyText": "Only if I coded it correctly!  But thanks - much more efficient.", "author": "stooke", "createdAt": "2020-07-20T21:12:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc4MTEzNA=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVStringTableRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVStringTableRecord.java\nindex ce9940abfea..d0fa57c82c0 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVStringTableRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVStringTableRecord.java\n", "chunk": "@@ -35,13 +35,9 @@ final class CVStringTableRecord extends CVSymbolRecord {\n         this.stringTable = stringTable;\n     }\n \n-    int add(String string) {\n-        return stringTable.add(string);\n-    }\n-\n     @Override\n     public int computeSize(int pos) {\n-        return computeContents(null, pos);\n+        return pos + stringTable.getCurrentOffset();\n     }\n \n     @Override\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc5MjMwOA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456792308", "body": "This is very similar to `CVSymbolRecord`, basically the only difference is the \"record header\". Perhaps a common superclass might be appropriate.", "bodyText": "This is very similar to CVSymbolRecord, basically the only difference is the \"record header\". Perhaps a common superclass might be appropriate.", "bodyHTML": "<p dir=\"auto\">This is very similar to <code>CVSymbolRecord</code>, basically the only difference is the \"record header\". Perhaps a common superclass might be appropriate.</p>", "author": "pejovica", "createdAt": "2020-07-18T13:53:37Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,652 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file\n+ */\n+abstract class CVSymbolSubrecord {", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NDYzNA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457694634", "bodyText": "It might make the code slightly smaller but would break the abstraction. A SymbolRecord can contain many SymbolSubRecords, and they can have differing alignment, etc restrictions.", "author": "stooke", "createdAt": "2020-07-20T21:12:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc5MjMwOA=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex 18490aec405..ddb43d1039c 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -27,20 +27,18 @@\n package com.oracle.objectfile.pecoff.cv;\n \n import com.oracle.objectfile.ObjectFile;\n-import com.oracle.objectfile.SectionName;\n import com.oracle.objectfile.debugentry.ClassEntry;\n \n import java.util.HashMap;\n import java.util.Map;\n \n-import static java.nio.charset.StandardCharsets.UTF_8;\n-\n /*\n- * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file\n+ * A CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file.\n  */\n abstract class CVSymbolSubrecord {\n \n     private int subrecordStartPosition;\n+\n     private final short cmd;\n     CVDebugInfo cvDebugInfo;\n \n", "next_change": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex ddb43d1039c..0a30db69e94 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -40,7 +39,7 @@ abstract class CVSymbolSubrecord {\n     private int subrecordStartPosition;\n \n     private final short cmd;\n-    CVDebugInfo cvDebugInfo;\n+    protected final CVDebugInfo cvDebugInfo;\n \n     CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n         this.cvDebugInfo = cvDebugInfo;\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc5OTA5MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456799090", "body": "```suggestion\r\n            return computeContents(null, initialPos);\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        int pos = initialPos + Integer.BYTES; /* signature = 0; */\n          \n          \n            \n                        pos += objName.getBytes(UTF_8).length + 1; /* inline null terminated */\n          \n          \n            \n                        return pos;\n          \n          \n            \n                        return computeContents(null, initialPos);", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"112\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-k\">int</span> pos <span class=\"pl-k\">=</span> initialPos <span class=\"pl-k\">+</span> <span class=\"pl-smi\">Integer</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>BYTES</span>; <span class=\"pl-c\"><span class=\"pl-c\">/*</span> signature = 0; <span class=\"pl-c\">*/</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"113\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            pos <span class=\"pl-k\">+=</span> objName<span class=\"pl-k\">.</span>getBytes(<span class=\"pl-c1\">UTF_8</span>)<span class=\"pl-k\">.</span>length <span class=\"pl-k\">+</span> <span class=\"pl-c1\">1</span>; <span class=\"pl-c\"><span class=\"pl-c\">/*</span> inline null terminated <span class=\"pl-c\">*/</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"114\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-k\">return</span> pos;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"112\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            <span class=\"pl-k\">return</span> computeContents(<span class=\"pl-c1\">null</span>, initialPos);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pejovica", "createdAt": "2020-07-18T15:13:44Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,652 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.subrecordStartPosition = initialPos;\n+        int prologueLength = Short.BYTES * 2; /* room for length and subcommand */\n+        return computeSize(initialPos + prologueLength);\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* save room for length (no including length bytes) */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(cmd=0x%04x pos=0x%06x)\", cmd, subrecordStartPosition);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeSize(int pos);\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* TODO: how to find the full path to object file we will produce */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Get file from first class object */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            int pos = initialPos + Integer.BYTES; /* signature = 0; */\n+            pos += objName.getBytes(UTF_8).length + 1; /* inline null terminated */\n+            return pos;", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NDc2NQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457694765", "bodyText": "Sold.", "author": "stooke", "createdAt": "2020-07-20T21:12:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc5OTA5MA=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex 18490aec405..ddb43d1039c 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -115,24 +106,22 @@ abstract class CVSymbolSubrecord {\n         }\n \n         @Override\n-        protected int computeSize(int initialPos) {\n-            int pos = initialPos + Integer.BYTES; /* signature = 0; */\n-            pos += objName.getBytes(UTF_8).length + 1; /* inline null terminated */\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* Signature is currently set to 0. */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos);\n             return pos;\n         }\n \n         @Override\n-        protected int computeContents(byte[] buffer, int initialPos) {\n-            int pos = CVUtil.putInt(0, buffer, initialPos); /* signature = 0 */\n-            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos); /* inline null terminated */\n-            return pos;\n+        public String toString() {\n+            return \"S_OBJNAME \" + objName;\n         }\n     }\n \n     public static final class CVCompile3Record extends CVSymbolSubrecord {\n \n         private static final byte HAS_DEBUG_FLAG = 0;\n-        // private static final byte HAS_NO_DEBUG_FLAG = (byte)0x80;\n+        @SuppressWarnings(\"unused\") private static final byte HAS_NO_DEBUG_FLAG = (byte) 0x80;\n \n         private byte language;\n         private byte cf1;\n", "next_change": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex ddb43d1039c..0a30db69e94 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -123,20 +122,20 @@ abstract class CVSymbolSubrecord {\n         private static final byte HAS_DEBUG_FLAG = 0;\n         @SuppressWarnings(\"unused\") private static final byte HAS_NO_DEBUG_FLAG = (byte) 0x80;\n \n-        private byte language;\n-        private byte cf1;\n-        private byte cf2;\n-        private byte padding;\n-        private short machine;\n-        private short feMajor;\n-        private short feMinor;\n-        private short feBuild;\n-        private short feQFE;\n-        private short beMajor;\n-        private short beMinor;\n-        private short beBuild;\n-        private short beQFE;\n-        private String compiler;\n+        private final byte language;\n+        private final byte cf1;\n+        private final byte cf2;\n+        private final byte padding;\n+        private final short machine;\n+        private final short feMajor;\n+        private final short feMinor;\n+        private final short feBuild;\n+        private final short feQFE;\n+        private final short beMajor;\n+        private final short beMinor;\n+        private final short beBuild;\n+        private final short beQFE;\n+        private final String compiler;\n \n         CVCompile3Record(CVDebugInfo cvDebugInfo) {\n             super(cvDebugInfo, CVDebugConstants.S_COMPILE3);\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgwOTcyMw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456809723", "body": "I think this should be passed in to `CVDebugInfo` via `DebugInfoProvider`.", "bodyText": "I think this should be passed in to CVDebugInfo via DebugInfoProvider.", "bodyHTML": "<p dir=\"auto\">I think this should be passed in to <code>CVDebugInfo</code> via <code>DebugInfoProvider</code>.</p>", "author": "pejovica", "createdAt": "2020-07-18T17:18:55Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,652 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.subrecordStartPosition = initialPos;\n+        int prologueLength = Short.BYTES * 2; /* room for length and subcommand */\n+        return computeSize(initialPos + prologueLength);\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* save room for length (no including length bytes) */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(cmd=0x%04x pos=0x%06x)\", cmd, subrecordStartPosition);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeSize(int pos);\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* TODO: how to find the full path to object file we will produce */", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NDgwNg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457694806", "bodyText": "DebugInfoProvider is due for a rework when the PRs for Dwarf and PE/Coff typeinfo are submitted.  I'd prefer to leave this for now.  There is other information I can expose in CodeView format; but it's not clear how much is useful.", "author": "stooke", "createdAt": "2020-07-20T21:12:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgwOTcyMw=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex 18490aec405..ddb43d1039c 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -78,13 +71,11 @@ abstract class CVSymbolSubrecord {\n         return cmd;\n     }\n \n-    protected abstract int computeSize(int pos);\n-\n     protected abstract int computeContents(byte[] buffer, int pos);\n \n     public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n \n-        String objName; /* TODO: how to find the full path to object file we will produce */\n+        String objName; /* find the full path to object file we will produce. */\n \n         CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n             super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n", "next_change": {"commit": "be97e8b0b377da7184398ae13748683d31424624", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex ddb43d1039c..1612d381498 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -75,7 +74,7 @@ abstract class CVSymbolSubrecord {\n \n     public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n \n-        String objName; /* find the full path to object file we will produce. */\n+        private final String objName; /* find the full path to object file we will produce. */\n \n         CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n             super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMDEyMg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456810122", "body": "A leftover?", "bodyText": "A leftover?", "bodyHTML": "<p dir=\"auto\">A leftover?</p>", "author": "pejovica", "createdAt": "2020-07-18T17:23:21Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,652 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.subrecordStartPosition = initialPos;\n+        int prologueLength = Short.BYTES * 2; /* room for length and subcommand */\n+        return computeSize(initialPos + prologueLength);\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* save room for length (no including length bytes) */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(cmd=0x%04x pos=0x%06x)\", cmd, subrecordStartPosition);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeSize(int pos);\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* TODO: how to find the full path to object file we will produce */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Get file from first class object */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            int pos = initialPos + Integer.BYTES; /* signature = 0; */\n+            pos += objName.getBytes(UTF_8).length + 1; /* inline null terminated */\n+            return pos;\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* signature = 0 */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos); /* inline null terminated */\n+            return pos;\n+        }\n+    }\n+\n+    public static final class CVCompile3Record extends CVSymbolSubrecord {\n+\n+        private static final byte HAS_DEBUG_FLAG = 0;\n+        // private static final byte HAS_NO_DEBUG_FLAG = (byte)0x80;", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NDg5NA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457694894", "bodyText": "This is one of those awkward constants I wanted to capture for future use.  You'd think \"no debug info\" would be 0 and \"has debug info\" would be, say, 1.  I've uncommented it and suppressed the \"unused\" warning.", "author": "stooke", "createdAt": "2020-07-20T21:13:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMDEyMg=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex 18490aec405..ddb43d1039c 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -115,24 +106,22 @@ abstract class CVSymbolSubrecord {\n         }\n \n         @Override\n-        protected int computeSize(int initialPos) {\n-            int pos = initialPos + Integer.BYTES; /* signature = 0; */\n-            pos += objName.getBytes(UTF_8).length + 1; /* inline null terminated */\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* Signature is currently set to 0. */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos);\n             return pos;\n         }\n \n         @Override\n-        protected int computeContents(byte[] buffer, int initialPos) {\n-            int pos = CVUtil.putInt(0, buffer, initialPos); /* signature = 0 */\n-            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos); /* inline null terminated */\n-            return pos;\n+        public String toString() {\n+            return \"S_OBJNAME \" + objName;\n         }\n     }\n \n     public static final class CVCompile3Record extends CVSymbolSubrecord {\n \n         private static final byte HAS_DEBUG_FLAG = 0;\n-        // private static final byte HAS_NO_DEBUG_FLAG = (byte)0x80;\n+        @SuppressWarnings(\"unused\") private static final byte HAS_NO_DEBUG_FLAG = (byte) 0x80;\n \n         private byte language;\n         private byte cf1;\n", "next_change": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex ddb43d1039c..0a30db69e94 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -123,20 +122,20 @@ abstract class CVSymbolSubrecord {\n         private static final byte HAS_DEBUG_FLAG = 0;\n         @SuppressWarnings(\"unused\") private static final byte HAS_NO_DEBUG_FLAG = (byte) 0x80;\n \n-        private byte language;\n-        private byte cf1;\n-        private byte cf2;\n-        private byte padding;\n-        private short machine;\n-        private short feMajor;\n-        private short feMinor;\n-        private short feBuild;\n-        private short feQFE;\n-        private short beMajor;\n-        private short beMinor;\n-        private short beBuild;\n-        private short beQFE;\n-        private String compiler;\n+        private final byte language;\n+        private final byte cf1;\n+        private final byte cf2;\n+        private final byte padding;\n+        private final short machine;\n+        private final short feMajor;\n+        private final short feMinor;\n+        private final short feBuild;\n+        private final short feQFE;\n+        private final short beMajor;\n+        private final short beMinor;\n+        private final short beBuild;\n+        private final short beQFE;\n+        private final String compiler;\n \n         CVCompile3Record(CVDebugInfo cvDebugInfo) {\n             super(cvDebugInfo, CVDebugConstants.S_COMPILE3);\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMTAyNw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456811027", "body": "So what is the purpose of this?", "bodyText": "So what is the purpose of this?", "bodyHTML": "<p dir=\"auto\">So what is the purpose of this?</p>", "author": "pejovica", "createdAt": "2020-07-18T17:34:09Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,652 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.subrecordStartPosition = initialPos;\n+        int prologueLength = Short.BYTES * 2; /* room for length and subcommand */\n+        return computeSize(initialPos + prologueLength);\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* save room for length (no including length bytes) */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(cmd=0x%04x pos=0x%06x)\", cmd, subrecordStartPosition);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeSize(int pos);\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* TODO: how to find the full path to object file we will produce */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Get file from first class object */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            int pos = initialPos + Integer.BYTES; /* signature = 0; */\n+            pos += objName.getBytes(UTF_8).length + 1; /* inline null terminated */\n+            return pos;\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* signature = 0 */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos); /* inline null terminated */\n+            return pos;\n+        }\n+    }\n+\n+    public static final class CVCompile3Record extends CVSymbolSubrecord {\n+\n+        private static final byte HAS_DEBUG_FLAG = 0;\n+        // private static final byte HAS_NO_DEBUG_FLAG = (byte)0x80;\n+\n+        private byte language;\n+        private byte cf1;\n+        private byte cf2;\n+        private byte padding;\n+        private short machine;\n+        private short feMajor;\n+        private short feMinor;\n+        private short feBuild;\n+        private short feQFE;\n+        private short beMajor;\n+        private short beMinor;\n+        private short beBuild;\n+        private short beQFE;\n+        private String compiler;\n+\n+        CVCompile3Record(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_COMPILE3);\n+            language = 0;\n+            cf1 = HAS_DEBUG_FLAG;\n+            cf2 = (byte) 0;\n+            padding = (byte) 0;\n+            machine = (short) 208;\n+            feMajor = (short) 2;\n+            feMinor = (short) 3;\n+            feBuild = (short) 4;\n+            feQFE = (short) 5;\n+            beMajor = (short) 6;\n+            beMinor = (short) 7;\n+            beBuild = (short) 8;\n+            beQFE = (short) 9;\n+            compiler = \"graal\";\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putByte(language, buffer, initialPos);\n+            pos = CVUtil.putByte(cf1, buffer, pos);\n+            pos = CVUtil.putByte(cf2, buffer, pos);\n+            pos = CVUtil.putByte(padding, buffer, pos);\n+            pos = CVUtil.putShort(machine, buffer, pos);\n+            pos = CVUtil.putShort(feMajor, buffer, pos);\n+            pos = CVUtil.putShort(feMinor, buffer, pos);\n+            pos = CVUtil.putShort(feBuild, buffer, pos);\n+            pos = CVUtil.putShort(feQFE, buffer, pos);\n+            pos = CVUtil.putShort(beMajor, buffer, pos);\n+            pos = CVUtil.putShort(beMinor, buffer, pos);\n+            pos = CVUtil.putShort(beBuild, buffer, pos);\n+            pos = CVUtil.putShort(beQFE, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(compiler, buffer, pos);  // inline null terminated\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_COMPILE3 machine=%d fe=%d.%d.%d.%d be=%d.%d.%d%d compiler=%s\", machine, feMajor, feMinor, feBuild, feQFE, beMajor, beMinor, beBuild, beQFE, compiler);\n+        }\n+    }\n+\n+    public static final class CVEnvBlockRecord extends CVSymbolSubrecord {\n+\n+        private static final int ENVMAP_INITIAL_CAPACITY = 10;\n+\n+        private Map<String, String> map = new HashMap<>(ENVMAP_INITIAL_CAPACITY);\n+\n+        /*-\n+         * Example contents of the environment block:\n+         *   cwd = C:\\tmp\\graal-8\n+         *   cl = C:\\tmp\\graal-8\\ojdkbuild\\tools\\toolchain\\vs2010e\\VC\\Bin\\x86_amd64\\cl.exe\n+         *   cmd = -Zi -MT -IC:\\tmp\\graal-8\\tools\\toolchain\\vs2010e\\VC\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE\\gl -TC -X\n+         *   src = helloworld.c\n+         *   pdb = C:\\tmp\\graal-8\\vc100.pdb\n+         */\n+        CVEnvBlockRecord(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_ENVBLOCK);\n+\n+            /* current directory */\n+            map.put(\"cwd\", System.getProperty(\"user.dir\"));\n+\n+            /* compiler executable */\n+            // map.put(\"cl\", \"cl.exe\");\n+\n+            /* argument list */\n+            // map.put(\"cmd\", \"-Zi -MT -wishfulthinking\");\n+\n+            /*\n+             * find first source file - which, for Graal would be a class file on the command line\n+             */\n+            String fn = findFirstFile(cvDebugInfo);\n+            if (fn != null) {\n+                map.put(\"src\", fn);\n+            }\n+\n+            /* Graal doesn't yet create PDB files; all type info is stored in object file */\n+            // map.put(\"pdb\", System.getProperty(\"user.dir\") + File.separator + \"vc100.pdb\");\n+        }\n+\n+        private static String findFirstFile(CVDebugInfo cvDebugInfo) {\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            /* flags */\n+            int pos = CVUtil.putByte((byte) 0, buffer, initialPos);\n+\n+            /* key/value pairs */\n+            for (Map.Entry<String, String> entry : map.entrySet()) {\n+                pos = CVUtil.putUTF8StringBytes(entry.getKey(), buffer, pos);\n+                pos = CVUtil.putUTF8StringBytes(entry.getValue(), buffer, pos);\n+            }\n+\n+            /* end marker */\n+            pos = CVUtil.putUTF8StringBytes(\"\", buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"S_ENVBLOCK \" + map.size() + \" entries\";\n+        }\n+    }\n+\n+    /*\n+     * creating a proc32 record has side effects. - a global symbol is added to the COFF symbol\n+     * section - two relocation entries are added to the section relocation table, they refer to the\n+     * global symbol\n+     */\n+    public static class CVSymbolGProc32Record extends CVSymbolSubrecord {\n+\n+        private static ObjectFile.Element textSection;\n+\n+        int pparent;\n+        int pend;\n+        int pnext;\n+        int proclen;\n+        int debugStart;\n+        int debugEnd;\n+        int typeIndex;\n+        int offset;\n+        short segment;\n+        byte flags;\n+        String name;\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, short cmd, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment,\n+                        byte flags) {\n+            super(cvDebugInfo, cmd);\n+            this.name = name;\n+            this.pparent = pparent;\n+            this.pend = pend;\n+            this.pnext = pnext;\n+            this.proclen = proclen;\n+            this.debugStart = debugStart;\n+            this.debugEnd = debugEnd;\n+            this.typeIndex = typeIndex;\n+            this.offset = offset;\n+            this.segment = segment;\n+            this.flags = flags;\n+        }\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment, byte flags) {\n+            this(cvDebugInfo, CVDebugConstants.S_GPROC32, name, pparent, pend, pnext, proclen, debugStart, debugEnd, typeIndex, offset, segment, flags);\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(pparent, buffer, initialPos);\n+            pos = CVUtil.putInt(pend, buffer, pos);\n+            pos = CVUtil.putInt(pnext, buffer, pos);\n+            pos = CVUtil.putInt(proclen, buffer, pos);\n+            pos = CVUtil.putInt(debugStart, buffer, pos);\n+            pos = CVUtil.putInt(debugEnd, buffer, pos);\n+            pos = CVUtil.putInt(typeIndex, buffer, pos);\n+            if (buffer == null) {\n+                cvDebugInfo.getCVSymbolSection().getOwner().createDefinedSymbol(name, getTextSection(), offset, proclen, true, true);\n+            }\n+            if (buffer != null) {\n+                // CVUtil.debug(\"CVSymbolGProc32Record() adding SECREL reloc at pos=0x%x for func=%s\n+                // addr=0x%x\\n\", pos, name, offset);\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 4, ObjectFile.RelocationKind.SECREL, name, false, 1L);\n+            }\n+            pos = CVUtil.putInt(0, buffer, pos);\n+            if (buffer != null) {\n+                // CVUtil.debug(\"CVSymbolGProc32Record() adding SECTION reloc at pos=0x%x for\n+                // func=%s addr=0x%x\\n\", pos, name, offset);\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 2, ObjectFile.RelocationKind.SECTION, name, false, 1L);\n+            }\n+            pos = CVUtil.putShort((short) 0, buffer, pos);\n+            pos = CVUtil.putByte(flags, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(name, buffer, pos);\n+            return pos;\n+        }\n+\n+        private ObjectFile.Element getTextSection() {\n+            if (textSection == null) {\n+                textSection = cvDebugInfo.getCVSymbolSection().getOwner().elementForName(SectionName.TEXT.getFormatDependentName(ObjectFile.Format.PECOFF));\n+            }\n+            return textSection;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            cvDebugInfo.getCVSymbolSection().debugAddress = offset;", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NDk0MQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457694941", "bodyText": "It's gone.   I have no idea what I was thinking at the time.", "author": "stooke", "createdAt": "2020-07-20T21:13:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMTAyNw=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex 18490aec405..ddb43d1039c 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -328,60 +296,25 @@ abstract class CVSymbolSubrecord {\n             pos = CVUtil.putInt(debugStart, buffer, pos);\n             pos = CVUtil.putInt(debugEnd, buffer, pos);\n             pos = CVUtil.putInt(typeIndex, buffer, pos);\n-            if (buffer == null) {\n-                cvDebugInfo.getCVSymbolSection().getOwner().createDefinedSymbol(name, getTextSection(), offset, proclen, true, true);\n-            }\n             if (buffer != null) {\n-                // CVUtil.debug(\"CVSymbolGProc32Record() adding SECREL reloc at pos=0x%x for func=%s\n-                // addr=0x%x\\n\", pos, name, offset);\n-                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 4, ObjectFile.RelocationKind.SECREL, name, false, 1L);\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, externalName, false, 1L);\n             }\n             pos = CVUtil.putInt(0, buffer, pos);\n             if (buffer != null) {\n-                // CVUtil.debug(\"CVSymbolGProc32Record() adding SECTION reloc at pos=0x%x for\n-                // func=%s addr=0x%x\\n\", pos, name, offset);\n-                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 2, ObjectFile.RelocationKind.SECTION, name, false, 1L);\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, externalName, false, 1L);\n             }\n             pos = CVUtil.putShort((short) 0, buffer, pos);\n             pos = CVUtil.putByte(flags, buffer, pos);\n-            pos = CVUtil.putUTF8StringBytes(name, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(debuggerName, buffer, pos);\n             return pos;\n         }\n \n-        private ObjectFile.Element getTextSection() {\n-            if (textSection == null) {\n-                textSection = cvDebugInfo.getCVSymbolSection().getOwner().elementForName(SectionName.TEXT.getFormatDependentName(ObjectFile.Format.PECOFF));\n-            }\n-            return textSection;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            cvDebugInfo.getCVSymbolSection().debugAddress = offset;\n-            return String.format(\"S_GPROC32   name=%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", name, pparent, debugStart, debugEnd, proclen, offset,\n-                            typeIndex,\n-                            flags);\n-        }\n-    }\n-\n-    /*-\n-    public static final class CVSymbolGProc32IDRecord extends CVSymbolGProc32Record {\n-\n-        CVSymbolGProc32IDRecord(CVDebugInfo cvDebugInfo, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment, byte flags) {\n-            super(cvDebugInfo, CVDebugConstants.S_GPROC32_ID, name, pparent, pend, pnext, proclen, debugStart, debugEnd, typeIndex, offset, segment, flags);\n-        }\n-\n-        /* this is almost certainly bad (not enough information); use only for debugging *\n-        CVSymbolGProc32IDRecord(CVDebugInfo cvDebugInfo, String name, int offset, int proclen) {\n-            super(cvDebugInfo, CVDebugConstants.S_GPROC32_ID, name, 0, 0, 0, proclen, 0, 0, 0, offset, (short)0, (byte)0);\n-        }\n-\n         @Override\n         public String toString() {\n-            return String.format(\"S_GPROC32_ID(name=%s parent=%d startaddr=0x%x end=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", name, pparent, debugStart, debugEnd, proclen, offset, typeIndex, flags);\n+            return String.format(\"S_GPROC32   name=%s/%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", debuggerName, externalName, pparent, debugStart, debugEnd,\n+                            proclen, offset, typeIndex, flags);\n         }\n     }\n-    */\n \n     public static final class CVSymbolFrameProcRecord extends CVSymbolSubrecord {\n \n", "next_change": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex ddb43d1039c..0a30db69e94 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -296,35 +295,28 @@ abstract class CVSymbolSubrecord {\n             pos = CVUtil.putInt(debugStart, buffer, pos);\n             pos = CVUtil.putInt(debugEnd, buffer, pos);\n             pos = CVUtil.putInt(typeIndex, buffer, pos);\n-            if (buffer != null) {\n-                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, externalName, false, 1L);\n-            }\n-            pos = CVUtil.putInt(0, buffer, pos);\n-            if (buffer != null) {\n-                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, externalName, false, 1L);\n-            }\n-            pos = CVUtil.putShort((short) 0, buffer, pos);\n+            pos = cvDebugInfo.getCVSymbolSection().markRelocationSite(buffer, pos, symbolName, (long) 0);\n             pos = CVUtil.putByte(flags, buffer, pos);\n-            pos = CVUtil.putUTF8StringBytes(debuggerName, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(displayName, buffer, pos);\n             return pos;\n         }\n \n         @Override\n         public String toString() {\n-            return String.format(\"S_GPROC32   name=%s/%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", debuggerName, externalName, pparent, debugStart, debugEnd,\n-                            proclen, offset, typeIndex, flags);\n+            return String.format(\"S_GPROC32   name=%s/%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x seg:offset=0x%x:0x%x type=0x%x flags=0x%x)\", displayName, symbolName, pparent, debugStart, debugEnd,\n+                            proclen, segment, offset, typeIndex, flags);\n         }\n     }\n \n     public static final class CVSymbolFrameProcRecord extends CVSymbolSubrecord {\n \n-        int framelen;\n-        int padLen;\n-        int padOffset;\n-        int saveRegsCount;\n-        int ehOffset;\n-        short ehSection;\n-        int flags;\n+        private final int framelen;\n+        private final int padLen;\n+        private final int padOffset;\n+        private final int saveRegsCount;\n+        private final int ehOffset;\n+        private final short ehSection;\n+        private final int flags;\n \n         CVSymbolFrameProcRecord(CVDebugInfo cvDebugInfo, int framelen, int padLen, int padOffset, int saveRegsCount, int ehOffset, short ehSection, int flags) {\n             super(cvDebugInfo, CVDebugConstants.S_FRAMEPROC);\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMTA3OQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456811079", "body": "Unused code.", "bodyText": "Unused code.", "bodyHTML": "<p dir=\"auto\">Unused code.</p>", "author": "pejovica", "createdAt": "2020-07-18T17:34:44Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,652 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.subrecordStartPosition = initialPos;\n+        int prologueLength = Short.BYTES * 2; /* room for length and subcommand */\n+        return computeSize(initialPos + prologueLength);\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* save room for length (no including length bytes) */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(cmd=0x%04x pos=0x%06x)\", cmd, subrecordStartPosition);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeSize(int pos);\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* TODO: how to find the full path to object file we will produce */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Get file from first class object */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            int pos = initialPos + Integer.BYTES; /* signature = 0; */\n+            pos += objName.getBytes(UTF_8).length + 1; /* inline null terminated */\n+            return pos;\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* signature = 0 */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos); /* inline null terminated */\n+            return pos;\n+        }\n+    }\n+\n+    public static final class CVCompile3Record extends CVSymbolSubrecord {\n+\n+        private static final byte HAS_DEBUG_FLAG = 0;\n+        // private static final byte HAS_NO_DEBUG_FLAG = (byte)0x80;\n+\n+        private byte language;\n+        private byte cf1;\n+        private byte cf2;\n+        private byte padding;\n+        private short machine;\n+        private short feMajor;\n+        private short feMinor;\n+        private short feBuild;\n+        private short feQFE;\n+        private short beMajor;\n+        private short beMinor;\n+        private short beBuild;\n+        private short beQFE;\n+        private String compiler;\n+\n+        CVCompile3Record(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_COMPILE3);\n+            language = 0;\n+            cf1 = HAS_DEBUG_FLAG;\n+            cf2 = (byte) 0;\n+            padding = (byte) 0;\n+            machine = (short) 208;\n+            feMajor = (short) 2;\n+            feMinor = (short) 3;\n+            feBuild = (short) 4;\n+            feQFE = (short) 5;\n+            beMajor = (short) 6;\n+            beMinor = (short) 7;\n+            beBuild = (short) 8;\n+            beQFE = (short) 9;\n+            compiler = \"graal\";\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putByte(language, buffer, initialPos);\n+            pos = CVUtil.putByte(cf1, buffer, pos);\n+            pos = CVUtil.putByte(cf2, buffer, pos);\n+            pos = CVUtil.putByte(padding, buffer, pos);\n+            pos = CVUtil.putShort(machine, buffer, pos);\n+            pos = CVUtil.putShort(feMajor, buffer, pos);\n+            pos = CVUtil.putShort(feMinor, buffer, pos);\n+            pos = CVUtil.putShort(feBuild, buffer, pos);\n+            pos = CVUtil.putShort(feQFE, buffer, pos);\n+            pos = CVUtil.putShort(beMajor, buffer, pos);\n+            pos = CVUtil.putShort(beMinor, buffer, pos);\n+            pos = CVUtil.putShort(beBuild, buffer, pos);\n+            pos = CVUtil.putShort(beQFE, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(compiler, buffer, pos);  // inline null terminated\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_COMPILE3 machine=%d fe=%d.%d.%d.%d be=%d.%d.%d%d compiler=%s\", machine, feMajor, feMinor, feBuild, feQFE, beMajor, beMinor, beBuild, beQFE, compiler);\n+        }\n+    }\n+\n+    public static final class CVEnvBlockRecord extends CVSymbolSubrecord {\n+\n+        private static final int ENVMAP_INITIAL_CAPACITY = 10;\n+\n+        private Map<String, String> map = new HashMap<>(ENVMAP_INITIAL_CAPACITY);\n+\n+        /*-\n+         * Example contents of the environment block:\n+         *   cwd = C:\\tmp\\graal-8\n+         *   cl = C:\\tmp\\graal-8\\ojdkbuild\\tools\\toolchain\\vs2010e\\VC\\Bin\\x86_amd64\\cl.exe\n+         *   cmd = -Zi -MT -IC:\\tmp\\graal-8\\tools\\toolchain\\vs2010e\\VC\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE\\gl -TC -X\n+         *   src = helloworld.c\n+         *   pdb = C:\\tmp\\graal-8\\vc100.pdb\n+         */\n+        CVEnvBlockRecord(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_ENVBLOCK);\n+\n+            /* current directory */\n+            map.put(\"cwd\", System.getProperty(\"user.dir\"));\n+\n+            /* compiler executable */\n+            // map.put(\"cl\", \"cl.exe\");\n+\n+            /* argument list */\n+            // map.put(\"cmd\", \"-Zi -MT -wishfulthinking\");\n+\n+            /*\n+             * find first source file - which, for Graal would be a class file on the command line\n+             */\n+            String fn = findFirstFile(cvDebugInfo);\n+            if (fn != null) {\n+                map.put(\"src\", fn);\n+            }\n+\n+            /* Graal doesn't yet create PDB files; all type info is stored in object file */\n+            // map.put(\"pdb\", System.getProperty(\"user.dir\") + File.separator + \"vc100.pdb\");\n+        }\n+\n+        private static String findFirstFile(CVDebugInfo cvDebugInfo) {\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            /* flags */\n+            int pos = CVUtil.putByte((byte) 0, buffer, initialPos);\n+\n+            /* key/value pairs */\n+            for (Map.Entry<String, String> entry : map.entrySet()) {\n+                pos = CVUtil.putUTF8StringBytes(entry.getKey(), buffer, pos);\n+                pos = CVUtil.putUTF8StringBytes(entry.getValue(), buffer, pos);\n+            }\n+\n+            /* end marker */\n+            pos = CVUtil.putUTF8StringBytes(\"\", buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"S_ENVBLOCK \" + map.size() + \" entries\";\n+        }\n+    }\n+\n+    /*\n+     * creating a proc32 record has side effects. - a global symbol is added to the COFF symbol\n+     * section - two relocation entries are added to the section relocation table, they refer to the\n+     * global symbol\n+     */\n+    public static class CVSymbolGProc32Record extends CVSymbolSubrecord {\n+\n+        private static ObjectFile.Element textSection;\n+\n+        int pparent;\n+        int pend;\n+        int pnext;\n+        int proclen;\n+        int debugStart;\n+        int debugEnd;\n+        int typeIndex;\n+        int offset;\n+        short segment;\n+        byte flags;\n+        String name;\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, short cmd, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment,\n+                        byte flags) {\n+            super(cvDebugInfo, cmd);\n+            this.name = name;\n+            this.pparent = pparent;\n+            this.pend = pend;\n+            this.pnext = pnext;\n+            this.proclen = proclen;\n+            this.debugStart = debugStart;\n+            this.debugEnd = debugEnd;\n+            this.typeIndex = typeIndex;\n+            this.offset = offset;\n+            this.segment = segment;\n+            this.flags = flags;\n+        }\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment, byte flags) {\n+            this(cvDebugInfo, CVDebugConstants.S_GPROC32, name, pparent, pend, pnext, proclen, debugStart, debugEnd, typeIndex, offset, segment, flags);\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(pparent, buffer, initialPos);\n+            pos = CVUtil.putInt(pend, buffer, pos);\n+            pos = CVUtil.putInt(pnext, buffer, pos);\n+            pos = CVUtil.putInt(proclen, buffer, pos);\n+            pos = CVUtil.putInt(debugStart, buffer, pos);\n+            pos = CVUtil.putInt(debugEnd, buffer, pos);\n+            pos = CVUtil.putInt(typeIndex, buffer, pos);\n+            if (buffer == null) {\n+                cvDebugInfo.getCVSymbolSection().getOwner().createDefinedSymbol(name, getTextSection(), offset, proclen, true, true);\n+            }\n+            if (buffer != null) {\n+                // CVUtil.debug(\"CVSymbolGProc32Record() adding SECREL reloc at pos=0x%x for func=%s\n+                // addr=0x%x\\n\", pos, name, offset);\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 4, ObjectFile.RelocationKind.SECREL, name, false, 1L);\n+            }\n+            pos = CVUtil.putInt(0, buffer, pos);\n+            if (buffer != null) {\n+                // CVUtil.debug(\"CVSymbolGProc32Record() adding SECTION reloc at pos=0x%x for\n+                // func=%s addr=0x%x\\n\", pos, name, offset);\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 2, ObjectFile.RelocationKind.SECTION, name, false, 1L);\n+            }\n+            pos = CVUtil.putShort((short) 0, buffer, pos);\n+            pos = CVUtil.putByte(flags, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(name, buffer, pos);\n+            return pos;\n+        }\n+\n+        private ObjectFile.Element getTextSection() {\n+            if (textSection == null) {\n+                textSection = cvDebugInfo.getCVSymbolSection().getOwner().elementForName(SectionName.TEXT.getFormatDependentName(ObjectFile.Format.PECOFF));\n+            }\n+            return textSection;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            cvDebugInfo.getCVSymbolSection().debugAddress = offset;\n+            return String.format(\"S_GPROC32   name=%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", name, pparent, debugStart, debugEnd, proclen, offset,\n+                            typeIndex,\n+                            flags);\n+        }\n+    }\n+\n+    /*-\n+    public static final class CVSymbolGProc32IDRecord extends CVSymbolGProc32Record {", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NTAyNQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457695025", "bodyText": "Moved in with the unused future code at the bottom.", "author": "stooke", "createdAt": "2020-07-20T21:13:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMTA3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex 18490aec405..ddb43d1039c 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -328,60 +296,25 @@ abstract class CVSymbolSubrecord {\n             pos = CVUtil.putInt(debugStart, buffer, pos);\n             pos = CVUtil.putInt(debugEnd, buffer, pos);\n             pos = CVUtil.putInt(typeIndex, buffer, pos);\n-            if (buffer == null) {\n-                cvDebugInfo.getCVSymbolSection().getOwner().createDefinedSymbol(name, getTextSection(), offset, proclen, true, true);\n-            }\n             if (buffer != null) {\n-                // CVUtil.debug(\"CVSymbolGProc32Record() adding SECREL reloc at pos=0x%x for func=%s\n-                // addr=0x%x\\n\", pos, name, offset);\n-                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 4, ObjectFile.RelocationKind.SECREL, name, false, 1L);\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, externalName, false, 1L);\n             }\n             pos = CVUtil.putInt(0, buffer, pos);\n             if (buffer != null) {\n-                // CVUtil.debug(\"CVSymbolGProc32Record() adding SECTION reloc at pos=0x%x for\n-                // func=%s addr=0x%x\\n\", pos, name, offset);\n-                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 2, ObjectFile.RelocationKind.SECTION, name, false, 1L);\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, externalName, false, 1L);\n             }\n             pos = CVUtil.putShort((short) 0, buffer, pos);\n             pos = CVUtil.putByte(flags, buffer, pos);\n-            pos = CVUtil.putUTF8StringBytes(name, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(debuggerName, buffer, pos);\n             return pos;\n         }\n \n-        private ObjectFile.Element getTextSection() {\n-            if (textSection == null) {\n-                textSection = cvDebugInfo.getCVSymbolSection().getOwner().elementForName(SectionName.TEXT.getFormatDependentName(ObjectFile.Format.PECOFF));\n-            }\n-            return textSection;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            cvDebugInfo.getCVSymbolSection().debugAddress = offset;\n-            return String.format(\"S_GPROC32   name=%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", name, pparent, debugStart, debugEnd, proclen, offset,\n-                            typeIndex,\n-                            flags);\n-        }\n-    }\n-\n-    /*-\n-    public static final class CVSymbolGProc32IDRecord extends CVSymbolGProc32Record {\n-\n-        CVSymbolGProc32IDRecord(CVDebugInfo cvDebugInfo, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment, byte flags) {\n-            super(cvDebugInfo, CVDebugConstants.S_GPROC32_ID, name, pparent, pend, pnext, proclen, debugStart, debugEnd, typeIndex, offset, segment, flags);\n-        }\n-\n-        /* this is almost certainly bad (not enough information); use only for debugging *\n-        CVSymbolGProc32IDRecord(CVDebugInfo cvDebugInfo, String name, int offset, int proclen) {\n-            super(cvDebugInfo, CVDebugConstants.S_GPROC32_ID, name, 0, 0, 0, proclen, 0, 0, 0, offset, (short)0, (byte)0);\n-        }\n-\n         @Override\n         public String toString() {\n-            return String.format(\"S_GPROC32_ID(name=%s parent=%d startaddr=0x%x end=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", name, pparent, debugStart, debugEnd, proclen, offset, typeIndex, flags);\n+            return String.format(\"S_GPROC32   name=%s/%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", debuggerName, externalName, pparent, debugStart, debugEnd,\n+                            proclen, offset, typeIndex, flags);\n         }\n     }\n-    */\n \n     public static final class CVSymbolFrameProcRecord extends CVSymbolSubrecord {\n \n", "next_change": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex ddb43d1039c..0a30db69e94 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -296,35 +295,28 @@ abstract class CVSymbolSubrecord {\n             pos = CVUtil.putInt(debugStart, buffer, pos);\n             pos = CVUtil.putInt(debugEnd, buffer, pos);\n             pos = CVUtil.putInt(typeIndex, buffer, pos);\n-            if (buffer != null) {\n-                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, externalName, false, 1L);\n-            }\n-            pos = CVUtil.putInt(0, buffer, pos);\n-            if (buffer != null) {\n-                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, externalName, false, 1L);\n-            }\n-            pos = CVUtil.putShort((short) 0, buffer, pos);\n+            pos = cvDebugInfo.getCVSymbolSection().markRelocationSite(buffer, pos, symbolName, (long) 0);\n             pos = CVUtil.putByte(flags, buffer, pos);\n-            pos = CVUtil.putUTF8StringBytes(debuggerName, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(displayName, buffer, pos);\n             return pos;\n         }\n \n         @Override\n         public String toString() {\n-            return String.format(\"S_GPROC32   name=%s/%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", debuggerName, externalName, pparent, debugStart, debugEnd,\n-                            proclen, offset, typeIndex, flags);\n+            return String.format(\"S_GPROC32   name=%s/%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x seg:offset=0x%x:0x%x type=0x%x flags=0x%x)\", displayName, symbolName, pparent, debugStart, debugEnd,\n+                            proclen, segment, offset, typeIndex, flags);\n         }\n     }\n \n     public static final class CVSymbolFrameProcRecord extends CVSymbolSubrecord {\n \n-        int framelen;\n-        int padLen;\n-        int padOffset;\n-        int saveRegsCount;\n-        int ehOffset;\n-        short ehSection;\n-        int flags;\n+        private final int framelen;\n+        private final int padLen;\n+        private final int padOffset;\n+        private final int saveRegsCount;\n+        private final int ehOffset;\n+        private final short ehSection;\n+        private final int flags;\n \n         CVSymbolFrameProcRecord(CVDebugInfo cvDebugInfo, int framelen, int padLen, int padOffset, int saveRegsCount, int ehOffset, short ehSection, int flags) {\n             super(cvDebugInfo, CVDebugConstants.S_FRAMEPROC);\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMTI5MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456811290", "body": "Lots of unused code. \ud83d\ude09", "bodyText": "Lots of unused code. \ud83d\ude09", "bodyHTML": "<p dir=\"auto\">Lots of unused code. <g-emoji class=\"g-emoji\" alias=\"wink\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f609.png\">\ud83d\ude09</g-emoji></p>", "author": "pejovica", "createdAt": "2020-07-18T17:36:48Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,652 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.subrecordStartPosition = initialPos;\n+        int prologueLength = Short.BYTES * 2; /* room for length and subcommand */\n+        return computeSize(initialPos + prologueLength);\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* save room for length (no including length bytes) */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(cmd=0x%04x pos=0x%06x)\", cmd, subrecordStartPosition);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeSize(int pos);\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* TODO: how to find the full path to object file we will produce */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Get file from first class object */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            int pos = initialPos + Integer.BYTES; /* signature = 0; */\n+            pos += objName.getBytes(UTF_8).length + 1; /* inline null terminated */\n+            return pos;\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* signature = 0 */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos); /* inline null terminated */\n+            return pos;\n+        }\n+    }\n+\n+    public static final class CVCompile3Record extends CVSymbolSubrecord {\n+\n+        private static final byte HAS_DEBUG_FLAG = 0;\n+        // private static final byte HAS_NO_DEBUG_FLAG = (byte)0x80;\n+\n+        private byte language;\n+        private byte cf1;\n+        private byte cf2;\n+        private byte padding;\n+        private short machine;\n+        private short feMajor;\n+        private short feMinor;\n+        private short feBuild;\n+        private short feQFE;\n+        private short beMajor;\n+        private short beMinor;\n+        private short beBuild;\n+        private short beQFE;\n+        private String compiler;\n+\n+        CVCompile3Record(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_COMPILE3);\n+            language = 0;\n+            cf1 = HAS_DEBUG_FLAG;\n+            cf2 = (byte) 0;\n+            padding = (byte) 0;\n+            machine = (short) 208;\n+            feMajor = (short) 2;\n+            feMinor = (short) 3;\n+            feBuild = (short) 4;\n+            feQFE = (short) 5;\n+            beMajor = (short) 6;\n+            beMinor = (short) 7;\n+            beBuild = (short) 8;\n+            beQFE = (short) 9;\n+            compiler = \"graal\";\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putByte(language, buffer, initialPos);\n+            pos = CVUtil.putByte(cf1, buffer, pos);\n+            pos = CVUtil.putByte(cf2, buffer, pos);\n+            pos = CVUtil.putByte(padding, buffer, pos);\n+            pos = CVUtil.putShort(machine, buffer, pos);\n+            pos = CVUtil.putShort(feMajor, buffer, pos);\n+            pos = CVUtil.putShort(feMinor, buffer, pos);\n+            pos = CVUtil.putShort(feBuild, buffer, pos);\n+            pos = CVUtil.putShort(feQFE, buffer, pos);\n+            pos = CVUtil.putShort(beMajor, buffer, pos);\n+            pos = CVUtil.putShort(beMinor, buffer, pos);\n+            pos = CVUtil.putShort(beBuild, buffer, pos);\n+            pos = CVUtil.putShort(beQFE, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(compiler, buffer, pos);  // inline null terminated\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_COMPILE3 machine=%d fe=%d.%d.%d.%d be=%d.%d.%d%d compiler=%s\", machine, feMajor, feMinor, feBuild, feQFE, beMajor, beMinor, beBuild, beQFE, compiler);\n+        }\n+    }\n+\n+    public static final class CVEnvBlockRecord extends CVSymbolSubrecord {\n+\n+        private static final int ENVMAP_INITIAL_CAPACITY = 10;\n+\n+        private Map<String, String> map = new HashMap<>(ENVMAP_INITIAL_CAPACITY);\n+\n+        /*-\n+         * Example contents of the environment block:\n+         *   cwd = C:\\tmp\\graal-8\n+         *   cl = C:\\tmp\\graal-8\\ojdkbuild\\tools\\toolchain\\vs2010e\\VC\\Bin\\x86_amd64\\cl.exe\n+         *   cmd = -Zi -MT -IC:\\tmp\\graal-8\\tools\\toolchain\\vs2010e\\VC\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE\\gl -TC -X\n+         *   src = helloworld.c\n+         *   pdb = C:\\tmp\\graal-8\\vc100.pdb\n+         */\n+        CVEnvBlockRecord(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_ENVBLOCK);\n+\n+            /* current directory */\n+            map.put(\"cwd\", System.getProperty(\"user.dir\"));\n+\n+            /* compiler executable */\n+            // map.put(\"cl\", \"cl.exe\");\n+\n+            /* argument list */\n+            // map.put(\"cmd\", \"-Zi -MT -wishfulthinking\");\n+\n+            /*\n+             * find first source file - which, for Graal would be a class file on the command line\n+             */\n+            String fn = findFirstFile(cvDebugInfo);\n+            if (fn != null) {\n+                map.put(\"src\", fn);\n+            }\n+\n+            /* Graal doesn't yet create PDB files; all type info is stored in object file */\n+            // map.put(\"pdb\", System.getProperty(\"user.dir\") + File.separator + \"vc100.pdb\");\n+        }\n+\n+        private static String findFirstFile(CVDebugInfo cvDebugInfo) {\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            /* flags */\n+            int pos = CVUtil.putByte((byte) 0, buffer, initialPos);\n+\n+            /* key/value pairs */\n+            for (Map.Entry<String, String> entry : map.entrySet()) {\n+                pos = CVUtil.putUTF8StringBytes(entry.getKey(), buffer, pos);\n+                pos = CVUtil.putUTF8StringBytes(entry.getValue(), buffer, pos);\n+            }\n+\n+            /* end marker */\n+            pos = CVUtil.putUTF8StringBytes(\"\", buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"S_ENVBLOCK \" + map.size() + \" entries\";\n+        }\n+    }\n+\n+    /*\n+     * creating a proc32 record has side effects. - a global symbol is added to the COFF symbol\n+     * section - two relocation entries are added to the section relocation table, they refer to the\n+     * global symbol\n+     */\n+    public static class CVSymbolGProc32Record extends CVSymbolSubrecord {\n+\n+        private static ObjectFile.Element textSection;\n+\n+        int pparent;\n+        int pend;\n+        int pnext;\n+        int proclen;\n+        int debugStart;\n+        int debugEnd;\n+        int typeIndex;\n+        int offset;\n+        short segment;\n+        byte flags;\n+        String name;\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, short cmd, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment,\n+                        byte flags) {\n+            super(cvDebugInfo, cmd);\n+            this.name = name;\n+            this.pparent = pparent;\n+            this.pend = pend;\n+            this.pnext = pnext;\n+            this.proclen = proclen;\n+            this.debugStart = debugStart;\n+            this.debugEnd = debugEnd;\n+            this.typeIndex = typeIndex;\n+            this.offset = offset;\n+            this.segment = segment;\n+            this.flags = flags;\n+        }\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment, byte flags) {\n+            this(cvDebugInfo, CVDebugConstants.S_GPROC32, name, pparent, pend, pnext, proclen, debugStart, debugEnd, typeIndex, offset, segment, flags);\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(pparent, buffer, initialPos);\n+            pos = CVUtil.putInt(pend, buffer, pos);\n+            pos = CVUtil.putInt(pnext, buffer, pos);\n+            pos = CVUtil.putInt(proclen, buffer, pos);\n+            pos = CVUtil.putInt(debugStart, buffer, pos);\n+            pos = CVUtil.putInt(debugEnd, buffer, pos);\n+            pos = CVUtil.putInt(typeIndex, buffer, pos);\n+            if (buffer == null) {\n+                cvDebugInfo.getCVSymbolSection().getOwner().createDefinedSymbol(name, getTextSection(), offset, proclen, true, true);\n+            }\n+            if (buffer != null) {\n+                // CVUtil.debug(\"CVSymbolGProc32Record() adding SECREL reloc at pos=0x%x for func=%s\n+                // addr=0x%x\\n\", pos, name, offset);\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 4, ObjectFile.RelocationKind.SECREL, name, false, 1L);\n+            }\n+            pos = CVUtil.putInt(0, buffer, pos);\n+            if (buffer != null) {\n+                // CVUtil.debug(\"CVSymbolGProc32Record() adding SECTION reloc at pos=0x%x for\n+                // func=%s addr=0x%x\\n\", pos, name, offset);\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 2, ObjectFile.RelocationKind.SECTION, name, false, 1L);\n+            }\n+            pos = CVUtil.putShort((short) 0, buffer, pos);\n+            pos = CVUtil.putByte(flags, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(name, buffer, pos);\n+            return pos;\n+        }\n+\n+        private ObjectFile.Element getTextSection() {\n+            if (textSection == null) {\n+                textSection = cvDebugInfo.getCVSymbolSection().getOwner().elementForName(SectionName.TEXT.getFormatDependentName(ObjectFile.Format.PECOFF));\n+            }\n+            return textSection;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            cvDebugInfo.getCVSymbolSection().debugAddress = offset;\n+            return String.format(\"S_GPROC32   name=%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", name, pparent, debugStart, debugEnd, proclen, offset,\n+                            typeIndex,\n+                            flags);\n+        }\n+    }\n+\n+    /*-\n+    public static final class CVSymbolGProc32IDRecord extends CVSymbolGProc32Record {\n+\n+        CVSymbolGProc32IDRecord(CVDebugInfo cvDebugInfo, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment, byte flags) {\n+            super(cvDebugInfo, CVDebugConstants.S_GPROC32_ID, name, pparent, pend, pnext, proclen, debugStart, debugEnd, typeIndex, offset, segment, flags);\n+        }\n+\n+        /* this is almost certainly bad (not enough information); use only for debugging *\n+        CVSymbolGProc32IDRecord(CVDebugInfo cvDebugInfo, String name, int offset, int proclen) {\n+            super(cvDebugInfo, CVDebugConstants.S_GPROC32_ID, name, 0, 0, 0, proclen, 0, 0, 0, offset, (short)0, (byte)0);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_GPROC32_ID(name=%s parent=%d startaddr=0x%x end=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", name, pparent, debugStart, debugEnd, proclen, offset, typeIndex, flags);\n+        }\n+    }\n+    */\n+\n+    public static final class CVSymbolFrameProcRecord extends CVSymbolSubrecord {\n+\n+        int framelen;\n+        int padLen;\n+        int padOffset;\n+        int saveRegsCount;\n+        int ehOffset;\n+        short ehSection;\n+        int flags;\n+\n+        CVSymbolFrameProcRecord(CVDebugInfo cvDebugInfo, int framelen, int padLen, int padOffset, int saveRegsCount, int ehOffset, short ehSection, int flags) {\n+            super(cvDebugInfo, CVDebugConstants.S_FRAMEPROC);\n+            this.framelen = framelen;\n+            this.padLen = padLen;\n+            this.padOffset = padOffset;\n+            this.saveRegsCount = saveRegsCount;\n+            this.ehOffset = ehOffset;\n+            this.ehSection = ehSection;\n+            this.flags = flags;\n+        }\n+\n+        CVSymbolFrameProcRecord(CVDebugInfo cvDebugInfo, int framelen, int flags) {\n+            this(cvDebugInfo, framelen, 0, 0, 0, 0, (short) 0, flags);\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(framelen, buffer, initialPos);\n+            pos = CVUtil.putInt(padLen, buffer, pos);\n+            pos = CVUtil.putInt(padOffset, buffer, pos);\n+            pos = CVUtil.putInt(saveRegsCount, buffer, pos);\n+            pos = CVUtil.putInt(ehOffset, buffer, pos);\n+            pos = CVUtil.putShort(ehSection, buffer, pos);\n+            pos = CVUtil.putInt(flags, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_FRAMEPROC len=0x%x padlen=0x%x paddOffset=0x%x regCount=%d flags=0x%x \", framelen, padLen, padOffset, saveRegsCount, flags);\n+        }\n+    }\n+\n+    public static class CVSymbolEndRecord extends CVSymbolSubrecord {\n+\n+        CVSymbolEndRecord(CVDebugInfo cvDebugInfo, short cmd) {\n+            super(cvDebugInfo, cmd);\n+        }\n+\n+        CVSymbolEndRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, CVDebugConstants.S_END);\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            // nothing\n+            return initialPos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"S_END\";\n+        }\n+    }\n+\n+    /*-\n+\n+    NOTE: All these records are not currently required, but will be (or will be discarded) once type information\n+    has been added.\n+\n+    public static final class CVSymbolRegRel32Record extends CVSymbolSubrecord {", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NTEyOQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457695129", "bodyText": "These will be used in the upcoming debug typeinfo PR.", "author": "stooke", "createdAt": "2020-07-20T21:13:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMTI5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM3MjkwMQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458372901", "bodyText": "gone for now.", "author": "stooke", "createdAt": "2020-07-21T20:37:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMTI5MA=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex 18490aec405..ddb43d1039c 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -457,196 +380,4 @@ abstract class CVSymbolSubrecord {\n             return \"S_END\";\n         }\n     }\n-\n-    /*-\n-\n-    NOTE: All these records are not currently required, but will be (or will be discarded) once type information\n-    has been added.\n-\n-    public static final class CVSymbolRegRel32Record extends CVSymbolSubrecord {\n-\n-        int typeIndex;\n-        short reg;\n-        int offset;\n-        String name;\n-\n-        public CVSymbolRegRel32Record(CVDebugInfo cvDebugInfo, String name, int typeIndex, int offset, short reg) {\n-            super(cvDebugInfo, CVDebugConstants.S_REGREL32);\n-            this.name = name;\n-            this.typeIndex = typeIndex;\n-            this.offset = offset;\n-        }\n-\n-        @Override\n-        protected int computeSize(int initialPos) {\n-            return computeContents(null, initialPos);\n-        }\n-\n-        @Override\n-        protected int computeContents(byte[] buffer, int initialPos) {\n-            int pos = CVUtil.putInt(offset, buffer, initialPos);\n-            pos = CVUtil.putInt(typeIndex, buffer, pos);\n-            pos = CVUtil.putShort(reg, buffer, pos);\n-            pos = CVUtil.putUTF8StringBytes(name, buffer, pos);\n-            return pos;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"S_REGREL32\";\n-        }\n-    }\n-\n-    public static class CVSymbolProcIdEndRecord extends CVSymbolEndRecord {\n-        CVSymbolProcIdEndRecord(CVDebugInfo cvDebugInfo) {\n-            super(cvDebugInfo, CVDebugConstants.S_PROC_ID_END);\n-        }\n-    }\n-\n-    public static final class CVSymbolConstantRecord extends CVSymbolSubrecord {\n-\n-        int typeIndex;\n-        short leaf;\n-        String name;\n-\n-        public CVSymbolConstantRecord(CVDebugInfo cvDebugInfo, String name, int typeIndex, short leaf) {\n-            super(cvDebugInfo, CVDebugConstants.S_CONSTANT);\n-            this.name = name;\n-            this.typeIndex = typeIndex;\n-            this.leaf = leaf;\n-        }\n-\n-        @Override\n-        protected int computeSize(int initialPos) {\n-            return computeContents(null, initialPos);\n-        }\n-\n-        @Override\n-        protected int computeContents(byte[] buffer, int initialPos) {\n-            int pos = CVUtil.putInt(typeIndex, buffer, initialPos);\n-            pos = CVUtil.putShort(leaf, buffer, pos);\n-            pos = CVUtil.putUTF8StringBytes(name, buffer, pos);\n-            return pos;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"S_CONSTANT\";\n-        }\n-    }\n-\n-    private static abstract class CVSymbolDataRecord extends CVSymbolSubrecord {\n-\n-        int typeIndex;\n-        int offset;\n-        short segment;\n-        String name;\n-\n-        CVSymbolDataRecord(CVDebugInfo cvDebugInfo, short recordType, String name, int typeIndex, int offset, short segment) {\n-            super(cvDebugInfo, recordType);\n-            this.name = name;\n-            this.typeIndex = typeIndex;\n-            this.offset = offset;\n-            this.segment = segment;\n-        }\n-\n-        @Override\n-        protected int computeSize(int initialPos) {\n-            return computeContents(null, initialPos);\n-        }\n-\n-        @Override\n-        protected int computeContents(byte[] buffer, int initialPos) {\n-            int pos = CVUtil.putInt(typeIndex, buffer, initialPos);\n-            pos = CVUtil.putInt(offset, buffer, pos);\n-            pos = CVUtil.putShort(segment, buffer, pos);\n-            pos = CVUtil.putUTF8StringBytes(name, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    public static final class CVSymbolLData32Record extends CVSymbolDataRecord {\n-\n-        public CVSymbolLData32Record(CVDebugInfo cvDebugInfo, String name, int typeIndex, int offset, short segment) {\n-            super(cvDebugInfo, CVDebugConstants.S_LDATA32, name, typeIndex, offset, segment);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"S_LDATA32_ST\";\n-        }\n-    }\n-\n-    public static final class CVSymbolLData32STRecord extends CVSymbolDataRecord {\n-\n-        public CVSymbolLData32STRecord(CVDebugInfo cvDebugInfo, String name, int typeIndex, int offset, short segment) {\n-            super(cvDebugInfo, CVDebugConstants.S_LDATA32_ST, name, typeIndex, offset, segment);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"S_LDATA32_ST\";\n-        }\n-    }\n-\n-    public static final class CVSymbolGData32Record extends CVSymbolDataRecord {\n-\n-        public CVSymbolGData32Record(CVDebugInfo cvDebugInfo, String name, int typeIndex, int offset, short segment) {\n-            super(cvDebugInfo, CVDebugConstants.S_GDATA32, name, typeIndex, offset, segment);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"S_GDATA32\";\n-        }\n-    }\n-\n-    public static final class CVSymbolSSearchRecord extends CVSymbolDataRecord {\n-\n-        public CVSymbolSSearchRecord(CVDebugInfo cvDebugInfo, int offset, short segment) {\n-            super(cvDebugInfo, CVDebugConstants.S_SSEARCH, null, 0, offset, segment);\n-        }\n-\n-        @Override\n-        protected int computeContents(byte[] buffer, int initialPos) {\n-            int pos = CVUtil.putInt(offset, buffer, initialPos);\n-            pos = CVUtil.putShort(segment, buffer, pos);\n-            return pos;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"S_SSEARCH\";\n-        }\n-    }\n-\n-    public static final class CVSymbolUDTRecord extends CVSymbolSubrecord {\n-\n-        int typeIndex;\n-        String name;\n-\n-        public CVSymbolUDTRecord(CVDebugInfo cvDebugInfo, String name, int typeIndex) {\n-            super(cvDebugInfo, CVDebugConstants.S_UDT);\n-            this.name = name;\n-            this.typeIndex = typeIndex;\n-        }\n-\n-        @Override\n-        protected int computeSize(int initialPos) {\n-            return computeContents(null, initialPos);\n-        }\n-\n-        @Override\n-        protected int computeContents(byte[] buffer, int initialPos) {\n-            int pos = CVUtil.putInt(typeIndex, buffer, initialPos);\n-            pos = CVUtil.putUTF8StringBytes(name, buffer, pos);\n-            return pos;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return String.format(\"S_UDT(name=%s typeindex=0x%x)\", name, typeIndex);\n-        }\n-    }\n-    */\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMjUwOQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456812509", "body": "A debugging leftover?", "bodyText": "A debugging leftover?", "bodyHTML": "<p dir=\"auto\">A debugging leftover?</p>", "author": "pejovica", "createdAt": "2020-07-18T17:51:50Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,652 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.subrecordStartPosition = initialPos;\n+        int prologueLength = Short.BYTES * 2; /* room for length and subcommand */\n+        return computeSize(initialPos + prologueLength);\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* save room for length (no including length bytes) */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(cmd=0x%04x pos=0x%06x)\", cmd, subrecordStartPosition);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeSize(int pos);\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* TODO: how to find the full path to object file we will produce */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Get file from first class object */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            int pos = initialPos + Integer.BYTES; /* signature = 0; */\n+            pos += objName.getBytes(UTF_8).length + 1; /* inline null terminated */\n+            return pos;\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* signature = 0 */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos); /* inline null terminated */\n+            return pos;\n+        }\n+    }\n+\n+    public static final class CVCompile3Record extends CVSymbolSubrecord {\n+\n+        private static final byte HAS_DEBUG_FLAG = 0;\n+        // private static final byte HAS_NO_DEBUG_FLAG = (byte)0x80;\n+\n+        private byte language;\n+        private byte cf1;\n+        private byte cf2;\n+        private byte padding;\n+        private short machine;\n+        private short feMajor;\n+        private short feMinor;\n+        private short feBuild;\n+        private short feQFE;\n+        private short beMajor;\n+        private short beMinor;\n+        private short beBuild;\n+        private short beQFE;\n+        private String compiler;\n+\n+        CVCompile3Record(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_COMPILE3);\n+            language = 0;\n+            cf1 = HAS_DEBUG_FLAG;\n+            cf2 = (byte) 0;\n+            padding = (byte) 0;\n+            machine = (short) 208;\n+            feMajor = (short) 2;\n+            feMinor = (short) 3;\n+            feBuild = (short) 4;\n+            feQFE = (short) 5;\n+            beMajor = (short) 6;\n+            beMinor = (short) 7;\n+            beBuild = (short) 8;\n+            beQFE = (short) 9;\n+            compiler = \"graal\";\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putByte(language, buffer, initialPos);\n+            pos = CVUtil.putByte(cf1, buffer, pos);\n+            pos = CVUtil.putByte(cf2, buffer, pos);\n+            pos = CVUtil.putByte(padding, buffer, pos);\n+            pos = CVUtil.putShort(machine, buffer, pos);\n+            pos = CVUtil.putShort(feMajor, buffer, pos);\n+            pos = CVUtil.putShort(feMinor, buffer, pos);\n+            pos = CVUtil.putShort(feBuild, buffer, pos);\n+            pos = CVUtil.putShort(feQFE, buffer, pos);\n+            pos = CVUtil.putShort(beMajor, buffer, pos);\n+            pos = CVUtil.putShort(beMinor, buffer, pos);\n+            pos = CVUtil.putShort(beBuild, buffer, pos);\n+            pos = CVUtil.putShort(beQFE, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(compiler, buffer, pos);  // inline null terminated\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_COMPILE3 machine=%d fe=%d.%d.%d.%d be=%d.%d.%d%d compiler=%s\", machine, feMajor, feMinor, feBuild, feQFE, beMajor, beMinor, beBuild, beQFE, compiler);\n+        }\n+    }\n+\n+    public static final class CVEnvBlockRecord extends CVSymbolSubrecord {\n+\n+        private static final int ENVMAP_INITIAL_CAPACITY = 10;\n+\n+        private Map<String, String> map = new HashMap<>(ENVMAP_INITIAL_CAPACITY);\n+\n+        /*-\n+         * Example contents of the environment block:\n+         *   cwd = C:\\tmp\\graal-8\n+         *   cl = C:\\tmp\\graal-8\\ojdkbuild\\tools\\toolchain\\vs2010e\\VC\\Bin\\x86_amd64\\cl.exe\n+         *   cmd = -Zi -MT -IC:\\tmp\\graal-8\\tools\\toolchain\\vs2010e\\VC\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE\\gl -TC -X\n+         *   src = helloworld.c\n+         *   pdb = C:\\tmp\\graal-8\\vc100.pdb\n+         */\n+        CVEnvBlockRecord(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_ENVBLOCK);\n+\n+            /* current directory */\n+            map.put(\"cwd\", System.getProperty(\"user.dir\"));\n+\n+            /* compiler executable */\n+            // map.put(\"cl\", \"cl.exe\");\n+\n+            /* argument list */\n+            // map.put(\"cmd\", \"-Zi -MT -wishfulthinking\");\n+\n+            /*\n+             * find first source file - which, for Graal would be a class file on the command line\n+             */\n+            String fn = findFirstFile(cvDebugInfo);\n+            if (fn != null) {\n+                map.put(\"src\", fn);\n+            }\n+\n+            /* Graal doesn't yet create PDB files; all type info is stored in object file */\n+            // map.put(\"pdb\", System.getProperty(\"user.dir\") + File.separator + \"vc100.pdb\");\n+        }\n+\n+        private static String findFirstFile(CVDebugInfo cvDebugInfo) {\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            /* flags */\n+            int pos = CVUtil.putByte((byte) 0, buffer, initialPos);\n+\n+            /* key/value pairs */\n+            for (Map.Entry<String, String> entry : map.entrySet()) {\n+                pos = CVUtil.putUTF8StringBytes(entry.getKey(), buffer, pos);\n+                pos = CVUtil.putUTF8StringBytes(entry.getValue(), buffer, pos);\n+            }\n+\n+            /* end marker */\n+            pos = CVUtil.putUTF8StringBytes(\"\", buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"S_ENVBLOCK \" + map.size() + \" entries\";\n+        }\n+    }\n+\n+    /*\n+     * creating a proc32 record has side effects. - a global symbol is added to the COFF symbol\n+     * section - two relocation entries are added to the section relocation table, they refer to the\n+     * global symbol\n+     */\n+    public static class CVSymbolGProc32Record extends CVSymbolSubrecord {\n+\n+        private static ObjectFile.Element textSection;\n+\n+        int pparent;\n+        int pend;\n+        int pnext;\n+        int proclen;\n+        int debugStart;\n+        int debugEnd;\n+        int typeIndex;\n+        int offset;\n+        short segment;\n+        byte flags;\n+        String name;\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, short cmd, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment,\n+                        byte flags) {\n+            super(cvDebugInfo, cmd);\n+            this.name = name;\n+            this.pparent = pparent;\n+            this.pend = pend;\n+            this.pnext = pnext;\n+            this.proclen = proclen;\n+            this.debugStart = debugStart;\n+            this.debugEnd = debugEnd;\n+            this.typeIndex = typeIndex;\n+            this.offset = offset;\n+            this.segment = segment;\n+            this.flags = flags;\n+        }\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment, byte flags) {\n+            this(cvDebugInfo, CVDebugConstants.S_GPROC32, name, pparent, pend, pnext, proclen, debugStart, debugEnd, typeIndex, offset, segment, flags);\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(pparent, buffer, initialPos);\n+            pos = CVUtil.putInt(pend, buffer, pos);\n+            pos = CVUtil.putInt(pnext, buffer, pos);\n+            pos = CVUtil.putInt(proclen, buffer, pos);\n+            pos = CVUtil.putInt(debugStart, buffer, pos);\n+            pos = CVUtil.putInt(debugEnd, buffer, pos);\n+            pos = CVUtil.putInt(typeIndex, buffer, pos);\n+            if (buffer == null) {\n+                cvDebugInfo.getCVSymbolSection().getOwner().createDefinedSymbol(name, getTextSection(), offset, proclen, true, true);\n+            }\n+            if (buffer != null) {\n+                // CVUtil.debug(\"CVSymbolGProc32Record() adding SECREL reloc at pos=0x%x for func=%s\n+                // addr=0x%x\\n\", pos, name, offset);", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NTE3NA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457695174", "bodyText": "Gone.", "author": "stooke", "createdAt": "2020-07-20T21:13:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMjUwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex 18490aec405..ddb43d1039c 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -328,60 +296,25 @@ abstract class CVSymbolSubrecord {\n             pos = CVUtil.putInt(debugStart, buffer, pos);\n             pos = CVUtil.putInt(debugEnd, buffer, pos);\n             pos = CVUtil.putInt(typeIndex, buffer, pos);\n-            if (buffer == null) {\n-                cvDebugInfo.getCVSymbolSection().getOwner().createDefinedSymbol(name, getTextSection(), offset, proclen, true, true);\n-            }\n             if (buffer != null) {\n-                // CVUtil.debug(\"CVSymbolGProc32Record() adding SECREL reloc at pos=0x%x for func=%s\n-                // addr=0x%x\\n\", pos, name, offset);\n-                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 4, ObjectFile.RelocationKind.SECREL, name, false, 1L);\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, externalName, false, 1L);\n             }\n             pos = CVUtil.putInt(0, buffer, pos);\n             if (buffer != null) {\n-                // CVUtil.debug(\"CVSymbolGProc32Record() adding SECTION reloc at pos=0x%x for\n-                // func=%s addr=0x%x\\n\", pos, name, offset);\n-                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 2, ObjectFile.RelocationKind.SECTION, name, false, 1L);\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, externalName, false, 1L);\n             }\n             pos = CVUtil.putShort((short) 0, buffer, pos);\n             pos = CVUtil.putByte(flags, buffer, pos);\n-            pos = CVUtil.putUTF8StringBytes(name, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(debuggerName, buffer, pos);\n             return pos;\n         }\n \n-        private ObjectFile.Element getTextSection() {\n-            if (textSection == null) {\n-                textSection = cvDebugInfo.getCVSymbolSection().getOwner().elementForName(SectionName.TEXT.getFormatDependentName(ObjectFile.Format.PECOFF));\n-            }\n-            return textSection;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            cvDebugInfo.getCVSymbolSection().debugAddress = offset;\n-            return String.format(\"S_GPROC32   name=%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", name, pparent, debugStart, debugEnd, proclen, offset,\n-                            typeIndex,\n-                            flags);\n-        }\n-    }\n-\n-    /*-\n-    public static final class CVSymbolGProc32IDRecord extends CVSymbolGProc32Record {\n-\n-        CVSymbolGProc32IDRecord(CVDebugInfo cvDebugInfo, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment, byte flags) {\n-            super(cvDebugInfo, CVDebugConstants.S_GPROC32_ID, name, pparent, pend, pnext, proclen, debugStart, debugEnd, typeIndex, offset, segment, flags);\n-        }\n-\n-        /* this is almost certainly bad (not enough information); use only for debugging *\n-        CVSymbolGProc32IDRecord(CVDebugInfo cvDebugInfo, String name, int offset, int proclen) {\n-            super(cvDebugInfo, CVDebugConstants.S_GPROC32_ID, name, 0, 0, 0, proclen, 0, 0, 0, offset, (short)0, (byte)0);\n-        }\n-\n         @Override\n         public String toString() {\n-            return String.format(\"S_GPROC32_ID(name=%s parent=%d startaddr=0x%x end=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", name, pparent, debugStart, debugEnd, proclen, offset, typeIndex, flags);\n+            return String.format(\"S_GPROC32   name=%s/%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", debuggerName, externalName, pparent, debugStart, debugEnd,\n+                            proclen, offset, typeIndex, flags);\n         }\n     }\n-    */\n \n     public static final class CVSymbolFrameProcRecord extends CVSymbolSubrecord {\n \n", "next_change": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex ddb43d1039c..0a30db69e94 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -296,35 +295,28 @@ abstract class CVSymbolSubrecord {\n             pos = CVUtil.putInt(debugStart, buffer, pos);\n             pos = CVUtil.putInt(debugEnd, buffer, pos);\n             pos = CVUtil.putInt(typeIndex, buffer, pos);\n-            if (buffer != null) {\n-                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, externalName, false, 1L);\n-            }\n-            pos = CVUtil.putInt(0, buffer, pos);\n-            if (buffer != null) {\n-                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, externalName, false, 1L);\n-            }\n-            pos = CVUtil.putShort((short) 0, buffer, pos);\n+            pos = cvDebugInfo.getCVSymbolSection().markRelocationSite(buffer, pos, symbolName, (long) 0);\n             pos = CVUtil.putByte(flags, buffer, pos);\n-            pos = CVUtil.putUTF8StringBytes(debuggerName, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(displayName, buffer, pos);\n             return pos;\n         }\n \n         @Override\n         public String toString() {\n-            return String.format(\"S_GPROC32   name=%s/%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", debuggerName, externalName, pparent, debugStart, debugEnd,\n-                            proclen, offset, typeIndex, flags);\n+            return String.format(\"S_GPROC32   name=%s/%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x seg:offset=0x%x:0x%x type=0x%x flags=0x%x)\", displayName, symbolName, pparent, debugStart, debugEnd,\n+                            proclen, segment, offset, typeIndex, flags);\n         }\n     }\n \n     public static final class CVSymbolFrameProcRecord extends CVSymbolSubrecord {\n \n-        int framelen;\n-        int padLen;\n-        int padOffset;\n-        int saveRegsCount;\n-        int ehOffset;\n-        short ehSection;\n-        int flags;\n+        private final int framelen;\n+        private final int padLen;\n+        private final int padOffset;\n+        private final int saveRegsCount;\n+        private final int ehOffset;\n+        private final short ehSection;\n+        private final int flags;\n \n         CVSymbolFrameProcRecord(CVDebugInfo cvDebugInfo, int framelen, int padLen, int padOffset, int saveRegsCount, int ehOffset, short ehSection, int flags) {\n             super(cvDebugInfo, CVDebugConstants.S_FRAMEPROC);\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMjc5MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456812790", "body": "Seems like a leftover.", "bodyText": "Seems like a leftover.", "bodyHTML": "<p dir=\"auto\">Seems like a leftover.</p>", "author": "pejovica", "createdAt": "2020-07-18T17:55:06Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,652 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.subrecordStartPosition = initialPos;\n+        int prologueLength = Short.BYTES * 2; /* room for length and subcommand */\n+        return computeSize(initialPos + prologueLength);\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* save room for length (no including length bytes) */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(cmd=0x%04x pos=0x%06x)\", cmd, subrecordStartPosition);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeSize(int pos);\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* TODO: how to find the full path to object file we will produce */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Get file from first class object */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            int pos = initialPos + Integer.BYTES; /* signature = 0; */\n+            pos += objName.getBytes(UTF_8).length + 1; /* inline null terminated */\n+            return pos;\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* signature = 0 */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos); /* inline null terminated */\n+            return pos;\n+        }\n+    }\n+\n+    public static final class CVCompile3Record extends CVSymbolSubrecord {\n+\n+        private static final byte HAS_DEBUG_FLAG = 0;\n+        // private static final byte HAS_NO_DEBUG_FLAG = (byte)0x80;\n+\n+        private byte language;\n+        private byte cf1;\n+        private byte cf2;\n+        private byte padding;\n+        private short machine;\n+        private short feMajor;\n+        private short feMinor;\n+        private short feBuild;\n+        private short feQFE;\n+        private short beMajor;\n+        private short beMinor;\n+        private short beBuild;\n+        private short beQFE;\n+        private String compiler;\n+\n+        CVCompile3Record(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_COMPILE3);\n+            language = 0;\n+            cf1 = HAS_DEBUG_FLAG;\n+            cf2 = (byte) 0;\n+            padding = (byte) 0;\n+            machine = (short) 208;\n+            feMajor = (short) 2;\n+            feMinor = (short) 3;\n+            feBuild = (short) 4;\n+            feQFE = (short) 5;\n+            beMajor = (short) 6;\n+            beMinor = (short) 7;\n+            beBuild = (short) 8;\n+            beQFE = (short) 9;\n+            compiler = \"graal\";\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putByte(language, buffer, initialPos);\n+            pos = CVUtil.putByte(cf1, buffer, pos);\n+            pos = CVUtil.putByte(cf2, buffer, pos);\n+            pos = CVUtil.putByte(padding, buffer, pos);\n+            pos = CVUtil.putShort(machine, buffer, pos);\n+            pos = CVUtil.putShort(feMajor, buffer, pos);\n+            pos = CVUtil.putShort(feMinor, buffer, pos);\n+            pos = CVUtil.putShort(feBuild, buffer, pos);\n+            pos = CVUtil.putShort(feQFE, buffer, pos);\n+            pos = CVUtil.putShort(beMajor, buffer, pos);\n+            pos = CVUtil.putShort(beMinor, buffer, pos);\n+            pos = CVUtil.putShort(beBuild, buffer, pos);\n+            pos = CVUtil.putShort(beQFE, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(compiler, buffer, pos);  // inline null terminated\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_COMPILE3 machine=%d fe=%d.%d.%d.%d be=%d.%d.%d%d compiler=%s\", machine, feMajor, feMinor, feBuild, feQFE, beMajor, beMinor, beBuild, beQFE, compiler);\n+        }\n+    }\n+\n+    public static final class CVEnvBlockRecord extends CVSymbolSubrecord {\n+\n+        private static final int ENVMAP_INITIAL_CAPACITY = 10;\n+\n+        private Map<String, String> map = new HashMap<>(ENVMAP_INITIAL_CAPACITY);\n+\n+        /*-\n+         * Example contents of the environment block:\n+         *   cwd = C:\\tmp\\graal-8\n+         *   cl = C:\\tmp\\graal-8\\ojdkbuild\\tools\\toolchain\\vs2010e\\VC\\Bin\\x86_amd64\\cl.exe\n+         *   cmd = -Zi -MT -IC:\\tmp\\graal-8\\tools\\toolchain\\vs2010e\\VC\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE\\gl -TC -X\n+         *   src = helloworld.c\n+         *   pdb = C:\\tmp\\graal-8\\vc100.pdb\n+         */\n+        CVEnvBlockRecord(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_ENVBLOCK);\n+\n+            /* current directory */\n+            map.put(\"cwd\", System.getProperty(\"user.dir\"));\n+\n+            /* compiler executable */\n+            // map.put(\"cl\", \"cl.exe\");\n+\n+            /* argument list */\n+            // map.put(\"cmd\", \"-Zi -MT -wishfulthinking\");", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NTIyNg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457695226", "bodyText": "Gone.", "author": "stooke", "createdAt": "2020-07-20T21:13:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMjc5MA=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex 18490aec405..ddb43d1039c 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -208,31 +192,25 @@ abstract class CVSymbolSubrecord {\n          *   cwd = C:\\tmp\\graal-8\n          *   cl = C:\\tmp\\graal-8\\ojdkbuild\\tools\\toolchain\\vs2010e\\VC\\Bin\\x86_amd64\\cl.exe\n          *   cmd = -Zi -MT -IC:\\tmp\\graal-8\\tools\\toolchain\\vs2010e\\VC\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE\\gl -TC -X\n-         *   src = helloworld.c\n+         *   src = helloworld.java\n          *   pdb = C:\\tmp\\graal-8\\vc100.pdb\n          */\n         CVEnvBlockRecord(CVDebugInfo cvDebugInfo) {\n             super(cvDebugInfo, CVDebugConstants.S_ENVBLOCK);\n \n-            /* current directory */\n+            /* Current directory. */\n             map.put(\"cwd\", System.getProperty(\"user.dir\"));\n \n-            /* compiler executable */\n-            // map.put(\"cl\", \"cl.exe\");\n-\n-            /* argument list */\n-            // map.put(\"cmd\", \"-Zi -MT -wishfulthinking\");\n-\n             /*\n-             * find first source file - which, for Graal would be a class file on the command line\n+             * Define the primary source file - ideally, the source file containing main(). (Note\n+             * that if Graal were to be used to compile a library, there may not be a main()). Since\n+             * Graal doesn't work with java source files, use the source file associated with the\n+             * first class that has a source file.\n              */\n             String fn = findFirstFile(cvDebugInfo);\n             if (fn != null) {\n                 map.put(\"src\", fn);\n             }\n-\n-            /* Graal doesn't yet create PDB files; all type info is stored in object file */\n-            // map.put(\"pdb\", System.getProperty(\"user.dir\") + File.separator + \"vc100.pdb\");\n         }\n \n         private static String findFirstFile(CVDebugInfo cvDebugInfo) {\n", "next_change": {"commit": "c6a802364a9fad1326060e138a0d3b9649802c98", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex ddb43d1039c..dd909f40af1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -215,7 +214,7 @@ abstract class CVSymbolSubrecord {\n \n         private static String findFirstFile(CVDebugInfo cvDebugInfo) {\n             String fn = null;\n-            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+            for (ClassEntry classEntry : cvDebugInfo.getInstanceClasses()) {\n                 if (classEntry.getFileName() != null) {\n                     fn = classEntry.getFileEntry().getFileName();\n                     break;\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMjgyNw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456812827", "body": "This as well.", "bodyText": "This as well.", "bodyHTML": "<p dir=\"auto\">This as well.</p>", "author": "pejovica", "createdAt": "2020-07-18T17:55:34Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,652 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.subrecordStartPosition = initialPos;\n+        int prologueLength = Short.BYTES * 2; /* room for length and subcommand */\n+        return computeSize(initialPos + prologueLength);\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* save room for length (no including length bytes) */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(cmd=0x%04x pos=0x%06x)\", cmd, subrecordStartPosition);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeSize(int pos);\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* TODO: how to find the full path to object file we will produce */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Get file from first class object */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            int pos = initialPos + Integer.BYTES; /* signature = 0; */\n+            pos += objName.getBytes(UTF_8).length + 1; /* inline null terminated */\n+            return pos;\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* signature = 0 */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos); /* inline null terminated */\n+            return pos;\n+        }\n+    }\n+\n+    public static final class CVCompile3Record extends CVSymbolSubrecord {\n+\n+        private static final byte HAS_DEBUG_FLAG = 0;\n+        // private static final byte HAS_NO_DEBUG_FLAG = (byte)0x80;\n+\n+        private byte language;\n+        private byte cf1;\n+        private byte cf2;\n+        private byte padding;\n+        private short machine;\n+        private short feMajor;\n+        private short feMinor;\n+        private short feBuild;\n+        private short feQFE;\n+        private short beMajor;\n+        private short beMinor;\n+        private short beBuild;\n+        private short beQFE;\n+        private String compiler;\n+\n+        CVCompile3Record(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_COMPILE3);\n+            language = 0;\n+            cf1 = HAS_DEBUG_FLAG;\n+            cf2 = (byte) 0;\n+            padding = (byte) 0;\n+            machine = (short) 208;\n+            feMajor = (short) 2;\n+            feMinor = (short) 3;\n+            feBuild = (short) 4;\n+            feQFE = (short) 5;\n+            beMajor = (short) 6;\n+            beMinor = (short) 7;\n+            beBuild = (short) 8;\n+            beQFE = (short) 9;\n+            compiler = \"graal\";\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putByte(language, buffer, initialPos);\n+            pos = CVUtil.putByte(cf1, buffer, pos);\n+            pos = CVUtil.putByte(cf2, buffer, pos);\n+            pos = CVUtil.putByte(padding, buffer, pos);\n+            pos = CVUtil.putShort(machine, buffer, pos);\n+            pos = CVUtil.putShort(feMajor, buffer, pos);\n+            pos = CVUtil.putShort(feMinor, buffer, pos);\n+            pos = CVUtil.putShort(feBuild, buffer, pos);\n+            pos = CVUtil.putShort(feQFE, buffer, pos);\n+            pos = CVUtil.putShort(beMajor, buffer, pos);\n+            pos = CVUtil.putShort(beMinor, buffer, pos);\n+            pos = CVUtil.putShort(beBuild, buffer, pos);\n+            pos = CVUtil.putShort(beQFE, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(compiler, buffer, pos);  // inline null terminated\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_COMPILE3 machine=%d fe=%d.%d.%d.%d be=%d.%d.%d%d compiler=%s\", machine, feMajor, feMinor, feBuild, feQFE, beMajor, beMinor, beBuild, beQFE, compiler);\n+        }\n+    }\n+\n+    public static final class CVEnvBlockRecord extends CVSymbolSubrecord {\n+\n+        private static final int ENVMAP_INITIAL_CAPACITY = 10;\n+\n+        private Map<String, String> map = new HashMap<>(ENVMAP_INITIAL_CAPACITY);\n+\n+        /*-\n+         * Example contents of the environment block:\n+         *   cwd = C:\\tmp\\graal-8\n+         *   cl = C:\\tmp\\graal-8\\ojdkbuild\\tools\\toolchain\\vs2010e\\VC\\Bin\\x86_amd64\\cl.exe\n+         *   cmd = -Zi -MT -IC:\\tmp\\graal-8\\tools\\toolchain\\vs2010e\\VC\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE\\gl -TC -X\n+         *   src = helloworld.c\n+         *   pdb = C:\\tmp\\graal-8\\vc100.pdb\n+         */\n+        CVEnvBlockRecord(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_ENVBLOCK);\n+\n+            /* current directory */\n+            map.put(\"cwd\", System.getProperty(\"user.dir\"));\n+\n+            /* compiler executable */\n+            // map.put(\"cl\", \"cl.exe\");\n+\n+            /* argument list */\n+            // map.put(\"cmd\", \"-Zi -MT -wishfulthinking\");\n+\n+            /*\n+             * find first source file - which, for Graal would be a class file on the command line\n+             */\n+            String fn = findFirstFile(cvDebugInfo);\n+            if (fn != null) {\n+                map.put(\"src\", fn);\n+            }\n+\n+            /* Graal doesn't yet create PDB files; all type info is stored in object file */\n+            // map.put(\"pdb\", System.getProperty(\"user.dir\") + File.separator + \"vc100.pdb\");", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex 18490aec405..ddb43d1039c 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -208,31 +192,25 @@ abstract class CVSymbolSubrecord {\n          *   cwd = C:\\tmp\\graal-8\n          *   cl = C:\\tmp\\graal-8\\ojdkbuild\\tools\\toolchain\\vs2010e\\VC\\Bin\\x86_amd64\\cl.exe\n          *   cmd = -Zi -MT -IC:\\tmp\\graal-8\\tools\\toolchain\\vs2010e\\VC\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE\\gl -TC -X\n-         *   src = helloworld.c\n+         *   src = helloworld.java\n          *   pdb = C:\\tmp\\graal-8\\vc100.pdb\n          */\n         CVEnvBlockRecord(CVDebugInfo cvDebugInfo) {\n             super(cvDebugInfo, CVDebugConstants.S_ENVBLOCK);\n \n-            /* current directory */\n+            /* Current directory. */\n             map.put(\"cwd\", System.getProperty(\"user.dir\"));\n \n-            /* compiler executable */\n-            // map.put(\"cl\", \"cl.exe\");\n-\n-            /* argument list */\n-            // map.put(\"cmd\", \"-Zi -MT -wishfulthinking\");\n-\n             /*\n-             * find first source file - which, for Graal would be a class file on the command line\n+             * Define the primary source file - ideally, the source file containing main(). (Note\n+             * that if Graal were to be used to compile a library, there may not be a main()). Since\n+             * Graal doesn't work with java source files, use the source file associated with the\n+             * first class that has a source file.\n              */\n             String fn = findFirstFile(cvDebugInfo);\n             if (fn != null) {\n                 map.put(\"src\", fn);\n             }\n-\n-            /* Graal doesn't yet create PDB files; all type info is stored in object file */\n-            // map.put(\"pdb\", System.getProperty(\"user.dir\") + File.separator + \"vc100.pdb\");\n         }\n \n         private static String findFirstFile(CVDebugInfo cvDebugInfo) {\n", "next_change": {"commit": "c6a802364a9fad1326060e138a0d3b9649802c98", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex ddb43d1039c..dd909f40af1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -215,7 +214,7 @@ abstract class CVSymbolSubrecord {\n \n         private static String findFirstFile(CVDebugInfo cvDebugInfo) {\n             String fn = null;\n-            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+            for (ClassEntry classEntry : cvDebugInfo.getInstanceClasses()) {\n                 if (classEntry.getFileName() != null) {\n                     fn = classEntry.getFileEntry().getFileName();\n                     break;\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMzE3OQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456813179", "body": "Same here.", "bodyText": "Same here.", "bodyHTML": "<p dir=\"auto\">Same here.</p>", "author": "pejovica", "createdAt": "2020-07-18T17:59:52Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,652 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.subrecordStartPosition = initialPos;\n+        int prologueLength = Short.BYTES * 2; /* room for length and subcommand */\n+        return computeSize(initialPos + prologueLength);\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* save room for length (no including length bytes) */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(cmd=0x%04x pos=0x%06x)\", cmd, subrecordStartPosition);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeSize(int pos);\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* TODO: how to find the full path to object file we will produce */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Get file from first class object */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            int pos = initialPos + Integer.BYTES; /* signature = 0; */\n+            pos += objName.getBytes(UTF_8).length + 1; /* inline null terminated */\n+            return pos;\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* signature = 0 */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos); /* inline null terminated */\n+            return pos;\n+        }\n+    }\n+\n+    public static final class CVCompile3Record extends CVSymbolSubrecord {\n+\n+        private static final byte HAS_DEBUG_FLAG = 0;\n+        // private static final byte HAS_NO_DEBUG_FLAG = (byte)0x80;\n+\n+        private byte language;\n+        private byte cf1;\n+        private byte cf2;\n+        private byte padding;\n+        private short machine;\n+        private short feMajor;\n+        private short feMinor;\n+        private short feBuild;\n+        private short feQFE;\n+        private short beMajor;\n+        private short beMinor;\n+        private short beBuild;\n+        private short beQFE;\n+        private String compiler;\n+\n+        CVCompile3Record(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_COMPILE3);\n+            language = 0;\n+            cf1 = HAS_DEBUG_FLAG;\n+            cf2 = (byte) 0;\n+            padding = (byte) 0;\n+            machine = (short) 208;\n+            feMajor = (short) 2;\n+            feMinor = (short) 3;\n+            feBuild = (short) 4;\n+            feQFE = (short) 5;\n+            beMajor = (short) 6;\n+            beMinor = (short) 7;\n+            beBuild = (short) 8;\n+            beQFE = (short) 9;\n+            compiler = \"graal\";\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putByte(language, buffer, initialPos);\n+            pos = CVUtil.putByte(cf1, buffer, pos);\n+            pos = CVUtil.putByte(cf2, buffer, pos);\n+            pos = CVUtil.putByte(padding, buffer, pos);\n+            pos = CVUtil.putShort(machine, buffer, pos);\n+            pos = CVUtil.putShort(feMajor, buffer, pos);\n+            pos = CVUtil.putShort(feMinor, buffer, pos);\n+            pos = CVUtil.putShort(feBuild, buffer, pos);\n+            pos = CVUtil.putShort(feQFE, buffer, pos);\n+            pos = CVUtil.putShort(beMajor, buffer, pos);\n+            pos = CVUtil.putShort(beMinor, buffer, pos);\n+            pos = CVUtil.putShort(beBuild, buffer, pos);\n+            pos = CVUtil.putShort(beQFE, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(compiler, buffer, pos);  // inline null terminated\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_COMPILE3 machine=%d fe=%d.%d.%d.%d be=%d.%d.%d%d compiler=%s\", machine, feMajor, feMinor, feBuild, feQFE, beMajor, beMinor, beBuild, beQFE, compiler);\n+        }\n+    }\n+\n+    public static final class CVEnvBlockRecord extends CVSymbolSubrecord {\n+\n+        private static final int ENVMAP_INITIAL_CAPACITY = 10;\n+\n+        private Map<String, String> map = new HashMap<>(ENVMAP_INITIAL_CAPACITY);\n+\n+        /*-\n+         * Example contents of the environment block:\n+         *   cwd = C:\\tmp\\graal-8\n+         *   cl = C:\\tmp\\graal-8\\ojdkbuild\\tools\\toolchain\\vs2010e\\VC\\Bin\\x86_amd64\\cl.exe\n+         *   cmd = -Zi -MT -IC:\\tmp\\graal-8\\tools\\toolchain\\vs2010e\\VC\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE\\gl -TC -X\n+         *   src = helloworld.c\n+         *   pdb = C:\\tmp\\graal-8\\vc100.pdb\n+         */\n+        CVEnvBlockRecord(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_ENVBLOCK);\n+\n+            /* current directory */\n+            map.put(\"cwd\", System.getProperty(\"user.dir\"));\n+\n+            /* compiler executable */\n+            // map.put(\"cl\", \"cl.exe\");\n+\n+            /* argument list */\n+            // map.put(\"cmd\", \"-Zi -MT -wishfulthinking\");\n+\n+            /*\n+             * find first source file - which, for Graal would be a class file on the command line\n+             */\n+            String fn = findFirstFile(cvDebugInfo);\n+            if (fn != null) {\n+                map.put(\"src\", fn);\n+            }\n+\n+            /* Graal doesn't yet create PDB files; all type info is stored in object file */\n+            // map.put(\"pdb\", System.getProperty(\"user.dir\") + File.separator + \"vc100.pdb\");\n+        }\n+\n+        private static String findFirstFile(CVDebugInfo cvDebugInfo) {\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            /* flags */\n+            int pos = CVUtil.putByte((byte) 0, buffer, initialPos);\n+\n+            /* key/value pairs */\n+            for (Map.Entry<String, String> entry : map.entrySet()) {\n+                pos = CVUtil.putUTF8StringBytes(entry.getKey(), buffer, pos);\n+                pos = CVUtil.putUTF8StringBytes(entry.getValue(), buffer, pos);\n+            }\n+\n+            /* end marker */\n+            pos = CVUtil.putUTF8StringBytes(\"\", buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"S_ENVBLOCK \" + map.size() + \" entries\";\n+        }\n+    }\n+\n+    /*\n+     * creating a proc32 record has side effects. - a global symbol is added to the COFF symbol\n+     * section - two relocation entries are added to the section relocation table, they refer to the\n+     * global symbol\n+     */\n+    public static class CVSymbolGProc32Record extends CVSymbolSubrecord {\n+\n+        private static ObjectFile.Element textSection;\n+\n+        int pparent;\n+        int pend;\n+        int pnext;\n+        int proclen;\n+        int debugStart;\n+        int debugEnd;\n+        int typeIndex;\n+        int offset;\n+        short segment;\n+        byte flags;\n+        String name;\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, short cmd, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment,\n+                        byte flags) {\n+            super(cvDebugInfo, cmd);\n+            this.name = name;\n+            this.pparent = pparent;\n+            this.pend = pend;\n+            this.pnext = pnext;\n+            this.proclen = proclen;\n+            this.debugStart = debugStart;\n+            this.debugEnd = debugEnd;\n+            this.typeIndex = typeIndex;\n+            this.offset = offset;\n+            this.segment = segment;\n+            this.flags = flags;\n+        }\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment, byte flags) {\n+            this(cvDebugInfo, CVDebugConstants.S_GPROC32, name, pparent, pend, pnext, proclen, debugStart, debugEnd, typeIndex, offset, segment, flags);\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(pparent, buffer, initialPos);\n+            pos = CVUtil.putInt(pend, buffer, pos);\n+            pos = CVUtil.putInt(pnext, buffer, pos);\n+            pos = CVUtil.putInt(proclen, buffer, pos);\n+            pos = CVUtil.putInt(debugStart, buffer, pos);\n+            pos = CVUtil.putInt(debugEnd, buffer, pos);\n+            pos = CVUtil.putInt(typeIndex, buffer, pos);\n+            if (buffer == null) {\n+                cvDebugInfo.getCVSymbolSection().getOwner().createDefinedSymbol(name, getTextSection(), offset, proclen, true, true);\n+            }\n+            if (buffer != null) {\n+                // CVUtil.debug(\"CVSymbolGProc32Record() adding SECREL reloc at pos=0x%x for func=%s\n+                // addr=0x%x\\n\", pos, name, offset);\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 4, ObjectFile.RelocationKind.SECREL, name, false, 1L);\n+            }\n+            pos = CVUtil.putInt(0, buffer, pos);\n+            if (buffer != null) {\n+                // CVUtil.debug(\"CVSymbolGProc32Record() adding SECTION reloc at pos=0x%x for\n+                // func=%s addr=0x%x\\n\", pos, name, offset);", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NTI3Mg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457695272", "bodyText": "Gone.", "author": "stooke", "createdAt": "2020-07-20T21:13:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMzE3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex 18490aec405..ddb43d1039c 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -328,60 +296,25 @@ abstract class CVSymbolSubrecord {\n             pos = CVUtil.putInt(debugStart, buffer, pos);\n             pos = CVUtil.putInt(debugEnd, buffer, pos);\n             pos = CVUtil.putInt(typeIndex, buffer, pos);\n-            if (buffer == null) {\n-                cvDebugInfo.getCVSymbolSection().getOwner().createDefinedSymbol(name, getTextSection(), offset, proclen, true, true);\n-            }\n             if (buffer != null) {\n-                // CVUtil.debug(\"CVSymbolGProc32Record() adding SECREL reloc at pos=0x%x for func=%s\n-                // addr=0x%x\\n\", pos, name, offset);\n-                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 4, ObjectFile.RelocationKind.SECREL, name, false, 1L);\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, externalName, false, 1L);\n             }\n             pos = CVUtil.putInt(0, buffer, pos);\n             if (buffer != null) {\n-                // CVUtil.debug(\"CVSymbolGProc32Record() adding SECTION reloc at pos=0x%x for\n-                // func=%s addr=0x%x\\n\", pos, name, offset);\n-                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 2, ObjectFile.RelocationKind.SECTION, name, false, 1L);\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, externalName, false, 1L);\n             }\n             pos = CVUtil.putShort((short) 0, buffer, pos);\n             pos = CVUtil.putByte(flags, buffer, pos);\n-            pos = CVUtil.putUTF8StringBytes(name, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(debuggerName, buffer, pos);\n             return pos;\n         }\n \n-        private ObjectFile.Element getTextSection() {\n-            if (textSection == null) {\n-                textSection = cvDebugInfo.getCVSymbolSection().getOwner().elementForName(SectionName.TEXT.getFormatDependentName(ObjectFile.Format.PECOFF));\n-            }\n-            return textSection;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            cvDebugInfo.getCVSymbolSection().debugAddress = offset;\n-            return String.format(\"S_GPROC32   name=%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", name, pparent, debugStart, debugEnd, proclen, offset,\n-                            typeIndex,\n-                            flags);\n-        }\n-    }\n-\n-    /*-\n-    public static final class CVSymbolGProc32IDRecord extends CVSymbolGProc32Record {\n-\n-        CVSymbolGProc32IDRecord(CVDebugInfo cvDebugInfo, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment, byte flags) {\n-            super(cvDebugInfo, CVDebugConstants.S_GPROC32_ID, name, pparent, pend, pnext, proclen, debugStart, debugEnd, typeIndex, offset, segment, flags);\n-        }\n-\n-        /* this is almost certainly bad (not enough information); use only for debugging *\n-        CVSymbolGProc32IDRecord(CVDebugInfo cvDebugInfo, String name, int offset, int proclen) {\n-            super(cvDebugInfo, CVDebugConstants.S_GPROC32_ID, name, 0, 0, 0, proclen, 0, 0, 0, offset, (short)0, (byte)0);\n-        }\n-\n         @Override\n         public String toString() {\n-            return String.format(\"S_GPROC32_ID(name=%s parent=%d startaddr=0x%x end=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", name, pparent, debugStart, debugEnd, proclen, offset, typeIndex, flags);\n+            return String.format(\"S_GPROC32   name=%s/%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", debuggerName, externalName, pparent, debugStart, debugEnd,\n+                            proclen, offset, typeIndex, flags);\n         }\n     }\n-    */\n \n     public static final class CVSymbolFrameProcRecord extends CVSymbolSubrecord {\n \n", "next_change": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex ddb43d1039c..0a30db69e94 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -296,35 +295,28 @@ abstract class CVSymbolSubrecord {\n             pos = CVUtil.putInt(debugStart, buffer, pos);\n             pos = CVUtil.putInt(debugEnd, buffer, pos);\n             pos = CVUtil.putInt(typeIndex, buffer, pos);\n-            if (buffer != null) {\n-                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, externalName, false, 1L);\n-            }\n-            pos = CVUtil.putInt(0, buffer, pos);\n-            if (buffer != null) {\n-                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, externalName, false, 1L);\n-            }\n-            pos = CVUtil.putShort((short) 0, buffer, pos);\n+            pos = cvDebugInfo.getCVSymbolSection().markRelocationSite(buffer, pos, symbolName, (long) 0);\n             pos = CVUtil.putByte(flags, buffer, pos);\n-            pos = CVUtil.putUTF8StringBytes(debuggerName, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(displayName, buffer, pos);\n             return pos;\n         }\n \n         @Override\n         public String toString() {\n-            return String.format(\"S_GPROC32   name=%s/%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", debuggerName, externalName, pparent, debugStart, debugEnd,\n-                            proclen, offset, typeIndex, flags);\n+            return String.format(\"S_GPROC32   name=%s/%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x seg:offset=0x%x:0x%x type=0x%x flags=0x%x)\", displayName, symbolName, pparent, debugStart, debugEnd,\n+                            proclen, segment, offset, typeIndex, flags);\n         }\n     }\n \n     public static final class CVSymbolFrameProcRecord extends CVSymbolSubrecord {\n \n-        int framelen;\n-        int padLen;\n-        int padOffset;\n-        int saveRegsCount;\n-        int ehOffset;\n-        short ehSection;\n-        int flags;\n+        private final int framelen;\n+        private final int padLen;\n+        private final int padOffset;\n+        private final int saveRegsCount;\n+        private final int ehOffset;\n+        private final short ehSection;\n+        private final int flags;\n \n         CVSymbolFrameProcRecord(CVDebugInfo cvDebugInfo, int framelen, int padLen, int padOffset, int saveRegsCount, int ehOffset, short ehSection, int flags) {\n             super(cvDebugInfo, CVDebugConstants.S_FRAMEPROC);\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxNTI4Ng==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456815286", "body": "Seems like a debugging leftover.", "bodyText": "Seems like a debugging leftover.", "bodyHTML": "<p dir=\"auto\">Seems like a debugging leftover.</p>", "author": "pejovica", "createdAt": "2020-07-18T18:25:40Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+abstract class CVUtil {\n+\n+    /* base level put methods that assume a non-null buffer */\n+    static int putByte(byte b, byte[] buffer, int initialPos) {\n+        if (buffer == null) {\n+            return initialPos + Byte.BYTES;\n+        }\n+        int pos = initialPos;\n+        buffer[pos++] = b;\n+        return pos;\n+    }\n+\n+    static int putShort(short s, byte[] buffer, int initialPos) {\n+        if (buffer == null) {\n+            return initialPos + Short.BYTES;\n+        }\n+        int pos = initialPos;\n+        buffer[pos++] = (byte) (s & 0xff);\n+        buffer[pos++] = (byte) ((s >> 8) & 0xff);\n+        return pos;\n+    }\n+\n+    static int putInt(int i, byte[] buffer, int initialPos) {\n+        if (buffer == null) {\n+            return initialPos + Integer.BYTES;\n+        }\n+        int pos = initialPos;\n+        buffer[pos++] = (byte) (i & 0xff);\n+        buffer[pos++] = (byte) ((i >> 8) & 0xff);\n+        buffer[pos++] = (byte) ((i >> 16) & 0xff);\n+        buffer[pos++] = (byte) ((i >> 24) & 0xff);\n+        return pos;\n+    }\n+\n+    static int putLong(long l, byte[] buffer, int initialPos) {\n+        if (buffer == null) {\n+            return initialPos + Long.BYTES;\n+        }\n+        int pos = initialPos;\n+        buffer[pos++] = (byte) (l & 0xff);\n+        buffer[pos++] = (byte) ((l >> 8) & 0xff);\n+        buffer[pos++] = (byte) ((l >> 16) & 0xff);\n+        buffer[pos++] = (byte) ((l >> 24) & 0xff);\n+        buffer[pos++] = (byte) ((l >> 32) & 0xff);\n+        buffer[pos++] = (byte) ((l >> 40) & 0xff);\n+        buffer[pos++] = (byte) ((l >> 48) & 0xff);\n+        buffer[pos++] = (byte) ((l >> 56) & 0xff);\n+        return pos;\n+    }\n+\n+    static int putBytes(byte[] inbuff, byte[] buffer, int initialPos) {\n+        if (buffer == null) {\n+            return initialPos + inbuff.length;\n+        }\n+        int pos = initialPos;\n+        for (byte b : inbuff) {\n+            buffer[pos++] = b;\n+        }\n+        return pos;\n+    }\n+\n+    static int putUTF8StringBytes(String s, byte[] buffer, int initialPos) {\n+        return putUTF8StringBytes(s, 0, buffer, initialPos);\n+    }\n+\n+    private static int putUTF8StringBytes(String s, int startChar, byte[] buffer, int initialPos) {\n+        byte[] buff = s.substring(startChar).getBytes(UTF_8);\n+        if (buffer == null) {\n+            return initialPos + buff.length + 1;\n+        }\n+        int pos = initialPos;\n+        for (byte b : buff) {\n+            if (b == 0) {\n+                throw new RuntimeException(\"oops : string has internal NULL character! \" + s);\n+            }\n+            buffer[pos++] = b;\n+        }\n+        buffer[pos++] = '\\0';\n+        return pos;\n+    }\n+\n+    static int getInt(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        int i = buffer[pos++] & 0xff;\n+        i += (buffer[pos++] & 0xff) << 8;\n+        i += (buffer[pos++] & 0xff) << 16;\n+        i += (buffer[pos] & 0xff) << 24;\n+        return i;\n+    }\n+\n+    static short getShort(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        short i = (short) (buffer[pos++] & 0xff);\n+        i = (short) (i + ((buffer[pos] & 0xff) << 8));\n+        return i;\n+    }\n+\n+    /*-\n+    static void dump(String msg, byte[] buffer, int initialPos, int len) {", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NTMyNQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457695325", "bodyText": "Debugging is never finished!  But, it's gone.", "author": "stooke", "createdAt": "2020-07-20T21:13:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxNTI4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java\nindex 25911004bea..d825143c67d 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java\n", "chunk": "@@ -90,65 +92,18 @@ abstract class CVUtil {\n     }\n \n     static int putUTF8StringBytes(String s, byte[] buffer, int initialPos) {\n-        return putUTF8StringBytes(s, 0, buffer, initialPos);\n-    }\n-\n-    private static int putUTF8StringBytes(String s, int startChar, byte[] buffer, int initialPos) {\n-        byte[] buff = s.substring(startChar).getBytes(UTF_8);\n+        assert !s.contains(\"\\0\");\n         if (buffer == null) {\n-            return initialPos + buff.length + 1;\n-        }\n-        int pos = initialPos;\n-        for (byte b : buff) {\n-            if (b == 0) {\n-                throw new RuntimeException(\"oops : string has internal NULL character! \" + s);\n-            }\n-            buffer[pos++] = b;\n+            return initialPos + Utf8.utf8Length(s) + 1;\n         }\n+        byte[] buff = s.getBytes(UTF_8);\n+        int pos = putBytes(buff, buffer, initialPos);\n         buffer[pos++] = '\\0';\n         return pos;\n     }\n \n-    static int getInt(byte[] buffer, int initialPos) {\n-        int pos = initialPos;\n-        int i = buffer[pos++] & 0xff;\n-        i += (buffer[pos++] & 0xff) << 8;\n-        i += (buffer[pos++] & 0xff) << 16;\n-        i += (buffer[pos] & 0xff) << 24;\n-        return i;\n-    }\n-\n-    static short getShort(byte[] buffer, int initialPos) {\n-        int pos = initialPos;\n-        short i = (short) (buffer[pos++] & 0xff);\n-        i = (short) (i + ((buffer[pos] & 0xff) << 8));\n-        return i;\n-    }\n-\n-    /*-\n-    static void dump(String msg, byte[] buffer, int initialPos, int len) {\n-        if (buffer == null) {\n-            return;\n-        }\n-        System.out.format(\"%s0x%06x\", msg, initialPos);\n-        for (int i = 0; i < len; i++) {\n-            System.out.format(\" %02x\", buffer[initialPos + i]);\n-        }\n-        System.out.format(\"\\n\");\n-    }\n-\n-    static void dump(byte[] buffer, int len) {\n-        if (buffer == null) {\n-            return;\n-        }\n-        for (int i = 0; i < len; i++) {\n-            System.out.format(\"%02x\", buffer[i]);\n-        }\n-    }\n-    */\n-\n     /**\n-     * align on 4 byte boundary.\n+     * Align on 4 byte boundary.\n      *\n      * @param initialPos initial unaligned position\n      * @return pos aligned on 4 byte boundary\n", "next_change": {"commit": "77e3a7479e429a3279d3061496d260e35f21f000", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java\nindex d825143c67d..8cec084ccc1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java\n", "chunk": "@@ -102,6 +140,38 @@ abstract class CVUtil {\n         return pos;\n     }\n \n+    /**\n+     * Some CodeView numeric fields can be variable length, depending on the value.\n+     *\n+     * @param value value to store\n+     * @param buffer buffer to store value in\n+     * @param initialPos initial position in buffer\n+     * @return position in buffer following stored value\n+     */\n+    static int putLfNumeric(long value, byte[] buffer, int initialPos) {\n+        if (0 <= value && value < 0x8000) {\n+            return putShort((short) value, buffer, initialPos);\n+        } else if (Byte.MIN_VALUE <= value && value <= Byte.MAX_VALUE) {\n+            int pos = putShort(LF_CHAR, buffer, initialPos);\n+            return putByte((byte) value, buffer, pos);\n+        } else if (Short.MIN_VALUE <= value && value <= Short.MAX_VALUE) {\n+            int pos = putShort(LF_SHORT, buffer, initialPos);\n+            return putShort((short) value, buffer, pos);\n+        } else if (0 <= value && value <= 0xffff) {\n+            int pos = putShort(LF_USHORT, buffer, initialPos);\n+            return putShort((short) value, buffer, pos);\n+        } else if (Integer.MIN_VALUE <= value && value <= Integer.MAX_VALUE) {\n+            int pos = putShort(LF_LONG, buffer, initialPos);\n+            return putInt((int) value, buffer, pos);\n+        } else if (0 <= value && value <= 0xffffffffL) {\n+            int pos = putShort(LF_ULONG, buffer, initialPos);\n+            return putInt((int) value, buffer, pos);\n+        } else {\n+            int pos = putShort(LF_QUADWORD, buffer, initialPos);\n+            return putLong(value, buffer, pos);\n+        }\n+    }\n+\n     /**\n      * Align on 4 byte boundary.\n      *\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxNTU2OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456815568", "body": "Outdated comment.", "bodyText": "Outdated comment.", "bodyHTML": "<p dir=\"auto\">Outdated comment.</p>", "author": "pejovica", "createdAt": "2020-07-18T18:29:32Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+abstract class CVUtil {\n+\n+    /* base level put methods that assume a non-null buffer */", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NTM4Mw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457695383", "bodyText": "Gone.", "author": "stooke", "createdAt": "2020-07-20T21:14:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxNTU2OA=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java\nindex 25911004bea..d825143c67d 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java\n", "chunk": "@@ -26,11 +26,12 @@\n \n package com.oracle.objectfile.pecoff.cv;\n \n+import com.oracle.objectfile.io.Utf8;\n+\n import static java.nio.charset.StandardCharsets.UTF_8;\n \n abstract class CVUtil {\n \n-    /* base level put methods that assume a non-null buffer */\n     static int putByte(byte b, byte[] buffer, int initialPos) {\n         if (buffer == null) {\n             return initialPos + Byte.BYTES;\n", "next_change": {"commit": "be97e8b0b377da7184398ae13748683d31424624", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java\nindex d825143c67d..f416e7bfc98 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java\n", "chunk": "@@ -32,51 +32,83 @@ import static java.nio.charset.StandardCharsets.UTF_8;\n \n abstract class CVUtil {\n \n-    static int putByte(byte b, byte[] buffer, int initialPos) {\n+    /**\n+     * Store a byte value in the buffer.\n+     *\n+     * @param value value to store\n+     * @param buffer buffer to store value in\n+     * @param initialPos initial position in buffer\n+     * @return position in buffer following stored value\n+     */\n+    static int putByte(byte value, byte[] buffer, int initialPos) {\n         if (buffer == null) {\n             return initialPos + Byte.BYTES;\n         }\n         int pos = initialPos;\n-        buffer[pos++] = b;\n+        buffer[pos++] = value;\n         return pos;\n     }\n \n-    static int putShort(short s, byte[] buffer, int initialPos) {\n+    /**\n+     * Store a short value in the buffer.\n+     *\n+     * @param value value to store\n+     * @param buffer buffer to store value in\n+     * @param initialPos initial position in buffer\n+     * @return position in buffer following stored value\n+     */\n+    static int putShort(short value, byte[] buffer, int initialPos) {\n         if (buffer == null) {\n             return initialPos + Short.BYTES;\n         }\n         int pos = initialPos;\n-        buffer[pos++] = (byte) (s & 0xff);\n-        buffer[pos++] = (byte) ((s >> 8) & 0xff);\n+        buffer[pos++] = (byte) (value & 0xff);\n+        buffer[pos++] = (byte) ((value >> 8) & 0xff);\n         return pos;\n     }\n \n-    static int putInt(int i, byte[] buffer, int initialPos) {\n+    /**\n+     * Store an integer value in the buffer.\n+     *\n+     * @param value value to store\n+     * @param buffer buffer to store value in\n+     * @param initialPos initial position in buffer\n+     * @return position in buffer following stored value\n+     */\n+    static int putInt(int value, byte[] buffer, int initialPos) {\n         if (buffer == null) {\n             return initialPos + Integer.BYTES;\n         }\n         int pos = initialPos;\n-        buffer[pos++] = (byte) (i & 0xff);\n-        buffer[pos++] = (byte) ((i >> 8) & 0xff);\n-        buffer[pos++] = (byte) ((i >> 16) & 0xff);\n-        buffer[pos++] = (byte) ((i >> 24) & 0xff);\n+        buffer[pos++] = (byte) (value & 0xff);\n+        buffer[pos++] = (byte) ((value >> 8) & 0xff);\n+        buffer[pos++] = (byte) ((value >> 16) & 0xff);\n+        buffer[pos++] = (byte) ((value >> 24) & 0xff);\n         return pos;\n     }\n \n+    /**\n+     * Store a long value in the buffer.\n+     *\n+     * @param value value to store\n+     * @param buffer buffer to store value in\n+     * @param initialPos initial position in buffer\n+     * @return position in buffer following stored value\n+     */\n     @SuppressWarnings(\"unused\")\n-    static int putLong(long l, byte[] buffer, int initialPos) {\n+    static int putLong(long value, byte[] buffer, int initialPos) {\n         if (buffer == null) {\n             return initialPos + Long.BYTES;\n         }\n         int pos = initialPos;\n-        buffer[pos++] = (byte) (l & 0xff);\n-        buffer[pos++] = (byte) ((l >> 8) & 0xff);\n-        buffer[pos++] = (byte) ((l >> 16) & 0xff);\n-        buffer[pos++] = (byte) ((l >> 24) & 0xff);\n-        buffer[pos++] = (byte) ((l >> 32) & 0xff);\n-        buffer[pos++] = (byte) ((l >> 40) & 0xff);\n-        buffer[pos++] = (byte) ((l >> 48) & 0xff);\n-        buffer[pos++] = (byte) ((l >> 56) & 0xff);\n+        buffer[pos++] = (byte) (value & 0xff);\n+        buffer[pos++] = (byte) ((value >> 8) & 0xff);\n+        buffer[pos++] = (byte) ((value >> 16) & 0xff);\n+        buffer[pos++] = (byte) ((value >> 24) & 0xff);\n+        buffer[pos++] = (byte) ((value >> 32) & 0xff);\n+        buffer[pos++] = (byte) ((value >> 40) & 0xff);\n+        buffer[pos++] = (byte) ((value >> 48) & 0xff);\n+        buffer[pos++] = (byte) ((value >> 56) & 0xff);\n         return pos;\n     }\n \n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkwMDg1OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456900858", "body": "Why are some constants commented out?", "bodyText": "Why are some constants commented out?", "bodyHTML": "<p dir=\"auto\">Why are some constants commented out?</p>", "author": "pejovica", "createdAt": "2020-07-19T12:09:13Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVDebugConstants.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+public abstract class CVDebugConstants {\n+\n+    // static final int DEBUG_S_IGNORE = 0x00;\n+    static final int DEBUG_S_SYMBOLS = 0xf1;\n+    static final int DEBUG_S_LINES = 0xf2;\n+    static final int DEBUG_S_STRINGTABLE = 0xf3;\n+    static final int DEBUG_S_FILECHKSMS = 0xf4;\n+\n+    /* subcommands in DEBUG_S_SYMBOLS section */\n+    // static final short S_COMPILE = 0x0001;", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NTQ1OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457695458", "bodyText": "I could suppress unused warnings instead.  Some of these constants will be used for the typeInfo PR, some for future architectures or compilers.  I'd rather pare the list after typeInfo is implemented.", "author": "stooke", "createdAt": "2020-07-20T21:14:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkwMDg1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM3Mjc1OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458372758", "bodyText": "gone, for now.", "author": "stooke", "createdAt": "2020-07-21T20:37:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkwMDg1OA=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVDebugConstants.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVDebugConstants.java\nindex 0cf9bf5550e..26f01446bb1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVDebugConstants.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVDebugConstants.java\n", "chunk": "@@ -28,77 +28,16 @@ package com.oracle.objectfile.pecoff.cv;\n \n public abstract class CVDebugConstants {\n \n-    // static final int DEBUG_S_IGNORE = 0x00;\n     static final int DEBUG_S_SYMBOLS = 0xf1;\n     static final int DEBUG_S_LINES = 0xf2;\n     static final int DEBUG_S_STRINGTABLE = 0xf3;\n     static final int DEBUG_S_FILECHKSMS = 0xf4;\n \n-    /* subcommands in DEBUG_S_SYMBOLS section */\n-    // static final short S_COMPILE = 0x0001;\n-    static final short S_SSEARCH = 0x0005;\n+    /* Subcommands in DEBUG_S_SYMBOLS section. */\n     static final short S_END = 0x0006;\n     static final short S_OBJNAME = 0x1101;\n-    static final short S_LDATA32_ST = 0x1007;\n     static final short S_FRAMEPROC = 0x1012;\n-    static final short S_CONSTANT = 0x1107;\n-    static final short S_UDT = 0x1108;\n-    static final short S_LDATA32 = 0x110c;\n-    static final short S_GDATA32 = 0x110d;\n     static final short S_GPROC32 = 0x1110;\n-    static final short S_REGREL32 = 0x1111;\n     static final short S_COMPILE3 = 0x113c;\n     static final short S_ENVBLOCK = 0x113d;\n-    static final short S_GPROC32_ID = 0x1147;\n-    static final short S_PROC_ID_END = 0x114f;\n-    // static final short S_BUILDINFO = 0x114c;\n-\n-    /* enums are more typesafe but the IDE no longer knows which enum constant is unused */\n-    @SuppressWarnings(\"unused\")\n-    enum CV_RECORD {\n-        CV_SIGNATURE_C13(4),\n-        S_COMPILE(0x0001),\n-        S_SSEARCH(0x0005),\n-        S_END(0x0006),\n-        S_OBJNAME(0x1101),\n-        S_LDATA32_ST(0x1007),\n-        S_FRAMEPROC(0x1012),\n-        S_CONSTANT(0x1107),\n-        S_UDT(0x1108),\n-        S_LDATA32(0x110c),\n-        S_GDATA32(0x110d),\n-        S_GPROC32(0x1110),\n-        S_REGREL32(0x1111),\n-        S_COMPILE3(0x113c),\n-        S_ENVBLOCK(0x113d);\n-\n-        final int cmd;\n-\n-        CV_RECORD(int cmd) {\n-            this.cmd = cmd;\n-        }\n-\n-        public int command() {\n-            return cmd;\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unused\")\n-    enum DEBUG_S {\n-        DEBUG_S_IGNORE(0x00),\n-        DEBUG_S_SYMBOLS(0xf1),\n-        DEBUG_S_LINES(0xf2),\n-        DEBUG_S_STRINGTABLE(0xf3),\n-        DEBUG_S_FILECHKSMS(0xf4);\n-\n-        final short cmd;\n-\n-        DEBUG_S(int cmd) {\n-            this.cmd = (short) cmd;\n-        }\n-\n-        public short command() {\n-            return cmd;\n-        }\n-    }\n }\n", "next_change": {"commit": "77e3a7479e429a3279d3061496d260e35f21f000", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVDebugConstants.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVDebugConstants.java\nindex 26f01446bb1..13e266c1fa1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVDebugConstants.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVDebugConstants.java\n", "chunk": "@@ -35,9 +35,13 @@ public abstract class CVDebugConstants {\n \n     /* Subcommands in DEBUG_S_SYMBOLS section. */\n     static final short S_END = 0x0006;\n-    static final short S_OBJNAME = 0x1101;\n     static final short S_FRAMEPROC = 0x1012;\n-    static final short S_GPROC32 = 0x1110;\n+    static final short S_OBJNAME = 0x1101;\n+    static final short S_UDT = 0x1108;\n+    static final short S_LDATA32 = 0x110c; /* Local static. */\n+    static final short S_GDATA32 = 0x110d; /* Global static. */\n+    static final short S_GPROC32 = 0x1110; /* Global procedure. */\n+    static final short S_REGREL32 = 0x1111;\n     static final short S_COMPILE3 = 0x113c;\n     static final short S_ENVBLOCK = 0x113d;\n }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkwMTA4NQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456901085", "body": "I think we should keep either constants or enums, but not both.", "bodyText": "I think we should keep either constants or enums, but not both.", "bodyHTML": "<p dir=\"auto\">I think we should keep either constants or enums, but not both.</p>", "author": "pejovica", "createdAt": "2020-07-19T12:11:17Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVDebugConstants.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+public abstract class CVDebugConstants {\n+\n+    // static final int DEBUG_S_IGNORE = 0x00;\n+    static final int DEBUG_S_SYMBOLS = 0xf1;\n+    static final int DEBUG_S_LINES = 0xf2;\n+    static final int DEBUG_S_STRINGTABLE = 0xf3;\n+    static final int DEBUG_S_FILECHKSMS = 0xf4;\n+\n+    /* subcommands in DEBUG_S_SYMBOLS section */\n+    // static final short S_COMPILE = 0x0001;\n+    static final short S_SSEARCH = 0x0005;\n+    static final short S_END = 0x0006;\n+    static final short S_OBJNAME = 0x1101;\n+    static final short S_LDATA32_ST = 0x1007;\n+    static final short S_FRAMEPROC = 0x1012;\n+    static final short S_CONSTANT = 0x1107;\n+    static final short S_UDT = 0x1108;\n+    static final short S_LDATA32 = 0x110c;\n+    static final short S_GDATA32 = 0x110d;\n+    static final short S_GPROC32 = 0x1110;\n+    static final short S_REGREL32 = 0x1111;\n+    static final short S_COMPILE3 = 0x113c;\n+    static final short S_ENVBLOCK = 0x113d;\n+    static final short S_GPROC32_ID = 0x1147;\n+    static final short S_PROC_ID_END = 0x114f;\n+    // static final short S_BUILDINFO = 0x114c;\n+\n+    /* enums are more typesafe but the IDE no longer knows which enum constant is unused */\n+    @SuppressWarnings(\"unused\")\n+    enum CV_RECORD {", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NTUyOA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457695528", "bodyText": "I'll get rid of the enums, because the IDE is less helpful with them.  Basically this was a rant that should have been deleted.", "author": "stooke", "createdAt": "2020-07-20T21:14:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkwMTA4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVDebugConstants.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVDebugConstants.java\nindex 0cf9bf5550e..26f01446bb1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVDebugConstants.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVDebugConstants.java\n", "chunk": "@@ -28,77 +28,16 @@ package com.oracle.objectfile.pecoff.cv;\n \n public abstract class CVDebugConstants {\n \n-    // static final int DEBUG_S_IGNORE = 0x00;\n     static final int DEBUG_S_SYMBOLS = 0xf1;\n     static final int DEBUG_S_LINES = 0xf2;\n     static final int DEBUG_S_STRINGTABLE = 0xf3;\n     static final int DEBUG_S_FILECHKSMS = 0xf4;\n \n-    /* subcommands in DEBUG_S_SYMBOLS section */\n-    // static final short S_COMPILE = 0x0001;\n-    static final short S_SSEARCH = 0x0005;\n+    /* Subcommands in DEBUG_S_SYMBOLS section. */\n     static final short S_END = 0x0006;\n     static final short S_OBJNAME = 0x1101;\n-    static final short S_LDATA32_ST = 0x1007;\n     static final short S_FRAMEPROC = 0x1012;\n-    static final short S_CONSTANT = 0x1107;\n-    static final short S_UDT = 0x1108;\n-    static final short S_LDATA32 = 0x110c;\n-    static final short S_GDATA32 = 0x110d;\n     static final short S_GPROC32 = 0x1110;\n-    static final short S_REGREL32 = 0x1111;\n     static final short S_COMPILE3 = 0x113c;\n     static final short S_ENVBLOCK = 0x113d;\n-    static final short S_GPROC32_ID = 0x1147;\n-    static final short S_PROC_ID_END = 0x114f;\n-    // static final short S_BUILDINFO = 0x114c;\n-\n-    /* enums are more typesafe but the IDE no longer knows which enum constant is unused */\n-    @SuppressWarnings(\"unused\")\n-    enum CV_RECORD {\n-        CV_SIGNATURE_C13(4),\n-        S_COMPILE(0x0001),\n-        S_SSEARCH(0x0005),\n-        S_END(0x0006),\n-        S_OBJNAME(0x1101),\n-        S_LDATA32_ST(0x1007),\n-        S_FRAMEPROC(0x1012),\n-        S_CONSTANT(0x1107),\n-        S_UDT(0x1108),\n-        S_LDATA32(0x110c),\n-        S_GDATA32(0x110d),\n-        S_GPROC32(0x1110),\n-        S_REGREL32(0x1111),\n-        S_COMPILE3(0x113c),\n-        S_ENVBLOCK(0x113d);\n-\n-        final int cmd;\n-\n-        CV_RECORD(int cmd) {\n-            this.cmd = cmd;\n-        }\n-\n-        public int command() {\n-            return cmd;\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unused\")\n-    enum DEBUG_S {\n-        DEBUG_S_IGNORE(0x00),\n-        DEBUG_S_SYMBOLS(0xf1),\n-        DEBUG_S_LINES(0xf2),\n-        DEBUG_S_STRINGTABLE(0xf3),\n-        DEBUG_S_FILECHKSMS(0xf4);\n-\n-        final short cmd;\n-\n-        DEBUG_S(int cmd) {\n-            this.cmd = (short) cmd;\n-        }\n-\n-        public short command() {\n-            return cmd;\n-        }\n-    }\n }\n", "next_change": {"commit": "77e3a7479e429a3279d3061496d260e35f21f000", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVDebugConstants.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVDebugConstants.java\nindex 26f01446bb1..13e266c1fa1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVDebugConstants.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVDebugConstants.java\n", "chunk": "@@ -35,9 +35,13 @@ public abstract class CVDebugConstants {\n \n     /* Subcommands in DEBUG_S_SYMBOLS section. */\n     static final short S_END = 0x0006;\n-    static final short S_OBJNAME = 0x1101;\n     static final short S_FRAMEPROC = 0x1012;\n-    static final short S_GPROC32 = 0x1110;\n+    static final short S_OBJNAME = 0x1101;\n+    static final short S_UDT = 0x1108;\n+    static final short S_LDATA32 = 0x110c; /* Local static. */\n+    static final short S_GDATA32 = 0x110d; /* Global static. */\n+    static final short S_GPROC32 = 0x1110; /* Global procedure. */\n+    static final short S_REGREL32 = 0x1111;\n     static final short S_COMPILE3 = 0x113c;\n     static final short S_ENVBLOCK = 0x113d;\n }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkwMjE0OQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456902149", "body": "I guess you don't need equivalents in `SectionName` then.", "bodyText": "I guess you don't need equivalents in SectionName then.", "bodyHTML": "<p dir=\"auto\">I guess you don't need equivalents in <code>SectionName</code> then.</p>", "author": "pejovica", "createdAt": "2020-07-19T12:21:37Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+public abstract class CVConstants {\n+\n+    /* names of relevant CodeView sections */\n+    static final String CV_SECTION_NAME_PREFIX = \".debug$\";\n+    static final String CV_SYMBOL_SECTION_NAME = CV_SECTION_NAME_PREFIX + \"S\";\n+    static final String CV_TYPE_SECTION_NAME = CV_SECTION_NAME_PREFIX + \"T\";", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NTU2NQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457695565", "bodyText": "Not at this time.  (So the SectionName constants have been deleted)", "author": "stooke", "createdAt": "2020-07-20T21:14:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkwMjE0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java\nindex 60cc6511ca2..5465da96716 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java\n", "chunk": "@@ -28,42 +28,11 @@ package com.oracle.objectfile.pecoff.cv;\n \n public abstract class CVConstants {\n \n-    /* names of relevant CodeView sections */\n+    /* The names of relevant CodeView sections. */\n     static final String CV_SECTION_NAME_PREFIX = \".debug$\";\n     static final String CV_SYMBOL_SECTION_NAME = CV_SECTION_NAME_PREFIX + \"S\";\n     static final String CV_TYPE_SECTION_NAME = CV_SECTION_NAME_PREFIX + \"T\";\n-    static final String TEXT_SECTION_NAME = \".text\";\n-    // static final String CV_RDATA_SECTION_NAME = \".rdata\";\n-    // static final String CV_PDATA_SECTION_NAME = \".pdata\";\n-    // static final String CV_XDATA_SECTION_NAME = \".xdata\";\n-    // static final String DATA_SECTION_NAME = \".data\";\n \n     /* CodeView section header signature */\n     static final int CV_SIGNATURE_C13 = 4;\n-\n-    /*\n-     * Knobs (some may become Graal options in the future)\n-     */\n-\n-    /*\n-     * if true, first main() does not have args in the debug name.\n-     */\n-    static final boolean emitUnadornedMain = true;\n-\n-    /*\n-     * if true, first main() becomes this name (with no class name or arg list at all) (set null to\n-     * disable).\n-     */\n-    static final String replaceMainFunctionName = null;\n-\n-    /*\n-     * The standard link.exe can't handle odd characters (parentheses or commas, for example) in\n-     * external names. Setting functionNamesHashArgs true replaces those names, so that\n-     * \"Foo.function(String[] args)\" becomes \"Foo.function_617849326\". If functionNamesHashArgs is\n-     * false, currently the linker will fail.\n-     *\n-     * if true, arg lists become obscure integers (and link.exe will work properly) TODO: strip\n-     * illegal characters from arg lists instead\n-     */\n-    static final boolean functionNamesHashArgs = true;\n }\n", "next_change": {"commit": "77e3a7479e429a3279d3061496d260e35f21f000", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java\nindex 5465da96716..9bea2634bbd 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java\n", "chunk": "@@ -35,4 +35,13 @@ public abstract class CVConstants {\n \n     /* CodeView section header signature */\n     static final int CV_SIGNATURE_C13 = 4;\n+\n+    static final int CV_AMD64_R8 = 336;\n+    static final int CV_AMD64_R9 = 337;\n+    static final int CV_AMD64_R10 = 338;\n+    static final int CV_AMD64_R11 = 339;\n+    static final int CV_AMD64_R12 = 340;\n+    static final int CV_AMD64_R13 = 341;\n+    static final int CV_AMD64_R14 = 342;\n+    static final int CV_AMD64_R15 = 343;\n }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkwMjg5Ng==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456902896", "body": "I would remove these. You can use `SectionName.TEXT` for the text section, and the rest can be added as needed.", "bodyText": "I would remove these. You can use SectionName.TEXT for the text section, and the rest can be added as needed.", "bodyHTML": "<p dir=\"auto\">I would remove these. You can use <code>SectionName.TEXT</code> for the text section, and the rest can be added as needed.</p>", "author": "pejovica", "createdAt": "2020-07-19T12:28:55Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+public abstract class CVConstants {\n+\n+    /* names of relevant CodeView sections */\n+    static final String CV_SECTION_NAME_PREFIX = \".debug$\";\n+    static final String CV_SYMBOL_SECTION_NAME = CV_SECTION_NAME_PREFIX + \"S\";\n+    static final String CV_TYPE_SECTION_NAME = CV_SECTION_NAME_PREFIX + \"T\";\n+    static final String TEXT_SECTION_NAME = \".text\";\n+    // static final String CV_RDATA_SECTION_NAME = \".rdata\";\n+    // static final String CV_PDATA_SECTION_NAME = \".pdata\";\n+    // static final String CV_XDATA_SECTION_NAME = \".xdata\";\n+    // static final String DATA_SECTION_NAME = \".data\";", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM3Njk1Ng==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458376956", "bodyText": "done.", "author": "stooke", "createdAt": "2020-07-21T20:45:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkwMjg5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java\nindex 60cc6511ca2..5465da96716 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java\n", "chunk": "@@ -28,42 +28,11 @@ package com.oracle.objectfile.pecoff.cv;\n \n public abstract class CVConstants {\n \n-    /* names of relevant CodeView sections */\n+    /* The names of relevant CodeView sections. */\n     static final String CV_SECTION_NAME_PREFIX = \".debug$\";\n     static final String CV_SYMBOL_SECTION_NAME = CV_SECTION_NAME_PREFIX + \"S\";\n     static final String CV_TYPE_SECTION_NAME = CV_SECTION_NAME_PREFIX + \"T\";\n-    static final String TEXT_SECTION_NAME = \".text\";\n-    // static final String CV_RDATA_SECTION_NAME = \".rdata\";\n-    // static final String CV_PDATA_SECTION_NAME = \".pdata\";\n-    // static final String CV_XDATA_SECTION_NAME = \".xdata\";\n-    // static final String DATA_SECTION_NAME = \".data\";\n \n     /* CodeView section header signature */\n     static final int CV_SIGNATURE_C13 = 4;\n-\n-    /*\n-     * Knobs (some may become Graal options in the future)\n-     */\n-\n-    /*\n-     * if true, first main() does not have args in the debug name.\n-     */\n-    static final boolean emitUnadornedMain = true;\n-\n-    /*\n-     * if true, first main() becomes this name (with no class name or arg list at all) (set null to\n-     * disable).\n-     */\n-    static final String replaceMainFunctionName = null;\n-\n-    /*\n-     * The standard link.exe can't handle odd characters (parentheses or commas, for example) in\n-     * external names. Setting functionNamesHashArgs true replaces those names, so that\n-     * \"Foo.function(String[] args)\" becomes \"Foo.function_617849326\". If functionNamesHashArgs is\n-     * false, currently the linker will fail.\n-     *\n-     * if true, arg lists become obscure integers (and link.exe will work properly) TODO: strip\n-     * illegal characters from arg lists instead\n-     */\n-    static final boolean functionNamesHashArgs = true;\n }\n", "next_change": {"commit": "77e3a7479e429a3279d3061496d260e35f21f000", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java\nindex 5465da96716..9bea2634bbd 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java\n", "chunk": "@@ -35,4 +35,13 @@ public abstract class CVConstants {\n \n     /* CodeView section header signature */\n     static final int CV_SIGNATURE_C13 = 4;\n+\n+    static final int CV_AMD64_R8 = 336;\n+    static final int CV_AMD64_R9 = 337;\n+    static final int CV_AMD64_R10 = 338;\n+    static final int CV_AMD64_R11 = 339;\n+    static final int CV_AMD64_R12 = 340;\n+    static final int CV_AMD64_R13 = 341;\n+    static final int CV_AMD64_R14 = 342;\n+    static final int CV_AMD64_R15 = 343;\n }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkwNTUyNQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456905525", "body": "Adding subrecords while computing the size seems a bit out of place.", "bodyText": "Adding subrecords while computing the size seems a bit out of place.", "bodyHTML": "<p dir=\"auto\">Adding subrecords while computing the size seems a bit out of place.</p>", "author": "pejovica", "createdAt": "2020-07-19T12:54:34Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsection.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A CVSymbolSubsection is s special record in debug$S containing nested symbol records\n+ * (the nested records inherit from CVSymbolSubrecord)\n+ */\n+class CVSymbolSubsection extends CVSymbolRecord {\n+\n+    private static final int SUBCMD_INITIAL_CAPACITY = 100;\n+\n+    private ArrayList<CVSymbolSubrecord> subcmds = new ArrayList<>(SUBCMD_INITIAL_CAPACITY);\n+\n+    CVSymbolSubsection(CVDebugInfo cvDebugInfo) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_SYMBOLS);\n+    }\n+\n+    void addRecord(CVSymbolSubrecord subcmd) {\n+        subcmds.add(subcmd);\n+    }\n+\n+    void addSubrecords() {\n+    }\n+\n+    @Override\n+    protected int computeSize(int initialPos) {\n+        int pos = initialPos;\n+        addSubrecords();", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgzMzM1OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458833358", "bodyText": "Gone.  Probably you would not have noticed if I called the functions pass1() and pass2().", "author": "stooke", "createdAt": "2020-07-22T14:26:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkwNTUyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsection.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsection.java\nindex 005bde7823f..da422e8b689 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsection.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsection.java\n", "chunk": "@@ -48,17 +48,9 @@ class CVSymbolSubsection extends CVSymbolRecord {\n         subcmds.add(subcmd);\n     }\n \n-    void addSubrecords() {\n-    }\n-\n     @Override\n     protected int computeSize(int initialPos) {\n-        int pos = initialPos;\n-        addSubrecords();\n-        for (CVSymbolSubrecord subcmd : subcmds) {\n-            pos = subcmd.computeFullSize(pos);\n-        }\n-        return pos;\n+        return computeContents(null, initialPos);\n     }\n \n     @Override\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkxNDIyNQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456914225", "body": "Unused method (a debugging leftover?).", "bodyText": "Unused method (a debugging leftover?).", "bodyHTML": "<p dir=\"auto\">Unused method (a debugging leftover?).</p>", "author": "pejovica", "createdAt": "2020-07-19T14:16:55Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVFileRecord.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+\n+import java.io.PrintStream;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Paths;\n+import java.security.MessageDigest;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+final class CVFileRecord extends CVSymbolRecord {\n+\n+    private static final byte CHECKSUM_NONE = 0x00;\n+    private static final byte CHECKSUM_MD5 = 0x01;\n+    private static final byte CB_VALUE = 0x10;\n+\n+    private static final int FILE_RECORD_LENGTH = 24;\n+\n+    private static final int CHECKSUM_LENGTH = 16;\n+    private static final byte[] EMPTY_CHECKSUM = new byte[CHECKSUM_LENGTH];\n+\n+    private static final int FILE_TABLE_INITIAL_SIZE = 200;\n+\n+    private final CVSymbolSectionImpl.CVStringTable strings;\n+\n+    private int currentOffset = 0;\n+    private Map<FileEntry, Integer> fileEntryToOffsetMap = new LinkedHashMap<>(FILE_TABLE_INITIAL_SIZE);\n+\n+    CVFileRecord(CVDebugInfo cvDebugInfo, CVSymbolSectionImpl.CVStringTable strings) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_FILECHKSMS);\n+        this.strings = strings;\n+    }\n+\n+    /**\n+     * Convert a FileEntry to a path. Avoid an NPE if there's no DirEntry.\n+     *\n+     * @param fileEntry\n+     * @return path string, including directory if it exists.\n+     */\n+    private static String fixPath(FileEntry fileEntry) {\n+        return fileEntry.getDirEntry() != null ? fileEntry.getFullName() : fileEntry.getFileName();\n+    }\n+\n+    int addFile(FileEntry entry) {\n+        if (fileEntryToOffsetMap.containsKey(entry)) {\n+            return fileEntryToOffsetMap.get(entry);\n+        } else {\n+            fileEntryToOffsetMap.put(entry, currentOffset);\n+            /* create required stringtable entry */\n+            strings.add(fixPath(entry));\n+            currentOffset += FILE_RECORD_LENGTH;\n+            return currentOffset - FILE_RECORD_LENGTH;\n+        }\n+    }\n+\n+    @Override\n+    public int computeSize(int initialPos) {\n+        /* add all fileEntries; duplicates are ignored */\n+        /*\n+         * probably don't need to do this because if it isn't already here it's probably referenced\n+         * by the debug info\n+         */\n+        /* consider moving this to CVSymbolSectionImpl */\n+        for (FileEntry entry : cvDebugInfo.getFiles()) {\n+            addFile(entry);\n+        }\n+        return initialPos + (fileEntryToOffsetMap.size() * FILE_RECORD_LENGTH);\n+    }\n+\n+    @Override\n+    public int computeContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        for (FileEntry entry : fileEntryToOffsetMap.keySet()) {\n+            pos = put(entry, buffer, pos);\n+        }\n+        return pos;\n+    }\n+\n+    private int put(FileEntry entry, byte[] buffer, int initialPos) {\n+        String fn = fixPath(entry);\n+        int stringId = strings.add(fn);\n+        int pos = CVUtil.putInt(stringId, buffer, initialPos); /* stringtable index */\n+        pos = CVUtil.putByte(CB_VALUE, buffer, pos); /* Cb (unknown what this is) */\n+        byte[] checksum = calculateMD5Sum(fn);\n+        if (checksum != null) {\n+            pos = CVUtil.putByte(CHECKSUM_MD5, buffer, pos); /* checksum type (0x01 == MD5) */\n+            pos = CVUtil.putBytes(checksum, buffer, pos);\n+        } else {\n+            pos = CVUtil.putByte(CHECKSUM_NONE, buffer, pos);\n+            pos = CVUtil.putBytes(EMPTY_CHECKSUM, buffer, pos);\n+        }\n+        pos = CVUtil.align4(pos);\n+        return pos;\n+    }\n+\n+    private static byte[] calculateMD5Sum(String fn) {\n+        try {\n+            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n+            md.update(Files.readAllBytes(Paths.get(fn)));\n+            return md.digest();\n+        } catch (NoSuchFileException e) {\n+            return null;\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"CVFileRecord(type=\" + type + \",pos=\" + recordStartPosition + \", size=\" + fileEntryToOffsetMap.size() + \")\";\n+    }\n+\n+    public void dump(PrintStream out) {", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM3NzUwNQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458377505", "bodyText": "There should be a place for these to live.  Gone.", "author": "stooke", "createdAt": "2020-07-21T20:46:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkxNDIyNQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkyNTAzOA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456925038", "body": "Why print a stack trace if you continue with normal execution?", "bodyText": "Why print a stack trace if you continue with normal execution?", "bodyHTML": "<p dir=\"auto\">Why print a stack trace if you continue with normal execution?</p>", "author": "pejovica", "createdAt": "2020-07-19T15:58:02Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVFileRecord.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+\n+import java.io.PrintStream;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Paths;\n+import java.security.MessageDigest;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+final class CVFileRecord extends CVSymbolRecord {\n+\n+    private static final byte CHECKSUM_NONE = 0x00;\n+    private static final byte CHECKSUM_MD5 = 0x01;\n+    private static final byte CB_VALUE = 0x10;\n+\n+    private static final int FILE_RECORD_LENGTH = 24;\n+\n+    private static final int CHECKSUM_LENGTH = 16;\n+    private static final byte[] EMPTY_CHECKSUM = new byte[CHECKSUM_LENGTH];\n+\n+    private static final int FILE_TABLE_INITIAL_SIZE = 200;\n+\n+    private final CVSymbolSectionImpl.CVStringTable strings;\n+\n+    private int currentOffset = 0;\n+    private Map<FileEntry, Integer> fileEntryToOffsetMap = new LinkedHashMap<>(FILE_TABLE_INITIAL_SIZE);\n+\n+    CVFileRecord(CVDebugInfo cvDebugInfo, CVSymbolSectionImpl.CVStringTable strings) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_FILECHKSMS);\n+        this.strings = strings;\n+    }\n+\n+    /**\n+     * Convert a FileEntry to a path. Avoid an NPE if there's no DirEntry.\n+     *\n+     * @param fileEntry\n+     * @return path string, including directory if it exists.\n+     */\n+    private static String fixPath(FileEntry fileEntry) {\n+        return fileEntry.getDirEntry() != null ? fileEntry.getFullName() : fileEntry.getFileName();\n+    }\n+\n+    int addFile(FileEntry entry) {\n+        if (fileEntryToOffsetMap.containsKey(entry)) {\n+            return fileEntryToOffsetMap.get(entry);\n+        } else {\n+            fileEntryToOffsetMap.put(entry, currentOffset);\n+            /* create required stringtable entry */\n+            strings.add(fixPath(entry));\n+            currentOffset += FILE_RECORD_LENGTH;\n+            return currentOffset - FILE_RECORD_LENGTH;\n+        }\n+    }\n+\n+    @Override\n+    public int computeSize(int initialPos) {\n+        /* add all fileEntries; duplicates are ignored */\n+        /*\n+         * probably don't need to do this because if it isn't already here it's probably referenced\n+         * by the debug info\n+         */\n+        /* consider moving this to CVSymbolSectionImpl */\n+        for (FileEntry entry : cvDebugInfo.getFiles()) {\n+            addFile(entry);\n+        }\n+        return initialPos + (fileEntryToOffsetMap.size() * FILE_RECORD_LENGTH);\n+    }\n+\n+    @Override\n+    public int computeContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        for (FileEntry entry : fileEntryToOffsetMap.keySet()) {\n+            pos = put(entry, buffer, pos);\n+        }\n+        return pos;\n+    }\n+\n+    private int put(FileEntry entry, byte[] buffer, int initialPos) {\n+        String fn = fixPath(entry);\n+        int stringId = strings.add(fn);\n+        int pos = CVUtil.putInt(stringId, buffer, initialPos); /* stringtable index */\n+        pos = CVUtil.putByte(CB_VALUE, buffer, pos); /* Cb (unknown what this is) */\n+        byte[] checksum = calculateMD5Sum(fn);\n+        if (checksum != null) {\n+            pos = CVUtil.putByte(CHECKSUM_MD5, buffer, pos); /* checksum type (0x01 == MD5) */\n+            pos = CVUtil.putBytes(checksum, buffer, pos);\n+        } else {\n+            pos = CVUtil.putByte(CHECKSUM_NONE, buffer, pos);\n+            pos = CVUtil.putBytes(EMPTY_CHECKSUM, buffer, pos);\n+        }\n+        pos = CVUtil.align4(pos);\n+        return pos;\n+    }\n+\n+    private static byte[] calculateMD5Sum(String fn) {\n+        try {\n+            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n+            md.update(Files.readAllBytes(Paths.get(fn)));\n+            return md.digest();\n+        } catch (NoSuchFileException e) {\n+            return null;\n+        } catch (Exception e) {\n+            e.printStackTrace();", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM5NjA1Mw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458396053", "bodyText": "Because I didn't know about throw GraalError.shouldNotReachHere().  Fixed.", "author": "stooke", "createdAt": "2020-07-21T21:22:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkyNTAzOA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkyNjI0OQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456926249", "body": "Can this be removed as the comments suggest, or is it still necessary?", "bodyText": "Can this be removed as the comments suggest, or is it still necessary?", "bodyHTML": "<p dir=\"auto\">Can this be removed as the comments suggest, or is it still necessary?</p>", "author": "pejovica", "createdAt": "2020-07-19T16:10:10Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVFileRecord.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+\n+import java.io.PrintStream;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Paths;\n+import java.security.MessageDigest;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+final class CVFileRecord extends CVSymbolRecord {\n+\n+    private static final byte CHECKSUM_NONE = 0x00;\n+    private static final byte CHECKSUM_MD5 = 0x01;\n+    private static final byte CB_VALUE = 0x10;\n+\n+    private static final int FILE_RECORD_LENGTH = 24;\n+\n+    private static final int CHECKSUM_LENGTH = 16;\n+    private static final byte[] EMPTY_CHECKSUM = new byte[CHECKSUM_LENGTH];\n+\n+    private static final int FILE_TABLE_INITIAL_SIZE = 200;\n+\n+    private final CVSymbolSectionImpl.CVStringTable strings;\n+\n+    private int currentOffset = 0;\n+    private Map<FileEntry, Integer> fileEntryToOffsetMap = new LinkedHashMap<>(FILE_TABLE_INITIAL_SIZE);\n+\n+    CVFileRecord(CVDebugInfo cvDebugInfo, CVSymbolSectionImpl.CVStringTable strings) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_FILECHKSMS);\n+        this.strings = strings;\n+    }\n+\n+    /**\n+     * Convert a FileEntry to a path. Avoid an NPE if there's no DirEntry.\n+     *\n+     * @param fileEntry\n+     * @return path string, including directory if it exists.\n+     */\n+    private static String fixPath(FileEntry fileEntry) {\n+        return fileEntry.getDirEntry() != null ? fileEntry.getFullName() : fileEntry.getFileName();\n+    }\n+\n+    int addFile(FileEntry entry) {\n+        if (fileEntryToOffsetMap.containsKey(entry)) {\n+            return fileEntryToOffsetMap.get(entry);\n+        } else {\n+            fileEntryToOffsetMap.put(entry, currentOffset);\n+            /* create required stringtable entry */\n+            strings.add(fixPath(entry));\n+            currentOffset += FILE_RECORD_LENGTH;\n+            return currentOffset - FILE_RECORD_LENGTH;\n+        }\n+    }\n+\n+    @Override\n+    public int computeSize(int initialPos) {\n+        /* add all fileEntries; duplicates are ignored */\n+        /*\n+         * probably don't need to do this because if it isn't already here it's probably referenced\n+         * by the debug info\n+         */\n+        /* consider moving this to CVSymbolSectionImpl */\n+        for (FileEntry entry : cvDebugInfo.getFiles()) {\n+            addFile(entry);\n+        }", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODg1MDkyNQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458850925", "bodyText": "Still necessary.  Comments have been cleaned up.", "author": "stooke", "createdAt": "2020-07-22T14:49:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkyNjI0OQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkyODYzMg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456928632", "body": "I would add an assertion that we indeed used exactly `FILE_RECORD_LENGTH` bytes (because that is assumed when computing the size).\r\n```suggestion\r\n        pos = CVUtil.align4(pos);\r\n        assert pos == initialPos + FILE_RECORD_LENGTH;\r\n```", "bodyText": "I would add an assertion that we indeed used exactly FILE_RECORD_LENGTH bytes (because that is assumed when computing the size).\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    pos = CVUtil.align4(pos);\n          \n          \n            \n                    pos = CVUtil.align4(pos);\n          \n          \n            \n                    assert pos == initialPos + FILE_RECORD_LENGTH;", "bodyHTML": "<p dir=\"auto\">I would add an assertion that we indeed used exactly <code>FILE_RECORD_LENGTH</code> bytes (because that is assumed when computing the size).</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        pos <span class=\"pl-k\">=</span> <span class=\"pl-smi\">CVUtil</span><span class=\"pl-k\">.</span>align4(pos);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        pos <span class=\"pl-k\">=</span> <span class=\"pl-smi\">CVUtil</span><span class=\"pl-k\">.</span>align4(pos);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">assert</span> pos <span class=\"pl-k\">==</span> initialPos <span class=\"pl-k\">+</span> <span class=\"pl-c1\">FILE_RECORD_LENGTH</span>;</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pejovica", "createdAt": "2020-07-19T16:33:48Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVFileRecord.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+\n+import java.io.PrintStream;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Paths;\n+import java.security.MessageDigest;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+final class CVFileRecord extends CVSymbolRecord {\n+\n+    private static final byte CHECKSUM_NONE = 0x00;\n+    private static final byte CHECKSUM_MD5 = 0x01;\n+    private static final byte CB_VALUE = 0x10;\n+\n+    private static final int FILE_RECORD_LENGTH = 24;\n+\n+    private static final int CHECKSUM_LENGTH = 16;\n+    private static final byte[] EMPTY_CHECKSUM = new byte[CHECKSUM_LENGTH];\n+\n+    private static final int FILE_TABLE_INITIAL_SIZE = 200;\n+\n+    private final CVSymbolSectionImpl.CVStringTable strings;\n+\n+    private int currentOffset = 0;\n+    private Map<FileEntry, Integer> fileEntryToOffsetMap = new LinkedHashMap<>(FILE_TABLE_INITIAL_SIZE);\n+\n+    CVFileRecord(CVDebugInfo cvDebugInfo, CVSymbolSectionImpl.CVStringTable strings) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_FILECHKSMS);\n+        this.strings = strings;\n+    }\n+\n+    /**\n+     * Convert a FileEntry to a path. Avoid an NPE if there's no DirEntry.\n+     *\n+     * @param fileEntry\n+     * @return path string, including directory if it exists.\n+     */\n+    private static String fixPath(FileEntry fileEntry) {\n+        return fileEntry.getDirEntry() != null ? fileEntry.getFullName() : fileEntry.getFileName();\n+    }\n+\n+    int addFile(FileEntry entry) {\n+        if (fileEntryToOffsetMap.containsKey(entry)) {\n+            return fileEntryToOffsetMap.get(entry);\n+        } else {\n+            fileEntryToOffsetMap.put(entry, currentOffset);\n+            /* create required stringtable entry */\n+            strings.add(fixPath(entry));\n+            currentOffset += FILE_RECORD_LENGTH;\n+            return currentOffset - FILE_RECORD_LENGTH;\n+        }\n+    }\n+\n+    @Override\n+    public int computeSize(int initialPos) {\n+        /* add all fileEntries; duplicates are ignored */\n+        /*\n+         * probably don't need to do this because if it isn't already here it's probably referenced\n+         * by the debug info\n+         */\n+        /* consider moving this to CVSymbolSectionImpl */\n+        for (FileEntry entry : cvDebugInfo.getFiles()) {\n+            addFile(entry);\n+        }\n+        return initialPos + (fileEntryToOffsetMap.size() * FILE_RECORD_LENGTH);\n+    }\n+\n+    @Override\n+    public int computeContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        for (FileEntry entry : fileEntryToOffsetMap.keySet()) {\n+            pos = put(entry, buffer, pos);\n+        }\n+        return pos;\n+    }\n+\n+    private int put(FileEntry entry, byte[] buffer, int initialPos) {\n+        String fn = fixPath(entry);\n+        int stringId = strings.add(fn);\n+        int pos = CVUtil.putInt(stringId, buffer, initialPos); /* stringtable index */\n+        pos = CVUtil.putByte(CB_VALUE, buffer, pos); /* Cb (unknown what this is) */\n+        byte[] checksum = calculateMD5Sum(fn);\n+        if (checksum != null) {\n+            pos = CVUtil.putByte(CHECKSUM_MD5, buffer, pos); /* checksum type (0x01 == MD5) */\n+            pos = CVUtil.putBytes(checksum, buffer, pos);\n+        } else {\n+            pos = CVUtil.putByte(CHECKSUM_NONE, buffer, pos);\n+            pos = CVUtil.putBytes(EMPTY_CHECKSUM, buffer, pos);\n+        }\n+        pos = CVUtil.align4(pos);", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODg3Mjg3MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458872870", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-07-22T15:18:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkyODYzMg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk1NzEzMg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456957132", "body": "These fields don\u2019t seem to have any practical use at the moment so I think they should be removed.", "bodyText": "These fields don\u2019t seem to have any practical use at the moment so I think they should be removed.", "bodyHTML": "<p dir=\"auto\">These fields don\u2019t seem to have any practical use at the moment so I think they should be removed.</p>", "author": "pejovica", "createdAt": "2020-07-19T21:21:19Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+abstract class CVSectionImpl extends BasicProgbitsSectionImpl {\n+\n+    boolean debug = false;\n+    long debugTextBase = 0;\n+    long debugAddress = 0;\n+    int debugBase = 0;", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM5MjQ2MQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458392461", "bodyText": "not any more.  Gone.", "author": "stooke", "createdAt": "2020-07-21T21:15:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk1NzEzMg=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java\nindex 7e12c260496..a149e38c99c 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java\n", "chunk": "@@ -40,48 +39,29 @@ import java.util.Set;\n abstract class CVSectionImpl extends BasicProgbitsSectionImpl {\n \n     boolean debug = false;\n-    long debugTextBase = 0;\n-    long debugAddress = 0;\n-    int debugBase = 0;\n \n     CVSectionImpl() {\n     }\n \n-    @Override\n-    public void setElement(ObjectFile.Element e) {\n-        super.setElement(e);\n-        /* define the section as a COFF symbol */\n-        getOwner().createDefinedSymbol(getSectionName(), getElement(), 0, 0, false, false);\n-    }\n-\n     private String debugSectionLogName() {\n         /*\n-         * Use prefix cv4 plus the section name (which already includes a dot separator) for the\n-         * context key. For example messages for type section will be keyed using \"cv4.debug$T\".\n-         * Other info formats use their own format-specific prefix.\n+         * Log messages for the symbol section will be enabled using \"PeCoffdebug$S\". Log messages\n+         * for the type section will be enabled using \"PeCoffdebug$T\".\n          */\n         assert getSectionName().startsWith(CVConstants.CV_SECTION_NAME_PREFIX);\n         return \"PeCoff\" + getSectionName().replace(\".\", \"\");\n     }\n \n-    protected void enableLog(DebugContext context, int pos) {\n+    protected void enableLog(DebugContext context) {\n         /*\n          * Unlike in the Dwarf debug code, debug output may be enabled in both the sizing and\n-         * writing phases. (Currently turned off in the sizing state) At this time, debugBase and\n-         * debugAddress aren't used but are there for the future.\n+         * writing phases. (Currently turned off in the sizing state)\n          */\n         if (context.areScopesEnabled()) {\n             debug = true;\n-            debugBase = pos;\n-            debugAddress = debugTextBase;\n         }\n     }\n \n-    @Override\n-    public int getAlignment() {\n-        return 1;\n-    }\n-\n     protected void log(DebugContext context, String format, Object... args) {\n         if (debug) {\n             context.logv(DebugContext.INFO_LEVEL, format, args);\n", "next_change": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java\nindex a149e38c99c..945111fc4c3 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java\n", "chunk": "@@ -52,25 +62,26 @@ abstract class CVSectionImpl extends BasicProgbitsSectionImpl {\n         return \"PeCoff\" + getSectionName().replace(\".\", \"\");\n     }\n \n-    protected void enableLog(DebugContext context) {\n+    protected void enableLog(DebugContext debugContext) {\n         /*\n          * Unlike in the Dwarf debug code, debug output may be enabled in both the sizing and\n          * writing phases. (Currently turned off in the sizing state)\n          */\n-        if (context.areScopesEnabled()) {\n+        cvDebugInfo.setDebugContext(debugContext);\n+        if (debugContext.areScopesEnabled()) {\n             debug = true;\n         }\n     }\n \n-    protected void log(DebugContext context, String format, Object... args) {\n+    protected void log(String format, Object... args) {\n         if (debug) {\n-            context.logv(DebugContext.INFO_LEVEL, format, args);\n+            getDebugContext().logv(DebugContext.INFO_LEVEL, format, args);\n         }\n     }\n \n-    protected void verboseLog(DebugContext context, String format, Object... args) {\n+    protected void verboseLog(String format, Object... args) {\n         if (debug) {\n-            context.logv(DebugContext.VERBOSE_LEVEL, format, args);\n+            getDebugContext().logv(DebugContext.VERBOSE_LEVEL, format, args);\n         }\n     }\n \n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk1ODA1MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456958050", "body": "Should this comment be updated? It does not match the return value.", "bodyText": "Should this comment be updated? It does not match the return value.", "bodyHTML": "<p dir=\"auto\">Should this comment be updated? It does not match the return value.</p>", "author": "pejovica", "createdAt": "2020-07-19T21:31:44Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+abstract class CVSectionImpl extends BasicProgbitsSectionImpl {\n+\n+    boolean debug = false;\n+    long debugTextBase = 0;\n+    long debugAddress = 0;\n+    int debugBase = 0;\n+\n+    CVSectionImpl() {\n+    }\n+\n+    @Override\n+    public void setElement(ObjectFile.Element e) {\n+        super.setElement(e);\n+        /* define the section as a COFF symbol */\n+        getOwner().createDefinedSymbol(getSectionName(), getElement(), 0, 0, false, false);\n+    }\n+\n+    private String debugSectionLogName() {\n+        /*\n+         * Use prefix cv4 plus the section name (which already includes a dot separator) for the\n+         * context key. For example messages for type section will be keyed using \"cv4.debug$T\".\n+         * Other info formats use their own format-specific prefix.\n+         */", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM5MzgzNw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458393837", "bodyText": "Updated.", "author": "stooke", "createdAt": "2020-07-21T21:18:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk1ODA1MA=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java\nindex 7e12c260496..a149e38c99c 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java\n", "chunk": "@@ -40,48 +39,29 @@ import java.util.Set;\n abstract class CVSectionImpl extends BasicProgbitsSectionImpl {\n \n     boolean debug = false;\n-    long debugTextBase = 0;\n-    long debugAddress = 0;\n-    int debugBase = 0;\n \n     CVSectionImpl() {\n     }\n \n-    @Override\n-    public void setElement(ObjectFile.Element e) {\n-        super.setElement(e);\n-        /* define the section as a COFF symbol */\n-        getOwner().createDefinedSymbol(getSectionName(), getElement(), 0, 0, false, false);\n-    }\n-\n     private String debugSectionLogName() {\n         /*\n-         * Use prefix cv4 plus the section name (which already includes a dot separator) for the\n-         * context key. For example messages for type section will be keyed using \"cv4.debug$T\".\n-         * Other info formats use their own format-specific prefix.\n+         * Log messages for the symbol section will be enabled using \"PeCoffdebug$S\". Log messages\n+         * for the type section will be enabled using \"PeCoffdebug$T\".\n          */\n         assert getSectionName().startsWith(CVConstants.CV_SECTION_NAME_PREFIX);\n         return \"PeCoff\" + getSectionName().replace(\".\", \"\");\n     }\n \n-    protected void enableLog(DebugContext context, int pos) {\n+    protected void enableLog(DebugContext context) {\n         /*\n          * Unlike in the Dwarf debug code, debug output may be enabled in both the sizing and\n-         * writing phases. (Currently turned off in the sizing state) At this time, debugBase and\n-         * debugAddress aren't used but are there for the future.\n+         * writing phases. (Currently turned off in the sizing state)\n          */\n         if (context.areScopesEnabled()) {\n             debug = true;\n-            debugBase = pos;\n-            debugAddress = debugTextBase;\n         }\n     }\n \n-    @Override\n-    public int getAlignment() {\n-        return 1;\n-    }\n-\n     protected void log(DebugContext context, String format, Object... args) {\n         if (debug) {\n             context.logv(DebugContext.INFO_LEVEL, format, args);\n", "next_change": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java\nindex a149e38c99c..945111fc4c3 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java\n", "chunk": "@@ -52,25 +62,26 @@ abstract class CVSectionImpl extends BasicProgbitsSectionImpl {\n         return \"PeCoff\" + getSectionName().replace(\".\", \"\");\n     }\n \n-    protected void enableLog(DebugContext context) {\n+    protected void enableLog(DebugContext debugContext) {\n         /*\n          * Unlike in the Dwarf debug code, debug output may be enabled in both the sizing and\n          * writing phases. (Currently turned off in the sizing state)\n          */\n-        if (context.areScopesEnabled()) {\n+        cvDebugInfo.setDebugContext(debugContext);\n+        if (debugContext.areScopesEnabled()) {\n             debug = true;\n         }\n     }\n \n-    protected void log(DebugContext context, String format, Object... args) {\n+    protected void log(String format, Object... args) {\n         if (debug) {\n-            context.logv(DebugContext.INFO_LEVEL, format, args);\n+            getDebugContext().logv(DebugContext.INFO_LEVEL, format, args);\n         }\n     }\n \n-    protected void verboseLog(DebugContext context, String format, Object... args) {\n+    protected void verboseLog(String format, Object... args) {\n         if (debug) {\n-            context.logv(DebugContext.VERBOSE_LEVEL, format, args);\n+            getDebugContext().logv(DebugContext.VERBOSE_LEVEL, format, args);\n         }\n     }\n \n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk1ODY0Mg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456958642", "body": "This looks like a leftover, as well as the unused `targetSection` above and the commented out `targetSectionKinds` below.", "bodyText": "This looks like a leftover, as well as the unused targetSection above and the commented out targetSectionKinds below.", "bodyHTML": "<p dir=\"auto\">This looks like a leftover, as well as the unused <code>targetSection</code> above and the commented out <code>targetSectionKinds</code> below.</p>", "author": "pejovica", "createdAt": "2020-07-19T21:39:01Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+abstract class CVSectionImpl extends BasicProgbitsSectionImpl {\n+\n+    boolean debug = false;\n+    long debugTextBase = 0;\n+    long debugAddress = 0;\n+    int debugBase = 0;\n+\n+    CVSectionImpl() {\n+    }\n+\n+    @Override\n+    public void setElement(ObjectFile.Element e) {\n+        super.setElement(e);\n+        /* define the section as a COFF symbol */\n+        getOwner().createDefinedSymbol(getSectionName(), getElement(), 0, 0, false, false);\n+    }\n+\n+    private String debugSectionLogName() {\n+        /*\n+         * Use prefix cv4 plus the section name (which already includes a dot separator) for the\n+         * context key. For example messages for type section will be keyed using \"cv4.debug$T\".\n+         * Other info formats use their own format-specific prefix.\n+         */\n+        assert getSectionName().startsWith(CVConstants.CV_SECTION_NAME_PREFIX);\n+        return \"PeCoff\" + getSectionName().replace(\".\", \"\");\n+    }\n+\n+    protected void enableLog(DebugContext context, int pos) {\n+        /*\n+         * Unlike in the Dwarf debug code, debug output may be enabled in both the sizing and\n+         * writing phases. (Currently turned off in the sizing state) At this time, debugBase and\n+         * debugAddress aren't used but are there for the future.\n+         */\n+        if (context.areScopesEnabled()) {\n+            debug = true;\n+            debugBase = pos;\n+            debugAddress = debugTextBase;\n+        }\n+    }\n+\n+    @Override\n+    public int getAlignment() {\n+        return 1;\n+    }\n+\n+    protected void log(DebugContext context, String format, Object... args) {\n+        if (debug) {\n+            context.logv(DebugContext.INFO_LEVEL, format, args);\n+        }\n+    }\n+\n+    protected void verboseLog(DebugContext context, String format, Object... args) {\n+        if (debug) {\n+            context.logv(DebugContext.VERBOSE_LEVEL, format, args);\n+        }\n+    }\n+\n+    @Override\n+    public byte[] getOrDecideContent(Map<ObjectFile.Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+\n+        /* ensure content byte[] has been created before calling super method */\n+        getOwner().debugContext(debugSectionLogName(), this::createContent);\n+\n+        /* ensure content byte[] has been written before calling super method */\n+        getOwner().debugContext(debugSectionLogName(), this::writeContent);\n+\n+        return super.getOrDecideContent(alreadyDecided, contentHint);\n+    }\n+\n+    @Override\n+    public Set<BuildDependency> getDependencies(Map<ObjectFile.Element, LayoutDecisionMap> decisions) {\n+        Set<BuildDependency> deps = super.getDependencies(decisions);\n+        String targetName = getSectionName();\n+        @SuppressWarnings(\"unused\")\n+        PECoffObjectFile.PECoffSection targetSection = (PECoffObjectFile.PECoffSection) getElement().getOwner().elementForName(targetName);\n+        LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n+        LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n+        // LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n+        /* make our content depend on the size and content of the target */\n+        // for (LayoutDecision.Kind targetKind : targetKinds) {\n+        // LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n+        // deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n+        // }", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM5ODI2Mw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458398263", "bodyText": "Gone.", "author": "stooke", "createdAt": "2020-07-21T21:27:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk1ODY0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java\nindex 7e12c260496..a149e38c99c 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java\n", "chunk": "@@ -109,23 +89,13 @@ abstract class CVSectionImpl extends BasicProgbitsSectionImpl {\n     @Override\n     public Set<BuildDependency> getDependencies(Map<ObjectFile.Element, LayoutDecisionMap> decisions) {\n         Set<BuildDependency> deps = super.getDependencies(decisions);\n-        String targetName = getSectionName();\n-        @SuppressWarnings(\"unused\")\n-        PECoffObjectFile.PECoffSection targetSection = (PECoffObjectFile.PECoffSection) getElement().getOwner().elementForName(targetName);\n         LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n         LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n-        // LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n-        /* make our content depend on the size and content of the target */\n-        // for (LayoutDecision.Kind targetKind : targetKinds) {\n-        // LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n-        // deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n-        // }\n-        /* make our size depend on our content */\n+        /* Make our size depend on our content. */\n         deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n         return deps;\n     }\n \n-    // public abstract LayoutDecision.Kind[] targetSectionKinds();\n     public abstract void createContent(DebugContext debugContext);\n \n     public abstract void writeContent(DebugContext debugContext);\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk2MzQ1MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456963450", "body": "Why not initialize the `fileRecord` field in the constructor?", "bodyText": "Why not initialize the fileRecord field in the constructor?", "bodyHTML": "<p dir=\"auto\">Why not initialize the <code>fileRecord</code> field in the constructor?</p>", "author": "pejovica", "createdAt": "2020-07-19T22:31:14Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Set;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SIGNATURE_C13;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SYMBOL_SECTION_NAME;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.TEXT_SECTION_NAME;\n+\n+public final class CVSymbolSectionImpl extends CVSectionImpl {\n+\n+    private static final int CV_VECTOR_DEFAULT_SIZE = 200;\n+    private static final int CV_STRINGTABLE_DEFAULT_SIZE = 200;\n+\n+    private CVDebugInfo cvDebugInfo;\n+    private CVFileRecord fileRecord;\n+\n+    private ArrayList<CVSymbolRecord> cvRecords = new ArrayList<>(CV_VECTOR_DEFAULT_SIZE);\n+    private CVStringTable stringTable = new CVStringTable(CV_STRINGTABLE_DEFAULT_SIZE);\n+\n+    CVSymbolSectionImpl(CVDebugInfo cvDebugInfo) {\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    @Override\n+    public String getSectionName() {\n+        return CV_SYMBOL_SECTION_NAME;\n+    }\n+\n+    /*\n+     * the CodeView symbol section (\"debug$S\") is actually a list of records containing sub-records\n+     */\n+    @Override\n+    public void createContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext, pos);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() adding records\");\n+        addRecords(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() start\");\n+        /* add header size */\n+        pos += Integer.BYTES;\n+        /* add sum of all record sizes */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            pos = record.computeFullSize(pos);\n+        }\n+        /* create a buffer that holds it all */\n+        byte[] buffer = new byte[pos];\n+        super.setContent(buffer);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() end\");\n+    }\n+\n+    @Override\n+    public void writeContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext, pos);\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() start recordcount=%d\", cvRecords.size());\n+        byte[] buffer = getContent();\n+        /* write section header */\n+        verboseLog(debugContext, \"  [0x%08x] CV_SIGNATURE_C13\", pos);\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, buffer, pos);\n+        /* write all records */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            verboseLog(debugContext, \"  [0x%08x] %s\", pos, record.toString());\n+            record.logContents(debugContext);\n+            pos = record.computeFullContents(buffer, pos);\n+        }\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() end\");\n+    }\n+\n+    private void addRecords(DebugContext debugContext) {\n+        addPrologueRecords();\n+        addFunctionRecords(debugContext);\n+        addTypeRecords();\n+        addFileRecords();\n+        addStringTableRecord();\n+    }\n+\n+    private void addPrologueRecords() {\n+        CVSymbolRecord prologue = new CVSymbolSubsection(cvDebugInfo) {\n+            @Override\n+            void addSubrecords() {\n+                CVSymbolSubrecord.CVObjectNameRecord objectNameRecord = new CVSymbolSubrecord.CVObjectNameRecord(cvDebugInfo);\n+                if (objectNameRecord.isValid()) {\n+                    addRecord(objectNameRecord);\n+                }\n+                addRecord(new CVSymbolSubrecord.CVCompile3Record(cvDebugInfo));\n+                addRecord(new CVSymbolSubrecord.CVEnvBlockRecord(cvDebugInfo));\n+            }\n+        };\n+        addRecord(prologue);\n+    }\n+\n+    private void addFunctionRecords(DebugContext debugContext) {\n+        new CVSymbolRecordBuilder(cvDebugInfo).build(debugContext);\n+    }\n+\n+    private void addTypeRecords() {\n+        /* not yet implemented. S_UDT, etc */\n+        // CVSymbolRecord externs = new CVSymbolSubsection.CVExternalSymbolRecord(cvDebugInfo);\n+        // addRecord(externs);\n+    }\n+\n+    private void addFileRecords() {\n+        addRecord(getFileRecord());\n+    }\n+\n+    CVFileRecord getFileRecord() {\n+        if (fileRecord == null) {\n+            this.fileRecord = new CVFileRecord(cvDebugInfo, stringTable);", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM4ODk0Mg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458388942", "bodyText": "I have made this a local variable.", "author": "stooke", "createdAt": "2020-07-21T21:08:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk2MzQ1MA=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\nindex 4a7bd3d19d9..ecf1a17c870 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n", "chunk": "@@ -110,47 +104,35 @@ public final class CVSymbolSectionImpl extends CVSectionImpl {\n     }\n \n     private void addRecords(DebugContext debugContext) {\n-        addPrologueRecords();\n+        addPrologueRecord();\n         addFunctionRecords(debugContext);\n-        addTypeRecords();\n-        addFileRecords();\n+        addFileRecord();\n         addStringTableRecord();\n     }\n \n-    private void addPrologueRecords() {\n-        CVSymbolRecord prologue = new CVSymbolSubsection(cvDebugInfo) {\n-            @Override\n-            void addSubrecords() {\n-                CVSymbolSubrecord.CVObjectNameRecord objectNameRecord = new CVSymbolSubrecord.CVObjectNameRecord(cvDebugInfo);\n-                if (objectNameRecord.isValid()) {\n-                    addRecord(objectNameRecord);\n-                }\n-                addRecord(new CVSymbolSubrecord.CVCompile3Record(cvDebugInfo));\n-                addRecord(new CVSymbolSubrecord.CVEnvBlockRecord(cvDebugInfo));\n-            }\n-        };\n+    private void addPrologueRecord() {\n+        CVSymbolSubsection prologue = new CVSymbolSubsection(cvDebugInfo);\n+        CVSymbolSubrecord.CVObjectNameRecord objectNameRecord = new CVSymbolSubrecord.CVObjectNameRecord(cvDebugInfo);\n+        if (objectNameRecord.isValid()) {\n+            prologue.addRecord(objectNameRecord);\n+        }\n+        prologue.addRecord(new CVSymbolSubrecord.CVCompile3Record(cvDebugInfo));\n+        prologue.addRecord(new CVSymbolSubrecord.CVEnvBlockRecord(cvDebugInfo));\n         addRecord(prologue);\n     }\n \n     private void addFunctionRecords(DebugContext debugContext) {\n-        new CVSymbolRecordBuilder(cvDebugInfo).build(debugContext);\n-    }\n-\n-    private void addTypeRecords() {\n-        /* not yet implemented. S_UDT, etc */\n-        // CVSymbolRecord externs = new CVSymbolSubsection.CVExternalSymbolRecord(cvDebugInfo);\n-        // addRecord(externs);\n+        /* This will build and add many records for each function. */\n+        new CVSymbolSubsectionBuilder(cvDebugInfo).build(debugContext);\n     }\n \n-    private void addFileRecords() {\n-        addRecord(getFileRecord());\n+    private void addFileRecord() {\n+        /* Files are added to this record during function record building. */\n+        addRecord(fileTableRecord);\n     }\n \n-    CVFileRecord getFileRecord() {\n-        if (fileRecord == null) {\n-            this.fileRecord = new CVFileRecord(cvDebugInfo, stringTable);\n-        }\n-        return fileRecord;\n+    CVFileTableRecord getFileTableRecord() {\n+        return this.fileTableRecord;\n     }\n \n     private void addStringTableRecord() {\n", "next_change": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\nindex ecf1a17c870..694e3bf7c7d 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n", "chunk": "@@ -136,7 +136,7 @@ public final class CVSymbolSectionImpl extends CVSectionImpl {\n     }\n \n     private void addStringTableRecord() {\n-        CVSymbolRecord stringTableRecord = new CVStringTableRecord(cvDebugInfo, stringTable);\n+        CVSymbolRecord stringTableRecord = new CVStringTableRecord(getCvDebugInfo(), stringTable);\n         addRecord(stringTableRecord);\n     }\n \n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk2NDY2Mw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456964663", "body": "Maybe something like `com.oracle.svm.core.util.Utf8.utf8Length`.", "bodyText": "Maybe something like com.oracle.svm.core.util.Utf8.utf8Length.", "bodyHTML": "<p dir=\"auto\">Maybe something like <code>com.oracle.svm.core.util.Utf8.utf8Length</code>.</p>", "author": "pejovica", "createdAt": "2020-07-19T22:44:22Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Set;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SIGNATURE_C13;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SYMBOL_SECTION_NAME;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.TEXT_SECTION_NAME;\n+\n+public final class CVSymbolSectionImpl extends CVSectionImpl {\n+\n+    private static final int CV_VECTOR_DEFAULT_SIZE = 200;\n+    private static final int CV_STRINGTABLE_DEFAULT_SIZE = 200;\n+\n+    private CVDebugInfo cvDebugInfo;\n+    private CVFileRecord fileRecord;\n+\n+    private ArrayList<CVSymbolRecord> cvRecords = new ArrayList<>(CV_VECTOR_DEFAULT_SIZE);\n+    private CVStringTable stringTable = new CVStringTable(CV_STRINGTABLE_DEFAULT_SIZE);\n+\n+    CVSymbolSectionImpl(CVDebugInfo cvDebugInfo) {\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    @Override\n+    public String getSectionName() {\n+        return CV_SYMBOL_SECTION_NAME;\n+    }\n+\n+    /*\n+     * the CodeView symbol section (\"debug$S\") is actually a list of records containing sub-records\n+     */\n+    @Override\n+    public void createContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext, pos);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() adding records\");\n+        addRecords(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() start\");\n+        /* add header size */\n+        pos += Integer.BYTES;\n+        /* add sum of all record sizes */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            pos = record.computeFullSize(pos);\n+        }\n+        /* create a buffer that holds it all */\n+        byte[] buffer = new byte[pos];\n+        super.setContent(buffer);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() end\");\n+    }\n+\n+    @Override\n+    public void writeContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext, pos);\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() start recordcount=%d\", cvRecords.size());\n+        byte[] buffer = getContent();\n+        /* write section header */\n+        verboseLog(debugContext, \"  [0x%08x] CV_SIGNATURE_C13\", pos);\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, buffer, pos);\n+        /* write all records */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            verboseLog(debugContext, \"  [0x%08x] %s\", pos, record.toString());\n+            record.logContents(debugContext);\n+            pos = record.computeFullContents(buffer, pos);\n+        }\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() end\");\n+    }\n+\n+    private void addRecords(DebugContext debugContext) {\n+        addPrologueRecords();\n+        addFunctionRecords(debugContext);\n+        addTypeRecords();\n+        addFileRecords();\n+        addStringTableRecord();\n+    }\n+\n+    private void addPrologueRecords() {\n+        CVSymbolRecord prologue = new CVSymbolSubsection(cvDebugInfo) {\n+            @Override\n+            void addSubrecords() {\n+                CVSymbolSubrecord.CVObjectNameRecord objectNameRecord = new CVSymbolSubrecord.CVObjectNameRecord(cvDebugInfo);\n+                if (objectNameRecord.isValid()) {\n+                    addRecord(objectNameRecord);\n+                }\n+                addRecord(new CVSymbolSubrecord.CVCompile3Record(cvDebugInfo));\n+                addRecord(new CVSymbolSubrecord.CVEnvBlockRecord(cvDebugInfo));\n+            }\n+        };\n+        addRecord(prologue);\n+    }\n+\n+    private void addFunctionRecords(DebugContext debugContext) {\n+        new CVSymbolRecordBuilder(cvDebugInfo).build(debugContext);\n+    }\n+\n+    private void addTypeRecords() {\n+        /* not yet implemented. S_UDT, etc */\n+        // CVSymbolRecord externs = new CVSymbolSubsection.CVExternalSymbolRecord(cvDebugInfo);\n+        // addRecord(externs);\n+    }\n+\n+    private void addFileRecords() {\n+        addRecord(getFileRecord());\n+    }\n+\n+    CVFileRecord getFileRecord() {\n+        if (fileRecord == null) {\n+            this.fileRecord = new CVFileRecord(cvDebugInfo, stringTable);\n+        }\n+        return fileRecord;\n+    }\n+\n+    private void addStringTableRecord() {\n+        CVSymbolRecord stringTableRecord = new CVStringTableRecord(cvDebugInfo, stringTable);\n+        addRecord(stringTableRecord);\n+    }\n+\n+    /* TODO: use ...objectfile.debugentry.StringTable instead */\n+    static final class CVStringTable {\n+        static final class StringTableEntry {\n+            public int offset;\n+            public String text;\n+\n+            StringTableEntry(int offset, String text) {\n+                this.offset = offset;\n+                this.text = text;\n+            }\n+        }\n+\n+        /* using LinkedHashMap so order is maintained when writing string table */\n+        private final HashMap<String, StringTableEntry> strings;\n+        private int currentOffset = 0;\n+\n+        CVStringTable(int startSize) {\n+            strings = new LinkedHashMap<>(startSize);\n+            /* ensure that the empty string has index 0 */\n+            add(\"\");\n+        }\n+\n+        int add(String s) {\n+            StringTableEntry newEntry = new StringTableEntry(currentOffset, s);\n+            StringTableEntry entry = strings.putIfAbsent(s, newEntry);\n+            if (entry == null) {\n+                /*\n+                 * TODO: getting the enecoded size should be made more efficient", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM4NTIyMg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458385222", "bodyText": "done.", "author": "stooke", "createdAt": "2020-07-21T21:01:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk2NDY2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\nindex 4a7bd3d19d9..ecf1a17c870 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n", "chunk": "@@ -184,11 +165,7 @@ public final class CVSymbolSectionImpl extends CVSectionImpl {\n             StringTableEntry newEntry = new StringTableEntry(currentOffset, s);\n             StringTableEntry entry = strings.putIfAbsent(s, newEntry);\n             if (entry == null) {\n-                /*\n-                 * TODO: getting the enecoded size should be made more efficient\n-                 */\n-                int utf8Length = s.getBytes(UTF_8).length;\n-                currentOffset += utf8Length + 1;\n+                currentOffset += Utf8.utf8Length(s) + 1;\n             }\n             return entry == null ? newEntry.offset : entry.offset;\n         }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk2OTkwNg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456969906", "body": "Any chance to switch to `StringTable` on this PR?", "bodyText": "Any chance to switch to StringTable on this PR?", "bodyHTML": "<p dir=\"auto\">Any chance to switch to <code>StringTable</code> on this PR?</p>", "author": "pejovica", "createdAt": "2020-07-19T23:36:43Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Set;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SIGNATURE_C13;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SYMBOL_SECTION_NAME;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.TEXT_SECTION_NAME;\n+\n+public final class CVSymbolSectionImpl extends CVSectionImpl {\n+\n+    private static final int CV_VECTOR_DEFAULT_SIZE = 200;\n+    private static final int CV_STRINGTABLE_DEFAULT_SIZE = 200;\n+\n+    private CVDebugInfo cvDebugInfo;\n+    private CVFileRecord fileRecord;\n+\n+    private ArrayList<CVSymbolRecord> cvRecords = new ArrayList<>(CV_VECTOR_DEFAULT_SIZE);\n+    private CVStringTable stringTable = new CVStringTable(CV_STRINGTABLE_DEFAULT_SIZE);\n+\n+    CVSymbolSectionImpl(CVDebugInfo cvDebugInfo) {\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    @Override\n+    public String getSectionName() {\n+        return CV_SYMBOL_SECTION_NAME;\n+    }\n+\n+    /*\n+     * the CodeView symbol section (\"debug$S\") is actually a list of records containing sub-records\n+     */\n+    @Override\n+    public void createContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext, pos);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() adding records\");\n+        addRecords(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() start\");\n+        /* add header size */\n+        pos += Integer.BYTES;\n+        /* add sum of all record sizes */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            pos = record.computeFullSize(pos);\n+        }\n+        /* create a buffer that holds it all */\n+        byte[] buffer = new byte[pos];\n+        super.setContent(buffer);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() end\");\n+    }\n+\n+    @Override\n+    public void writeContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext, pos);\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() start recordcount=%d\", cvRecords.size());\n+        byte[] buffer = getContent();\n+        /* write section header */\n+        verboseLog(debugContext, \"  [0x%08x] CV_SIGNATURE_C13\", pos);\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, buffer, pos);\n+        /* write all records */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            verboseLog(debugContext, \"  [0x%08x] %s\", pos, record.toString());\n+            record.logContents(debugContext);\n+            pos = record.computeFullContents(buffer, pos);\n+        }\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() end\");\n+    }\n+\n+    private void addRecords(DebugContext debugContext) {\n+        addPrologueRecords();\n+        addFunctionRecords(debugContext);\n+        addTypeRecords();\n+        addFileRecords();\n+        addStringTableRecord();\n+    }\n+\n+    private void addPrologueRecords() {\n+        CVSymbolRecord prologue = new CVSymbolSubsection(cvDebugInfo) {\n+            @Override\n+            void addSubrecords() {\n+                CVSymbolSubrecord.CVObjectNameRecord objectNameRecord = new CVSymbolSubrecord.CVObjectNameRecord(cvDebugInfo);\n+                if (objectNameRecord.isValid()) {\n+                    addRecord(objectNameRecord);\n+                }\n+                addRecord(new CVSymbolSubrecord.CVCompile3Record(cvDebugInfo));\n+                addRecord(new CVSymbolSubrecord.CVEnvBlockRecord(cvDebugInfo));\n+            }\n+        };\n+        addRecord(prologue);\n+    }\n+\n+    private void addFunctionRecords(DebugContext debugContext) {\n+        new CVSymbolRecordBuilder(cvDebugInfo).build(debugContext);\n+    }\n+\n+    private void addTypeRecords() {\n+        /* not yet implemented. S_UDT, etc */\n+        // CVSymbolRecord externs = new CVSymbolSubsection.CVExternalSymbolRecord(cvDebugInfo);\n+        // addRecord(externs);\n+    }\n+\n+    private void addFileRecords() {\n+        addRecord(getFileRecord());\n+    }\n+\n+    CVFileRecord getFileRecord() {\n+        if (fileRecord == null) {\n+            this.fileRecord = new CVFileRecord(cvDebugInfo, stringTable);\n+        }\n+        return fileRecord;\n+    }\n+\n+    private void addStringTableRecord() {\n+        CVSymbolRecord stringTableRecord = new CVStringTableRecord(cvDebugInfo, stringTable);\n+        addRecord(stringTableRecord);\n+    }\n+\n+    /* TODO: use ...objectfile.debugentry.StringTable instead */", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM4NjM3Mw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458386373", "bodyText": "No, the semantics are not the same, especially the way offsets are calculated.  Comment removed.", "author": "stooke", "createdAt": "2020-07-21T21:03:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk2OTkwNg=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\nindex 4a7bd3d19d9..ecf1a17c870 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n", "chunk": "@@ -110,47 +104,35 @@ public final class CVSymbolSectionImpl extends CVSectionImpl {\n     }\n \n     private void addRecords(DebugContext debugContext) {\n-        addPrologueRecords();\n+        addPrologueRecord();\n         addFunctionRecords(debugContext);\n-        addTypeRecords();\n-        addFileRecords();\n+        addFileRecord();\n         addStringTableRecord();\n     }\n \n-    private void addPrologueRecords() {\n-        CVSymbolRecord prologue = new CVSymbolSubsection(cvDebugInfo) {\n-            @Override\n-            void addSubrecords() {\n-                CVSymbolSubrecord.CVObjectNameRecord objectNameRecord = new CVSymbolSubrecord.CVObjectNameRecord(cvDebugInfo);\n-                if (objectNameRecord.isValid()) {\n-                    addRecord(objectNameRecord);\n-                }\n-                addRecord(new CVSymbolSubrecord.CVCompile3Record(cvDebugInfo));\n-                addRecord(new CVSymbolSubrecord.CVEnvBlockRecord(cvDebugInfo));\n-            }\n-        };\n+    private void addPrologueRecord() {\n+        CVSymbolSubsection prologue = new CVSymbolSubsection(cvDebugInfo);\n+        CVSymbolSubrecord.CVObjectNameRecord objectNameRecord = new CVSymbolSubrecord.CVObjectNameRecord(cvDebugInfo);\n+        if (objectNameRecord.isValid()) {\n+            prologue.addRecord(objectNameRecord);\n+        }\n+        prologue.addRecord(new CVSymbolSubrecord.CVCompile3Record(cvDebugInfo));\n+        prologue.addRecord(new CVSymbolSubrecord.CVEnvBlockRecord(cvDebugInfo));\n         addRecord(prologue);\n     }\n \n     private void addFunctionRecords(DebugContext debugContext) {\n-        new CVSymbolRecordBuilder(cvDebugInfo).build(debugContext);\n-    }\n-\n-    private void addTypeRecords() {\n-        /* not yet implemented. S_UDT, etc */\n-        // CVSymbolRecord externs = new CVSymbolSubsection.CVExternalSymbolRecord(cvDebugInfo);\n-        // addRecord(externs);\n+        /* This will build and add many records for each function. */\n+        new CVSymbolSubsectionBuilder(cvDebugInfo).build(debugContext);\n     }\n \n-    private void addFileRecords() {\n-        addRecord(getFileRecord());\n+    private void addFileRecord() {\n+        /* Files are added to this record during function record building. */\n+        addRecord(fileTableRecord);\n     }\n \n-    CVFileRecord getFileRecord() {\n-        if (fileRecord == null) {\n-            this.fileRecord = new CVFileRecord(cvDebugInfo, stringTable);\n-        }\n-        return fileRecord;\n+    CVFileTableRecord getFileTableRecord() {\n+        return this.fileTableRecord;\n     }\n \n     private void addStringTableRecord() {\n", "next_change": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\nindex ecf1a17c870..694e3bf7c7d 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n", "chunk": "@@ -136,7 +136,7 @@ public final class CVSymbolSectionImpl extends CVSectionImpl {\n     }\n \n     private void addStringTableRecord() {\n-        CVSymbolRecord stringTableRecord = new CVStringTableRecord(cvDebugInfo, stringTable);\n+        CVSymbolRecord stringTableRecord = new CVStringTableRecord(getCvDebugInfo(), stringTable);\n         addRecord(stringTableRecord);\n     }\n \n", "next_change": null}]}}, {"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\nindex 4a7bd3d19d9..ecf1a17c870 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n", "chunk": "@@ -158,7 +140,6 @@ public final class CVSymbolSectionImpl extends CVSectionImpl {\n         addRecord(stringTableRecord);\n     }\n \n-    /* TODO: use ...objectfile.debugentry.StringTable instead */\n     static final class CVStringTable {\n         static final class StringTableEntry {\n             public int offset;\n", "next_change": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\nindex ecf1a17c870..694e3bf7c7d 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n", "chunk": "@@ -136,7 +136,7 @@ public final class CVSymbolSectionImpl extends CVSectionImpl {\n     }\n \n     private void addStringTableRecord() {\n-        CVSymbolRecord stringTableRecord = new CVStringTableRecord(cvDebugInfo, stringTable);\n+        CVSymbolRecord stringTableRecord = new CVStringTableRecord(getCvDebugInfo(), stringTable);\n         addRecord(stringTableRecord);\n     }\n \n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk3MTE1Mg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456971152", "body": "Perhaps a better option would be to pass the subrecords using a constructor or simply add them here using `prologue.addRecord`.", "bodyText": "Perhaps a better option would be to pass the subrecords using a constructor or simply add them here using prologue.addRecord.", "bodyHTML": "<p dir=\"auto\">Perhaps a better option would be to pass the subrecords using a constructor or simply add them here using <code>prologue.addRecord</code>.</p>", "author": "pejovica", "createdAt": "2020-07-19T23:48:48Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Set;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SIGNATURE_C13;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SYMBOL_SECTION_NAME;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.TEXT_SECTION_NAME;\n+\n+public final class CVSymbolSectionImpl extends CVSectionImpl {\n+\n+    private static final int CV_VECTOR_DEFAULT_SIZE = 200;\n+    private static final int CV_STRINGTABLE_DEFAULT_SIZE = 200;\n+\n+    private CVDebugInfo cvDebugInfo;\n+    private CVFileRecord fileRecord;\n+\n+    private ArrayList<CVSymbolRecord> cvRecords = new ArrayList<>(CV_VECTOR_DEFAULT_SIZE);\n+    private CVStringTable stringTable = new CVStringTable(CV_STRINGTABLE_DEFAULT_SIZE);\n+\n+    CVSymbolSectionImpl(CVDebugInfo cvDebugInfo) {\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    @Override\n+    public String getSectionName() {\n+        return CV_SYMBOL_SECTION_NAME;\n+    }\n+\n+    /*\n+     * the CodeView symbol section (\"debug$S\") is actually a list of records containing sub-records\n+     */\n+    @Override\n+    public void createContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext, pos);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() adding records\");\n+        addRecords(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() start\");\n+        /* add header size */\n+        pos += Integer.BYTES;\n+        /* add sum of all record sizes */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            pos = record.computeFullSize(pos);\n+        }\n+        /* create a buffer that holds it all */\n+        byte[] buffer = new byte[pos];\n+        super.setContent(buffer);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() end\");\n+    }\n+\n+    @Override\n+    public void writeContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext, pos);\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() start recordcount=%d\", cvRecords.size());\n+        byte[] buffer = getContent();\n+        /* write section header */\n+        verboseLog(debugContext, \"  [0x%08x] CV_SIGNATURE_C13\", pos);\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, buffer, pos);\n+        /* write all records */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            verboseLog(debugContext, \"  [0x%08x] %s\", pos, record.toString());\n+            record.logContents(debugContext);\n+            pos = record.computeFullContents(buffer, pos);\n+        }\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() end\");\n+    }\n+\n+    private void addRecords(DebugContext debugContext) {\n+        addPrologueRecords();\n+        addFunctionRecords(debugContext);\n+        addTypeRecords();\n+        addFileRecords();\n+        addStringTableRecord();\n+    }\n+\n+    private void addPrologueRecords() {\n+        CVSymbolRecord prologue = new CVSymbolSubsection(cvDebugInfo) {\n+            @Override\n+            void addSubrecords() {\n+                CVSymbolSubrecord.CVObjectNameRecord objectNameRecord = new CVSymbolSubrecord.CVObjectNameRecord(cvDebugInfo);\n+                if (objectNameRecord.isValid()) {\n+                    addRecord(objectNameRecord);\n+                }\n+                addRecord(new CVSymbolSubrecord.CVCompile3Record(cvDebugInfo));\n+                addRecord(new CVSymbolSubrecord.CVEnvBlockRecord(cvDebugInfo));\n+            }\n+        };", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc4NjA5OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458786098", "bodyText": "Better in what sense? I have changed this to use addRecord().", "author": "stooke", "createdAt": "2020-07-22T13:21:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk3MTE1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\nindex 4a7bd3d19d9..ecf1a17c870 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n", "chunk": "@@ -110,47 +104,35 @@ public final class CVSymbolSectionImpl extends CVSectionImpl {\n     }\n \n     private void addRecords(DebugContext debugContext) {\n-        addPrologueRecords();\n+        addPrologueRecord();\n         addFunctionRecords(debugContext);\n-        addTypeRecords();\n-        addFileRecords();\n+        addFileRecord();\n         addStringTableRecord();\n     }\n \n-    private void addPrologueRecords() {\n-        CVSymbolRecord prologue = new CVSymbolSubsection(cvDebugInfo) {\n-            @Override\n-            void addSubrecords() {\n-                CVSymbolSubrecord.CVObjectNameRecord objectNameRecord = new CVSymbolSubrecord.CVObjectNameRecord(cvDebugInfo);\n-                if (objectNameRecord.isValid()) {\n-                    addRecord(objectNameRecord);\n-                }\n-                addRecord(new CVSymbolSubrecord.CVCompile3Record(cvDebugInfo));\n-                addRecord(new CVSymbolSubrecord.CVEnvBlockRecord(cvDebugInfo));\n-            }\n-        };\n+    private void addPrologueRecord() {\n+        CVSymbolSubsection prologue = new CVSymbolSubsection(cvDebugInfo);\n+        CVSymbolSubrecord.CVObjectNameRecord objectNameRecord = new CVSymbolSubrecord.CVObjectNameRecord(cvDebugInfo);\n+        if (objectNameRecord.isValid()) {\n+            prologue.addRecord(objectNameRecord);\n+        }\n+        prologue.addRecord(new CVSymbolSubrecord.CVCompile3Record(cvDebugInfo));\n+        prologue.addRecord(new CVSymbolSubrecord.CVEnvBlockRecord(cvDebugInfo));\n         addRecord(prologue);\n     }\n \n     private void addFunctionRecords(DebugContext debugContext) {\n-        new CVSymbolRecordBuilder(cvDebugInfo).build(debugContext);\n-    }\n-\n-    private void addTypeRecords() {\n-        /* not yet implemented. S_UDT, etc */\n-        // CVSymbolRecord externs = new CVSymbolSubsection.CVExternalSymbolRecord(cvDebugInfo);\n-        // addRecord(externs);\n+        /* This will build and add many records for each function. */\n+        new CVSymbolSubsectionBuilder(cvDebugInfo).build(debugContext);\n     }\n \n-    private void addFileRecords() {\n-        addRecord(getFileRecord());\n+    private void addFileRecord() {\n+        /* Files are added to this record during function record building. */\n+        addRecord(fileTableRecord);\n     }\n \n-    CVFileRecord getFileRecord() {\n-        if (fileRecord == null) {\n-            this.fileRecord = new CVFileRecord(cvDebugInfo, stringTable);\n-        }\n-        return fileRecord;\n+    CVFileTableRecord getFileTableRecord() {\n+        return this.fileTableRecord;\n     }\n \n     private void addStringTableRecord() {\n", "next_change": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\nindex ecf1a17c870..694e3bf7c7d 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n", "chunk": "@@ -136,7 +136,7 @@ public final class CVSymbolSectionImpl extends CVSectionImpl {\n     }\n \n     private void addStringTableRecord() {\n-        CVSymbolRecord stringTableRecord = new CVStringTableRecord(cvDebugInfo, stringTable);\n+        CVSymbolRecord stringTableRecord = new CVStringTableRecord(getCvDebugInfo(), stringTable);\n         addRecord(stringTableRecord);\n     }\n \n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzEzMTMwOQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457131309", "body": "I think this should be renamed to something that better reflects the actual behaviour. Maybe `CVSymbolSubsectionBuilder`?", "bodyText": "I think this should be renamed to something that better reflects the actual behaviour. Maybe CVSymbolSubsectionBuilder?", "bodyHTML": "<p dir=\"auto\">I think this should be renamed to something that better reflects the actual behaviour. Maybe <code>CVSymbolSubsectionBuilder</code>?</p>", "author": "pejovica", "createdAt": "2020-07-20T07:30:49Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolRecordBuilder.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.functionNamesHashArgs;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.replaceMainFunctionName;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.emitUnadornedMain;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_NOTYPE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_VOID;\n+\n+final class CVSymbolRecordBuilder {", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgzNjQwMg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458836402", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-07-22T14:30:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzEzMTMwOQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzEzMzc4OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457133788", "body": "What's the purpose of this check?", "bodyText": "What's the purpose of this check?", "bodyHTML": "<p dir=\"auto\">What's the purpose of this check?</p>", "author": "pejovica", "createdAt": "2020-07-20T07:34:35Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolRecordBuilder.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.functionNamesHashArgs;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.replaceMainFunctionName;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.emitUnadornedMain;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_NOTYPE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_VOID;\n+\n+final class CVSymbolRecordBuilder {\n+\n+    private final CVDebugInfo cvDebugInfo;\n+    private final CVSymbolSubsection symbolRecord;\n+    private CVLineRecordBuilder lineRecordBuilder;\n+    private DebugContext debugContext = null;\n+\n+    private boolean noMainFound = true;\n+\n+    CVSymbolRecordBuilder(CVDebugInfo cvDebugInfo) {\n+        this.symbolRecord = new CVSymbolSubsection(cvDebugInfo);\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    /**\n+     * build DEBUG_S_SYMBOLS record from all classEntries. (could probably build one per class or\n+     * one per function)\n+     */\n+    void build(DebugContext theDebugContext) {\n+        this.debugContext = theDebugContext;\n+        this.lineRecordBuilder = new CVLineRecordBuilder(debugContext, cvDebugInfo);\n+        /* look over all classes defined in this module */\n+        for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+            build(classEntry);\n+        }\n+        cvDebugInfo.getCVSymbolSection().addRecord(symbolRecord);\n+    }\n+\n+    /**\n+     * Build all debug info for a classEntry. (does not yet handle member variables)\n+     *\n+     * @param classEntry current class\n+     */\n+    private void build(ClassEntry classEntry) {\n+        String previousMethodName = \"\";\n+        /* loop over all functions defined in this class */\n+        for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+            Range primaryRange = primaryEntry.getPrimary();\n+            if (primaryRange.getFileName() != null) {\n+                /* eliminate ranges with no associated files */\n+                String newMethodName = fixMethodName(primaryRange);\n+                if (!newMethodName.equals(previousMethodName)) {", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQzMjEyMA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r459432120", "bodyText": "Removed.", "author": "stooke", "createdAt": "2020-07-23T13:04:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzEzMzc4OA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE0MjA0Mg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457142042", "body": "I don't quite understand the purpose of this. Why do you handle the main method in such a way?", "bodyText": "I don't quite understand the purpose of this. Why do you handle the main method in such a way?", "bodyHTML": "<p dir=\"auto\">I don't quite understand the purpose of this. Why do you handle the main method in such a way?</p>", "author": "pejovica", "createdAt": "2020-07-20T07:46:55Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolRecordBuilder.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.functionNamesHashArgs;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.replaceMainFunctionName;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.emitUnadornedMain;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_NOTYPE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_VOID;\n+\n+final class CVSymbolRecordBuilder {\n+\n+    private final CVDebugInfo cvDebugInfo;\n+    private final CVSymbolSubsection symbolRecord;\n+    private CVLineRecordBuilder lineRecordBuilder;\n+    private DebugContext debugContext = null;\n+\n+    private boolean noMainFound = true;\n+\n+    CVSymbolRecordBuilder(CVDebugInfo cvDebugInfo) {\n+        this.symbolRecord = new CVSymbolSubsection(cvDebugInfo);\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    /**\n+     * build DEBUG_S_SYMBOLS record from all classEntries. (could probably build one per class or\n+     * one per function)\n+     */\n+    void build(DebugContext theDebugContext) {\n+        this.debugContext = theDebugContext;\n+        this.lineRecordBuilder = new CVLineRecordBuilder(debugContext, cvDebugInfo);\n+        /* look over all classes defined in this module */\n+        for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+            build(classEntry);\n+        }\n+        cvDebugInfo.getCVSymbolSection().addRecord(symbolRecord);\n+    }\n+\n+    /**\n+     * Build all debug info for a classEntry. (does not yet handle member variables)\n+     *\n+     * @param classEntry current class\n+     */\n+    private void build(ClassEntry classEntry) {\n+        String previousMethodName = \"\";\n+        /* loop over all functions defined in this class */\n+        for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+            Range primaryRange = primaryEntry.getPrimary();\n+            if (primaryRange.getFileName() != null) {\n+                /* eliminate ranges with no associated files */\n+                String newMethodName = fixMethodName(primaryRange);\n+                if (!newMethodName.equals(previousMethodName)) {\n+                    previousMethodName = newMethodName;\n+                    build(primaryEntry, newMethodName);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emit records for each function: PROC32 S_FRAMEPROC S_END and line number records. (later:\n+     * type records as required)\n+     *\n+     * @param primaryEntry primary entry for this function\n+     * @param methodName method name alias as it will be seen by the user\n+     */\n+    private void build(PrimaryEntry primaryEntry, String methodName) {\n+        final Range primaryRange = primaryEntry.getPrimary();\n+\n+        /* S_PROC32 add function definition */\n+        int functionTypeIndex = addTypeRecords(primaryEntry);\n+        byte funcFlags = 0;\n+        CVSymbolSubrecord.CVSymbolGProc32Record proc32 = new CVSymbolSubrecord.CVSymbolGProc32Record(cvDebugInfo, methodName, 0, 0, 0, primaryRange.getHi() - primaryRange.getLo(), 0, 0,\n+                        functionTypeIndex, primaryRange.getLo(), (short) 0, funcFlags);\n+        addToSymbolRecord(proc32);\n+\n+        /* S_FRAMEPROC add frame definitions */\n+        int asynceh = 1 << 9; /* aync eh (msc uses 1, clang uses 0) */\n+        int localBP = 1 << 14; /* local base pointer = SP (0=none, 1=sp, 2=bp 3=r13) */\n+        int paramBP = 1 << 16; /* param base pointer = SP */\n+        int frameFlags = asynceh + localBP + paramBP; /* LLVM uses 0x14000; */\n+        addToSymbolRecord(new CVSymbolSubrecord.CVSymbolFrameProcRecord(cvDebugInfo, primaryRange.getHi() - primaryRange.getLo(), frameFlags));\n+\n+        /* TODO: add local variables, and their types */\n+        /* TODO: add block definitions */\n+\n+        /* S_END add end record */\n+        addToSymbolRecord(new CVSymbolSubrecord.CVSymbolEndRecord(cvDebugInfo));\n+        addLineNumberRecords(primaryEntry, methodName);\n+    }\n+\n+    /**\n+     * renames a method name ot something user friendly in the debugger. (does not affect external\n+     * symbols used by linker)\n+     *\n+     * first encountered main function becomes class.main (unless replaceMainFunctionName is\n+     * non-null) if functionNamesHashArgs is true (which it must be for the linker to work properly)\n+     * all other functions become class.function.999 (where 999 is a hash of the arglist)\n+     *\n+     * @param range Range contained in the method of interest\n+     * @return user debugger friendly method name\n+     */\n+    private String fixMethodName(Range range) {\n+        final String methodName;\n+        if (replaceMainFunctionName != null && noMainFound && range.getMethodName().equals(\"main\")) {\n+            noMainFound = false;\n+            methodName = replaceMainFunctionName;\n+        } else if (emitUnadornedMain && noMainFound && range.getMethodName().equals(\"main\")) {\n+            /* TODO: check for static void main(String args[]) instead of just main(...) */\n+            noMainFound = false;\n+            methodName = range.getClassAndMethodName();", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NjA3Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457696077", "bodyText": "An attempt at usability.  Visual Studio doesn't come up with the main Java class when you start it up with a Graal executable, so the user currently has to set a function breakpoint, and I wanted to make that predictable (i.e. \"stop in Myclass.main\").\nIn earlier discussions, it was agreed to revisit function names in general in a later PR.", "author": "stooke", "createdAt": "2020-07-20T21:15:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE0MjA0Mg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE0NTExNA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457145114", "body": "Why have the `functionNamesHashArgs` flag if there is no alternative?", "bodyText": "Why have the functionNamesHashArgs flag if there is no alternative?", "bodyHTML": "<p dir=\"auto\">Why have the <code>functionNamesHashArgs</code> flag if there is no alternative?</p>", "author": "pejovica", "createdAt": "2020-07-20T07:51:13Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolRecordBuilder.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.functionNamesHashArgs;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.replaceMainFunctionName;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.emitUnadornedMain;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_NOTYPE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_VOID;\n+\n+final class CVSymbolRecordBuilder {\n+\n+    private final CVDebugInfo cvDebugInfo;\n+    private final CVSymbolSubsection symbolRecord;\n+    private CVLineRecordBuilder lineRecordBuilder;\n+    private DebugContext debugContext = null;\n+\n+    private boolean noMainFound = true;\n+\n+    CVSymbolRecordBuilder(CVDebugInfo cvDebugInfo) {\n+        this.symbolRecord = new CVSymbolSubsection(cvDebugInfo);\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    /**\n+     * build DEBUG_S_SYMBOLS record from all classEntries. (could probably build one per class or\n+     * one per function)\n+     */\n+    void build(DebugContext theDebugContext) {\n+        this.debugContext = theDebugContext;\n+        this.lineRecordBuilder = new CVLineRecordBuilder(debugContext, cvDebugInfo);\n+        /* look over all classes defined in this module */\n+        for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+            build(classEntry);\n+        }\n+        cvDebugInfo.getCVSymbolSection().addRecord(symbolRecord);\n+    }\n+\n+    /**\n+     * Build all debug info for a classEntry. (does not yet handle member variables)\n+     *\n+     * @param classEntry current class\n+     */\n+    private void build(ClassEntry classEntry) {\n+        String previousMethodName = \"\";\n+        /* loop over all functions defined in this class */\n+        for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+            Range primaryRange = primaryEntry.getPrimary();\n+            if (primaryRange.getFileName() != null) {\n+                /* eliminate ranges with no associated files */\n+                String newMethodName = fixMethodName(primaryRange);\n+                if (!newMethodName.equals(previousMethodName)) {\n+                    previousMethodName = newMethodName;\n+                    build(primaryEntry, newMethodName);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emit records for each function: PROC32 S_FRAMEPROC S_END and line number records. (later:\n+     * type records as required)\n+     *\n+     * @param primaryEntry primary entry for this function\n+     * @param methodName method name alias as it will be seen by the user\n+     */\n+    private void build(PrimaryEntry primaryEntry, String methodName) {\n+        final Range primaryRange = primaryEntry.getPrimary();\n+\n+        /* S_PROC32 add function definition */\n+        int functionTypeIndex = addTypeRecords(primaryEntry);\n+        byte funcFlags = 0;\n+        CVSymbolSubrecord.CVSymbolGProc32Record proc32 = new CVSymbolSubrecord.CVSymbolGProc32Record(cvDebugInfo, methodName, 0, 0, 0, primaryRange.getHi() - primaryRange.getLo(), 0, 0,\n+                        functionTypeIndex, primaryRange.getLo(), (short) 0, funcFlags);\n+        addToSymbolRecord(proc32);\n+\n+        /* S_FRAMEPROC add frame definitions */\n+        int asynceh = 1 << 9; /* aync eh (msc uses 1, clang uses 0) */\n+        int localBP = 1 << 14; /* local base pointer = SP (0=none, 1=sp, 2=bp 3=r13) */\n+        int paramBP = 1 << 16; /* param base pointer = SP */\n+        int frameFlags = asynceh + localBP + paramBP; /* LLVM uses 0x14000; */\n+        addToSymbolRecord(new CVSymbolSubrecord.CVSymbolFrameProcRecord(cvDebugInfo, primaryRange.getHi() - primaryRange.getLo(), frameFlags));\n+\n+        /* TODO: add local variables, and their types */\n+        /* TODO: add block definitions */\n+\n+        /* S_END add end record */\n+        addToSymbolRecord(new CVSymbolSubrecord.CVSymbolEndRecord(cvDebugInfo));\n+        addLineNumberRecords(primaryEntry, methodName);\n+    }\n+\n+    /**\n+     * renames a method name ot something user friendly in the debugger. (does not affect external\n+     * symbols used by linker)\n+     *\n+     * first encountered main function becomes class.main (unless replaceMainFunctionName is\n+     * non-null) if functionNamesHashArgs is true (which it must be for the linker to work properly)\n+     * all other functions become class.function.999 (where 999 is a hash of the arglist)\n+     *\n+     * @param range Range contained in the method of interest\n+     * @return user debugger friendly method name\n+     */\n+    private String fixMethodName(Range range) {\n+        final String methodName;\n+        if (replaceMainFunctionName != null && noMainFound && range.getMethodName().equals(\"main\")) {\n+            noMainFound = false;\n+            methodName = replaceMainFunctionName;\n+        } else if (emitUnadornedMain && noMainFound && range.getMethodName().equals(\"main\")) {\n+            /* TODO: check for static void main(String args[]) instead of just main(...) */\n+            noMainFound = false;\n+            methodName = range.getClassAndMethodName();\n+        } else if (functionNamesHashArgs) {\n+            long hash = range.getParamNames().hashCode() & 0xffffffffL;\n+            methodName = range.getClassAndMethodName() + \".\" + hash;", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NjEzNg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457696136", "bodyText": "I have removed the constant and conditional, and updated the comments.", "author": "stooke", "createdAt": "2020-07-20T21:15:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE0NTExNA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUwNzQyNQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457507425", "body": "I am aware that support for type records is underway, but there is a lot of unused code here. Basically, everything except `CVTypeArglistRecord` and `CVTypeProcedureRecord` is not currently used.", "bodyText": "I am aware that support for type records is underway, but there is a lot of unused code here. Basically, everything except CVTypeArglistRecord and CVTypeProcedureRecord is not currently used.", "bodyHTML": "<p dir=\"auto\">I am aware that support for type records is underway, but there is a lot of unused code here. Basically, everything except <code>CVTypeArglistRecord</code> and <code>CVTypeProcedureRecord</code> is not currently used.</p>", "author": "pejovica", "createdAt": "2020-07-20T15:43:14Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java", "diffHunk": "@@ -0,0 +1,700 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_ARGLIST;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_ARRAY;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_BCLASS;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_BINTERFACE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_BITFIELD;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_CLASS;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_INTERFACE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_MEMBER;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_MODIFIER;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD1;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD2;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD3;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_POINTER;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PROCEDURE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_STRUCTURE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_TYPESERVER2;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_UQUAD;\n+\n+/*\n+ * CV Type Record format (little-endian):\n+ * uint16 length\n+ * uint16 leaf (a.k.a. record type)\n+ * (contents)\n+ */\n+abstract class CVTypeRecord {", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM3MjA0Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458372047", "bodyText": "gone.", "author": "stooke", "createdAt": "2020-07-21T20:35:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUwNzQyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\nindex eccc38900d3..2b8f1de74e9 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\n", "chunk": "@@ -27,25 +27,12 @@\n package com.oracle.objectfile.pecoff.cv;\n \n import java.util.ArrayList;\n-import java.util.Arrays;\n \n import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_ARGLIST;\n-import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_ARRAY;\n-import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_BCLASS;\n-import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_BINTERFACE;\n-import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_BITFIELD;\n-import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_CLASS;\n-import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_INTERFACE;\n-import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_MEMBER;\n-import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_MODIFIER;\n import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD1;\n import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD2;\n import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD3;\n-import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_POINTER;\n import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PROCEDURE;\n-import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_STRUCTURE;\n-import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_TYPESERVER2;\n-import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_UQUAD;\n \n /*\n  * CV Type Record format (little-endian):\n", "next_change": {"commit": "77e3a7479e429a3279d3061496d260e35f21f000", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\nindex 2b8f1de74e9..94dfc59bd8b 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\n", "chunk": "@@ -26,13 +26,41 @@\n \n package com.oracle.objectfile.pecoff.cv;\n \n+import org.graalvm.compiler.debug.GraalError;\n+\n import java.util.ArrayList;\n \n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.CV_CALL_NEAR_C;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.FUNC_IS_CONSTRUCTOR;\n import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_ARGLIST;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_ARRAY;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_BCLASS;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_CLASS;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_FIELDLIST;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_INDEX;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_MEMBER;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_METHOD;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_METHODLIST;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_MFUNCTION;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_ONEMETHOD;\n import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD1;\n import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD2;\n import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD3;\n-import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PROCEDURE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_POINTER;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_STMEMBER;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_STRING_ID;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_UDT_SRC_LINE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.MPROP_ABSTRACT;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.MPROP_COMPGENX;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.MPROP_FINAL_CLASS;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.MPROP_FINAL_METHOD;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.MPROP_IVIRTUAL;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.MPROP_PPP_MASK;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.MPROP_PSEUDO;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.MPROP_PURE_IVIRTUAL;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.MPROP_VSF_MASK;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_NOTYPE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_UINT8;\n \n /*\n  * CV Type Record format (little-endian):\n", "next_change": null}]}}, {"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\nindex eccc38900d3..2b8f1de74e9 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\n", "chunk": "@@ -57,7 +44,7 @@ abstract class CVTypeRecord {\n \n     protected final short type;\n     private int startPosition;\n-    private int sequenceNumber; /* CodeView type records are numbered 1000 on up */\n+    private int sequenceNumber; /* CodeView type records are numbered 1000 on up. */\n \n     CVTypeRecord(short type) {\n         this.type = type;\n", "next_change": {"commit": "77e3a7479e429a3279d3061496d260e35f21f000", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\nindex 2b8f1de74e9..94dfc59bd8b 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\n", "chunk": "@@ -42,6 +70,9 @@ import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PROCEDURE;\n  */\n abstract class CVTypeRecord {\n \n+    static final int FIRST_TYPE_INDEX = 0x1000;\n+    static final int CV_TYPE_RECORD_MAX_SIZE = 0xffff;\n+\n     protected final short type;\n     private int startPosition;\n     private int sequenceNumber; /* CodeView type records are numbered 1000 on up. */\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxMjA3MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457512070", "body": "```suggestion\r\n            return computeContents(null, initialPos);\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return initialPos + Integer.BYTES + Byte.BYTES + Byte.BYTES + Short.BYTES + Integer.BYTES;\n          \n          \n            \n                        return computeContents(null, initialPos);", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-k\">return</span> <span class=\"x x-first\">initialPos </span><span class=\"pl-k x\">+</span><span class=\"x\"> </span><span class=\"pl-smi x\">Integer</span><span class=\"pl-c1\"><span class=\"pl-k x\">.</span><span class=\"x\">BYTES</span></span><span class=\"x\"> </span><span class=\"pl-k x\">+</span><span class=\"x\"> </span><span class=\"pl-smi x\">Byte</span><span class=\"pl-c1\"><span class=\"pl-k x\">.</span><span class=\"x\">BYTES</span></span><span class=\"x\"> </span><span class=\"pl-k x\">+</span><span class=\"x\"> </span><span class=\"pl-smi x\">Byte</span><span class=\"pl-c1\"><span class=\"pl-k x\">.</span><span class=\"x\">BYTES</span></span><span class=\"x\"> </span><span class=\"pl-k x\">+</span><span class=\"x\"> </span><span class=\"pl-smi x\">Short</span><span class=\"pl-c1\"><span class=\"pl-k x\">.</span><span class=\"x\">BYTES</span></span><span class=\"x\"> </span><span class=\"pl-k x\">+</span><span class=\"x\"> </span><span class=\"pl-smi x\">Integer</span><span class=\"pl-c1\"><span class=\"pl-k x\">.</span><span class=\"x x-last\">BYTES</span></span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            <span class=\"pl-k\">return</span> <span class=\"x x-first\">computeContents(</span><span class=\"pl-c1 x\">null</span><span class=\"x x-last\">, initialPos)</span>;</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pejovica", "createdAt": "2020-07-20T15:49:03Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java", "diffHunk": "@@ -0,0 +1,700 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_ARGLIST;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_ARRAY;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_BCLASS;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_BINTERFACE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_BITFIELD;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_CLASS;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_INTERFACE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_MEMBER;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_MODIFIER;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD1;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD2;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD3;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_POINTER;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PROCEDURE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_STRUCTURE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_TYPESERVER2;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_UQUAD;\n+\n+/*\n+ * CV Type Record format (little-endian):\n+ * uint16 length\n+ * uint16 leaf (a.k.a. record type)\n+ * (contents)\n+ */\n+abstract class CVTypeRecord {\n+\n+    protected final short type;\n+    private int startPosition;\n+    private int sequenceNumber; /* CodeView type records are numbered 1000 on up */\n+\n+    CVTypeRecord(short type) {\n+        this.type = type;\n+        this.startPosition = -1;\n+        this.sequenceNumber = -1;\n+    }\n+\n+    int getSequenceNumber() {\n+        return sequenceNumber;\n+    }\n+\n+    void setSequenceNumber(int sequenceNumber) {\n+        this.sequenceNumber = sequenceNumber;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.startPosition = initialPos;\n+        int pos = initialPos + Short.BYTES * 2; /* save room for length and leaf type */\n+        pos = computeSize(pos);\n+        pos = alignPadded4(null, pos);\n+        return pos;\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int lenPos = initialPos; /* save position of length short */\n+        int pos = initialPos + Short.BYTES; /* save room for length short */\n+        pos = CVUtil.putShort(type, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        /* length does not include record length (2 bytes)) but does include end padding */\n+        pos = alignPadded4(buffer, pos);\n+        int length = (short) (pos - lenPos - Short.BYTES);\n+        CVUtil.putShort((short) length, buffer, lenPos);\n+        return pos;\n+    }\n+\n+    protected abstract int computeSize(int initialPos);\n+\n+    protected abstract int computeContents(byte[] buffer, int initialPos);\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVTypeRecord seq=0x%04x type=0x%04x pos=0x%04x \", sequenceNumber, type, startPosition);\n+    }\n+\n+    private static int alignPadded4(byte[] buffer, int originalpos) {\n+        int pos = originalpos;\n+        int align = pos & 3;\n+        if (align == 1) {\n+            byte[] p3 = {LF_PAD3, LF_PAD2, LF_PAD1};\n+            pos = CVUtil.putBytes(p3, buffer, pos);\n+        } else if (align == 2) {\n+            pos = CVUtil.putByte(LF_PAD2, buffer, pos);\n+            pos = CVUtil.putByte(LF_PAD1, buffer, pos);\n+        } else if (align == 3) {\n+            pos = CVUtil.putByte(LF_PAD1, buffer, pos);\n+        }\n+        return pos;\n+    }\n+\n+    static final class CVTypeModifierRecord extends CVTypeRecord {\n+\n+        int originalLeaf = -1;\n+        boolean addConst = false;\n+        boolean addVolatile = false;\n+        boolean addUnaligned = false;\n+\n+        CVTypeModifierRecord(int originalLeaf) {\n+            super(LF_MODIFIER);\n+            this.originalLeaf = originalLeaf;\n+        }\n+\n+        CVTypeModifierRecord(CVTypeRecord originalLeaf) {\n+            super(LF_MODIFIER);\n+            this.originalLeaf = originalLeaf.getSequenceNumber();\n+        }\n+\n+        CVTypeModifierRecord addConst() {\n+            this.addConst = true;\n+            return this;\n+        }\n+\n+        CVTypeModifierRecord addVolatile() {\n+            this.addVolatile = true;\n+            return this;\n+        }\n+\n+        CVTypeModifierRecord addUnaligned() {\n+            this.addUnaligned = true;\n+            return this;\n+        }\n+\n+        private short computeFlags() {\n+            return (short) ((addConst ? 0x01 : 0x00) | (addVolatile ? 0x02 : 0x00) | (addUnaligned ? 0x04 : 0));\n+        }\n+\n+        @Override\n+        public int computeSize(int initialPos) {\n+            return initialPos + Integer.BYTES + Short.BYTES;\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(originalLeaf, buffer, initialPos);\n+            pos = CVUtil.putShort(computeFlags(), buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String s = String.format(\"LF_MODIFIER 0x%04x\", getSequenceNumber());\n+            if (addConst) {\n+                s += \" const\";\n+            }\n+            if (addVolatile) {\n+                s += \" volatile\";\n+            }\n+            if (addUnaligned) {\n+                s += \"unaligned\";\n+            }\n+            s += String.format(\" 0x%04x\", originalLeaf);\n+            return s;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = type;\n+            h = 31 * h + originalLeaf;\n+            h = 31 * h + computeFlags();\n+            return h;\n+        }\n+    }\n+\n+    static final class CVTypePointerRecord extends CVTypeRecord {\n+\n+        int originalLeaf = -1;\n+        int kind = 0;\n+        int mode = 0;\n+        int modifiers = 0;\n+        int size = 4;\n+        int flags = 0;\n+\n+        /*-\n+        int kind      =  attributes & 0x00001f;\n+        int mode      = (attributes & 0x0000e0) >> 5;\n+        int modifiers = (attributes & 0x001f00) >> 8;\n+        int size      = (attributes & 0x07e000) >> 13;\n+        int flags     = (attributes & 0x380000) >> 19;\n+        out.printf(\"LF_POINTER len=%d leaf=0x%04x refType=0x%06x attrib=0x%06x\\n\", len, leaf, referentType, attributes);\n+        out.printf(\"           kind=%d mode=%d modifiers=%d size=%d flags=%d\\n\", kind, mode, modifiers, size, flags);\n+        */\n+\n+        CVTypePointerRecord(int originalLeaf) {\n+            super(LF_POINTER);\n+            this.originalLeaf = originalLeaf;\n+        }\n+\n+        CVTypePointerRecord(CVTypeRecord originalLeaf) {\n+            super(LF_POINTER);\n+            this.originalLeaf = originalLeaf.getSequenceNumber();\n+        }\n+\n+        private int computeAttributes() {\n+            return kind | (mode << 5) | (modifiers << 8) | (size << 13) | (flags << 19);\n+        }\n+\n+        @Override\n+        public int computeSize(int initialPos) {\n+            return initialPos + Integer.BYTES * 2;\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(originalLeaf, buffer, initialPos);\n+            pos = CVUtil.putInt(computeAttributes(), buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LF_POINTER 0x%04x * 0x%04x\", getSequenceNumber(), originalLeaf);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = type;\n+            h = 31 * h + originalLeaf;\n+            h = 31 * h + computeAttributes();\n+            return h;\n+        }\n+    }\n+\n+    static final class CVTypeProcedureRecord extends CVTypeRecord {\n+\n+        int returnType = -1;\n+        CVTypeArglistRecord argList = null;\n+\n+        CVTypeProcedureRecord() {\n+            super(LF_PROCEDURE);\n+        }\n+\n+        public CVTypeProcedureRecord returnType(int leaf) {\n+            this.returnType = leaf;\n+            return this;\n+        }\n+\n+        public CVTypeProcedureRecord returnType(CVTypeRecord leaf) {\n+            this.returnType = leaf.getSequenceNumber();\n+            return this;\n+        }\n+\n+        CVTypeProcedureRecord argList(CVTypeArglistRecord leaf) {\n+            this.argList = leaf;\n+            return this;\n+        }\n+\n+        @Override\n+        public int computeSize(int initialPos) {\n+            return initialPos + Integer.BYTES + Byte.BYTES + Byte.BYTES + Short.BYTES + Integer.BYTES;", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgxMDkxMw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458810913", "bodyText": "This code no longer exists.", "author": "stooke", "createdAt": "2020-07-22T13:55:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxMjA3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4Njg1OQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460186859", "bodyText": "No, it's still here. \ud83d\ude09", "author": "pejovica", "createdAt": "2020-07-24T17:20:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxMjA3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI0NDExMQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460244111", "bodyText": "So it is.  But it's so much more efficient (and prone to coding errors)!  Changed..", "author": "stooke", "createdAt": "2020-07-24T19:21:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxMjA3MA=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\nindex eccc38900d3..2b8f1de74e9 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\n", "chunk": "@@ -275,14 +143,14 @@ abstract class CVTypeRecord {\n \n         @Override\n         public int computeSize(int initialPos) {\n-            return initialPos + Integer.BYTES + Byte.BYTES + Byte.BYTES + Short.BYTES + Integer.BYTES;\n+            return computeContents(null, initialPos);\n         }\n \n         @Override\n         public int computeContents(byte[] buffer, int initialPos) {\n             int pos = CVUtil.putInt(returnType, buffer, initialPos);\n-            pos = CVUtil.putByte((byte) 0, buffer, pos); // callType\n-            pos = CVUtil.putByte((byte) 0, buffer, pos); // funcAttr\n+            pos = CVUtil.putByte((byte) 0, buffer, pos); /* callType */\n+            pos = CVUtil.putByte((byte) 0, buffer, pos); /* funcAttr */\n             pos = CVUtil.putShort((short) argList.getSize(), buffer, pos);\n             pos = CVUtil.putInt(argList.getSequenceNumber(), buffer, pos);\n             return pos;\n", "next_change": {"commit": "77e3a7479e429a3279d3061496d260e35f21f000", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\nindex 2b8f1de74e9..94dfc59bd8b 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\n", "chunk": "@@ -117,56 +155,195 @@ abstract class CVTypeRecord {\n         return pos;\n     }\n \n-    static final class CVTypeProcedureRecord extends CVTypeRecord {\n+    static final class CVTypePrimitive extends CVTypeRecord {\n \n-        int returnType = -1;\n-        CVTypeArglistRecord argList = null;\n+        private final int length;\n \n-        CVTypeProcedureRecord() {\n-            super(LF_PROCEDURE);\n+        CVTypePrimitive(short cvtype, int length) {\n+            super(cvtype);\n+            assert cvtype < FIRST_TYPE_INDEX;\n+            this.length = length;\n+            setSequenceNumber(cvtype);\n         }\n \n-        public CVTypeProcedureRecord returnType(int leaf) {\n-            this.returnType = leaf;\n-            return this;\n+        @Override\n+        public int computeSize(int initialPos) {\n+            throw GraalError.shouldNotReachHere();\n         }\n \n-        public CVTypeProcedureRecord returnType(CVTypeRecord leaf) {\n-            this.returnType = leaf.getSequenceNumber();\n-            return this;\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            throw GraalError.shouldNotReachHere();\n         }\n \n-        CVTypeProcedureRecord argList(CVTypeArglistRecord leaf) {\n-            this.argList = leaf;\n-            return this;\n+        @Override\n+        public int hashCode() {\n+            throw GraalError.shouldNotReachHere();\n         }\n \n         @Override\n-        public int computeSize(int initialPos) {\n-            return computeContents(null, initialPos);\n+        public String toString() {\n+            return String.format(\"PRIMITIVE 0x%04x (len=%d)\", getSequenceNumber(), length);\n+        }\n+    }\n+\n+    static final class CVTypePointerRecord extends CVTypeRecord {\n+\n+        static final int KIND_64 = 0x0000c;\n+        static final int SIZE_8 = 8 << 13;\n+\n+        /* Standard 64-bit absolute pointer type. */\n+        static final int NORMAL_64 = KIND_64 | SIZE_8;\n+\n+        private final int pointsTo;\n+\n+        /*-\n+         * int kind      =  attributes & 0x00001f;\n+         * int mode      = (attributes & 0x0000e0) >> 5;\n+         * int modifiers = (attributes & 0x001f00) >> 8;\n+         * int size      = (attributes & 0x07e000) >> 13;\n+         * int flags     = (attributes & 0x380000) >> 19;\n+         */\n+        private final int attrs;\n+\n+        CVTypePointerRecord(int pointTo, int attrs) {\n+            super(LF_POINTER);\n+            this.pointsTo = pointTo;\n+            this.attrs = attrs;\n+        }\n+\n+        @SuppressWarnings(\"unused\")\n+        int getPointsTo() {\n+            return pointsTo;\n         }\n \n         @Override\n         public int computeContents(byte[] buffer, int initialPos) {\n-            int pos = CVUtil.putInt(returnType, buffer, initialPos);\n-            pos = CVUtil.putByte((byte) 0, buffer, pos); /* callType */\n-            pos = CVUtil.putByte((byte) 0, buffer, pos); /* funcAttr */\n-            pos = CVUtil.putShort((short) argList.getSize(), buffer, pos);\n-            pos = CVUtil.putInt(argList.getSequenceNumber(), buffer, pos);\n-            return pos;\n+            int pos = CVUtil.putInt(pointsTo, buffer, initialPos);\n+            return CVUtil.putInt(attrs, buffer, pos);\n         }\n \n+        static String[] ptrType = {\"near16\", \"far16\", \"huge\", \"base-seg\", \"base-val\", \"base-segval\", \"base-addr\", \"base-segaddr\", \"base-type\", \"base-self\", \"near32\", \"far32\", \"64\"};\n+        static String[] modeStrs = {\"normal\", \"lvalref\", \"datamem\", \"memfunc\", \"rvalref\"};\n+\n         @Override\n         public String toString() {\n-            return String.format(\"LF_PROCEDURE 0x%04x ret=0x%04x arg=0x%04x \", getSequenceNumber(), returnType, argList.getSequenceNumber());\n+            int kind = attrs & 0x00001f;\n+            int mode = (attrs & 0x0000e0) >> 5;\n+            int flags1 = (attrs & 0x001f00) >> 8;\n+            int size = (attrs & 0x07e000) >> 13;\n+            int flags2 = (attrs & 0x380000) >> 19;\n+            StringBuilder sb = new StringBuilder();\n+            sb.append((flags1 & 1) != 0 ? \"flat32\" : \"\");\n+            sb.append((flags1 & 2) != 0 ? \" volatile\" : \"\");\n+            sb.append((flags1 & 4) != 0 ? \" const\" : \"\");\n+            sb.append((flags1 & 8) != 0 ? \" unaligned\" : \"\");\n+            sb.append((flags1 & 16) != 0 ? \" restricted\" : \"\");\n+            return String.format(\"LF_POINTER 0x%04x attrs=0x%x(kind=%d(%s) mode=%d(%s) flags1=0x%x(%s) size=%d flags2=0x%x) pointTo=0x%04x\", getSequenceNumber(), attrs, kind, ptrType[kind], mode,\n+                            modeStrs[mode], flags1, sb, size, flags2, pointsTo);\n         }\n \n         @Override\n         public int hashCode() {\n             int h = type;\n-            h = 31 * h + returnType;\n-            h = 31 * h + argList.hashCode();\n-            /* callType and funcAttr are always zero so do not add them to the hash */\n+            h = 31 * h + pointsTo;\n+            h = 31 * h + attrs;\n+            return h;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (!super.equals(obj)) {\n+                return false;\n+            }\n+            CVTypePointerRecord other = (CVTypePointerRecord) obj;\n+            return this.pointsTo == other.pointsTo && this.attrs == other.attrs;\n+        }\n+    }\n+\n+    static class CVUdtTypeLineRecord extends CVTypeRecord {\n+\n+        final int typeIndex;\n+        int fileIndex;\n+        int line;\n+\n+        CVUdtTypeLineRecord(int typeIndex, int fileIndex, int line) {\n+            this(LF_UDT_SRC_LINE, typeIndex, fileIndex, line);\n+        }\n+\n+        CVUdtTypeLineRecord(short t, int typeIndex, int fileIndex, int line) {\n+            super(t);\n+            this.typeIndex = typeIndex;\n+            this.fileIndex = fileIndex;\n+            this.line = line;\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(typeIndex, buffer, initialPos);\n+            pos = CVUtil.putInt(fileIndex, buffer, pos);\n+            return CVUtil.putInt(line, buffer, pos);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LF_UDT_SRC_LINE 0x%04x typeIdx=0x%x fileIdx=0x%x line=%d\", getSequenceNumber(), typeIndex, fileIndex, line);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = type;\n+            h = 31 * h + typeIndex;\n+            h = 31 * h + fileIndex;\n+            h = 31 * h + line;\n+            return h;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (!super.equals(obj)) {\n+                return false;\n+            }\n+            CVUdtTypeLineRecord other = (CVUdtTypeLineRecord) obj;\n+            /*\n+             * NB: if the record has the same type but different file or line, it's probably an\n+             * error.\n+             */\n+            return this.typeIndex == other.typeIndex && this.fileIndex == other.fileIndex && this.line == other.line;\n+        }\n+    }\n+\n+    static final class CVTypeStringIdRecord extends CVTypeRecord {\n+\n+        String string;\n+        int substringListIndex;\n+\n+        CVTypeStringIdRecord(int substringListIndex, String string) {\n+            super(LF_STRING_ID);\n+            this.substringListIndex = substringListIndex;\n+            this.string = string;\n+        }\n+\n+        CVTypeStringIdRecord(String string) {\n+            this(T_NOTYPE, string);\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(substringListIndex, buffer, initialPos);\n+            return CVUtil.putUTF8StringBytes(string, buffer, pos);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LF_STRING_ID 0x%04x substringListIdx=0x%x %s\", getSequenceNumber(), substringListIndex, string);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = type;\n+            h = 31 * h + substringListIndex;\n+            h = 31 * h + string.hashCode();\n             return h;\n         }\n \n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxMjU4NQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457512585", "body": "A leftover?", "bodyText": "A leftover?", "bodyHTML": "<p dir=\"auto\">A leftover?</p>", "author": "pejovica", "createdAt": "2020-07-20T15:49:42Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java", "diffHunk": "@@ -0,0 +1,700 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_ARGLIST;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_ARRAY;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_BCLASS;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_BINTERFACE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_BITFIELD;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_CLASS;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_INTERFACE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_MEMBER;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_MODIFIER;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD1;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD2;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD3;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_POINTER;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PROCEDURE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_STRUCTURE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_TYPESERVER2;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_UQUAD;\n+\n+/*\n+ * CV Type Record format (little-endian):\n+ * uint16 length\n+ * uint16 leaf (a.k.a. record type)\n+ * (contents)\n+ */\n+abstract class CVTypeRecord {\n+\n+    protected final short type;\n+    private int startPosition;\n+    private int sequenceNumber; /* CodeView type records are numbered 1000 on up */\n+\n+    CVTypeRecord(short type) {\n+        this.type = type;\n+        this.startPosition = -1;\n+        this.sequenceNumber = -1;\n+    }\n+\n+    int getSequenceNumber() {\n+        return sequenceNumber;\n+    }\n+\n+    void setSequenceNumber(int sequenceNumber) {\n+        this.sequenceNumber = sequenceNumber;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.startPosition = initialPos;\n+        int pos = initialPos + Short.BYTES * 2; /* save room for length and leaf type */\n+        pos = computeSize(pos);\n+        pos = alignPadded4(null, pos);\n+        return pos;\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int lenPos = initialPos; /* save position of length short */\n+        int pos = initialPos + Short.BYTES; /* save room for length short */\n+        pos = CVUtil.putShort(type, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        /* length does not include record length (2 bytes)) but does include end padding */\n+        pos = alignPadded4(buffer, pos);\n+        int length = (short) (pos - lenPos - Short.BYTES);\n+        CVUtil.putShort((short) length, buffer, lenPos);\n+        return pos;\n+    }\n+\n+    protected abstract int computeSize(int initialPos);\n+\n+    protected abstract int computeContents(byte[] buffer, int initialPos);\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVTypeRecord seq=0x%04x type=0x%04x pos=0x%04x \", sequenceNumber, type, startPosition);\n+    }\n+\n+    private static int alignPadded4(byte[] buffer, int originalpos) {\n+        int pos = originalpos;\n+        int align = pos & 3;\n+        if (align == 1) {\n+            byte[] p3 = {LF_PAD3, LF_PAD2, LF_PAD1};\n+            pos = CVUtil.putBytes(p3, buffer, pos);\n+        } else if (align == 2) {\n+            pos = CVUtil.putByte(LF_PAD2, buffer, pos);\n+            pos = CVUtil.putByte(LF_PAD1, buffer, pos);\n+        } else if (align == 3) {\n+            pos = CVUtil.putByte(LF_PAD1, buffer, pos);\n+        }\n+        return pos;\n+    }\n+\n+    static final class CVTypeModifierRecord extends CVTypeRecord {\n+\n+        int originalLeaf = -1;\n+        boolean addConst = false;\n+        boolean addVolatile = false;\n+        boolean addUnaligned = false;\n+\n+        CVTypeModifierRecord(int originalLeaf) {\n+            super(LF_MODIFIER);\n+            this.originalLeaf = originalLeaf;\n+        }\n+\n+        CVTypeModifierRecord(CVTypeRecord originalLeaf) {\n+            super(LF_MODIFIER);\n+            this.originalLeaf = originalLeaf.getSequenceNumber();\n+        }\n+\n+        CVTypeModifierRecord addConst() {\n+            this.addConst = true;\n+            return this;\n+        }\n+\n+        CVTypeModifierRecord addVolatile() {\n+            this.addVolatile = true;\n+            return this;\n+        }\n+\n+        CVTypeModifierRecord addUnaligned() {\n+            this.addUnaligned = true;\n+            return this;\n+        }\n+\n+        private short computeFlags() {\n+            return (short) ((addConst ? 0x01 : 0x00) | (addVolatile ? 0x02 : 0x00) | (addUnaligned ? 0x04 : 0));\n+        }\n+\n+        @Override\n+        public int computeSize(int initialPos) {\n+            return initialPos + Integer.BYTES + Short.BYTES;\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(originalLeaf, buffer, initialPos);\n+            pos = CVUtil.putShort(computeFlags(), buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String s = String.format(\"LF_MODIFIER 0x%04x\", getSequenceNumber());\n+            if (addConst) {\n+                s += \" const\";\n+            }\n+            if (addVolatile) {\n+                s += \" volatile\";\n+            }\n+            if (addUnaligned) {\n+                s += \"unaligned\";\n+            }\n+            s += String.format(\" 0x%04x\", originalLeaf);\n+            return s;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = type;\n+            h = 31 * h + originalLeaf;\n+            h = 31 * h + computeFlags();\n+            return h;\n+        }\n+    }\n+\n+    static final class CVTypePointerRecord extends CVTypeRecord {\n+\n+        int originalLeaf = -1;\n+        int kind = 0;\n+        int mode = 0;\n+        int modifiers = 0;\n+        int size = 4;\n+        int flags = 0;\n+\n+        /*-\n+        int kind      =  attributes & 0x00001f;\n+        int mode      = (attributes & 0x0000e0) >> 5;\n+        int modifiers = (attributes & 0x001f00) >> 8;\n+        int size      = (attributes & 0x07e000) >> 13;\n+        int flags     = (attributes & 0x380000) >> 19;\n+        out.printf(\"LF_POINTER len=%d leaf=0x%04x refType=0x%06x attrib=0x%06x\\n\", len, leaf, referentType, attributes);\n+        out.printf(\"           kind=%d mode=%d modifiers=%d size=%d flags=%d\\n\", kind, mode, modifiers, size, flags);\n+        */\n+\n+        CVTypePointerRecord(int originalLeaf) {\n+            super(LF_POINTER);\n+            this.originalLeaf = originalLeaf;\n+        }\n+\n+        CVTypePointerRecord(CVTypeRecord originalLeaf) {\n+            super(LF_POINTER);\n+            this.originalLeaf = originalLeaf.getSequenceNumber();\n+        }\n+\n+        private int computeAttributes() {\n+            return kind | (mode << 5) | (modifiers << 8) | (size << 13) | (flags << 19);\n+        }\n+\n+        @Override\n+        public int computeSize(int initialPos) {\n+            return initialPos + Integer.BYTES * 2;\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(originalLeaf, buffer, initialPos);\n+            pos = CVUtil.putInt(computeAttributes(), buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LF_POINTER 0x%04x * 0x%04x\", getSequenceNumber(), originalLeaf);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = type;\n+            h = 31 * h + originalLeaf;\n+            h = 31 * h + computeAttributes();\n+            return h;\n+        }\n+    }\n+\n+    static final class CVTypeProcedureRecord extends CVTypeRecord {\n+\n+        int returnType = -1;\n+        CVTypeArglistRecord argList = null;\n+\n+        CVTypeProcedureRecord() {\n+            super(LF_PROCEDURE);\n+        }\n+\n+        public CVTypeProcedureRecord returnType(int leaf) {\n+            this.returnType = leaf;\n+            return this;\n+        }\n+\n+        public CVTypeProcedureRecord returnType(CVTypeRecord leaf) {\n+            this.returnType = leaf.getSequenceNumber();\n+            return this;\n+        }\n+\n+        CVTypeProcedureRecord argList(CVTypeArglistRecord leaf) {\n+            this.argList = leaf;\n+            return this;\n+        }\n+\n+        @Override\n+        public int computeSize(int initialPos) {\n+            return initialPos + Integer.BYTES + Byte.BYTES + Byte.BYTES + Short.BYTES + Integer.BYTES;\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(returnType, buffer, initialPos);\n+            pos = CVUtil.putByte((byte) 0, buffer, pos); // callType\n+            pos = CVUtil.putByte((byte) 0, buffer, pos); // funcAttr\n+            pos = CVUtil.putShort((short) argList.getSize(), buffer, pos);\n+            pos = CVUtil.putInt(argList.getSequenceNumber(), buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LF_PROCEDURE 0x%04x ret=0x%04x arg=0x%04x \", getSequenceNumber(), returnType, argList.getSequenceNumber());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = type;\n+            h = 31 * h + returnType;\n+            h = 31 * h + argList.hashCode();\n+            // h = 31 * h + // callType + funcAttr", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc4OTg1MQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458789851", "bodyText": "comment changed,  the line is commented out because funcAddr and callType are currently always zero.", "author": "stooke", "createdAt": "2020-07-22T13:26:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxMjU4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\nindex eccc38900d3..2b8f1de74e9 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\n", "chunk": "@@ -298,9 +166,18 @@ abstract class CVTypeRecord {\n             int h = type;\n             h = 31 * h + returnType;\n             h = 31 * h + argList.hashCode();\n-            // h = 31 * h + // callType + funcAttr\n+            /* callType and funcAttr are always zero so do not add them to the hash */\n             return h;\n         }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (!super.equals(obj)) {\n+                return false;\n+            }\n+            CVTypeProcedureRecord other = (CVTypeProcedureRecord) obj;\n+            return this.returnType == other.returnType && this.argList == other.argList;\n+        }\n     }\n \n     static final class CVTypeArglistRecord extends CVTypeRecord {\n", "next_change": {"commit": "77e3a7479e429a3279d3061496d260e35f21f000", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\nindex 2b8f1de74e9..94dfc59bd8b 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\n", "chunk": "@@ -175,22 +352,21 @@ abstract class CVTypeRecord {\n             if (!super.equals(obj)) {\n                 return false;\n             }\n-            CVTypeProcedureRecord other = (CVTypeProcedureRecord) obj;\n-            return this.returnType == other.returnType && this.argList == other.argList;\n+            CVTypeStringIdRecord other = (CVTypeStringIdRecord) obj;\n+            return this.string.equals(other.string) && this.substringListIndex == other.substringListIndex;\n         }\n     }\n \n     static final class CVTypeArglistRecord extends CVTypeRecord {\n \n-        ArrayList<Integer> args = new ArrayList<>();\n+        private final ArrayList<Integer> args = new ArrayList<>();\n \n         CVTypeArglistRecord() {\n             super(LF_ARGLIST);\n         }\n \n-        CVTypeArglistRecord add(int argType) {\n+        void add(int argType) {\n             args.add(argType);\n-            return this;\n         }\n \n         @Override\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU5ODY4Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457598687", "body": "There seems to be potential for some sharing with `CVSymbolSectionImpl`, e.g., `createContent`, `writeContent`, and even `getDependencies` are all very similar.", "bodyText": "There seems to be potential for some sharing with CVSymbolSectionImpl, e.g., createContent, writeContent, and even getDependencies are all very similar.", "bodyHTML": "<p dir=\"auto\">There seems to be potential for some sharing with <code>CVSymbolSectionImpl</code>, e.g., <code>createContent</code>, <code>writeContent</code>, and even <code>getDependencies</code> are all very similar.</p>", "author": "pejovica", "createdAt": "2020-07-20T18:10:00Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SIGNATURE_C13;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SYMBOL_SECTION_NAME;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_TYPE_SECTION_NAME;\n+\n+public final class CVTypeSectionImpl extends CVSectionImpl {", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgxMTc3Mw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458811773", "bodyText": "Similar but not identical,  Structured almost identically.  I think actual code sharing would make the structure more confusing. I'm happy to revisit this after the type section is fully implemented.", "author": "stooke", "createdAt": "2020-07-22T13:56:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU5ODY4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\nindex 66268aa567a..ac22c2be305 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\n", "chunk": "@@ -33,9 +33,7 @@ import com.oracle.objectfile.ObjectFile;\n import com.oracle.objectfile.pecoff.PECoffObjectFile;\n import org.graalvm.compiler.debug.DebugContext;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n+import java.util.LinkedHashMap;\n import java.util.Map;\n import java.util.Set;\n \n", "next_change": {"commit": "77e3a7479e429a3279d3061496d260e35f21f000", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\nindex ac22c2be305..696b9434c9a 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\n", "chunk": "@@ -30,6 +30,8 @@ import com.oracle.objectfile.BuildDependency;\n import com.oracle.objectfile.LayoutDecision;\n import com.oracle.objectfile.LayoutDecisionMap;\n import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debugentry.CompiledMethodEntry;\n+import com.oracle.objectfile.debugentry.TypeEntry;\n import com.oracle.objectfile.pecoff.PECoffObjectFile;\n import org.graalvm.compiler.debug.DebugContext;\n \n", "next_change": null}]}}, {"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\nindex 66268aa567a..ac22c2be305 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\n", "chunk": "@@ -47,8 +45,11 @@ public final class CVTypeSectionImpl extends CVSectionImpl {\n \n     private static final int CV_RECORD_INITIAL_CAPACITY = 200;\n \n-    private ArrayList<CVTypeRecord> cvRecords = new ArrayList<>(CV_RECORD_INITIAL_CAPACITY);\n-    private CVTypeRecordBuilder builder = new CVTypeRecordBuilder(this);\n+    /* CodeView 4 type records below 1000 are pre-defined. */\n+    private int sequenceCounter = 0x1000;\n+\n+    /* A sequential map of type records, starting at 1000 */\n+    private Map<CVTypeRecord, CVTypeRecord> typeMap = new LinkedHashMap<>(CV_RECORD_INITIAL_CAPACITY);\n \n     CVTypeSectionImpl() {\n     }\n", "next_change": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\nindex ac22c2be305..89a552626bf 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\n", "chunk": "@@ -49,9 +49,10 @@ public final class CVTypeSectionImpl extends CVSectionImpl {\n     private int sequenceCounter = 0x1000;\n \n     /* A sequential map of type records, starting at 1000 */\n-    private Map<CVTypeRecord, CVTypeRecord> typeMap = new LinkedHashMap<>(CV_RECORD_INITIAL_CAPACITY);\n+    private final Map<CVTypeRecord, CVTypeRecord> typeMap = new LinkedHashMap<>(CV_RECORD_INITIAL_CAPACITY);\n \n-    CVTypeSectionImpl() {\n+    CVTypeSectionImpl(CVDebugInfo cvDebugInfo) {\n+        super(cvDebugInfo);\n     }\n \n     @Override\n", "next_change": {"commit": "77e3a7479e429a3279d3061496d260e35f21f000", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\nindex 89a552626bf..696b9434c9a 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\n", "chunk": "@@ -49,10 +51,17 @@ public final class CVTypeSectionImpl extends CVSectionImpl {\n     private int sequenceCounter = 0x1000;\n \n     /* A sequential map of type records, starting at 1000 */\n+    /* This map is used to implement deduplication. */\n     private final Map<CVTypeRecord, CVTypeRecord> typeMap = new LinkedHashMap<>(CV_RECORD_INITIAL_CAPACITY);\n \n+    private final CVTypeSectionBuilder builder;\n+\n     CVTypeSectionImpl(CVDebugInfo cvDebugInfo) {\n+        /*\n+         * At this point, there is no debugContext in debugInfo, so no logging should be attempted.\n+         */\n         super(cvDebugInfo);\n+        builder = new CVTypeSectionBuilder(this);\n     }\n \n     @Override\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYwMDkxOQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457600919", "body": "I don\u2019t think it makes sense to keep this method at the moment.", "bodyText": "I don\u2019t think it makes sense to keep this method at the moment.", "bodyHTML": "<p dir=\"auto\">I don\u2019t think it makes sense to keep this method at the moment.</p>", "author": "pejovica", "createdAt": "2020-07-20T18:13:59Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SIGNATURE_C13;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SYMBOL_SECTION_NAME;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_TYPE_SECTION_NAME;\n+\n+public final class CVTypeSectionImpl extends CVSectionImpl {\n+\n+    private static final int CV_RECORD_INITIAL_CAPACITY = 200;\n+\n+    private ArrayList<CVTypeRecord> cvRecords = new ArrayList<>(CV_RECORD_INITIAL_CAPACITY);\n+    private CVTypeRecordBuilder builder = new CVTypeRecordBuilder(this);\n+\n+    CVTypeSectionImpl() {\n+    }\n+\n+    @Override\n+    public String getSectionName() {\n+        return CV_TYPE_SECTION_NAME;\n+    }\n+\n+    @Override\n+    public void createContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext, pos);\n+        log(debugContext, \"CVTypeSectionImpl.createContent() adding records\");\n+        addRecords();\n+        log(debugContext, \"CVTypeSectionImpl.createContent() start\");\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, null, pos);\n+        for (CVTypeRecord record : cvRecords) {\n+            pos = record.computeFullSize(pos);\n+        }\n+        byte[] buffer = new byte[pos];\n+        super.setContent(buffer);\n+        log(debugContext, \"CVTypeSectionImpl.createContent() end\");\n+    }\n+\n+    @Override\n+    public void writeContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext, pos);\n+        log(debugContext, \"CVTypeSectionImpl.writeContent() start\");\n+        byte[] buffer = getContent();\n+        verboseLog(debugContext, \"  [0x%08x] CV_SIGNATURE_C13\", pos);\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, buffer, pos);\n+        for (CVTypeRecord record : cvRecords) {\n+            verboseLog(debugContext, \"  [0x%08x] 0x%06x %s\", pos, record.getSequenceNumber(), record.toString());\n+            pos = record.computeFullContents(buffer, pos);\n+        }\n+        verboseLog(debugContext, \"CVTypeSectionImpl.writeContent() end\");\n+    }\n+\n+    public List<CVTypeRecord> getRecords() {\n+        return Collections.unmodifiableList(cvRecords);\n+    }\n+\n+    /**\n+     * Add a record (that has a unique hashcode) to the type section.\n+     *\n+     * @param r the record to add\n+     */\n+    void addUniqueRecord(CVTypeRecord r) {\n+        cvRecords.add(r);\n+    }\n+\n+    /**\n+     * Add a record to the type section if it has a unique hash.\n+     *\n+     * @param <T>\n+     * @param newRecord record to add\n+     * @return newRecord if the hash is unique, or the existing record already in the type table\n+     */\n+    <T extends CVTypeRecord> T addRecord(T newRecord) {\n+        // verboseLog(debugContext, \"adding type record: %s hash=%d\\n\", newRecord,\n+        // newRecord.hashCode());\n+        T actual = builder.addOrReference(newRecord);\n+        return actual;\n+    }\n+\n+    /**\n+     * Add definitions for all classes.\n+     */\n+    private void addClassRecords() {", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODg0Nzk2Ng==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458847966", "bodyText": "Gone.", "author": "stooke", "createdAt": "2020-07-22T14:45:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYwMDkxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\nindex 66268aa567a..ac22c2be305 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\n", "chunk": "@@ -77,64 +78,45 @@ public final class CVTypeSectionImpl extends CVSectionImpl {\n     @Override\n     public void writeContent(DebugContext debugContext) {\n         int pos = 0;\n-        enableLog(debugContext, pos);\n+        enableLog(debugContext);\n         log(debugContext, \"CVTypeSectionImpl.writeContent() start\");\n         byte[] buffer = getContent();\n         verboseLog(debugContext, \"  [0x%08x] CV_SIGNATURE_C13\", pos);\n         pos = CVUtil.putInt(CV_SIGNATURE_C13, buffer, pos);\n-        for (CVTypeRecord record : cvRecords) {\n+        for (CVTypeRecord record : typeMap.values()) {\n             verboseLog(debugContext, \"  [0x%08x] 0x%06x %s\", pos, record.getSequenceNumber(), record.toString());\n             pos = record.computeFullContents(buffer, pos);\n         }\n         verboseLog(debugContext, \"CVTypeSectionImpl.writeContent() end\");\n     }\n \n-    public List<CVTypeRecord> getRecords() {\n-        return Collections.unmodifiableList(cvRecords);\n-    }\n-\n     /**\n-     * Add a record (that has a unique hashcode) to the type section.\n-     *\n-     * @param r the record to add\n+     * Add all relevant type records to the type section.\n      */\n-    void addUniqueRecord(CVTypeRecord r) {\n-        cvRecords.add(r);\n+    private void addRecords() {\n+        /* if an external PDB file is generated, add CVTypeServer2Record */\n+        /* for each class, add all members, types, etc */\n     }\n \n     /**\n-     * Add a record to the type section if it has a unique hash.\n+     * Return either the caller-created instance or a matching existing instance. Every entry in\n+     * typeMap is a T, because it is ONLY this function which inserts entries (of type T).\n      *\n-     * @param <T>\n-     * @param newRecord record to add\n-     * @return newRecord if the hash is unique, or the existing record already in the type table\n+     * @param <T> type of new record\n+     * @param newRecord record to add if an existing record with same hash hasn't already been added\n+     * @return the record (if previously unseen) or old record\n      */\n-    <T extends CVTypeRecord> T addRecord(T newRecord) {\n-        // verboseLog(debugContext, \"adding type record: %s hash=%d\\n\", newRecord,\n-        // newRecord.hashCode());\n-        T actual = builder.addOrReference(newRecord);\n-        return actual;\n-    }\n-\n-    /**\n-     * Add definitions for all classes.\n-     */\n-    private void addClassRecords() {\n-        /* we may have done this already when emiting globals in debug$S section */\n-        // for (DebugInfoBase.ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n-        // TODO - emit all members, all types, etc\n-        // }\n-    }\n-\n-    /**\n-     * Add all relevant type records to the type section. The symbol section code may have already\n-     * added many type records.\n-     */\n-    private void addRecords() {\n-        // final CVTypeRecord r0 = addRecord(new\n-        // CVTypeRecord.CVTypeServer2Record(\"0123456789abcdef\".getBytes(UTF_8), 1,\n-        // \"c:\\\\tmp\\\\graal-8\\\\vc100.pdb\"));\n-        addClassRecords();\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends CVTypeRecord> T addOrReference(T newRecord) {\n+        final T record;\n+        if (typeMap.containsKey(newRecord)) {\n+            record = (T) typeMap.get(newRecord);\n+        } else {\n+            newRecord.setSequenceNumber(sequenceCounter++);\n+            typeMap.put(newRecord, newRecord);\n+            record = newRecord;\n+        }\n+        return record;\n     }\n \n     @Override\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYwNDc2Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457604767", "body": "A debugging leftover?", "bodyText": "A debugging leftover?", "bodyHTML": "<p dir=\"auto\">A debugging leftover?</p>", "author": "pejovica", "createdAt": "2020-07-20T18:21:14Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SIGNATURE_C13;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SYMBOL_SECTION_NAME;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_TYPE_SECTION_NAME;\n+\n+public final class CVTypeSectionImpl extends CVSectionImpl {\n+\n+    private static final int CV_RECORD_INITIAL_CAPACITY = 200;\n+\n+    private ArrayList<CVTypeRecord> cvRecords = new ArrayList<>(CV_RECORD_INITIAL_CAPACITY);\n+    private CVTypeRecordBuilder builder = new CVTypeRecordBuilder(this);\n+\n+    CVTypeSectionImpl() {\n+    }\n+\n+    @Override\n+    public String getSectionName() {\n+        return CV_TYPE_SECTION_NAME;\n+    }\n+\n+    @Override\n+    public void createContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext, pos);\n+        log(debugContext, \"CVTypeSectionImpl.createContent() adding records\");\n+        addRecords();\n+        log(debugContext, \"CVTypeSectionImpl.createContent() start\");\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, null, pos);\n+        for (CVTypeRecord record : cvRecords) {\n+            pos = record.computeFullSize(pos);\n+        }\n+        byte[] buffer = new byte[pos];\n+        super.setContent(buffer);\n+        log(debugContext, \"CVTypeSectionImpl.createContent() end\");\n+    }\n+\n+    @Override\n+    public void writeContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext, pos);\n+        log(debugContext, \"CVTypeSectionImpl.writeContent() start\");\n+        byte[] buffer = getContent();\n+        verboseLog(debugContext, \"  [0x%08x] CV_SIGNATURE_C13\", pos);\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, buffer, pos);\n+        for (CVTypeRecord record : cvRecords) {\n+            verboseLog(debugContext, \"  [0x%08x] 0x%06x %s\", pos, record.getSequenceNumber(), record.toString());\n+            pos = record.computeFullContents(buffer, pos);\n+        }\n+        verboseLog(debugContext, \"CVTypeSectionImpl.writeContent() end\");\n+    }\n+\n+    public List<CVTypeRecord> getRecords() {\n+        return Collections.unmodifiableList(cvRecords);\n+    }\n+\n+    /**\n+     * Add a record (that has a unique hashcode) to the type section.\n+     *\n+     * @param r the record to add\n+     */\n+    void addUniqueRecord(CVTypeRecord r) {\n+        cvRecords.add(r);\n+    }\n+\n+    /**\n+     * Add a record to the type section if it has a unique hash.\n+     *\n+     * @param <T>\n+     * @param newRecord record to add\n+     * @return newRecord if the hash is unique, or the existing record already in the type table\n+     */\n+    <T extends CVTypeRecord> T addRecord(T newRecord) {\n+        // verboseLog(debugContext, \"adding type record: %s hash=%d\\n\", newRecord,\n+        // newRecord.hashCode());", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgxMjY4Ng==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458812686", "bodyText": "Gone.", "author": "stooke", "createdAt": "2020-07-22T13:58:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYwNDc2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\nindex 66268aa567a..ac22c2be305 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\n", "chunk": "@@ -77,64 +78,45 @@ public final class CVTypeSectionImpl extends CVSectionImpl {\n     @Override\n     public void writeContent(DebugContext debugContext) {\n         int pos = 0;\n-        enableLog(debugContext, pos);\n+        enableLog(debugContext);\n         log(debugContext, \"CVTypeSectionImpl.writeContent() start\");\n         byte[] buffer = getContent();\n         verboseLog(debugContext, \"  [0x%08x] CV_SIGNATURE_C13\", pos);\n         pos = CVUtil.putInt(CV_SIGNATURE_C13, buffer, pos);\n-        for (CVTypeRecord record : cvRecords) {\n+        for (CVTypeRecord record : typeMap.values()) {\n             verboseLog(debugContext, \"  [0x%08x] 0x%06x %s\", pos, record.getSequenceNumber(), record.toString());\n             pos = record.computeFullContents(buffer, pos);\n         }\n         verboseLog(debugContext, \"CVTypeSectionImpl.writeContent() end\");\n     }\n \n-    public List<CVTypeRecord> getRecords() {\n-        return Collections.unmodifiableList(cvRecords);\n-    }\n-\n     /**\n-     * Add a record (that has a unique hashcode) to the type section.\n-     *\n-     * @param r the record to add\n+     * Add all relevant type records to the type section.\n      */\n-    void addUniqueRecord(CVTypeRecord r) {\n-        cvRecords.add(r);\n+    private void addRecords() {\n+        /* if an external PDB file is generated, add CVTypeServer2Record */\n+        /* for each class, add all members, types, etc */\n     }\n \n     /**\n-     * Add a record to the type section if it has a unique hash.\n+     * Return either the caller-created instance or a matching existing instance. Every entry in\n+     * typeMap is a T, because it is ONLY this function which inserts entries (of type T).\n      *\n-     * @param <T>\n-     * @param newRecord record to add\n-     * @return newRecord if the hash is unique, or the existing record already in the type table\n+     * @param <T> type of new record\n+     * @param newRecord record to add if an existing record with same hash hasn't already been added\n+     * @return the record (if previously unseen) or old record\n      */\n-    <T extends CVTypeRecord> T addRecord(T newRecord) {\n-        // verboseLog(debugContext, \"adding type record: %s hash=%d\\n\", newRecord,\n-        // newRecord.hashCode());\n-        T actual = builder.addOrReference(newRecord);\n-        return actual;\n-    }\n-\n-    /**\n-     * Add definitions for all classes.\n-     */\n-    private void addClassRecords() {\n-        /* we may have done this already when emiting globals in debug$S section */\n-        // for (DebugInfoBase.ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n-        // TODO - emit all members, all types, etc\n-        // }\n-    }\n-\n-    /**\n-     * Add all relevant type records to the type section. The symbol section code may have already\n-     * added many type records.\n-     */\n-    private void addRecords() {\n-        // final CVTypeRecord r0 = addRecord(new\n-        // CVTypeRecord.CVTypeServer2Record(\"0123456789abcdef\".getBytes(UTF_8), 1,\n-        // \"c:\\\\tmp\\\\graal-8\\\\vc100.pdb\"));\n-        addClassRecords();\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends CVTypeRecord> T addOrReference(T newRecord) {\n+        final T record;\n+        if (typeMap.containsKey(newRecord)) {\n+            record = (T) typeMap.get(newRecord);\n+        } else {\n+            newRecord.setSequenceNumber(sequenceCounter++);\n+            typeMap.put(newRecord, newRecord);\n+            record = newRecord;\n+        }\n+        return record;\n     }\n \n     @Override\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYzOTg5Mw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457639893", "body": "This builder seems a bit redundant. Would it make sense to move the handling of `sequenceCounter` into `CVTypeSectionImpl`?", "bodyText": "This builder seems a bit redundant. Would it make sense to move the handling of sequenceCounter into CVTypeSectionImpl?", "bodyHTML": "<p dir=\"auto\">This builder seems a bit redundant. Would it make sense to move the handling of <code>sequenceCounter</code> into <code>CVTypeSectionImpl</code>?</p>", "author": "pejovica", "createdAt": "2020-07-20T19:25:24Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecordBuilder.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+class CVTypeRecordBuilder {", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODg2NzA4MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458867080", "bodyText": "I wanted to keep the knowledge of the typeid processing separate from the knowledge of the type section overall structure.  But I have combined the two again.", "author": "stooke", "createdAt": "2020-07-22T15:11:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYzOTg5Mw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk4MjExMQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457982111", "body": "```suggestion\r\n            pos = CVUtil.putInt(computeSize(0), buffer, pos);\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        /* If HAS_COLUMNS is true, this formula is incorrect. */\n          \n          \n            \n                        assert !HAS_COLUMNS;\n          \n          \n            \n                        pos = CVUtil.putInt(Integer.BYTES * 3 + lineEntries.size() * LineEntry.LINE_ENTRY_SIZE, buffer, pos);\n          \n          \n            \n                        pos = CVUtil.putInt(computeSize(0), buffer, pos);", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-c\"><span class=\"pl-c\">/*</span> If HAS_COLUMNS is true, this formula is incorrect. <span class=\"pl-c\">*/</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-k\">assert</span> <span class=\"pl-k\">!</span><span class=\"pl-c1\">HAS_COLUMNS</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            pos <span class=\"pl-k\">=</span> <span class=\"pl-smi\">CVUtil</span><span class=\"pl-k\">.</span>putInt(<span class=\"pl-smi\">Integer</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>BYTES</span> <span class=\"pl-k\">*</span> <span class=\"pl-c1\">3</span> <span class=\"pl-k\">+</span> lineEntries<span class=\"pl-k\">.</span>size() <span class=\"pl-k\">*</span> <span class=\"pl-smi\">LineEntry</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>LINE_ENTRY_SIZE</span>, buffer, pos);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            pos <span class=\"pl-k\">=</span> <span class=\"pl-smi\">CVUtil</span><span class=\"pl-k\">.</span>putInt(computeSize(<span class=\"pl-c1\">0</span>), buffer, pos);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pejovica", "createdAt": "2020-07-21T10:02:28Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.ObjectFile;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A line record (DEBUG_S_LINES) consists of a list of (file block record + subrecords).\n+ * Graal will generate one CVLineRecord per function.\n+ */\n+final class CVLineRecord extends CVSymbolRecord {\n+\n+    private static final boolean HAS_COLUMNS = false;\n+\n+    private static final int DEFAULT_LINE_BLOCK_COUNT = 100;\n+    private static final int DEFAULT_LINE_ENTRY_COUNT = 100;\n+\n+    private static final short CB_HAS_COLUMNS_FLAG = 0x01;\n+    private static final short CB_HAS_NO_COLUMNS_FLAG = 0x00;\n+\n+    private String symbolName;\n+    @SuppressWarnings(\"unused\") private PrimaryEntry primaryEntry;\n+    private ArrayList<FileBlock> fileBlocks = new ArrayList<>(DEFAULT_LINE_BLOCK_COUNT);\n+\n+    /*\n+     * FileBlock is a section of contiguous code in a compilation unit, associated with a single\n+     * source file. If a function includes inlined code, that code needs its own FileBlock,\n+     * surrounded by FileBlocks describing the enclosing source file A FileBlock consists of a list\n+     * of LineEntries.\n+     */\n+    private static class FileBlock {\n+\n+        /* Fileblock header: fileId (4 bytes) lineEntry count (4 bytes) tablesize (4 bytes) */\n+        static final int FILE_BLOCK_HEADER_SIZE = Integer.BYTES * 3;\n+\n+        ArrayList<LineEntry> lineEntries = new ArrayList<>(DEFAULT_LINE_ENTRY_COUNT);\n+        int highAddr = 0;\n+        @SuppressWarnings(\"unused\") FileEntry file;\n+        int fileId;\n+\n+        FileBlock(FileEntry file, int fileId) {\n+            this.file = file;\n+            this.fileId = fileId;\n+        }\n+\n+        void addEntry(LineEntry le) {\n+            highAddr = Math.max(highAddr, le.addr);\n+            lineEntries.add(le);\n+        }\n+\n+        int computeContents(byte[] buffer, int initialPos) {\n+            int pos = initialPos;\n+            pos = CVUtil.putInt(fileId, buffer, pos);\n+            pos = CVUtil.putInt(lineEntries.size(), buffer, pos);\n+            /* If HAS_COLUMNS is true, this formula is incorrect. */\n+            assert !HAS_COLUMNS;\n+            pos = CVUtil.putInt(Integer.BYTES * 3 + lineEntries.size() * LineEntry.LINE_ENTRY_SIZE, buffer, pos);", "originalCommit": "85f3abd5ff140b0079a0d35a9f00f6973b60f499", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgyMTU0MQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458821541", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-07-22T14:10:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk4MjExMQ=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\nindex 9a21d248e97..090f30fe4ac 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n", "chunk": "@@ -61,28 +127,25 @@ final class CVLineRecord extends CVSymbolRecord {\n         /* Fileblock header: fileId (4 bytes) lineEntry count (4 bytes) tablesize (4 bytes) */\n         static final int FILE_BLOCK_HEADER_SIZE = Integer.BYTES * 3;\n \n-        ArrayList<LineEntry> lineEntries = new ArrayList<>(DEFAULT_LINE_ENTRY_COUNT);\n-        int highAddr = 0;\n-        @SuppressWarnings(\"unused\") FileEntry file;\n-        int fileId;\n+        private ArrayList<LineEntry> lineEntries = new ArrayList<>(DEFAULT_LINE_ENTRY_COUNT);\n+        private int fileId;\n \n-        FileBlock(FileEntry file, int fileId) {\n-            this.file = file;\n+        FileBlock(int fileId) {\n             this.fileId = fileId;\n         }\n \n         void addEntry(LineEntry le) {\n-            highAddr = Math.max(highAddr, le.addr);\n             lineEntries.add(le);\n         }\n \n         int computeContents(byte[] buffer, int initialPos) {\n+            if (buffer == null) {\n+                return computeSize(initialPos);\n+            }\n             int pos = initialPos;\n             pos = CVUtil.putInt(fileId, buffer, pos);\n             pos = CVUtil.putInt(lineEntries.size(), buffer, pos);\n-            /* If HAS_COLUMNS is true, this formula is incorrect. */\n-            assert !HAS_COLUMNS;\n-            pos = CVUtil.putInt(Integer.BYTES * 3 + lineEntries.size() * LineEntry.LINE_ENTRY_SIZE, buffer, pos);\n+            pos = CVUtil.putInt(computeSize(0), buffer, pos);\n             for (LineEntry lineEntry : lineEntries) {\n                 pos = lineEntry.computeContents(buffer, pos);\n             }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk4NTY5NQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457985695", "body": "Can this field be removed?", "bodyText": "Can this field be removed?", "bodyHTML": "<p dir=\"auto\">Can this field be removed?</p>", "author": "pejovica", "createdAt": "2020-07-21T10:09:19Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.ObjectFile;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A line record (DEBUG_S_LINES) consists of a list of (file block record + subrecords).\n+ * Graal will generate one CVLineRecord per function.\n+ */\n+final class CVLineRecord extends CVSymbolRecord {\n+\n+    private static final boolean HAS_COLUMNS = false;\n+\n+    private static final int DEFAULT_LINE_BLOCK_COUNT = 100;\n+    private static final int DEFAULT_LINE_ENTRY_COUNT = 100;\n+\n+    private static final short CB_HAS_COLUMNS_FLAG = 0x01;\n+    private static final short CB_HAS_NO_COLUMNS_FLAG = 0x00;\n+\n+    private String symbolName;\n+    @SuppressWarnings(\"unused\") private PrimaryEntry primaryEntry;", "originalCommit": "85f3abd5ff140b0079a0d35a9f00f6973b60f499", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgxNDgyMw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458814823", "bodyText": "Gone.", "author": "stooke", "createdAt": "2020-07-22T14:01:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk4NTY5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\nindex 9a21d248e97..090f30fe4ac 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n", "chunk": "@@ -38,22 +36,90 @@ import java.util.ArrayList;\n  */\n final class CVLineRecord extends CVSymbolRecord {\n \n-    private static final boolean HAS_COLUMNS = false;\n+    /* Header: addr (4 bytes):section (2 bytes) flags (2 bytes) chunck length (4 bytes). */\n+    private static final int LINE_RECORD_HEADER_SIZE = Integer.BYTES + Short.BYTES * 2 + Integer.BYTES;\n \n     private static final int DEFAULT_LINE_BLOCK_COUNT = 100;\n     private static final int DEFAULT_LINE_ENTRY_COUNT = 100;\n \n-    private static final short CB_HAS_COLUMNS_FLAG = 0x01;\n+    /* Has columns flag = 0x80 - not supported. */\n     private static final short CB_HAS_NO_COLUMNS_FLAG = 0x00;\n \n     private String symbolName;\n-    @SuppressWarnings(\"unused\") private PrimaryEntry primaryEntry;\n     private ArrayList<FileBlock> fileBlocks = new ArrayList<>(DEFAULT_LINE_BLOCK_COUNT);\n \n+    CVLineRecord(CVDebugInfo cvDebugInfo, String symbolName) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_LINES);\n+        this.symbolName = symbolName;\n+    }\n+\n+    void addNewFile(int fileId) {\n+        fileBlocks.add(new FileBlock(fileId));\n+    }\n+\n+    void addNewLine(int addr, int line) {\n+        fileBlocks.get(fileBlocks.size() - 1).addEntry(new LineEntry(addr, line));\n+    }\n+\n+    int getCurrentFileId() {\n+        assert !fileBlocks.isEmpty();\n+        return fileBlocks.get(fileBlocks.size() - 1).fileId;\n+    }\n+\n+    @Override\n+    protected int computeSize(int initialPos) {\n+        return computeContents(null, initialPos);\n+    }\n+\n+    @Override\n+    protected int computeContents(byte[] buffer, int initialPos) {\n+        /* Line record header. */\n+        int pos = computeHeader(buffer, initialPos);\n+        /* All blocks. */\n+        for (FileBlock fileBlock : fileBlocks) {\n+            pos = fileBlock.computeContents(buffer, pos);\n+        }\n+        return pos;\n+    }\n+\n+    private int computeHeader(byte[] buffer, int initialPos) {\n+\n+        if (buffer == null) {\n+            return initialPos + LINE_RECORD_HEADER_SIZE;\n+        }\n+\n+        assert symbolName != null;\n+        int pos = initialPos;\n+\n+        /* Emit addr:section relocation records. */\n+        cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, symbolName, false, 1L);\n+        pos = CVUtil.putInt(0, buffer, pos);\n+        cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, symbolName, false, 1L);\n+        pos = CVUtil.putShort((short) 0, buffer, pos);\n+\n+        /* Emit flags. */\n+        pos = CVUtil.putShort(CB_HAS_NO_COLUMNS_FLAG, buffer, pos);\n+\n+        /* Length of this chunk in object file (= highAddr since it's zero based. */\n+        assert !fileBlocks.isEmpty();\n+        int length = fileBlocks.get(fileBlocks.size() - 1).getHighAddr();\n+        pos = CVUtil.putInt(length, buffer, pos);\n+        return pos;\n+    }\n+\n+    boolean isEmpty() {\n+        return fileBlocks.isEmpty();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVLineRecord(type=0x%04x pos=0x%05x size=0x%d)\", type, recordStartPosition, fileBlocks.size());\n+    }\n+\n     /*\n      * FileBlock is a section of contiguous code in a compilation unit, associated with a single\n      * source file. If a function includes inlined code, that code needs its own FileBlock,\n-     * surrounded by FileBlocks describing the enclosing source file A FileBlock consists of a list\n+     * surrounded by FileBlocks describing the enclosing source file. A FileBlock consists of a list\n      * of LineEntries.\n      */\n     private static class FileBlock {\n", "next_change": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\nindex 090f30fe4ac..27d7935f6d0 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n", "chunk": "@@ -127,8 +122,8 @@ final class CVLineRecord extends CVSymbolRecord {\n         /* Fileblock header: fileId (4 bytes) lineEntry count (4 bytes) tablesize (4 bytes) */\n         static final int FILE_BLOCK_HEADER_SIZE = Integer.BYTES * 3;\n \n-        private ArrayList<LineEntry> lineEntries = new ArrayList<>(DEFAULT_LINE_ENTRY_COUNT);\n-        private int fileId;\n+        private final ArrayList<LineEntry> lineEntries = new ArrayList<>(DEFAULT_LINE_ENTRY_COUNT);\n+        private final int fileId;\n \n         FileBlock(int fileId) {\n             this.fileId = fileId;\n", "next_change": {"commit": "6d209109480ecec08ebf137288371d4c56064ba0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\nindex 27d7935f6d0..868d68f2bd5 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n", "chunk": "@@ -124,13 +124,19 @@ final class CVLineRecord extends CVSymbolRecord {\n \n         private final ArrayList<LineEntry> lineEntries = new ArrayList<>(DEFAULT_LINE_ENTRY_COUNT);\n         private final int fileId;\n+        private int previousLine;\n \n         FileBlock(int fileId) {\n             this.fileId = fileId;\n+            this.previousLine = -2;\n         }\n \n         void addEntry(LineEntry le) {\n-            lineEntries.add(le);\n+            /* Only add an entry if the line number has changed. */\n+            if (le.lineAndFlags != previousLine) {\n+                lineEntries.add(le);\n+                previousLine = le.lineAndFlags;\n+            }\n         }\n \n         int computeContents(byte[] buffer, int initialPos) {\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk4NjE1Mg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457986152", "body": "And this field, can it be removed?", "bodyText": "And this field, can it be removed?", "bodyHTML": "<p dir=\"auto\">And this field, can it be removed?</p>", "author": "pejovica", "createdAt": "2020-07-21T10:10:09Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.ObjectFile;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A line record (DEBUG_S_LINES) consists of a list of (file block record + subrecords).\n+ * Graal will generate one CVLineRecord per function.\n+ */\n+final class CVLineRecord extends CVSymbolRecord {\n+\n+    private static final boolean HAS_COLUMNS = false;\n+\n+    private static final int DEFAULT_LINE_BLOCK_COUNT = 100;\n+    private static final int DEFAULT_LINE_ENTRY_COUNT = 100;\n+\n+    private static final short CB_HAS_COLUMNS_FLAG = 0x01;\n+    private static final short CB_HAS_NO_COLUMNS_FLAG = 0x00;\n+\n+    private String symbolName;\n+    @SuppressWarnings(\"unused\") private PrimaryEntry primaryEntry;\n+    private ArrayList<FileBlock> fileBlocks = new ArrayList<>(DEFAULT_LINE_BLOCK_COUNT);\n+\n+    /*\n+     * FileBlock is a section of contiguous code in a compilation unit, associated with a single\n+     * source file. If a function includes inlined code, that code needs its own FileBlock,\n+     * surrounded by FileBlocks describing the enclosing source file A FileBlock consists of a list\n+     * of LineEntries.\n+     */\n+    private static class FileBlock {\n+\n+        /* Fileblock header: fileId (4 bytes) lineEntry count (4 bytes) tablesize (4 bytes) */\n+        static final int FILE_BLOCK_HEADER_SIZE = Integer.BYTES * 3;\n+\n+        ArrayList<LineEntry> lineEntries = new ArrayList<>(DEFAULT_LINE_ENTRY_COUNT);\n+        int highAddr = 0;\n+        @SuppressWarnings(\"unused\") FileEntry file;", "originalCommit": "85f3abd5ff140b0079a0d35a9f00f6973b60f499", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgxNzIyMg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458817222", "bodyText": "Gone.", "author": "stooke", "createdAt": "2020-07-22T14:04:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk4NjE1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\nindex 9a21d248e97..090f30fe4ac 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n", "chunk": "@@ -61,28 +127,25 @@ final class CVLineRecord extends CVSymbolRecord {\n         /* Fileblock header: fileId (4 bytes) lineEntry count (4 bytes) tablesize (4 bytes) */\n         static final int FILE_BLOCK_HEADER_SIZE = Integer.BYTES * 3;\n \n-        ArrayList<LineEntry> lineEntries = new ArrayList<>(DEFAULT_LINE_ENTRY_COUNT);\n-        int highAddr = 0;\n-        @SuppressWarnings(\"unused\") FileEntry file;\n-        int fileId;\n+        private ArrayList<LineEntry> lineEntries = new ArrayList<>(DEFAULT_LINE_ENTRY_COUNT);\n+        private int fileId;\n \n-        FileBlock(FileEntry file, int fileId) {\n-            this.file = file;\n+        FileBlock(int fileId) {\n             this.fileId = fileId;\n         }\n \n         void addEntry(LineEntry le) {\n-            highAddr = Math.max(highAddr, le.addr);\n             lineEntries.add(le);\n         }\n \n         int computeContents(byte[] buffer, int initialPos) {\n+            if (buffer == null) {\n+                return computeSize(initialPos);\n+            }\n             int pos = initialPos;\n             pos = CVUtil.putInt(fileId, buffer, pos);\n             pos = CVUtil.putInt(lineEntries.size(), buffer, pos);\n-            /* If HAS_COLUMNS is true, this formula is incorrect. */\n-            assert !HAS_COLUMNS;\n-            pos = CVUtil.putInt(Integer.BYTES * 3 + lineEntries.size() * LineEntry.LINE_ENTRY_SIZE, buffer, pos);\n+            pos = CVUtil.putInt(computeSize(0), buffer, pos);\n             for (LineEntry lineEntry : lineEntries) {\n                 pos = lineEntry.computeContents(buffer, pos);\n             }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIyNjQ0NQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458226445", "body": "Are there any plans to support the columns?", "bodyText": "Are there any plans to support the columns?", "bodyHTML": "<p dir=\"auto\">Are there any plans to support the columns?</p>", "author": "pejovica", "createdAt": "2020-07-21T16:23:04Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.ObjectFile;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A line record (DEBUG_S_LINES) consists of a list of (file block record + subrecords).\n+ * Graal will generate one CVLineRecord per function.\n+ */\n+final class CVLineRecord extends CVSymbolRecord {\n+\n+    private static final boolean HAS_COLUMNS = false;", "originalCommit": "85f3abd5ff140b0079a0d35a9f00f6973b60f499", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgwNTI3Mg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458805272", "bodyText": "Well, at one point I considered the possibility.  Gone.", "author": "stooke", "createdAt": "2020-07-22T13:48:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIyNjQ0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\nindex 9a21d248e97..090f30fe4ac 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n", "chunk": "@@ -38,22 +36,90 @@ import java.util.ArrayList;\n  */\n final class CVLineRecord extends CVSymbolRecord {\n \n-    private static final boolean HAS_COLUMNS = false;\n+    /* Header: addr (4 bytes):section (2 bytes) flags (2 bytes) chunck length (4 bytes). */\n+    private static final int LINE_RECORD_HEADER_SIZE = Integer.BYTES + Short.BYTES * 2 + Integer.BYTES;\n \n     private static final int DEFAULT_LINE_BLOCK_COUNT = 100;\n     private static final int DEFAULT_LINE_ENTRY_COUNT = 100;\n \n-    private static final short CB_HAS_COLUMNS_FLAG = 0x01;\n+    /* Has columns flag = 0x80 - not supported. */\n     private static final short CB_HAS_NO_COLUMNS_FLAG = 0x00;\n \n     private String symbolName;\n-    @SuppressWarnings(\"unused\") private PrimaryEntry primaryEntry;\n     private ArrayList<FileBlock> fileBlocks = new ArrayList<>(DEFAULT_LINE_BLOCK_COUNT);\n \n+    CVLineRecord(CVDebugInfo cvDebugInfo, String symbolName) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_LINES);\n+        this.symbolName = symbolName;\n+    }\n+\n+    void addNewFile(int fileId) {\n+        fileBlocks.add(new FileBlock(fileId));\n+    }\n+\n+    void addNewLine(int addr, int line) {\n+        fileBlocks.get(fileBlocks.size() - 1).addEntry(new LineEntry(addr, line));\n+    }\n+\n+    int getCurrentFileId() {\n+        assert !fileBlocks.isEmpty();\n+        return fileBlocks.get(fileBlocks.size() - 1).fileId;\n+    }\n+\n+    @Override\n+    protected int computeSize(int initialPos) {\n+        return computeContents(null, initialPos);\n+    }\n+\n+    @Override\n+    protected int computeContents(byte[] buffer, int initialPos) {\n+        /* Line record header. */\n+        int pos = computeHeader(buffer, initialPos);\n+        /* All blocks. */\n+        for (FileBlock fileBlock : fileBlocks) {\n+            pos = fileBlock.computeContents(buffer, pos);\n+        }\n+        return pos;\n+    }\n+\n+    private int computeHeader(byte[] buffer, int initialPos) {\n+\n+        if (buffer == null) {\n+            return initialPos + LINE_RECORD_HEADER_SIZE;\n+        }\n+\n+        assert symbolName != null;\n+        int pos = initialPos;\n+\n+        /* Emit addr:section relocation records. */\n+        cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, symbolName, false, 1L);\n+        pos = CVUtil.putInt(0, buffer, pos);\n+        cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, symbolName, false, 1L);\n+        pos = CVUtil.putShort((short) 0, buffer, pos);\n+\n+        /* Emit flags. */\n+        pos = CVUtil.putShort(CB_HAS_NO_COLUMNS_FLAG, buffer, pos);\n+\n+        /* Length of this chunk in object file (= highAddr since it's zero based. */\n+        assert !fileBlocks.isEmpty();\n+        int length = fileBlocks.get(fileBlocks.size() - 1).getHighAddr();\n+        pos = CVUtil.putInt(length, buffer, pos);\n+        return pos;\n+    }\n+\n+    boolean isEmpty() {\n+        return fileBlocks.isEmpty();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVLineRecord(type=0x%04x pos=0x%05x size=0x%d)\", type, recordStartPosition, fileBlocks.size());\n+    }\n+\n     /*\n      * FileBlock is a section of contiguous code in a compilation unit, associated with a single\n      * source file. If a function includes inlined code, that code needs its own FileBlock,\n-     * surrounded by FileBlocks describing the enclosing source file A FileBlock consists of a list\n+     * surrounded by FileBlocks describing the enclosing source file. A FileBlock consists of a list\n      * of LineEntries.\n      */\n     private static class FileBlock {\n", "next_change": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\nindex 090f30fe4ac..27d7935f6d0 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n", "chunk": "@@ -127,8 +122,8 @@ final class CVLineRecord extends CVSymbolRecord {\n         /* Fileblock header: fileId (4 bytes) lineEntry count (4 bytes) tablesize (4 bytes) */\n         static final int FILE_BLOCK_HEADER_SIZE = Integer.BYTES * 3;\n \n-        private ArrayList<LineEntry> lineEntries = new ArrayList<>(DEFAULT_LINE_ENTRY_COUNT);\n-        private int fileId;\n+        private final ArrayList<LineEntry> lineEntries = new ArrayList<>(DEFAULT_LINE_ENTRY_COUNT);\n+        private final int fileId;\n \n         FileBlock(int fileId) {\n             this.fileId = fileId;\n", "next_change": {"commit": "6d209109480ecec08ebf137288371d4c56064ba0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\nindex 27d7935f6d0..868d68f2bd5 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n", "chunk": "@@ -124,13 +124,19 @@ final class CVLineRecord extends CVSymbolRecord {\n \n         private final ArrayList<LineEntry> lineEntries = new ArrayList<>(DEFAULT_LINE_ENTRY_COUNT);\n         private final int fileId;\n+        private int previousLine;\n \n         FileBlock(int fileId) {\n             this.fileId = fileId;\n+            this.previousLine = -2;\n         }\n \n         void addEntry(LineEntry le) {\n-            lineEntries.add(le);\n+            /* Only add an entry if the line number has changed. */\n+            if (le.lineAndFlags != previousLine) {\n+                lineEntries.add(le);\n+                previousLine = le.lineAndFlags;\n+            }\n         }\n \n         int computeContents(byte[] buffer, int initialPos) {\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIzOTA2MQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458239061", "body": "Maybe move this out of the `LineEntry` class?", "bodyText": "Maybe move this out of the LineEntry class?", "bodyHTML": "<p dir=\"auto\">Maybe move this out of the <code>LineEntry</code> class?</p>", "author": "pejovica", "createdAt": "2020-07-21T16:42:34Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.ObjectFile;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A line record (DEBUG_S_LINES) consists of a list of (file block record + subrecords).\n+ * Graal will generate one CVLineRecord per function.\n+ */\n+final class CVLineRecord extends CVSymbolRecord {\n+\n+    private static final boolean HAS_COLUMNS = false;\n+\n+    private static final int DEFAULT_LINE_BLOCK_COUNT = 100;\n+    private static final int DEFAULT_LINE_ENTRY_COUNT = 100;\n+\n+    private static final short CB_HAS_COLUMNS_FLAG = 0x01;\n+    private static final short CB_HAS_NO_COLUMNS_FLAG = 0x00;\n+\n+    private String symbolName;\n+    @SuppressWarnings(\"unused\") private PrimaryEntry primaryEntry;\n+    private ArrayList<FileBlock> fileBlocks = new ArrayList<>(DEFAULT_LINE_BLOCK_COUNT);\n+\n+    /*\n+     * FileBlock is a section of contiguous code in a compilation unit, associated with a single\n+     * source file. If a function includes inlined code, that code needs its own FileBlock,\n+     * surrounded by FileBlocks describing the enclosing source file A FileBlock consists of a list\n+     * of LineEntries.\n+     */\n+    private static class FileBlock {\n+\n+        /* Fileblock header: fileId (4 bytes) lineEntry count (4 bytes) tablesize (4 bytes) */\n+        static final int FILE_BLOCK_HEADER_SIZE = Integer.BYTES * 3;\n+\n+        ArrayList<LineEntry> lineEntries = new ArrayList<>(DEFAULT_LINE_ENTRY_COUNT);\n+        int highAddr = 0;\n+        @SuppressWarnings(\"unused\") FileEntry file;\n+        int fileId;\n+\n+        FileBlock(FileEntry file, int fileId) {\n+            this.file = file;\n+            this.fileId = fileId;\n+        }\n+\n+        void addEntry(LineEntry le) {\n+            highAddr = Math.max(highAddr, le.addr);\n+            lineEntries.add(le);\n+        }\n+\n+        int computeContents(byte[] buffer, int initialPos) {\n+            int pos = initialPos;\n+            pos = CVUtil.putInt(fileId, buffer, pos);\n+            pos = CVUtil.putInt(lineEntries.size(), buffer, pos);\n+            /* If HAS_COLUMNS is true, this formula is incorrect. */\n+            assert !HAS_COLUMNS;\n+            pos = CVUtil.putInt(Integer.BYTES * 3 + lineEntries.size() * LineEntry.LINE_ENTRY_SIZE, buffer, pos);\n+            for (LineEntry lineEntry : lineEntries) {\n+                pos = lineEntry.computeContents(buffer, pos);\n+            }\n+            return pos;\n+        }\n+\n+        int computeSize(int initialPos) {\n+            /* If HAS_COLUMNS is true, this formula is incorrect. */\n+            assert !HAS_COLUMNS;\n+            return initialPos + FILE_BLOCK_HEADER_SIZE + LineEntry.LINE_ENTRY_SIZE * lineEntries.size();\n+        }\n+\n+        int getHighAddr() {\n+            return highAddr;\n+        }\n+    }\n+\n+    /*\n+     * LineEntry associates some object code (at 'addr', relative to the start of this DEBUG_S_LINES\n+     * record) with a source line in the current FileBlock file.\n+     */\n+    static class LineEntry {\n+\n+        /* Header: addr (4 bytes):section (2 bytes) flags (2 bytes) chunck length (4 bytes). */\n+        static final int LINE_RECORD_HEADER_SIZE = Integer.BYTES + Short.BYTES * 2 + Integer.BYTES;", "originalCommit": "85f3abd5ff140b0079a0d35a9f00f6973b60f499", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgwNTY4MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458805680", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-07-22T13:48:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIzOTA2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\nindex 9a21d248e97..090f30fe4ac 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n", "chunk": "@@ -104,11 +166,9 @@ final class CVLineRecord extends CVSymbolRecord {\n      * LineEntry associates some object code (at 'addr', relative to the start of this DEBUG_S_LINES\n      * record) with a source line in the current FileBlock file.\n      */\n-    static class LineEntry {\n-\n-        /* Header: addr (4 bytes):section (2 bytes) flags (2 bytes) chunck length (4 bytes). */\n-        static final int LINE_RECORD_HEADER_SIZE = Integer.BYTES + Short.BYTES * 2 + Integer.BYTES;\n+    private static class LineEntry {\n \n+        /* Entry: address(4 bytes) line number+flags (4 bytes) */\n         static final int LINE_ENTRY_SIZE = 2 * Integer.BYTES;\n \n         int addr;\n", "next_change": {"commit": "6d209109480ecec08ebf137288371d4c56064ba0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\nindex 090f30fe4ac..868d68f2bd5 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n", "chunk": "@@ -172,7 +173,7 @@ final class CVLineRecord extends CVSymbolRecord {\n         static final int LINE_ENTRY_SIZE = 2 * Integer.BYTES;\n \n         int addr;\n-        int lineAndFLags;\n+        int lineAndFlags;\n \n         LineEntry(int addr, int line, int deltaEnd, boolean isStatement) {\n             this.addr = addr;\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI0OTc1NA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458249754", "body": "Unused constructor. Perhaps to chain it with the next one?", "bodyText": "Unused constructor. Perhaps to chain it with the next one?", "bodyHTML": "<p dir=\"auto\">Unused constructor. Perhaps to chain it with the next one?</p>", "author": "pejovica", "createdAt": "2020-07-21T16:59:14Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.ObjectFile;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A line record (DEBUG_S_LINES) consists of a list of (file block record + subrecords).\n+ * Graal will generate one CVLineRecord per function.\n+ */\n+final class CVLineRecord extends CVSymbolRecord {\n+\n+    private static final boolean HAS_COLUMNS = false;\n+\n+    private static final int DEFAULT_LINE_BLOCK_COUNT = 100;\n+    private static final int DEFAULT_LINE_ENTRY_COUNT = 100;\n+\n+    private static final short CB_HAS_COLUMNS_FLAG = 0x01;\n+    private static final short CB_HAS_NO_COLUMNS_FLAG = 0x00;\n+\n+    private String symbolName;\n+    @SuppressWarnings(\"unused\") private PrimaryEntry primaryEntry;\n+    private ArrayList<FileBlock> fileBlocks = new ArrayList<>(DEFAULT_LINE_BLOCK_COUNT);\n+\n+    /*\n+     * FileBlock is a section of contiguous code in a compilation unit, associated with a single\n+     * source file. If a function includes inlined code, that code needs its own FileBlock,\n+     * surrounded by FileBlocks describing the enclosing source file A FileBlock consists of a list\n+     * of LineEntries.\n+     */\n+    private static class FileBlock {\n+\n+        /* Fileblock header: fileId (4 bytes) lineEntry count (4 bytes) tablesize (4 bytes) */\n+        static final int FILE_BLOCK_HEADER_SIZE = Integer.BYTES * 3;\n+\n+        ArrayList<LineEntry> lineEntries = new ArrayList<>(DEFAULT_LINE_ENTRY_COUNT);\n+        int highAddr = 0;\n+        @SuppressWarnings(\"unused\") FileEntry file;\n+        int fileId;\n+\n+        FileBlock(FileEntry file, int fileId) {\n+            this.file = file;\n+            this.fileId = fileId;\n+        }\n+\n+        void addEntry(LineEntry le) {\n+            highAddr = Math.max(highAddr, le.addr);\n+            lineEntries.add(le);\n+        }\n+\n+        int computeContents(byte[] buffer, int initialPos) {\n+            int pos = initialPos;\n+            pos = CVUtil.putInt(fileId, buffer, pos);\n+            pos = CVUtil.putInt(lineEntries.size(), buffer, pos);\n+            /* If HAS_COLUMNS is true, this formula is incorrect. */\n+            assert !HAS_COLUMNS;\n+            pos = CVUtil.putInt(Integer.BYTES * 3 + lineEntries.size() * LineEntry.LINE_ENTRY_SIZE, buffer, pos);\n+            for (LineEntry lineEntry : lineEntries) {\n+                pos = lineEntry.computeContents(buffer, pos);\n+            }\n+            return pos;\n+        }\n+\n+        int computeSize(int initialPos) {\n+            /* If HAS_COLUMNS is true, this formula is incorrect. */\n+            assert !HAS_COLUMNS;\n+            return initialPos + FILE_BLOCK_HEADER_SIZE + LineEntry.LINE_ENTRY_SIZE * lineEntries.size();\n+        }\n+\n+        int getHighAddr() {\n+            return highAddr;\n+        }\n+    }\n+\n+    /*\n+     * LineEntry associates some object code (at 'addr', relative to the start of this DEBUG_S_LINES\n+     * record) with a source line in the current FileBlock file.\n+     */\n+    static class LineEntry {\n+\n+        /* Header: addr (4 bytes):section (2 bytes) flags (2 bytes) chunck length (4 bytes). */\n+        static final int LINE_RECORD_HEADER_SIZE = Integer.BYTES + Short.BYTES * 2 + Integer.BYTES;\n+\n+        static final int LINE_ENTRY_SIZE = 2 * Integer.BYTES;\n+\n+        int addr;\n+        int lineAndFLags;\n+\n+        LineEntry(int addr, int line, int deltaEnd, boolean isStatement) {", "originalCommit": "85f3abd5ff140b0079a0d35a9f00f6973b60f499", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc5ODYzNw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458798637", "bodyText": "done.", "author": "stooke", "createdAt": "2020-07-22T13:39:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI0OTc1NA=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\nindex 9a21d248e97..090f30fe4ac 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n", "chunk": "@@ -104,11 +166,9 @@ final class CVLineRecord extends CVSymbolRecord {\n      * LineEntry associates some object code (at 'addr', relative to the start of this DEBUG_S_LINES\n      * record) with a source line in the current FileBlock file.\n      */\n-    static class LineEntry {\n-\n-        /* Header: addr (4 bytes):section (2 bytes) flags (2 bytes) chunck length (4 bytes). */\n-        static final int LINE_RECORD_HEADER_SIZE = Integer.BYTES + Short.BYTES * 2 + Integer.BYTES;\n+    private static class LineEntry {\n \n+        /* Entry: address(4 bytes) line number+flags (4 bytes) */\n         static final int LINE_ENTRY_SIZE = 2 * Integer.BYTES;\n \n         int addr;\n", "next_change": {"commit": "6d209109480ecec08ebf137288371d4c56064ba0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\nindex 090f30fe4ac..868d68f2bd5 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n", "chunk": "@@ -172,7 +173,7 @@ final class CVLineRecord extends CVSymbolRecord {\n         static final int LINE_ENTRY_SIZE = 2 * Integer.BYTES;\n \n         int addr;\n-        int lineAndFLags;\n+        int lineAndFlags;\n \n         LineEntry(int addr, int line, int deltaEnd, boolean isStatement) {\n             this.addr = addr;\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI3NTEyNA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458275124", "body": "You could simplify these bits here (and in several other places) by writing the whole header after the content.\r\n\r\nFor example, if the method `void computeHeader(byte[] buffer, int initialPos, int contentSize)` writes only the header, then writing the content could become something like:\r\n```java\r\n        int pos = initialPos + LINE_RECORD_HEADER_SIZE;\r\n        for (FileBlock fileBlock : fileBlocks) {\r\n            highAddr = Math.max(highAddr, fileBlock.getHighAddr());\r\n            pos = fileBlock.computeContents(buffer, pos);\r\n        }\r\n        computeHeader(initialPos, buffer, highAddr);\r\n        return pos;\r\n```", "bodyText": "You could simplify these bits here (and in several other places) by writing the whole header after the content.\nFor example, if the method void computeHeader(byte[] buffer, int initialPos, int contentSize) writes only the header, then writing the content could become something like:\n        int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n        for (FileBlock fileBlock : fileBlocks) {\n            highAddr = Math.max(highAddr, fileBlock.getHighAddr());\n            pos = fileBlock.computeContents(buffer, pos);\n        }\n        computeHeader(initialPos, buffer, highAddr);\n        return pos;", "bodyHTML": "<p dir=\"auto\">You could simplify these bits here (and in several other places) by writing the whole header after the content.</p>\n<p dir=\"auto\">For example, if the method <code>void computeHeader(byte[] buffer, int initialPos, int contentSize)</code> writes only the header, then writing the content could become something like:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"        int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n        for (FileBlock fileBlock : fileBlocks) {\n            highAddr = Math.max(highAddr, fileBlock.getHighAddr());\n            pos = fileBlock.computeContents(buffer, pos);\n        }\n        computeHeader(initialPos, buffer, highAddr);\n        return pos;\"><pre>        <span class=\"pl-k\">int</span> pos <span class=\"pl-k\">=</span> initialPos <span class=\"pl-k\">+</span> <span class=\"pl-c1\">LINE_RECORD_HEADER_SIZE</span>;\n        <span class=\"pl-k\">for</span> (<span class=\"pl-smi\">FileBlock</span> fileBlock <span class=\"pl-k\">:</span> fileBlocks) {\n            highAddr <span class=\"pl-k\">=</span> <span class=\"pl-smi\">Math</span><span class=\"pl-k\">.</span>max(highAddr, fileBlock<span class=\"pl-k\">.</span>getHighAddr());\n            pos <span class=\"pl-k\">=</span> fileBlock<span class=\"pl-k\">.</span>computeContents(buffer, pos);\n        }\n        computeHeader(initialPos, buffer, highAddr);\n        <span class=\"pl-k\">return</span> pos;</pre></div>", "author": "pejovica", "createdAt": "2020-07-21T17:40:56Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.ObjectFile;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A line record (DEBUG_S_LINES) consists of a list of (file block record + subrecords).\n+ * Graal will generate one CVLineRecord per function.\n+ */\n+final class CVLineRecord extends CVSymbolRecord {\n+\n+    private static final boolean HAS_COLUMNS = false;\n+\n+    private static final int DEFAULT_LINE_BLOCK_COUNT = 100;\n+    private static final int DEFAULT_LINE_ENTRY_COUNT = 100;\n+\n+    private static final short CB_HAS_COLUMNS_FLAG = 0x01;\n+    private static final short CB_HAS_NO_COLUMNS_FLAG = 0x00;\n+\n+    private String symbolName;\n+    @SuppressWarnings(\"unused\") private PrimaryEntry primaryEntry;\n+    private ArrayList<FileBlock> fileBlocks = new ArrayList<>(DEFAULT_LINE_BLOCK_COUNT);\n+\n+    /*\n+     * FileBlock is a section of contiguous code in a compilation unit, associated with a single\n+     * source file. If a function includes inlined code, that code needs its own FileBlock,\n+     * surrounded by FileBlocks describing the enclosing source file A FileBlock consists of a list\n+     * of LineEntries.\n+     */\n+    private static class FileBlock {\n+\n+        /* Fileblock header: fileId (4 bytes) lineEntry count (4 bytes) tablesize (4 bytes) */\n+        static final int FILE_BLOCK_HEADER_SIZE = Integer.BYTES * 3;\n+\n+        ArrayList<LineEntry> lineEntries = new ArrayList<>(DEFAULT_LINE_ENTRY_COUNT);\n+        int highAddr = 0;\n+        @SuppressWarnings(\"unused\") FileEntry file;\n+        int fileId;\n+\n+        FileBlock(FileEntry file, int fileId) {\n+            this.file = file;\n+            this.fileId = fileId;\n+        }\n+\n+        void addEntry(LineEntry le) {\n+            highAddr = Math.max(highAddr, le.addr);\n+            lineEntries.add(le);\n+        }\n+\n+        int computeContents(byte[] buffer, int initialPos) {\n+            int pos = initialPos;\n+            pos = CVUtil.putInt(fileId, buffer, pos);\n+            pos = CVUtil.putInt(lineEntries.size(), buffer, pos);\n+            /* If HAS_COLUMNS is true, this formula is incorrect. */\n+            assert !HAS_COLUMNS;\n+            pos = CVUtil.putInt(Integer.BYTES * 3 + lineEntries.size() * LineEntry.LINE_ENTRY_SIZE, buffer, pos);\n+            for (LineEntry lineEntry : lineEntries) {\n+                pos = lineEntry.computeContents(buffer, pos);\n+            }\n+            return pos;\n+        }\n+\n+        int computeSize(int initialPos) {\n+            /* If HAS_COLUMNS is true, this formula is incorrect. */\n+            assert !HAS_COLUMNS;\n+            return initialPos + FILE_BLOCK_HEADER_SIZE + LineEntry.LINE_ENTRY_SIZE * lineEntries.size();\n+        }\n+\n+        int getHighAddr() {\n+            return highAddr;\n+        }\n+    }\n+\n+    /*\n+     * LineEntry associates some object code (at 'addr', relative to the start of this DEBUG_S_LINES\n+     * record) with a source line in the current FileBlock file.\n+     */\n+    static class LineEntry {\n+\n+        /* Header: addr (4 bytes):section (2 bytes) flags (2 bytes) chunck length (4 bytes). */\n+        static final int LINE_RECORD_HEADER_SIZE = Integer.BYTES + Short.BYTES * 2 + Integer.BYTES;\n+\n+        static final int LINE_ENTRY_SIZE = 2 * Integer.BYTES;\n+\n+        int addr;\n+        int lineAndFLags;\n+\n+        LineEntry(int addr, int line, int deltaEnd, boolean isStatement) {\n+            this.addr = addr;\n+            assert line <= 0xffffff;\n+            assert line >= 0;\n+            assert deltaEnd <= 0x7f;\n+            assert deltaEnd >= 0;\n+            lineAndFLags = line | (deltaEnd << 24) | (isStatement ? 0x80000000 : 0);\n+        }\n+\n+        LineEntry(int addr, int line) {\n+            this.addr = addr;\n+            this.lineAndFLags = line;\n+        }\n+\n+        int computeContents(byte[] buffer, int initialPos) {\n+            int pos = initialPos;\n+            pos = CVUtil.putInt(addr, buffer, pos);\n+            pos = CVUtil.putInt(lineAndFLags, buffer, pos);\n+            return pos;\n+        }\n+    }\n+\n+    CVLineRecord(CVDebugInfo cvDebugInfo, String symbolName, PrimaryEntry entry) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_LINES);\n+        this.primaryEntry = entry;\n+        this.symbolName = symbolName;\n+    }\n+\n+    void addNewFile(FileEntry file) {\n+        CVFileRecord fr = cvDebugInfo.getCVSymbolSection().getFileRecord();\n+        int fileId = fr.addFile(file);\n+        fileBlocks.add(new FileBlock(file, fileId));\n+    }\n+\n+    void addNewLine(int addr, int line) {\n+        fileBlocks.get(fileBlocks.size() - 1).addEntry(new LineEntry(addr, line));\n+    }\n+\n+    @Override\n+    protected int computeSize(int initialPos) {\n+        /* Line record header. */\n+        int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n+        /* All blocks. */\n+        for (FileBlock fileBlock : fileBlocks) {\n+            pos = fileBlock.computeSize(pos);\n+        }\n+        return pos;\n+    }\n+\n+    @Override\n+    protected int computeContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+\n+        assert symbolName != null;\n+        /* This implementation can't handle columns yet. */\n+        assert !HAS_COLUMNS;\n+\n+        if (buffer != null) {\n+            cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 4, ObjectFile.RelocationKind.SECREL, symbolName, false, 1L);\n+        }\n+        pos = CVUtil.putInt(0, buffer, pos);\n+\n+        if (buffer != null) {\n+            cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 2, ObjectFile.RelocationKind.SECTION, symbolName, false, 1L);\n+        }\n+        pos = CVUtil.putShort((short) 0, buffer, pos);\n+\n+        final short flags = HAS_COLUMNS ? CB_HAS_COLUMNS_FLAG : CB_HAS_NO_COLUMNS_FLAG;\n+        pos = CVUtil.putShort(flags, buffer, pos); /* flags */\n+\n+        /*\n+         * HighAddr = length of this chunk in object file (fill in correctly later).\n+         */\n+        final int cbConPos = pos; /* Save position of length(int32). */\n+        int highAddr = 0;\n+        pos = CVUtil.putInt(highAddr, buffer, pos);", "originalCommit": "85f3abd5ff140b0079a0d35a9f00f6973b60f499", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODg5NDkwNw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458894907", "bodyText": "done (here, at least).", "author": "stooke", "createdAt": "2020-07-22T15:49:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI3NTEyNA=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\nindex 9a21d248e97..090f30fe4ac 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n", "chunk": "@@ -135,71 +194,4 @@ final class CVLineRecord extends CVSymbolRecord {\n             return pos;\n         }\n     }\n-\n-    CVLineRecord(CVDebugInfo cvDebugInfo, String symbolName, PrimaryEntry entry) {\n-        super(cvDebugInfo, CVDebugConstants.DEBUG_S_LINES);\n-        this.primaryEntry = entry;\n-        this.symbolName = symbolName;\n-    }\n-\n-    void addNewFile(FileEntry file) {\n-        CVFileRecord fr = cvDebugInfo.getCVSymbolSection().getFileRecord();\n-        int fileId = fr.addFile(file);\n-        fileBlocks.add(new FileBlock(file, fileId));\n-    }\n-\n-    void addNewLine(int addr, int line) {\n-        fileBlocks.get(fileBlocks.size() - 1).addEntry(new LineEntry(addr, line));\n-    }\n-\n-    @Override\n-    protected int computeSize(int initialPos) {\n-        /* Line record header. */\n-        int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n-        /* All blocks. */\n-        for (FileBlock fileBlock : fileBlocks) {\n-            pos = fileBlock.computeSize(pos);\n-        }\n-        return pos;\n-    }\n-\n-    @Override\n-    protected int computeContents(byte[] buffer, int initialPos) {\n-        int pos = initialPos;\n-\n-        assert symbolName != null;\n-        /* This implementation can't handle columns yet. */\n-        assert !HAS_COLUMNS;\n-\n-        if (buffer != null) {\n-            cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 4, ObjectFile.RelocationKind.SECREL, symbolName, false, 1L);\n-        }\n-        pos = CVUtil.putInt(0, buffer, pos);\n-\n-        if (buffer != null) {\n-            cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 2, ObjectFile.RelocationKind.SECTION, symbolName, false, 1L);\n-        }\n-        pos = CVUtil.putShort((short) 0, buffer, pos);\n-\n-        final short flags = HAS_COLUMNS ? CB_HAS_COLUMNS_FLAG : CB_HAS_NO_COLUMNS_FLAG;\n-        pos = CVUtil.putShort(flags, buffer, pos); /* flags */\n-\n-        /*\n-         * HighAddr = length of this chunk in object file (fill in correctly later).\n-         */\n-        final int cbConPos = pos; /* Save position of length(int32). */\n-        int highAddr = 0;\n-        pos = CVUtil.putInt(highAddr, buffer, pos);\n-        for (FileBlock fileBlock : fileBlocks) {\n-            highAddr = Math.max(highAddr, fileBlock.getHighAddr());\n-            pos = fileBlock.computeContents(buffer, pos);\n-        }\n-        CVUtil.putInt(highAddr, buffer, cbConPos);\n-        return pos;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"CVLineRecord(type=0x%04x pos=0x%05x size=0x%d)\", type, recordStartPosition, fileBlocks.size());\n-    }\n }\n", "next_change": {"commit": "6d209109480ecec08ebf137288371d4c56064ba0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\nindex 090f30fe4ac..868d68f2bd5 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n", "chunk": "@@ -190,7 +191,7 @@ final class CVLineRecord extends CVSymbolRecord {\n         int computeContents(byte[] buffer, int initialPos) {\n             int pos = initialPos;\n             pos = CVUtil.putInt(addr, buffer, pos);\n-            pos = CVUtil.putInt(lineAndFLags, buffer, pos);\n+            pos = CVUtil.putInt(lineAndFlags, buffer, pos);\n             return pos;\n         }\n     }\n", "next_change": null}]}}]}}, {"oid": "6b5e7101280ba80b98dd45bd2df905479963b5bd", "url": "https://github.com/oracle/graal/commit/6b5e7101280ba80b98dd45bd2df905479963b5bd", "message": "First round of changes after pejovica review", "committedDate": "2020-07-23T17:34:08Z", "type": "forcePushed"}, {"oid": "46d1056558f8ff5a1e7004219de75a046c063991", "url": "https://github.com/oracle/graal/commit/46d1056558f8ff5a1e7004219de75a046c063991", "message": "Changes from pejovica review", "committedDate": "2020-07-23T17:45:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk0ODMyMA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r459948320", "body": "```suggestion\r\n         * The address of the object file section containing the relocation's symbol (+addend)\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * The address of the object file section containing the relocation's symbol (+addend(\n          \n          \n            \n                     * The address of the object file section containing the relocation's symbol (+addend)", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">         <span class=\"pl-k\">*</span> <span class=\"pl-smi\">The</span> address of the object file section containing the relocation<span class=\"pl-s\"><span class=\"pl-pds\">'</span>s symbol (+addend<span class=\"x x-first x-last\">(</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">         <span class=\"pl-k\">*</span> <span class=\"pl-smi\">The</span> address of the object file section containing the relocation<span class=\"pl-s\"><span class=\"pl-pds\">'</span>s symbol (+addend<span class=\"x x-first x-last\">)</span></span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pejovica", "createdAt": "2020-07-24T09:29:59Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java", "diffHunk": "@@ -252,6 +252,16 @@ public static ObjectFile createRuntimeDebugInfo(int pageSize) {\n          * The relocation's symbol provides high fixup bytes.\n          */\n         DIRECT_HI,\n+        /**\n+         * The index of the object file section containing the relocation's symbol supplies the\n+         * fixup bytes. (used in CodeView debug information)\n+         */\n+        SECTION,\n+        /**\n+         * The address of the object file section containing the relocation's symbol (+addend(", "originalCommit": "46d1056558f8ff5a1e7004219de75a046c063991", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI0MTc3OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460241778", "bodyText": "FIxed (and reordered so DIRECT_HI and DIRECT_LOW are consecutive).", "author": "stooke", "createdAt": "2020-07-24T19:16:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk0ODMyMA=="}], "type": "inlineReview", "revised_code": {"commit": "7248c596e88f83b93728b9e4a5553df345fc7b07", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java\nindex f0f8c6981d6..ab00cc8836e 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java\n", "chunk": "@@ -247,41 +248,18 @@ public abstract class ObjectFile {\n          * The relocation's symbol provides an address whose absolute value (plus addend) supplies\n          * the fixup bytes.\n          */\n-        DIRECT,\n-        /**\n-         * The relocation's symbol provides high fixup bytes.\n-         */\n-        DIRECT_HI,\n-        /**\n-         * The index of the object file section containing the relocation's symbol supplies the\n-         * fixup bytes. (used in CodeView debug information)\n-         */\n-        SECTION,\n-        /**\n-         * The address of the object file section containing the relocation's symbol (+addend(\n-         * supplies the fixup bytes. (used in CodeView debug information)\n-         */\n-        SECREL,\n-        /**\n-         * The relocation's symbol provides low fixup bytes.\n-         */\n-        DIRECT_LO,\n+        DIRECT_1,\n+        DIRECT_2,\n+        DIRECT_4,\n+        DIRECT_8,\n         /**\n          * The relocation's symbol provides an address whose PC-relative value (plus addend)\n          * supplies the fixup bytes.\n          */\n-        PC_RELATIVE,\n-        /**\n-         * The relocation's symbol is ignored; the load-time offset of the program (FIXME: or shared\n-         * object), plus addend, supplies the fixup bytes.\n-         */\n-        PROGRAM_BASE {\n-\n-            @Override\n-            public boolean usesSymbolValue() {\n-                return false;\n-            }\n-        },\n+        PC_RELATIVE_1,\n+        PC_RELATIVE_2,\n+        PC_RELATIVE_4,\n+        PC_RELATIVE_8,\n         AARCH64_R_MOVW_UABS_G0,\n         AARCH64_R_MOVW_UABS_G0_NC,\n         AARCH64_R_MOVW_UABS_G1,\n", "next_change": {"commit": "0c24d67d194819dad45c3682d1b8eba391cf0cfe", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java\nindex ab00cc8836e..4bf21afddb0 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java\n", "chunk": "@@ -260,6 +274,9 @@ public abstract class ObjectFile {\n         PC_RELATIVE_2,\n         PC_RELATIVE_4,\n         PC_RELATIVE_8,\n+        /**\n+         * AArch64-specific relocation types.\n+         */\n         AARCH64_R_MOVW_UABS_G0,\n         AARCH64_R_MOVW_UABS_G0_NC,\n         AARCH64_R_MOVW_UABS_G1,\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk4MjgzOQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r459982839", "body": "Unused method.", "bodyText": "Unused method.", "bodyHTML": "<p dir=\"auto\">Unused method.</p>", "author": "pejovica", "createdAt": "2020-07-24T10:52:07Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SIGNATURE_C13;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SYMBOL_SECTION_NAME;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_TYPE_SECTION_NAME;\n+\n+public final class CVTypeSectionImpl extends CVSectionImpl {\n+\n+    private static final int CV_RECORD_INITIAL_CAPACITY = 200;\n+\n+    private int sequenceCounter = 0x1000;\n+    private ArrayList<CVTypeRecord> cvRecords = new ArrayList<>(CV_RECORD_INITIAL_CAPACITY);\n+    private Map<Integer, CVTypeRecord> typeMap = new HashMap<>();\n+\n+    CVTypeSectionImpl() {\n+    }\n+\n+    @Override\n+    public String getSectionName() {\n+        return CV_TYPE_SECTION_NAME;\n+    }\n+\n+    @Override\n+    public void createContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext);\n+        log(debugContext, \"CVTypeSectionImpl.createContent() adding records\");\n+        addRecords();\n+        log(debugContext, \"CVTypeSectionImpl.createContent() start\");\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, null, pos);\n+        for (CVTypeRecord record : cvRecords) {\n+            pos = record.computeFullSize(pos);\n+        }\n+        byte[] buffer = new byte[pos];\n+        super.setContent(buffer);\n+        log(debugContext, \"CVTypeSectionImpl.createContent() end\");\n+    }\n+\n+    @Override\n+    public void writeContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext);\n+        log(debugContext, \"CVTypeSectionImpl.writeContent() start\");\n+        byte[] buffer = getContent();\n+        verboseLog(debugContext, \"  [0x%08x] CV_SIGNATURE_C13\", pos);\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, buffer, pos);\n+        for (CVTypeRecord record : cvRecords) {\n+            verboseLog(debugContext, \"  [0x%08x] 0x%06x %s\", pos, record.getSequenceNumber(), record.toString());\n+            pos = record.computeFullContents(buffer, pos);\n+        }\n+        verboseLog(debugContext, \"CVTypeSectionImpl.writeContent() end\");\n+    }\n+\n+    /**\n+     * Add all relevant type records to the type section.\n+     */\n+    private void addRecords() {\n+        /* if an external PDB file is generated, add CVTypeServer2Record */\n+        /* for each class, add all members, types, etc */\n+    }\n+\n+    public List<CVTypeRecord> getRecords() {", "originalCommit": "46d1056558f8ff5a1e7004219de75a046c063991", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI0MTYzNw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460241637", "bodyText": "Removed.", "author": "stooke", "createdAt": "2020-07-24T19:16:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk4MjgzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\nindex eeab4d7d56f..ac22c2be305 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\n", "chunk": "@@ -99,44 +98,6 @@ public final class CVTypeSectionImpl extends CVSectionImpl {\n         /* for each class, add all members, types, etc */\n     }\n \n-    public List<CVTypeRecord> getRecords() {\n-        return Collections.unmodifiableList(cvRecords);\n-    }\n-\n-    /**\n-     * Add a record to the type section if it has a unique hash.\n-     *\n-     * @param <T> type of new record.\n-     * @param newRecord record to add\n-     * @return newRecord if the hash is unique, or the existing record already in the type table\n-     */\n-    <T extends CVTypeRecord> T addRecord(T newRecord) {\n-        return addOrReference(newRecord);\n-    }\n-\n-    /**\n-     * Add a record (that has a unique hashcode) to the type section.\n-     *\n-     * @param r the record to add\n-     */\n-    private void addUniqueRecord(CVTypeRecord r) {\n-        cvRecords.add(r);\n-    }\n-\n-    @Override\n-    public Set<BuildDependency> getDependencies(Map<ObjectFile.Element, LayoutDecisionMap> decisions) {\n-        Set<BuildDependency> deps = super.getDependencies(decisions);\n-        PECoffObjectFile.PECoffSection targetSection = (PECoffObjectFile.PECoffSection) getElement().getOwner().elementForName(CV_SYMBOL_SECTION_NAME);\n-        LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n-        LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n-        /* Make our content depend on the codeview symbol section. */\n-        deps.add(BuildDependency.createOrGet(ourContent, decisions.get(targetSection).getDecision(LayoutDecision.Kind.CONTENT)));\n-        /* Make our size depend on our content. */\n-        deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n-\n-        return deps;\n-    }\n-\n     /**\n      * Return either the caller-created instance or a matching existing instance. Every entry in\n      * typeMap is a T, because it is ONLY this function which inserts entries (of type T).\n", "next_change": {"commit": "77e3a7479e429a3279d3061496d260e35f21f000", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\nindex ac22c2be305..696b9434c9a 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\n", "chunk": "@@ -63,39 +73,31 @@ public final class CVTypeSectionImpl extends CVSectionImpl {\n     public void createContent(DebugContext debugContext) {\n         int pos = 0;\n         enableLog(debugContext);\n-        log(debugContext, \"CVTypeSectionImpl.createContent() adding records\");\n-        addRecords();\n-        log(debugContext, \"CVTypeSectionImpl.createContent() start\");\n+        log(\"CVTypeSectionImpl.createContent() verifying that all types have been defined\");\n+        builder.verifyAllClassesDefined();\n+        log(\"CVTypeSectionImpl.createContent() start\");\n         pos = CVUtil.putInt(CV_SIGNATURE_C13, null, pos);\n         for (CVTypeRecord record : typeMap.values()) {\n             pos = record.computeFullSize(pos);\n         }\n         byte[] buffer = new byte[pos];\n         super.setContent(buffer);\n-        log(debugContext, \"CVTypeSectionImpl.createContent() end\");\n+        log(\"CVTypeSectionImpl.createContent() end\");\n     }\n \n     @Override\n     public void writeContent(DebugContext debugContext) {\n         int pos = 0;\n         enableLog(debugContext);\n-        log(debugContext, \"CVTypeSectionImpl.writeContent() start\");\n+        log(\"CVTypeSectionImpl.writeContent() start\");\n         byte[] buffer = getContent();\n-        verboseLog(debugContext, \"  [0x%08x] CV_SIGNATURE_C13\", pos);\n+        verboseLog(\"  [0x%08x] CV_SIGNATURE_C13\", pos);\n         pos = CVUtil.putInt(CV_SIGNATURE_C13, buffer, pos);\n         for (CVTypeRecord record : typeMap.values()) {\n-            verboseLog(debugContext, \"  [0x%08x] 0x%06x %s\", pos, record.getSequenceNumber(), record.toString());\n+            verboseLog(\"  [0x%08x] 0x%06x %s\", pos, record.getSequenceNumber(), record.toString());\n             pos = record.computeFullContents(buffer, pos);\n         }\n-        verboseLog(debugContext, \"CVTypeSectionImpl.writeContent() end\");\n-    }\n-\n-    /**\n-     * Add all relevant type records to the type section.\n-     */\n-    private void addRecords() {\n-        /* if an external PDB file is generated, add CVTypeServer2Record */\n-        /* for each class, add all members, types, etc */\n+        verboseLog(\"CVTypeSectionImpl.writeContent() end\");\n     }\n \n     /**\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk4NTYwMw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r459985603", "body": "Is this necessary given that `super.getDependencies` does the same?", "bodyText": "Is this necessary given that super.getDependencies does the same?", "bodyHTML": "<p dir=\"auto\">Is this necessary given that <code>super.getDependencies</code> does the same?</p>", "author": "pejovica", "createdAt": "2020-07-24T10:59:15Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SIGNATURE_C13;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SYMBOL_SECTION_NAME;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_TYPE_SECTION_NAME;\n+\n+public final class CVTypeSectionImpl extends CVSectionImpl {\n+\n+    private static final int CV_RECORD_INITIAL_CAPACITY = 200;\n+\n+    private int sequenceCounter = 0x1000;\n+    private ArrayList<CVTypeRecord> cvRecords = new ArrayList<>(CV_RECORD_INITIAL_CAPACITY);\n+    private Map<Integer, CVTypeRecord> typeMap = new HashMap<>();\n+\n+    CVTypeSectionImpl() {\n+    }\n+\n+    @Override\n+    public String getSectionName() {\n+        return CV_TYPE_SECTION_NAME;\n+    }\n+\n+    @Override\n+    public void createContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext);\n+        log(debugContext, \"CVTypeSectionImpl.createContent() adding records\");\n+        addRecords();\n+        log(debugContext, \"CVTypeSectionImpl.createContent() start\");\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, null, pos);\n+        for (CVTypeRecord record : cvRecords) {\n+            pos = record.computeFullSize(pos);\n+        }\n+        byte[] buffer = new byte[pos];\n+        super.setContent(buffer);\n+        log(debugContext, \"CVTypeSectionImpl.createContent() end\");\n+    }\n+\n+    @Override\n+    public void writeContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext);\n+        log(debugContext, \"CVTypeSectionImpl.writeContent() start\");\n+        byte[] buffer = getContent();\n+        verboseLog(debugContext, \"  [0x%08x] CV_SIGNATURE_C13\", pos);\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, buffer, pos);\n+        for (CVTypeRecord record : cvRecords) {\n+            verboseLog(debugContext, \"  [0x%08x] 0x%06x %s\", pos, record.getSequenceNumber(), record.toString());\n+            pos = record.computeFullContents(buffer, pos);\n+        }\n+        verboseLog(debugContext, \"CVTypeSectionImpl.writeContent() end\");\n+    }\n+\n+    /**\n+     * Add all relevant type records to the type section.\n+     */\n+    private void addRecords() {\n+        /* if an external PDB file is generated, add CVTypeServer2Record */\n+        /* for each class, add all members, types, etc */\n+    }\n+\n+    public List<CVTypeRecord> getRecords() {\n+        return Collections.unmodifiableList(cvRecords);\n+    }\n+\n+    /**\n+     * Add a record to the type section if it has a unique hash.\n+     *\n+     * @param <T> type of new record.\n+     * @param newRecord record to add\n+     * @return newRecord if the hash is unique, or the existing record already in the type table\n+     */\n+    <T extends CVTypeRecord> T addRecord(T newRecord) {\n+        return addOrReference(newRecord);\n+    }\n+\n+    /**\n+     * Add a record (that has a unique hashcode) to the type section.\n+     *\n+     * @param r the record to add\n+     */\n+    private void addUniqueRecord(CVTypeRecord r) {\n+        cvRecords.add(r);\n+    }\n+\n+    @Override\n+    public Set<BuildDependency> getDependencies(Map<ObjectFile.Element, LayoutDecisionMap> decisions) {\n+        Set<BuildDependency> deps = super.getDependencies(decisions);\n+        PECoffObjectFile.PECoffSection targetSection = (PECoffObjectFile.PECoffSection) getElement().getOwner().elementForName(CV_SYMBOL_SECTION_NAME);\n+        LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n+        LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n+        /* Make our content depend on the codeview symbol section. */\n+        deps.add(BuildDependency.createOrGet(ourContent, decisions.get(targetSection).getDecision(LayoutDecision.Kind.CONTENT)));\n+        /* Make our size depend on our content. */\n+        deps.add(BuildDependency.createOrGet(ourSize, ourContent));", "originalCommit": "46d1056558f8ff5a1e7004219de75a046c063991", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI0MTU4MQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460241581", "bodyText": "Removed.", "author": "stooke", "createdAt": "2020-07-24T19:16:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk4NTYwMw=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\nindex eeab4d7d56f..ac22c2be305 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\n", "chunk": "@@ -99,44 +98,6 @@ public final class CVTypeSectionImpl extends CVSectionImpl {\n         /* for each class, add all members, types, etc */\n     }\n \n-    public List<CVTypeRecord> getRecords() {\n-        return Collections.unmodifiableList(cvRecords);\n-    }\n-\n-    /**\n-     * Add a record to the type section if it has a unique hash.\n-     *\n-     * @param <T> type of new record.\n-     * @param newRecord record to add\n-     * @return newRecord if the hash is unique, or the existing record already in the type table\n-     */\n-    <T extends CVTypeRecord> T addRecord(T newRecord) {\n-        return addOrReference(newRecord);\n-    }\n-\n-    /**\n-     * Add a record (that has a unique hashcode) to the type section.\n-     *\n-     * @param r the record to add\n-     */\n-    private void addUniqueRecord(CVTypeRecord r) {\n-        cvRecords.add(r);\n-    }\n-\n-    @Override\n-    public Set<BuildDependency> getDependencies(Map<ObjectFile.Element, LayoutDecisionMap> decisions) {\n-        Set<BuildDependency> deps = super.getDependencies(decisions);\n-        PECoffObjectFile.PECoffSection targetSection = (PECoffObjectFile.PECoffSection) getElement().getOwner().elementForName(CV_SYMBOL_SECTION_NAME);\n-        LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n-        LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n-        /* Make our content depend on the codeview symbol section. */\n-        deps.add(BuildDependency.createOrGet(ourContent, decisions.get(targetSection).getDecision(LayoutDecision.Kind.CONTENT)));\n-        /* Make our size depend on our content. */\n-        deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n-\n-        return deps;\n-    }\n-\n     /**\n      * Return either the caller-created instance or a matching existing instance. Every entry in\n      * typeMap is a T, because it is ONLY this function which inserts entries (of type T).\n", "next_change": {"commit": "77e3a7479e429a3279d3061496d260e35f21f000", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\nindex ac22c2be305..696b9434c9a 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\n", "chunk": "@@ -63,39 +73,31 @@ public final class CVTypeSectionImpl extends CVSectionImpl {\n     public void createContent(DebugContext debugContext) {\n         int pos = 0;\n         enableLog(debugContext);\n-        log(debugContext, \"CVTypeSectionImpl.createContent() adding records\");\n-        addRecords();\n-        log(debugContext, \"CVTypeSectionImpl.createContent() start\");\n+        log(\"CVTypeSectionImpl.createContent() verifying that all types have been defined\");\n+        builder.verifyAllClassesDefined();\n+        log(\"CVTypeSectionImpl.createContent() start\");\n         pos = CVUtil.putInt(CV_SIGNATURE_C13, null, pos);\n         for (CVTypeRecord record : typeMap.values()) {\n             pos = record.computeFullSize(pos);\n         }\n         byte[] buffer = new byte[pos];\n         super.setContent(buffer);\n-        log(debugContext, \"CVTypeSectionImpl.createContent() end\");\n+        log(\"CVTypeSectionImpl.createContent() end\");\n     }\n \n     @Override\n     public void writeContent(DebugContext debugContext) {\n         int pos = 0;\n         enableLog(debugContext);\n-        log(debugContext, \"CVTypeSectionImpl.writeContent() start\");\n+        log(\"CVTypeSectionImpl.writeContent() start\");\n         byte[] buffer = getContent();\n-        verboseLog(debugContext, \"  [0x%08x] CV_SIGNATURE_C13\", pos);\n+        verboseLog(\"  [0x%08x] CV_SIGNATURE_C13\", pos);\n         pos = CVUtil.putInt(CV_SIGNATURE_C13, buffer, pos);\n         for (CVTypeRecord record : typeMap.values()) {\n-            verboseLog(debugContext, \"  [0x%08x] 0x%06x %s\", pos, record.getSequenceNumber(), record.toString());\n+            verboseLog(\"  [0x%08x] 0x%06x %s\", pos, record.getSequenceNumber(), record.toString());\n             pos = record.computeFullContents(buffer, pos);\n         }\n-        verboseLog(debugContext, \"CVTypeSectionImpl.writeContent() end\");\n-    }\n-\n-    /**\n-     * Add all relevant type records to the type section.\n-     */\n-    private void addRecords() {\n-        /* if an external PDB file is generated, add CVTypeServer2Record */\n-        /* for each class, add all members, types, etc */\n+        verboseLog(\"CVTypeSectionImpl.writeContent() end\");\n     }\n \n     /**\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk4NzY5Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r459987697", "body": "```suggestion\r\n        /* Files are added to this record during function record building. */\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    /* file are added to this record during function record building. */\n          \n          \n            \n                    /* Files are added to this record during function record building. */", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-c\"><span class=\"pl-c\">/*</span> <span class=\"x x-first x-last\">file</span> are added to this record during function record building. <span class=\"pl-c\">*/</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-c\"><span class=\"pl-c\">/*</span> <span class=\"x x-first x-last\">Files</span> are added to this record during function record building. <span class=\"pl-c\">*/</span></span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pejovica", "createdAt": "2020-07-24T11:04:31Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import com.oracle.objectfile.io.Utf8;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Set;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SIGNATURE_C13;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SYMBOL_SECTION_NAME;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.TEXT_SECTION_NAME;\n+\n+public final class CVSymbolSectionImpl extends CVSectionImpl {\n+\n+    private static final int CV_VECTOR_DEFAULT_SIZE = 200;\n+    private static final int CV_STRINGTABLE_DEFAULT_SIZE = 200;\n+\n+    private CVDebugInfo cvDebugInfo;\n+\n+    private ArrayList<CVSymbolRecord> cvRecords = new ArrayList<>(CV_VECTOR_DEFAULT_SIZE);\n+    private CVStringTable stringTable = new CVStringTable(CV_STRINGTABLE_DEFAULT_SIZE);\n+    private CVFileTableRecord fileTableRecord = new CVFileTableRecord(cvDebugInfo, stringTable);\n+\n+    CVSymbolSectionImpl(CVDebugInfo cvDebugInfo) {\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    @Override\n+    public String getSectionName() {\n+        return CV_SYMBOL_SECTION_NAME;\n+    }\n+\n+    /*\n+     * Any (there may be sewveral) CodeView symbol section (\"debug$S\") is actually a list of\n+     * records, some of which containing sub-records.\n+     */\n+    @Override\n+    public void createContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() adding records\");\n+        addRecords(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() start\");\n+        /* Add header size. */\n+        pos += Integer.BYTES;\n+        /* Add sum of all record sizes. */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            pos = record.computeFullSize(pos);\n+        }\n+        /* Create a buffer that holds it all. */\n+        byte[] buffer = new byte[pos];\n+        super.setContent(buffer);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() end\");\n+    }\n+\n+    @Override\n+    public void writeContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() start recordcount=%d\", cvRecords.size());\n+        byte[] buffer = getContent();\n+        /* Write section header. */\n+        verboseLog(debugContext, \"  [0x%08x] CV_SIGNATURE_C13\", pos);\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, buffer, pos);\n+        /* Write all records. */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            verboseLog(debugContext, \"  [0x%08x] %s\", pos, record.toString());\n+            record.logContents(debugContext);\n+            pos = record.computeFullContents(buffer, pos);\n+        }\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() end\");\n+    }\n+\n+    private void addRecords(DebugContext debugContext) {\n+        addPrologueRecord();\n+        addFunctionRecords(debugContext);\n+        addFileRecord();\n+        addStringTableRecord();\n+    }\n+\n+    private void addPrologueRecord() {\n+        CVSymbolSubsection prologue = new CVSymbolSubsection(cvDebugInfo);\n+        CVSymbolSubrecord.CVObjectNameRecord objectNameRecord = new CVSymbolSubrecord.CVObjectNameRecord(cvDebugInfo);\n+        if (objectNameRecord.isValid()) {\n+            prologue.addRecord(objectNameRecord);\n+        }\n+        prologue.addRecord(new CVSymbolSubrecord.CVCompile3Record(cvDebugInfo));\n+        prologue.addRecord(new CVSymbolSubrecord.CVEnvBlockRecord(cvDebugInfo));\n+        addRecord(prologue);\n+    }\n+\n+    private void addFunctionRecords(DebugContext debugContext) {\n+        /* This will build and add many records for each function. */\n+        new CVSymbolSubsectionBuilder(cvDebugInfo).build(debugContext);\n+    }\n+\n+    private void addFileRecord() {\n+        /* file are added to this record during function record building. */", "originalCommit": "46d1056558f8ff5a1e7004219de75a046c063991", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI0MTUzNg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460241536", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-07-24T19:16:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk4NzY5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\nindex 5c3f64ee5c4..ecf1a17c870 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n", "chunk": "@@ -133,7 +127,7 @@ public final class CVSymbolSectionImpl extends CVSectionImpl {\n     }\n \n     private void addFileRecord() {\n-        /* file are added to this record during function record building. */\n+        /* Files are added to this record during function record building. */\n         addRecord(fileTableRecord);\n     }\n \n", "next_change": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\nindex ecf1a17c870..694e3bf7c7d 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n", "chunk": "@@ -81,49 +81,49 @@ public final class CVSymbolSectionImpl extends CVSectionImpl {\n         /* Create a buffer that holds it all. */\n         byte[] buffer = new byte[pos];\n         super.setContent(buffer);\n-        log(debugContext, \"CVSymbolSectionImpl.createContent() end\");\n+        log(\"CVSymbolSectionImpl.createContent() end\");\n     }\n \n     @Override\n     public void writeContent(DebugContext debugContext) {\n         int pos = 0;\n         enableLog(debugContext);\n-        log(debugContext, \"CVSymbolSectionImpl.writeContent() start recordcount=%d\", cvRecords.size());\n+        log(\"CVSymbolSectionImpl.writeContent() start recordcount=%d\", cvRecords.size());\n         byte[] buffer = getContent();\n         /* Write section header. */\n-        log(debugContext, \"  [0x%08x] CV_SIGNATURE_C13\", pos);\n+        log(\"  [0x%08x] CV_SIGNATURE_C13\", pos);\n         pos = CVUtil.putInt(CV_SIGNATURE_C13, buffer, pos);\n         /* Write all records. */\n         for (CVSymbolRecord record : cvRecords) {\n             pos = CVUtil.align4(pos);\n-            log(debugContext, \"  [0x%08x] %s\", pos, record.toString());\n+            log(\"  [0x%08x] %s\", pos, record.toString());\n             record.logContents(debugContext);\n             pos = record.computeFullContents(buffer, pos);\n         }\n-        log(debugContext, \"CVSymbolSectionImpl.writeContent() end\");\n+        log(\"CVSymbolSectionImpl.writeContent() end\");\n     }\n \n-    private void addRecords(DebugContext debugContext) {\n+    private void addRecords() {\n         addPrologueRecord();\n-        addFunctionRecords(debugContext);\n+        addFunctionRecords();\n         addFileRecord();\n         addStringTableRecord();\n     }\n \n     private void addPrologueRecord() {\n-        CVSymbolSubsection prologue = new CVSymbolSubsection(cvDebugInfo);\n-        CVSymbolSubrecord.CVObjectNameRecord objectNameRecord = new CVSymbolSubrecord.CVObjectNameRecord(cvDebugInfo);\n+        CVSymbolSubsection prologue = new CVSymbolSubsection(getCvDebugInfo());\n+        CVSymbolSubrecord.CVObjectNameRecord objectNameRecord = new CVSymbolSubrecord.CVObjectNameRecord(getCvDebugInfo());\n         if (objectNameRecord.isValid()) {\n             prologue.addRecord(objectNameRecord);\n         }\n-        prologue.addRecord(new CVSymbolSubrecord.CVCompile3Record(cvDebugInfo));\n-        prologue.addRecord(new CVSymbolSubrecord.CVEnvBlockRecord(cvDebugInfo));\n+        prologue.addRecord(new CVSymbolSubrecord.CVCompile3Record(getCvDebugInfo()));\n+        prologue.addRecord(new CVSymbolSubrecord.CVEnvBlockRecord(getCvDebugInfo()));\n         addRecord(prologue);\n     }\n \n-    private void addFunctionRecords(DebugContext debugContext) {\n+    private void addFunctionRecords() {\n         /* This will build and add many records for each function. */\n-        new CVSymbolSubsectionBuilder(cvDebugInfo).build(debugContext);\n+        new CVSymbolSubsectionBuilder(getCvDebugInfo()).build();\n     }\n \n     private void addFileRecord() {\n", "next_change": null}, {"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\nindex ecf1a17c870..694e3bf7c7d 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n", "chunk": "@@ -136,7 +136,7 @@ public final class CVSymbolSectionImpl extends CVSectionImpl {\n     }\n \n     private void addStringTableRecord() {\n-        CVSymbolRecord stringTableRecord = new CVStringTableRecord(cvDebugInfo, stringTable);\n+        CVSymbolRecord stringTableRecord = new CVStringTableRecord(getCvDebugInfo(), stringTable);\n         addRecord(stringTableRecord);\n     }\n \n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk5NTk3OQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r459995979", "body": "You could also update `CVUtil.putUTF8StringBytes` so that when `buffer` is `null` it uses `Utf8.utf8Length`.\r\n```suggestion\r\n                currentOffset = CVUtil.putUTF8StringBytes(s, null, currentOffset);\r\n```", "bodyText": "You could also update CVUtil.putUTF8StringBytes so that when buffer is null it uses Utf8.utf8Length.\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            currentOffset += Utf8.utf8Length(s) + 1;\n          \n          \n            \n                            currentOffset = CVUtil.putUTF8StringBytes(s, null, currentOffset);", "bodyHTML": "<p dir=\"auto\">You could also update <code>CVUtil.putUTF8StringBytes</code> so that when <code>buffer</code> is <code>null</code> it uses <code>Utf8.utf8Length</code>.</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"168\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                currentOffset <span class=\"pl-k x x-first\">+=</span><span class=\"x\"> </span><span class=\"pl-smi x\">Utf8</span><span class=\"pl-k x\">.</span><span class=\"x\">utf8Length(s) </span><span class=\"pl-k x\">+</span><span class=\"x\"> </span><span class=\"pl-c1 x x-last\">1</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"168\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                currentOffset <span class=\"pl-k x x-first\">=</span><span class=\"x\"> </span><span class=\"pl-smi x\">CVUtil</span><span class=\"pl-k x\">.</span><span class=\"x\">putUTF8StringBytes(s, </span><span class=\"pl-c1 x\">null</span><span class=\"x x-last\">, currentOffset)</span>;</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pejovica", "createdAt": "2020-07-24T11:25:51Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import com.oracle.objectfile.io.Utf8;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Set;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SIGNATURE_C13;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SYMBOL_SECTION_NAME;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.TEXT_SECTION_NAME;\n+\n+public final class CVSymbolSectionImpl extends CVSectionImpl {\n+\n+    private static final int CV_VECTOR_DEFAULT_SIZE = 200;\n+    private static final int CV_STRINGTABLE_DEFAULT_SIZE = 200;\n+\n+    private CVDebugInfo cvDebugInfo;\n+\n+    private ArrayList<CVSymbolRecord> cvRecords = new ArrayList<>(CV_VECTOR_DEFAULT_SIZE);\n+    private CVStringTable stringTable = new CVStringTable(CV_STRINGTABLE_DEFAULT_SIZE);\n+    private CVFileTableRecord fileTableRecord = new CVFileTableRecord(cvDebugInfo, stringTable);\n+\n+    CVSymbolSectionImpl(CVDebugInfo cvDebugInfo) {\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    @Override\n+    public String getSectionName() {\n+        return CV_SYMBOL_SECTION_NAME;\n+    }\n+\n+    /*\n+     * Any (there may be sewveral) CodeView symbol section (\"debug$S\") is actually a list of\n+     * records, some of which containing sub-records.\n+     */\n+    @Override\n+    public void createContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() adding records\");\n+        addRecords(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() start\");\n+        /* Add header size. */\n+        pos += Integer.BYTES;\n+        /* Add sum of all record sizes. */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            pos = record.computeFullSize(pos);\n+        }\n+        /* Create a buffer that holds it all. */\n+        byte[] buffer = new byte[pos];\n+        super.setContent(buffer);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() end\");\n+    }\n+\n+    @Override\n+    public void writeContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() start recordcount=%d\", cvRecords.size());\n+        byte[] buffer = getContent();\n+        /* Write section header. */\n+        verboseLog(debugContext, \"  [0x%08x] CV_SIGNATURE_C13\", pos);\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, buffer, pos);\n+        /* Write all records. */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            verboseLog(debugContext, \"  [0x%08x] %s\", pos, record.toString());\n+            record.logContents(debugContext);\n+            pos = record.computeFullContents(buffer, pos);\n+        }\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() end\");\n+    }\n+\n+    private void addRecords(DebugContext debugContext) {\n+        addPrologueRecord();\n+        addFunctionRecords(debugContext);\n+        addFileRecord();\n+        addStringTableRecord();\n+    }\n+\n+    private void addPrologueRecord() {\n+        CVSymbolSubsection prologue = new CVSymbolSubsection(cvDebugInfo);\n+        CVSymbolSubrecord.CVObjectNameRecord objectNameRecord = new CVSymbolSubrecord.CVObjectNameRecord(cvDebugInfo);\n+        if (objectNameRecord.isValid()) {\n+            prologue.addRecord(objectNameRecord);\n+        }\n+        prologue.addRecord(new CVSymbolSubrecord.CVCompile3Record(cvDebugInfo));\n+        prologue.addRecord(new CVSymbolSubrecord.CVEnvBlockRecord(cvDebugInfo));\n+        addRecord(prologue);\n+    }\n+\n+    private void addFunctionRecords(DebugContext debugContext) {\n+        /* This will build and add many records for each function. */\n+        new CVSymbolSubsectionBuilder(cvDebugInfo).build(debugContext);\n+    }\n+\n+    private void addFileRecord() {\n+        /* file are added to this record during function record building. */\n+        addRecord(fileTableRecord);\n+    }\n+\n+    CVFileTableRecord getFileTableRecord() {\n+        return this.fileTableRecord;\n+    }\n+\n+    private void addStringTableRecord() {\n+        CVSymbolRecord stringTableRecord = new CVStringTableRecord(cvDebugInfo, stringTable);\n+        addRecord(stringTableRecord);\n+    }\n+\n+    static final class CVStringTable {\n+        static final class StringTableEntry {\n+            public int offset;\n+            public String text;\n+\n+            StringTableEntry(int offset, String text) {\n+                this.offset = offset;\n+                this.text = text;\n+            }\n+        }\n+\n+        /* Use LinkedHashMap so order is maintained when writing string table. */\n+        private final HashMap<String, StringTableEntry> strings;\n+        private int currentOffset = 0;\n+\n+        CVStringTable(int startSize) {\n+            strings = new LinkedHashMap<>(startSize);\n+            /* Ensure that the empty string has index 0. */\n+            add(\"\");\n+        }\n+\n+        int add(String s) {\n+            StringTableEntry newEntry = new StringTableEntry(currentOffset, s);\n+            StringTableEntry entry = strings.putIfAbsent(s, newEntry);\n+            if (entry == null) {\n+                currentOffset += Utf8.utf8Length(s) + 1;", "originalCommit": "46d1056558f8ff5a1e7004219de75a046c063991", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI0NzIwMg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460247202", "bodyText": "I've changed CVUtil.putUTF8StringBytes() as per this suggestion, but I think changing this particular call to use a code emitting function (even if no code is emitted) obscures the algorithm.", "author": "stooke", "createdAt": "2020-07-24T19:28:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk5NTk3OQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk5ODcwOQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r459998709", "body": "As in `CVTypeSectionImpl`, this may be unnecessary.", "bodyText": "As in CVTypeSectionImpl, this may be unnecessary.", "bodyHTML": "<p dir=\"auto\">As in <code>CVTypeSectionImpl</code>, this may be unnecessary.</p>", "author": "pejovica", "createdAt": "2020-07-24T11:32:52Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import com.oracle.objectfile.io.Utf8;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Set;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SIGNATURE_C13;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SYMBOL_SECTION_NAME;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.TEXT_SECTION_NAME;\n+\n+public final class CVSymbolSectionImpl extends CVSectionImpl {\n+\n+    private static final int CV_VECTOR_DEFAULT_SIZE = 200;\n+    private static final int CV_STRINGTABLE_DEFAULT_SIZE = 200;\n+\n+    private CVDebugInfo cvDebugInfo;\n+\n+    private ArrayList<CVSymbolRecord> cvRecords = new ArrayList<>(CV_VECTOR_DEFAULT_SIZE);\n+    private CVStringTable stringTable = new CVStringTable(CV_STRINGTABLE_DEFAULT_SIZE);\n+    private CVFileTableRecord fileTableRecord = new CVFileTableRecord(cvDebugInfo, stringTable);\n+\n+    CVSymbolSectionImpl(CVDebugInfo cvDebugInfo) {\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    @Override\n+    public String getSectionName() {\n+        return CV_SYMBOL_SECTION_NAME;\n+    }\n+\n+    /*\n+     * Any (there may be sewveral) CodeView symbol section (\"debug$S\") is actually a list of\n+     * records, some of which containing sub-records.\n+     */\n+    @Override\n+    public void createContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() adding records\");\n+        addRecords(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() start\");\n+        /* Add header size. */\n+        pos += Integer.BYTES;\n+        /* Add sum of all record sizes. */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            pos = record.computeFullSize(pos);\n+        }\n+        /* Create a buffer that holds it all. */\n+        byte[] buffer = new byte[pos];\n+        super.setContent(buffer);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() end\");\n+    }\n+\n+    @Override\n+    public void writeContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() start recordcount=%d\", cvRecords.size());\n+        byte[] buffer = getContent();\n+        /* Write section header. */\n+        verboseLog(debugContext, \"  [0x%08x] CV_SIGNATURE_C13\", pos);\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, buffer, pos);\n+        /* Write all records. */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            verboseLog(debugContext, \"  [0x%08x] %s\", pos, record.toString());\n+            record.logContents(debugContext);\n+            pos = record.computeFullContents(buffer, pos);\n+        }\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() end\");\n+    }\n+\n+    private void addRecords(DebugContext debugContext) {\n+        addPrologueRecord();\n+        addFunctionRecords(debugContext);\n+        addFileRecord();\n+        addStringTableRecord();\n+    }\n+\n+    private void addPrologueRecord() {\n+        CVSymbolSubsection prologue = new CVSymbolSubsection(cvDebugInfo);\n+        CVSymbolSubrecord.CVObjectNameRecord objectNameRecord = new CVSymbolSubrecord.CVObjectNameRecord(cvDebugInfo);\n+        if (objectNameRecord.isValid()) {\n+            prologue.addRecord(objectNameRecord);\n+        }\n+        prologue.addRecord(new CVSymbolSubrecord.CVCompile3Record(cvDebugInfo));\n+        prologue.addRecord(new CVSymbolSubrecord.CVEnvBlockRecord(cvDebugInfo));\n+        addRecord(prologue);\n+    }\n+\n+    private void addFunctionRecords(DebugContext debugContext) {\n+        /* This will build and add many records for each function. */\n+        new CVSymbolSubsectionBuilder(cvDebugInfo).build(debugContext);\n+    }\n+\n+    private void addFileRecord() {\n+        /* file are added to this record during function record building. */\n+        addRecord(fileTableRecord);\n+    }\n+\n+    CVFileTableRecord getFileTableRecord() {\n+        return this.fileTableRecord;\n+    }\n+\n+    private void addStringTableRecord() {\n+        CVSymbolRecord stringTableRecord = new CVStringTableRecord(cvDebugInfo, stringTable);\n+        addRecord(stringTableRecord);\n+    }\n+\n+    static final class CVStringTable {\n+        static final class StringTableEntry {\n+            public int offset;\n+            public String text;\n+\n+            StringTableEntry(int offset, String text) {\n+                this.offset = offset;\n+                this.text = text;\n+            }\n+        }\n+\n+        /* Use LinkedHashMap so order is maintained when writing string table. */\n+        private final HashMap<String, StringTableEntry> strings;\n+        private int currentOffset = 0;\n+\n+        CVStringTable(int startSize) {\n+            strings = new LinkedHashMap<>(startSize);\n+            /* Ensure that the empty string has index 0. */\n+            add(\"\");\n+        }\n+\n+        int add(String s) {\n+            StringTableEntry newEntry = new StringTableEntry(currentOffset, s);\n+            StringTableEntry entry = strings.putIfAbsent(s, newEntry);\n+            if (entry == null) {\n+                currentOffset += Utf8.utf8Length(s) + 1;\n+            }\n+            return entry == null ? newEntry.offset : entry.offset;\n+        }\n+\n+        Collection<StringTableEntry> values() {\n+            return strings.values();\n+        }\n+\n+        int size() {\n+            return strings.size();\n+        }\n+\n+        int getCurrentOffset() {\n+            return currentOffset;\n+        }\n+    }\n+\n+    void addRecord(CVSymbolRecord record) {\n+        cvRecords.add(record);\n+    }\n+\n+    @Override\n+    public Set<BuildDependency> getDependencies(Map<ObjectFile.Element, LayoutDecisionMap> decisions) {\n+        Set<BuildDependency> deps = super.getDependencies(decisions);\n+        PECoffObjectFile.PECoffSection targetSection = (PECoffObjectFile.PECoffSection) getElement().getOwner().elementForName(TEXT_SECTION_NAME);\n+        LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n+        LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n+        /* Make our content depend on the compiled code (.text) section. */\n+        deps.add(BuildDependency.createOrGet(ourContent, decisions.get(targetSection).getDecision(LayoutDecision.Kind.CONTENT)));\n+        /* Make our size depend on our content. */\n+        deps.add(BuildDependency.createOrGet(ourSize, ourContent));", "originalCommit": "46d1056558f8ff5a1e7004219de75a046c063991", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI0MjA1Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460242057", "bodyText": "Removed.", "author": "stooke", "createdAt": "2020-07-24T19:17:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk5ODcwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\nindex 5c3f64ee5c4..ecf1a17c870 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n", "chunk": "@@ -192,17 +186,4 @@ public final class CVSymbolSectionImpl extends CVSectionImpl {\n     void addRecord(CVSymbolRecord record) {\n         cvRecords.add(record);\n     }\n-\n-    @Override\n-    public Set<BuildDependency> getDependencies(Map<ObjectFile.Element, LayoutDecisionMap> decisions) {\n-        Set<BuildDependency> deps = super.getDependencies(decisions);\n-        PECoffObjectFile.PECoffSection targetSection = (PECoffObjectFile.PECoffSection) getElement().getOwner().elementForName(TEXT_SECTION_NAME);\n-        LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n-        LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n-        /* Make our content depend on the compiled code (.text) section. */\n-        deps.add(BuildDependency.createOrGet(ourContent, decisions.get(targetSection).getDecision(LayoutDecision.Kind.CONTENT)));\n-        /* Make our size depend on our content. */\n-        deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n-        return deps;\n-    }\n }\n", "next_change": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\nindex ecf1a17c870..694e3bf7c7d 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n", "chunk": "@@ -186,4 +186,27 @@ public final class CVSymbolSectionImpl extends CVSectionImpl {\n     void addRecord(CVSymbolRecord record) {\n         cvRecords.add(record);\n     }\n+\n+    /**\n+     * Mark an offset:segment relocation site for linker or loader fixup.\n+     *\n+     * @param buffer output buffer\n+     * @param initialPos position of fixup in output buffer\n+     * @param offset offset to add to the fixup\n+     * @param symbolName symbolname to reference\n+     * @return new position in output buffer\n+     */\n+    public int markRelocationSite(byte[] buffer, int initialPos, String symbolName, Long offset) {\n+        int pos = initialPos;\n+        if (buffer != null) {\n+            markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, symbolName, offset);\n+            pos += ObjectFile.RelocationKind.getRelocationSize(ObjectFile.RelocationKind.SECREL_4);\n+            markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, symbolName, 0);\n+            pos += ObjectFile.RelocationKind.getRelocationSize(ObjectFile.RelocationKind.SECTION_2);\n+        } else {\n+            pos = CVUtil.putInt(0, buffer, pos);\n+            pos = CVUtil.putShort((short) 0, buffer, pos);\n+        }\n+        return pos;\n+    }\n }\n", "next_change": {"commit": "be97e8b0b377da7184398ae13748683d31424624", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\nindex 694e3bf7c7d..456adceeb6c 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n", "chunk": "@@ -192,21 +192,31 @@ public final class CVSymbolSectionImpl extends CVSectionImpl {\n      *\n      * @param buffer output buffer\n      * @param initialPos position of fixup in output buffer\n-     * @param offset offset to add to the fixup\n      * @param symbolName symbolname to reference\n      * @return new position in output buffer\n      */\n-    public int markRelocationSite(byte[] buffer, int initialPos, String symbolName, Long offset) {\n-        int pos = initialPos;\n+    public int markRelocationSite(byte[] buffer, int initialPos, String symbolName) {\n+        return markRelocationSite(buffer, initialPos, symbolName, 0);\n+    }\n+\n+    /**\n+     * Mark an offset:segment + offset relocation site for linker or loader fixup.\n+     *\n+     * @param buffer output buffer\n+     * @param initialPos position of fixup in output buffer\n+     * @param symbolName symbolname to reference\n+     * @param offset offset from symbol\n+     * @return new position in output buffer\n+     */\n+    public int markRelocationSite(byte[] buffer, int initialPos, String symbolName, long offset) {\n+        int pos = markRelocationSite(buffer, initialPos, symbolName, RelocationKind.SECREL_4, offset);\n+        return markRelocationSite(buffer, pos, symbolName, RelocationKind.SECTION_2, 0);\n+    }\n+\n+    private int markRelocationSite(byte[] buffer, int initialPos, String symbolName, RelocationKind kind, long offset) {\n         if (buffer != null) {\n-            markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, symbolName, offset);\n-            pos += ObjectFile.RelocationKind.getRelocationSize(ObjectFile.RelocationKind.SECREL_4);\n-            markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, symbolName, 0);\n-            pos += ObjectFile.RelocationKind.getRelocationSize(ObjectFile.RelocationKind.SECTION_2);\n-        } else {\n-            pos = CVUtil.putInt(0, buffer, pos);\n-            pos = CVUtil.putShort((short) 0, buffer, pos);\n+            markRelocationSite(initialPos, kind, symbolName, offset);\n         }\n-        return pos;\n+        return initialPos + RelocationKind.getRelocationSize(kind);\n     }\n }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAyMjE2NA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460022164", "body": "This should be unnecessary as the elment is already set in `PECoffObjectFile.newUserDefinedSection`.", "bodyText": "This should be unnecessary as the elment is already set in PECoffObjectFile.newUserDefinedSection.", "bodyHTML": "<p dir=\"auto\">This should be unnecessary as the elment is already set in <code>PECoffObjectFile.newUserDefinedSection</code>.</p>", "author": "pejovica", "createdAt": "2020-07-24T12:29:51Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/PECoffObjectFile.java", "diffHunk": "@@ -683,4 +688,42 @@ public PECoffRelocationTable getRelocationTable() {\n     protected int getMinimumFileSize() {\n         return 0;\n     }\n+\n+    @Override\n+    public Section newDebugSection(String name, ElementImpl impl) {\n+        PECoffSection coffSection = (PECoffSection) super.newDebugSection(name, impl);\n+        coffSection.getFlags().add(PECoffSectionFlag.DISCARDABLE);\n+        coffSection.getFlags().add(PECoffSectionFlag.READ);\n+        coffSection.getFlags().add(PECoffSectionFlag.INITIALIZED_DATA);\n+        impl.setElement(coffSection);", "originalCommit": "46d1056558f8ff5a1e7004219de75a046c063991", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI1MTQ0Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460251447", "bodyText": "I believe you're right.  The call to setElement() is gone.", "author": "stooke", "createdAt": "2020-07-24T19:37:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAyMjE2NA=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/PECoffObjectFile.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/PECoffObjectFile.java\nindex 199199d15f0..138ad8457e3 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/PECoffObjectFile.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/PECoffObjectFile.java\n", "chunk": "@@ -695,7 +695,6 @@ public class PECoffObjectFile extends ObjectFile {\n         coffSection.getFlags().add(PECoffSectionFlag.DISCARDABLE);\n         coffSection.getFlags().add(PECoffSectionFlag.READ);\n         coffSection.getFlags().add(PECoffSectionFlag.INITIALIZED_DATA);\n-        impl.setElement(coffSection);\n         return coffSection;\n     }\n \n", "next_change": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/PECoffObjectFile.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/PECoffObjectFile.java\nindex 138ad8457e3..4f48b7762c9 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/PECoffObjectFile.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/PECoffObjectFile.java\n", "chunk": "@@ -700,7 +700,7 @@ public class PECoffObjectFile extends ObjectFile {\n \n     @Override\n     public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n-        CVDebugInfo cvDebugInfo = new CVDebugInfo(getByteOrder());\n+        CVDebugInfo cvDebugInfo = new CVDebugInfo(getMachine(), getByteOrder());\n \n         // we need an implementation for each section\n         CVSymbolSectionImpl cvSymbolSectionImpl = cvDebugInfo.getCVSymbolSection();\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAyMzczNQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460023735", "body": "Isn't it enough that `ObjectFile.newDebugSection` already sets the allignment to `1`?", "bodyText": "Isn't it enough that ObjectFile.newDebugSection already sets the allignment to 1?", "bodyHTML": "<p dir=\"auto\">Isn't it enough that <code>ObjectFile.newDebugSection</code> already sets the allignment to <code>1</code>?</p>", "author": "pejovica", "createdAt": "2020-07-24T12:33:16Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+abstract class CVSectionImpl extends BasicProgbitsSectionImpl {\n+\n+    boolean debug = false;\n+\n+    CVSectionImpl() {\n+    }\n+\n+    @Override\n+    public void setElement(ObjectFile.Element e) {\n+        super.setElement(e);\n+        /* Define the section as a COFF symbol. */\n+        getOwner().createDefinedSymbol(getSectionName(), getElement(), 0, 0, false, false);\n+    }\n+\n+    private String debugSectionLogName() {\n+        /*\n+         * Log messages for the symbol section will be enabled using \"PeCoffdebug$S\". Log messages\n+         * for the type section will be enabled using \"PeCoffdebug$T\".\n+         */\n+        assert getSectionName().startsWith(CVConstants.CV_SECTION_NAME_PREFIX);\n+        return \"PeCoff\" + getSectionName().replace(\".\", \"\");\n+    }\n+\n+    protected void enableLog(DebugContext context) {\n+        /*\n+         * Unlike in the Dwarf debug code, debug output may be enabled in both the sizing and\n+         * writing phases. (Currently turned off in the sizing state)\n+         */\n+        if (context.areScopesEnabled()) {\n+            debug = true;\n+        }\n+    }\n+\n+    @Override\n+    public int getAlignment() {\n+        return 1;", "originalCommit": "46d1056558f8ff5a1e7004219de75a046c063991", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI4NzMzNw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460287337", "bodyText": "Gone.", "author": "stooke", "createdAt": "2020-07-24T21:04:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAyMzczNQ=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java\nindex 7d0544bc9a3..a149e38c99c 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java\n", "chunk": "@@ -69,11 +62,6 @@ abstract class CVSectionImpl extends BasicProgbitsSectionImpl {\n         }\n     }\n \n-    @Override\n-    public int getAlignment() {\n-        return 1;\n-    }\n-\n     protected void log(DebugContext context, String format, Object... args) {\n         if (debug) {\n             context.logv(DebugContext.INFO_LEVEL, format, args);\n", "next_change": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java\nindex a149e38c99c..945111fc4c3 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java\n", "chunk": "@@ -52,25 +62,26 @@ abstract class CVSectionImpl extends BasicProgbitsSectionImpl {\n         return \"PeCoff\" + getSectionName().replace(\".\", \"\");\n     }\n \n-    protected void enableLog(DebugContext context) {\n+    protected void enableLog(DebugContext debugContext) {\n         /*\n          * Unlike in the Dwarf debug code, debug output may be enabled in both the sizing and\n          * writing phases. (Currently turned off in the sizing state)\n          */\n-        if (context.areScopesEnabled()) {\n+        cvDebugInfo.setDebugContext(debugContext);\n+        if (debugContext.areScopesEnabled()) {\n             debug = true;\n         }\n     }\n \n-    protected void log(DebugContext context, String format, Object... args) {\n+    protected void log(String format, Object... args) {\n         if (debug) {\n-            context.logv(DebugContext.INFO_LEVEL, format, args);\n+            getDebugContext().logv(DebugContext.INFO_LEVEL, format, args);\n         }\n     }\n \n-    protected void verboseLog(DebugContext context, String format, Object... args) {\n+    protected void verboseLog(String format, Object... args) {\n         if (debug) {\n-            context.logv(DebugContext.VERBOSE_LEVEL, format, args);\n+            getDebugContext().logv(DebugContext.VERBOSE_LEVEL, format, args);\n         }\n     }\n \n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEyMDkxNg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460120916", "body": "It might make sense to change `computeFullSize` like this and remove `computeSize` completely as it doesn't seem to be needed anymore.\r\n```suggestion\r\n        return computeFullContents(null, initialPos);\r\n```", "bodyText": "It might make sense to change computeFullSize like this and remove computeSize completely as it doesn't seem to be needed anymore.\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    int prologueLength = Short.BYTES * 2; /* Room for length and subcommand. */\n          \n          \n            \n                    return computeSize(initialPos + prologueLength);\n          \n          \n            \n                    return computeFullContents(null, initialPos);", "bodyHTML": "<p dir=\"auto\">It might make sense to change <code>computeFullSize</code> like this and remove <code>computeSize</code> completely as it doesn't seem to be needed anymore.</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">int</span> prologueLength <span class=\"pl-k\">=</span> <span class=\"pl-smi\">Short</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>BYTES</span> <span class=\"pl-k\">*</span> <span class=\"pl-c1\">2</span>; <span class=\"pl-c\"><span class=\"pl-c\">/*</span> Room for length and subcommand. <span class=\"pl-c\">*/</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">return</span> computeSize(initialPos <span class=\"pl-k\">+</span> prologueLength);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">return</span> computeFullContents(<span class=\"pl-c1\">null</span>, initialPos);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pejovica", "createdAt": "2020-07-24T15:20:46Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,426 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file.\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.subrecordStartPosition = initialPos;\n+        int prologueLength = Short.BYTES * 2; /* Room for length and subcommand. */\n+        return computeSize(initialPos + prologueLength);", "originalCommit": "46d1056558f8ff5a1e7004219de75a046c063991", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI0MTQ0NQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460241445", "bodyText": "The intent was that computeSize() could be a quick calculation, but the reality (in this class at least) is that manually keeping track of size was a source of errors.  Changed.", "author": "stooke", "createdAt": "2020-07-24T19:15:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEyMDkxNg=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex b7fb25890e1..ddb43d1039c 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -47,15 +47,10 @@ abstract class CVSymbolSubrecord {\n         this.cmd = cmd;\n     }\n \n-    int computeFullSize(int initialPos) {\n-        this.subrecordStartPosition = initialPos;\n-        int prologueLength = Short.BYTES * 2; /* Room for length and subcommand. */\n-        return computeSize(initialPos + prologueLength);\n-    }\n-\n-    int computeFullContents(byte[] buffer, int initialPos) {\n+    final int computeFullContents(byte[] buffer, int initialPos) {\n+        subrecordStartPosition = initialPos;\n         int pos = initialPos;\n-        pos += Short.BYTES; /* Save room for length (no including length bytes). */\n+        pos += Short.BYTES; /* Save room for length (not including length bytes). */\n         pos = CVUtil.putShort(cmd, buffer, pos);\n         pos = computeContents(buffer, pos);\n         short length = (short) (pos - initialPos - Short.BYTES);\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEzMjQ2Mg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460132462", "body": "```suggestion\r\n                textSection = cvDebugInfo.getCVSymbolSection().getOwner().elementForName(TEXT_SECTION_NAME);\r\n```\r\nAlso, why not change `textSection` to be an instance field? Then you wouldn't even need `getTextSection`.", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            textSection = cvDebugInfo.getCVSymbolSection().getOwner().elementForName(SectionName.TEXT.getFormatDependentName(ObjectFile.Format.PECOFF));\n          \n          \n            \n                            textSection = cvDebugInfo.getCVSymbolSection().getOwner().elementForName(TEXT_SECTION_NAME);\n          \n      \n    \n    \n  \n\nAlso, why not change textSection to be an instance field? Then you wouldn't even need getTextSection.", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                textSection <span class=\"pl-k\">=</span> cvDebugInfo<span class=\"pl-k\">.</span>getCVSymbolSection()<span class=\"pl-k\">.</span>getOwner()<span class=\"pl-k\">.</span>elementForName(<span class=\"pl-smi x x-first\">SectionName</span><span class=\"pl-c1\"><span class=\"pl-k x\">.</span><span class=\"x\">TEXT</span></span><span class=\"pl-k x\">.</span><span class=\"x\">getFormatDependentName(</span><span class=\"pl-smi x\">ObjectFile</span><span class=\"pl-k x\">.</span><span class=\"pl-smi x\">Format</span><span class=\"pl-c1\"><span class=\"pl-k x\">.</span><span class=\"x\">PECOFF</span></span><span class=\"x x-last\">)</span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                textSection <span class=\"pl-k\">=</span> cvDebugInfo<span class=\"pl-k\">.</span>getCVSymbolSection()<span class=\"pl-k\">.</span>getOwner()<span class=\"pl-k\">.</span>elementForName(<span class=\"pl-c1 x x-first x-last\">TEXT_SECTION_NAME</span>);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n\n<p dir=\"auto\">Also, why not change <code>textSection</code> to be an instance field? Then you wouldn't even need <code>getTextSection</code>.</p>", "author": "pejovica", "createdAt": "2020-07-24T15:40:12Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,426 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file.\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.subrecordStartPosition = initialPos;\n+        int prologueLength = Short.BYTES * 2; /* Room for length and subcommand. */\n+        return computeSize(initialPos + prologueLength);\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* Save room for length (no including length bytes). */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(cmd=0x%04x pos=0x%06x)\", cmd, subrecordStartPosition);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeSize(int pos);\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* find the full path to object file we will produce. */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Extrapolate object filename from first class definition. */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* Signature is currently set to 0. */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos); /*\n+                                                                    * This string is inline null\n+                                                                    * terminated.\n+                                                                    */\n+            return pos;\n+        }\n+    }\n+\n+    public static final class CVCompile3Record extends CVSymbolSubrecord {\n+\n+        private static final byte HAS_DEBUG_FLAG = 0;\n+        @SuppressWarnings(\"unused\") private static final byte HAS_NO_DEBUG_FLAG = (byte) 0x80;\n+\n+        private byte language;\n+        private byte cf1;\n+        private byte cf2;\n+        private byte padding;\n+        private short machine;\n+        private short feMajor;\n+        private short feMinor;\n+        private short feBuild;\n+        private short feQFE;\n+        private short beMajor;\n+        private short beMinor;\n+        private short beBuild;\n+        private short beQFE;\n+        private String compiler;\n+\n+        CVCompile3Record(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_COMPILE3);\n+            language = 0;\n+            cf1 = HAS_DEBUG_FLAG;\n+            cf2 = (byte) 0;\n+            padding = (byte) 0;\n+            machine = (short) 208;\n+            feMajor = (short) 2;\n+            feMinor = (short) 3;\n+            feBuild = (short) 4;\n+            feQFE = (short) 5;\n+            beMajor = (short) 6;\n+            beMinor = (short) 7;\n+            beBuild = (short) 8;\n+            beQFE = (short) 9;\n+            compiler = \"graal\";\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putByte(language, buffer, initialPos);\n+            pos = CVUtil.putByte(cf1, buffer, pos);\n+            pos = CVUtil.putByte(cf2, buffer, pos);\n+            pos = CVUtil.putByte(padding, buffer, pos);\n+            pos = CVUtil.putShort(machine, buffer, pos);\n+            pos = CVUtil.putShort(feMajor, buffer, pos);\n+            pos = CVUtil.putShort(feMinor, buffer, pos);\n+            pos = CVUtil.putShort(feBuild, buffer, pos);\n+            pos = CVUtil.putShort(feQFE, buffer, pos);\n+            pos = CVUtil.putShort(beMajor, buffer, pos);\n+            pos = CVUtil.putShort(beMinor, buffer, pos);\n+            pos = CVUtil.putShort(beBuild, buffer, pos);\n+            pos = CVUtil.putShort(beQFE, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(compiler, buffer, pos);  // inline null terminated\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_COMPILE3 machine=%d fe=%d.%d.%d.%d be=%d.%d.%d%d compiler=%s\", machine, feMajor, feMinor, feBuild, feQFE, beMajor, beMinor, beBuild, beQFE, compiler);\n+        }\n+    }\n+\n+    public static final class CVEnvBlockRecord extends CVSymbolSubrecord {\n+\n+        private static final int ENVMAP_INITIAL_CAPACITY = 10;\n+\n+        private Map<String, String> map = new HashMap<>(ENVMAP_INITIAL_CAPACITY);\n+\n+        /*-\n+         * Example contents of the environment block:\n+         *   cwd = C:\\tmp\\graal-8\n+         *   cl = C:\\tmp\\graal-8\\ojdkbuild\\tools\\toolchain\\vs2010e\\VC\\Bin\\x86_amd64\\cl.exe\n+         *   cmd = -Zi -MT -IC:\\tmp\\graal-8\\tools\\toolchain\\vs2010e\\VC\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE\\gl -TC -X\n+         *   src = helloworld.c\n+         *   pdb = C:\\tmp\\graal-8\\vc100.pdb\n+         */\n+        CVEnvBlockRecord(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_ENVBLOCK);\n+\n+            /* Current directory. */\n+            map.put(\"cwd\", System.getProperty(\"user.dir\"));\n+\n+            /*\n+             * Find first source file - which, for Graal would be a class file on the command line.\n+             */\n+            String fn = findFirstFile(cvDebugInfo);\n+            if (fn != null) {\n+                map.put(\"src\", fn);\n+            }\n+        }\n+\n+        private static String findFirstFile(CVDebugInfo cvDebugInfo) {\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            /* Flags. */\n+            int pos = CVUtil.putByte((byte) 0, buffer, initialPos);\n+\n+            /* Key/value pairs. */\n+            for (Map.Entry<String, String> entry : map.entrySet()) {\n+                pos = CVUtil.putUTF8StringBytes(entry.getKey(), buffer, pos);\n+                pos = CVUtil.putUTF8StringBytes(entry.getValue(), buffer, pos);\n+            }\n+\n+            /* End marker. */\n+            pos = CVUtil.putUTF8StringBytes(\"\", buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"S_ENVBLOCK \" + map.size() + \" entries\";\n+        }\n+    }\n+\n+    /*\n+     * Creating a proc32 record has side effects: a global symbol is added to the COFF symbol\n+     * section, and two relocation entries are added to the section relocation table, they refer\n+     * back to the global symbol.\n+     */\n+    public static class CVSymbolGProc32Record extends CVSymbolSubrecord {\n+\n+        private static ObjectFile.Element textSection;\n+\n+        int pparent;\n+        int pend;\n+        int pnext;\n+        int proclen;\n+        int debugStart;\n+        int debugEnd;\n+        int typeIndex;\n+        int offset;\n+        short segment;\n+        byte flags;\n+        String name;\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, short cmd, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment,\n+                        byte flags) {\n+            super(cvDebugInfo, cmd);\n+            this.name = name;\n+            this.pparent = pparent;\n+            this.pend = pend;\n+            this.pnext = pnext;\n+            this.proclen = proclen;\n+            this.debugStart = debugStart;\n+            this.debugEnd = debugEnd;\n+            this.typeIndex = typeIndex;\n+            this.offset = offset;\n+            this.segment = segment;\n+            this.flags = flags;\n+        }\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment, byte flags) {\n+            this(cvDebugInfo, CVDebugConstants.S_GPROC32, name, pparent, pend, pnext, proclen, debugStart, debugEnd, typeIndex, offset, segment, flags);\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(pparent, buffer, initialPos);\n+            pos = CVUtil.putInt(pend, buffer, pos);\n+            pos = CVUtil.putInt(pnext, buffer, pos);\n+            pos = CVUtil.putInt(proclen, buffer, pos);\n+            pos = CVUtil.putInt(debugStart, buffer, pos);\n+            pos = CVUtil.putInt(debugEnd, buffer, pos);\n+            pos = CVUtil.putInt(typeIndex, buffer, pos);\n+            if (buffer == null) {\n+                cvDebugInfo.getCVSymbolSection().getOwner().createDefinedSymbol(name, getTextSection(), offset, proclen, true, true);\n+            }\n+            if (buffer != null) {\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 4, ObjectFile.RelocationKind.SECREL, name, false, 1L);\n+            }\n+            pos = CVUtil.putInt(0, buffer, pos);\n+            if (buffer != null) {\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 2, ObjectFile.RelocationKind.SECTION, name, false, 1L);\n+            }\n+            pos = CVUtil.putShort((short) 0, buffer, pos);\n+            pos = CVUtil.putByte(flags, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(name, buffer, pos);\n+            return pos;\n+        }\n+\n+        private ObjectFile.Element getTextSection() {\n+            if (textSection == null) {\n+                textSection = cvDebugInfo.getCVSymbolSection().getOwner().elementForName(SectionName.TEXT.getFormatDependentName(ObjectFile.Format.PECOFF));", "originalCommit": "46d1056558f8ff5a1e7004219de75a046c063991", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI2OTcyMg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460269722", "bodyText": "I've changed the code to use CvConstants.TEXT_SECTION_NAME, but I have kept it a global static for performance reasons: elementForName() does a HashMap lookup..", "author": "stooke", "createdAt": "2020-07-24T20:21:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEzMjQ2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex b7fb25890e1..ddb43d1039c 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -318,34 +296,23 @@ abstract class CVSymbolSubrecord {\n             pos = CVUtil.putInt(debugStart, buffer, pos);\n             pos = CVUtil.putInt(debugEnd, buffer, pos);\n             pos = CVUtil.putInt(typeIndex, buffer, pos);\n-            if (buffer == null) {\n-                cvDebugInfo.getCVSymbolSection().getOwner().createDefinedSymbol(name, getTextSection(), offset, proclen, true, true);\n-            }\n             if (buffer != null) {\n-                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 4, ObjectFile.RelocationKind.SECREL, name, false, 1L);\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, externalName, false, 1L);\n             }\n             pos = CVUtil.putInt(0, buffer, pos);\n             if (buffer != null) {\n-                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 2, ObjectFile.RelocationKind.SECTION, name, false, 1L);\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, externalName, false, 1L);\n             }\n             pos = CVUtil.putShort((short) 0, buffer, pos);\n             pos = CVUtil.putByte(flags, buffer, pos);\n-            pos = CVUtil.putUTF8StringBytes(name, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(debuggerName, buffer, pos);\n             return pos;\n         }\n \n-        private ObjectFile.Element getTextSection() {\n-            if (textSection == null) {\n-                textSection = cvDebugInfo.getCVSymbolSection().getOwner().elementForName(SectionName.TEXT.getFormatDependentName(ObjectFile.Format.PECOFF));\n-            }\n-            return textSection;\n-        }\n-\n         @Override\n         public String toString() {\n-            return String.format(\"S_GPROC32   name=%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", name, pparent, debugStart, debugEnd, proclen, offset,\n-                            typeIndex,\n-                            flags);\n+            return String.format(\"S_GPROC32   name=%s/%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", debuggerName, externalName, pparent, debugStart, debugEnd,\n+                            proclen, offset, typeIndex, flags);\n         }\n     }\n \n", "next_change": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex ddb43d1039c..0a30db69e94 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -296,35 +295,28 @@ abstract class CVSymbolSubrecord {\n             pos = CVUtil.putInt(debugStart, buffer, pos);\n             pos = CVUtil.putInt(debugEnd, buffer, pos);\n             pos = CVUtil.putInt(typeIndex, buffer, pos);\n-            if (buffer != null) {\n-                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, externalName, false, 1L);\n-            }\n-            pos = CVUtil.putInt(0, buffer, pos);\n-            if (buffer != null) {\n-                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, externalName, false, 1L);\n-            }\n-            pos = CVUtil.putShort((short) 0, buffer, pos);\n+            pos = cvDebugInfo.getCVSymbolSection().markRelocationSite(buffer, pos, symbolName, (long) 0);\n             pos = CVUtil.putByte(flags, buffer, pos);\n-            pos = CVUtil.putUTF8StringBytes(debuggerName, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(displayName, buffer, pos);\n             return pos;\n         }\n \n         @Override\n         public String toString() {\n-            return String.format(\"S_GPROC32   name=%s/%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", debuggerName, externalName, pparent, debugStart, debugEnd,\n-                            proclen, offset, typeIndex, flags);\n+            return String.format(\"S_GPROC32   name=%s/%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x seg:offset=0x%x:0x%x type=0x%x flags=0x%x)\", displayName, symbolName, pparent, debugStart, debugEnd,\n+                            proclen, segment, offset, typeIndex, flags);\n         }\n     }\n \n     public static final class CVSymbolFrameProcRecord extends CVSymbolSubrecord {\n \n-        int framelen;\n-        int padLen;\n-        int padOffset;\n-        int saveRegsCount;\n-        int ehOffset;\n-        short ehSection;\n-        int flags;\n+        private final int framelen;\n+        private final int padLen;\n+        private final int padOffset;\n+        private final int saveRegsCount;\n+        private final int ehOffset;\n+        private final short ehSection;\n+        private final int flags;\n \n         CVSymbolFrameProcRecord(CVDebugInfo cvDebugInfo, int framelen, int padLen, int padOffset, int saveRegsCount, int ehOffset, short ehSection, int flags) {\n             super(cvDebugInfo, CVDebugConstants.S_FRAMEPROC);\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEzNzYzNQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460137635", "body": "```suggestion\r\n                            typeIndex, flags);\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        typeIndex,\n          \n          \n            \n                                        flags);\n          \n          \n            \n                                        typeIndex, flags);", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                            typeIndex,</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                            flags);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                            typeIndex, flags);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pejovica", "createdAt": "2020-07-24T15:48:58Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,426 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file.\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.subrecordStartPosition = initialPos;\n+        int prologueLength = Short.BYTES * 2; /* Room for length and subcommand. */\n+        return computeSize(initialPos + prologueLength);\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* Save room for length (no including length bytes). */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(cmd=0x%04x pos=0x%06x)\", cmd, subrecordStartPosition);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeSize(int pos);\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* find the full path to object file we will produce. */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Extrapolate object filename from first class definition. */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* Signature is currently set to 0. */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos); /*\n+                                                                    * This string is inline null\n+                                                                    * terminated.\n+                                                                    */\n+            return pos;\n+        }\n+    }\n+\n+    public static final class CVCompile3Record extends CVSymbolSubrecord {\n+\n+        private static final byte HAS_DEBUG_FLAG = 0;\n+        @SuppressWarnings(\"unused\") private static final byte HAS_NO_DEBUG_FLAG = (byte) 0x80;\n+\n+        private byte language;\n+        private byte cf1;\n+        private byte cf2;\n+        private byte padding;\n+        private short machine;\n+        private short feMajor;\n+        private short feMinor;\n+        private short feBuild;\n+        private short feQFE;\n+        private short beMajor;\n+        private short beMinor;\n+        private short beBuild;\n+        private short beQFE;\n+        private String compiler;\n+\n+        CVCompile3Record(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_COMPILE3);\n+            language = 0;\n+            cf1 = HAS_DEBUG_FLAG;\n+            cf2 = (byte) 0;\n+            padding = (byte) 0;\n+            machine = (short) 208;\n+            feMajor = (short) 2;\n+            feMinor = (short) 3;\n+            feBuild = (short) 4;\n+            feQFE = (short) 5;\n+            beMajor = (short) 6;\n+            beMinor = (short) 7;\n+            beBuild = (short) 8;\n+            beQFE = (short) 9;\n+            compiler = \"graal\";\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putByte(language, buffer, initialPos);\n+            pos = CVUtil.putByte(cf1, buffer, pos);\n+            pos = CVUtil.putByte(cf2, buffer, pos);\n+            pos = CVUtil.putByte(padding, buffer, pos);\n+            pos = CVUtil.putShort(machine, buffer, pos);\n+            pos = CVUtil.putShort(feMajor, buffer, pos);\n+            pos = CVUtil.putShort(feMinor, buffer, pos);\n+            pos = CVUtil.putShort(feBuild, buffer, pos);\n+            pos = CVUtil.putShort(feQFE, buffer, pos);\n+            pos = CVUtil.putShort(beMajor, buffer, pos);\n+            pos = CVUtil.putShort(beMinor, buffer, pos);\n+            pos = CVUtil.putShort(beBuild, buffer, pos);\n+            pos = CVUtil.putShort(beQFE, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(compiler, buffer, pos);  // inline null terminated\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_COMPILE3 machine=%d fe=%d.%d.%d.%d be=%d.%d.%d%d compiler=%s\", machine, feMajor, feMinor, feBuild, feQFE, beMajor, beMinor, beBuild, beQFE, compiler);\n+        }\n+    }\n+\n+    public static final class CVEnvBlockRecord extends CVSymbolSubrecord {\n+\n+        private static final int ENVMAP_INITIAL_CAPACITY = 10;\n+\n+        private Map<String, String> map = new HashMap<>(ENVMAP_INITIAL_CAPACITY);\n+\n+        /*-\n+         * Example contents of the environment block:\n+         *   cwd = C:\\tmp\\graal-8\n+         *   cl = C:\\tmp\\graal-8\\ojdkbuild\\tools\\toolchain\\vs2010e\\VC\\Bin\\x86_amd64\\cl.exe\n+         *   cmd = -Zi -MT -IC:\\tmp\\graal-8\\tools\\toolchain\\vs2010e\\VC\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE\\gl -TC -X\n+         *   src = helloworld.c\n+         *   pdb = C:\\tmp\\graal-8\\vc100.pdb\n+         */\n+        CVEnvBlockRecord(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_ENVBLOCK);\n+\n+            /* Current directory. */\n+            map.put(\"cwd\", System.getProperty(\"user.dir\"));\n+\n+            /*\n+             * Find first source file - which, for Graal would be a class file on the command line.\n+             */\n+            String fn = findFirstFile(cvDebugInfo);\n+            if (fn != null) {\n+                map.put(\"src\", fn);\n+            }\n+        }\n+\n+        private static String findFirstFile(CVDebugInfo cvDebugInfo) {\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            /* Flags. */\n+            int pos = CVUtil.putByte((byte) 0, buffer, initialPos);\n+\n+            /* Key/value pairs. */\n+            for (Map.Entry<String, String> entry : map.entrySet()) {\n+                pos = CVUtil.putUTF8StringBytes(entry.getKey(), buffer, pos);\n+                pos = CVUtil.putUTF8StringBytes(entry.getValue(), buffer, pos);\n+            }\n+\n+            /* End marker. */\n+            pos = CVUtil.putUTF8StringBytes(\"\", buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"S_ENVBLOCK \" + map.size() + \" entries\";\n+        }\n+    }\n+\n+    /*\n+     * Creating a proc32 record has side effects: a global symbol is added to the COFF symbol\n+     * section, and two relocation entries are added to the section relocation table, they refer\n+     * back to the global symbol.\n+     */\n+    public static class CVSymbolGProc32Record extends CVSymbolSubrecord {\n+\n+        private static ObjectFile.Element textSection;\n+\n+        int pparent;\n+        int pend;\n+        int pnext;\n+        int proclen;\n+        int debugStart;\n+        int debugEnd;\n+        int typeIndex;\n+        int offset;\n+        short segment;\n+        byte flags;\n+        String name;\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, short cmd, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment,\n+                        byte flags) {\n+            super(cvDebugInfo, cmd);\n+            this.name = name;\n+            this.pparent = pparent;\n+            this.pend = pend;\n+            this.pnext = pnext;\n+            this.proclen = proclen;\n+            this.debugStart = debugStart;\n+            this.debugEnd = debugEnd;\n+            this.typeIndex = typeIndex;\n+            this.offset = offset;\n+            this.segment = segment;\n+            this.flags = flags;\n+        }\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment, byte flags) {\n+            this(cvDebugInfo, CVDebugConstants.S_GPROC32, name, pparent, pend, pnext, proclen, debugStart, debugEnd, typeIndex, offset, segment, flags);\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(pparent, buffer, initialPos);\n+            pos = CVUtil.putInt(pend, buffer, pos);\n+            pos = CVUtil.putInt(pnext, buffer, pos);\n+            pos = CVUtil.putInt(proclen, buffer, pos);\n+            pos = CVUtil.putInt(debugStart, buffer, pos);\n+            pos = CVUtil.putInt(debugEnd, buffer, pos);\n+            pos = CVUtil.putInt(typeIndex, buffer, pos);\n+            if (buffer == null) {\n+                cvDebugInfo.getCVSymbolSection().getOwner().createDefinedSymbol(name, getTextSection(), offset, proclen, true, true);\n+            }\n+            if (buffer != null) {\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 4, ObjectFile.RelocationKind.SECREL, name, false, 1L);\n+            }\n+            pos = CVUtil.putInt(0, buffer, pos);\n+            if (buffer != null) {\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 2, ObjectFile.RelocationKind.SECTION, name, false, 1L);\n+            }\n+            pos = CVUtil.putShort((short) 0, buffer, pos);\n+            pos = CVUtil.putByte(flags, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(name, buffer, pos);\n+            return pos;\n+        }\n+\n+        private ObjectFile.Element getTextSection() {\n+            if (textSection == null) {\n+                textSection = cvDebugInfo.getCVSymbolSection().getOwner().elementForName(SectionName.TEXT.getFormatDependentName(ObjectFile.Format.PECOFF));\n+            }\n+            return textSection;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_GPROC32   name=%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", name, pparent, debugStart, debugEnd, proclen, offset,\n+                            typeIndex,\n+                            flags);", "originalCommit": "46d1056558f8ff5a1e7004219de75a046c063991", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI0MTMxNw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460241317", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-07-24T19:15:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEzNzYzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex b7fb25890e1..ddb43d1039c 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -318,34 +296,23 @@ abstract class CVSymbolSubrecord {\n             pos = CVUtil.putInt(debugStart, buffer, pos);\n             pos = CVUtil.putInt(debugEnd, buffer, pos);\n             pos = CVUtil.putInt(typeIndex, buffer, pos);\n-            if (buffer == null) {\n-                cvDebugInfo.getCVSymbolSection().getOwner().createDefinedSymbol(name, getTextSection(), offset, proclen, true, true);\n-            }\n             if (buffer != null) {\n-                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 4, ObjectFile.RelocationKind.SECREL, name, false, 1L);\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, externalName, false, 1L);\n             }\n             pos = CVUtil.putInt(0, buffer, pos);\n             if (buffer != null) {\n-                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 2, ObjectFile.RelocationKind.SECTION, name, false, 1L);\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, externalName, false, 1L);\n             }\n             pos = CVUtil.putShort((short) 0, buffer, pos);\n             pos = CVUtil.putByte(flags, buffer, pos);\n-            pos = CVUtil.putUTF8StringBytes(name, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(debuggerName, buffer, pos);\n             return pos;\n         }\n \n-        private ObjectFile.Element getTextSection() {\n-            if (textSection == null) {\n-                textSection = cvDebugInfo.getCVSymbolSection().getOwner().elementForName(SectionName.TEXT.getFormatDependentName(ObjectFile.Format.PECOFF));\n-            }\n-            return textSection;\n-        }\n-\n         @Override\n         public String toString() {\n-            return String.format(\"S_GPROC32   name=%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", name, pparent, debugStart, debugEnd, proclen, offset,\n-                            typeIndex,\n-                            flags);\n+            return String.format(\"S_GPROC32   name=%s/%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", debuggerName, externalName, pparent, debugStart, debugEnd,\n+                            proclen, offset, typeIndex, flags);\n         }\n     }\n \n", "next_change": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex ddb43d1039c..0a30db69e94 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -296,35 +295,28 @@ abstract class CVSymbolSubrecord {\n             pos = CVUtil.putInt(debugStart, buffer, pos);\n             pos = CVUtil.putInt(debugEnd, buffer, pos);\n             pos = CVUtil.putInt(typeIndex, buffer, pos);\n-            if (buffer != null) {\n-                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, externalName, false, 1L);\n-            }\n-            pos = CVUtil.putInt(0, buffer, pos);\n-            if (buffer != null) {\n-                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, externalName, false, 1L);\n-            }\n-            pos = CVUtil.putShort((short) 0, buffer, pos);\n+            pos = cvDebugInfo.getCVSymbolSection().markRelocationSite(buffer, pos, symbolName, (long) 0);\n             pos = CVUtil.putByte(flags, buffer, pos);\n-            pos = CVUtil.putUTF8StringBytes(debuggerName, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(displayName, buffer, pos);\n             return pos;\n         }\n \n         @Override\n         public String toString() {\n-            return String.format(\"S_GPROC32   name=%s/%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", debuggerName, externalName, pparent, debugStart, debugEnd,\n-                            proclen, offset, typeIndex, flags);\n+            return String.format(\"S_GPROC32   name=%s/%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x seg:offset=0x%x:0x%x type=0x%x flags=0x%x)\", displayName, symbolName, pparent, debugStart, debugEnd,\n+                            proclen, segment, offset, typeIndex, flags);\n         }\n     }\n \n     public static final class CVSymbolFrameProcRecord extends CVSymbolSubrecord {\n \n-        int framelen;\n-        int padLen;\n-        int padOffset;\n-        int saveRegsCount;\n-        int ehOffset;\n-        short ehSection;\n-        int flags;\n+        private final int framelen;\n+        private final int padLen;\n+        private final int padOffset;\n+        private final int saveRegsCount;\n+        private final int ehOffset;\n+        private final short ehSection;\n+        private final int flags;\n \n         CVSymbolFrameProcRecord(CVDebugInfo cvDebugInfo, int framelen, int padLen, int padOffset, int saveRegsCount, int ehOffset, short ehSection, int flags) {\n             super(cvDebugInfo, CVDebugConstants.S_FRAMEPROC);\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NTg3NA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460145874", "body": "Given its formatting, I think we can remove this comment. \ud83d\ude09\r\n```suggestion\r\n            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos);\r\n```", "bodyText": "Given its formatting, I think we can remove this comment. \ud83d\ude09\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        pos = CVUtil.putUTF8StringBytes(objName, buffer, pos); /*\n          \n          \n            \n                                                                                * This string is inline null\n          \n          \n            \n                                                                                * terminated.\n          \n          \n            \n                                                                                */\n          \n          \n            \n                        pos = CVUtil.putUTF8StringBytes(objName, buffer, pos);", "bodyHTML": "<p dir=\"auto\">Given its formatting, I think we can remove this comment. <g-emoji class=\"g-emoji\" alias=\"wink\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f609.png\">\ud83d\ude09</g-emoji></p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            pos <span class=\"pl-k\">=</span> <span class=\"pl-smi\">CVUtil</span><span class=\"pl-k\">.</span>putUTF8StringBytes(objName, buffer, pos); <span class=\"pl-c\"><span class=\"pl-c\">/*</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                                                                    <span class=\"pl-k\">*</span> <span class=\"pl-smi\">This</span> string is inline <span class=\"pl-c1\">null</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                                                                    <span class=\"pl-k\">*</span> terminated.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                                                                    <span class=\"pl-k\">*/</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            pos <span class=\"pl-k\">=</span> <span class=\"pl-smi\">CVUtil</span><span class=\"pl-k\">.</span>putUTF8StringBytes(objName, buffer, pos);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pejovica", "createdAt": "2020-07-24T16:02:52Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,426 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file.\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.subrecordStartPosition = initialPos;\n+        int prologueLength = Short.BYTES * 2; /* Room for length and subcommand. */\n+        return computeSize(initialPos + prologueLength);\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* Save room for length (no including length bytes). */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(cmd=0x%04x pos=0x%06x)\", cmd, subrecordStartPosition);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeSize(int pos);\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* find the full path to object file we will produce. */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Extrapolate object filename from first class definition. */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* Signature is currently set to 0. */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos); /*\n+                                                                    * This string is inline null\n+                                                                    * terminated.\n+                                                                    */", "originalCommit": "46d1056558f8ff5a1e7004219de75a046c063991", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI0MTM2Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460241367", "bodyText": "Yes, this was the eclipse formatter.  Gone.", "author": "stooke", "createdAt": "2020-07-24T19:15:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NTg3NA=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex b7fb25890e1..ddb43d1039c 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -112,20 +105,17 @@ abstract class CVSymbolSubrecord {\n             return objName != null;\n         }\n \n-        @Override\n-        protected int computeSize(int initialPos) {\n-            return computeContents(null, initialPos);\n-        }\n-\n         @Override\n         protected int computeContents(byte[] buffer, int initialPos) {\n             int pos = CVUtil.putInt(0, buffer, initialPos); /* Signature is currently set to 0. */\n-            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos); /*\n-                                                                    * This string is inline null\n-                                                                    * terminated.\n-                                                                    */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos);\n             return pos;\n         }\n+\n+        @Override\n+        public String toString() {\n+            return \"S_OBJNAME \" + objName;\n+        }\n     }\n \n     public static final class CVCompile3Record extends CVSymbolSubrecord {\n", "next_change": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex ddb43d1039c..0a30db69e94 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -123,20 +122,20 @@ abstract class CVSymbolSubrecord {\n         private static final byte HAS_DEBUG_FLAG = 0;\n         @SuppressWarnings(\"unused\") private static final byte HAS_NO_DEBUG_FLAG = (byte) 0x80;\n \n-        private byte language;\n-        private byte cf1;\n-        private byte cf2;\n-        private byte padding;\n-        private short machine;\n-        private short feMajor;\n-        private short feMinor;\n-        private short feBuild;\n-        private short feQFE;\n-        private short beMajor;\n-        private short beMinor;\n-        private short beBuild;\n-        private short beQFE;\n-        private String compiler;\n+        private final byte language;\n+        private final byte cf1;\n+        private final byte cf2;\n+        private final byte padding;\n+        private final short machine;\n+        private final short feMajor;\n+        private final short feMinor;\n+        private final short feBuild;\n+        private final short feQFE;\n+        private final short beMajor;\n+        private final short beMinor;\n+        private final short beBuild;\n+        private final short beQFE;\n+        private final String compiler;\n \n         CVCompile3Record(CVDebugInfo cvDebugInfo) {\n             super(cvDebugInfo, CVDebugConstants.S_COMPILE3);\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE1MTU3OQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460151579", "body": "I suppose this should ideally be the source file of the class with the main method, right?", "bodyText": "I suppose this should ideally be the source file of the class with the main method, right?", "bodyHTML": "<p dir=\"auto\">I suppose this should ideally be the source file of the class with the main method, right?</p>", "author": "pejovica", "createdAt": "2020-07-24T16:12:58Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,426 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file.\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.subrecordStartPosition = initialPos;\n+        int prologueLength = Short.BYTES * 2; /* Room for length and subcommand. */\n+        return computeSize(initialPos + prologueLength);\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* Save room for length (no including length bytes). */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(cmd=0x%04x pos=0x%06x)\", cmd, subrecordStartPosition);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeSize(int pos);\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* find the full path to object file we will produce. */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Extrapolate object filename from first class definition. */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* Signature is currently set to 0. */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos); /*\n+                                                                    * This string is inline null\n+                                                                    * terminated.\n+                                                                    */\n+            return pos;\n+        }\n+    }\n+\n+    public static final class CVCompile3Record extends CVSymbolSubrecord {\n+\n+        private static final byte HAS_DEBUG_FLAG = 0;\n+        @SuppressWarnings(\"unused\") private static final byte HAS_NO_DEBUG_FLAG = (byte) 0x80;\n+\n+        private byte language;\n+        private byte cf1;\n+        private byte cf2;\n+        private byte padding;\n+        private short machine;\n+        private short feMajor;\n+        private short feMinor;\n+        private short feBuild;\n+        private short feQFE;\n+        private short beMajor;\n+        private short beMinor;\n+        private short beBuild;\n+        private short beQFE;\n+        private String compiler;\n+\n+        CVCompile3Record(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_COMPILE3);\n+            language = 0;\n+            cf1 = HAS_DEBUG_FLAG;\n+            cf2 = (byte) 0;\n+            padding = (byte) 0;\n+            machine = (short) 208;\n+            feMajor = (short) 2;\n+            feMinor = (short) 3;\n+            feBuild = (short) 4;\n+            feQFE = (short) 5;\n+            beMajor = (short) 6;\n+            beMinor = (short) 7;\n+            beBuild = (short) 8;\n+            beQFE = (short) 9;\n+            compiler = \"graal\";\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putByte(language, buffer, initialPos);\n+            pos = CVUtil.putByte(cf1, buffer, pos);\n+            pos = CVUtil.putByte(cf2, buffer, pos);\n+            pos = CVUtil.putByte(padding, buffer, pos);\n+            pos = CVUtil.putShort(machine, buffer, pos);\n+            pos = CVUtil.putShort(feMajor, buffer, pos);\n+            pos = CVUtil.putShort(feMinor, buffer, pos);\n+            pos = CVUtil.putShort(feBuild, buffer, pos);\n+            pos = CVUtil.putShort(feQFE, buffer, pos);\n+            pos = CVUtil.putShort(beMajor, buffer, pos);\n+            pos = CVUtil.putShort(beMinor, buffer, pos);\n+            pos = CVUtil.putShort(beBuild, buffer, pos);\n+            pos = CVUtil.putShort(beQFE, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(compiler, buffer, pos);  // inline null terminated\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_COMPILE3 machine=%d fe=%d.%d.%d.%d be=%d.%d.%d%d compiler=%s\", machine, feMajor, feMinor, feBuild, feQFE, beMajor, beMinor, beBuild, beQFE, compiler);\n+        }\n+    }\n+\n+    public static final class CVEnvBlockRecord extends CVSymbolSubrecord {\n+\n+        private static final int ENVMAP_INITIAL_CAPACITY = 10;\n+\n+        private Map<String, String> map = new HashMap<>(ENVMAP_INITIAL_CAPACITY);\n+\n+        /*-\n+         * Example contents of the environment block:\n+         *   cwd = C:\\tmp\\graal-8\n+         *   cl = C:\\tmp\\graal-8\\ojdkbuild\\tools\\toolchain\\vs2010e\\VC\\Bin\\x86_amd64\\cl.exe\n+         *   cmd = -Zi -MT -IC:\\tmp\\graal-8\\tools\\toolchain\\vs2010e\\VC\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE\\gl -TC -X\n+         *   src = helloworld.c\n+         *   pdb = C:\\tmp\\graal-8\\vc100.pdb\n+         */\n+        CVEnvBlockRecord(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_ENVBLOCK);\n+\n+            /* Current directory. */\n+            map.put(\"cwd\", System.getProperty(\"user.dir\"));\n+\n+            /*\n+             * Find first source file - which, for Graal would be a class file on the command line.\n+             */\n+            String fn = findFirstFile(cvDebugInfo);", "originalCommit": "46d1056558f8ff5a1e7004219de75a046c063991", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI3NTA1MQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460275051", "bodyText": "Yes, if there is actually a main().  I could imagine there might not be a main() if Graal were set up to build a library.\nI have expanded the comment.", "author": "stooke", "createdAt": "2020-07-24T20:34:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE1MTU3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM0MzEyMA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r462343120", "bodyText": "In that case, I think the actual main method (if any) should also be passed in to CVDebugInfo via DebugInfoProvider, but that can wait for the rework you mentioned.", "author": "pejovica", "createdAt": "2020-07-29T14:28:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE1MTU3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex b7fb25890e1..ddb43d1039c 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -217,7 +202,10 @@ abstract class CVSymbolSubrecord {\n             map.put(\"cwd\", System.getProperty(\"user.dir\"));\n \n             /*\n-             * Find first source file - which, for Graal would be a class file on the command line.\n+             * Define the primary source file - ideally, the source file containing main(). (Note\n+             * that if Graal were to be used to compile a library, there may not be a main()). Since\n+             * Graal doesn't work with java source files, use the source file associated with the\n+             * first class that has a source file.\n              */\n             String fn = findFirstFile(cvDebugInfo);\n             if (fn != null) {\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE2MjMyNg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460162326", "body": "```suggestion\r\n        return computeContents(null, initialPos);\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    int pos = initialPos;\n          \n          \n            \n                    for (CVSymbolSubrecord subcmd : subcmds) {\n          \n          \n            \n                        pos = subcmd.computeFullSize(pos);\n          \n          \n            \n                    }\n          \n          \n            \n                    return pos;\n          \n          \n            \n                    return computeContents(null, initialPos);", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">int</span> pos <span class=\"pl-k\">=</span> initialPos;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">for</span> (<span class=\"pl-smi\">CVSymbolSubrecord</span> subcmd <span class=\"pl-k\">:</span> subcmds) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            pos <span class=\"pl-k\">=</span> subcmd<span class=\"pl-k\">.</span>computeFullSize(pos);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">return</span> pos;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">return</span> computeContents(<span class=\"pl-c1\">null</span>, initialPos);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pejovica", "createdAt": "2020-07-24T16:33:44Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsection.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A CVSymbolSubsection is s special record in debug$S containing nested symbol records.\n+ * (the nested records inherit from CVSymbolSubrecord)\n+ */\n+class CVSymbolSubsection extends CVSymbolRecord {\n+\n+    private static final int SUBCMD_INITIAL_CAPACITY = 100;\n+\n+    private ArrayList<CVSymbolSubrecord> subcmds = new ArrayList<>(SUBCMD_INITIAL_CAPACITY);\n+\n+    CVSymbolSubsection(CVDebugInfo cvDebugInfo) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_SYMBOLS);\n+    }\n+\n+    void addRecord(CVSymbolSubrecord subcmd) {\n+        subcmds.add(subcmd);\n+    }\n+\n+    @Override\n+    protected int computeSize(int initialPos) {\n+        int pos = initialPos;\n+        for (CVSymbolSubrecord subcmd : subcmds) {\n+            pos = subcmd.computeFullSize(pos);\n+        }\n+        return pos;", "originalCommit": "46d1056558f8ff5a1e7004219de75a046c063991", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI0ODQ1Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460248457", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-07-24T19:31:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE2MjMyNg=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsection.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsection.java\nindex 70619799971..da422e8b689 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsection.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsection.java\n", "chunk": "@@ -50,11 +50,7 @@ class CVSymbolSubsection extends CVSymbolRecord {\n \n     @Override\n     protected int computeSize(int initialPos) {\n-        int pos = initialPos;\n-        for (CVSymbolSubrecord subcmd : subcmds) {\n-            pos = subcmd.computeFullSize(pos);\n-        }\n-        return pos;\n+        return computeContents(null, initialPos);\n     }\n \n     @Override\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ5NDA0NA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r461494044", "body": "I believe you meant the frame size here:\r\n```suggestion\r\n        addToSymbolRecord(new CVSymbolSubrecord.CVSymbolFrameProcRecord(cvDebugInfo, primaryEntry.getFrameSize(), frameFlags));\r\n```", "bodyText": "I believe you meant the frame size here:\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    addToSymbolRecord(new CVSymbolSubrecord.CVSymbolFrameProcRecord(cvDebugInfo, primaryRange.getHi() - primaryRange.getLo(), frameFlags));\n          \n          \n            \n                    addToSymbolRecord(new CVSymbolSubrecord.CVSymbolFrameProcRecord(cvDebugInfo, primaryEntry.getFrameSize(), frameFlags));", "bodyHTML": "<p dir=\"auto\">I believe you meant the frame size here:</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        addToSymbolRecord(<span class=\"pl-k\">new</span> <span class=\"pl-smi\">CVSymbolSubrecord</span>.<span class=\"pl-smi\">CVSymbolFrameProcRecord</span>(cvDebugInfo, <span class=\"x x-first\">primaryRange</span><span class=\"pl-k x\">.</span><span class=\"x\">getHi() </span><span class=\"pl-k x\">-</span><span class=\"x\"> primaryRange</span><span class=\"pl-k x\">.</span><span class=\"x x-last\">getLo</span>(), frameFlags));</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        addToSymbolRecord(<span class=\"pl-k\">new</span> <span class=\"pl-smi\">CVSymbolSubrecord</span>.<span class=\"pl-smi\">CVSymbolFrameProcRecord</span>(cvDebugInfo, <span class=\"x x-first\">primaryEntry</span><span class=\"pl-k x\">.</span><span class=\"x x-last\">getFrameSize</span>(), frameFlags));</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pejovica", "createdAt": "2020-07-28T10:56:58Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.replaceMainFunctionName;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.emitUnadornedMain;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_NOTYPE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_VOID;\n+\n+final class CVSymbolSubsectionBuilder {\n+\n+    private final CVDebugInfo cvDebugInfo;\n+    private final CVSymbolSubsection symbolRecord;\n+    private CVLineRecordBuilder lineRecordBuilder;\n+    private DebugContext debugContext = null;\n+\n+    private boolean noMainFound = true;\n+\n+    CVSymbolSubsectionBuilder(CVDebugInfo cvDebugInfo) {\n+        this.symbolRecord = new CVSymbolSubsection(cvDebugInfo);\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    /**\n+     * Build DEBUG_S_SYMBOLS record from all classEntries. (CodeView 4 format allows us to build one\n+     * per class or one per function or one big record - which is what we do here).\n+     *\n+     * The CodeView symbol section Prolog is also a CVSymbolSubsection, but it is not build in this\n+     * class.\n+     */\n+    void build(DebugContext theDebugContext) {\n+        this.debugContext = theDebugContext;\n+        this.lineRecordBuilder = new CVLineRecordBuilder(debugContext, cvDebugInfo);\n+        /* loop over all classes defined in this module. */\n+        for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+            build(classEntry);\n+        }\n+        cvDebugInfo.getCVSymbolSection().addRecord(symbolRecord);\n+    }\n+\n+    /**\n+     * Build all debug info for a classEntry. (does not yet handle member variables).\n+     *\n+     * @param classEntry current class\n+     */\n+    private void build(ClassEntry classEntry) {\n+        String previousMethodName = \"\";\n+        /* Loop over all functions defined in this class. */\n+        for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+            Range primaryRange = primaryEntry.getPrimary();\n+            String newMethodName = fixMethodName(primaryRange);\n+            if (!newMethodName.equals(previousMethodName)) {\n+                previousMethodName = newMethodName;\n+                build(primaryEntry, newMethodName);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emit records for each function: PROC32 S_FRAMEPROC S_END and line number records. (later:\n+     * type records as required).\n+     *\n+     * @param primaryEntry primary entry for this function\n+     * @param methodName method name alias as it will be seen by the user\n+     */\n+    private void build(PrimaryEntry primaryEntry, String methodName) {\n+        final Range primaryRange = primaryEntry.getPrimary();\n+\n+        /* S_PROC32 add function definition. */\n+        int functionTypeIndex = addTypeRecords(primaryEntry);\n+        byte funcFlags = 0;\n+        CVSymbolSubrecord.CVSymbolGProc32Record proc32 = new CVSymbolSubrecord.CVSymbolGProc32Record(cvDebugInfo, methodName, 0, 0, 0, primaryRange.getHi() - primaryRange.getLo(), 0, 0,\n+                        functionTypeIndex, primaryRange.getLo(), (short) 0, funcFlags);\n+        addToSymbolRecord(proc32);\n+\n+        /* S_FRAMEPROC add frame definitions. */\n+        int asynceh = 1 << 9; /* Async exception handling (vc++ uses 1, clang uses 0). */\n+        int localBP = 1 << 14; /* Local base pointer = SP (0=none, 1=sp, 2=bp 3=r13). */\n+        int paramBP = 1 << 16; /* Param base pointer = SP. */\n+        int frameFlags = asynceh + localBP + paramBP; /* NB: LLVM uses 0x14000. */\n+        addToSymbolRecord(new CVSymbolSubrecord.CVSymbolFrameProcRecord(cvDebugInfo, primaryRange.getHi() - primaryRange.getLo(), frameFlags));", "originalCommit": "26825b7727b0cfbcff2dbf28e7fea03b862493ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQzMjE4MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r466432180", "bodyText": "Good catch.", "author": "stooke", "createdAt": "2020-08-06T13:57:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ5NDA0NA=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\nindex eb254c951c8..f0eac5086e0 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n", "chunk": "@@ -90,42 +82,48 @@ final class CVSymbolSubsectionBuilder {\n      * type records as required).\n      *\n      * @param primaryEntry primary entry for this function\n-     * @param methodName method name alias as it will be seen by the user\n      */\n-    private void build(PrimaryEntry primaryEntry, String methodName) {\n+    private void build(PrimaryEntry primaryEntry) {\n         final Range primaryRange = primaryEntry.getPrimary();\n \n+        /* The name as it will appear in the debugger. */\n+        final String debuggerName = getDebuggerName(primaryRange);\n+\n+        /* The name as exposed to the linker. */\n+        final String externalName = primaryRange.getSymbolName();\n+\n         /* S_PROC32 add function definition. */\n         int functionTypeIndex = addTypeRecords(primaryEntry);\n         byte funcFlags = 0;\n-        CVSymbolSubrecord.CVSymbolGProc32Record proc32 = new CVSymbolSubrecord.CVSymbolGProc32Record(cvDebugInfo, methodName, 0, 0, 0, primaryRange.getHi() - primaryRange.getLo(), 0, 0,\n-                        functionTypeIndex, primaryRange.getLo(), (short) 0, funcFlags);\n-        addToSymbolRecord(proc32);\n+        CVSymbolSubrecord.CVSymbolGProc32Record proc32 = new CVSymbolSubrecord.CVSymbolGProc32Record(cvDebugInfo, externalName, debuggerName, 0, 0, 0, primaryRange.getHi() - primaryRange.getLo(), 0,\n+                        0, functionTypeIndex, primaryRange.getLo(), (short) 0, funcFlags);\n+        addToSymbolSubsection(proc32);\n \n         /* S_FRAMEPROC add frame definitions. */\n         int asynceh = 1 << 9; /* Async exception handling (vc++ uses 1, clang uses 0). */\n         int localBP = 1 << 14; /* Local base pointer = SP (0=none, 1=sp, 2=bp 3=r13). */\n         int paramBP = 1 << 16; /* Param base pointer = SP. */\n         int frameFlags = asynceh + localBP + paramBP; /* NB: LLVM uses 0x14000. */\n-        addToSymbolRecord(new CVSymbolSubrecord.CVSymbolFrameProcRecord(cvDebugInfo, primaryRange.getHi() - primaryRange.getLo(), frameFlags));\n+        addToSymbolSubsection(new CVSymbolSubrecord.CVSymbolFrameProcRecord(cvDebugInfo, primaryEntry.getFrameSize(), frameFlags));\n \n         /* TODO: add local variables, and their types. */\n         /* TODO: add block definitions. */\n \n         /* S_END add end record. */\n-        addToSymbolRecord(new CVSymbolSubrecord.CVSymbolEndRecord(cvDebugInfo));\n-        addLineNumberRecords(primaryEntry, methodName);\n+        addToSymbolSubsection(new CVSymbolSubrecord.CVSymbolEndRecord(cvDebugInfo));\n+\n+        /* Add line number records. */\n+        addLineNumberRecords(primaryEntry);\n     }\n \n     /**\n      * Rename function names for usability or functionality.\n      *\n-     * First encountered main function becomes class.main (unless replaceMainFunctionName is\n-     * non-null). This is for usability.\n+     * First encountered main function becomes class.main. This is for usability.\n      *\n      * All other functions become class.function.999 (where 999 is a hash of the arglist). This is\n      * because The standard link.exe can't handle odd characters (parentheses or commas, for\n-     * example) in debug information, so\n+     * example) in debug information.\n      *\n      * This does not affect external symbols used by linker.\n      *\n", "next_change": {"commit": "77e3a7479e429a3279d3061496d260e35f21f000", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\nindex f0eac5086e0..dd2b8e972f8 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n", "chunk": "@@ -26,126 +26,134 @@\n \n package com.oracle.objectfile.pecoff.cv;\n \n+import com.oracle.objectfile.SectionName;\n import com.oracle.objectfile.debugentry.ClassEntry;\n-import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.CompiledMethodEntry;\n+import com.oracle.objectfile.debugentry.FieldEntry;\n import com.oracle.objectfile.debugentry.Range;\n-import org.graalvm.compiler.debug.DebugContext;\n+import com.oracle.objectfile.debugentry.TypeEntry;\n \n-import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_NOTYPE;\n-import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_VOID;\n+import java.lang.reflect.Modifier;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_AMD64_R8;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.MAX_PRIMITIVE;\n \n final class CVSymbolSubsectionBuilder {\n \n     private final CVDebugInfo cvDebugInfo;\n     private final CVSymbolSubsection cvSymbolSubsection;\n-    private CVLineRecordBuilder lineRecordBuilder;\n-    private DebugContext debugContext = null;\n+    private final CVLineRecordBuilder lineRecordBuilder;\n \n-    private boolean noMainFound = true;\n+    private final String heapName;\n+    private final short heapRegister;\n \n     CVSymbolSubsectionBuilder(CVDebugInfo cvDebugInfo) {\n-        this.cvSymbolSubsection = new CVSymbolSubsection(cvDebugInfo);\n         this.cvDebugInfo = cvDebugInfo;\n+        this.cvSymbolSubsection = new CVSymbolSubsection(cvDebugInfo);\n+        this.lineRecordBuilder = new CVLineRecordBuilder(cvDebugInfo);\n+        this.heapName = SectionName.SVM_HEAP.getFormatDependentName(cvDebugInfo.getCVSymbolSection().getOwner().getFormat());\n+        /* For isolates, Graal currently uses r14; this code will handle r8-r15. */\n+        assert 8 <= cvDebugInfo.getHeapbaseRegister() && cvDebugInfo.getHeapbaseRegister() <= 15;\n+        this.heapRegister = (short) (CV_AMD64_R8 + cvDebugInfo.getHeapbaseRegister() - 8);\n     }\n \n     /**\n      * Build DEBUG_S_SYMBOLS record from all classEntries. (CodeView 4 format allows us to build one\n      * per class or one per function or one big record - which is what we do here).\n      *\n-     * The CodeView symbol section Prolog is also a CVSymbolSubsection, but it is not build in this\n+     * The CodeView symbol section Prolog is also a CVSymbolSubsection, but it is not built in this\n      * class.\n      */\n-    void build(DebugContext theDebugContext) {\n-        this.debugContext = theDebugContext;\n-        this.lineRecordBuilder = new CVLineRecordBuilder(debugContext, cvDebugInfo);\n-        /* loop over all classes defined in this module. */\n-        for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n-            build(classEntry);\n+    void build() {\n+        /* Loop over all classes defined in this module. */\n+        for (TypeEntry typeEntry : cvDebugInfo.getTypes()) {\n+            /* Add type record for this entry. */\n+            if (typeEntry.isClass()) {\n+                buildClass((ClassEntry) typeEntry);\n+            } else {\n+                addTypeRecords(typeEntry);\n+            }\n         }\n         cvDebugInfo.getCVSymbolSection().addRecord(cvSymbolSubsection);\n     }\n \n     /**\n-     * Build all debug info for a classEntry. (does not yet handle member variables).\n+     * Build all debug info for a classEntry.\n      *\n      * @param classEntry current class\n      */\n-    private void build(ClassEntry classEntry) {\n-        /* Loop over all functions defined in this class. */\n-        for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-            build(primaryEntry);\n-        }\n+    private void buildClass(ClassEntry classEntry) {\n+\n+        /* Define all the functions in this class all functions defined in this class. */\n+        classEntry.compiledEntries().forEach(this::buildFunction);\n+\n+        /* Define the class itself. */\n+        addTypeRecords(classEntry);\n+\n+        /* Add manifested static fields as S_GDATA32 records. */\n+        classEntry.fields().filter(CVSymbolSubsectionBuilder::isManifestedStaticField).forEach(f -> {\n+            int typeIndex = cvDebugInfo.getCVTypeSection().getIndexForPointer(f.getValueType());\n+            String displayName = CVNames.fieldNameToCodeViewName(f);\n+            if (cvDebugInfo.useHeapBase()) {\n+                /*\n+                 * Isolates are enabled. Static member is located at REL32 offset from heap base\n+                 * register.\n+                 */\n+                addSymbolRecord(new CVSymbolSubrecord.CVSymbolRegRel32Record(cvDebugInfo, displayName, typeIndex, f.getOffset(), heapRegister));\n+            } else {\n+                /* Isolates are disabled. Static member is located at offset from heap begin. */\n+                addSymbolRecord(new CVSymbolSubrecord.CVSymbolGData32Record(cvDebugInfo, heapName, displayName, typeIndex, f.getOffset(), (short) 0));\n+            }\n+        });\n+    }\n+\n+    private static boolean isManifestedStaticField(FieldEntry fieldEntry) {\n+        return Modifier.isStatic(fieldEntry.getModifiers()) && fieldEntry.getOffset() >= 0;\n     }\n \n     /**\n      * Emit records for each function: PROC32 S_FRAMEPROC S_END and line number records. (later:\n      * type records as required).\n      *\n-     * @param primaryEntry primary entry for this function\n+     * @param compiledEntry compiled method for this function\n      */\n-    private void build(PrimaryEntry primaryEntry) {\n-        final Range primaryRange = primaryEntry.getPrimary();\n+    private void buildFunction(CompiledMethodEntry compiledEntry) {\n+        final Range primaryRange = compiledEntry.getPrimary();\n \n         /* The name as it will appear in the debugger. */\n-        final String debuggerName = getDebuggerName(primaryRange);\n+        final String debuggerName = CVNames.methodNameToCodeViewName(primaryRange.getMethodEntry());\n \n         /* The name as exposed to the linker. */\n         final String externalName = primaryRange.getSymbolName();\n \n         /* S_PROC32 add function definition. */\n-        int functionTypeIndex = addTypeRecords(primaryEntry);\n+        int functionTypeIndex = addTypeRecords(compiledEntry);\n         byte funcFlags = 0;\n         CVSymbolSubrecord.CVSymbolGProc32Record proc32 = new CVSymbolSubrecord.CVSymbolGProc32Record(cvDebugInfo, externalName, debuggerName, 0, 0, 0, primaryRange.getHi() - primaryRange.getLo(), 0,\n-                        0, functionTypeIndex, primaryRange.getLo(), (short) 0, funcFlags);\n-        addToSymbolSubsection(proc32);\n+                        0, functionTypeIndex, (short) 0, funcFlags);\n+        addSymbolRecord(proc32);\n \n         /* S_FRAMEPROC add frame definitions. */\n         int asynceh = 1 << 9; /* Async exception handling (vc++ uses 1, clang uses 0). */\n+        /* TODO: This may change in the presence of isolates. */\n         int localBP = 1 << 14; /* Local base pointer = SP (0=none, 1=sp, 2=bp 3=r13). */\n         int paramBP = 1 << 16; /* Param base pointer = SP. */\n         int frameFlags = asynceh + localBP + paramBP; /* NB: LLVM uses 0x14000. */\n-        addToSymbolSubsection(new CVSymbolSubrecord.CVSymbolFrameProcRecord(cvDebugInfo, primaryEntry.getFrameSize(), frameFlags));\n+        addSymbolRecord(new CVSymbolSubrecord.CVSymbolFrameProcRecord(cvDebugInfo, compiledEntry.getFrameSize(), frameFlags));\n \n+        /* TODO: add parameter definitions (types have been added already). */\n         /* TODO: add local variables, and their types. */\n         /* TODO: add block definitions. */\n \n         /* S_END add end record. */\n-        addToSymbolSubsection(new CVSymbolSubrecord.CVSymbolEndRecord(cvDebugInfo));\n+        addSymbolRecord(new CVSymbolSubrecord.CVSymbolEndRecord(cvDebugInfo));\n \n         /* Add line number records. */\n-        addLineNumberRecords(primaryEntry);\n-    }\n-\n-    /**\n-     * Rename function names for usability or functionality.\n-     *\n-     * First encountered main function becomes class.main. This is for usability.\n-     *\n-     * All other functions become class.function.999 (where 999 is a hash of the arglist). This is\n-     * because The standard link.exe can't handle odd characters (parentheses or commas, for\n-     * example) in debug information.\n-     *\n-     * This does not affect external symbols used by linker.\n-     *\n-     * TODO: strip illegal characters from arg lists instead (\"link.exe\" - safe names)\n-     *\n-     * @param range Range contained in the method of interest\n-     * @return user debugger friendly method name\n-     */\n-    private String getDebuggerName(Range range) {\n-        final String methodName;\n-        if (noMainFound && range.getMethodName().equals(\"main\")) {\n-            noMainFound = false;\n-            methodName = range.getClassAndMethodName();\n-        } else {\n-            /* In the future, use a more user-friendly name instead of a hash function. */\n-            methodName = range.getSymbolName();\n-        }\n-        return methodName;\n+        addLineNumberRecords(compiledEntry);\n     }\n \n-    private void addLineNumberRecords(PrimaryEntry primaryEntry) {\n-        CVLineRecord record = lineRecordBuilder.build(primaryEntry);\n+    private void addLineNumberRecords(CompiledMethodEntry compiledEntry) {\n+        CVLineRecord record = lineRecordBuilder.build(compiledEntry);\n         /*\n          * If there are no file entries (perhaps for a synthetic function?), we don't add this\n          * record.\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ5ODcwOQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r461498709", "body": "Why is it necessary to define a new symbol for each function? Was it not possible to use the existing ones?", "bodyText": "Why is it necessary to define a new symbol for each function? Was it not possible to use the existing ones?", "bodyHTML": "<p dir=\"auto\">Why is it necessary to define a new symbol for each function? Was it not possible to use the existing ones?</p>", "author": "pejovica", "createdAt": "2020-07-28T11:06:23Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,426 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file.\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.subrecordStartPosition = initialPos;\n+        int prologueLength = Short.BYTES * 2; /* Room for length and subcommand. */\n+        return computeSize(initialPos + prologueLength);\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* Save room for length (no including length bytes). */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(cmd=0x%04x pos=0x%06x)\", cmd, subrecordStartPosition);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeSize(int pos);\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* find the full path to object file we will produce. */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Extrapolate object filename from first class definition. */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* Signature is currently set to 0. */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos); /*\n+                                                                    * This string is inline null\n+                                                                    * terminated.\n+                                                                    */\n+            return pos;\n+        }\n+    }\n+\n+    public static final class CVCompile3Record extends CVSymbolSubrecord {\n+\n+        private static final byte HAS_DEBUG_FLAG = 0;\n+        @SuppressWarnings(\"unused\") private static final byte HAS_NO_DEBUG_FLAG = (byte) 0x80;\n+\n+        private byte language;\n+        private byte cf1;\n+        private byte cf2;\n+        private byte padding;\n+        private short machine;\n+        private short feMajor;\n+        private short feMinor;\n+        private short feBuild;\n+        private short feQFE;\n+        private short beMajor;\n+        private short beMinor;\n+        private short beBuild;\n+        private short beQFE;\n+        private String compiler;\n+\n+        CVCompile3Record(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_COMPILE3);\n+            language = 0;\n+            cf1 = HAS_DEBUG_FLAG;\n+            cf2 = (byte) 0;\n+            padding = (byte) 0;\n+            machine = (short) 208;\n+            feMajor = (short) 2;\n+            feMinor = (short) 3;\n+            feBuild = (short) 4;\n+            feQFE = (short) 5;\n+            beMajor = (short) 6;\n+            beMinor = (short) 7;\n+            beBuild = (short) 8;\n+            beQFE = (short) 9;\n+            compiler = \"graal\";\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putByte(language, buffer, initialPos);\n+            pos = CVUtil.putByte(cf1, buffer, pos);\n+            pos = CVUtil.putByte(cf2, buffer, pos);\n+            pos = CVUtil.putByte(padding, buffer, pos);\n+            pos = CVUtil.putShort(machine, buffer, pos);\n+            pos = CVUtil.putShort(feMajor, buffer, pos);\n+            pos = CVUtil.putShort(feMinor, buffer, pos);\n+            pos = CVUtil.putShort(feBuild, buffer, pos);\n+            pos = CVUtil.putShort(feQFE, buffer, pos);\n+            pos = CVUtil.putShort(beMajor, buffer, pos);\n+            pos = CVUtil.putShort(beMinor, buffer, pos);\n+            pos = CVUtil.putShort(beBuild, buffer, pos);\n+            pos = CVUtil.putShort(beQFE, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(compiler, buffer, pos);  // inline null terminated\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_COMPILE3 machine=%d fe=%d.%d.%d.%d be=%d.%d.%d%d compiler=%s\", machine, feMajor, feMinor, feBuild, feQFE, beMajor, beMinor, beBuild, beQFE, compiler);\n+        }\n+    }\n+\n+    public static final class CVEnvBlockRecord extends CVSymbolSubrecord {\n+\n+        private static final int ENVMAP_INITIAL_CAPACITY = 10;\n+\n+        private Map<String, String> map = new HashMap<>(ENVMAP_INITIAL_CAPACITY);\n+\n+        /*-\n+         * Example contents of the environment block:\n+         *   cwd = C:\\tmp\\graal-8\n+         *   cl = C:\\tmp\\graal-8\\ojdkbuild\\tools\\toolchain\\vs2010e\\VC\\Bin\\x86_amd64\\cl.exe\n+         *   cmd = -Zi -MT -IC:\\tmp\\graal-8\\tools\\toolchain\\vs2010e\\VC\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE\\gl -TC -X\n+         *   src = helloworld.c\n+         *   pdb = C:\\tmp\\graal-8\\vc100.pdb\n+         */\n+        CVEnvBlockRecord(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_ENVBLOCK);\n+\n+            /* Current directory. */\n+            map.put(\"cwd\", System.getProperty(\"user.dir\"));\n+\n+            /*\n+             * Find first source file - which, for Graal would be a class file on the command line.\n+             */\n+            String fn = findFirstFile(cvDebugInfo);\n+            if (fn != null) {\n+                map.put(\"src\", fn);\n+            }\n+        }\n+\n+        private static String findFirstFile(CVDebugInfo cvDebugInfo) {\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            /* Flags. */\n+            int pos = CVUtil.putByte((byte) 0, buffer, initialPos);\n+\n+            /* Key/value pairs. */\n+            for (Map.Entry<String, String> entry : map.entrySet()) {\n+                pos = CVUtil.putUTF8StringBytes(entry.getKey(), buffer, pos);\n+                pos = CVUtil.putUTF8StringBytes(entry.getValue(), buffer, pos);\n+            }\n+\n+            /* End marker. */\n+            pos = CVUtil.putUTF8StringBytes(\"\", buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"S_ENVBLOCK \" + map.size() + \" entries\";\n+        }\n+    }\n+\n+    /*\n+     * Creating a proc32 record has side effects: a global symbol is added to the COFF symbol\n+     * section, and two relocation entries are added to the section relocation table, they refer\n+     * back to the global symbol.\n+     */\n+    public static class CVSymbolGProc32Record extends CVSymbolSubrecord {\n+\n+        private static ObjectFile.Element textSection;\n+\n+        int pparent;\n+        int pend;\n+        int pnext;\n+        int proclen;\n+        int debugStart;\n+        int debugEnd;\n+        int typeIndex;\n+        int offset;\n+        short segment;\n+        byte flags;\n+        String name;\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, short cmd, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment,\n+                        byte flags) {\n+            super(cvDebugInfo, cmd);\n+            this.name = name;\n+            this.pparent = pparent;\n+            this.pend = pend;\n+            this.pnext = pnext;\n+            this.proclen = proclen;\n+            this.debugStart = debugStart;\n+            this.debugEnd = debugEnd;\n+            this.typeIndex = typeIndex;\n+            this.offset = offset;\n+            this.segment = segment;\n+            this.flags = flags;\n+        }\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment, byte flags) {\n+            this(cvDebugInfo, CVDebugConstants.S_GPROC32, name, pparent, pend, pnext, proclen, debugStart, debugEnd, typeIndex, offset, segment, flags);\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(pparent, buffer, initialPos);\n+            pos = CVUtil.putInt(pend, buffer, pos);\n+            pos = CVUtil.putInt(pnext, buffer, pos);\n+            pos = CVUtil.putInt(proclen, buffer, pos);\n+            pos = CVUtil.putInt(debugStart, buffer, pos);\n+            pos = CVUtil.putInt(debugEnd, buffer, pos);\n+            pos = CVUtil.putInt(typeIndex, buffer, pos);\n+            if (buffer == null) {\n+                cvDebugInfo.getCVSymbolSection().getOwner().createDefinedSymbol(name, getTextSection(), offset, proclen, true, true);", "originalCommit": "26825b7727b0cfbcff2dbf28e7fea03b862493ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5OTAzNw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r465699037", "bodyText": "Two reasons: I don't think they actually exist - if Graal produces a single large object file, then there is normally no need to emit externs for non-exported  functions.  Second reason, to emit a non-mangled name that the use can refer to in Visual Studio.", "author": "stooke", "createdAt": "2020-08-05T12:45:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ5ODcwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex b7fb25890e1..ddb43d1039c 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -318,34 +296,23 @@ abstract class CVSymbolSubrecord {\n             pos = CVUtil.putInt(debugStart, buffer, pos);\n             pos = CVUtil.putInt(debugEnd, buffer, pos);\n             pos = CVUtil.putInt(typeIndex, buffer, pos);\n-            if (buffer == null) {\n-                cvDebugInfo.getCVSymbolSection().getOwner().createDefinedSymbol(name, getTextSection(), offset, proclen, true, true);\n-            }\n             if (buffer != null) {\n-                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 4, ObjectFile.RelocationKind.SECREL, name, false, 1L);\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, externalName, false, 1L);\n             }\n             pos = CVUtil.putInt(0, buffer, pos);\n             if (buffer != null) {\n-                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 2, ObjectFile.RelocationKind.SECTION, name, false, 1L);\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, externalName, false, 1L);\n             }\n             pos = CVUtil.putShort((short) 0, buffer, pos);\n             pos = CVUtil.putByte(flags, buffer, pos);\n-            pos = CVUtil.putUTF8StringBytes(name, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(debuggerName, buffer, pos);\n             return pos;\n         }\n \n-        private ObjectFile.Element getTextSection() {\n-            if (textSection == null) {\n-                textSection = cvDebugInfo.getCVSymbolSection().getOwner().elementForName(SectionName.TEXT.getFormatDependentName(ObjectFile.Format.PECOFF));\n-            }\n-            return textSection;\n-        }\n-\n         @Override\n         public String toString() {\n-            return String.format(\"S_GPROC32   name=%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", name, pparent, debugStart, debugEnd, proclen, offset,\n-                            typeIndex,\n-                            flags);\n+            return String.format(\"S_GPROC32   name=%s/%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", debuggerName, externalName, pparent, debugStart, debugEnd,\n+                            proclen, offset, typeIndex, flags);\n         }\n     }\n \n", "next_change": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex ddb43d1039c..0a30db69e94 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -296,35 +295,28 @@ abstract class CVSymbolSubrecord {\n             pos = CVUtil.putInt(debugStart, buffer, pos);\n             pos = CVUtil.putInt(debugEnd, buffer, pos);\n             pos = CVUtil.putInt(typeIndex, buffer, pos);\n-            if (buffer != null) {\n-                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, externalName, false, 1L);\n-            }\n-            pos = CVUtil.putInt(0, buffer, pos);\n-            if (buffer != null) {\n-                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, externalName, false, 1L);\n-            }\n-            pos = CVUtil.putShort((short) 0, buffer, pos);\n+            pos = cvDebugInfo.getCVSymbolSection().markRelocationSite(buffer, pos, symbolName, (long) 0);\n             pos = CVUtil.putByte(flags, buffer, pos);\n-            pos = CVUtil.putUTF8StringBytes(debuggerName, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(displayName, buffer, pos);\n             return pos;\n         }\n \n         @Override\n         public String toString() {\n-            return String.format(\"S_GPROC32   name=%s/%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", debuggerName, externalName, pparent, debugStart, debugEnd,\n-                            proclen, offset, typeIndex, flags);\n+            return String.format(\"S_GPROC32   name=%s/%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x seg:offset=0x%x:0x%x type=0x%x flags=0x%x)\", displayName, symbolName, pparent, debugStart, debugEnd,\n+                            proclen, segment, offset, typeIndex, flags);\n         }\n     }\n \n     public static final class CVSymbolFrameProcRecord extends CVSymbolSubrecord {\n \n-        int framelen;\n-        int padLen;\n-        int padOffset;\n-        int saveRegsCount;\n-        int ehOffset;\n-        short ehSection;\n-        int flags;\n+        private final int framelen;\n+        private final int padLen;\n+        private final int padOffset;\n+        private final int saveRegsCount;\n+        private final int ehOffset;\n+        private final short ehSection;\n+        private final int flags;\n \n         CVSymbolFrameProcRecord(CVDebugInfo cvDebugInfo, int framelen, int padLen, int padOffset, int saveRegsCount, int ehOffset, short ehSection, int flags) {\n             super(cvDebugInfo, CVDebugConstants.S_FRAMEPROC);\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUyNDAzMA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r461524030", "body": "```suggestion\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        this.addr = addr;\n          \n          \n            \n                        this.lineAndFLags = line;", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>addr <span class=\"pl-k\">=</span> addr;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>lineAndFLags <span class=\"pl-k\">=</span> line;</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pejovica", "createdAt": "2020-07-28T11:58:09Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.ObjectFile;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A line record (DEBUG_S_LINES) consists of a list of (file block record + subrecords).\n+ * Graal will generate one CVLineRecord per function.\n+ */\n+final class CVLineRecord extends CVSymbolRecord {\n+\n+    /* Header: addr (4 bytes):section (2 bytes) flags (2 bytes) chunck length (4 bytes). */\n+    private static final int LINE_RECORD_HEADER_SIZE = Integer.BYTES + Short.BYTES * 2 + Integer.BYTES;\n+\n+    private static final int DEFAULT_LINE_BLOCK_COUNT = 100;\n+    private static final int DEFAULT_LINE_ENTRY_COUNT = 100;\n+\n+    /* has colummns flag = 0x80 - not supported */\n+    private static final short CB_HAS_NO_COLUMNS_FLAG = 0x00;\n+\n+    private String symbolName;\n+    private ArrayList<FileBlock> fileBlocks = new ArrayList<>(DEFAULT_LINE_BLOCK_COUNT);\n+\n+    CVLineRecord(CVDebugInfo cvDebugInfo, String symbolName) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_LINES);\n+        this.symbolName = symbolName;\n+    }\n+\n+    void addNewFile(FileEntry file) {\n+        CVFileTableRecord fr = cvDebugInfo.getCVSymbolSection().getFileTableRecord();\n+        int fileId = fr.addFile(file);\n+        fileBlocks.add(new FileBlock(fileId));\n+    }\n+\n+    void addNewLine(int addr, int line) {\n+        fileBlocks.get(fileBlocks.size() - 1).addEntry(new LineEntry(addr, line));\n+    }\n+\n+    @Override\n+    protected int computeSize(int initialPos) {\n+        /* Line record header. */\n+        int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n+        /* All blocks. */\n+        for (FileBlock fileBlock : fileBlocks) {\n+            pos = fileBlock.computeSize(pos);\n+        }\n+        return pos;\n+    }\n+\n+    private void computeHeader(byte[] buffer, int initialPos, int length) {\n+\n+        assert symbolName != null;\n+        int pos = initialPos;\n+\n+        if (buffer != null) {\n+            cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 4, ObjectFile.RelocationKind.SECREL, symbolName, false, 1L);\n+        }\n+        pos = CVUtil.putInt(0, buffer, pos);\n+\n+        if (buffer != null) {\n+            cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 2, ObjectFile.RelocationKind.SECTION, symbolName, false, 1L);\n+        }\n+        pos = CVUtil.putShort((short) 0, buffer, pos);\n+\n+        pos = CVUtil.putShort(CB_HAS_NO_COLUMNS_FLAG, buffer, pos); /* flags */\n+        CVUtil.putInt(length, buffer, pos);\n+    }\n+\n+    @Override\n+    protected int computeContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n+        int highAddr = 0; /* Length of this chunk in object file */\n+        for (FileBlock fileBlock : fileBlocks) {\n+            highAddr = Math.max(highAddr, fileBlock.getHighAddr());\n+            pos = fileBlock.computeContents(buffer, pos);\n+        }\n+        computeHeader(buffer, initialPos, highAddr);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVLineRecord(type=0x%04x pos=0x%05x size=0x%d)\", type, recordStartPosition, fileBlocks.size());\n+    }\n+\n+    /*\n+     * FileBlock is a section of contiguous code in a compilation unit, associated with a single\n+     * source file. If a function includes inlined code, that code needs its own FileBlock,\n+     * surrounded by FileBlocks describing the enclosing source file. A FileBlock consists of a list\n+     * of LineEntries.\n+     */\n+    private static class FileBlock {\n+\n+        /* Fileblock header: fileId (4 bytes) lineEntry count (4 bytes) tablesize (4 bytes) */\n+        static final int FILE_BLOCK_HEADER_SIZE = Integer.BYTES * 3;\n+\n+        ArrayList<LineEntry> lineEntries = new ArrayList<>(DEFAULT_LINE_ENTRY_COUNT);\n+        int highAddr = 0;\n+        int fileId;\n+\n+        FileBlock(int fileId) {\n+            this.fileId = fileId;\n+        }\n+\n+        void addEntry(LineEntry le) {\n+            highAddr = Math.max(highAddr, le.addr);\n+            lineEntries.add(le);\n+        }\n+\n+        int computeContents(byte[] buffer, int initialPos) {\n+            int pos = initialPos;\n+            pos = CVUtil.putInt(fileId, buffer, pos);\n+            pos = CVUtil.putInt(lineEntries.size(), buffer, pos);\n+            pos = CVUtil.putInt(computeSize(0), buffer, pos);\n+            for (LineEntry lineEntry : lineEntries) {\n+                pos = lineEntry.computeContents(buffer, pos);\n+            }\n+            return pos;\n+        }\n+\n+        int computeSize(int initialPos) {\n+            return initialPos + FILE_BLOCK_HEADER_SIZE + LineEntry.LINE_ENTRY_SIZE * lineEntries.size();\n+        }\n+\n+        int getHighAddr() {\n+            return highAddr;\n+        }\n+    }\n+\n+    /*\n+     * LineEntry associates some object code (at 'addr', relative to the start of this DEBUG_S_LINES\n+     * record) with a source line in the current FileBlock file.\n+     */\n+    private static class LineEntry {\n+\n+        /* Entry: address(4 bytes) line number+flags (4 bytes) */\n+        static final int LINE_ENTRY_SIZE = 2 * Integer.BYTES;\n+\n+        int addr;\n+        int lineAndFLags;\n+\n+        LineEntry(int addr, int line, int deltaEnd, boolean isStatement) {\n+            this.addr = addr;\n+            assert line <= 0xffffff;\n+            assert line >= 0;\n+            assert deltaEnd <= 0x7f;\n+            assert deltaEnd >= 0;\n+            lineAndFLags = line | (deltaEnd << 24) | (isStatement ? 0x80000000 : 0);\n+        }\n+\n+        LineEntry(int addr, int line) {\n+            this(addr, line, 0, false);\n+            this.addr = addr;\n+            this.lineAndFLags = line;", "originalCommit": "26825b7727b0cfbcff2dbf28e7fea03b862493ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY3MTU1Mw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r465671553", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-08-05T11:53:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUyNDAzMA=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\nindex 5b7f92ec8c7..090f30fe4ac 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n", "chunk": "@@ -178,8 +185,6 @@ final class CVLineRecord extends CVSymbolRecord {\n \n         LineEntry(int addr, int line) {\n             this(addr, line, 0, false);\n-            this.addr = addr;\n-            this.lineAndFLags = line;\n         }\n \n         int computeContents(byte[] buffer, int initialPos) {\n", "next_change": {"commit": "6d209109480ecec08ebf137288371d4c56064ba0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\nindex 090f30fe4ac..868d68f2bd5 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n", "chunk": "@@ -180,7 +181,7 @@ final class CVLineRecord extends CVSymbolRecord {\n             assert line >= 0;\n             assert deltaEnd <= 0x7f;\n             assert deltaEnd >= 0;\n-            lineAndFLags = line | (deltaEnd << 24) | (isStatement ? 0x80000000 : 0);\n+            lineAndFlags = line | (deltaEnd << 24) | (isStatement ? 0x80000000 : 0);\n         }\n \n         LineEntry(int addr, int line) {\n", "next_change": null}, {"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\nindex 090f30fe4ac..868d68f2bd5 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n", "chunk": "@@ -190,7 +191,7 @@ final class CVLineRecord extends CVSymbolRecord {\n         int computeContents(byte[] buffer, int initialPos) {\n             int pos = initialPos;\n             pos = CVUtil.putInt(addr, buffer, pos);\n-            pos = CVUtil.putInt(lineAndFLags, buffer, pos);\n+            pos = CVUtil.putInt(lineAndFlags, buffer, pos);\n             return pos;\n         }\n     }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc0OTgwOQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r461749809", "body": "A leftover?", "bodyText": "A leftover?", "bodyHTML": "<p dir=\"auto\">A leftover?</p>", "author": "pejovica", "createdAt": "2020-07-28T17:27:13Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.replaceMainFunctionName;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.emitUnadornedMain;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_NOTYPE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_VOID;\n+\n+final class CVSymbolSubsectionBuilder {\n+\n+    private final CVDebugInfo cvDebugInfo;\n+    private final CVSymbolSubsection symbolRecord;\n+    private CVLineRecordBuilder lineRecordBuilder;\n+    private DebugContext debugContext = null;\n+\n+    private boolean noMainFound = true;\n+\n+    CVSymbolSubsectionBuilder(CVDebugInfo cvDebugInfo) {\n+        this.symbolRecord = new CVSymbolSubsection(cvDebugInfo);\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    /**\n+     * Build DEBUG_S_SYMBOLS record from all classEntries. (CodeView 4 format allows us to build one\n+     * per class or one per function or one big record - which is what we do here).\n+     *\n+     * The CodeView symbol section Prolog is also a CVSymbolSubsection, but it is not build in this\n+     * class.\n+     */\n+    void build(DebugContext theDebugContext) {\n+        this.debugContext = theDebugContext;\n+        this.lineRecordBuilder = new CVLineRecordBuilder(debugContext, cvDebugInfo);\n+        /* loop over all classes defined in this module. */\n+        for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+            build(classEntry);\n+        }\n+        cvDebugInfo.getCVSymbolSection().addRecord(symbolRecord);\n+    }\n+\n+    /**\n+     * Build all debug info for a classEntry. (does not yet handle member variables).\n+     *\n+     * @param classEntry current class\n+     */\n+    private void build(ClassEntry classEntry) {\n+        String previousMethodName = \"\";\n+        /* Loop over all functions defined in this class. */\n+        for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+            Range primaryRange = primaryEntry.getPrimary();\n+            String newMethodName = fixMethodName(primaryRange);\n+            if (!newMethodName.equals(previousMethodName)) {\n+                previousMethodName = newMethodName;\n+                build(primaryEntry, newMethodName);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emit records for each function: PROC32 S_FRAMEPROC S_END and line number records. (later:\n+     * type records as required).\n+     *\n+     * @param primaryEntry primary entry for this function\n+     * @param methodName method name alias as it will be seen by the user\n+     */\n+    private void build(PrimaryEntry primaryEntry, String methodName) {\n+        final Range primaryRange = primaryEntry.getPrimary();\n+\n+        /* S_PROC32 add function definition. */\n+        int functionTypeIndex = addTypeRecords(primaryEntry);\n+        byte funcFlags = 0;\n+        CVSymbolSubrecord.CVSymbolGProc32Record proc32 = new CVSymbolSubrecord.CVSymbolGProc32Record(cvDebugInfo, methodName, 0, 0, 0, primaryRange.getHi() - primaryRange.getLo(), 0, 0,\n+                        functionTypeIndex, primaryRange.getLo(), (short) 0, funcFlags);\n+        addToSymbolRecord(proc32);\n+\n+        /* S_FRAMEPROC add frame definitions. */\n+        int asynceh = 1 << 9; /* Async exception handling (vc++ uses 1, clang uses 0). */\n+        int localBP = 1 << 14; /* Local base pointer = SP (0=none, 1=sp, 2=bp 3=r13). */\n+        int paramBP = 1 << 16; /* Param base pointer = SP. */\n+        int frameFlags = asynceh + localBP + paramBP; /* NB: LLVM uses 0x14000. */\n+        addToSymbolRecord(new CVSymbolSubrecord.CVSymbolFrameProcRecord(cvDebugInfo, primaryRange.getHi() - primaryRange.getLo(), frameFlags));\n+\n+        /* TODO: add local variables, and their types. */\n+        /* TODO: add block definitions. */\n+\n+        /* S_END add end record. */\n+        addToSymbolRecord(new CVSymbolSubrecord.CVSymbolEndRecord(cvDebugInfo));\n+        addLineNumberRecords(primaryEntry, methodName);\n+    }\n+\n+    /**\n+     * Rename function names for usability or functionality.\n+     *\n+     * First encountered main function becomes class.main (unless replaceMainFunctionName is\n+     * non-null). This is for usability.\n+     *\n+     * All other functions become class.function.999 (where 999 is a hash of the arglist). This is\n+     * because The standard link.exe can't handle odd characters (parentheses or commas, for\n+     * example) in debug information, so\n+     *\n+     * This does not affect external symbols used by linker.\n+     *\n+     * TODO: strip illegal characters from arg lists instead (\"link.exe\" - safe names)\n+     *\n+     * @param range Range contained in the method of interest\n+     * @return user debugger friendly method name\n+     */\n+    private String fixMethodName(Range range) {\n+        final String methodName;\n+        if (replaceMainFunctionName != null && noMainFound && range.getMethodName().equals(\"main\")) {\n+            noMainFound = false;\n+            methodName = replaceMainFunctionName;\n+        } else if (emitUnadornedMain && noMainFound && range.getMethodName().equals(\"main\")) {\n+            /* TODO: check for static void main(String args[]) instead of just main(...). */\n+            noMainFound = false;\n+            methodName = range.getClassAndMethodName();\n+        } else {\n+            /* in the future, use a \"link.exe-safe\" name instead of a hash function. */\n+            long hash = range.getParamNames().hashCode() & 0xffffffffL;\n+            methodName = range.getClassAndMethodName() + \".\" + hash;\n+        }\n+        // debug(\"replacing %s with %s\\n\", range.getFullMethodName(), methodName);", "originalCommit": "26825b7727b0cfbcff2dbf28e7fea03b862493ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY3MTQ5Ng==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r465671496", "bodyText": "Gone.", "author": "stooke", "createdAt": "2020-08-05T11:53:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc0OTgwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\nindex eb254c951c8..f0eac5086e0 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n", "chunk": "@@ -134,44 +132,43 @@ final class CVSymbolSubsectionBuilder {\n      * @param range Range contained in the method of interest\n      * @return user debugger friendly method name\n      */\n-    private String fixMethodName(Range range) {\n+    private String getDebuggerName(Range range) {\n         final String methodName;\n-        if (replaceMainFunctionName != null && noMainFound && range.getMethodName().equals(\"main\")) {\n-            noMainFound = false;\n-            methodName = replaceMainFunctionName;\n-        } else if (emitUnadornedMain && noMainFound && range.getMethodName().equals(\"main\")) {\n-            /* TODO: check for static void main(String args[]) instead of just main(...). */\n+        if (noMainFound && range.getMethodName().equals(\"main\")) {\n             noMainFound = false;\n             methodName = range.getClassAndMethodName();\n         } else {\n-            /* in the future, use a \"link.exe-safe\" name instead of a hash function. */\n-            long hash = range.getParamNames().hashCode() & 0xffffffffL;\n-            methodName = range.getClassAndMethodName() + \".\" + hash;\n+            /* In the future, use a more user-friendly name instead of a hash function. */\n+            methodName = range.getSymbolName();\n         }\n-        // debug(\"replacing %s with %s\\n\", range.getFullMethodName(), methodName);\n         return methodName;\n     }\n \n-    private void addLineNumberRecords(PrimaryEntry primaryEntry, String methodName) {\n-        CVLineRecord record = lineRecordBuilder.build(primaryEntry, methodName);\n+    private void addLineNumberRecords(PrimaryEntry primaryEntry) {\n+        CVLineRecord record = lineRecordBuilder.build(primaryEntry);\n         /*\n-         * If the builder decides this entry is uninteresting, we don't build a record. for example,\n-         * Graal intrinsics may be uninteresting to some developers.\n+         * If there are no file entries (perhaps for a synthetic function?), we don't add this\n+         * record.\n          */\n-        if (record != null) {\n+        if (!record.isEmpty()) {\n             cvDebugInfo.getCVSymbolSection().addRecord(record);\n         }\n     }\n \n-    private void addToSymbolRecord(CVSymbolSubrecord record) {\n-        symbolRecord.addRecord(record);\n+    /**\n+     * Add a record to the symbol subsection. A symbol subsection is contained within the top level\n+     * .debug$S symbol section.\n+     *\n+     * @param record the symbol subrecord to add.\n+     */\n+    private void addToSymbolSubsection(CVSymbolSubrecord record) {\n+        cvSymbolSubsection.addRecord(record);\n     }\n \n     /**\n      * Add type records for function. (later add arglist, and return type and local types).\n      *\n      * @param entry primaryEntry containing entities whoses type records must be added\n-     *\n      * @return type index of function type\n      */\n     private int addTypeRecords(@SuppressWarnings(\"unused\") PrimaryEntry entry) {\n", "next_change": {"commit": "4caf93deee510084247c88599752478fc53bd73d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\nindex f0eac5086e0..ec33be0b99f 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n", "chunk": "@@ -168,10 +163,10 @@ final class CVSymbolSubsectionBuilder {\n     /**\n      * Add type records for function. (later add arglist, and return type and local types).\n      *\n-     * @param entry primaryEntry containing entities whoses type records must be added\n+     * @param entry compild method containing entities whoses type records must be added\n      * @return type index of function type\n      */\n-    private int addTypeRecords(@SuppressWarnings(\"unused\") PrimaryEntry entry) {\n+    private int addTypeRecords(@SuppressWarnings(\"unused\") CompiledMethodEntry entry) {\n         CVTypeRecord.CVTypeArglistRecord argListType = addTypeRecord(new CVTypeRecord.CVTypeArglistRecord().add(T_NOTYPE));\n         CVTypeRecord funcType = addTypeRecord(new CVTypeRecord.CVTypeProcedureRecord().returnType(T_VOID).argList(argListType));\n         return funcType.getSequenceNumber();\n", "next_change": {"commit": "77e3a7479e429a3279d3061496d260e35f21f000", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\nindex ec33be0b99f..dd2b8e972f8 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n", "chunk": "@@ -156,23 +169,35 @@ final class CVSymbolSubsectionBuilder {\n      *\n      * @param record the symbol subrecord to add.\n      */\n-    private void addToSymbolSubsection(CVSymbolSubrecord record) {\n+    private void addSymbolRecord(CVSymbolSubrecord record) {\n         cvSymbolSubsection.addRecord(record);\n     }\n \n     /**\n-     * Add type records for function. (later add arglist, and return type and local types).\n+     * Add type records for a class and all its members.\n      *\n-     * @param entry compild method containing entities whoses type records must be added\n-     * @return type index of function type\n+     * @param typeEntry class to add records for.\n      */\n-    private int addTypeRecords(@SuppressWarnings(\"unused\") CompiledMethodEntry entry) {\n-        CVTypeRecord.CVTypeArglistRecord argListType = addTypeRecord(new CVTypeRecord.CVTypeArglistRecord().add(T_NOTYPE));\n-        CVTypeRecord funcType = addTypeRecord(new CVTypeRecord.CVTypeProcedureRecord().returnType(T_VOID).argList(argListType));\n-        return funcType.getSequenceNumber();\n+    private void addTypeRecords(TypeEntry typeEntry) {\n+        int typeIdx = cvDebugInfo.getCVTypeSection().addTypeRecords(typeEntry).getSequenceNumber();\n+\n+        if (typeIdx > MAX_PRIMITIVE) {\n+            /*\n+             * Adding an S_UDT (User Defined Type) record ensures the linker doesn't throw away the\n+             * type definition.\n+             */\n+            CVSymbolSubrecord.CVSymbolUDTRecord udtRecord = new CVSymbolSubrecord.CVSymbolUDTRecord(cvDebugInfo, typeIdx, CVNames.typeNameToCodeViewName(typeEntry.getTypeName()));\n+            addSymbolRecord(udtRecord);\n+        }\n     }\n \n-    private <T extends CVTypeRecord> T addTypeRecord(T record) {\n-        return cvDebugInfo.getCVTypeSection().addOrReference(record);\n+    /**\n+     * Add type records for a class and all its members.\n+     *\n+     * @param entry compiled method containing entities whos type records must be added\n+     * @return type index of function type\n+     */\n+    private int addTypeRecords(CompiledMethodEntry entry) {\n+        return cvDebugInfo.getCVTypeSection().addTypeRecords(entry).getSequenceNumber();\n     }\n }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2MjEyNg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r461762126", "body": "Adding a small abstraction for `FileTableEntry` could help with clarity. Basically, the code is already structured with file table entries in mind, it's just that they are not explicit.", "bodyText": "Adding a small abstraction for FileTableEntry could help with clarity. Basically, the code is already structured with file table entries in mind, it's just that they are not explicit.", "bodyHTML": "<p dir=\"auto\">Adding a small abstraction for <code>FileTableEntry</code> could help with clarity. Basically, the code is already structured with file table entries in mind, it's just that they are not explicit.</p>", "author": "pejovica", "createdAt": "2020-07-28T17:47:38Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVFileTableRecord.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import org.graalvm.compiler.debug.GraalError;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+final class CVFileTableRecord extends CVSymbolRecord {", "originalCommit": "26825b7727b0cfbcff2dbf28e7fea03b862493ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk4ODI4NQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r466988285", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-08-07T11:43:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2MjEyNg=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVFileTableRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVFileTableRecord.java\nindex 1c48738ce68..4c77a935806 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVFileTableRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVFileTableRecord.java\n", "chunk": "@@ -39,21 +39,14 @@ import java.util.Map;\n \n final class CVFileTableRecord extends CVSymbolRecord {\n \n-    private static final byte CHECKSUM_NONE = 0x00;\n-    private static final byte CHECKSUM_MD5 = 0x01;\n-    private static final byte CB_VALUE = 0x10;\n-\n-    private static final int FILE_RECORD_LENGTH = 24;\n-\n-    private static final int CHECKSUM_LENGTH = 16;\n-    private static final byte[] EMPTY_CHECKSUM = new byte[CHECKSUM_LENGTH];\n-\n     private static final int FILE_TABLE_INITIAL_SIZE = 200;\n \n     private final CVSymbolSectionImpl.CVStringTable strings;\n \n     private int currentOffset = 0;\n-    private Map<FileEntry, Integer> fileEntryToOffsetMap = new LinkedHashMap<>(FILE_TABLE_INITIAL_SIZE);\n+\n+    /* Use a LinkedHashMap to maintain insertion order. */\n+    private Map<FileEntry, FileRecord> fileEntryToRecordMap = new LinkedHashMap<>(FILE_TABLE_INITIAL_SIZE);\n \n     CVFileTableRecord(CVDebugInfo cvDebugInfo, CVSymbolSectionImpl.CVStringTable strings) {\n         super(cvDebugInfo, CVDebugConstants.DEBUG_S_FILECHKSMS);\n", "next_change": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVFileTableRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVFileTableRecord.java\nindex 4c77a935806..8c7074c9f7b 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVFileTableRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVFileTableRecord.java\n", "chunk": "@@ -46,7 +46,7 @@ final class CVFileTableRecord extends CVSymbolRecord {\n     private int currentOffset = 0;\n \n     /* Use a LinkedHashMap to maintain insertion order. */\n-    private Map<FileEntry, FileRecord> fileEntryToRecordMap = new LinkedHashMap<>(FILE_TABLE_INITIAL_SIZE);\n+    private final Map<FileEntry, FileRecord> fileEntryToRecordMap = new LinkedHashMap<>(FILE_TABLE_INITIAL_SIZE);\n \n     CVFileTableRecord(CVDebugInfo cvDebugInfo, CVSymbolSectionImpl.CVStringTable strings) {\n         super(cvDebugInfo, CVDebugConstants.DEBUG_S_FILECHKSMS);\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIxODQyMQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r462218421", "body": "This looks like a bug in `FileEntry`, so why not fix it there?", "bodyText": "This looks like a bug in FileEntry, so why not fix it there?", "bodyHTML": "<p dir=\"auto\">This looks like a bug in <code>FileEntry</code>, so why not fix it there?</p>", "author": "pejovica", "createdAt": "2020-07-29T11:07:03Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVFileTableRecord.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import org.graalvm.compiler.debug.GraalError;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+final class CVFileTableRecord extends CVSymbolRecord {\n+\n+    private static final byte CHECKSUM_NONE = 0x00;\n+    private static final byte CHECKSUM_MD5 = 0x01;\n+    private static final byte CB_VALUE = 0x10;\n+\n+    private static final int FILE_RECORD_LENGTH = 24;\n+\n+    private static final int CHECKSUM_LENGTH = 16;\n+    private static final byte[] EMPTY_CHECKSUM = new byte[CHECKSUM_LENGTH];\n+\n+    private static final int FILE_TABLE_INITIAL_SIZE = 200;\n+\n+    private final CVSymbolSectionImpl.CVStringTable strings;\n+\n+    private int currentOffset = 0;\n+    private Map<FileEntry, Integer> fileEntryToOffsetMap = new LinkedHashMap<>(FILE_TABLE_INITIAL_SIZE);\n+\n+    CVFileTableRecord(CVDebugInfo cvDebugInfo, CVSymbolSectionImpl.CVStringTable strings) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_FILECHKSMS);\n+        this.strings = strings;\n+    }\n+\n+    int addFile(FileEntry entry) {\n+        if (fileEntryToOffsetMap.containsKey(entry)) {\n+            return fileEntryToOffsetMap.get(entry);\n+        } else {\n+            fileEntryToOffsetMap.put(entry, currentOffset);\n+            /* Create required stringtable entry. */\n+            strings.add(fixPath(entry));\n+            currentOffset += FILE_RECORD_LENGTH;\n+            return currentOffset - FILE_RECORD_LENGTH;\n+        }\n+    }\n+\n+    @Override\n+    public int computeSize(int initialPos) {\n+        /*\n+         * As part of computing the size, add all fileEntries ignoring duplicates. Most fileEntries\n+         * are created while building the symbol section.\n+         */\n+        for (FileEntry entry : cvDebugInfo.getFiles()) {\n+            addFile(entry);\n+        }\n+        return initialPos + (fileEntryToOffsetMap.size() * FILE_RECORD_LENGTH);\n+    }\n+\n+    @Override\n+    public int computeContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        for (FileEntry entry : fileEntryToOffsetMap.keySet()) {\n+            pos = put(entry, buffer, pos);\n+        }\n+        return pos;\n+    }\n+\n+    private int put(FileEntry entry, byte[] buffer, int initialPos) {\n+        String fn = fixPath(entry);\n+        int stringId = fn != null ? strings.add(fn) : 0; /* If no file, then use string 0 (= \"\"). */\n+        int pos = CVUtil.putInt(stringId, buffer, initialPos); /* Stringtable index. */\n+        pos = CVUtil.putByte(CB_VALUE, buffer, pos); /* Cb (unknown what this is). */\n+        byte[] checksum = calculateMD5Sum(fn);\n+        if (checksum != null) {\n+            pos = CVUtil.putByte(CHECKSUM_MD5, buffer, pos); /* Checksum type (0x01 == MD5). */\n+            pos = CVUtil.putBytes(checksum, buffer, pos);\n+        } else {\n+            pos = CVUtil.putByte(CHECKSUM_NONE, buffer, pos);\n+            pos = CVUtil.putBytes(EMPTY_CHECKSUM, buffer, pos);\n+        }\n+        pos = CVUtil.align4(pos);\n+        assert pos == initialPos + FILE_RECORD_LENGTH;\n+        return pos;\n+    }\n+\n+    private static byte[] calculateMD5Sum(String fn) {\n+        try {\n+            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n+            md.update(Files.readAllBytes(Paths.get(fn)));\n+            return md.digest();\n+        } catch (IOException e) {\n+            return null;\n+        } catch (NoSuchAlgorithmException e) {\n+            throw GraalError.shouldNotReachHere();\n+        }\n+    }\n+\n+    /**\n+     * Convert a FileEntry to a path. Avoid an NPE if there's no DirEntry.\n+     *\n+     * @param fileEntry entry containing uncorrected path.\n+     * @return path string, including directory if it exists.\n+     */\n+    private static String fixPath(FileEntry fileEntry) {\n+        return fileEntry.getDirEntry() != null ? fileEntry.getFullName() : fileEntry.getFileName();\n+    }", "originalCommit": "26825b7727b0cfbcff2dbf28e7fea03b862493ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY1OTEwMw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r466659103", "bodyText": "There is a semantic change if I do it there.  But I've done it anyways...", "author": "stooke", "createdAt": "2020-08-06T20:11:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIxODQyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVFileTableRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVFileTableRecord.java\nindex 1c48738ce68..4c77a935806 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVFileTableRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVFileTableRecord.java\n", "chunk": "@@ -61,80 +54,94 @@ final class CVFileTableRecord extends CVSymbolRecord {\n     }\n \n     int addFile(FileEntry entry) {\n-        if (fileEntryToOffsetMap.containsKey(entry)) {\n-            return fileEntryToOffsetMap.get(entry);\n+        if (fileEntryToRecordMap.containsKey(entry)) {\n+            return fileEntryToRecordMap.get(entry).getFileTableId();\n         } else {\n-            fileEntryToOffsetMap.put(entry, currentOffset);\n             /* Create required stringtable entry. */\n-            strings.add(fixPath(entry));\n-            currentOffset += FILE_RECORD_LENGTH;\n-            return currentOffset - FILE_RECORD_LENGTH;\n+            int stringTableOffset = strings.add(entry.getFullName());\n+            fileEntryToRecordMap.put(entry, new FileRecord(entry, currentOffset, stringTableOffset));\n+            currentOffset += FileRecord.FILE_RECORD_LENGTH;\n+            return currentOffset - FileRecord.FILE_RECORD_LENGTH;\n         }\n     }\n \n     @Override\n     public int computeSize(int initialPos) {\n-        /*\n-         * As part of computing the size, add all fileEntries ignoring duplicates. Most fileEntries\n-         * are created while building the symbol section.\n-         */\n-        for (FileEntry entry : cvDebugInfo.getFiles()) {\n-            addFile(entry);\n-        }\n-        return initialPos + (fileEntryToOffsetMap.size() * FILE_RECORD_LENGTH);\n+        return initialPos + (fileEntryToRecordMap.size() * FileRecord.FILE_RECORD_LENGTH);\n     }\n \n     @Override\n     public int computeContents(byte[] buffer, int initialPos) {\n         int pos = initialPos;\n-        for (FileEntry entry : fileEntryToOffsetMap.keySet()) {\n-            pos = put(entry, buffer, pos);\n+        for (FileRecord record : fileEntryToRecordMap.values()) {\n+            pos = record.put(buffer, pos);\n         }\n         return pos;\n     }\n \n-    private int put(FileEntry entry, byte[] buffer, int initialPos) {\n-        String fn = fixPath(entry);\n-        int stringId = fn != null ? strings.add(fn) : 0; /* If no file, then use string 0 (= \"\"). */\n-        int pos = CVUtil.putInt(stringId, buffer, initialPos); /* Stringtable index. */\n-        pos = CVUtil.putByte(CB_VALUE, buffer, pos); /* Cb (unknown what this is). */\n-        byte[] checksum = calculateMD5Sum(fn);\n-        if (checksum != null) {\n-            pos = CVUtil.putByte(CHECKSUM_MD5, buffer, pos); /* Checksum type (0x01 == MD5). */\n-            pos = CVUtil.putBytes(checksum, buffer, pos);\n-        } else {\n-            pos = CVUtil.putByte(CHECKSUM_NONE, buffer, pos);\n-            pos = CVUtil.putBytes(EMPTY_CHECKSUM, buffer, pos);\n-        }\n-        pos = CVUtil.align4(pos);\n-        assert pos == initialPos + FILE_RECORD_LENGTH;\n-        return pos;\n+    @Override\n+    public String toString() {\n+        return \"CVFileRecord(type=\" + type + \",pos=\" + recordStartPosition + \", size=\" + fileEntryToRecordMap.size() + \")\";\n     }\n \n-    private static byte[] calculateMD5Sum(String fn) {\n-        try {\n-            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n-            md.update(Files.readAllBytes(Paths.get(fn)));\n-            return md.digest();\n-        } catch (IOException e) {\n-            return null;\n-        } catch (NoSuchAlgorithmException e) {\n-            throw GraalError.shouldNotReachHere();\n+    private static final class FileRecord {\n+\n+        static final int FILE_RECORD_LENGTH = 24;\n+\n+        private static final byte CB_VALUE = 0x10;\n+        private static final int CHECKSUM_LENGTH = 16;\n+        private static final byte CHECKSUM_NONE = 0x00;\n+        private static final byte CHECKSUM_MD5 = 0x01;\n+        private static final byte[] EMPTY_CHECKSUM = new byte[CHECKSUM_LENGTH];\n+\n+        private FileEntry entry;\n+        private int fileTableId;\n+        private int stringTableId;\n+\n+        FileRecord(FileEntry entry, int fileTableId, int stringTableId) {\n+            this.entry = entry;\n+            this.fileTableId = fileTableId;\n+            this.stringTableId = stringTableId;\n         }\n-    }\n \n-    /**\n-     * Convert a FileEntry to a path. Avoid an NPE if there's no DirEntry.\n-     *\n-     * @param fileEntry entry containing uncorrected path.\n-     * @return path string, including directory if it exists.\n-     */\n-    private static String fixPath(FileEntry fileEntry) {\n-        return fileEntry.getDirEntry() != null ? fileEntry.getFullName() : fileEntry.getFileName();\n-    }\n+        private int put(byte[] buffer, int initialPos) {\n+            String fn = entry.getFullName();\n+            int pos = CVUtil.putInt(stringTableId, buffer, initialPos); /* Stringtable index. */\n+            pos = CVUtil.putByte(CB_VALUE, buffer, pos); /* Cb (unknown what this is). */\n+            byte[] checksum = calculateMD5Sum(fn);\n+            if (checksum != null) {\n+                pos = CVUtil.putByte(CHECKSUM_MD5, buffer, pos); /* Checksum type (0x01 == MD5). */\n+                pos = CVUtil.putBytes(checksum, buffer, pos);\n+            } else {\n+                pos = CVUtil.putByte(CHECKSUM_NONE, buffer, pos);\n+                pos = CVUtil.putBytes(EMPTY_CHECKSUM, buffer, pos);\n+            }\n+            pos = CVUtil.align4(pos);\n+            assert pos == initialPos + FILE_RECORD_LENGTH;\n+            return pos;\n+        }\n \n-    @Override\n-    public String toString() {\n-        return \"CVFileRecord(type=\" + type + \",pos=\" + recordStartPosition + \", size=\" + fileEntryToOffsetMap.size() + \")\";\n+        int getFileTableId() {\n+            return fileTableId;\n+        }\n+\n+        /**\n+         * Calculate the MD5 checksum of a file.\n+         *\n+         * @param fn path to file\n+         * @return a byte array containing the checksum, or null if there was an error reading the\n+         *         file.\n+         */\n+        private static byte[] calculateMD5Sum(String fn) {\n+            try {\n+                MessageDigest md = MessageDigest.getInstance(\"MD5\");\n+                md.update(Files.readAllBytes(Paths.get(fn)));\n+                return md.digest();\n+            } catch (IOException e) {\n+                return null;\n+            } catch (NoSuchAlgorithmException e) {\n+                throw GraalError.shouldNotReachHere();\n+            }\n+        }\n     }\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI4NTA1Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r462285057", "body": "I don't quite understand the purpose of this check. Won't it make you skip a function in case of a hash code collision?", "bodyText": "I don't quite understand the purpose of this check. Won't it make you skip a function in case of a hash code collision?", "bodyHTML": "<p dir=\"auto\">I don't quite understand the purpose of this check. Won't it make you skip a function in case of a hash code collision?</p>", "author": "pejovica", "createdAt": "2020-07-29T13:10:15Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.replaceMainFunctionName;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.emitUnadornedMain;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_NOTYPE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_VOID;\n+\n+final class CVSymbolSubsectionBuilder {\n+\n+    private final CVDebugInfo cvDebugInfo;\n+    private final CVSymbolSubsection symbolRecord;\n+    private CVLineRecordBuilder lineRecordBuilder;\n+    private DebugContext debugContext = null;\n+\n+    private boolean noMainFound = true;\n+\n+    CVSymbolSubsectionBuilder(CVDebugInfo cvDebugInfo) {\n+        this.symbolRecord = new CVSymbolSubsection(cvDebugInfo);\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    /**\n+     * Build DEBUG_S_SYMBOLS record from all classEntries. (CodeView 4 format allows us to build one\n+     * per class or one per function or one big record - which is what we do here).\n+     *\n+     * The CodeView symbol section Prolog is also a CVSymbolSubsection, but it is not build in this\n+     * class.\n+     */\n+    void build(DebugContext theDebugContext) {\n+        this.debugContext = theDebugContext;\n+        this.lineRecordBuilder = new CVLineRecordBuilder(debugContext, cvDebugInfo);\n+        /* loop over all classes defined in this module. */\n+        for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+            build(classEntry);\n+        }\n+        cvDebugInfo.getCVSymbolSection().addRecord(symbolRecord);\n+    }\n+\n+    /**\n+     * Build all debug info for a classEntry. (does not yet handle member variables).\n+     *\n+     * @param classEntry current class\n+     */\n+    private void build(ClassEntry classEntry) {\n+        String previousMethodName = \"\";\n+        /* Loop over all functions defined in this class. */\n+        for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+            Range primaryRange = primaryEntry.getPrimary();\n+            String newMethodName = fixMethodName(primaryRange);\n+            if (!newMethodName.equals(previousMethodName)) {", "originalCommit": "2b7c351c66a14132a77aef64a09e0d5a6a800367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5OTQ4NA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r465699484", "bodyText": "Technically, yes.  But the collusion space is only the argument list for a given overloaded function, and the functions must be declared sequentially, so it is very small.  I actually suspect that the test is completely unnecessary (if a debug info primary entry represents a class function), but this is defensive code.  If I can confirm that, I'll get rid of this test entirely.", "author": "stooke", "createdAt": "2020-08-05T12:45:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI4NTA1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\nindex eb254c951c8..f0eac5086e0 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n", "chunk": "@@ -73,15 +71,9 @@ final class CVSymbolSubsectionBuilder {\n      * @param classEntry current class\n      */\n     private void build(ClassEntry classEntry) {\n-        String previousMethodName = \"\";\n         /* Loop over all functions defined in this class. */\n         for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-            Range primaryRange = primaryEntry.getPrimary();\n-            String newMethodName = fixMethodName(primaryRange);\n-            if (!newMethodName.equals(previousMethodName)) {\n-                previousMethodName = newMethodName;\n-                build(primaryEntry, newMethodName);\n-            }\n+            build(primaryEntry);\n         }\n     }\n \n", "next_change": {"commit": "289479fcd179647215c85f2d5a8438265e536e2b", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\nindex f0eac5086e0..c8d672cdea2 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n", "chunk": "@@ -72,9 +69,7 @@ final class CVSymbolSubsectionBuilder {\n      */\n     private void build(ClassEntry classEntry) {\n         /* Loop over all functions defined in this class. */\n-        for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-            build(primaryEntry);\n-        }\n+        classEntry.primaryEntries().forEach(primaryEntry -> build(primaryEntry));\n     }\n \n     /**\n", "next_change": {"commit": "4caf93deee510084247c88599752478fc53bd73d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\nindex c8d672cdea2..ec33be0b99f 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n", "chunk": "@@ -69,17 +69,17 @@ final class CVSymbolSubsectionBuilder {\n      */\n     private void build(ClassEntry classEntry) {\n         /* Loop over all functions defined in this class. */\n-        classEntry.primaryEntries().forEach(primaryEntry -> build(primaryEntry));\n+        classEntry.compiledEntries().forEach(compiledEntry -> build(compiledEntry));\n     }\n \n     /**\n      * Emit records for each function: PROC32 S_FRAMEPROC S_END and line number records. (later:\n      * type records as required).\n      *\n-     * @param primaryEntry primary entry for this function\n+     * @param compiledEntry compiled method for this function\n      */\n-    private void build(PrimaryEntry primaryEntry) {\n-        final Range primaryRange = primaryEntry.getPrimary();\n+    private void build(CompiledMethodEntry compiledEntry) {\n+        final Range primaryRange = compiledEntry.getPrimary();\n \n         /* The name as it will appear in the debugger. */\n         final String debuggerName = getDebuggerName(primaryRange);\n", "next_change": {"commit": "77e3a7479e429a3279d3061496d260e35f21f000", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\nindex ec33be0b99f..dd2b8e972f8 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n", "chunk": "@@ -78,11 +117,11 @@ final class CVSymbolSubsectionBuilder {\n      *\n      * @param compiledEntry compiled method for this function\n      */\n-    private void build(CompiledMethodEntry compiledEntry) {\n+    private void buildFunction(CompiledMethodEntry compiledEntry) {\n         final Range primaryRange = compiledEntry.getPrimary();\n \n         /* The name as it will appear in the debugger. */\n-        final String debuggerName = getDebuggerName(primaryRange);\n+        final String debuggerName = CVNames.methodNameToCodeViewName(primaryRange.getMethodEntry());\n \n         /* The name as exposed to the linker. */\n         final String externalName = primaryRange.getSymbolName();\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg4MzA4Mg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r462883082", "body": "Can we rename `symbolRecord` to something more descriptive? E.g.,\r\n```suggestion\r\n    private final CVSymbolSubsection cvSymbolSubsection;\r\n```", "bodyText": "Can we rename symbolRecord to something more descriptive? E.g.,\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final CVSymbolSubsection symbolRecord;\n          \n          \n            \n                private final CVSymbolSubsection cvSymbolSubsection;", "bodyHTML": "<p dir=\"auto\">Can we rename <code>symbolRecord</code> to something more descriptive? E.g.,</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-k\">private</span> <span class=\"pl-k\">final</span> <span class=\"pl-smi\">CVSymbolSubsection</span> <span class=\"x x-first x-last\">symbolRecord</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">private</span> <span class=\"pl-k\">final</span> <span class=\"pl-smi\">CVSymbolSubsection</span> <span class=\"x x-first x-last\">cvSymbolSubsection</span>;</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pejovica", "createdAt": "2020-07-30T09:50:48Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.replaceMainFunctionName;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.emitUnadornedMain;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_NOTYPE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_VOID;\n+\n+final class CVSymbolSubsectionBuilder {\n+\n+    private final CVDebugInfo cvDebugInfo;\n+    private final CVSymbolSubsection symbolRecord;", "originalCommit": "2b7c351c66a14132a77aef64a09e0d5a6a800367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY3MTIzOA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r465671238", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-08-05T11:52:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg4MzA4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\nindex eb254c951c8..f0eac5086e0 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n", "chunk": "@@ -31,22 +31,20 @@ import com.oracle.objectfile.debugentry.PrimaryEntry;\n import com.oracle.objectfile.debugentry.Range;\n import org.graalvm.compiler.debug.DebugContext;\n \n-import static com.oracle.objectfile.pecoff.cv.CVConstants.replaceMainFunctionName;\n-import static com.oracle.objectfile.pecoff.cv.CVConstants.emitUnadornedMain;\n import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_NOTYPE;\n import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_VOID;\n \n final class CVSymbolSubsectionBuilder {\n \n     private final CVDebugInfo cvDebugInfo;\n-    private final CVSymbolSubsection symbolRecord;\n+    private final CVSymbolSubsection cvSymbolSubsection;\n     private CVLineRecordBuilder lineRecordBuilder;\n     private DebugContext debugContext = null;\n \n     private boolean noMainFound = true;\n \n     CVSymbolSubsectionBuilder(CVDebugInfo cvDebugInfo) {\n-        this.symbolRecord = new CVSymbolSubsection(cvDebugInfo);\n+        this.cvSymbolSubsection = new CVSymbolSubsection(cvDebugInfo);\n         this.cvDebugInfo = cvDebugInfo;\n     }\n \n", "next_change": {"commit": "be97e8b0b377da7184398ae13748683d31424624", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\nindex f0eac5086e0..0f9ec7586ec 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n", "chunk": "@@ -38,14 +37,14 @@ final class CVSymbolSubsectionBuilder {\n \n     private final CVDebugInfo cvDebugInfo;\n     private final CVSymbolSubsection cvSymbolSubsection;\n-    private CVLineRecordBuilder lineRecordBuilder;\n-    private DebugContext debugContext = null;\n+    private final CVLineRecordBuilder lineRecordBuilder;\n \n     private boolean noMainFound = true;\n \n     CVSymbolSubsectionBuilder(CVDebugInfo cvDebugInfo) {\n-        this.cvSymbolSubsection = new CVSymbolSubsection(cvDebugInfo);\n         this.cvDebugInfo = cvDebugInfo;\n+        this.cvSymbolSubsection = new CVSymbolSubsection(cvDebugInfo);\n+        this.lineRecordBuilder = new CVLineRecordBuilder(cvDebugInfo);\n     }\n \n     /**\n", "next_change": {"commit": "77e3a7479e429a3279d3061496d260e35f21f000", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\nindex 0f9ec7586ec..dd2b8e972f8 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n", "chunk": "@@ -39,110 +44,116 @@ final class CVSymbolSubsectionBuilder {\n     private final CVSymbolSubsection cvSymbolSubsection;\n     private final CVLineRecordBuilder lineRecordBuilder;\n \n-    private boolean noMainFound = true;\n+    private final String heapName;\n+    private final short heapRegister;\n \n     CVSymbolSubsectionBuilder(CVDebugInfo cvDebugInfo) {\n         this.cvDebugInfo = cvDebugInfo;\n         this.cvSymbolSubsection = new CVSymbolSubsection(cvDebugInfo);\n         this.lineRecordBuilder = new CVLineRecordBuilder(cvDebugInfo);\n+        this.heapName = SectionName.SVM_HEAP.getFormatDependentName(cvDebugInfo.getCVSymbolSection().getOwner().getFormat());\n+        /* For isolates, Graal currently uses r14; this code will handle r8-r15. */\n+        assert 8 <= cvDebugInfo.getHeapbaseRegister() && cvDebugInfo.getHeapbaseRegister() <= 15;\n+        this.heapRegister = (short) (CV_AMD64_R8 + cvDebugInfo.getHeapbaseRegister() - 8);\n     }\n \n     /**\n      * Build DEBUG_S_SYMBOLS record from all classEntries. (CodeView 4 format allows us to build one\n      * per class or one per function or one big record - which is what we do here).\n      *\n-     * The CodeView symbol section Prolog is also a CVSymbolSubsection, but it is not build in this\n+     * The CodeView symbol section Prolog is also a CVSymbolSubsection, but it is not built in this\n      * class.\n      */\n     void build() {\n-        /* loop over all classes defined in this module. */\n-        for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n-            build(classEntry);\n+        /* Loop over all classes defined in this module. */\n+        for (TypeEntry typeEntry : cvDebugInfo.getTypes()) {\n+            /* Add type record for this entry. */\n+            if (typeEntry.isClass()) {\n+                buildClass((ClassEntry) typeEntry);\n+            } else {\n+                addTypeRecords(typeEntry);\n+            }\n         }\n         cvDebugInfo.getCVSymbolSection().addRecord(cvSymbolSubsection);\n     }\n \n     /**\n-     * Build all debug info for a classEntry. (does not yet handle member variables).\n+     * Build all debug info for a classEntry.\n      *\n      * @param classEntry current class\n      */\n-    private void build(ClassEntry classEntry) {\n-        /* Loop over all functions defined in this class. */\n-        for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-            build(primaryEntry);\n-        }\n+    private void buildClass(ClassEntry classEntry) {\n+\n+        /* Define all the functions in this class all functions defined in this class. */\n+        classEntry.compiledEntries().forEach(this::buildFunction);\n+\n+        /* Define the class itself. */\n+        addTypeRecords(classEntry);\n+\n+        /* Add manifested static fields as S_GDATA32 records. */\n+        classEntry.fields().filter(CVSymbolSubsectionBuilder::isManifestedStaticField).forEach(f -> {\n+            int typeIndex = cvDebugInfo.getCVTypeSection().getIndexForPointer(f.getValueType());\n+            String displayName = CVNames.fieldNameToCodeViewName(f);\n+            if (cvDebugInfo.useHeapBase()) {\n+                /*\n+                 * Isolates are enabled. Static member is located at REL32 offset from heap base\n+                 * register.\n+                 */\n+                addSymbolRecord(new CVSymbolSubrecord.CVSymbolRegRel32Record(cvDebugInfo, displayName, typeIndex, f.getOffset(), heapRegister));\n+            } else {\n+                /* Isolates are disabled. Static member is located at offset from heap begin. */\n+                addSymbolRecord(new CVSymbolSubrecord.CVSymbolGData32Record(cvDebugInfo, heapName, displayName, typeIndex, f.getOffset(), (short) 0));\n+            }\n+        });\n+    }\n+\n+    private static boolean isManifestedStaticField(FieldEntry fieldEntry) {\n+        return Modifier.isStatic(fieldEntry.getModifiers()) && fieldEntry.getOffset() >= 0;\n     }\n \n     /**\n      * Emit records for each function: PROC32 S_FRAMEPROC S_END and line number records. (later:\n      * type records as required).\n      *\n-     * @param primaryEntry primary entry for this function\n+     * @param compiledEntry compiled method for this function\n      */\n-    private void build(PrimaryEntry primaryEntry) {\n-        final Range primaryRange = primaryEntry.getPrimary();\n+    private void buildFunction(CompiledMethodEntry compiledEntry) {\n+        final Range primaryRange = compiledEntry.getPrimary();\n \n         /* The name as it will appear in the debugger. */\n-        final String debuggerName = getDebuggerName(primaryRange);\n+        final String debuggerName = CVNames.methodNameToCodeViewName(primaryRange.getMethodEntry());\n \n         /* The name as exposed to the linker. */\n         final String externalName = primaryRange.getSymbolName();\n \n         /* S_PROC32 add function definition. */\n-        int functionTypeIndex = addTypeRecords(primaryEntry);\n+        int functionTypeIndex = addTypeRecords(compiledEntry);\n         byte funcFlags = 0;\n         CVSymbolSubrecord.CVSymbolGProc32Record proc32 = new CVSymbolSubrecord.CVSymbolGProc32Record(cvDebugInfo, externalName, debuggerName, 0, 0, 0, primaryRange.getHi() - primaryRange.getLo(), 0,\n-                        0, functionTypeIndex, primaryRange.getLo(), (short) 0, funcFlags);\n-        addToSymbolSubsection(proc32);\n+                        0, functionTypeIndex, (short) 0, funcFlags);\n+        addSymbolRecord(proc32);\n \n         /* S_FRAMEPROC add frame definitions. */\n         int asynceh = 1 << 9; /* Async exception handling (vc++ uses 1, clang uses 0). */\n+        /* TODO: This may change in the presence of isolates. */\n         int localBP = 1 << 14; /* Local base pointer = SP (0=none, 1=sp, 2=bp 3=r13). */\n         int paramBP = 1 << 16; /* Param base pointer = SP. */\n         int frameFlags = asynceh + localBP + paramBP; /* NB: LLVM uses 0x14000. */\n-        addToSymbolSubsection(new CVSymbolSubrecord.CVSymbolFrameProcRecord(cvDebugInfo, primaryEntry.getFrameSize(), frameFlags));\n+        addSymbolRecord(new CVSymbolSubrecord.CVSymbolFrameProcRecord(cvDebugInfo, compiledEntry.getFrameSize(), frameFlags));\n \n+        /* TODO: add parameter definitions (types have been added already). */\n         /* TODO: add local variables, and their types. */\n         /* TODO: add block definitions. */\n \n         /* S_END add end record. */\n-        addToSymbolSubsection(new CVSymbolSubrecord.CVSymbolEndRecord(cvDebugInfo));\n+        addSymbolRecord(new CVSymbolSubrecord.CVSymbolEndRecord(cvDebugInfo));\n \n         /* Add line number records. */\n-        addLineNumberRecords(primaryEntry);\n-    }\n-\n-    /**\n-     * Rename function names for usability or functionality.\n-     *\n-     * First encountered main function becomes class.main. This is for usability.\n-     *\n-     * All other functions become class.function.999 (where 999 is a hash of the arglist). This is\n-     * because The standard link.exe can't handle odd characters (parentheses or commas, for\n-     * example) in debug information.\n-     *\n-     * This does not affect external symbols used by linker.\n-     *\n-     * TODO: strip illegal characters from arg lists instead (\"link.exe\" - safe names)\n-     *\n-     * @param range Range contained in the method of interest\n-     * @return user debugger friendly method name\n-     */\n-    private String getDebuggerName(Range range) {\n-        final String methodName;\n-        if (noMainFound && range.getMethodName().equals(\"main\")) {\n-            noMainFound = false;\n-            methodName = range.getFullMethodName();\n-        } else {\n-            /* In the future, use a more user-friendly name instead of a hash function. */\n-            methodName = range.getSymbolName();\n-        }\n-        return methodName;\n+        addLineNumberRecords(compiledEntry);\n     }\n \n-    private void addLineNumberRecords(PrimaryEntry primaryEntry) {\n-        CVLineRecord record = lineRecordBuilder.build(primaryEntry);\n+    private void addLineNumberRecords(CompiledMethodEntry compiledEntry) {\n+        CVLineRecord record = lineRecordBuilder.build(compiledEntry);\n         /*\n          * If there are no file entries (perhaps for a synthetic function?), we don't add this\n          * record.\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg5MDUwMA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r462890500", "body": "This method needs a more descriptive name. Or you could just remove it.", "bodyText": "This method needs a more descriptive name. Or you could just remove it.", "bodyHTML": "<p dir=\"auto\">This method needs a more descriptive name. Or you could just remove it.</p>", "author": "pejovica", "createdAt": "2020-07-30T10:04:36Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.replaceMainFunctionName;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.emitUnadornedMain;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_NOTYPE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_VOID;\n+\n+final class CVSymbolSubsectionBuilder {\n+\n+    private final CVDebugInfo cvDebugInfo;\n+    private final CVSymbolSubsection symbolRecord;\n+    private CVLineRecordBuilder lineRecordBuilder;\n+    private DebugContext debugContext = null;\n+\n+    private boolean noMainFound = true;\n+\n+    CVSymbolSubsectionBuilder(CVDebugInfo cvDebugInfo) {\n+        this.symbolRecord = new CVSymbolSubsection(cvDebugInfo);\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    /**\n+     * Build DEBUG_S_SYMBOLS record from all classEntries. (CodeView 4 format allows us to build one\n+     * per class or one per function or one big record - which is what we do here).\n+     *\n+     * The CodeView symbol section Prolog is also a CVSymbolSubsection, but it is not build in this\n+     * class.\n+     */\n+    void build(DebugContext theDebugContext) {\n+        this.debugContext = theDebugContext;\n+        this.lineRecordBuilder = new CVLineRecordBuilder(debugContext, cvDebugInfo);\n+        /* loop over all classes defined in this module. */\n+        for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+            build(classEntry);\n+        }\n+        cvDebugInfo.getCVSymbolSection().addRecord(symbolRecord);\n+    }\n+\n+    /**\n+     * Build all debug info for a classEntry. (does not yet handle member variables).\n+     *\n+     * @param classEntry current class\n+     */\n+    private void build(ClassEntry classEntry) {\n+        String previousMethodName = \"\";\n+        /* Loop over all functions defined in this class. */\n+        for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+            Range primaryRange = primaryEntry.getPrimary();\n+            String newMethodName = fixMethodName(primaryRange);\n+            if (!newMethodName.equals(previousMethodName)) {\n+                previousMethodName = newMethodName;\n+                build(primaryEntry, newMethodName);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emit records for each function: PROC32 S_FRAMEPROC S_END and line number records. (later:\n+     * type records as required).\n+     *\n+     * @param primaryEntry primary entry for this function\n+     * @param methodName method name alias as it will be seen by the user\n+     */\n+    private void build(PrimaryEntry primaryEntry, String methodName) {\n+        final Range primaryRange = primaryEntry.getPrimary();\n+\n+        /* S_PROC32 add function definition. */\n+        int functionTypeIndex = addTypeRecords(primaryEntry);\n+        byte funcFlags = 0;\n+        CVSymbolSubrecord.CVSymbolGProc32Record proc32 = new CVSymbolSubrecord.CVSymbolGProc32Record(cvDebugInfo, methodName, 0, 0, 0, primaryRange.getHi() - primaryRange.getLo(), 0, 0,\n+                        functionTypeIndex, primaryRange.getLo(), (short) 0, funcFlags);\n+        addToSymbolRecord(proc32);\n+\n+        /* S_FRAMEPROC add frame definitions. */\n+        int asynceh = 1 << 9; /* Async exception handling (vc++ uses 1, clang uses 0). */\n+        int localBP = 1 << 14; /* Local base pointer = SP (0=none, 1=sp, 2=bp 3=r13). */\n+        int paramBP = 1 << 16; /* Param base pointer = SP. */\n+        int frameFlags = asynceh + localBP + paramBP; /* NB: LLVM uses 0x14000. */\n+        addToSymbolRecord(new CVSymbolSubrecord.CVSymbolFrameProcRecord(cvDebugInfo, primaryRange.getHi() - primaryRange.getLo(), frameFlags));\n+\n+        /* TODO: add local variables, and their types. */\n+        /* TODO: add block definitions. */\n+\n+        /* S_END add end record. */\n+        addToSymbolRecord(new CVSymbolSubrecord.CVSymbolEndRecord(cvDebugInfo));\n+        addLineNumberRecords(primaryEntry, methodName);\n+    }\n+\n+    /**\n+     * Rename function names for usability or functionality.\n+     *\n+     * First encountered main function becomes class.main (unless replaceMainFunctionName is\n+     * non-null). This is for usability.\n+     *\n+     * All other functions become class.function.999 (where 999 is a hash of the arglist). This is\n+     * because The standard link.exe can't handle odd characters (parentheses or commas, for\n+     * example) in debug information, so\n+     *\n+     * This does not affect external symbols used by linker.\n+     *\n+     * TODO: strip illegal characters from arg lists instead (\"link.exe\" - safe names)\n+     *\n+     * @param range Range contained in the method of interest\n+     * @return user debugger friendly method name\n+     */\n+    private String fixMethodName(Range range) {\n+        final String methodName;\n+        if (replaceMainFunctionName != null && noMainFound && range.getMethodName().equals(\"main\")) {\n+            noMainFound = false;\n+            methodName = replaceMainFunctionName;\n+        } else if (emitUnadornedMain && noMainFound && range.getMethodName().equals(\"main\")) {\n+            /* TODO: check for static void main(String args[]) instead of just main(...). */\n+            noMainFound = false;\n+            methodName = range.getClassAndMethodName();\n+        } else {\n+            /* in the future, use a \"link.exe-safe\" name instead of a hash function. */\n+            long hash = range.getParamNames().hashCode() & 0xffffffffL;\n+            methodName = range.getClassAndMethodName() + \".\" + hash;\n+        }\n+        // debug(\"replacing %s with %s\\n\", range.getFullMethodName(), methodName);\n+        return methodName;\n+    }\n+\n+    private void addLineNumberRecords(PrimaryEntry primaryEntry, String methodName) {\n+        CVLineRecord record = lineRecordBuilder.build(primaryEntry, methodName);\n+        /*\n+         * If the builder decides this entry is uninteresting, we don't build a record. for example,\n+         * Graal intrinsics may be uninteresting to some developers.\n+         */\n+        if (record != null) {\n+            cvDebugInfo.getCVSymbolSection().addRecord(record);\n+        }\n+    }\n+\n+    private void addToSymbolRecord(CVSymbolSubrecord record) {", "originalCommit": "2b7c351c66a14132a77aef64a09e0d5a6a800367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5MTY5Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r465691697", "bodyText": "Renamed to \"addToSymbolSubsection()\" and a comment added.", "author": "stooke", "createdAt": "2020-08-05T12:32:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg5MDUwMA=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\nindex eb254c951c8..f0eac5086e0 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n", "chunk": "@@ -134,44 +132,43 @@ final class CVSymbolSubsectionBuilder {\n      * @param range Range contained in the method of interest\n      * @return user debugger friendly method name\n      */\n-    private String fixMethodName(Range range) {\n+    private String getDebuggerName(Range range) {\n         final String methodName;\n-        if (replaceMainFunctionName != null && noMainFound && range.getMethodName().equals(\"main\")) {\n-            noMainFound = false;\n-            methodName = replaceMainFunctionName;\n-        } else if (emitUnadornedMain && noMainFound && range.getMethodName().equals(\"main\")) {\n-            /* TODO: check for static void main(String args[]) instead of just main(...). */\n+        if (noMainFound && range.getMethodName().equals(\"main\")) {\n             noMainFound = false;\n             methodName = range.getClassAndMethodName();\n         } else {\n-            /* in the future, use a \"link.exe-safe\" name instead of a hash function. */\n-            long hash = range.getParamNames().hashCode() & 0xffffffffL;\n-            methodName = range.getClassAndMethodName() + \".\" + hash;\n+            /* In the future, use a more user-friendly name instead of a hash function. */\n+            methodName = range.getSymbolName();\n         }\n-        // debug(\"replacing %s with %s\\n\", range.getFullMethodName(), methodName);\n         return methodName;\n     }\n \n-    private void addLineNumberRecords(PrimaryEntry primaryEntry, String methodName) {\n-        CVLineRecord record = lineRecordBuilder.build(primaryEntry, methodName);\n+    private void addLineNumberRecords(PrimaryEntry primaryEntry) {\n+        CVLineRecord record = lineRecordBuilder.build(primaryEntry);\n         /*\n-         * If the builder decides this entry is uninteresting, we don't build a record. for example,\n-         * Graal intrinsics may be uninteresting to some developers.\n+         * If there are no file entries (perhaps for a synthetic function?), we don't add this\n+         * record.\n          */\n-        if (record != null) {\n+        if (!record.isEmpty()) {\n             cvDebugInfo.getCVSymbolSection().addRecord(record);\n         }\n     }\n \n-    private void addToSymbolRecord(CVSymbolSubrecord record) {\n-        symbolRecord.addRecord(record);\n+    /**\n+     * Add a record to the symbol subsection. A symbol subsection is contained within the top level\n+     * .debug$S symbol section.\n+     *\n+     * @param record the symbol subrecord to add.\n+     */\n+    private void addToSymbolSubsection(CVSymbolSubrecord record) {\n+        cvSymbolSubsection.addRecord(record);\n     }\n \n     /**\n      * Add type records for function. (later add arglist, and return type and local types).\n      *\n      * @param entry primaryEntry containing entities whoses type records must be added\n-     *\n      * @return type index of function type\n      */\n     private int addTypeRecords(@SuppressWarnings(\"unused\") PrimaryEntry entry) {\n", "next_change": {"commit": "4caf93deee510084247c88599752478fc53bd73d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\nindex f0eac5086e0..ec33be0b99f 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n", "chunk": "@@ -168,10 +163,10 @@ final class CVSymbolSubsectionBuilder {\n     /**\n      * Add type records for function. (later add arglist, and return type and local types).\n      *\n-     * @param entry primaryEntry containing entities whoses type records must be added\n+     * @param entry compild method containing entities whoses type records must be added\n      * @return type index of function type\n      */\n-    private int addTypeRecords(@SuppressWarnings(\"unused\") PrimaryEntry entry) {\n+    private int addTypeRecords(@SuppressWarnings(\"unused\") CompiledMethodEntry entry) {\n         CVTypeRecord.CVTypeArglistRecord argListType = addTypeRecord(new CVTypeRecord.CVTypeArglistRecord().add(T_NOTYPE));\n         CVTypeRecord funcType = addTypeRecord(new CVTypeRecord.CVTypeProcedureRecord().returnType(T_VOID).argList(argListType));\n         return funcType.getSequenceNumber();\n", "next_change": {"commit": "77e3a7479e429a3279d3061496d260e35f21f000", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\nindex ec33be0b99f..dd2b8e972f8 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n", "chunk": "@@ -156,23 +169,35 @@ final class CVSymbolSubsectionBuilder {\n      *\n      * @param record the symbol subrecord to add.\n      */\n-    private void addToSymbolSubsection(CVSymbolSubrecord record) {\n+    private void addSymbolRecord(CVSymbolSubrecord record) {\n         cvSymbolSubsection.addRecord(record);\n     }\n \n     /**\n-     * Add type records for function. (later add arglist, and return type and local types).\n+     * Add type records for a class and all its members.\n      *\n-     * @param entry compild method containing entities whoses type records must be added\n-     * @return type index of function type\n+     * @param typeEntry class to add records for.\n      */\n-    private int addTypeRecords(@SuppressWarnings(\"unused\") CompiledMethodEntry entry) {\n-        CVTypeRecord.CVTypeArglistRecord argListType = addTypeRecord(new CVTypeRecord.CVTypeArglistRecord().add(T_NOTYPE));\n-        CVTypeRecord funcType = addTypeRecord(new CVTypeRecord.CVTypeProcedureRecord().returnType(T_VOID).argList(argListType));\n-        return funcType.getSequenceNumber();\n+    private void addTypeRecords(TypeEntry typeEntry) {\n+        int typeIdx = cvDebugInfo.getCVTypeSection().addTypeRecords(typeEntry).getSequenceNumber();\n+\n+        if (typeIdx > MAX_PRIMITIVE) {\n+            /*\n+             * Adding an S_UDT (User Defined Type) record ensures the linker doesn't throw away the\n+             * type definition.\n+             */\n+            CVSymbolSubrecord.CVSymbolUDTRecord udtRecord = new CVSymbolSubrecord.CVSymbolUDTRecord(cvDebugInfo, typeIdx, CVNames.typeNameToCodeViewName(typeEntry.getTypeName()));\n+            addSymbolRecord(udtRecord);\n+        }\n     }\n \n-    private <T extends CVTypeRecord> T addTypeRecord(T record) {\n-        return cvDebugInfo.getCVTypeSection().addOrReference(record);\n+    /**\n+     * Add type records for a class and all its members.\n+     *\n+     * @param entry compiled method containing entities whos type records must be added\n+     * @return type index of function type\n+     */\n+    private int addTypeRecords(CompiledMethodEntry entry) {\n+        return cvDebugInfo.getCVTypeSection().addTypeRecords(entry).getSequenceNumber();\n     }\n }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjkxODUxMQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r462918511", "body": "As far as I can see, if there is a new file here, it means that there is no line entry that refers to it, so why add it? How will it be used?", "bodyText": "As far as I can see, if there is a new file here, it means that there is no line entry that refers to it, so why add it? How will it be used?", "bodyHTML": "<p dir=\"auto\">As far as I can see, if there is a new file here, it means that there is no line entry that refers to it, so why add it? How will it be used?</p>", "author": "pejovica", "createdAt": "2020-07-30T11:01:13Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVFileTableRecord.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import org.graalvm.compiler.debug.GraalError;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+final class CVFileTableRecord extends CVSymbolRecord {\n+\n+    private static final byte CHECKSUM_NONE = 0x00;\n+    private static final byte CHECKSUM_MD5 = 0x01;\n+    private static final byte CB_VALUE = 0x10;\n+\n+    private static final int FILE_RECORD_LENGTH = 24;\n+\n+    private static final int CHECKSUM_LENGTH = 16;\n+    private static final byte[] EMPTY_CHECKSUM = new byte[CHECKSUM_LENGTH];\n+\n+    private static final int FILE_TABLE_INITIAL_SIZE = 200;\n+\n+    private final CVSymbolSectionImpl.CVStringTable strings;\n+\n+    private int currentOffset = 0;\n+    private Map<FileEntry, Integer> fileEntryToOffsetMap = new LinkedHashMap<>(FILE_TABLE_INITIAL_SIZE);\n+\n+    CVFileTableRecord(CVDebugInfo cvDebugInfo, CVSymbolSectionImpl.CVStringTable strings) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_FILECHKSMS);\n+        this.strings = strings;\n+    }\n+\n+    int addFile(FileEntry entry) {\n+        if (fileEntryToOffsetMap.containsKey(entry)) {\n+            return fileEntryToOffsetMap.get(entry);\n+        } else {\n+            fileEntryToOffsetMap.put(entry, currentOffset);\n+            /* Create required stringtable entry. */\n+            strings.add(fixPath(entry));\n+            currentOffset += FILE_RECORD_LENGTH;\n+            return currentOffset - FILE_RECORD_LENGTH;\n+        }\n+    }\n+\n+    @Override\n+    public int computeSize(int initialPos) {\n+        /*\n+         * As part of computing the size, add all fileEntries ignoring duplicates. Most fileEntries\n+         * are created while building the symbol section.\n+         */\n+        for (FileEntry entry : cvDebugInfo.getFiles()) {\n+            addFile(entry);", "originalCommit": "2b7c351c66a14132a77aef64a09e0d5a6a800367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5MjYwNA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r465692604", "bodyText": "This is partially defensive programming, and partially to account for files that define types without code, which will be used when the type section PR comes along.", "author": "stooke", "createdAt": "2020-08-05T12:34:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjkxODUxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY2NzAyMw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r502667023", "bodyText": "I fine with being defensive, but I don't think we should be adding files just in case. Therefore, I suggest removing this, or you could try to make an assertion that there are no unused files (I think that should be true at least for now), in which case that assertion should be put in CVSymbolSectionImpl.addFileRecord instead of here.", "author": "pejovica", "createdAt": "2020-10-09T20:55:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjkxODUxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVFileTableRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVFileTableRecord.java\nindex 1c48738ce68..4c77a935806 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVFileTableRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVFileTableRecord.java\n", "chunk": "@@ -61,80 +54,94 @@ final class CVFileTableRecord extends CVSymbolRecord {\n     }\n \n     int addFile(FileEntry entry) {\n-        if (fileEntryToOffsetMap.containsKey(entry)) {\n-            return fileEntryToOffsetMap.get(entry);\n+        if (fileEntryToRecordMap.containsKey(entry)) {\n+            return fileEntryToRecordMap.get(entry).getFileTableId();\n         } else {\n-            fileEntryToOffsetMap.put(entry, currentOffset);\n             /* Create required stringtable entry. */\n-            strings.add(fixPath(entry));\n-            currentOffset += FILE_RECORD_LENGTH;\n-            return currentOffset - FILE_RECORD_LENGTH;\n+            int stringTableOffset = strings.add(entry.getFullName());\n+            fileEntryToRecordMap.put(entry, new FileRecord(entry, currentOffset, stringTableOffset));\n+            currentOffset += FileRecord.FILE_RECORD_LENGTH;\n+            return currentOffset - FileRecord.FILE_RECORD_LENGTH;\n         }\n     }\n \n     @Override\n     public int computeSize(int initialPos) {\n-        /*\n-         * As part of computing the size, add all fileEntries ignoring duplicates. Most fileEntries\n-         * are created while building the symbol section.\n-         */\n-        for (FileEntry entry : cvDebugInfo.getFiles()) {\n-            addFile(entry);\n-        }\n-        return initialPos + (fileEntryToOffsetMap.size() * FILE_RECORD_LENGTH);\n+        return initialPos + (fileEntryToRecordMap.size() * FileRecord.FILE_RECORD_LENGTH);\n     }\n \n     @Override\n     public int computeContents(byte[] buffer, int initialPos) {\n         int pos = initialPos;\n-        for (FileEntry entry : fileEntryToOffsetMap.keySet()) {\n-            pos = put(entry, buffer, pos);\n+        for (FileRecord record : fileEntryToRecordMap.values()) {\n+            pos = record.put(buffer, pos);\n         }\n         return pos;\n     }\n \n-    private int put(FileEntry entry, byte[] buffer, int initialPos) {\n-        String fn = fixPath(entry);\n-        int stringId = fn != null ? strings.add(fn) : 0; /* If no file, then use string 0 (= \"\"). */\n-        int pos = CVUtil.putInt(stringId, buffer, initialPos); /* Stringtable index. */\n-        pos = CVUtil.putByte(CB_VALUE, buffer, pos); /* Cb (unknown what this is). */\n-        byte[] checksum = calculateMD5Sum(fn);\n-        if (checksum != null) {\n-            pos = CVUtil.putByte(CHECKSUM_MD5, buffer, pos); /* Checksum type (0x01 == MD5). */\n-            pos = CVUtil.putBytes(checksum, buffer, pos);\n-        } else {\n-            pos = CVUtil.putByte(CHECKSUM_NONE, buffer, pos);\n-            pos = CVUtil.putBytes(EMPTY_CHECKSUM, buffer, pos);\n-        }\n-        pos = CVUtil.align4(pos);\n-        assert pos == initialPos + FILE_RECORD_LENGTH;\n-        return pos;\n+    @Override\n+    public String toString() {\n+        return \"CVFileRecord(type=\" + type + \",pos=\" + recordStartPosition + \", size=\" + fileEntryToRecordMap.size() + \")\";\n     }\n \n-    private static byte[] calculateMD5Sum(String fn) {\n-        try {\n-            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n-            md.update(Files.readAllBytes(Paths.get(fn)));\n-            return md.digest();\n-        } catch (IOException e) {\n-            return null;\n-        } catch (NoSuchAlgorithmException e) {\n-            throw GraalError.shouldNotReachHere();\n+    private static final class FileRecord {\n+\n+        static final int FILE_RECORD_LENGTH = 24;\n+\n+        private static final byte CB_VALUE = 0x10;\n+        private static final int CHECKSUM_LENGTH = 16;\n+        private static final byte CHECKSUM_NONE = 0x00;\n+        private static final byte CHECKSUM_MD5 = 0x01;\n+        private static final byte[] EMPTY_CHECKSUM = new byte[CHECKSUM_LENGTH];\n+\n+        private FileEntry entry;\n+        private int fileTableId;\n+        private int stringTableId;\n+\n+        FileRecord(FileEntry entry, int fileTableId, int stringTableId) {\n+            this.entry = entry;\n+            this.fileTableId = fileTableId;\n+            this.stringTableId = stringTableId;\n         }\n-    }\n \n-    /**\n-     * Convert a FileEntry to a path. Avoid an NPE if there's no DirEntry.\n-     *\n-     * @param fileEntry entry containing uncorrected path.\n-     * @return path string, including directory if it exists.\n-     */\n-    private static String fixPath(FileEntry fileEntry) {\n-        return fileEntry.getDirEntry() != null ? fileEntry.getFullName() : fileEntry.getFileName();\n-    }\n+        private int put(byte[] buffer, int initialPos) {\n+            String fn = entry.getFullName();\n+            int pos = CVUtil.putInt(stringTableId, buffer, initialPos); /* Stringtable index. */\n+            pos = CVUtil.putByte(CB_VALUE, buffer, pos); /* Cb (unknown what this is). */\n+            byte[] checksum = calculateMD5Sum(fn);\n+            if (checksum != null) {\n+                pos = CVUtil.putByte(CHECKSUM_MD5, buffer, pos); /* Checksum type (0x01 == MD5). */\n+                pos = CVUtil.putBytes(checksum, buffer, pos);\n+            } else {\n+                pos = CVUtil.putByte(CHECKSUM_NONE, buffer, pos);\n+                pos = CVUtil.putBytes(EMPTY_CHECKSUM, buffer, pos);\n+            }\n+            pos = CVUtil.align4(pos);\n+            assert pos == initialPos + FILE_RECORD_LENGTH;\n+            return pos;\n+        }\n \n-    @Override\n-    public String toString() {\n-        return \"CVFileRecord(type=\" + type + \",pos=\" + recordStartPosition + \", size=\" + fileEntryToOffsetMap.size() + \")\";\n+        int getFileTableId() {\n+            return fileTableId;\n+        }\n+\n+        /**\n+         * Calculate the MD5 checksum of a file.\n+         *\n+         * @param fn path to file\n+         * @return a byte array containing the checksum, or null if there was an error reading the\n+         *         file.\n+         */\n+        private static byte[] calculateMD5Sum(String fn) {\n+            try {\n+                MessageDigest md = MessageDigest.getInstance(\"MD5\");\n+                md.update(Files.readAllBytes(Paths.get(fn)));\n+                return md.digest();\n+            } catch (IOException e) {\n+                return null;\n+            } catch (NoSuchAlgorithmException e) {\n+                throw GraalError.shouldNotReachHere();\n+            }\n+        }\n     }\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjkyNzU0Ng==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r462927546", "body": "As far as usability goes, I think this is fine. However, I don\u2019t think we need all these \"options\". Could we simplify this and just use the first `main` we find. This should only be temporary anyway (until the actual `main` becomes available via `DebugInfoProvider` as I have already suggested).", "bodyText": "As far as usability goes, I think this is fine. However, I don\u2019t think we need all these \"options\". Could we simplify this and just use the first main we find. This should only be temporary anyway (until the actual main becomes available via DebugInfoProvider as I have already suggested).", "bodyHTML": "<p dir=\"auto\">As far as usability goes, I think this is fine. However, I don\u2019t think we need all these \"options\". Could we simplify this and just use the first <code>main</code> we find. This should only be temporary anyway (until the actual <code>main</code> becomes available via <code>DebugInfoProvider</code> as I have already suggested).</p>", "author": "pejovica", "createdAt": "2020-07-30T11:20:40Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.replaceMainFunctionName;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.emitUnadornedMain;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_NOTYPE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_VOID;\n+\n+final class CVSymbolSubsectionBuilder {\n+\n+    private final CVDebugInfo cvDebugInfo;\n+    private final CVSymbolSubsection symbolRecord;\n+    private CVLineRecordBuilder lineRecordBuilder;\n+    private DebugContext debugContext = null;\n+\n+    private boolean noMainFound = true;\n+\n+    CVSymbolSubsectionBuilder(CVDebugInfo cvDebugInfo) {\n+        this.symbolRecord = new CVSymbolSubsection(cvDebugInfo);\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    /**\n+     * Build DEBUG_S_SYMBOLS record from all classEntries. (CodeView 4 format allows us to build one\n+     * per class or one per function or one big record - which is what we do here).\n+     *\n+     * The CodeView symbol section Prolog is also a CVSymbolSubsection, but it is not build in this\n+     * class.\n+     */\n+    void build(DebugContext theDebugContext) {\n+        this.debugContext = theDebugContext;\n+        this.lineRecordBuilder = new CVLineRecordBuilder(debugContext, cvDebugInfo);\n+        /* loop over all classes defined in this module. */\n+        for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+            build(classEntry);\n+        }\n+        cvDebugInfo.getCVSymbolSection().addRecord(symbolRecord);\n+    }\n+\n+    /**\n+     * Build all debug info for a classEntry. (does not yet handle member variables).\n+     *\n+     * @param classEntry current class\n+     */\n+    private void build(ClassEntry classEntry) {\n+        String previousMethodName = \"\";\n+        /* Loop over all functions defined in this class. */\n+        for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+            Range primaryRange = primaryEntry.getPrimary();\n+            String newMethodName = fixMethodName(primaryRange);\n+            if (!newMethodName.equals(previousMethodName)) {\n+                previousMethodName = newMethodName;\n+                build(primaryEntry, newMethodName);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emit records for each function: PROC32 S_FRAMEPROC S_END and line number records. (later:\n+     * type records as required).\n+     *\n+     * @param primaryEntry primary entry for this function\n+     * @param methodName method name alias as it will be seen by the user\n+     */\n+    private void build(PrimaryEntry primaryEntry, String methodName) {\n+        final Range primaryRange = primaryEntry.getPrimary();\n+\n+        /* S_PROC32 add function definition. */\n+        int functionTypeIndex = addTypeRecords(primaryEntry);\n+        byte funcFlags = 0;\n+        CVSymbolSubrecord.CVSymbolGProc32Record proc32 = new CVSymbolSubrecord.CVSymbolGProc32Record(cvDebugInfo, methodName, 0, 0, 0, primaryRange.getHi() - primaryRange.getLo(), 0, 0,\n+                        functionTypeIndex, primaryRange.getLo(), (short) 0, funcFlags);\n+        addToSymbolRecord(proc32);\n+\n+        /* S_FRAMEPROC add frame definitions. */\n+        int asynceh = 1 << 9; /* Async exception handling (vc++ uses 1, clang uses 0). */\n+        int localBP = 1 << 14; /* Local base pointer = SP (0=none, 1=sp, 2=bp 3=r13). */\n+        int paramBP = 1 << 16; /* Param base pointer = SP. */\n+        int frameFlags = asynceh + localBP + paramBP; /* NB: LLVM uses 0x14000. */\n+        addToSymbolRecord(new CVSymbolSubrecord.CVSymbolFrameProcRecord(cvDebugInfo, primaryRange.getHi() - primaryRange.getLo(), frameFlags));\n+\n+        /* TODO: add local variables, and their types. */\n+        /* TODO: add block definitions. */\n+\n+        /* S_END add end record. */\n+        addToSymbolRecord(new CVSymbolSubrecord.CVSymbolEndRecord(cvDebugInfo));\n+        addLineNumberRecords(primaryEntry, methodName);\n+    }\n+\n+    /**\n+     * Rename function names for usability or functionality.\n+     *\n+     * First encountered main function becomes class.main (unless replaceMainFunctionName is\n+     * non-null). This is for usability.\n+     *\n+     * All other functions become class.function.999 (where 999 is a hash of the arglist). This is\n+     * because The standard link.exe can't handle odd characters (parentheses or commas, for\n+     * example) in debug information, so\n+     *\n+     * This does not affect external symbols used by linker.\n+     *\n+     * TODO: strip illegal characters from arg lists instead (\"link.exe\" - safe names)\n+     *\n+     * @param range Range contained in the method of interest\n+     * @return user debugger friendly method name\n+     */\n+    private String fixMethodName(Range range) {\n+        final String methodName;\n+        if (replaceMainFunctionName != null && noMainFound && range.getMethodName().equals(\"main\")) {\n+            noMainFound = false;\n+            methodName = replaceMainFunctionName;\n+        } else if (emitUnadornedMain && noMainFound && range.getMethodName().equals(\"main\")) {\n+            /* TODO: check for static void main(String args[]) instead of just main(...). */\n+            noMainFound = false;\n+            methodName = range.getClassAndMethodName();", "originalCommit": "2b7c351c66a14132a77aef64a09e0d5a6a800367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk5NzUxNQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r466997515", "bodyText": "For now, the first main function will be  'package.Class.main' no 'package.Class.main_9999999'.", "author": "stooke", "createdAt": "2020-08-07T12:04:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjkyNzU0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\nindex eb254c951c8..f0eac5086e0 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n", "chunk": "@@ -134,44 +132,43 @@ final class CVSymbolSubsectionBuilder {\n      * @param range Range contained in the method of interest\n      * @return user debugger friendly method name\n      */\n-    private String fixMethodName(Range range) {\n+    private String getDebuggerName(Range range) {\n         final String methodName;\n-        if (replaceMainFunctionName != null && noMainFound && range.getMethodName().equals(\"main\")) {\n-            noMainFound = false;\n-            methodName = replaceMainFunctionName;\n-        } else if (emitUnadornedMain && noMainFound && range.getMethodName().equals(\"main\")) {\n-            /* TODO: check for static void main(String args[]) instead of just main(...). */\n+        if (noMainFound && range.getMethodName().equals(\"main\")) {\n             noMainFound = false;\n             methodName = range.getClassAndMethodName();\n         } else {\n-            /* in the future, use a \"link.exe-safe\" name instead of a hash function. */\n-            long hash = range.getParamNames().hashCode() & 0xffffffffL;\n-            methodName = range.getClassAndMethodName() + \".\" + hash;\n+            /* In the future, use a more user-friendly name instead of a hash function. */\n+            methodName = range.getSymbolName();\n         }\n-        // debug(\"replacing %s with %s\\n\", range.getFullMethodName(), methodName);\n         return methodName;\n     }\n \n-    private void addLineNumberRecords(PrimaryEntry primaryEntry, String methodName) {\n-        CVLineRecord record = lineRecordBuilder.build(primaryEntry, methodName);\n+    private void addLineNumberRecords(PrimaryEntry primaryEntry) {\n+        CVLineRecord record = lineRecordBuilder.build(primaryEntry);\n         /*\n-         * If the builder decides this entry is uninteresting, we don't build a record. for example,\n-         * Graal intrinsics may be uninteresting to some developers.\n+         * If there are no file entries (perhaps for a synthetic function?), we don't add this\n+         * record.\n          */\n-        if (record != null) {\n+        if (!record.isEmpty()) {\n             cvDebugInfo.getCVSymbolSection().addRecord(record);\n         }\n     }\n \n-    private void addToSymbolRecord(CVSymbolSubrecord record) {\n-        symbolRecord.addRecord(record);\n+    /**\n+     * Add a record to the symbol subsection. A symbol subsection is contained within the top level\n+     * .debug$S symbol section.\n+     *\n+     * @param record the symbol subrecord to add.\n+     */\n+    private void addToSymbolSubsection(CVSymbolSubrecord record) {\n+        cvSymbolSubsection.addRecord(record);\n     }\n \n     /**\n      * Add type records for function. (later add arglist, and return type and local types).\n      *\n      * @param entry primaryEntry containing entities whoses type records must be added\n-     *\n      * @return type index of function type\n      */\n     private int addTypeRecords(@SuppressWarnings(\"unused\") PrimaryEntry entry) {\n", "next_change": {"commit": "4caf93deee510084247c88599752478fc53bd73d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\nindex f0eac5086e0..ec33be0b99f 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n", "chunk": "@@ -168,10 +163,10 @@ final class CVSymbolSubsectionBuilder {\n     /**\n      * Add type records for function. (later add arglist, and return type and local types).\n      *\n-     * @param entry primaryEntry containing entities whoses type records must be added\n+     * @param entry compild method containing entities whoses type records must be added\n      * @return type index of function type\n      */\n-    private int addTypeRecords(@SuppressWarnings(\"unused\") PrimaryEntry entry) {\n+    private int addTypeRecords(@SuppressWarnings(\"unused\") CompiledMethodEntry entry) {\n         CVTypeRecord.CVTypeArglistRecord argListType = addTypeRecord(new CVTypeRecord.CVTypeArglistRecord().add(T_NOTYPE));\n         CVTypeRecord funcType = addTypeRecord(new CVTypeRecord.CVTypeProcedureRecord().returnType(T_VOID).argList(argListType));\n         return funcType.getSequenceNumber();\n", "next_change": {"commit": "77e3a7479e429a3279d3061496d260e35f21f000", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\nindex ec33be0b99f..dd2b8e972f8 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n", "chunk": "@@ -156,23 +169,35 @@ final class CVSymbolSubsectionBuilder {\n      *\n      * @param record the symbol subrecord to add.\n      */\n-    private void addToSymbolSubsection(CVSymbolSubrecord record) {\n+    private void addSymbolRecord(CVSymbolSubrecord record) {\n         cvSymbolSubsection.addRecord(record);\n     }\n \n     /**\n-     * Add type records for function. (later add arglist, and return type and local types).\n+     * Add type records for a class and all its members.\n      *\n-     * @param entry compild method containing entities whoses type records must be added\n-     * @return type index of function type\n+     * @param typeEntry class to add records for.\n      */\n-    private int addTypeRecords(@SuppressWarnings(\"unused\") CompiledMethodEntry entry) {\n-        CVTypeRecord.CVTypeArglistRecord argListType = addTypeRecord(new CVTypeRecord.CVTypeArglistRecord().add(T_NOTYPE));\n-        CVTypeRecord funcType = addTypeRecord(new CVTypeRecord.CVTypeProcedureRecord().returnType(T_VOID).argList(argListType));\n-        return funcType.getSequenceNumber();\n+    private void addTypeRecords(TypeEntry typeEntry) {\n+        int typeIdx = cvDebugInfo.getCVTypeSection().addTypeRecords(typeEntry).getSequenceNumber();\n+\n+        if (typeIdx > MAX_PRIMITIVE) {\n+            /*\n+             * Adding an S_UDT (User Defined Type) record ensures the linker doesn't throw away the\n+             * type definition.\n+             */\n+            CVSymbolSubrecord.CVSymbolUDTRecord udtRecord = new CVSymbolSubrecord.CVSymbolUDTRecord(cvDebugInfo, typeIdx, CVNames.typeNameToCodeViewName(typeEntry.getTypeName()));\n+            addSymbolRecord(udtRecord);\n+        }\n     }\n \n-    private <T extends CVTypeRecord> T addTypeRecord(T record) {\n-        return cvDebugInfo.getCVTypeSection().addOrReference(record);\n+    /**\n+     * Add type records for a class and all its members.\n+     *\n+     * @param entry compiled method containing entities whos type records must be added\n+     * @return type index of function type\n+     */\n+    private int addTypeRecords(CompiledMethodEntry entry) {\n+        return cvDebugInfo.getCVTypeSection().addTypeRecords(entry).getSequenceNumber();\n     }\n }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgyMDMzNQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r484820335", "body": "This shouldn't be necessary.", "bodyText": "This shouldn't be necessary.", "bodyHTML": "<p dir=\"auto\">This shouldn't be necessary.</p>", "author": "pejovica", "createdAt": "2020-09-08T10:38:48Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/PECoffSymtab.java", "diffHunk": "@@ -299,6 +299,9 @@ public int indexOf(Symbol sym) {\n         if (symtabStruct == null) {\n             throw new IllegalStateException(\"Symbol table content is not decided yet.\");\n         }\n+        if (sym == null) {\n+            throw new NullPointerException(\"symbol doesn't exist yet\");\n+        }", "originalCommit": "f853143b8b1b99dc5ecb13bc9d3f90133041e58f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE2OTQ3OQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r485169479", "bodyText": "This was not my code (you added it in February); are you sure you want me to delete it in this PR?", "author": "stooke", "createdAt": "2020-09-08T20:11:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgyMDMzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ2Nzc1Ng==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r485467756", "bodyText": "Yes, please remove it.", "author": "pejovica", "createdAt": "2020-09-09T09:21:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgyMDMzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU3MzE2NA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r485573164", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-09-09T12:31:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgyMDMzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "9f570e5e713f3e56e46086fad502cb599ddb2406", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/PECoffSymtab.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/PECoffSymtab.java\nindex 0bc011f347b..81d1198596c 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/PECoffSymtab.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/PECoffSymtab.java\n", "chunk": "@@ -299,9 +299,6 @@ public class PECoffSymtab extends ObjectFile.Element implements SymbolTable {\n         if (symtabStruct == null) {\n             throw new IllegalStateException(\"Symbol table content is not decided yet.\");\n         }\n-        if (sym == null) {\n-            throw new NullPointerException(\"symbol doesn't exist yet\");\n-        }\n         return entriesToIndex.get(sym);\n     }\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgzODI3OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r484838278", "body": "```suggestion\r\n                    int hi, int line, boolean isDeoptTarget) {\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                int hi, int line,\n          \n          \n            \n                                boolean isDeoptTarget) {\n          \n          \n            \n                                int hi, int line, boolean isDeoptTarget) {", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                    <span class=\"pl-k\">int</span> hi, <span class=\"pl-k\">int</span> line,</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                    <span class=\"pl-k\">boolean</span> isDeoptTarget) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                    <span class=\"pl-k\">int</span> hi, <span class=\"pl-k\">int</span> line, <span class=\"pl-k\">boolean</span> isDeoptTarget) {</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pejovica", "createdAt": "2020-09-08T11:14:21Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java", "diffHunk": "@@ -56,23 +60,26 @@\n     /*\n      * Create a primary range.\n      */\n-    public Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String paramNames, String returnTypeName, StringTable stringTable, int lo, int hi, int line,\n+    public Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String symbolName, String paramNames, String returnTypeName, StringTable stringTable, int lo,\n+                    int hi, int line,\n                     boolean isDeoptTarget) {", "originalCommit": "f853143b8b1b99dc5ecb13bc9d3f90133041e58f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyNDcwNA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r485124704", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-09-08T18:45:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgzODI3OA=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 1078a5ac8c3..d8166f2ddfa 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -61,8 +61,7 @@ public class Range {\n      * Create a primary range.\n      */\n     public Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String symbolName, String paramNames, String returnTypeName, StringTable stringTable, int lo,\n-                    int hi, int line,\n-                    boolean isDeoptTarget) {\n+                    int hi, int line, boolean isDeoptTarget) {\n         this(fileName, filePath, cachePath, className, methodName, symbolName, paramNames, returnTypeName, stringTable, lo, hi, line, isDeoptTarget, null);\n     }\n \n", "next_change": {"commit": "b307ee84155fb340719a658a7be2cc9159c49c02", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex d8166f2ddfa..6cdd3ed052a 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -60,41 +57,42 @@ public class Range {\n     /*\n      * Create a primary range.\n      */\n-    public Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String symbolName, String paramNames, String returnTypeName, StringTable stringTable, int lo,\n-                    int hi, int line, boolean isDeoptTarget) {\n-        this(fileName, filePath, cachePath, className, methodName, symbolName, paramNames, returnTypeName, stringTable, lo, hi, line, isDeoptTarget, null);\n+    public Range(String className, String methodName, String symbolName, String paramSignature, String returnTypeName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n+                    int modifiers, boolean isDeoptTarget) {\n+        this(className, methodName, symbolName, paramSignature, returnTypeName, stringTable, fileEntry, lo, hi, line, modifiers, isDeoptTarget, null);\n     }\n \n     /*\n      * Create a secondary range.\n      */\n-    public Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String symbolName, String paramNames, String returnTypeName, StringTable stringTable, int lo,\n-                    int hi, int line, Range primary) {\n-        this(fileName, filePath, cachePath, className, methodName, symbolName, paramNames, returnTypeName, stringTable, lo, hi, line, false, primary);\n+    public Range(String className, String methodName, String symbolName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n+                    Range primary) {\n+        this(className, methodName, symbolName, \"\", \"\", stringTable, fileEntry, lo, hi, line, 0, false, primary);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String symbolName, String paramNames, String returnTypeName, StringTable stringTable, int lo,\n-                    int hi, int line, boolean isDeoptTarget, Range primary) {\n-        /*\n-         * Currently file name and full method name need to go into the debug_str section other\n-         * strings just need to be deduplicated to save space.\n-         */\n-        this.fileName = (fileName == null ? null : stringTable.uniqueDebugString(fileName));\n-        this.filePath = filePath;\n-        this.cachePath = (cachePath == null ? \"\" : stringTable.uniqueDebugString(cachePath.toString()));\n+    private Range(String className, String methodName, String symbolName, String paramSignature, String returnTypeName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n+                    int modifiers, boolean isDeoptTarget, Range primary) {\n+        this.fileEntry = fileEntry;\n+        if (fileEntry != null) {\n+            stringTable.uniqueDebugString(fileEntry.getFileName());\n+            stringTable.uniqueDebugString(fileEntry.getPathName());\n+        }\n         this.className = stringTable.uniqueString(className);\n         this.methodName = stringTable.uniqueString(methodName);\n         this.symbolName = stringTable.uniqueString(symbolName);\n-        this.paramNames = stringTable.uniqueString(paramNames);\n+        this.paramSignature = stringTable.uniqueString(paramSignature);\n         this.returnTypeName = stringTable.uniqueString(returnTypeName);\n-        this.fullMethodName = stringTable.uniqueDebugString(constructClassAndMethodNameWithParams());\n+        this.fullMethodName = stringTable.uniqueString(constructClassAndMethodName());\n+        this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n+        this.fullMethodNameWithParamsAndReturnType = stringTable.uniqueString(constructClassAndMethodNameWithParamsAndReturnType());\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n         this.isDeoptTarget = isDeoptTarget;\n+        this.modifiers = modifiers;\n         this.primary = primary;\n     }\n \n", "next_change": {"commit": "b384283b5ac0e455e66648c0d661ce5410bdd863", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 6cdd3ed052a..9bea361bef6 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -34,65 +34,52 @@ package com.oracle.objectfile.debugentry;\n \n public class Range {\n     private static final String CLASS_DELIMITER = \".\";\n-    private FileEntry fileEntry;\n-    private String className;\n-    private String methodName;\n-    private String symbolName;\n-    private String paramSignature;\n-    private String returnTypeName;\n-    private String methodNameWithParams;\n-    private String fullMethodName;\n-    private String fullMethodNameWithParams;\n-    private String fullMethodNameWithParamsAndReturnType;\n-    private int lo;\n-    private int hi;\n-    private int line;\n-    private boolean isDeoptTarget;\n-    private int modifiers;\n+    private final FileEntry fileEntry;\n+    private MethodEntry methodEntry;\n+    private final String symbolName;\n+    private final String fullMethodNameWithParams;\n+    private final int lo;\n+    private final int hi;\n+    private final int line;\n+    private final boolean isDeoptTarget;\n     /*\n      * This is null for a primary range.\n      */\n-    private Range primary;\n+    private final Range primary;\n \n     /*\n      * Create a primary range.\n      */\n-    public Range(String className, String methodName, String symbolName, String paramSignature, String returnTypeName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n-                    int modifiers, boolean isDeoptTarget) {\n-        this(className, methodName, symbolName, paramSignature, returnTypeName, stringTable, fileEntry, lo, hi, line, modifiers, isDeoptTarget, null);\n+    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n+                 boolean isDeoptTarget) {\n+        this(symbolName, stringTable, methodEntry, fileEntry, lo, hi, line, isDeoptTarget, null);\n     }\n \n     /*\n      * Create a secondary range.\n      */\n-    public Range(String className, String methodName, String symbolName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n-                    Range primary) {\n-        this(className, methodName, symbolName, \"\", \"\", stringTable, fileEntry, lo, hi, line, 0, false, primary);\n+    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n+        this(symbolName, stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, false, primary);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(String className, String methodName, String symbolName, String paramSignature, String returnTypeName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n-                    int modifiers, boolean isDeoptTarget, Range primary) {\n-        this.fileEntry = fileEntry;\n+    private Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n+                    boolean isDeoptTarget, Range primary) {\n+        this.fileEntry = fileEntry; // TODO remove and use fileEntry from MethodEntry\n         if (fileEntry != null) {\n             stringTable.uniqueDebugString(fileEntry.getFileName());\n             stringTable.uniqueDebugString(fileEntry.getPathName());\n         }\n-        this.className = stringTable.uniqueString(className);\n-        this.methodName = stringTable.uniqueString(methodName);\n+        assert methodEntry != null;\n+        this.methodEntry = methodEntry;\n         this.symbolName = stringTable.uniqueString(symbolName);\n-        this.paramSignature = stringTable.uniqueString(paramSignature);\n-        this.returnTypeName = stringTable.uniqueString(returnTypeName);\n-        this.fullMethodName = stringTable.uniqueString(constructClassAndMethodName());\n         this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n-        this.fullMethodNameWithParamsAndReturnType = stringTable.uniqueString(constructClassAndMethodNameWithParamsAndReturnType());\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n         this.isDeoptTarget = isDeoptTarget;\n-        this.modifiers = modifiers;\n         this.primary = primary;\n     }\n \n", "next_change": {"commit": "f485a3c15f5e29daf480657c0bfa22662f8005ae", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 9bea361bef6..a3d6e1c0db2 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -79,7 +77,6 @@ public class Range {\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n-        this.isDeoptTarget = isDeoptTarget;\n         this.primary = primary;\n     }\n \n", "next_change": {"commit": "dbb2c7607429817e58a1a9af8012e25e861368dc", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex a3d6e1c0db2..af465363bbf 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -49,30 +48,29 @@ public class Range {\n     /*\n      * Create a primary range.\n      */\n-    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n-        this(symbolName, stringTable, methodEntry, fileEntry, lo, hi, line, null);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n+        this(stringTable, methodEntry, fileEntry, lo, hi, line, null);\n     }\n \n     /*\n      * Create a secondary range.\n      */\n-    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n-        this(symbolName, stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n+        this(stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n+    private Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n                     Range primary) {\n-        this.fileEntry = fileEntry; // TODO remove and use fileEntry from MethodEntry\n+        this.fileEntry = fileEntry;\n         if (fileEntry != null) {\n             stringTable.uniqueDebugString(fileEntry.getFileName());\n             stringTable.uniqueDebugString(fileEntry.getPathName());\n         }\n         assert methodEntry != null;\n         this.methodEntry = methodEntry;\n-        this.symbolName = stringTable.uniqueString(symbolName);\n         this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n         this.lo = lo;\n         this.hi = hi;\n", "next_change": {"commit": "a658b95d63a93b1980e4ac81fd4c034c70b9d9cb", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex af465363bbf..5f7f3fe3bda 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -48,28 +47,19 @@ public class Range {\n     /*\n      * Create a primary range.\n      */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n-        this(stringTable, methodEntry, fileEntry, lo, hi, line, null);\n-    }\n-\n-    /*\n-     * Create a secondary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n-        this(stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line) {\n+        this(stringTable, methodEntry, lo, hi, line, null);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n-                    Range primary) {\n-        this.fileEntry = fileEntry;\n-        if (fileEntry != null) {\n-            stringTable.uniqueDebugString(fileEntry.getFileName());\n-            stringTable.uniqueDebugString(fileEntry.getPathName());\n-        }\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n         assert methodEntry != null;\n+        if (methodEntry.fileEntry != null) {\n+            stringTable.uniqueDebugString(methodEntry.fileEntry.getFileName());\n+            stringTable.uniqueDebugString(methodEntry.fileEntry.getPathName());\n+        }\n         this.methodEntry = methodEntry;\n         this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n         this.lo = lo;\n", "next_change": {"commit": "6fcf98378231f0e754061b683c3dba387ce8b0e9", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 5f7f3fe3bda..cc407a53acd 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -65,7 +68,10 @@ public class Range {\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n+        this.isInlined = isInline;\n         this.primary = primary;\n+        this.withChildren = withChildren;\n+        this.caller = caller;\n     }\n \n     public boolean contains(Range other) {\n", "next_change": {"commit": "abe98eaaa6dd772b7419b819fa342e810a0939e0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex cc407a53acd..037024f1755 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -71,6 +74,7 @@ public class Range {\n         this.isInlined = isInline;\n         this.primary = primary;\n         this.withChildren = withChildren;\n+        this.withInlinedChildren = false;\n         this.caller = caller;\n     }\n \n", "next_change": {"commit": "268c33256b26217c50339f452adea942fb48818f", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 037024f1755..1951241dda1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -73,9 +93,32 @@ public class Range {\n         this.line = line;\n         this.isInlined = isInline;\n         this.primary = primary;\n-        this.withChildren = withChildren;\n-        this.withInlinedChildren = false;\n+        this.firstCallee = null;\n+        this.lastCallee = null;\n+        this.nextCallee = null;\n         this.caller = caller;\n+        if (caller != null) {\n+            caller.addCallee(this);\n+        }\n+        if (this.isPrimary()) {\n+            this.depth = -1;\n+        } else {\n+            this.depth = caller.depth + 1;\n+        }\n+    }\n+\n+    private void addCallee(Range callee) {\n+        assert this.lo <= callee.lo;\n+        assert this.hi >= callee.hi;\n+        assert callee.caller == this;\n+        assert callee.nextCallee == null;\n+        if (this.firstCallee == null) {\n+            assert this.lastCallee == null;\n+            this.firstCallee = this.lastCallee = callee;\n+        } else {\n+            this.lastCallee.nextCallee = callee;\n+            this.lastCallee = callee;\n+        }\n     }\n \n     public boolean contains(Range other) {\n", "next_change": {"commit": "6ae5665ec0f5f89ff4a7804dbeec25c85d0982ea", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 1951241dda1..43c64a540e9 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -111,12 +111,12 @@ public class Range {\n         assert this.lo <= callee.lo;\n         assert this.hi >= callee.hi;\n         assert callee.caller == this;\n-        assert callee.nextCallee == null;\n+        assert callee.siblingCallee == null;\n         if (this.firstCallee == null) {\n             assert this.lastCallee == null;\n             this.firstCallee = this.lastCallee = callee;\n         } else {\n-            this.lastCallee.nextCallee = callee;\n+            this.lastCallee.siblingCallee = callee;\n             this.lastCallee = callee;\n         }\n     }\n", "next_change": {"commit": "9acf1c5d597e38f3e832360ce3f372ad94b16e9e", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\ndeleted file mode 100644\nindex 43c64a540e9..00000000000\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ /dev/null\n", "chunk": "@@ -1,339 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.objectfile.debugentry;\n-\n-import org.graalvm.compiler.debug.DebugContext;\n-\n-/**\n- * Details of a specific address range in a compiled method either a primary range identifying a\n- * whole method or a sub-range identifying a sequence of instructions that belong to an inlined\n- * method. Each sub-range is linked with its caller and its callees, forming a call tree.\n- */\n-public class Range {\n-    private static final String CLASS_DELIMITER = \".\";\n-    private Range caller;\n-    private final MethodEntry methodEntry;\n-    private final String fullMethodName;\n-    private final String fullMethodNameWithParams;\n-    private final int lo;\n-    private int hi;\n-    private final int line;\n-    private final boolean isInlined;\n-    private final int depth;\n-    /**\n-     * This is null for a primary range. For sub ranges it holds the root of the call tree they\n-     * belong to.\n-     */\n-    private final Range primary;\n-\n-    /*\n-     * Support for tree of nested inline callee ranges\n-     */\n-\n-    /**\n-     * The first direct callee whose range is wholly contained in this range.\n-     */\n-    private Range firstCallee;\n-\n-    /**\n-     * The last direct callee whose range is wholly contained in this range.\n-     */\n-    private Range lastCallee;\n-\n-    /**\n-     * A link to a sibling callee, i.e., a range sharing the same caller with this range.\n-     */\n-    private Range siblingCallee;\n-\n-    /*\n-     * Create a primary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line) {\n-        this(stringTable, methodEntry, lo, hi, line, null, false, null);\n-    }\n-\n-    /*\n-     * Create a primary or secondary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary, boolean isInline, Range caller) {\n-        assert methodEntry != null;\n-        if (methodEntry.fileEntry != null) {\n-            stringTable.uniqueDebugString(methodEntry.fileEntry.getFileName());\n-            stringTable.uniqueDebugString(methodEntry.fileEntry.getPathName());\n-        }\n-        this.methodEntry = methodEntry;\n-        this.fullMethodName = isInline ? stringTable.uniqueDebugString(constructClassAndMethodName()) : stringTable.uniqueString(constructClassAndMethodName());\n-        this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n-        this.lo = lo;\n-        this.hi = hi;\n-        this.line = line;\n-        this.isInlined = isInline;\n-        this.primary = primary;\n-        this.firstCallee = null;\n-        this.lastCallee = null;\n-        this.siblingCallee = null;\n-        this.caller = caller;\n-        if (caller != null) {\n-            caller.addCallee(this);\n-        }\n-        if (this.isPrimary()) {\n-            this.depth = -1;\n-        } else {\n-            this.depth = caller.depth + 1;\n-        }\n-    }\n-\n-    private void addCallee(Range callee) {\n-        assert this.lo <= callee.lo;\n-        assert this.hi >= callee.hi;\n-        assert callee.caller == this;\n-        assert callee.siblingCallee == null;\n-        if (this.firstCallee == null) {\n-            assert this.lastCallee == null;\n-            this.firstCallee = this.lastCallee = callee;\n-        } else {\n-            this.lastCallee.siblingCallee = callee;\n-            this.lastCallee = callee;\n-        }\n-    }\n-\n-    public boolean contains(Range other) {\n-        return (lo <= other.lo && hi >= other.hi);\n-    }\n-\n-    public boolean isPrimary() {\n-        return getPrimary() == null;\n-    }\n-\n-    public Range getPrimary() {\n-        return primary;\n-    }\n-\n-    public String getClassName() {\n-        return methodEntry.ownerType.typeName;\n-    }\n-\n-    public String getMethodName() {\n-        return methodEntry.memberName;\n-    }\n-\n-    public String getSymbolName() {\n-        return methodEntry.getSymbolName();\n-    }\n-\n-    public int getHi() {\n-        return hi;\n-    }\n-\n-    public int getLo() {\n-        return lo;\n-    }\n-\n-    public int getLine() {\n-        return line;\n-    }\n-\n-    public String getFullMethodName() {\n-        return fullMethodName;\n-    }\n-\n-    public String getFullMethodNameWithParams() {\n-        return fullMethodNameWithParams;\n-    }\n-\n-    public boolean isDeoptTarget() {\n-        return methodEntry.isDeopt();\n-    }\n-\n-    private String getExtendedMethodName(boolean includeClass, boolean includeParams, boolean includeReturnType) {\n-        StringBuilder builder = new StringBuilder();\n-        if (includeReturnType && methodEntry.valueType.typeName.length() > 0) {\n-            builder.append(methodEntry.valueType.typeName);\n-            builder.append(' ');\n-        }\n-        if (includeClass && getClassName() != null) {\n-            builder.append(getClassName());\n-            builder.append(CLASS_DELIMITER);\n-        }\n-        builder.append(getMethodName());\n-        if (includeParams) {\n-            builder.append('(');\n-            builder.append(String.join(\", \", methodEntry.paramNames));\n-            builder.append(')');\n-        }\n-        if (includeReturnType) {\n-            builder.append(\" \");\n-            builder.append(methodEntry.valueType.typeName);\n-        }\n-        return builder.toString();\n-    }\n-\n-    private String constructClassAndMethodName() {\n-        return getExtendedMethodName(true, false, false);\n-    }\n-\n-    private String constructClassAndMethodNameWithParams() {\n-        return getExtendedMethodName(true, true, false);\n-    }\n-\n-    public FileEntry getFileEntry() {\n-        return methodEntry.fileEntry;\n-    }\n-\n-    public int getModifiers() {\n-        return methodEntry.modifiers;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"Range(lo=0x%05x hi=0x%05x %s %s:%d)\", lo, hi, constructClassAndMethodNameWithParams(), methodEntry.getFullFileName(), line);\n-    }\n-\n-    public String getFileName() {\n-        return methodEntry.getFileName();\n-    }\n-\n-    public MethodEntry getMethodEntry() {\n-        return methodEntry;\n-    }\n-\n-    public boolean isInlined() {\n-        return isInlined;\n-    }\n-\n-    public Range getCaller() {\n-        return caller;\n-    }\n-\n-    public Range getFirstCallee() {\n-        return firstCallee;\n-    }\n-\n-    public Range getSiblingCallee() {\n-        return siblingCallee;\n-    }\n-\n-    public Range getLastCallee() {\n-        return lastCallee;\n-    }\n-\n-    public boolean isLeaf() {\n-        return firstCallee == null;\n-    }\n-\n-    public int getDepth() {\n-        return depth;\n-    }\n-\n-    /**\n-     * Minimizes the nodes in the tree that track the inline call hierarchy and associated code\n-     * ranges. The initial range tree models the call hierarchy as presented in the original debug\n-     * line info. It consists of a root node each of whose children is a sequence of linear call\n-     * chains, either a single leaf node for some given file and line or a series of inline calls to\n-     * such a leaf node. In this initial tree all node ranges in a given chain have the same lo and\n-     * hi address and chains are properly ordered by range The merge algorithm works across siblings\n-     * at successive depths starting at depth 1. Once all possible nodes at a given depth have been\n-     * merged their children can then be merged. A successor node may only be merged into its\n-     * predecessor if the nodes have contiguous ranges and idenitfy the same method, line and file.\n-     * The range and children of the merged node are, respectively, the union of the input ranges\n-     * and children. This preserves the invariant that child ranges lie within their parent range.\n-     *\n-     * @param debugContext\n-     */\n-    public void mergeSubranges(DebugContext debugContext) {\n-        Range next = getFirstCallee();\n-        if (next == null) {\n-            return;\n-        }\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Merge subranges [0x%x, 0x%x] %s\", lo, hi, getFullMethodNameWithParams());\n-        /* merge siblings together if possible, reparenting children to the merged node */\n-        while (next != null) {\n-            next = next.maybeMergeSibling(debugContext);\n-        }\n-        /* now recurse down to merge children of whatever nodes remain */\n-        next = getFirstCallee();\n-        /* now this level is merged recursively merge children of each child node. */\n-        while (next != null) {\n-            next.mergeSubranges(debugContext);\n-            next = next.getSiblingCallee();\n-        }\n-    }\n-\n-    /**\n-     * Removes and merges the next sibling returning the current node or it skips past the current\n-     * node as is and returns the next sibling or null if no sibling exists.\n-     */\n-    private Range maybeMergeSibling(DebugContext debugContext) {\n-        Range sibling = getSiblingCallee();\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Merge subrange (maybe) [0x%x, 0x%x] %s\", lo, hi, getFullMethodNameWithParams());\n-        if (sibling == null) {\n-            /* all child nodes at this level have been merged */\n-            return null;\n-        }\n-        if (hi < sibling.lo) {\n-            /* cannot merge non-contiguous ranges, move on. */\n-            return sibling;\n-        }\n-        if (getMethodEntry() != sibling.getMethodEntry()) {\n-            /* cannot merge distinct callers, move on. */\n-            return sibling;\n-        }\n-        if (getLine() != sibling.getLine()) {\n-            /* cannot merge callers with different line numbers, move on. */\n-            return sibling;\n-        }\n-        /* splice out the sibling from the chain and update this one to include it. */\n-        unlink(debugContext, sibling);\n-        /* relocate the siblings children to this node. */\n-        reparentChildren(debugContext, sibling);\n-        /* return the merged node so we can maybe merge it again. */\n-        return this;\n-    }\n-\n-    private void unlink(DebugContext debugContext, Range sibling) {\n-        assert hi == sibling.lo : String.format(\"gap in range [0x%x,0x%x] %s [0x%x,0x%x] %s\",\n-                        lo, hi, getFullMethodNameWithParams(), sibling.getLo(), sibling.getHi(), sibling.getFullMethodNameWithParams());\n-        assert this.isInlined == sibling.isInlined : String.format(\"change in inlined [0x%x,0x%x] %s %s [0x%x,0x%x] %s %s\",\n-                        lo, hi, getFullMethodNameWithParams(), Boolean.valueOf(this.isInlined), sibling.lo, sibling.hi, sibling.getFullMethodNameWithParams(), Boolean.valueOf(sibling.isInlined));\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Combining [0x%x, 0x%x] %s into [0x%x, 0x%x] %s\", sibling.lo, sibling.hi, sibling.getFullMethodName(), lo, hi, getFullMethodNameWithParams());\n-        this.hi = sibling.hi;\n-        this.siblingCallee = sibling.siblingCallee;\n-    }\n-\n-    private void reparentChildren(DebugContext debugContext, Range sibling) {\n-        Range siblingNext = sibling.getFirstCallee();\n-        while (siblingNext != null) {\n-            debugContext.log(DebugContext.INFO_LEVEL, \"Reparenting [0x%x, 0x%x] %s to [0x%x, 0x%x] %s\", siblingNext.lo, siblingNext.hi, siblingNext.getFullMethodName(), lo, hi,\n-                            getFullMethodNameWithParams());\n-            siblingNext.caller = this;\n-            Range newSiblingNext = siblingNext.siblingCallee;\n-            siblingNext.siblingCallee = null;\n-            addCallee(siblingNext);\n-            siblingNext = newSiblingNext;\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgzODUxMA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r484838510", "body": "```suggestion\r\n                    int hi, int line, Range primary) {\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                int hi, int line,\n          \n          \n            \n                                Range primary) {\n          \n          \n            \n                                int hi, int line, Range primary) {", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                    <span class=\"pl-k\">int</span> hi, <span class=\"pl-k\">int</span> line,</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                    <span class=\"pl-smi\">Range</span> primary) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                    <span class=\"pl-k\">int</span> hi, <span class=\"pl-k\">int</span> line, <span class=\"pl-smi\">Range</span> primary) {</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pejovica", "createdAt": "2020-09-08T11:14:51Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java", "diffHunk": "@@ -56,23 +60,26 @@\n     /*\n      * Create a primary range.\n      */\n-    public Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String paramNames, String returnTypeName, StringTable stringTable, int lo, int hi, int line,\n+    public Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String symbolName, String paramNames, String returnTypeName, StringTable stringTable, int lo,\n+                    int hi, int line,\n                     boolean isDeoptTarget) {\n-        this(fileName, filePath, cachePath, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, line, isDeoptTarget, null);\n+        this(fileName, filePath, cachePath, className, methodName, symbolName, paramNames, returnTypeName, stringTable, lo, hi, line, isDeoptTarget, null);\n     }\n \n     /*\n      * Create a secondary range.\n      */\n-    public Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String paramNames, String returnTypeName, StringTable stringTable, int lo, int hi, int line,\n+    public Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String symbolName, String paramNames, String returnTypeName, StringTable stringTable, int lo,\n+                    int hi, int line,\n                     Range primary) {", "originalCommit": "f853143b8b1b99dc5ecb13bc9d3f90133041e58f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyNDg3NA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r485124874", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-09-08T18:45:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgzODUxMA=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 1078a5ac8c3..d8166f2ddfa 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -70,8 +69,7 @@ public class Range {\n      * Create a secondary range.\n      */\n     public Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String symbolName, String paramNames, String returnTypeName, StringTable stringTable, int lo,\n-                    int hi, int line,\n-                    Range primary) {\n+                    int hi, int line, Range primary) {\n         this(fileName, filePath, cachePath, className, methodName, symbolName, paramNames, returnTypeName, stringTable, lo, hi, line, false, primary);\n     }\n \n", "next_change": {"commit": "b307ee84155fb340719a658a7be2cc9159c49c02", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex d8166f2ddfa..6cdd3ed052a 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -60,41 +57,42 @@ public class Range {\n     /*\n      * Create a primary range.\n      */\n-    public Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String symbolName, String paramNames, String returnTypeName, StringTable stringTable, int lo,\n-                    int hi, int line, boolean isDeoptTarget) {\n-        this(fileName, filePath, cachePath, className, methodName, symbolName, paramNames, returnTypeName, stringTable, lo, hi, line, isDeoptTarget, null);\n+    public Range(String className, String methodName, String symbolName, String paramSignature, String returnTypeName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n+                    int modifiers, boolean isDeoptTarget) {\n+        this(className, methodName, symbolName, paramSignature, returnTypeName, stringTable, fileEntry, lo, hi, line, modifiers, isDeoptTarget, null);\n     }\n \n     /*\n      * Create a secondary range.\n      */\n-    public Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String symbolName, String paramNames, String returnTypeName, StringTable stringTable, int lo,\n-                    int hi, int line, Range primary) {\n-        this(fileName, filePath, cachePath, className, methodName, symbolName, paramNames, returnTypeName, stringTable, lo, hi, line, false, primary);\n+    public Range(String className, String methodName, String symbolName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n+                    Range primary) {\n+        this(className, methodName, symbolName, \"\", \"\", stringTable, fileEntry, lo, hi, line, 0, false, primary);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String symbolName, String paramNames, String returnTypeName, StringTable stringTable, int lo,\n-                    int hi, int line, boolean isDeoptTarget, Range primary) {\n-        /*\n-         * Currently file name and full method name need to go into the debug_str section other\n-         * strings just need to be deduplicated to save space.\n-         */\n-        this.fileName = (fileName == null ? null : stringTable.uniqueDebugString(fileName));\n-        this.filePath = filePath;\n-        this.cachePath = (cachePath == null ? \"\" : stringTable.uniqueDebugString(cachePath.toString()));\n+    private Range(String className, String methodName, String symbolName, String paramSignature, String returnTypeName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n+                    int modifiers, boolean isDeoptTarget, Range primary) {\n+        this.fileEntry = fileEntry;\n+        if (fileEntry != null) {\n+            stringTable.uniqueDebugString(fileEntry.getFileName());\n+            stringTable.uniqueDebugString(fileEntry.getPathName());\n+        }\n         this.className = stringTable.uniqueString(className);\n         this.methodName = stringTable.uniqueString(methodName);\n         this.symbolName = stringTable.uniqueString(symbolName);\n-        this.paramNames = stringTable.uniqueString(paramNames);\n+        this.paramSignature = stringTable.uniqueString(paramSignature);\n         this.returnTypeName = stringTable.uniqueString(returnTypeName);\n-        this.fullMethodName = stringTable.uniqueDebugString(constructClassAndMethodNameWithParams());\n+        this.fullMethodName = stringTable.uniqueString(constructClassAndMethodName());\n+        this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n+        this.fullMethodNameWithParamsAndReturnType = stringTable.uniqueString(constructClassAndMethodNameWithParamsAndReturnType());\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n         this.isDeoptTarget = isDeoptTarget;\n+        this.modifiers = modifiers;\n         this.primary = primary;\n     }\n \n", "next_change": {"commit": "b384283b5ac0e455e66648c0d661ce5410bdd863", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 6cdd3ed052a..9bea361bef6 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -34,65 +34,52 @@ package com.oracle.objectfile.debugentry;\n \n public class Range {\n     private static final String CLASS_DELIMITER = \".\";\n-    private FileEntry fileEntry;\n-    private String className;\n-    private String methodName;\n-    private String symbolName;\n-    private String paramSignature;\n-    private String returnTypeName;\n-    private String methodNameWithParams;\n-    private String fullMethodName;\n-    private String fullMethodNameWithParams;\n-    private String fullMethodNameWithParamsAndReturnType;\n-    private int lo;\n-    private int hi;\n-    private int line;\n-    private boolean isDeoptTarget;\n-    private int modifiers;\n+    private final FileEntry fileEntry;\n+    private MethodEntry methodEntry;\n+    private final String symbolName;\n+    private final String fullMethodNameWithParams;\n+    private final int lo;\n+    private final int hi;\n+    private final int line;\n+    private final boolean isDeoptTarget;\n     /*\n      * This is null for a primary range.\n      */\n-    private Range primary;\n+    private final Range primary;\n \n     /*\n      * Create a primary range.\n      */\n-    public Range(String className, String methodName, String symbolName, String paramSignature, String returnTypeName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n-                    int modifiers, boolean isDeoptTarget) {\n-        this(className, methodName, symbolName, paramSignature, returnTypeName, stringTable, fileEntry, lo, hi, line, modifiers, isDeoptTarget, null);\n+    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n+                 boolean isDeoptTarget) {\n+        this(symbolName, stringTable, methodEntry, fileEntry, lo, hi, line, isDeoptTarget, null);\n     }\n \n     /*\n      * Create a secondary range.\n      */\n-    public Range(String className, String methodName, String symbolName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n-                    Range primary) {\n-        this(className, methodName, symbolName, \"\", \"\", stringTable, fileEntry, lo, hi, line, 0, false, primary);\n+    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n+        this(symbolName, stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, false, primary);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(String className, String methodName, String symbolName, String paramSignature, String returnTypeName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n-                    int modifiers, boolean isDeoptTarget, Range primary) {\n-        this.fileEntry = fileEntry;\n+    private Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n+                    boolean isDeoptTarget, Range primary) {\n+        this.fileEntry = fileEntry; // TODO remove and use fileEntry from MethodEntry\n         if (fileEntry != null) {\n             stringTable.uniqueDebugString(fileEntry.getFileName());\n             stringTable.uniqueDebugString(fileEntry.getPathName());\n         }\n-        this.className = stringTable.uniqueString(className);\n-        this.methodName = stringTable.uniqueString(methodName);\n+        assert methodEntry != null;\n+        this.methodEntry = methodEntry;\n         this.symbolName = stringTable.uniqueString(symbolName);\n-        this.paramSignature = stringTable.uniqueString(paramSignature);\n-        this.returnTypeName = stringTable.uniqueString(returnTypeName);\n-        this.fullMethodName = stringTable.uniqueString(constructClassAndMethodName());\n         this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n-        this.fullMethodNameWithParamsAndReturnType = stringTable.uniqueString(constructClassAndMethodNameWithParamsAndReturnType());\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n         this.isDeoptTarget = isDeoptTarget;\n-        this.modifiers = modifiers;\n         this.primary = primary;\n     }\n \n", "next_change": {"commit": "f485a3c15f5e29daf480657c0bfa22662f8005ae", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 9bea361bef6..a3d6e1c0db2 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -79,7 +77,6 @@ public class Range {\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n-        this.isDeoptTarget = isDeoptTarget;\n         this.primary = primary;\n     }\n \n", "next_change": {"commit": "dbb2c7607429817e58a1a9af8012e25e861368dc", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex a3d6e1c0db2..af465363bbf 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -49,30 +48,29 @@ public class Range {\n     /*\n      * Create a primary range.\n      */\n-    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n-        this(symbolName, stringTable, methodEntry, fileEntry, lo, hi, line, null);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n+        this(stringTable, methodEntry, fileEntry, lo, hi, line, null);\n     }\n \n     /*\n      * Create a secondary range.\n      */\n-    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n-        this(symbolName, stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n+        this(stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n+    private Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n                     Range primary) {\n-        this.fileEntry = fileEntry; // TODO remove and use fileEntry from MethodEntry\n+        this.fileEntry = fileEntry;\n         if (fileEntry != null) {\n             stringTable.uniqueDebugString(fileEntry.getFileName());\n             stringTable.uniqueDebugString(fileEntry.getPathName());\n         }\n         assert methodEntry != null;\n         this.methodEntry = methodEntry;\n-        this.symbolName = stringTable.uniqueString(symbolName);\n         this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n         this.lo = lo;\n         this.hi = hi;\n", "next_change": {"commit": "a658b95d63a93b1980e4ac81fd4c034c70b9d9cb", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex af465363bbf..5f7f3fe3bda 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -48,28 +47,19 @@ public class Range {\n     /*\n      * Create a primary range.\n      */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n-        this(stringTable, methodEntry, fileEntry, lo, hi, line, null);\n-    }\n-\n-    /*\n-     * Create a secondary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n-        this(stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line) {\n+        this(stringTable, methodEntry, lo, hi, line, null);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n-                    Range primary) {\n-        this.fileEntry = fileEntry;\n-        if (fileEntry != null) {\n-            stringTable.uniqueDebugString(fileEntry.getFileName());\n-            stringTable.uniqueDebugString(fileEntry.getPathName());\n-        }\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n         assert methodEntry != null;\n+        if (methodEntry.fileEntry != null) {\n+            stringTable.uniqueDebugString(methodEntry.fileEntry.getFileName());\n+            stringTable.uniqueDebugString(methodEntry.fileEntry.getPathName());\n+        }\n         this.methodEntry = methodEntry;\n         this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n         this.lo = lo;\n", "next_change": {"commit": "6fcf98378231f0e754061b683c3dba387ce8b0e9", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 5f7f3fe3bda..cc407a53acd 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -65,7 +68,10 @@ public class Range {\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n+        this.isInlined = isInline;\n         this.primary = primary;\n+        this.withChildren = withChildren;\n+        this.caller = caller;\n     }\n \n     public boolean contains(Range other) {\n", "next_change": {"commit": "abe98eaaa6dd772b7419b819fa342e810a0939e0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex cc407a53acd..037024f1755 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -71,6 +74,7 @@ public class Range {\n         this.isInlined = isInline;\n         this.primary = primary;\n         this.withChildren = withChildren;\n+        this.withInlinedChildren = false;\n         this.caller = caller;\n     }\n \n", "next_change": {"commit": "268c33256b26217c50339f452adea942fb48818f", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 037024f1755..1951241dda1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -73,9 +93,32 @@ public class Range {\n         this.line = line;\n         this.isInlined = isInline;\n         this.primary = primary;\n-        this.withChildren = withChildren;\n-        this.withInlinedChildren = false;\n+        this.firstCallee = null;\n+        this.lastCallee = null;\n+        this.nextCallee = null;\n         this.caller = caller;\n+        if (caller != null) {\n+            caller.addCallee(this);\n+        }\n+        if (this.isPrimary()) {\n+            this.depth = -1;\n+        } else {\n+            this.depth = caller.depth + 1;\n+        }\n+    }\n+\n+    private void addCallee(Range callee) {\n+        assert this.lo <= callee.lo;\n+        assert this.hi >= callee.hi;\n+        assert callee.caller == this;\n+        assert callee.nextCallee == null;\n+        if (this.firstCallee == null) {\n+            assert this.lastCallee == null;\n+            this.firstCallee = this.lastCallee = callee;\n+        } else {\n+            this.lastCallee.nextCallee = callee;\n+            this.lastCallee = callee;\n+        }\n     }\n \n     public boolean contains(Range other) {\n", "next_change": {"commit": "6ae5665ec0f5f89ff4a7804dbeec25c85d0982ea", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 1951241dda1..43c64a540e9 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -111,12 +111,12 @@ public class Range {\n         assert this.lo <= callee.lo;\n         assert this.hi >= callee.hi;\n         assert callee.caller == this;\n-        assert callee.nextCallee == null;\n+        assert callee.siblingCallee == null;\n         if (this.firstCallee == null) {\n             assert this.lastCallee == null;\n             this.firstCallee = this.lastCallee = callee;\n         } else {\n-            this.lastCallee.nextCallee = callee;\n+            this.lastCallee.siblingCallee = callee;\n             this.lastCallee = callee;\n         }\n     }\n", "next_change": {"commit": "9acf1c5d597e38f3e832360ce3f372ad94b16e9e", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\ndeleted file mode 100644\nindex 43c64a540e9..00000000000\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ /dev/null\n", "chunk": "@@ -1,339 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.objectfile.debugentry;\n-\n-import org.graalvm.compiler.debug.DebugContext;\n-\n-/**\n- * Details of a specific address range in a compiled method either a primary range identifying a\n- * whole method or a sub-range identifying a sequence of instructions that belong to an inlined\n- * method. Each sub-range is linked with its caller and its callees, forming a call tree.\n- */\n-public class Range {\n-    private static final String CLASS_DELIMITER = \".\";\n-    private Range caller;\n-    private final MethodEntry methodEntry;\n-    private final String fullMethodName;\n-    private final String fullMethodNameWithParams;\n-    private final int lo;\n-    private int hi;\n-    private final int line;\n-    private final boolean isInlined;\n-    private final int depth;\n-    /**\n-     * This is null for a primary range. For sub ranges it holds the root of the call tree they\n-     * belong to.\n-     */\n-    private final Range primary;\n-\n-    /*\n-     * Support for tree of nested inline callee ranges\n-     */\n-\n-    /**\n-     * The first direct callee whose range is wholly contained in this range.\n-     */\n-    private Range firstCallee;\n-\n-    /**\n-     * The last direct callee whose range is wholly contained in this range.\n-     */\n-    private Range lastCallee;\n-\n-    /**\n-     * A link to a sibling callee, i.e., a range sharing the same caller with this range.\n-     */\n-    private Range siblingCallee;\n-\n-    /*\n-     * Create a primary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line) {\n-        this(stringTable, methodEntry, lo, hi, line, null, false, null);\n-    }\n-\n-    /*\n-     * Create a primary or secondary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary, boolean isInline, Range caller) {\n-        assert methodEntry != null;\n-        if (methodEntry.fileEntry != null) {\n-            stringTable.uniqueDebugString(methodEntry.fileEntry.getFileName());\n-            stringTable.uniqueDebugString(methodEntry.fileEntry.getPathName());\n-        }\n-        this.methodEntry = methodEntry;\n-        this.fullMethodName = isInline ? stringTable.uniqueDebugString(constructClassAndMethodName()) : stringTable.uniqueString(constructClassAndMethodName());\n-        this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n-        this.lo = lo;\n-        this.hi = hi;\n-        this.line = line;\n-        this.isInlined = isInline;\n-        this.primary = primary;\n-        this.firstCallee = null;\n-        this.lastCallee = null;\n-        this.siblingCallee = null;\n-        this.caller = caller;\n-        if (caller != null) {\n-            caller.addCallee(this);\n-        }\n-        if (this.isPrimary()) {\n-            this.depth = -1;\n-        } else {\n-            this.depth = caller.depth + 1;\n-        }\n-    }\n-\n-    private void addCallee(Range callee) {\n-        assert this.lo <= callee.lo;\n-        assert this.hi >= callee.hi;\n-        assert callee.caller == this;\n-        assert callee.siblingCallee == null;\n-        if (this.firstCallee == null) {\n-            assert this.lastCallee == null;\n-            this.firstCallee = this.lastCallee = callee;\n-        } else {\n-            this.lastCallee.siblingCallee = callee;\n-            this.lastCallee = callee;\n-        }\n-    }\n-\n-    public boolean contains(Range other) {\n-        return (lo <= other.lo && hi >= other.hi);\n-    }\n-\n-    public boolean isPrimary() {\n-        return getPrimary() == null;\n-    }\n-\n-    public Range getPrimary() {\n-        return primary;\n-    }\n-\n-    public String getClassName() {\n-        return methodEntry.ownerType.typeName;\n-    }\n-\n-    public String getMethodName() {\n-        return methodEntry.memberName;\n-    }\n-\n-    public String getSymbolName() {\n-        return methodEntry.getSymbolName();\n-    }\n-\n-    public int getHi() {\n-        return hi;\n-    }\n-\n-    public int getLo() {\n-        return lo;\n-    }\n-\n-    public int getLine() {\n-        return line;\n-    }\n-\n-    public String getFullMethodName() {\n-        return fullMethodName;\n-    }\n-\n-    public String getFullMethodNameWithParams() {\n-        return fullMethodNameWithParams;\n-    }\n-\n-    public boolean isDeoptTarget() {\n-        return methodEntry.isDeopt();\n-    }\n-\n-    private String getExtendedMethodName(boolean includeClass, boolean includeParams, boolean includeReturnType) {\n-        StringBuilder builder = new StringBuilder();\n-        if (includeReturnType && methodEntry.valueType.typeName.length() > 0) {\n-            builder.append(methodEntry.valueType.typeName);\n-            builder.append(' ');\n-        }\n-        if (includeClass && getClassName() != null) {\n-            builder.append(getClassName());\n-            builder.append(CLASS_DELIMITER);\n-        }\n-        builder.append(getMethodName());\n-        if (includeParams) {\n-            builder.append('(');\n-            builder.append(String.join(\", \", methodEntry.paramNames));\n-            builder.append(')');\n-        }\n-        if (includeReturnType) {\n-            builder.append(\" \");\n-            builder.append(methodEntry.valueType.typeName);\n-        }\n-        return builder.toString();\n-    }\n-\n-    private String constructClassAndMethodName() {\n-        return getExtendedMethodName(true, false, false);\n-    }\n-\n-    private String constructClassAndMethodNameWithParams() {\n-        return getExtendedMethodName(true, true, false);\n-    }\n-\n-    public FileEntry getFileEntry() {\n-        return methodEntry.fileEntry;\n-    }\n-\n-    public int getModifiers() {\n-        return methodEntry.modifiers;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"Range(lo=0x%05x hi=0x%05x %s %s:%d)\", lo, hi, constructClassAndMethodNameWithParams(), methodEntry.getFullFileName(), line);\n-    }\n-\n-    public String getFileName() {\n-        return methodEntry.getFileName();\n-    }\n-\n-    public MethodEntry getMethodEntry() {\n-        return methodEntry;\n-    }\n-\n-    public boolean isInlined() {\n-        return isInlined;\n-    }\n-\n-    public Range getCaller() {\n-        return caller;\n-    }\n-\n-    public Range getFirstCallee() {\n-        return firstCallee;\n-    }\n-\n-    public Range getSiblingCallee() {\n-        return siblingCallee;\n-    }\n-\n-    public Range getLastCallee() {\n-        return lastCallee;\n-    }\n-\n-    public boolean isLeaf() {\n-        return firstCallee == null;\n-    }\n-\n-    public int getDepth() {\n-        return depth;\n-    }\n-\n-    /**\n-     * Minimizes the nodes in the tree that track the inline call hierarchy and associated code\n-     * ranges. The initial range tree models the call hierarchy as presented in the original debug\n-     * line info. It consists of a root node each of whose children is a sequence of linear call\n-     * chains, either a single leaf node for some given file and line or a series of inline calls to\n-     * such a leaf node. In this initial tree all node ranges in a given chain have the same lo and\n-     * hi address and chains are properly ordered by range The merge algorithm works across siblings\n-     * at successive depths starting at depth 1. Once all possible nodes at a given depth have been\n-     * merged their children can then be merged. A successor node may only be merged into its\n-     * predecessor if the nodes have contiguous ranges and idenitfy the same method, line and file.\n-     * The range and children of the merged node are, respectively, the union of the input ranges\n-     * and children. This preserves the invariant that child ranges lie within their parent range.\n-     *\n-     * @param debugContext\n-     */\n-    public void mergeSubranges(DebugContext debugContext) {\n-        Range next = getFirstCallee();\n-        if (next == null) {\n-            return;\n-        }\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Merge subranges [0x%x, 0x%x] %s\", lo, hi, getFullMethodNameWithParams());\n-        /* merge siblings together if possible, reparenting children to the merged node */\n-        while (next != null) {\n-            next = next.maybeMergeSibling(debugContext);\n-        }\n-        /* now recurse down to merge children of whatever nodes remain */\n-        next = getFirstCallee();\n-        /* now this level is merged recursively merge children of each child node. */\n-        while (next != null) {\n-            next.mergeSubranges(debugContext);\n-            next = next.getSiblingCallee();\n-        }\n-    }\n-\n-    /**\n-     * Removes and merges the next sibling returning the current node or it skips past the current\n-     * node as is and returns the next sibling or null if no sibling exists.\n-     */\n-    private Range maybeMergeSibling(DebugContext debugContext) {\n-        Range sibling = getSiblingCallee();\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Merge subrange (maybe) [0x%x, 0x%x] %s\", lo, hi, getFullMethodNameWithParams());\n-        if (sibling == null) {\n-            /* all child nodes at this level have been merged */\n-            return null;\n-        }\n-        if (hi < sibling.lo) {\n-            /* cannot merge non-contiguous ranges, move on. */\n-            return sibling;\n-        }\n-        if (getMethodEntry() != sibling.getMethodEntry()) {\n-            /* cannot merge distinct callers, move on. */\n-            return sibling;\n-        }\n-        if (getLine() != sibling.getLine()) {\n-            /* cannot merge callers with different line numbers, move on. */\n-            return sibling;\n-        }\n-        /* splice out the sibling from the chain and update this one to include it. */\n-        unlink(debugContext, sibling);\n-        /* relocate the siblings children to this node. */\n-        reparentChildren(debugContext, sibling);\n-        /* return the merged node so we can maybe merge it again. */\n-        return this;\n-    }\n-\n-    private void unlink(DebugContext debugContext, Range sibling) {\n-        assert hi == sibling.lo : String.format(\"gap in range [0x%x,0x%x] %s [0x%x,0x%x] %s\",\n-                        lo, hi, getFullMethodNameWithParams(), sibling.getLo(), sibling.getHi(), sibling.getFullMethodNameWithParams());\n-        assert this.isInlined == sibling.isInlined : String.format(\"change in inlined [0x%x,0x%x] %s %s [0x%x,0x%x] %s %s\",\n-                        lo, hi, getFullMethodNameWithParams(), Boolean.valueOf(this.isInlined), sibling.lo, sibling.hi, sibling.getFullMethodNameWithParams(), Boolean.valueOf(sibling.isInlined));\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Combining [0x%x, 0x%x] %s into [0x%x, 0x%x] %s\", sibling.lo, sibling.hi, sibling.getFullMethodName(), lo, hi, getFullMethodNameWithParams());\n-        this.hi = sibling.hi;\n-        this.siblingCallee = sibling.siblingCallee;\n-    }\n-\n-    private void reparentChildren(DebugContext debugContext, Range sibling) {\n-        Range siblingNext = sibling.getFirstCallee();\n-        while (siblingNext != null) {\n-            debugContext.log(DebugContext.INFO_LEVEL, \"Reparenting [0x%x, 0x%x] %s to [0x%x, 0x%x] %s\", siblingNext.lo, siblingNext.hi, siblingNext.getFullMethodName(), lo, hi,\n-                            getFullMethodNameWithParams());\n-            siblingNext.caller = this;\n-            Range newSiblingNext = siblingNext.siblingCallee;\n-            siblingNext.siblingCallee = null;\n-            addCallee(siblingNext);\n-            siblingNext = newSiblingNext;\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgzOTE3OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r484839178", "body": "```suggestion\r\n                    int hi, int line, boolean isDeoptTarget, Range primary) {\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                int hi, int line,\n          \n          \n            \n                                boolean isDeoptTarget, Range primary) {\n          \n          \n            \n                                int hi, int line, boolean isDeoptTarget, Range primary) {", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                    <span class=\"pl-k\">int</span> hi, <span class=\"pl-k\">int</span> line,</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                    <span class=\"pl-k\">boolean</span> isDeoptTarget, <span class=\"pl-smi\">Range</span> primary) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                    <span class=\"pl-k\">int</span> hi, <span class=\"pl-k\">int</span> line, <span class=\"pl-k\">boolean</span> isDeoptTarget, <span class=\"pl-smi\">Range</span> primary) {</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pejovica", "createdAt": "2020-09-08T11:16:09Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java", "diffHunk": "@@ -56,23 +60,26 @@\n     /*\n      * Create a primary range.\n      */\n-    public Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String paramNames, String returnTypeName, StringTable stringTable, int lo, int hi, int line,\n+    public Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String symbolName, String paramNames, String returnTypeName, StringTable stringTable, int lo,\n+                    int hi, int line,\n                     boolean isDeoptTarget) {\n-        this(fileName, filePath, cachePath, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, line, isDeoptTarget, null);\n+        this(fileName, filePath, cachePath, className, methodName, symbolName, paramNames, returnTypeName, stringTable, lo, hi, line, isDeoptTarget, null);\n     }\n \n     /*\n      * Create a secondary range.\n      */\n-    public Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String paramNames, String returnTypeName, StringTable stringTable, int lo, int hi, int line,\n+    public Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String symbolName, String paramNames, String returnTypeName, StringTable stringTable, int lo,\n+                    int hi, int line,\n                     Range primary) {\n-        this(fileName, filePath, cachePath, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, line, false, primary);\n+        this(fileName, filePath, cachePath, className, methodName, symbolName, paramNames, returnTypeName, stringTable, lo, hi, line, false, primary);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String paramNames, String returnTypeName, StringTable stringTable, int lo, int hi, int line,\n+    private Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String symbolName, String paramNames, String returnTypeName, StringTable stringTable, int lo,\n+                    int hi, int line,\n                     boolean isDeoptTarget, Range primary) {", "originalCommit": "f853143b8b1b99dc5ecb13bc9d3f90133041e58f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyNDk3OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r485124978", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-09-08T18:45:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgzOTE3OA=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 1078a5ac8c3..d8166f2ddfa 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -79,8 +77,7 @@ public class Range {\n      * Create a primary or secondary range.\n      */\n     private Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String symbolName, String paramNames, String returnTypeName, StringTable stringTable, int lo,\n-                    int hi, int line,\n-                    boolean isDeoptTarget, Range primary) {\n+                    int hi, int line, boolean isDeoptTarget, Range primary) {\n         /*\n          * Currently file name and full method name need to go into the debug_str section other\n          * strings just need to be deduplicated to save space.\n", "next_change": {"commit": "b307ee84155fb340719a658a7be2cc9159c49c02", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex d8166f2ddfa..6cdd3ed052a 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -60,41 +57,42 @@ public class Range {\n     /*\n      * Create a primary range.\n      */\n-    public Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String symbolName, String paramNames, String returnTypeName, StringTable stringTable, int lo,\n-                    int hi, int line, boolean isDeoptTarget) {\n-        this(fileName, filePath, cachePath, className, methodName, symbolName, paramNames, returnTypeName, stringTable, lo, hi, line, isDeoptTarget, null);\n+    public Range(String className, String methodName, String symbolName, String paramSignature, String returnTypeName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n+                    int modifiers, boolean isDeoptTarget) {\n+        this(className, methodName, symbolName, paramSignature, returnTypeName, stringTable, fileEntry, lo, hi, line, modifiers, isDeoptTarget, null);\n     }\n \n     /*\n      * Create a secondary range.\n      */\n-    public Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String symbolName, String paramNames, String returnTypeName, StringTable stringTable, int lo,\n-                    int hi, int line, Range primary) {\n-        this(fileName, filePath, cachePath, className, methodName, symbolName, paramNames, returnTypeName, stringTable, lo, hi, line, false, primary);\n+    public Range(String className, String methodName, String symbolName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n+                    Range primary) {\n+        this(className, methodName, symbolName, \"\", \"\", stringTable, fileEntry, lo, hi, line, 0, false, primary);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String symbolName, String paramNames, String returnTypeName, StringTable stringTable, int lo,\n-                    int hi, int line, boolean isDeoptTarget, Range primary) {\n-        /*\n-         * Currently file name and full method name need to go into the debug_str section other\n-         * strings just need to be deduplicated to save space.\n-         */\n-        this.fileName = (fileName == null ? null : stringTable.uniqueDebugString(fileName));\n-        this.filePath = filePath;\n-        this.cachePath = (cachePath == null ? \"\" : stringTable.uniqueDebugString(cachePath.toString()));\n+    private Range(String className, String methodName, String symbolName, String paramSignature, String returnTypeName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n+                    int modifiers, boolean isDeoptTarget, Range primary) {\n+        this.fileEntry = fileEntry;\n+        if (fileEntry != null) {\n+            stringTable.uniqueDebugString(fileEntry.getFileName());\n+            stringTable.uniqueDebugString(fileEntry.getPathName());\n+        }\n         this.className = stringTable.uniqueString(className);\n         this.methodName = stringTable.uniqueString(methodName);\n         this.symbolName = stringTable.uniqueString(symbolName);\n-        this.paramNames = stringTable.uniqueString(paramNames);\n+        this.paramSignature = stringTable.uniqueString(paramSignature);\n         this.returnTypeName = stringTable.uniqueString(returnTypeName);\n-        this.fullMethodName = stringTable.uniqueDebugString(constructClassAndMethodNameWithParams());\n+        this.fullMethodName = stringTable.uniqueString(constructClassAndMethodName());\n+        this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n+        this.fullMethodNameWithParamsAndReturnType = stringTable.uniqueString(constructClassAndMethodNameWithParamsAndReturnType());\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n         this.isDeoptTarget = isDeoptTarget;\n+        this.modifiers = modifiers;\n         this.primary = primary;\n     }\n \n", "next_change": {"commit": "b384283b5ac0e455e66648c0d661ce5410bdd863", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 6cdd3ed052a..9bea361bef6 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -34,65 +34,52 @@ package com.oracle.objectfile.debugentry;\n \n public class Range {\n     private static final String CLASS_DELIMITER = \".\";\n-    private FileEntry fileEntry;\n-    private String className;\n-    private String methodName;\n-    private String symbolName;\n-    private String paramSignature;\n-    private String returnTypeName;\n-    private String methodNameWithParams;\n-    private String fullMethodName;\n-    private String fullMethodNameWithParams;\n-    private String fullMethodNameWithParamsAndReturnType;\n-    private int lo;\n-    private int hi;\n-    private int line;\n-    private boolean isDeoptTarget;\n-    private int modifiers;\n+    private final FileEntry fileEntry;\n+    private MethodEntry methodEntry;\n+    private final String symbolName;\n+    private final String fullMethodNameWithParams;\n+    private final int lo;\n+    private final int hi;\n+    private final int line;\n+    private final boolean isDeoptTarget;\n     /*\n      * This is null for a primary range.\n      */\n-    private Range primary;\n+    private final Range primary;\n \n     /*\n      * Create a primary range.\n      */\n-    public Range(String className, String methodName, String symbolName, String paramSignature, String returnTypeName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n-                    int modifiers, boolean isDeoptTarget) {\n-        this(className, methodName, symbolName, paramSignature, returnTypeName, stringTable, fileEntry, lo, hi, line, modifiers, isDeoptTarget, null);\n+    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n+                 boolean isDeoptTarget) {\n+        this(symbolName, stringTable, methodEntry, fileEntry, lo, hi, line, isDeoptTarget, null);\n     }\n \n     /*\n      * Create a secondary range.\n      */\n-    public Range(String className, String methodName, String symbolName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n-                    Range primary) {\n-        this(className, methodName, symbolName, \"\", \"\", stringTable, fileEntry, lo, hi, line, 0, false, primary);\n+    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n+        this(symbolName, stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, false, primary);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(String className, String methodName, String symbolName, String paramSignature, String returnTypeName, StringTable stringTable, FileEntry fileEntry, int lo, int hi, int line,\n-                    int modifiers, boolean isDeoptTarget, Range primary) {\n-        this.fileEntry = fileEntry;\n+    private Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n+                    boolean isDeoptTarget, Range primary) {\n+        this.fileEntry = fileEntry; // TODO remove and use fileEntry from MethodEntry\n         if (fileEntry != null) {\n             stringTable.uniqueDebugString(fileEntry.getFileName());\n             stringTable.uniqueDebugString(fileEntry.getPathName());\n         }\n-        this.className = stringTable.uniqueString(className);\n-        this.methodName = stringTable.uniqueString(methodName);\n+        assert methodEntry != null;\n+        this.methodEntry = methodEntry;\n         this.symbolName = stringTable.uniqueString(symbolName);\n-        this.paramSignature = stringTable.uniqueString(paramSignature);\n-        this.returnTypeName = stringTable.uniqueString(returnTypeName);\n-        this.fullMethodName = stringTable.uniqueString(constructClassAndMethodName());\n         this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n-        this.fullMethodNameWithParamsAndReturnType = stringTable.uniqueString(constructClassAndMethodNameWithParamsAndReturnType());\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n         this.isDeoptTarget = isDeoptTarget;\n-        this.modifiers = modifiers;\n         this.primary = primary;\n     }\n \n", "next_change": {"commit": "f485a3c15f5e29daf480657c0bfa22662f8005ae", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 9bea361bef6..a3d6e1c0db2 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -79,7 +77,6 @@ public class Range {\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n-        this.isDeoptTarget = isDeoptTarget;\n         this.primary = primary;\n     }\n \n", "next_change": {"commit": "dbb2c7607429817e58a1a9af8012e25e861368dc", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex a3d6e1c0db2..af465363bbf 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -49,30 +48,29 @@ public class Range {\n     /*\n      * Create a primary range.\n      */\n-    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n-        this(symbolName, stringTable, methodEntry, fileEntry, lo, hi, line, null);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n+        this(stringTable, methodEntry, fileEntry, lo, hi, line, null);\n     }\n \n     /*\n      * Create a secondary range.\n      */\n-    public Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n-        this(symbolName, stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n+        this(stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(String symbolName, StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n+    private Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n                     Range primary) {\n-        this.fileEntry = fileEntry; // TODO remove and use fileEntry from MethodEntry\n+        this.fileEntry = fileEntry;\n         if (fileEntry != null) {\n             stringTable.uniqueDebugString(fileEntry.getFileName());\n             stringTable.uniqueDebugString(fileEntry.getPathName());\n         }\n         assert methodEntry != null;\n         this.methodEntry = methodEntry;\n-        this.symbolName = stringTable.uniqueString(symbolName);\n         this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n         this.lo = lo;\n         this.hi = hi;\n", "next_change": {"commit": "a658b95d63a93b1980e4ac81fd4c034c70b9d9cb", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex af465363bbf..5f7f3fe3bda 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -48,28 +47,19 @@ public class Range {\n     /*\n      * Create a primary range.\n      */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line) {\n-        this(stringTable, methodEntry, fileEntry, lo, hi, line, null);\n-    }\n-\n-    /*\n-     * Create a secondary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n-        this(stringTable, methodEntry, methodEntry.fileEntry, lo, hi, line, primary);\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line) {\n+        this(stringTable, methodEntry, lo, hi, line, null);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(StringTable stringTable, MethodEntry methodEntry, FileEntry fileEntry, int lo, int hi, int line,\n-                    Range primary) {\n-        this.fileEntry = fileEntry;\n-        if (fileEntry != null) {\n-            stringTable.uniqueDebugString(fileEntry.getFileName());\n-            stringTable.uniqueDebugString(fileEntry.getPathName());\n-        }\n+    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary) {\n         assert methodEntry != null;\n+        if (methodEntry.fileEntry != null) {\n+            stringTable.uniqueDebugString(methodEntry.fileEntry.getFileName());\n+            stringTable.uniqueDebugString(methodEntry.fileEntry.getPathName());\n+        }\n         this.methodEntry = methodEntry;\n         this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n         this.lo = lo;\n", "next_change": {"commit": "6fcf98378231f0e754061b683c3dba387ce8b0e9", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 5f7f3fe3bda..cc407a53acd 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -65,7 +68,10 @@ public class Range {\n         this.lo = lo;\n         this.hi = hi;\n         this.line = line;\n+        this.isInlined = isInline;\n         this.primary = primary;\n+        this.withChildren = withChildren;\n+        this.caller = caller;\n     }\n \n     public boolean contains(Range other) {\n", "next_change": {"commit": "abe98eaaa6dd772b7419b819fa342e810a0939e0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex cc407a53acd..037024f1755 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -71,6 +74,7 @@ public class Range {\n         this.isInlined = isInline;\n         this.primary = primary;\n         this.withChildren = withChildren;\n+        this.withInlinedChildren = false;\n         this.caller = caller;\n     }\n \n", "next_change": {"commit": "268c33256b26217c50339f452adea942fb48818f", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 037024f1755..1951241dda1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -73,9 +93,32 @@ public class Range {\n         this.line = line;\n         this.isInlined = isInline;\n         this.primary = primary;\n-        this.withChildren = withChildren;\n-        this.withInlinedChildren = false;\n+        this.firstCallee = null;\n+        this.lastCallee = null;\n+        this.nextCallee = null;\n         this.caller = caller;\n+        if (caller != null) {\n+            caller.addCallee(this);\n+        }\n+        if (this.isPrimary()) {\n+            this.depth = -1;\n+        } else {\n+            this.depth = caller.depth + 1;\n+        }\n+    }\n+\n+    private void addCallee(Range callee) {\n+        assert this.lo <= callee.lo;\n+        assert this.hi >= callee.hi;\n+        assert callee.caller == this;\n+        assert callee.nextCallee == null;\n+        if (this.firstCallee == null) {\n+            assert this.lastCallee == null;\n+            this.firstCallee = this.lastCallee = callee;\n+        } else {\n+            this.lastCallee.nextCallee = callee;\n+            this.lastCallee = callee;\n+        }\n     }\n \n     public boolean contains(Range other) {\n", "next_change": {"commit": "6ae5665ec0f5f89ff4a7804dbeec25c85d0982ea", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 1951241dda1..43c64a540e9 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -111,12 +111,12 @@ public class Range {\n         assert this.lo <= callee.lo;\n         assert this.hi >= callee.hi;\n         assert callee.caller == this;\n-        assert callee.nextCallee == null;\n+        assert callee.siblingCallee == null;\n         if (this.firstCallee == null) {\n             assert this.lastCallee == null;\n             this.firstCallee = this.lastCallee = callee;\n         } else {\n-            this.lastCallee.nextCallee = callee;\n+            this.lastCallee.siblingCallee = callee;\n             this.lastCallee = callee;\n         }\n     }\n", "next_change": {"commit": "9acf1c5d597e38f3e832360ce3f372ad94b16e9e", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\ndeleted file mode 100644\nindex 43c64a540e9..00000000000\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ /dev/null\n", "chunk": "@@ -1,339 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.objectfile.debugentry;\n-\n-import org.graalvm.compiler.debug.DebugContext;\n-\n-/**\n- * Details of a specific address range in a compiled method either a primary range identifying a\n- * whole method or a sub-range identifying a sequence of instructions that belong to an inlined\n- * method. Each sub-range is linked with its caller and its callees, forming a call tree.\n- */\n-public class Range {\n-    private static final String CLASS_DELIMITER = \".\";\n-    private Range caller;\n-    private final MethodEntry methodEntry;\n-    private final String fullMethodName;\n-    private final String fullMethodNameWithParams;\n-    private final int lo;\n-    private int hi;\n-    private final int line;\n-    private final boolean isInlined;\n-    private final int depth;\n-    /**\n-     * This is null for a primary range. For sub ranges it holds the root of the call tree they\n-     * belong to.\n-     */\n-    private final Range primary;\n-\n-    /*\n-     * Support for tree of nested inline callee ranges\n-     */\n-\n-    /**\n-     * The first direct callee whose range is wholly contained in this range.\n-     */\n-    private Range firstCallee;\n-\n-    /**\n-     * The last direct callee whose range is wholly contained in this range.\n-     */\n-    private Range lastCallee;\n-\n-    /**\n-     * A link to a sibling callee, i.e., a range sharing the same caller with this range.\n-     */\n-    private Range siblingCallee;\n-\n-    /*\n-     * Create a primary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line) {\n-        this(stringTable, methodEntry, lo, hi, line, null, false, null);\n-    }\n-\n-    /*\n-     * Create a primary or secondary range.\n-     */\n-    public Range(StringTable stringTable, MethodEntry methodEntry, int lo, int hi, int line, Range primary, boolean isInline, Range caller) {\n-        assert methodEntry != null;\n-        if (methodEntry.fileEntry != null) {\n-            stringTable.uniqueDebugString(methodEntry.fileEntry.getFileName());\n-            stringTable.uniqueDebugString(methodEntry.fileEntry.getPathName());\n-        }\n-        this.methodEntry = methodEntry;\n-        this.fullMethodName = isInline ? stringTable.uniqueDebugString(constructClassAndMethodName()) : stringTable.uniqueString(constructClassAndMethodName());\n-        this.fullMethodNameWithParams = stringTable.uniqueString(constructClassAndMethodNameWithParams());\n-        this.lo = lo;\n-        this.hi = hi;\n-        this.line = line;\n-        this.isInlined = isInline;\n-        this.primary = primary;\n-        this.firstCallee = null;\n-        this.lastCallee = null;\n-        this.siblingCallee = null;\n-        this.caller = caller;\n-        if (caller != null) {\n-            caller.addCallee(this);\n-        }\n-        if (this.isPrimary()) {\n-            this.depth = -1;\n-        } else {\n-            this.depth = caller.depth + 1;\n-        }\n-    }\n-\n-    private void addCallee(Range callee) {\n-        assert this.lo <= callee.lo;\n-        assert this.hi >= callee.hi;\n-        assert callee.caller == this;\n-        assert callee.siblingCallee == null;\n-        if (this.firstCallee == null) {\n-            assert this.lastCallee == null;\n-            this.firstCallee = this.lastCallee = callee;\n-        } else {\n-            this.lastCallee.siblingCallee = callee;\n-            this.lastCallee = callee;\n-        }\n-    }\n-\n-    public boolean contains(Range other) {\n-        return (lo <= other.lo && hi >= other.hi);\n-    }\n-\n-    public boolean isPrimary() {\n-        return getPrimary() == null;\n-    }\n-\n-    public Range getPrimary() {\n-        return primary;\n-    }\n-\n-    public String getClassName() {\n-        return methodEntry.ownerType.typeName;\n-    }\n-\n-    public String getMethodName() {\n-        return methodEntry.memberName;\n-    }\n-\n-    public String getSymbolName() {\n-        return methodEntry.getSymbolName();\n-    }\n-\n-    public int getHi() {\n-        return hi;\n-    }\n-\n-    public int getLo() {\n-        return lo;\n-    }\n-\n-    public int getLine() {\n-        return line;\n-    }\n-\n-    public String getFullMethodName() {\n-        return fullMethodName;\n-    }\n-\n-    public String getFullMethodNameWithParams() {\n-        return fullMethodNameWithParams;\n-    }\n-\n-    public boolean isDeoptTarget() {\n-        return methodEntry.isDeopt();\n-    }\n-\n-    private String getExtendedMethodName(boolean includeClass, boolean includeParams, boolean includeReturnType) {\n-        StringBuilder builder = new StringBuilder();\n-        if (includeReturnType && methodEntry.valueType.typeName.length() > 0) {\n-            builder.append(methodEntry.valueType.typeName);\n-            builder.append(' ');\n-        }\n-        if (includeClass && getClassName() != null) {\n-            builder.append(getClassName());\n-            builder.append(CLASS_DELIMITER);\n-        }\n-        builder.append(getMethodName());\n-        if (includeParams) {\n-            builder.append('(');\n-            builder.append(String.join(\", \", methodEntry.paramNames));\n-            builder.append(')');\n-        }\n-        if (includeReturnType) {\n-            builder.append(\" \");\n-            builder.append(methodEntry.valueType.typeName);\n-        }\n-        return builder.toString();\n-    }\n-\n-    private String constructClassAndMethodName() {\n-        return getExtendedMethodName(true, false, false);\n-    }\n-\n-    private String constructClassAndMethodNameWithParams() {\n-        return getExtendedMethodName(true, true, false);\n-    }\n-\n-    public FileEntry getFileEntry() {\n-        return methodEntry.fileEntry;\n-    }\n-\n-    public int getModifiers() {\n-        return methodEntry.modifiers;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"Range(lo=0x%05x hi=0x%05x %s %s:%d)\", lo, hi, constructClassAndMethodNameWithParams(), methodEntry.getFullFileName(), line);\n-    }\n-\n-    public String getFileName() {\n-        return methodEntry.getFileName();\n-    }\n-\n-    public MethodEntry getMethodEntry() {\n-        return methodEntry;\n-    }\n-\n-    public boolean isInlined() {\n-        return isInlined;\n-    }\n-\n-    public Range getCaller() {\n-        return caller;\n-    }\n-\n-    public Range getFirstCallee() {\n-        return firstCallee;\n-    }\n-\n-    public Range getSiblingCallee() {\n-        return siblingCallee;\n-    }\n-\n-    public Range getLastCallee() {\n-        return lastCallee;\n-    }\n-\n-    public boolean isLeaf() {\n-        return firstCallee == null;\n-    }\n-\n-    public int getDepth() {\n-        return depth;\n-    }\n-\n-    /**\n-     * Minimizes the nodes in the tree that track the inline call hierarchy and associated code\n-     * ranges. The initial range tree models the call hierarchy as presented in the original debug\n-     * line info. It consists of a root node each of whose children is a sequence of linear call\n-     * chains, either a single leaf node for some given file and line or a series of inline calls to\n-     * such a leaf node. In this initial tree all node ranges in a given chain have the same lo and\n-     * hi address and chains are properly ordered by range The merge algorithm works across siblings\n-     * at successive depths starting at depth 1. Once all possible nodes at a given depth have been\n-     * merged their children can then be merged. A successor node may only be merged into its\n-     * predecessor if the nodes have contiguous ranges and idenitfy the same method, line and file.\n-     * The range and children of the merged node are, respectively, the union of the input ranges\n-     * and children. This preserves the invariant that child ranges lie within their parent range.\n-     *\n-     * @param debugContext\n-     */\n-    public void mergeSubranges(DebugContext debugContext) {\n-        Range next = getFirstCallee();\n-        if (next == null) {\n-            return;\n-        }\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Merge subranges [0x%x, 0x%x] %s\", lo, hi, getFullMethodNameWithParams());\n-        /* merge siblings together if possible, reparenting children to the merged node */\n-        while (next != null) {\n-            next = next.maybeMergeSibling(debugContext);\n-        }\n-        /* now recurse down to merge children of whatever nodes remain */\n-        next = getFirstCallee();\n-        /* now this level is merged recursively merge children of each child node. */\n-        while (next != null) {\n-            next.mergeSubranges(debugContext);\n-            next = next.getSiblingCallee();\n-        }\n-    }\n-\n-    /**\n-     * Removes and merges the next sibling returning the current node or it skips past the current\n-     * node as is and returns the next sibling or null if no sibling exists.\n-     */\n-    private Range maybeMergeSibling(DebugContext debugContext) {\n-        Range sibling = getSiblingCallee();\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Merge subrange (maybe) [0x%x, 0x%x] %s\", lo, hi, getFullMethodNameWithParams());\n-        if (sibling == null) {\n-            /* all child nodes at this level have been merged */\n-            return null;\n-        }\n-        if (hi < sibling.lo) {\n-            /* cannot merge non-contiguous ranges, move on. */\n-            return sibling;\n-        }\n-        if (getMethodEntry() != sibling.getMethodEntry()) {\n-            /* cannot merge distinct callers, move on. */\n-            return sibling;\n-        }\n-        if (getLine() != sibling.getLine()) {\n-            /* cannot merge callers with different line numbers, move on. */\n-            return sibling;\n-        }\n-        /* splice out the sibling from the chain and update this one to include it. */\n-        unlink(debugContext, sibling);\n-        /* relocate the siblings children to this node. */\n-        reparentChildren(debugContext, sibling);\n-        /* return the merged node so we can maybe merge it again. */\n-        return this;\n-    }\n-\n-    private void unlink(DebugContext debugContext, Range sibling) {\n-        assert hi == sibling.lo : String.format(\"gap in range [0x%x,0x%x] %s [0x%x,0x%x] %s\",\n-                        lo, hi, getFullMethodNameWithParams(), sibling.getLo(), sibling.getHi(), sibling.getFullMethodNameWithParams());\n-        assert this.isInlined == sibling.isInlined : String.format(\"change in inlined [0x%x,0x%x] %s %s [0x%x,0x%x] %s %s\",\n-                        lo, hi, getFullMethodNameWithParams(), Boolean.valueOf(this.isInlined), sibling.lo, sibling.hi, sibling.getFullMethodNameWithParams(), Boolean.valueOf(sibling.isInlined));\n-        debugContext.log(DebugContext.INFO_LEVEL, \"Combining [0x%x, 0x%x] %s into [0x%x, 0x%x] %s\", sibling.lo, sibling.hi, sibling.getFullMethodName(), lo, hi, getFullMethodNameWithParams());\n-        this.hi = sibling.hi;\n-        this.siblingCallee = sibling.siblingCallee;\n-    }\n-\n-    private void reparentChildren(DebugContext debugContext, Range sibling) {\n-        Range siblingNext = sibling.getFirstCallee();\n-        while (siblingNext != null) {\n-            debugContext.log(DebugContext.INFO_LEVEL, \"Reparenting [0x%x, 0x%x] %s to [0x%x, 0x%x] %s\", siblingNext.lo, siblingNext.hi, siblingNext.getFullMethodName(), lo, hi,\n-                            getFullMethodNameWithParams());\n-            siblingNext.caller = this;\n-            Range newSiblingNext = siblingNext.siblingCallee;\n-            siblingNext.siblingCallee = null;\n-            addCallee(siblingNext);\n-            siblingNext = newSiblingNext;\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg0NDgxMg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r484844812", "body": "I think this can be simplified to\r\n```suggestion\r\n        return getExtendedMethodName(false, false);\r\n```", "bodyText": "I think this can be simplified to\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    StringBuilder builder = new StringBuilder();\n          \n          \n            \n                    if (className != null) {\n          \n          \n            \n                        builder.append(className).append(CLASS_DELIMITER);\n          \n          \n            \n                    }\n          \n          \n            \n                    builder.append(methodName);\n          \n          \n            \n                    return builder.toString();\n          \n          \n            \n                    return getExtendedMethodName(false, false);", "bodyHTML": "<p dir=\"auto\">I think this can be simplified to</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-smi\">StringBuilder</span> builder <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">StringBuilder</span>();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">if</span> (className <span class=\"pl-k\">!=</span> <span class=\"pl-c1\">null</span>) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            builder<span class=\"pl-k\">.</span>append(className)<span class=\"pl-k\">.</span>append(<span class=\"pl-c1\">CLASS_DELIMITER</span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        builder<span class=\"pl-k\">.</span>append(methodName);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">return</span> builder<span class=\"pl-k\">.</span>toString();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">return</span> getExtendedMethodName(<span class=\"pl-c1\">false</span>, <span class=\"pl-c1\">false</span>);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pejovica", "createdAt": "2020-09-08T11:27:57Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java", "diffHunk": "@@ -151,6 +163,19 @@ public boolean isDeoptTarget() {\n         return isDeoptTarget;\n     }\n \n+    public String getParamNames() {\n+        return paramNames;\n+    }\n+\n+    public String getClassAndMethodName() {\n+        StringBuilder builder = new StringBuilder();\n+        if (className != null) {\n+            builder.append(className).append(CLASS_DELIMITER);\n+        }\n+        builder.append(methodName);\n+        return builder.toString();", "originalCommit": "f853143b8b1b99dc5ecb13bc9d3f90133041e58f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE2OTIxNA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r485169214", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-09-08T20:11:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg0NDgxMg=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 1078a5ac8c3..d8166f2ddfa 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -168,12 +165,7 @@ public class Range {\n     }\n \n     public String getClassAndMethodName() {\n-        StringBuilder builder = new StringBuilder();\n-        if (className != null) {\n-            builder.append(className).append(CLASS_DELIMITER);\n-        }\n-        builder.append(methodName);\n-        return builder.toString();\n+        return getExtendedMethodName(false, false);\n     }\n \n     private String getExtendedMethodName(boolean includeParams, boolean includeReturnType) {\n", "next_change": {"commit": "b307ee84155fb340719a658a7be2cc9159c49c02", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex d8166f2ddfa..6cdd3ed052a 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -156,50 +136,79 @@ public class Range {\n         return fullMethodName;\n     }\n \n-    public boolean isDeoptTarget() {\n-        return isDeoptTarget;\n+    public String getFullMethodNameWithParams() {\n+        return fullMethodNameWithParams;\n     }\n \n-    public String getParamNames() {\n-        return paramNames;\n+    public String getFullMethodNameWithParamsAndReturnType() {\n+        return fullMethodNameWithParamsAndReturnType;\n     }\n \n-    public String getClassAndMethodName() {\n-        return getExtendedMethodName(false, false);\n+    public boolean isDeoptTarget() {\n+        return isDeoptTarget;\n     }\n \n-    private String getExtendedMethodName(boolean includeParams, boolean includeReturnType) {\n+    private String getExtendedMethodName(boolean includeClass, boolean includeParams, boolean includeReturnType) {\n         StringBuilder builder = new StringBuilder();\n         if (includeReturnType && returnTypeName.length() > 0) {\n             builder.append(returnTypeName);\n             builder.append(' ');\n         }\n-        if (className != null) {\n+        if (includeClass && className != null) {\n             builder.append(className);\n             builder.append(CLASS_DELIMITER);\n         }\n         builder.append(methodName);\n-        if (includeParams && !paramNames.isEmpty()) {\n+        if (includeParams) {\n             builder.append('(');\n-            builder.append(paramNames);\n+            builder.append(paramSignature);\n             builder.append(')');\n         }\n+        if (includeReturnType) {\n+            builder.append(\" \");\n+            builder.append(returnTypeName);\n+        }\n         return builder.toString();\n     }\n \n+    private String constructClassAndMethodName() {\n+        return getExtendedMethodName(true, false, false);\n+    }\n+\n     private String constructClassAndMethodNameWithParams() {\n-        return getExtendedMethodName(true, false);\n+        return getExtendedMethodName(true, true, false);\n     }\n \n-    /**\n-     * Get the compilation directory in which to look for source files as a {@link String}.\n-     */\n-    public String getCachePath() {\n-        return cachePath;\n+    private String constructClassAndMethodNameWithParamsAndReturnType() {\n+        return getExtendedMethodName(true, true, true);\n+    }\n+\n+    public String getMethodReturnTypeName() {\n+        return returnTypeName;\n+    }\n+\n+    public String getParamSignature() {\n+        return paramSignature;\n+    }\n+\n+    public FileEntry getFileEntry() {\n+        return fileEntry;\n+    }\n+\n+    public void setFileEntry(FileEntry fileEntry) {\n+        this.fileEntry = fileEntry;\n+    }\n+\n+    public int getModifiers() {\n+        return modifiers;\n     }\n \n     @Override\n     public String toString() {\n-        return String.format(\"Range(lo=0x%05x hi=0x%05x %s %s:%d)\", lo, hi, constructClassAndMethodNameWithParams(), getFileAsPath(), line);\n+        return String.format(\"Range(lo=0x%05x hi=0x%05x %s %s:%d)\", lo, hi, constructClassAndMethodNameWithParams(), fileEntry.getFullName(), line);\n+    }\n+\n+    public String getFileName() {\n+        return fileEntry.getFileName();\n     }\n }\n", "next_change": {"commit": "dbb2c7607429817e58a1a9af8012e25e861368dc", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 6cdd3ed052a..af465363bbf 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -211,4 +173,8 @@ public class Range {\n     public String getFileName() {\n         return fileEntry.getFileName();\n     }\n+\n+    public MethodEntry getMethodEntry() {\n+        return methodEntry;\n+    }\n }\n", "next_change": {"commit": "a658b95d63a93b1980e4ac81fd4c034c70b9d9cb", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex af465363bbf..5f7f3fe3bda 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -167,11 +157,11 @@ public class Range {\n \n     @Override\n     public String toString() {\n-        return String.format(\"Range(lo=0x%05x hi=0x%05x %s %s:%d)\", lo, hi, constructClassAndMethodNameWithParams(), fileEntry.getFullName(), line);\n+        return String.format(\"Range(lo=0x%05x hi=0x%05x %s %s:%d)\", lo, hi, constructClassAndMethodNameWithParams(), methodEntry.getFullFileName(), line);\n     }\n \n     public String getFileName() {\n-        return fileEntry.getFileName();\n+        return methodEntry.getFileName();\n     }\n \n     public MethodEntry getMethodEntry() {\n", "next_change": {"commit": "6fcf98378231f0e754061b683c3dba387ce8b0e9", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 5f7f3fe3bda..cc407a53acd 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -167,4 +173,16 @@ public class Range {\n     public MethodEntry getMethodEntry() {\n         return methodEntry;\n     }\n+\n+    public boolean isInlined() {\n+        return isInlined;\n+    }\n+\n+    public boolean withChildren() {\n+        return withChildren;\n+    }\n+\n+    public Range getCaller() {\n+        return caller;\n+    }\n }\n", "next_change": {"commit": "abe98eaaa6dd772b7419b819fa342e810a0939e0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex cc407a53acd..037024f1755 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -182,6 +186,14 @@ public class Range {\n         return withChildren;\n     }\n \n+    public boolean withInlinedChildren() {\n+        return withInlinedChildren;\n+    }\n+\n+    public boolean setWithInlinedChildren(boolean withInlinedChildren) {\n+        return this.withInlinedChildren = withInlinedChildren;\n+    }\n+\n     public Range getCaller() {\n         return caller;\n     }\n", "next_change": {"commit": "268c33256b26217c50339f452adea942fb48818f", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 037024f1755..1951241dda1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -182,19 +225,100 @@ public class Range {\n         return isInlined;\n     }\n \n-    public boolean withChildren() {\n-        return withChildren;\n+    public Range getCaller() {\n+        return caller;\n     }\n \n-    public boolean withInlinedChildren() {\n-        return withInlinedChildren;\n+    public Range getFirstCallee() {\n+        return firstCallee;\n     }\n \n-    public boolean setWithInlinedChildren(boolean withInlinedChildren) {\n-        return this.withInlinedChildren = withInlinedChildren;\n+    public Range getNextCallee() {\n+        return nextCallee;\n     }\n \n-    public Range getCaller() {\n-        return caller;\n+    public Range getLastCallee() {\n+        return lastCallee;\n+    }\n+\n+    public boolean isLeaf() {\n+        return firstCallee == null;\n+    }\n+\n+    public int getDepth() {\n+        return depth;\n+    }\n+\n+    public void mergeSubranges(DebugContext debugContext) {\n+        Range next = getFirstCallee();\n+        if (next == null) {\n+            return;\n+        }\n+        debugContext.log(DebugContext.INFO_LEVEL, \"Merge subranges [0x%x, 0x%x] %s\", lo, hi, getFullMethodNameWithParams());\n+        /* merge siblings together if possible, reparenting children to the merged node */\n+        while (next != null) {\n+            next = next.maybeMergeSibling(debugContext);\n+        }\n+        /* now recurse down to merge children of whatever nodes remain */\n+        next = getFirstCallee();\n+        /* now this level is merged recursively merge children of each child node. */\n+        while (next != null) {\n+            next.mergeSubranges(debugContext);\n+            next = next.getNextCallee();\n+        }\n+    }\n+\n+    /**\n+     * Removes and merges the next sibling returning the current node or it skips past the current\n+     * node as is and returns the next sibling or null if no sibling exists.\n+     */\n+    private Range maybeMergeSibling(DebugContext debugContext) {\n+        Range sibling = getNextCallee();\n+        debugContext.log(DebugContext.INFO_LEVEL, \"Merge subrange (maybe) [0x%x, 0x%x] %s\", lo, hi, getFullMethodNameWithParams());\n+        if (sibling == null) {\n+            /* all child nodes at this level have been merged */\n+            return null;\n+        }\n+        if (hi < sibling.lo) {\n+            /* cannot merge non-contiguous ranges, move on. */\n+            return sibling;\n+        }\n+        if (getMethodEntry() != sibling.getMethodEntry()) {\n+            /* cannot merge distinct callers, move on. */\n+            return sibling;\n+        }\n+        if (getLine() != sibling.getLine()) {\n+            /* cannot merge callers with different line numbers, move on. */\n+            return sibling;\n+        }\n+        /* splice out the sibling from the chain and update this one to include it. */\n+        unlink(debugContext, sibling);\n+        /* relocate the siblings children to this node. */\n+        reparentChildren(debugContext, sibling);\n+        /* return the merged node so we can maybe merge it again. */\n+        return this;\n+    }\n+\n+    private void unlink(DebugContext debugContext, Range sibling) {\n+        assert hi == sibling.lo : String.format(\"gap in range [0x%x,0x%x] %s [0x%x,0x%x] %s\",\n+                        lo, hi, getFullMethodNameWithParams(), sibling.getLo(), sibling.getHi(), sibling.getFullMethodNameWithParams());\n+        assert this.isInlined == sibling.isInlined : String.format(\"change in inlined [0x%x,0x%x] %s %s [0x%x,0x%x] %s %s\",\n+                        lo, hi, getFullMethodNameWithParams(), Boolean.valueOf(this.isInlined), sibling.lo, sibling.hi, sibling.getFullMethodNameWithParams(), Boolean.valueOf(sibling.isInlined));\n+        debugContext.log(DebugContext.INFO_LEVEL, \"Combining [0x%x, 0x%x] %s into [0x%x, 0x%x] %s\", sibling.lo, sibling.hi, sibling.getFullMethodName(), lo, hi, getFullMethodNameWithParams());\n+        this.hi = sibling.hi;\n+        this.nextCallee = sibling.nextCallee;\n+    }\n+\n+    private void reparentChildren(DebugContext debugContext, Range sibling) {\n+        Range siblingNext = sibling.getFirstCallee();\n+        while (siblingNext != null) {\n+            debugContext.log(DebugContext.INFO_LEVEL, \"Reparenting [0x%x, 0x%x] %s to [0x%x, 0x%x] %s\", siblingNext.lo, siblingNext.hi, siblingNext.getFullMethodName(), lo, hi,\n+                            getFullMethodNameWithParams());\n+            siblingNext.caller = this;\n+            Range newSiblingNext = siblingNext.nextCallee;\n+            siblingNext.nextCallee = null;\n+            addCallee(siblingNext);\n+            siblingNext = newSiblingNext;\n+        }\n     }\n }\n", "next_change": {"commit": "6ae5665ec0f5f89ff4a7804dbeec25c85d0982ea", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 1951241dda1..43c64a540e9 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -315,8 +330,8 @@ public class Range {\n             debugContext.log(DebugContext.INFO_LEVEL, \"Reparenting [0x%x, 0x%x] %s to [0x%x, 0x%x] %s\", siblingNext.lo, siblingNext.hi, siblingNext.getFullMethodName(), lo, hi,\n                             getFullMethodNameWithParams());\n             siblingNext.caller = this;\n-            Range newSiblingNext = siblingNext.nextCallee;\n-            siblingNext.nextCallee = null;\n+            Range newSiblingNext = siblingNext.siblingCallee;\n+            siblingNext.siblingCallee = null;\n             addCallee(siblingNext);\n             siblingNext = newSiblingNext;\n         }\n", "next_change": {"commit": "5654e72b90de37daeafc10bbac259754b62502a2", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 43c64a540e9..3d24a6e40aa 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -327,7 +342,7 @@ public class Range {\n     private void reparentChildren(DebugContext debugContext, Range sibling) {\n         Range siblingNext = sibling.getFirstCallee();\n         while (siblingNext != null) {\n-            debugContext.log(DebugContext.INFO_LEVEL, \"Reparenting [0x%x, 0x%x] %s to [0x%x, 0x%x] %s\", siblingNext.lo, siblingNext.hi, siblingNext.getFullMethodName(), lo, hi,\n+            debugContext.log(DebugContext.DETAILED_LEVEL, \"Reparenting [0x%x, 0x%x] %s to [0x%x, 0x%x] %s\", siblingNext.lo, siblingNext.hi, siblingNext.getFullMethodName(), lo, hi,\n                             getFullMethodNameWithParams());\n             siblingNext.caller = this;\n             Range newSiblingNext = siblingNext.siblingCallee;\n", "next_change": {"commit": "d88c987fa1ec476437226e641a9210b136790fee", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 3d24a6e40aa..92a9fed3718 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -256,99 +254,4 @@ public class Range {\n     public int getDepth() {\n         return depth;\n     }\n-\n-    /**\n-     * Minimizes the nodes in the tree that track the inline call hierarchy and associated code\n-     * ranges. The initial range tree models the call hierarchy as presented in the original debug\n-     * line info. It consists of a root node each of whose children is a sequence of linear call\n-     * chains, either a single leaf node for some given file and line or a series of inline calls to\n-     * such a leaf node. In this initial tree all node ranges in a given chain have the same lo and\n-     * hi address and chains are properly ordered by range The merge algorithm works across siblings\n-     * at successive depths starting at depth 1. Once all possible nodes at a given depth have been\n-     * merged their children can then be merged. A successor node may only be merged into its\n-     * predecessor if the nodes have contiguous ranges and idenitfy the same method, line and file.\n-     * The range and children of the merged node are, respectively, the union of the input ranges\n-     * and children. This preserves the invariant that child ranges lie within their parent range.\n-     *\n-     * @param debugContext\n-     */\n-    public void mergeSubranges(DebugContext debugContext) {\n-        Range next = getFirstCallee();\n-        if (next == null) {\n-            return;\n-        }\n-        debugContext.log(DebugContext.DETAILED_LEVEL, \"Merge subranges [0x%x, 0x%x] %s\", lo, hi, getFullMethodNameWithParams());\n-        /* merge siblings together if possible, reparenting children to the merged node */\n-        while (next != null) {\n-            next = next.maybeMergeSibling(debugContext);\n-        }\n-        /* now recurse down to merge children of whatever nodes remain */\n-        next = getFirstCallee();\n-        /* now this level is merged recursively merge children of each child node. */\n-        while (next != null) {\n-            next.mergeSubranges(debugContext);\n-            next = next.getSiblingCallee();\n-        }\n-    }\n-\n-    /**\n-     * Removes and merges the next sibling returning the current node or it skips past the current\n-     * node as is and returns the next sibling or null if no sibling exists.\n-     */\n-    private Range maybeMergeSibling(DebugContext debugContext) {\n-        Range sibling = getSiblingCallee();\n-        debugContext.log(DebugContext.DETAILED_LEVEL, \"Merge subrange (maybe) [0x%x, 0x%x] %s\", lo, hi, getFullMethodNameWithParams());\n-        if (sibling == null) {\n-            /* all child nodes at this level have been merged */\n-            return null;\n-        }\n-        if (hi < sibling.lo) {\n-            /* cannot merge non-contiguous ranges, move on. */\n-            return sibling;\n-        }\n-        if (getMethodEntry() != sibling.getMethodEntry()) {\n-            /* cannot merge distinct callers, move on. */\n-            return sibling;\n-        }\n-        if (getLine() != sibling.getLine()) {\n-            /* cannot merge callers with different line numbers, move on. */\n-            return sibling;\n-        }\n-        if (isLeaf() != sibling.isLeaf()) {\n-            /*\n-             * cannot merge leafs with non-leafs as that results in them becoming non-leafs and not\n-             * getting proper line info\n-             */\n-            return sibling;\n-        }\n-        /* splice out the sibling from the chain and update this one to include it. */\n-        unlink(debugContext, sibling);\n-        /* relocate the siblings children to this node. */\n-        reparentChildren(debugContext, sibling);\n-        /* return the merged node so we can maybe merge it again. */\n-        return this;\n-    }\n-\n-    private void unlink(DebugContext debugContext, Range sibling) {\n-        assert hi == sibling.lo : String.format(\"gap in range [0x%x,0x%x] %s [0x%x,0x%x] %s\",\n-                        lo, hi, getFullMethodNameWithParams(), sibling.getLo(), sibling.getHi(), sibling.getFullMethodNameWithParams());\n-        assert this.isInlined == sibling.isInlined : String.format(\"change in inlined [0x%x,0x%x] %s %s [0x%x,0x%x] %s %s\",\n-                        lo, hi, getFullMethodNameWithParams(), Boolean.valueOf(this.isInlined), sibling.lo, sibling.hi, sibling.getFullMethodNameWithParams(), Boolean.valueOf(sibling.isInlined));\n-        debugContext.log(DebugContext.DETAILED_LEVEL, \"Combining [0x%x, 0x%x] %s into [0x%x, 0x%x] %s\", sibling.lo, sibling.hi, sibling.getFullMethodName(), lo, hi, getFullMethodNameWithParams());\n-        this.hi = sibling.hi;\n-        this.siblingCallee = sibling.siblingCallee;\n-    }\n-\n-    private void reparentChildren(DebugContext debugContext, Range sibling) {\n-        Range siblingNext = sibling.getFirstCallee();\n-        while (siblingNext != null) {\n-            debugContext.log(DebugContext.DETAILED_LEVEL, \"Reparenting [0x%x, 0x%x] %s to [0x%x, 0x%x] %s\", siblingNext.lo, siblingNext.hi, siblingNext.getFullMethodName(), lo, hi,\n-                            getFullMethodNameWithParams());\n-            siblingNext.caller = this;\n-            Range newSiblingNext = siblingNext.siblingCallee;\n-            siblingNext.siblingCallee = null;\n-            addCallee(siblingNext);\n-            siblingNext = newSiblingNext;\n-        }\n-    }\n }\n", "next_change": {"commit": "2070ace4d658b9767e7502bf21d31fe7658d4c1d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 92a9fed3718..6bb1eb1d42e 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -251,7 +254,20 @@ public class Range {\n         return firstCallee == null;\n     }\n \n+    public boolean includesInlineRanges() {\n+        Range child = firstCallee;\n+        while (child != null && child.isLeaf()) {\n+            child = child.siblingCallee;\n+        }\n+        return child != null;\n+    }\n+\n     public int getDepth() {\n         return depth;\n     }\n+\n+    @SuppressWarnings(\"unused\")\n+    public boolean isPrologueEnd() {\n+        return isPrologueEnd;\n+    }\n }\n", "next_change": {"commit": "f22d3cb6554a4cbd5b156016ddd506e169be3beb", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 6bb1eb1d42e..2f5417118fb 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -270,4 +335,68 @@ public class Range {\n     public boolean isPrologueEnd() {\n         return isPrologueEnd;\n     }\n+\n+    public void setLocalValueInfo(DebugLocalValueInfo[] localValueInfos) {\n+        int len = localValueInfos.length;\n+        this.localValueInfos = localValueInfos;\n+        this.localInfos = new DebugLocalInfo[len];\n+        // set up mapping from local values to local variables\n+        for (int i = 0; i < len; i++) {\n+            localInfos[i] = methodEntry.recordLocal(localValueInfos[i]);\n+        }\n+    }\n+\n+    public HashMap<DebugLocalInfo, List<Range>> getVarRangeMap() {\n+        MethodEntry calleeMethod;\n+        if (isPrimary()) {\n+            calleeMethod = getMethodEntry();\n+        } else {\n+            assert !isLeaf() : \"should only be looking up var ranges for inlined calls\";\n+            calleeMethod = firstCallee.getMethodEntry();\n+        }\n+        HashMap<DebugLocalInfo, List<Range>> varRangeMap = new HashMap<>();\n+        varRangeMap.put(calleeMethod.getThisParam(), new ArrayList<Range>());\n+        for (int i = 0; i < calleeMethod.getParamCount(); i++) {\n+            varRangeMap.put(calleeMethod.getParam(i), new ArrayList<Range>());\n+        }\n+        for (int i = 0; i < calleeMethod.getLocalCount(); i++) {\n+            varRangeMap.put(calleeMethod.getLocal(i), new ArrayList<Range>());\n+        }\n+        return updateVarRangeMap(varRangeMap);\n+    }\n+\n+    public HashMap<DebugLocalInfo, List<Range>> updateVarRangeMap(HashMap<DebugLocalInfo, List<Range>> varRangeMap) {\n+        // leaf subranges of the current range may provide values for param or local vars\n+        // of this range's method. find them and index the range so that we can identify\n+        // both the local/param and the associated range.\n+        Range subRange = this.firstCallee;\n+        while (subRange != null) {\n+            addVarRanges(subRange, varRangeMap);\n+            subRange = subRange.siblingCallee;\n+        }\n+        return varRangeMap;\n+    }\n+\n+    public void addVarRanges(Range subRange, HashMap<DebugLocalInfo, List<Range>> varRangeMap) {\n+        int localValueCount = subRange.getLocalValueCount();\n+        for (int i = 0; i < localValueCount; i++) {\n+            DebugLocalValueInfo localValueInfo = subRange.getLocalValue(i);\n+            DebugLocalInfo local = subRange.getLocal(i);\n+            if (local != null && localValueInfo.localKind() != DebugLocalValueInfo.LocalKind.UNDEFINED) {\n+                List<Range> varRanges = varRangeMap.get(local);\n+                assert varRanges != null : \"local not present in var to ranges map!\";\n+                varRanges.add(subRange);\n+            }\n+        }\n+    }\n+\n+    public DebugLocalValueInfo lookupValue(DebugLocalInfo local) {\n+        int localValueCount = getLocalValueCount();\n+        for (int i = 0; i < localValueCount; i++) {\n+            if (getLocal(i) == local) {\n+                return getLocalValue(i);\n+            }\n+        }\n+        return null;\n+    }\n }\n", "next_change": {"commit": "9acf1c5d597e38f3e832360ce3f372ad94b16e9e", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/range/Range.java\nsimilarity index 51%\nrename from substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nrename to substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/range/Range.java\nindex 2f5417118fb..0ddc82fe6f9 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/range/Range.java\n", "chunk": "@@ -377,26 +273,25 @@ public class Range {\n         return varRangeMap;\n     }\n \n-    public void addVarRanges(Range subRange, HashMap<DebugLocalInfo, List<Range>> varRangeMap) {\n+    public void addVarRanges(SubRange subRange, HashMap<DebugLocalInfo, List<SubRange>> varRangeMap) {\n         int localValueCount = subRange.getLocalValueCount();\n         for (int i = 0; i < localValueCount; i++) {\n             DebugLocalValueInfo localValueInfo = subRange.getLocalValue(i);\n             DebugLocalInfo local = subRange.getLocal(i);\n-            if (local != null && localValueInfo.localKind() != DebugLocalValueInfo.LocalKind.UNDEFINED) {\n-                List<Range> varRanges = varRangeMap.get(local);\n-                assert varRanges != null : \"local not present in var to ranges map!\";\n-                varRanges.add(subRange);\n+            if (local != null) {\n+                switch (localValueInfo.localKind()) {\n+                    case REGISTER:\n+                    case STACKSLOT:\n+                    case CONSTANT:\n+                        List<SubRange> varRanges = varRangeMap.get(local);\n+                        assert varRanges != null : \"local not present in var to ranges map!\";\n+                        varRanges.add(subRange);\n+                        break;\n+                    case UNDEFINED:\n+                        break;\n+                }\n             }\n         }\n     }\n \n-    public DebugLocalValueInfo lookupValue(DebugLocalInfo local) {\n-        int localValueCount = getLocalValueCount();\n-        for (int i = 0; i < localValueCount; i++) {\n-            if (getLocal(i) == local) {\n-                return getLocalValue(i);\n-            }\n-        }\n-        return null;\n-    }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk0ODg2MQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r484948861", "body": "As a result of your latest changes, this should no longer be necessary, i.e., there should be no dependency from the `.debug$S` section to the `.text` section, so you can remove the whole `getDependencies` method.", "bodyText": "As a result of your latest changes, this should no longer be necessary, i.e., there should be no dependency from the .debug$S section to the .text section, so you can remove the whole getDependencies method.", "bodyHTML": "<p dir=\"auto\">As a result of your latest changes, this should no longer be necessary, i.e., there should be no dependency from the <code>.debug$S</code> section to the <code>.text</code> section, so you can remove the whole <code>getDependencies</code> method.</p>", "author": "pejovica", "createdAt": "2020-09-08T14:07:22Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import com.oracle.objectfile.io.Utf8;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Set;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SIGNATURE_C13;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SYMBOL_SECTION_NAME;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.TEXT_SECTION_NAME;\n+\n+public final class CVSymbolSectionImpl extends CVSectionImpl {\n+\n+    private static final int CV_VECTOR_DEFAULT_SIZE = 200;\n+    private static final int CV_STRINGTABLE_DEFAULT_SIZE = 200;\n+\n+    private final CVDebugInfo cvDebugInfo;\n+    private final ArrayList<CVSymbolRecord> cvRecords;\n+    private final CVStringTable stringTable;\n+    private final CVFileTableRecord fileTableRecord;\n+\n+    CVSymbolSectionImpl(CVDebugInfo cvDebugInfo) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cvRecords = new ArrayList<>(CV_VECTOR_DEFAULT_SIZE);\n+        this.stringTable = new CVStringTable(CV_STRINGTABLE_DEFAULT_SIZE);\n+        this.fileTableRecord = new CVFileTableRecord(cvDebugInfo, stringTable);\n+    }\n+\n+    @Override\n+    public String getSectionName() {\n+        return CV_SYMBOL_SECTION_NAME;\n+    }\n+\n+    /*\n+     * Any (there may be sewveral) CodeView symbol section (\"debug$S\") is actually a list of\n+     * records, some of which containing sub-records.\n+     */\n+    @Override\n+    public void createContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() adding records\");\n+        addRecords(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() start\");\n+        /* Add header size. */\n+        pos += Integer.BYTES;\n+        /* Add sum of all record sizes. */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            pos = record.computeFullSize(pos);\n+        }\n+        /* Create a buffer that holds it all. */\n+        byte[] buffer = new byte[pos];\n+        super.setContent(buffer);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() end\");\n+    }\n+\n+    @Override\n+    public void writeContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() start recordcount=%d\", cvRecords.size());\n+        byte[] buffer = getContent();\n+        /* Write section header. */\n+        log(debugContext, \"  [0x%08x] CV_SIGNATURE_C13\", pos);\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, buffer, pos);\n+        /* Write all records. */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            log(debugContext, \"  [0x%08x] %s\", pos, record.toString());\n+            record.logContents(debugContext);\n+            pos = record.computeFullContents(buffer, pos);\n+        }\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() end\");\n+    }\n+\n+    private void addRecords(DebugContext debugContext) {\n+        addPrologueRecord();\n+        addFunctionRecords(debugContext);\n+        addFileRecord();\n+        addStringTableRecord();\n+    }\n+\n+    private void addPrologueRecord() {\n+        CVSymbolSubsection prologue = new CVSymbolSubsection(cvDebugInfo);\n+        CVSymbolSubrecord.CVObjectNameRecord objectNameRecord = new CVSymbolSubrecord.CVObjectNameRecord(cvDebugInfo);\n+        if (objectNameRecord.isValid()) {\n+            prologue.addRecord(objectNameRecord);\n+        }\n+        prologue.addRecord(new CVSymbolSubrecord.CVCompile3Record(cvDebugInfo));\n+        prologue.addRecord(new CVSymbolSubrecord.CVEnvBlockRecord(cvDebugInfo));\n+        addRecord(prologue);\n+    }\n+\n+    private void addFunctionRecords(DebugContext debugContext) {\n+        /* This will build and add many records for each function. */\n+        new CVSymbolSubsectionBuilder(cvDebugInfo).build(debugContext);\n+    }\n+\n+    private void addFileRecord() {\n+        /* Files are added to this record during function record building. */\n+        addRecord(fileTableRecord);\n+    }\n+\n+    CVFileTableRecord getFileTableRecord() {\n+        return this.fileTableRecord;\n+    }\n+\n+    private void addStringTableRecord() {\n+        CVSymbolRecord stringTableRecord = new CVStringTableRecord(cvDebugInfo, stringTable);\n+        addRecord(stringTableRecord);\n+    }\n+\n+    static final class CVStringTable {\n+        static final class StringTableEntry {\n+            public int offset;\n+            public String text;\n+\n+            StringTableEntry(int offset, String text) {\n+                this.offset = offset;\n+                this.text = text;\n+            }\n+        }\n+\n+        /* Use LinkedHashMap so order is maintained when writing string table. */\n+        private final HashMap<String, StringTableEntry> strings;\n+        private int currentOffset = 0;\n+\n+        CVStringTable(int startSize) {\n+            strings = new LinkedHashMap<>(startSize);\n+            /* Ensure that the empty string has index 0. */\n+            add(\"\");\n+        }\n+\n+        int add(String s) {\n+            StringTableEntry newEntry = new StringTableEntry(currentOffset, s);\n+            StringTableEntry entry = strings.putIfAbsent(s, newEntry);\n+            if (entry == null) {\n+                currentOffset += Utf8.utf8Length(s) + 1;\n+            }\n+            return entry == null ? newEntry.offset : entry.offset;\n+        }\n+\n+        Collection<StringTableEntry> values() {\n+            return strings.values();\n+        }\n+\n+        int size() {\n+            return strings.size();\n+        }\n+\n+        int getCurrentOffset() {\n+            return currentOffset;\n+        }\n+    }\n+\n+    void addRecord(CVSymbolRecord record) {\n+        cvRecords.add(record);\n+    }\n+\n+    @Override\n+    public Set<BuildDependency> getDependencies(Map<ObjectFile.Element, LayoutDecisionMap> decisions) {\n+        Set<BuildDependency> deps = super.getDependencies(decisions);\n+        PECoffObjectFile.PECoffSection targetSection = (PECoffObjectFile.PECoffSection) getElement().getOwner().elementForName(TEXT_SECTION_NAME);\n+        LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n+        /* Make our content depend on the compiled code (.text) section. */\n+        deps.add(BuildDependency.createOrGet(ourContent, decisions.get(targetSection).getDecision(LayoutDecision.Kind.CONTENT)));", "originalCommit": "f853143b8b1b99dc5ecb13bc9d3f90133041e58f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyNjg3OQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r485126879", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-09-08T18:49:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk0ODg2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\nindex 9a659174324..ecf1a17c870 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n", "chunk": "@@ -194,14 +186,4 @@ public final class CVSymbolSectionImpl extends CVSectionImpl {\n     void addRecord(CVSymbolRecord record) {\n         cvRecords.add(record);\n     }\n-\n-    @Override\n-    public Set<BuildDependency> getDependencies(Map<ObjectFile.Element, LayoutDecisionMap> decisions) {\n-        Set<BuildDependency> deps = super.getDependencies(decisions);\n-        PECoffObjectFile.PECoffSection targetSection = (PECoffObjectFile.PECoffSection) getElement().getOwner().elementForName(TEXT_SECTION_NAME);\n-        LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n-        /* Make our content depend on the compiled code (.text) section. */\n-        deps.add(BuildDependency.createOrGet(ourContent, decisions.get(targetSection).getDecision(LayoutDecision.Kind.CONTENT)));\n-        return deps;\n-    }\n }\n", "next_change": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\nindex ecf1a17c870..694e3bf7c7d 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n", "chunk": "@@ -186,4 +186,27 @@ public final class CVSymbolSectionImpl extends CVSectionImpl {\n     void addRecord(CVSymbolRecord record) {\n         cvRecords.add(record);\n     }\n+\n+    /**\n+     * Mark an offset:segment relocation site for linker or loader fixup.\n+     *\n+     * @param buffer output buffer\n+     * @param initialPos position of fixup in output buffer\n+     * @param offset offset to add to the fixup\n+     * @param symbolName symbolname to reference\n+     * @return new position in output buffer\n+     */\n+    public int markRelocationSite(byte[] buffer, int initialPos, String symbolName, Long offset) {\n+        int pos = initialPos;\n+        if (buffer != null) {\n+            markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, symbolName, offset);\n+            pos += ObjectFile.RelocationKind.getRelocationSize(ObjectFile.RelocationKind.SECREL_4);\n+            markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, symbolName, 0);\n+            pos += ObjectFile.RelocationKind.getRelocationSize(ObjectFile.RelocationKind.SECTION_2);\n+        } else {\n+            pos = CVUtil.putInt(0, buffer, pos);\n+            pos = CVUtil.putShort((short) 0, buffer, pos);\n+        }\n+        return pos;\n+    }\n }\n", "next_change": {"commit": "be97e8b0b377da7184398ae13748683d31424624", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\nindex 694e3bf7c7d..456adceeb6c 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n", "chunk": "@@ -192,21 +192,31 @@ public final class CVSymbolSectionImpl extends CVSectionImpl {\n      *\n      * @param buffer output buffer\n      * @param initialPos position of fixup in output buffer\n-     * @param offset offset to add to the fixup\n      * @param symbolName symbolname to reference\n      * @return new position in output buffer\n      */\n-    public int markRelocationSite(byte[] buffer, int initialPos, String symbolName, Long offset) {\n-        int pos = initialPos;\n+    public int markRelocationSite(byte[] buffer, int initialPos, String symbolName) {\n+        return markRelocationSite(buffer, initialPos, symbolName, 0);\n+    }\n+\n+    /**\n+     * Mark an offset:segment + offset relocation site for linker or loader fixup.\n+     *\n+     * @param buffer output buffer\n+     * @param initialPos position of fixup in output buffer\n+     * @param symbolName symbolname to reference\n+     * @param offset offset from symbol\n+     * @return new position in output buffer\n+     */\n+    public int markRelocationSite(byte[] buffer, int initialPos, String symbolName, long offset) {\n+        int pos = markRelocationSite(buffer, initialPos, symbolName, RelocationKind.SECREL_4, offset);\n+        return markRelocationSite(buffer, pos, symbolName, RelocationKind.SECTION_2, 0);\n+    }\n+\n+    private int markRelocationSite(byte[] buffer, int initialPos, String symbolName, RelocationKind kind, long offset) {\n         if (buffer != null) {\n-            markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, symbolName, offset);\n-            pos += ObjectFile.RelocationKind.getRelocationSize(ObjectFile.RelocationKind.SECREL_4);\n-            markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, symbolName, 0);\n-            pos += ObjectFile.RelocationKind.getRelocationSize(ObjectFile.RelocationKind.SECTION_2);\n-        } else {\n-            pos = CVUtil.putInt(0, buffer, pos);\n-            pos = CVUtil.putShort((short) 0, buffer, pos);\n+            markRelocationSite(initialPos, kind, symbolName, offset);\n         }\n-        return pos;\n+        return initialPos + RelocationKind.getRelocationSize(kind);\n     }\n }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk4MzA5NA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r484983094", "body": "```suggestion\r\n                        int offset, short segment, byte flags) {\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    int offset, short segment,\n          \n          \n            \n                                    byte flags) {\n          \n          \n            \n                                    int offset, short segment, byte flags) {", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                        <span class=\"pl-k\">int</span> offset, <span class=\"pl-k\">short</span> segment,</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                        <span class=\"pl-k\">byte</span> flags) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                        <span class=\"pl-k\">int</span> offset, <span class=\"pl-k\">short</span> segment, <span class=\"pl-k\">byte</span> flags) {</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pejovica", "createdAt": "2020-09-08T14:52:26Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/*\n+ * A CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file.\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    final int computeFullContents(byte[] buffer, int initialPos) {\n+        subrecordStartPosition = initialPos;\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* Save room for length (not including length bytes). */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(pos=0x%06x cmd=0x%04x)\", subrecordStartPosition, cmd);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* find the full path to object file we will produce. */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Infer object filename from first class definition. */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* Signature is currently set to 0. */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"S_OBJNAME \" + objName;\n+        }\n+    }\n+\n+    public static final class CVCompile3Record extends CVSymbolSubrecord {\n+\n+        private static final byte HAS_DEBUG_FLAG = 0;\n+        @SuppressWarnings(\"unused\") private static final byte HAS_NO_DEBUG_FLAG = (byte) 0x80;\n+\n+        private byte language;\n+        private byte cf1;\n+        private byte cf2;\n+        private byte padding;\n+        private short machine;\n+        private short feMajor;\n+        private short feMinor;\n+        private short feBuild;\n+        private short feQFE;\n+        private short beMajor;\n+        private short beMinor;\n+        private short beBuild;\n+        private short beQFE;\n+        private String compiler;\n+\n+        CVCompile3Record(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_COMPILE3);\n+            language = 0;\n+            cf1 = HAS_DEBUG_FLAG;\n+            cf2 = (byte) 0;\n+            padding = (byte) 0;\n+            machine = (short) 208;\n+            feMajor = (short) 2;\n+            feMinor = (short) 3;\n+            feBuild = (short) 4;\n+            feQFE = (short) 5;\n+            beMajor = (short) 6;\n+            beMinor = (short) 7;\n+            beBuild = (short) 8;\n+            beQFE = (short) 9;\n+            compiler = \"graal\";\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putByte(language, buffer, initialPos);\n+            pos = CVUtil.putByte(cf1, buffer, pos);\n+            pos = CVUtil.putByte(cf2, buffer, pos);\n+            pos = CVUtil.putByte(padding, buffer, pos);\n+            pos = CVUtil.putShort(machine, buffer, pos);\n+            pos = CVUtil.putShort(feMajor, buffer, pos);\n+            pos = CVUtil.putShort(feMinor, buffer, pos);\n+            pos = CVUtil.putShort(feBuild, buffer, pos);\n+            pos = CVUtil.putShort(feQFE, buffer, pos);\n+            pos = CVUtil.putShort(beMajor, buffer, pos);\n+            pos = CVUtil.putShort(beMinor, buffer, pos);\n+            pos = CVUtil.putShort(beBuild, buffer, pos);\n+            pos = CVUtil.putShort(beQFE, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(compiler, buffer, pos);  // inline null terminated\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_COMPILE3 machine=%d fe=%d.%d.%d.%d be=%d.%d.%d%d compiler=%s\", machine, feMajor, feMinor, feBuild, feQFE, beMajor, beMinor, beBuild, beQFE, compiler);\n+        }\n+    }\n+\n+    public static final class CVEnvBlockRecord extends CVSymbolSubrecord {\n+\n+        private static final int ENVMAP_INITIAL_CAPACITY = 10;\n+\n+        private Map<String, String> map = new HashMap<>(ENVMAP_INITIAL_CAPACITY);\n+\n+        /*-\n+         * Example contents of the environment block:\n+         *   cwd = C:\\tmp\\graal-8\n+         *   cl = C:\\tmp\\graal-8\\ojdkbuild\\tools\\toolchain\\vs2010e\\VC\\Bin\\x86_amd64\\cl.exe\n+         *   cmd = -Zi -MT -IC:\\tmp\\graal-8\\tools\\toolchain\\vs2010e\\VC\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE\\gl -TC -X\n+         *   src = helloworld.java\n+         *   pdb = C:\\tmp\\graal-8\\vc100.pdb\n+         */\n+        CVEnvBlockRecord(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_ENVBLOCK);\n+\n+            /* Current directory. */\n+            map.put(\"cwd\", System.getProperty(\"user.dir\"));\n+\n+            /*\n+             * Define the primary source file - ideally, the source file containing main(). (Note\n+             * that if Graal were to be used to compile a library, there may not be a main()). Since\n+             * Graal doesn't work with java source files, use the source file associated with the\n+             * first class that has a source file.\n+             */\n+            String fn = findFirstFile(cvDebugInfo);\n+            if (fn != null) {\n+                map.put(\"src\", fn);\n+            }\n+        }\n+\n+        private static String findFirstFile(CVDebugInfo cvDebugInfo) {\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            /* Flags. */\n+            int pos = CVUtil.putByte((byte) 0, buffer, initialPos);\n+\n+            /* Key/value pairs. */\n+            for (Map.Entry<String, String> entry : map.entrySet()) {\n+                pos = CVUtil.putUTF8StringBytes(entry.getKey(), buffer, pos);\n+                pos = CVUtil.putUTF8StringBytes(entry.getValue(), buffer, pos);\n+            }\n+\n+            /* End marker. */\n+            pos = CVUtil.putUTF8StringBytes(\"\", buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"S_ENVBLOCK \" + map.size() + \" entries\";\n+        }\n+    }\n+\n+    /*\n+     * Creating a proc32 record has side effects: a global symbol is added to the COFF symbol\n+     * section, and two relocation entries are added to the section relocation table, they refer\n+     * back to the global symbol.\n+     */\n+    public static class CVSymbolGProc32Record extends CVSymbolSubrecord {\n+\n+        int pparent;\n+        int pend;\n+        int pnext;\n+        int proclen;\n+        int debugStart;\n+        int debugEnd;\n+        int typeIndex;\n+        int offset;\n+        short segment;\n+        byte flags;\n+        String externalName;\n+        String debuggerName;\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, short cmd, String externalName, String debuggerName, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex,\n+                        int offset, short segment,\n+                        byte flags) {", "originalCommit": "f853143b8b1b99dc5ecb13bc9d3f90133041e58f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyNTU2NQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r485125565", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-09-08T18:46:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk4MzA5NA=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex ccbdd1011ca..ddb43d1039c 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -267,8 +266,7 @@ abstract class CVSymbolSubrecord {\n         String debuggerName;\n \n         CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, short cmd, String externalName, String debuggerName, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex,\n-                        int offset, short segment,\n-                        byte flags) {\n+                        int offset, short segment, byte flags) {\n             super(cvDebugInfo, cmd);\n             this.externalName = externalName;\n             this.debuggerName = debuggerName;\n", "next_change": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex ddb43d1039c..0a30db69e94 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -252,24 +251,24 @@ abstract class CVSymbolSubrecord {\n      */\n     public static class CVSymbolGProc32Record extends CVSymbolSubrecord {\n \n-        int pparent;\n-        int pend;\n-        int pnext;\n-        int proclen;\n-        int debugStart;\n-        int debugEnd;\n-        int typeIndex;\n-        int offset;\n-        short segment;\n-        byte flags;\n-        String externalName;\n-        String debuggerName;\n-\n-        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, short cmd, String externalName, String debuggerName, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex,\n+        private final int pparent;\n+        private final int pend;\n+        private final int pnext;\n+        private final int proclen;\n+        private final int debugStart;\n+        private final int debugEnd;\n+        private final int typeIndex;\n+        private final int offset;\n+        private final short segment;\n+        private final byte flags;\n+        private final String symbolName;\n+        private final String displayName;\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, short cmd, String symbolName, String displayName, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex,\n                         int offset, short segment, byte flags) {\n             super(cvDebugInfo, cmd);\n-            this.externalName = externalName;\n-            this.debuggerName = debuggerName;\n+            this.symbolName = symbolName;\n+            this.displayName = displayName;\n             this.pparent = pparent;\n             this.pend = pend;\n             this.pnext = pnext;\n", "next_change": {"commit": "77e3a7479e429a3279d3061496d260e35f21f000", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex 0a30db69e94..29d819c743f 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -258,15 +344,14 @@ abstract class CVSymbolSubrecord {\n         private final int debugStart;\n         private final int debugEnd;\n         private final int typeIndex;\n-        private final int offset;\n         private final short segment;\n         private final byte flags;\n         private final String symbolName;\n         private final String displayName;\n \n-        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, short cmd, String symbolName, String displayName, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex,\n-                        int offset, short segment, byte flags) {\n-            super(cvDebugInfo, cmd);\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, String symbolName, String displayName, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex,\n+                        short segment, byte flags) {\n+            super(cvDebugInfo, CVDebugConstants.S_GPROC32);\n             this.symbolName = symbolName;\n             this.displayName = displayName;\n             this.pparent = pparent;\n", "next_change": null}, {"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex 0a30db69e94..29d819c743f 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -276,16 +361,10 @@ abstract class CVSymbolSubrecord {\n             this.debugStart = debugStart;\n             this.debugEnd = debugEnd;\n             this.typeIndex = typeIndex;\n-            this.offset = offset;\n             this.segment = segment;\n             this.flags = flags;\n         }\n \n-        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, String symbolName, String displayName, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset,\n-                        short segment, byte flags) {\n-            this(cvDebugInfo, CVDebugConstants.S_GPROC32, symbolName, displayName, pparent, pend, pnext, proclen, debugStart, debugEnd, typeIndex, offset, segment, flags);\n-        }\n-\n         @Override\n         protected int computeContents(byte[] buffer, int initialPos) {\n             int pos = CVUtil.putInt(pparent, buffer, initialPos);\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk4Mzc4Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r484983787", "body": "```suggestion\r\n                            proclen, offset, typeIndex, flags);\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        proclen, offset,\n          \n          \n            \n                                        typeIndex, flags);\n          \n          \n            \n                                        proclen, offset, typeIndex, flags);", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                            proclen, offset,</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                            typeIndex, flags);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                            proclen, offset, typeIndex, flags);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pejovica", "createdAt": "2020-09-08T14:53:24Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/*\n+ * A CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file.\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    final int computeFullContents(byte[] buffer, int initialPos) {\n+        subrecordStartPosition = initialPos;\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* Save room for length (not including length bytes). */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(pos=0x%06x cmd=0x%04x)\", subrecordStartPosition, cmd);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* find the full path to object file we will produce. */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Infer object filename from first class definition. */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* Signature is currently set to 0. */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"S_OBJNAME \" + objName;\n+        }\n+    }\n+\n+    public static final class CVCompile3Record extends CVSymbolSubrecord {\n+\n+        private static final byte HAS_DEBUG_FLAG = 0;\n+        @SuppressWarnings(\"unused\") private static final byte HAS_NO_DEBUG_FLAG = (byte) 0x80;\n+\n+        private byte language;\n+        private byte cf1;\n+        private byte cf2;\n+        private byte padding;\n+        private short machine;\n+        private short feMajor;\n+        private short feMinor;\n+        private short feBuild;\n+        private short feQFE;\n+        private short beMajor;\n+        private short beMinor;\n+        private short beBuild;\n+        private short beQFE;\n+        private String compiler;\n+\n+        CVCompile3Record(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_COMPILE3);\n+            language = 0;\n+            cf1 = HAS_DEBUG_FLAG;\n+            cf2 = (byte) 0;\n+            padding = (byte) 0;\n+            machine = (short) 208;\n+            feMajor = (short) 2;\n+            feMinor = (short) 3;\n+            feBuild = (short) 4;\n+            feQFE = (short) 5;\n+            beMajor = (short) 6;\n+            beMinor = (short) 7;\n+            beBuild = (short) 8;\n+            beQFE = (short) 9;\n+            compiler = \"graal\";\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putByte(language, buffer, initialPos);\n+            pos = CVUtil.putByte(cf1, buffer, pos);\n+            pos = CVUtil.putByte(cf2, buffer, pos);\n+            pos = CVUtil.putByte(padding, buffer, pos);\n+            pos = CVUtil.putShort(machine, buffer, pos);\n+            pos = CVUtil.putShort(feMajor, buffer, pos);\n+            pos = CVUtil.putShort(feMinor, buffer, pos);\n+            pos = CVUtil.putShort(feBuild, buffer, pos);\n+            pos = CVUtil.putShort(feQFE, buffer, pos);\n+            pos = CVUtil.putShort(beMajor, buffer, pos);\n+            pos = CVUtil.putShort(beMinor, buffer, pos);\n+            pos = CVUtil.putShort(beBuild, buffer, pos);\n+            pos = CVUtil.putShort(beQFE, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(compiler, buffer, pos);  // inline null terminated\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_COMPILE3 machine=%d fe=%d.%d.%d.%d be=%d.%d.%d%d compiler=%s\", machine, feMajor, feMinor, feBuild, feQFE, beMajor, beMinor, beBuild, beQFE, compiler);\n+        }\n+    }\n+\n+    public static final class CVEnvBlockRecord extends CVSymbolSubrecord {\n+\n+        private static final int ENVMAP_INITIAL_CAPACITY = 10;\n+\n+        private Map<String, String> map = new HashMap<>(ENVMAP_INITIAL_CAPACITY);\n+\n+        /*-\n+         * Example contents of the environment block:\n+         *   cwd = C:\\tmp\\graal-8\n+         *   cl = C:\\tmp\\graal-8\\ojdkbuild\\tools\\toolchain\\vs2010e\\VC\\Bin\\x86_amd64\\cl.exe\n+         *   cmd = -Zi -MT -IC:\\tmp\\graal-8\\tools\\toolchain\\vs2010e\\VC\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE\\gl -TC -X\n+         *   src = helloworld.java\n+         *   pdb = C:\\tmp\\graal-8\\vc100.pdb\n+         */\n+        CVEnvBlockRecord(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_ENVBLOCK);\n+\n+            /* Current directory. */\n+            map.put(\"cwd\", System.getProperty(\"user.dir\"));\n+\n+            /*\n+             * Define the primary source file - ideally, the source file containing main(). (Note\n+             * that if Graal were to be used to compile a library, there may not be a main()). Since\n+             * Graal doesn't work with java source files, use the source file associated with the\n+             * first class that has a source file.\n+             */\n+            String fn = findFirstFile(cvDebugInfo);\n+            if (fn != null) {\n+                map.put(\"src\", fn);\n+            }\n+        }\n+\n+        private static String findFirstFile(CVDebugInfo cvDebugInfo) {\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            /* Flags. */\n+            int pos = CVUtil.putByte((byte) 0, buffer, initialPos);\n+\n+            /* Key/value pairs. */\n+            for (Map.Entry<String, String> entry : map.entrySet()) {\n+                pos = CVUtil.putUTF8StringBytes(entry.getKey(), buffer, pos);\n+                pos = CVUtil.putUTF8StringBytes(entry.getValue(), buffer, pos);\n+            }\n+\n+            /* End marker. */\n+            pos = CVUtil.putUTF8StringBytes(\"\", buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"S_ENVBLOCK \" + map.size() + \" entries\";\n+        }\n+    }\n+\n+    /*\n+     * Creating a proc32 record has side effects: a global symbol is added to the COFF symbol\n+     * section, and two relocation entries are added to the section relocation table, they refer\n+     * back to the global symbol.\n+     */\n+    public static class CVSymbolGProc32Record extends CVSymbolSubrecord {\n+\n+        int pparent;\n+        int pend;\n+        int pnext;\n+        int proclen;\n+        int debugStart;\n+        int debugEnd;\n+        int typeIndex;\n+        int offset;\n+        short segment;\n+        byte flags;\n+        String externalName;\n+        String debuggerName;\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, short cmd, String externalName, String debuggerName, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex,\n+                        int offset, short segment,\n+                        byte flags) {\n+            super(cvDebugInfo, cmd);\n+            this.externalName = externalName;\n+            this.debuggerName = debuggerName;\n+            this.pparent = pparent;\n+            this.pend = pend;\n+            this.pnext = pnext;\n+            this.proclen = proclen;\n+            this.debugStart = debugStart;\n+            this.debugEnd = debugEnd;\n+            this.typeIndex = typeIndex;\n+            this.offset = offset;\n+            this.segment = segment;\n+            this.flags = flags;\n+        }\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, String externalName, String debuggerName, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset,\n+                        short segment, byte flags) {\n+            this(cvDebugInfo, CVDebugConstants.S_GPROC32, externalName, debuggerName, pparent, pend, pnext, proclen, debugStart, debugEnd, typeIndex, offset, segment, flags);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(pparent, buffer, initialPos);\n+            pos = CVUtil.putInt(pend, buffer, pos);\n+            pos = CVUtil.putInt(pnext, buffer, pos);\n+            pos = CVUtil.putInt(proclen, buffer, pos);\n+            pos = CVUtil.putInt(debugStart, buffer, pos);\n+            pos = CVUtil.putInt(debugEnd, buffer, pos);\n+            pos = CVUtil.putInt(typeIndex, buffer, pos);\n+            if (buffer != null) {\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, externalName, false, 1L);\n+            }\n+            pos = CVUtil.putInt(0, buffer, pos);\n+            if (buffer != null) {\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, externalName, false, 1L);\n+            }\n+            pos = CVUtil.putShort((short) 0, buffer, pos);\n+            pos = CVUtil.putByte(flags, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(debuggerName, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_GPROC32   name=%s/%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", debuggerName, externalName, pparent, debugStart, debugEnd,\n+                            proclen, offset,\n+                            typeIndex, flags);", "originalCommit": "f853143b8b1b99dc5ecb13bc9d3f90133041e58f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyNTgyOQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r485125829", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-09-08T18:47:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk4Mzc4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex ccbdd1011ca..ddb43d1039c 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -314,8 +312,7 @@ abstract class CVSymbolSubrecord {\n         @Override\n         public String toString() {\n             return String.format(\"S_GPROC32   name=%s/%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", debuggerName, externalName, pparent, debugStart, debugEnd,\n-                            proclen, offset,\n-                            typeIndex, flags);\n+                            proclen, offset, typeIndex, flags);\n         }\n     }\n \n", "next_change": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex ddb43d1039c..0a30db69e94 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -296,35 +295,28 @@ abstract class CVSymbolSubrecord {\n             pos = CVUtil.putInt(debugStart, buffer, pos);\n             pos = CVUtil.putInt(debugEnd, buffer, pos);\n             pos = CVUtil.putInt(typeIndex, buffer, pos);\n-            if (buffer != null) {\n-                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, externalName, false, 1L);\n-            }\n-            pos = CVUtil.putInt(0, buffer, pos);\n-            if (buffer != null) {\n-                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, externalName, false, 1L);\n-            }\n-            pos = CVUtil.putShort((short) 0, buffer, pos);\n+            pos = cvDebugInfo.getCVSymbolSection().markRelocationSite(buffer, pos, symbolName, (long) 0);\n             pos = CVUtil.putByte(flags, buffer, pos);\n-            pos = CVUtil.putUTF8StringBytes(debuggerName, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(displayName, buffer, pos);\n             return pos;\n         }\n \n         @Override\n         public String toString() {\n-            return String.format(\"S_GPROC32   name=%s/%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", debuggerName, externalName, pparent, debugStart, debugEnd,\n-                            proclen, offset, typeIndex, flags);\n+            return String.format(\"S_GPROC32   name=%s/%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x seg:offset=0x%x:0x%x type=0x%x flags=0x%x)\", displayName, symbolName, pparent, debugStart, debugEnd,\n+                            proclen, segment, offset, typeIndex, flags);\n         }\n     }\n \n     public static final class CVSymbolFrameProcRecord extends CVSymbolSubrecord {\n \n-        int framelen;\n-        int padLen;\n-        int padOffset;\n-        int saveRegsCount;\n-        int ehOffset;\n-        short ehSection;\n-        int flags;\n+        private final int framelen;\n+        private final int padLen;\n+        private final int padOffset;\n+        private final int saveRegsCount;\n+        private final int ehOffset;\n+        private final short ehSection;\n+        private final int flags;\n \n         CVSymbolFrameProcRecord(CVDebugInfo cvDebugInfo, int framelen, int padLen, int padOffset, int saveRegsCount, int ehOffset, short ehSection, int flags) {\n             super(cvDebugInfo, CVDebugConstants.S_FRAMEPROC);\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDEzNDM1MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r490134350", "body": "Is `ADDR32` needed? It doesn't seem to be used anywhere.", "bodyText": "Is ADDR32 needed? It doesn't seem to be used anywhere.", "bodyHTML": "<p dir=\"auto\">Is <code>ADDR32</code> needed? It doesn't seem to be used anywhere.</p>", "author": "pejovica", "createdAt": "2020-09-17T10:20:35Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/PECoffMachine.java", "diffHunk": "@@ -146,6 +150,24 @@ public long toLong() {\n             return IMAGE_RELOCATION.IMAGE_REL_AMD64_ADDR64;\n         }\n     },\n+    ADDR32 {", "originalCommit": "63c089695709a51471b1a8771431e40da7773b08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMzMjkwNw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r492332907", "bodyText": "Not at this time, but I included it to be more consistent with other code in Graal, (such as PECoff.java).\nMy belief is that when you're defining constants for hardware, you should include them all, not just a subset.\nIt doesn't hurt readability, and may make some coder's life easier in the future.", "author": "stooke", "createdAt": "2020-09-21T20:40:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDEzNDM1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMxMzUzOA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r502313538", "bodyText": "Could you then hook it into getRelocation as well, because it's kind of half done right now.", "author": "pejovica", "createdAt": "2020-10-09T09:44:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDEzNDM1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIyMTQxOA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r510221418", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-10-22T14:44:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDEzNDM1MA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDEzOTkwMw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r490139903", "body": "This should no longer be needed.\r\n```suggestion\r\n```", "bodyText": "This should no longer be needed.\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                static final String TEXT_SECTION_NAME = SectionName.TEXT.getFormatDependentName(PECOFF);", "bodyHTML": "<p dir=\"auto\">This should no longer be needed.</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"><span class=\"x x-first\">    </span><span class=\"pl-k x\">static</span><span class=\"x\"> </span><span class=\"pl-k x\">final</span><span class=\"x\"> </span><span class=\"pl-smi x\">String</span><span class=\"x\"> </span><span class=\"pl-c1 x\">TEXT_SECTION_NAME</span><span class=\"x\"> </span><span class=\"pl-k x\">=</span><span class=\"x\"> </span><span class=\"pl-smi x\">SectionName</span><span class=\"pl-c1\"><span class=\"pl-k x\">.</span><span class=\"x\">TEXT</span></span><span class=\"pl-k x\">.</span><span class=\"x\">getFormatDependentName(</span><span class=\"pl-c1 x\">PECOFF</span><span class=\"x x-last\">);</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pejovica", "createdAt": "2020-09-17T10:30:58Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.SectionName;\n+\n+import static com.oracle.objectfile.ObjectFile.Format.PECOFF;\n+\n+public abstract class CVConstants {\n+\n+    /* The names of relevant CodeView sections. */\n+    static final String CV_SECTION_NAME_PREFIX = \".debug$\";\n+    static final String CV_SYMBOL_SECTION_NAME = CV_SECTION_NAME_PREFIX + \"S\";\n+    static final String CV_TYPE_SECTION_NAME = CV_SECTION_NAME_PREFIX + \"T\";\n+    static final String TEXT_SECTION_NAME = SectionName.TEXT.getFormatDependentName(PECOFF);", "originalCommit": "63c089695709a51471b1a8771431e40da7773b08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3NjA1MQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r492276051", "bodyText": "done.", "author": "stooke", "createdAt": "2020-09-21T18:52:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDEzOTkwMw=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java\nindex a551ce974e8..5465da96716 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java\n", "chunk": "@@ -26,17 +26,12 @@\n \n package com.oracle.objectfile.pecoff.cv;\n \n-import com.oracle.objectfile.SectionName;\n-\n-import static com.oracle.objectfile.ObjectFile.Format.PECOFF;\n-\n public abstract class CVConstants {\n \n     /* The names of relevant CodeView sections. */\n     static final String CV_SECTION_NAME_PREFIX = \".debug$\";\n     static final String CV_SYMBOL_SECTION_NAME = CV_SECTION_NAME_PREFIX + \"S\";\n     static final String CV_TYPE_SECTION_NAME = CV_SECTION_NAME_PREFIX + \"T\";\n-    static final String TEXT_SECTION_NAME = SectionName.TEXT.getFormatDependentName(PECOFF);\n \n     /* CodeView section header signature */\n     static final int CV_SIGNATURE_C13 = 4;\n", "next_change": {"commit": "77e3a7479e429a3279d3061496d260e35f21f000", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java\nindex 5465da96716..9bea2634bbd 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java\n", "chunk": "@@ -35,4 +35,13 @@ public abstract class CVConstants {\n \n     /* CodeView section header signature */\n     static final int CV_SIGNATURE_C13 = 4;\n+\n+    static final int CV_AMD64_R8 = 336;\n+    static final int CV_AMD64_R9 = 337;\n+    static final int CV_AMD64_R10 = 338;\n+    static final int CV_AMD64_R11 = 339;\n+    static final int CV_AMD64_R12 = 340;\n+    static final int CV_AMD64_R13 = 341;\n+    static final int CV_AMD64_R14 = 342;\n+    static final int CV_AMD64_R15 = 343;\n }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE3MjY3Mg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r490172672", "body": "The `methodName` parameter is no longer needed because you can now get the symbol name via `primaryEntry`.", "bodyText": "The methodName parameter is no longer needed because you can now get the symbol name via primaryEntry.", "bodyHTML": "<p dir=\"auto\">The <code>methodName</code> parameter is no longer needed because you can now get the symbol name via <code>primaryEntry</code>.</p>", "author": "pejovica", "createdAt": "2020-09-17T11:34:23Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_NOTYPE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_VOID;\n+\n+final class CVSymbolSubsectionBuilder {\n+\n+    private final CVDebugInfo cvDebugInfo;\n+    private final CVSymbolSubsection cvSymbolSubsection;\n+    private CVLineRecordBuilder lineRecordBuilder;\n+    private DebugContext debugContext = null;\n+\n+    private boolean noMainFound = true;\n+\n+    CVSymbolSubsectionBuilder(CVDebugInfo cvDebugInfo) {\n+        this.cvSymbolSubsection = new CVSymbolSubsection(cvDebugInfo);\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    /**\n+     * Build DEBUG_S_SYMBOLS record from all classEntries. (CodeView 4 format allows us to build one\n+     * per class or one per function or one big record - which is what we do here).\n+     *\n+     * The CodeView symbol section Prolog is also a CVSymbolSubsection, but it is not build in this\n+     * class.\n+     */\n+    void build(DebugContext theDebugContext) {\n+        this.debugContext = theDebugContext;\n+        this.lineRecordBuilder = new CVLineRecordBuilder(debugContext, cvDebugInfo);\n+        /* loop over all classes defined in this module. */\n+        for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+            build(classEntry);\n+        }\n+        cvDebugInfo.getCVSymbolSection().addRecord(cvSymbolSubsection);\n+    }\n+\n+    /**\n+     * Build all debug info for a classEntry. (does not yet handle member variables).\n+     *\n+     * @param classEntry current class\n+     */\n+    private void build(ClassEntry classEntry) {\n+        /* Loop over all functions defined in this class. */\n+        for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+            build(primaryEntry);\n+        }\n+    }\n+\n+    /**\n+     * Emit records for each function: PROC32 S_FRAMEPROC S_END and line number records. (later:\n+     * type records as required).\n+     *\n+     * @param primaryEntry primary entry for this function\n+     */\n+    private void build(PrimaryEntry primaryEntry) {\n+        final Range primaryRange = primaryEntry.getPrimary();\n+\n+        /* The name as it will appear in the debugger. */\n+        final String debuggerName = getDebuggerName(primaryRange);\n+\n+        /* The name as exposed to the linker. */\n+        final String externalName = primaryRange.getSymbolName();\n+\n+        /* S_PROC32 add function definition. */\n+        int functionTypeIndex = addTypeRecords(primaryEntry);\n+        byte funcFlags = 0;\n+        CVSymbolSubrecord.CVSymbolGProc32Record proc32 = new CVSymbolSubrecord.CVSymbolGProc32Record(cvDebugInfo, externalName, debuggerName, 0, 0, 0, primaryEntry.getFrameSize(), 0, 0,\n+                        functionTypeIndex, primaryRange.getLo(), (short) 0, funcFlags);\n+        addToSymbolSubsection(proc32);\n+\n+        /* S_FRAMEPROC add frame definitions. */\n+        int asynceh = 1 << 9; /* Async exception handling (vc++ uses 1, clang uses 0). */\n+        int localBP = 1 << 14; /* Local base pointer = SP (0=none, 1=sp, 2=bp 3=r13). */\n+        int paramBP = 1 << 16; /* Param base pointer = SP. */\n+        int frameFlags = asynceh + localBP + paramBP; /* NB: LLVM uses 0x14000. */\n+        addToSymbolSubsection(new CVSymbolSubrecord.CVSymbolFrameProcRecord(cvDebugInfo, primaryEntry.getFrameSize(), frameFlags));\n+\n+        /* TODO: add local variables, and their types. */\n+        /* TODO: add block definitions. */\n+\n+        /* S_END add end record. */\n+        addToSymbolSubsection(new CVSymbolSubrecord.CVSymbolEndRecord(cvDebugInfo));\n+\n+        /* Add line number records. */\n+        addLineNumberRecords(primaryEntry, externalName);\n+    }\n+\n+    /**\n+     * Rename function names for usability or functionality.\n+     *\n+     * First encountered main function becomes class.main. This is for usability.\n+     *\n+     * All other functions become class.function.999 (where 999 is a hash of the arglist). This is\n+     * because The standard link.exe can't handle odd characters (parentheses or commas, for\n+     * example) in debug information.\n+     *\n+     * This does not affect external symbols used by linker.\n+     *\n+     * TODO: strip illegal characters from arg lists instead (\"link.exe\" - safe names)\n+     *\n+     * @param range Range contained in the method of interest\n+     * @return user debugger friendly method name\n+     */\n+    private String getDebuggerName(Range range) {\n+        final String methodName;\n+        if (noMainFound && range.getMethodName().equals(\"main\")) {\n+            noMainFound = false;\n+            methodName = range.getClassAndMethodName();\n+        } else {\n+            /* In the future, use a more user-friendly name instead of a hash function. */\n+            methodName = range.getSymbolName();\n+        }\n+        return methodName;\n+    }\n+\n+    private void addLineNumberRecords(PrimaryEntry primaryEntry, String methodName) {", "originalCommit": "63c089695709a51471b1a8771431e40da7773b08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMyNjcwNQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r492326705", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-09-21T20:28:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE3MjY3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\nindex 11f51e773f5..f0eac5086e0 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n", "chunk": "@@ -144,13 +144,13 @@ final class CVSymbolSubsectionBuilder {\n         return methodName;\n     }\n \n-    private void addLineNumberRecords(PrimaryEntry primaryEntry, String methodName) {\n-        CVLineRecord record = lineRecordBuilder.build(primaryEntry, methodName);\n+    private void addLineNumberRecords(PrimaryEntry primaryEntry) {\n+        CVLineRecord record = lineRecordBuilder.build(primaryEntry);\n         /*\n-         * If the builder decides this entry is uninteresting, we don't build a record. for example,\n-         * Graal intrinsics may be uninteresting to some developers.\n+         * If there are no file entries (perhaps for a synthetic function?), we don't add this\n+         * record.\n          */\n-        if (record != null) {\n+        if (!record.isEmpty()) {\n             cvDebugInfo.getCVSymbolSection().addRecord(record);\n         }\n     }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE3Nzg4Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r490177887", "body": "It seems that `record` is never `null`, so perhaps code and comment need updating.", "bodyText": "It seems that record is never null, so perhaps code and comment need updating.", "bodyHTML": "<p dir=\"auto\">It seems that <code>record</code> is never <code>null</code>, so perhaps code and comment need updating.</p>", "author": "pejovica", "createdAt": "2020-09-17T11:43:48Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_NOTYPE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_VOID;\n+\n+final class CVSymbolSubsectionBuilder {\n+\n+    private final CVDebugInfo cvDebugInfo;\n+    private final CVSymbolSubsection cvSymbolSubsection;\n+    private CVLineRecordBuilder lineRecordBuilder;\n+    private DebugContext debugContext = null;\n+\n+    private boolean noMainFound = true;\n+\n+    CVSymbolSubsectionBuilder(CVDebugInfo cvDebugInfo) {\n+        this.cvSymbolSubsection = new CVSymbolSubsection(cvDebugInfo);\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    /**\n+     * Build DEBUG_S_SYMBOLS record from all classEntries. (CodeView 4 format allows us to build one\n+     * per class or one per function or one big record - which is what we do here).\n+     *\n+     * The CodeView symbol section Prolog is also a CVSymbolSubsection, but it is not build in this\n+     * class.\n+     */\n+    void build(DebugContext theDebugContext) {\n+        this.debugContext = theDebugContext;\n+        this.lineRecordBuilder = new CVLineRecordBuilder(debugContext, cvDebugInfo);\n+        /* loop over all classes defined in this module. */\n+        for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+            build(classEntry);\n+        }\n+        cvDebugInfo.getCVSymbolSection().addRecord(cvSymbolSubsection);\n+    }\n+\n+    /**\n+     * Build all debug info for a classEntry. (does not yet handle member variables).\n+     *\n+     * @param classEntry current class\n+     */\n+    private void build(ClassEntry classEntry) {\n+        /* Loop over all functions defined in this class. */\n+        for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+            build(primaryEntry);\n+        }\n+    }\n+\n+    /**\n+     * Emit records for each function: PROC32 S_FRAMEPROC S_END and line number records. (later:\n+     * type records as required).\n+     *\n+     * @param primaryEntry primary entry for this function\n+     */\n+    private void build(PrimaryEntry primaryEntry) {\n+        final Range primaryRange = primaryEntry.getPrimary();\n+\n+        /* The name as it will appear in the debugger. */\n+        final String debuggerName = getDebuggerName(primaryRange);\n+\n+        /* The name as exposed to the linker. */\n+        final String externalName = primaryRange.getSymbolName();\n+\n+        /* S_PROC32 add function definition. */\n+        int functionTypeIndex = addTypeRecords(primaryEntry);\n+        byte funcFlags = 0;\n+        CVSymbolSubrecord.CVSymbolGProc32Record proc32 = new CVSymbolSubrecord.CVSymbolGProc32Record(cvDebugInfo, externalName, debuggerName, 0, 0, 0, primaryEntry.getFrameSize(), 0, 0,\n+                        functionTypeIndex, primaryRange.getLo(), (short) 0, funcFlags);\n+        addToSymbolSubsection(proc32);\n+\n+        /* S_FRAMEPROC add frame definitions. */\n+        int asynceh = 1 << 9; /* Async exception handling (vc++ uses 1, clang uses 0). */\n+        int localBP = 1 << 14; /* Local base pointer = SP (0=none, 1=sp, 2=bp 3=r13). */\n+        int paramBP = 1 << 16; /* Param base pointer = SP. */\n+        int frameFlags = asynceh + localBP + paramBP; /* NB: LLVM uses 0x14000. */\n+        addToSymbolSubsection(new CVSymbolSubrecord.CVSymbolFrameProcRecord(cvDebugInfo, primaryEntry.getFrameSize(), frameFlags));\n+\n+        /* TODO: add local variables, and their types. */\n+        /* TODO: add block definitions. */\n+\n+        /* S_END add end record. */\n+        addToSymbolSubsection(new CVSymbolSubrecord.CVSymbolEndRecord(cvDebugInfo));\n+\n+        /* Add line number records. */\n+        addLineNumberRecords(primaryEntry, externalName);\n+    }\n+\n+    /**\n+     * Rename function names for usability or functionality.\n+     *\n+     * First encountered main function becomes class.main. This is for usability.\n+     *\n+     * All other functions become class.function.999 (where 999 is a hash of the arglist). This is\n+     * because The standard link.exe can't handle odd characters (parentheses or commas, for\n+     * example) in debug information.\n+     *\n+     * This does not affect external symbols used by linker.\n+     *\n+     * TODO: strip illegal characters from arg lists instead (\"link.exe\" - safe names)\n+     *\n+     * @param range Range contained in the method of interest\n+     * @return user debugger friendly method name\n+     */\n+    private String getDebuggerName(Range range) {\n+        final String methodName;\n+        if (noMainFound && range.getMethodName().equals(\"main\")) {\n+            noMainFound = false;\n+            methodName = range.getClassAndMethodName();\n+        } else {\n+            /* In the future, use a more user-friendly name instead of a hash function. */\n+            methodName = range.getSymbolName();\n+        }\n+        return methodName;\n+    }\n+\n+    private void addLineNumberRecords(PrimaryEntry primaryEntry, String methodName) {\n+        CVLineRecord record = lineRecordBuilder.build(primaryEntry, methodName);\n+        /*\n+         * If the builder decides this entry is uninteresting, we don't build a record. for example,\n+         * Graal intrinsics may be uninteresting to some developers.\n+         */\n+        if (record != null) {", "originalCommit": "63c089695709a51471b1a8771431e40da7773b08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwNjkxOQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r492306919", "bodyText": "You're right; I changed the code to only add a record if there were fileblock entries.", "author": "stooke", "createdAt": "2020-09-21T19:49:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE3Nzg4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\nindex 11f51e773f5..f0eac5086e0 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n", "chunk": "@@ -144,13 +144,13 @@ final class CVSymbolSubsectionBuilder {\n         return methodName;\n     }\n \n-    private void addLineNumberRecords(PrimaryEntry primaryEntry, String methodName) {\n-        CVLineRecord record = lineRecordBuilder.build(primaryEntry, methodName);\n+    private void addLineNumberRecords(PrimaryEntry primaryEntry) {\n+        CVLineRecord record = lineRecordBuilder.build(primaryEntry);\n         /*\n-         * If the builder decides this entry is uninteresting, we don't build a record. for example,\n-         * Graal intrinsics may be uninteresting to some developers.\n+         * If there are no file entries (perhaps for a synthetic function?), we don't add this\n+         * record.\n          */\n-        if (record != null) {\n+        if (!record.isEmpty()) {\n             cvDebugInfo.getCVSymbolSection().addRecord(record);\n         }\n     }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIwOTIzNA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r490209234", "body": "Have you considered using a new builder for each entry? I think that would simplify the code a bit because you would no longer have to think about the state of the builder here (e.g., you would already set `primaryEntry` in the constructor).", "bodyText": "Have you considered using a new builder for each entry? I think that would simplify the code a bit because you would no longer have to think about the state of the builder here (e.g., you would already set primaryEntry in the constructor).", "bodyHTML": "<p dir=\"auto\">Have you considered using a new builder for each entry? I think that would simplify the code a bit because you would no longer have to think about the state of the builder here (e.g., you would already set <code>primaryEntry</code> in the constructor).</p>", "author": "pejovica", "createdAt": "2020-09-17T12:37:56Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+\n+/*\n+ * In CV4, the line table consists of a series of file headers followed by line number entries.\n+ * to handle this, first we decide if we want to merge this with the previous range (only if\n+ * same file and start of this range is end of previous range) if we are emitting a new range to\n+ * the same file, write the range, save it as the previous range and go on If this is a\n+ * different file, then update the length of the previous file header, write the new file header\n+ * and write the new range At the very end, make sure we update the last file header.\n+ *\n+ * In addition, optionally ignore Ranges that point into Graal innards, just adding them to the\n+ * current enclosing range.\n+ */\n+\n+public class CVLineRecordBuilder {\n+\n+    private CVDebugInfo cvDebugInfo;\n+    private DebugContext debugContext;\n+    private CVLineRecord lineRecord;\n+    private PrimaryEntry primaryEntry;\n+\n+    CVLineRecordBuilder(DebugContext theDebugContext, CVDebugInfo cvDebugInfo) {\n+        this.debugContext = theDebugContext;\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    public void debug(String format, Object... args) {\n+        cvDebugInfo.getCVSymbolSection().verboseLog(debugContext, format, args);\n+    }\n+\n+    /**\n+     * Build line number records for a function.\n+     *\n+     * @param entry function to build line number table for\n+     * @return CVLineRecord containing any entries generated, or null if no entries generated\n+     */\n+    CVLineRecord build(PrimaryEntry entry, String methodName) {", "originalCommit": "63c089695709a51471b1a8771431e40da7773b08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzAzNzQzMg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r493037432", "bodyText": "I'd rather not; I don't think the code would be much clearer (but it would be less efficient - I'd like to rewrite it more of a stream handler), and there's a chance that the Builder might in future need to know the previous state when I reimplement some of the code that I've removed.", "author": "stooke", "createdAt": "2020-09-22T21:14:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIwOTIzNA=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\nindex 9c37c305ba7..1156522fb8e 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n", "chunk": "@@ -65,111 +58,52 @@ public class CVLineRecordBuilder {\n      * @param entry function to build line number table for\n      * @return CVLineRecord containing any entries generated, or null if no entries generated\n      */\n-    CVLineRecord build(PrimaryEntry entry, String methodName) {\n-        // long lowAddr = Long.MAX_VALUE;\n-        // long highAddr = 0;\n+    CVLineRecord build(PrimaryEntry entry) {\n         this.primaryEntry = entry;\n-\n         Range primaryRange = primaryEntry.getPrimary();\n-        Range previousRange = null;\n \n         debug(\"DEBUG_S_LINES linerecord for 0x%05x file: %s:%d\\n\", primaryRange.getLo(), primaryRange.getFileName(), primaryRange.getLine());\n-        this.lineRecord = new CVLineRecord(cvDebugInfo, methodName);\n+        this.lineRecord = new CVLineRecord(cvDebugInfo, primaryRange.getSymbolName());\n         debug(\"CVLineRecord.computeContents: processing primary range %s\\n\", primaryRange);\n-        previousRange = processRange(primaryRange, previousRange);\n-        // lowAddr = Math.min(lowAddr, primaryRange.getLo());\n-        // highAddr = Math.max(highAddr, primaryRange.getHi());\n \n+        processRange(primaryRange);\n         for (Range subRange : primaryEntry.getSubranges()) {\n             debug(\"CVLineRecord.computeContents: processing range %s\\n\", subRange);\n-            FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subRange);\n-            if (subFileEntry == null) {\n-                continue;\n-            }\n-            previousRange = processRange(subRange, previousRange);\n-            // lowAddr = Math.min(lowAddr, subRange.getLo());\n-            // highAddr = Math.max(highAddr, subRange.getHi());\n+            processRange(subRange);\n         }\n         return lineRecord;\n     }\n \n     /**\n      * Merge input Range structures into line number table. The Range structures are assumed to be\n-     * ordered by ascending address merge with previous line entry if: - if a Range has a negative\n-     * linenumber - if a range is part of Graal or the JDK, and skipGraalOption is true - if a range\n-     * has the same line number, source file and function\n+     * ordered by ascending address.\n      *\n      * @param range to be merged or added to line number record\n-     * @param oldPreviousRange the previously processed Range\n-     * @return new value for previousRange in caller\n      */\n-    private Range processRange(Range range, Range oldPreviousRange) {\n+    private void processRange(Range range) {\n \n-        Range previousRange = oldPreviousRange;\n-\n-        if (range.getLine() == -1) {\n-            debug(\"     processRange: ignoring: bad line number\\n\");\n-            return previousRange;\n+        FileEntry file = cvDebugInfo.findFile(range.getFileAsPath());\n+        if (file == null) {\n+            debug(\"processRange: range has no file: %s\\n\", range);\n+            return;\n         }\n \n-        /* Is this a new file? if so emit a new file record. */\n-        boolean wantNewFile = previousRange == null || !previousRange.getFileAsPath().equals(range.getFileAsPath());\n-        if (wantNewFile) {\n-            FileEntry file = cvDebugInfo.findFile(range.getFileAsPath());\n-            if (file != null && file.getFileName() != null) {\n-                previousRange = null;\n-                debug(\"processRange: addNewFile: %s\\n\", file);\n-                lineRecord.addNewFile(file);\n-            } else {\n-                debug(\"processRange: range has no file: %s\\n\", range);\n-                return previousRange;\n-            }\n+        if (range.getLine() == -1) {\n+            debug(\"processRange: ignoring: bad line number\\n\");\n+            return;\n         }\n \n-        if (wantNewRange(range, previousRange)) {\n-            previousRange = range;\n-            int lineLoAddr = range.getLo() - primaryEntry.getPrimary().getLo();\n-            int line = Math.max(range.getLine(), 1);\n-            debug(\"processRange:   addNewLine: 0x%05x %s\\n\", lineLoAddr, line);\n-            lineRecord.addNewLine(lineLoAddr, line);\n+        int fileId = cvDebugInfo.getCVSymbolSection().getFileTableRecord().addFile(file);\n+        if (lineRecord.isEmpty() || lineRecord.getCurrentFileId() != fileId) {\n+            debug(\"processRange: addNewFile: %s\\n\", file);\n+            lineRecord.addNewFile(fileId);\n         }\n-        return previousRange;\n-    }\n-\n-    /**\n-     * Test to see if a new line record should be emitted.\n-     *\n-     * @param previousRange previous range\n-     * @param range current range\n-     * @return true if the current range is on a different line or file from the previous one\n-     */\n-    private static boolean wantNewRange(@SuppressWarnings(\"unused\") Range range, @SuppressWarnings(\"unused\") Range previousRange) {\n-        /* Return true for now; this will be a further optimization (see unused_wantNewRange). */\n-        return true;\n-    }\n \n-    /**\n-     * Test to see if a new line record should be emitted.\n-     *\n-     * @param previousRange previous range\n-     * @param range current range\n-     * @return true if the current range is on a different line or file from the previous one\n-     */\n-    @SuppressWarnings(\"unused\")\n-    private static boolean unusedWantNewRange(@SuppressWarnings(\"unused\") Range range, @SuppressWarnings(\"unused\") Range previousRange) {\n-        if (previousRange == null) {\n-            return true;\n-        }\n-        if (previousRange.getLine() != range.getLine()) {\n-            return true;\n-        }\n-        if (previousRange.getFilePath() != range.getFilePath()) {\n-            return true;\n-        }\n-        /* It might actually be fine to merge if there's a gap between ranges. */\n-        // if (previousRange.getHi() < range.getLo()) {\n-        // return true;\n-        // }\n-        return false;\n+        /* Add line record. */\n+        /* An optimization would be to merge adjacent line records. */\n+        int lineLoAddr = range.getLo() - primaryEntry.getPrimary().getLo();\n+        int line = Math.max(range.getLine(), 1);\n+        debug(\"processRange:   addNewLine: 0x%05x %s\\n\", lineLoAddr, line);\n+        lineRecord.addNewLine(lineLoAddr, line);\n     }\n }\n", "next_change": {"commit": "6d209109480ecec08ebf137288371d4c56064ba0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\nindex 1156522fb8e..2e83cf343d2 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n", "chunk": "@@ -103,7 +104,7 @@ public class CVLineRecordBuilder {\n         /* An optimization would be to merge adjacent line records. */\n         int lineLoAddr = range.getLo() - primaryEntry.getPrimary().getLo();\n         int line = Math.max(range.getLine(), 1);\n-        debug(\"processRange:   addNewLine: 0x%05x %s\\n\", lineLoAddr, line);\n+        debug(\"  processRange:   addNewLine: 0x%05x-0x%05x %s\", lineLoAddr, range.getLo() - primaryEntry.getPrimary().getHi(), line);\n         lineRecord.addNewLine(lineLoAddr, line);\n     }\n }\n", "next_change": {"commit": "20496a00704b8c5b6445a353f1bd114181ae7d91", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\nindex 2e83cf343d2..714f0194fc8 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n", "chunk": "@@ -101,10 +101,9 @@ public class CVLineRecordBuilder {\n         }\n \n         /* Add line record. */\n-        /* An optimization would be to merge adjacent line records. */\n         int lineLoAddr = range.getLo() - primaryEntry.getPrimary().getLo();\n         int line = Math.max(range.getLine(), 1);\n-        debug(\"  processRange:   addNewLine: 0x%05x-0x%05x %s\", lineLoAddr, range.getLo() - primaryEntry.getPrimary().getHi(), line);\n+        debug(\"  processRange:   addNewLine: 0x%05x-0x%05x %s\", lineLoAddr, range.getHi() - primaryEntry.getPrimary().getLo(), line);\n         lineRecord.addNewLine(lineLoAddr, line);\n     }\n }\n", "next_change": {"commit": "4caf93deee510084247c88599752478fc53bd73d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\nindex 714f0194fc8..34598cf5e9f 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n", "chunk": "@@ -101,9 +101,9 @@ public class CVLineRecordBuilder {\n         }\n \n         /* Add line record. */\n-        int lineLoAddr = range.getLo() - primaryEntry.getPrimary().getLo();\n+        int lineLoAddr = range.getLo() - compiledEntry.getPrimary().getLo();\n         int line = Math.max(range.getLine(), 1);\n-        debug(\"  processRange:   addNewLine: 0x%05x-0x%05x %s\", lineLoAddr, range.getHi() - primaryEntry.getPrimary().getLo(), line);\n+        debug(\"  processRange:   addNewLine: 0x%05x-0x%05x %s\", lineLoAddr, range.getHi() - compiledEntry.getPrimary().getLo(), line);\n         lineRecord.addNewLine(lineLoAddr, line);\n     }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIxMDM2Ng==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r490210366", "body": "A leftover? Same below.", "bodyText": "A leftover? Same below.", "bodyHTML": "<p dir=\"auto\">A leftover? Same below.</p>", "author": "pejovica", "createdAt": "2020-09-17T12:39:45Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+\n+/*\n+ * In CV4, the line table consists of a series of file headers followed by line number entries.\n+ * to handle this, first we decide if we want to merge this with the previous range (only if\n+ * same file and start of this range is end of previous range) if we are emitting a new range to\n+ * the same file, write the range, save it as the previous range and go on If this is a\n+ * different file, then update the length of the previous file header, write the new file header\n+ * and write the new range At the very end, make sure we update the last file header.\n+ *\n+ * In addition, optionally ignore Ranges that point into Graal innards, just adding them to the\n+ * current enclosing range.\n+ */\n+\n+public class CVLineRecordBuilder {\n+\n+    private CVDebugInfo cvDebugInfo;\n+    private DebugContext debugContext;\n+    private CVLineRecord lineRecord;\n+    private PrimaryEntry primaryEntry;\n+\n+    CVLineRecordBuilder(DebugContext theDebugContext, CVDebugInfo cvDebugInfo) {\n+        this.debugContext = theDebugContext;\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    public void debug(String format, Object... args) {\n+        cvDebugInfo.getCVSymbolSection().verboseLog(debugContext, format, args);\n+    }\n+\n+    /**\n+     * Build line number records for a function.\n+     *\n+     * @param entry function to build line number table for\n+     * @return CVLineRecord containing any entries generated, or null if no entries generated\n+     */\n+    CVLineRecord build(PrimaryEntry entry, String methodName) {\n+        // long lowAddr = Long.MAX_VALUE;\n+        // long highAddr = 0;", "originalCommit": "63c089695709a51471b1a8771431e40da7773b08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMyNzU3NA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r492327574", "bodyText": "Gone.", "author": "stooke", "createdAt": "2020-09-21T20:29:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIxMDM2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\nindex 9c37c305ba7..1156522fb8e 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n", "chunk": "@@ -65,111 +58,52 @@ public class CVLineRecordBuilder {\n      * @param entry function to build line number table for\n      * @return CVLineRecord containing any entries generated, or null if no entries generated\n      */\n-    CVLineRecord build(PrimaryEntry entry, String methodName) {\n-        // long lowAddr = Long.MAX_VALUE;\n-        // long highAddr = 0;\n+    CVLineRecord build(PrimaryEntry entry) {\n         this.primaryEntry = entry;\n-\n         Range primaryRange = primaryEntry.getPrimary();\n-        Range previousRange = null;\n \n         debug(\"DEBUG_S_LINES linerecord for 0x%05x file: %s:%d\\n\", primaryRange.getLo(), primaryRange.getFileName(), primaryRange.getLine());\n-        this.lineRecord = new CVLineRecord(cvDebugInfo, methodName);\n+        this.lineRecord = new CVLineRecord(cvDebugInfo, primaryRange.getSymbolName());\n         debug(\"CVLineRecord.computeContents: processing primary range %s\\n\", primaryRange);\n-        previousRange = processRange(primaryRange, previousRange);\n-        // lowAddr = Math.min(lowAddr, primaryRange.getLo());\n-        // highAddr = Math.max(highAddr, primaryRange.getHi());\n \n+        processRange(primaryRange);\n         for (Range subRange : primaryEntry.getSubranges()) {\n             debug(\"CVLineRecord.computeContents: processing range %s\\n\", subRange);\n-            FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subRange);\n-            if (subFileEntry == null) {\n-                continue;\n-            }\n-            previousRange = processRange(subRange, previousRange);\n-            // lowAddr = Math.min(lowAddr, subRange.getLo());\n-            // highAddr = Math.max(highAddr, subRange.getHi());\n+            processRange(subRange);\n         }\n         return lineRecord;\n     }\n \n     /**\n      * Merge input Range structures into line number table. The Range structures are assumed to be\n-     * ordered by ascending address merge with previous line entry if: - if a Range has a negative\n-     * linenumber - if a range is part of Graal or the JDK, and skipGraalOption is true - if a range\n-     * has the same line number, source file and function\n+     * ordered by ascending address.\n      *\n      * @param range to be merged or added to line number record\n-     * @param oldPreviousRange the previously processed Range\n-     * @return new value for previousRange in caller\n      */\n-    private Range processRange(Range range, Range oldPreviousRange) {\n+    private void processRange(Range range) {\n \n-        Range previousRange = oldPreviousRange;\n-\n-        if (range.getLine() == -1) {\n-            debug(\"     processRange: ignoring: bad line number\\n\");\n-            return previousRange;\n+        FileEntry file = cvDebugInfo.findFile(range.getFileAsPath());\n+        if (file == null) {\n+            debug(\"processRange: range has no file: %s\\n\", range);\n+            return;\n         }\n \n-        /* Is this a new file? if so emit a new file record. */\n-        boolean wantNewFile = previousRange == null || !previousRange.getFileAsPath().equals(range.getFileAsPath());\n-        if (wantNewFile) {\n-            FileEntry file = cvDebugInfo.findFile(range.getFileAsPath());\n-            if (file != null && file.getFileName() != null) {\n-                previousRange = null;\n-                debug(\"processRange: addNewFile: %s\\n\", file);\n-                lineRecord.addNewFile(file);\n-            } else {\n-                debug(\"processRange: range has no file: %s\\n\", range);\n-                return previousRange;\n-            }\n+        if (range.getLine() == -1) {\n+            debug(\"processRange: ignoring: bad line number\\n\");\n+            return;\n         }\n \n-        if (wantNewRange(range, previousRange)) {\n-            previousRange = range;\n-            int lineLoAddr = range.getLo() - primaryEntry.getPrimary().getLo();\n-            int line = Math.max(range.getLine(), 1);\n-            debug(\"processRange:   addNewLine: 0x%05x %s\\n\", lineLoAddr, line);\n-            lineRecord.addNewLine(lineLoAddr, line);\n+        int fileId = cvDebugInfo.getCVSymbolSection().getFileTableRecord().addFile(file);\n+        if (lineRecord.isEmpty() || lineRecord.getCurrentFileId() != fileId) {\n+            debug(\"processRange: addNewFile: %s\\n\", file);\n+            lineRecord.addNewFile(fileId);\n         }\n-        return previousRange;\n-    }\n-\n-    /**\n-     * Test to see if a new line record should be emitted.\n-     *\n-     * @param previousRange previous range\n-     * @param range current range\n-     * @return true if the current range is on a different line or file from the previous one\n-     */\n-    private static boolean wantNewRange(@SuppressWarnings(\"unused\") Range range, @SuppressWarnings(\"unused\") Range previousRange) {\n-        /* Return true for now; this will be a further optimization (see unused_wantNewRange). */\n-        return true;\n-    }\n \n-    /**\n-     * Test to see if a new line record should be emitted.\n-     *\n-     * @param previousRange previous range\n-     * @param range current range\n-     * @return true if the current range is on a different line or file from the previous one\n-     */\n-    @SuppressWarnings(\"unused\")\n-    private static boolean unusedWantNewRange(@SuppressWarnings(\"unused\") Range range, @SuppressWarnings(\"unused\") Range previousRange) {\n-        if (previousRange == null) {\n-            return true;\n-        }\n-        if (previousRange.getLine() != range.getLine()) {\n-            return true;\n-        }\n-        if (previousRange.getFilePath() != range.getFilePath()) {\n-            return true;\n-        }\n-        /* It might actually be fine to merge if there's a gap between ranges. */\n-        // if (previousRange.getHi() < range.getLo()) {\n-        // return true;\n-        // }\n-        return false;\n+        /* Add line record. */\n+        /* An optimization would be to merge adjacent line records. */\n+        int lineLoAddr = range.getLo() - primaryEntry.getPrimary().getLo();\n+        int line = Math.max(range.getLine(), 1);\n+        debug(\"processRange:   addNewLine: 0x%05x %s\\n\", lineLoAddr, line);\n+        lineRecord.addNewLine(lineLoAddr, line);\n     }\n }\n", "next_change": {"commit": "6d209109480ecec08ebf137288371d4c56064ba0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\nindex 1156522fb8e..2e83cf343d2 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n", "chunk": "@@ -103,7 +104,7 @@ public class CVLineRecordBuilder {\n         /* An optimization would be to merge adjacent line records. */\n         int lineLoAddr = range.getLo() - primaryEntry.getPrimary().getLo();\n         int line = Math.max(range.getLine(), 1);\n-        debug(\"processRange:   addNewLine: 0x%05x %s\\n\", lineLoAddr, line);\n+        debug(\"  processRange:   addNewLine: 0x%05x-0x%05x %s\", lineLoAddr, range.getLo() - primaryEntry.getPrimary().getHi(), line);\n         lineRecord.addNewLine(lineLoAddr, line);\n     }\n }\n", "next_change": {"commit": "20496a00704b8c5b6445a353f1bd114181ae7d91", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\nindex 2e83cf343d2..714f0194fc8 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n", "chunk": "@@ -101,10 +101,9 @@ public class CVLineRecordBuilder {\n         }\n \n         /* Add line record. */\n-        /* An optimization would be to merge adjacent line records. */\n         int lineLoAddr = range.getLo() - primaryEntry.getPrimary().getLo();\n         int line = Math.max(range.getLine(), 1);\n-        debug(\"  processRange:   addNewLine: 0x%05x-0x%05x %s\", lineLoAddr, range.getLo() - primaryEntry.getPrimary().getHi(), line);\n+        debug(\"  processRange:   addNewLine: 0x%05x-0x%05x %s\", lineLoAddr, range.getHi() - primaryEntry.getPrimary().getLo(), line);\n         lineRecord.addNewLine(lineLoAddr, line);\n     }\n }\n", "next_change": {"commit": "4caf93deee510084247c88599752478fc53bd73d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\nindex 714f0194fc8..34598cf5e9f 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n", "chunk": "@@ -101,9 +101,9 @@ public class CVLineRecordBuilder {\n         }\n \n         /* Add line record. */\n-        int lineLoAddr = range.getLo() - primaryEntry.getPrimary().getLo();\n+        int lineLoAddr = range.getLo() - compiledEntry.getPrimary().getLo();\n         int line = Math.max(range.getLine(), 1);\n-        debug(\"  processRange:   addNewLine: 0x%05x-0x%05x %s\", lineLoAddr, range.getHi() - primaryEntry.getPrimary().getLo(), line);\n+        debug(\"  processRange:   addNewLine: 0x%05x-0x%05x %s\", lineLoAddr, range.getHi() - compiledEntry.getPrimary().getLo(), line);\n         lineRecord.addNewLine(lineLoAddr, line);\n     }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIzMDY4Ng==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r490230686", "body": "This is a bit hard to follow. Could you please remove everything that hasn't been fully implemented yet, so that the code (and comments) better reflect what's actually going on.", "bodyText": "This is a bit hard to follow. Could you please remove everything that hasn't been fully implemented yet, so that the code (and comments) better reflect what's actually going on.", "bodyHTML": "<p dir=\"auto\">This is a bit hard to follow. Could you please remove everything that hasn't been fully implemented yet, so that the code (and comments) better reflect what's actually going on.</p>", "author": "pejovica", "createdAt": "2020-09-17T13:10:26Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+\n+/*\n+ * In CV4, the line table consists of a series of file headers followed by line number entries.\n+ * to handle this, first we decide if we want to merge this with the previous range (only if\n+ * same file and start of this range is end of previous range) if we are emitting a new range to\n+ * the same file, write the range, save it as the previous range and go on If this is a\n+ * different file, then update the length of the previous file header, write the new file header\n+ * and write the new range At the very end, make sure we update the last file header.\n+ *\n+ * In addition, optionally ignore Ranges that point into Graal innards, just adding them to the\n+ * current enclosing range.\n+ */\n+\n+public class CVLineRecordBuilder {\n+\n+    private CVDebugInfo cvDebugInfo;\n+    private DebugContext debugContext;\n+    private CVLineRecord lineRecord;\n+    private PrimaryEntry primaryEntry;\n+\n+    CVLineRecordBuilder(DebugContext theDebugContext, CVDebugInfo cvDebugInfo) {\n+        this.debugContext = theDebugContext;\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    public void debug(String format, Object... args) {\n+        cvDebugInfo.getCVSymbolSection().verboseLog(debugContext, format, args);\n+    }\n+\n+    /**\n+     * Build line number records for a function.\n+     *\n+     * @param entry function to build line number table for\n+     * @return CVLineRecord containing any entries generated, or null if no entries generated\n+     */\n+    CVLineRecord build(PrimaryEntry entry, String methodName) {\n+        // long lowAddr = Long.MAX_VALUE;\n+        // long highAddr = 0;\n+        this.primaryEntry = entry;\n+\n+        Range primaryRange = primaryEntry.getPrimary();\n+        Range previousRange = null;\n+\n+        debug(\"DEBUG_S_LINES linerecord for 0x%05x file: %s:%d\\n\", primaryRange.getLo(), primaryRange.getFileName(), primaryRange.getLine());\n+        this.lineRecord = new CVLineRecord(cvDebugInfo, methodName);\n+        debug(\"CVLineRecord.computeContents: processing primary range %s\\n\", primaryRange);\n+        previousRange = processRange(primaryRange, previousRange);\n+        // lowAddr = Math.min(lowAddr, primaryRange.getLo());\n+        // highAddr = Math.max(highAddr, primaryRange.getHi());\n+\n+        for (Range subRange : primaryEntry.getSubranges()) {\n+            debug(\"CVLineRecord.computeContents: processing range %s\\n\", subRange);\n+            FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subRange);\n+            if (subFileEntry == null) {\n+                continue;\n+            }\n+            previousRange = processRange(subRange, previousRange);\n+            // lowAddr = Math.min(lowAddr, subRange.getLo());\n+            // highAddr = Math.max(highAddr, subRange.getHi());\n+        }\n+        return lineRecord;\n+    }\n+\n+    /**\n+     * Merge input Range structures into line number table. The Range structures are assumed to be\n+     * ordered by ascending address merge with previous line entry if: - if a Range has a negative\n+     * linenumber - if a range is part of Graal or the JDK, and skipGraalOption is true - if a range\n+     * has the same line number, source file and function\n+     *\n+     * @param range to be merged or added to line number record\n+     * @param oldPreviousRange the previously processed Range\n+     * @return new value for previousRange in caller\n+     */\n+    private Range processRange(Range range, Range oldPreviousRange) {", "originalCommit": "63c089695709a51471b1a8771431e40da7773b08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzAzNzQ4Mw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r493037483", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-09-22T21:14:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIzMDY4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\nindex 9c37c305ba7..1156522fb8e 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n", "chunk": "@@ -65,111 +58,52 @@ public class CVLineRecordBuilder {\n      * @param entry function to build line number table for\n      * @return CVLineRecord containing any entries generated, or null if no entries generated\n      */\n-    CVLineRecord build(PrimaryEntry entry, String methodName) {\n-        // long lowAddr = Long.MAX_VALUE;\n-        // long highAddr = 0;\n+    CVLineRecord build(PrimaryEntry entry) {\n         this.primaryEntry = entry;\n-\n         Range primaryRange = primaryEntry.getPrimary();\n-        Range previousRange = null;\n \n         debug(\"DEBUG_S_LINES linerecord for 0x%05x file: %s:%d\\n\", primaryRange.getLo(), primaryRange.getFileName(), primaryRange.getLine());\n-        this.lineRecord = new CVLineRecord(cvDebugInfo, methodName);\n+        this.lineRecord = new CVLineRecord(cvDebugInfo, primaryRange.getSymbolName());\n         debug(\"CVLineRecord.computeContents: processing primary range %s\\n\", primaryRange);\n-        previousRange = processRange(primaryRange, previousRange);\n-        // lowAddr = Math.min(lowAddr, primaryRange.getLo());\n-        // highAddr = Math.max(highAddr, primaryRange.getHi());\n \n+        processRange(primaryRange);\n         for (Range subRange : primaryEntry.getSubranges()) {\n             debug(\"CVLineRecord.computeContents: processing range %s\\n\", subRange);\n-            FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subRange);\n-            if (subFileEntry == null) {\n-                continue;\n-            }\n-            previousRange = processRange(subRange, previousRange);\n-            // lowAddr = Math.min(lowAddr, subRange.getLo());\n-            // highAddr = Math.max(highAddr, subRange.getHi());\n+            processRange(subRange);\n         }\n         return lineRecord;\n     }\n \n     /**\n      * Merge input Range structures into line number table. The Range structures are assumed to be\n-     * ordered by ascending address merge with previous line entry if: - if a Range has a negative\n-     * linenumber - if a range is part of Graal or the JDK, and skipGraalOption is true - if a range\n-     * has the same line number, source file and function\n+     * ordered by ascending address.\n      *\n      * @param range to be merged or added to line number record\n-     * @param oldPreviousRange the previously processed Range\n-     * @return new value for previousRange in caller\n      */\n-    private Range processRange(Range range, Range oldPreviousRange) {\n+    private void processRange(Range range) {\n \n-        Range previousRange = oldPreviousRange;\n-\n-        if (range.getLine() == -1) {\n-            debug(\"     processRange: ignoring: bad line number\\n\");\n-            return previousRange;\n+        FileEntry file = cvDebugInfo.findFile(range.getFileAsPath());\n+        if (file == null) {\n+            debug(\"processRange: range has no file: %s\\n\", range);\n+            return;\n         }\n \n-        /* Is this a new file? if so emit a new file record. */\n-        boolean wantNewFile = previousRange == null || !previousRange.getFileAsPath().equals(range.getFileAsPath());\n-        if (wantNewFile) {\n-            FileEntry file = cvDebugInfo.findFile(range.getFileAsPath());\n-            if (file != null && file.getFileName() != null) {\n-                previousRange = null;\n-                debug(\"processRange: addNewFile: %s\\n\", file);\n-                lineRecord.addNewFile(file);\n-            } else {\n-                debug(\"processRange: range has no file: %s\\n\", range);\n-                return previousRange;\n-            }\n+        if (range.getLine() == -1) {\n+            debug(\"processRange: ignoring: bad line number\\n\");\n+            return;\n         }\n \n-        if (wantNewRange(range, previousRange)) {\n-            previousRange = range;\n-            int lineLoAddr = range.getLo() - primaryEntry.getPrimary().getLo();\n-            int line = Math.max(range.getLine(), 1);\n-            debug(\"processRange:   addNewLine: 0x%05x %s\\n\", lineLoAddr, line);\n-            lineRecord.addNewLine(lineLoAddr, line);\n+        int fileId = cvDebugInfo.getCVSymbolSection().getFileTableRecord().addFile(file);\n+        if (lineRecord.isEmpty() || lineRecord.getCurrentFileId() != fileId) {\n+            debug(\"processRange: addNewFile: %s\\n\", file);\n+            lineRecord.addNewFile(fileId);\n         }\n-        return previousRange;\n-    }\n-\n-    /**\n-     * Test to see if a new line record should be emitted.\n-     *\n-     * @param previousRange previous range\n-     * @param range current range\n-     * @return true if the current range is on a different line or file from the previous one\n-     */\n-    private static boolean wantNewRange(@SuppressWarnings(\"unused\") Range range, @SuppressWarnings(\"unused\") Range previousRange) {\n-        /* Return true for now; this will be a further optimization (see unused_wantNewRange). */\n-        return true;\n-    }\n \n-    /**\n-     * Test to see if a new line record should be emitted.\n-     *\n-     * @param previousRange previous range\n-     * @param range current range\n-     * @return true if the current range is on a different line or file from the previous one\n-     */\n-    @SuppressWarnings(\"unused\")\n-    private static boolean unusedWantNewRange(@SuppressWarnings(\"unused\") Range range, @SuppressWarnings(\"unused\") Range previousRange) {\n-        if (previousRange == null) {\n-            return true;\n-        }\n-        if (previousRange.getLine() != range.getLine()) {\n-            return true;\n-        }\n-        if (previousRange.getFilePath() != range.getFilePath()) {\n-            return true;\n-        }\n-        /* It might actually be fine to merge if there's a gap between ranges. */\n-        // if (previousRange.getHi() < range.getLo()) {\n-        // return true;\n-        // }\n-        return false;\n+        /* Add line record. */\n+        /* An optimization would be to merge adjacent line records. */\n+        int lineLoAddr = range.getLo() - primaryEntry.getPrimary().getLo();\n+        int line = Math.max(range.getLine(), 1);\n+        debug(\"processRange:   addNewLine: 0x%05x %s\\n\", lineLoAddr, line);\n+        lineRecord.addNewLine(lineLoAddr, line);\n     }\n }\n", "next_change": {"commit": "6d209109480ecec08ebf137288371d4c56064ba0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\nindex 1156522fb8e..2e83cf343d2 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n", "chunk": "@@ -103,7 +104,7 @@ public class CVLineRecordBuilder {\n         /* An optimization would be to merge adjacent line records. */\n         int lineLoAddr = range.getLo() - primaryEntry.getPrimary().getLo();\n         int line = Math.max(range.getLine(), 1);\n-        debug(\"processRange:   addNewLine: 0x%05x %s\\n\", lineLoAddr, line);\n+        debug(\"  processRange:   addNewLine: 0x%05x-0x%05x %s\", lineLoAddr, range.getLo() - primaryEntry.getPrimary().getHi(), line);\n         lineRecord.addNewLine(lineLoAddr, line);\n     }\n }\n", "next_change": {"commit": "20496a00704b8c5b6445a353f1bd114181ae7d91", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\nindex 2e83cf343d2..714f0194fc8 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n", "chunk": "@@ -101,10 +101,9 @@ public class CVLineRecordBuilder {\n         }\n \n         /* Add line record. */\n-        /* An optimization would be to merge adjacent line records. */\n         int lineLoAddr = range.getLo() - primaryEntry.getPrimary().getLo();\n         int line = Math.max(range.getLine(), 1);\n-        debug(\"  processRange:   addNewLine: 0x%05x-0x%05x %s\", lineLoAddr, range.getLo() - primaryEntry.getPrimary().getHi(), line);\n+        debug(\"  processRange:   addNewLine: 0x%05x-0x%05x %s\", lineLoAddr, range.getHi() - primaryEntry.getPrimary().getLo(), line);\n         lineRecord.addNewLine(lineLoAddr, line);\n     }\n }\n", "next_change": {"commit": "4caf93deee510084247c88599752478fc53bd73d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\nindex 714f0194fc8..34598cf5e9f 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n", "chunk": "@@ -101,9 +101,9 @@ public class CVLineRecordBuilder {\n         }\n \n         /* Add line record. */\n-        int lineLoAddr = range.getLo() - primaryEntry.getPrimary().getLo();\n+        int lineLoAddr = range.getLo() - compiledEntry.getPrimary().getLo();\n         int line = Math.max(range.getLine(), 1);\n-        debug(\"  processRange:   addNewLine: 0x%05x-0x%05x %s\", lineLoAddr, range.getHi() - primaryEntry.getPrimary().getLo(), line);\n+        debug(\"  processRange:   addNewLine: 0x%05x-0x%05x %s\", lineLoAddr, range.getHi() - compiledEntry.getPrimary().getLo(), line);\n         lineRecord.addNewLine(lineLoAddr, line);\n     }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDM1ODQxMQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r490358411", "body": "I wonder if it is even necessary to compute `highAddr`? Given that the ranges are already sorted by ascending addresses, shouldn't it be the same as the one from the last `fileBlock`?", "bodyText": "I wonder if it is even necessary to compute highAddr? Given that the ranges are already sorted by ascending addresses, shouldn't it be the same as the one from the last fileBlock?", "bodyHTML": "<p dir=\"auto\">I wonder if it is even necessary to compute <code>highAddr</code>? Given that the ranges are already sorted by ascending addresses, shouldn't it be the same as the one from the last <code>fileBlock</code>?</p>", "author": "pejovica", "createdAt": "2020-09-17T15:49:25Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.ObjectFile;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A line record (DEBUG_S_LINES) consists of a list of (file block record + subrecords).\n+ * Graal will generate one CVLineRecord per function.\n+ */\n+final class CVLineRecord extends CVSymbolRecord {\n+\n+    /* Header: addr (4 bytes):section (2 bytes) flags (2 bytes) chunck length (4 bytes). */\n+    private static final int LINE_RECORD_HEADER_SIZE = Integer.BYTES + Short.BYTES * 2 + Integer.BYTES;\n+\n+    private static final int DEFAULT_LINE_BLOCK_COUNT = 100;\n+    private static final int DEFAULT_LINE_ENTRY_COUNT = 100;\n+\n+    /* has colummns flag = 0x80 - not supported */\n+    private static final short CB_HAS_NO_COLUMNS_FLAG = 0x00;\n+\n+    private String symbolName;\n+    private ArrayList<FileBlock> fileBlocks = new ArrayList<>(DEFAULT_LINE_BLOCK_COUNT);\n+\n+    CVLineRecord(CVDebugInfo cvDebugInfo, String symbolName) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_LINES);\n+        this.symbolName = symbolName;\n+    }\n+\n+    void addNewFile(FileEntry file) {\n+        CVFileTableRecord fr = cvDebugInfo.getCVSymbolSection().getFileTableRecord();\n+        int fileId = fr.addFile(file);\n+        fileBlocks.add(new FileBlock(fileId));\n+    }\n+\n+    void addNewLine(int addr, int line) {\n+        fileBlocks.get(fileBlocks.size() - 1).addEntry(new LineEntry(addr, line));\n+    }\n+\n+    @Override\n+    protected int computeSize(int initialPos) {\n+        /* Line record header. */\n+        int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n+        /* All blocks. */\n+        for (FileBlock fileBlock : fileBlocks) {\n+            pos = fileBlock.computeSize(pos);\n+        }\n+        return pos;\n+    }\n+\n+    private void computeHeader(byte[] buffer, int initialPos, int length) {\n+\n+        assert symbolName != null;\n+        int pos = initialPos;\n+\n+        if (buffer != null) {\n+            cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, symbolName, false, 1L);\n+        }\n+        pos = CVUtil.putInt(0, buffer, pos);\n+\n+        if (buffer != null) {\n+            cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, symbolName, false, 1L);\n+        }\n+        pos = CVUtil.putShort((short) 0, buffer, pos);\n+\n+        pos = CVUtil.putShort(CB_HAS_NO_COLUMNS_FLAG, buffer, pos); /* flags */\n+        CVUtil.putInt(length, buffer, pos);\n+    }\n+\n+    @Override\n+    protected int computeContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n+        int highAddr = 0; /* Length of this chunk in object file */\n+        for (FileBlock fileBlock : fileBlocks) {\n+            highAddr = Math.max(highAddr, fileBlock.getHighAddr());", "originalCommit": "63c089695709a51471b1a8771431e40da7773b08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzAwNDAwNw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r493004007", "bodyText": "done.", "author": "stooke", "createdAt": "2020-09-22T20:10:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDM1ODQxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\nindex 794a466e142..090f30fe4ac 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n", "chunk": "@@ -64,48 +61,56 @@ final class CVLineRecord extends CVSymbolRecord {\n         fileBlocks.get(fileBlocks.size() - 1).addEntry(new LineEntry(addr, line));\n     }\n \n+    int getCurrentFileId() {\n+        assert !fileBlocks.isEmpty();\n+        return fileBlocks.get(fileBlocks.size() - 1).fileId;\n+    }\n+\n     @Override\n     protected int computeSize(int initialPos) {\n+        return computeContents(null, initialPos);\n+    }\n+\n+    @Override\n+    protected int computeContents(byte[] buffer, int initialPos) {\n         /* Line record header. */\n-        int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n+        int pos = computeHeader(buffer, initialPos);\n         /* All blocks. */\n         for (FileBlock fileBlock : fileBlocks) {\n-            pos = fileBlock.computeSize(pos);\n+            pos = fileBlock.computeContents(buffer, pos);\n         }\n         return pos;\n     }\n \n-    private void computeHeader(byte[] buffer, int initialPos, int length) {\n+    private int computeHeader(byte[] buffer, int initialPos) {\n+\n+        if (buffer == null) {\n+            return initialPos + LINE_RECORD_HEADER_SIZE;\n+        }\n \n         assert symbolName != null;\n         int pos = initialPos;\n \n-        if (buffer != null) {\n-            cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, symbolName, false, 1L);\n-        }\n+        /* Emit addr:section relocation records. */\n+        cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, symbolName, false, 1L);\n         pos = CVUtil.putInt(0, buffer, pos);\n-\n-        if (buffer != null) {\n-            cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, symbolName, false, 1L);\n-        }\n+        cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, symbolName, false, 1L);\n         pos = CVUtil.putShort((short) 0, buffer, pos);\n \n-        pos = CVUtil.putShort(CB_HAS_NO_COLUMNS_FLAG, buffer, pos); /* flags */\n-        CVUtil.putInt(length, buffer, pos);\n-    }\n+        /* Emit flags. */\n+        pos = CVUtil.putShort(CB_HAS_NO_COLUMNS_FLAG, buffer, pos);\n \n-    @Override\n-    protected int computeContents(byte[] buffer, int initialPos) {\n-        int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n-        int highAddr = 0; /* Length of this chunk in object file */\n-        for (FileBlock fileBlock : fileBlocks) {\n-            highAddr = Math.max(highAddr, fileBlock.getHighAddr());\n-            pos = fileBlock.computeContents(buffer, pos);\n-        }\n-        computeHeader(buffer, initialPos, highAddr);\n+        /* Length of this chunk in object file (= highAddr since it's zero based. */\n+        assert !fileBlocks.isEmpty();\n+        int length = fileBlocks.get(fileBlocks.size() - 1).getHighAddr();\n+        pos = CVUtil.putInt(length, buffer, pos);\n         return pos;\n     }\n \n+    boolean isEmpty() {\n+        return fileBlocks.isEmpty();\n+    }\n+\n     @Override\n     public String toString() {\n         return String.format(\"CVLineRecord(type=0x%04x pos=0x%05x size=0x%d)\", type, recordStartPosition, fileBlocks.size());\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDM4MzgxMw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r490383813", "body": "Assuming the ranges are sorted correctly (which you could assert when adding an entry or line), you could simply return `addr` of the last line here.", "bodyText": "Assuming the ranges are sorted correctly (which you could assert when adding an entry or line), you could simply return addr of the last line here.", "bodyHTML": "<p dir=\"auto\">Assuming the ranges are sorted correctly (which you could assert when adding an entry or line), you could simply return <code>addr</code> of the last line here.</p>", "author": "pejovica", "createdAt": "2020-09-17T16:17:21Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.ObjectFile;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A line record (DEBUG_S_LINES) consists of a list of (file block record + subrecords).\n+ * Graal will generate one CVLineRecord per function.\n+ */\n+final class CVLineRecord extends CVSymbolRecord {\n+\n+    /* Header: addr (4 bytes):section (2 bytes) flags (2 bytes) chunck length (4 bytes). */\n+    private static final int LINE_RECORD_HEADER_SIZE = Integer.BYTES + Short.BYTES * 2 + Integer.BYTES;\n+\n+    private static final int DEFAULT_LINE_BLOCK_COUNT = 100;\n+    private static final int DEFAULT_LINE_ENTRY_COUNT = 100;\n+\n+    /* has colummns flag = 0x80 - not supported */\n+    private static final short CB_HAS_NO_COLUMNS_FLAG = 0x00;\n+\n+    private String symbolName;\n+    private ArrayList<FileBlock> fileBlocks = new ArrayList<>(DEFAULT_LINE_BLOCK_COUNT);\n+\n+    CVLineRecord(CVDebugInfo cvDebugInfo, String symbolName) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_LINES);\n+        this.symbolName = symbolName;\n+    }\n+\n+    void addNewFile(FileEntry file) {\n+        CVFileTableRecord fr = cvDebugInfo.getCVSymbolSection().getFileTableRecord();\n+        int fileId = fr.addFile(file);\n+        fileBlocks.add(new FileBlock(fileId));\n+    }\n+\n+    void addNewLine(int addr, int line) {\n+        fileBlocks.get(fileBlocks.size() - 1).addEntry(new LineEntry(addr, line));\n+    }\n+\n+    @Override\n+    protected int computeSize(int initialPos) {\n+        /* Line record header. */\n+        int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n+        /* All blocks. */\n+        for (FileBlock fileBlock : fileBlocks) {\n+            pos = fileBlock.computeSize(pos);\n+        }\n+        return pos;\n+    }\n+\n+    private void computeHeader(byte[] buffer, int initialPos, int length) {\n+\n+        assert symbolName != null;\n+        int pos = initialPos;\n+\n+        if (buffer != null) {\n+            cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, symbolName, false, 1L);\n+        }\n+        pos = CVUtil.putInt(0, buffer, pos);\n+\n+        if (buffer != null) {\n+            cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, symbolName, false, 1L);\n+        }\n+        pos = CVUtil.putShort((short) 0, buffer, pos);\n+\n+        pos = CVUtil.putShort(CB_HAS_NO_COLUMNS_FLAG, buffer, pos); /* flags */\n+        CVUtil.putInt(length, buffer, pos);\n+    }\n+\n+    @Override\n+    protected int computeContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n+        int highAddr = 0; /* Length of this chunk in object file */\n+        for (FileBlock fileBlock : fileBlocks) {\n+            highAddr = Math.max(highAddr, fileBlock.getHighAddr());\n+            pos = fileBlock.computeContents(buffer, pos);\n+        }\n+        computeHeader(buffer, initialPos, highAddr);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVLineRecord(type=0x%04x pos=0x%05x size=0x%d)\", type, recordStartPosition, fileBlocks.size());\n+    }\n+\n+    /*\n+     * FileBlock is a section of contiguous code in a compilation unit, associated with a single\n+     * source file. If a function includes inlined code, that code needs its own FileBlock,\n+     * surrounded by FileBlocks describing the enclosing source file. A FileBlock consists of a list\n+     * of LineEntries.\n+     */\n+    private static class FileBlock {\n+\n+        /* Fileblock header: fileId (4 bytes) lineEntry count (4 bytes) tablesize (4 bytes) */\n+        static final int FILE_BLOCK_HEADER_SIZE = Integer.BYTES * 3;\n+\n+        ArrayList<LineEntry> lineEntries = new ArrayList<>(DEFAULT_LINE_ENTRY_COUNT);\n+        int highAddr = 0;\n+        int fileId;\n+\n+        FileBlock(int fileId) {\n+            this.fileId = fileId;\n+        }\n+\n+        void addEntry(LineEntry le) {\n+            highAddr = Math.max(highAddr, le.addr);\n+            lineEntries.add(le);\n+        }\n+\n+        int computeContents(byte[] buffer, int initialPos) {\n+            int pos = initialPos;\n+            pos = CVUtil.putInt(fileId, buffer, pos);\n+            pos = CVUtil.putInt(lineEntries.size(), buffer, pos);\n+            pos = CVUtil.putInt(computeSize(0), buffer, pos);\n+            for (LineEntry lineEntry : lineEntries) {\n+                pos = lineEntry.computeContents(buffer, pos);\n+            }\n+            return pos;\n+        }\n+\n+        int computeSize(int initialPos) {\n+            return initialPos + FILE_BLOCK_HEADER_SIZE + LineEntry.LINE_ENTRY_SIZE * lineEntries.size();\n+        }\n+\n+        int getHighAddr() {\n+            return highAddr;", "originalCommit": "63c089695709a51471b1a8771431e40da7773b08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzAwNTY0Ng==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r493005646", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-09-22T20:13:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDM4MzgxMw=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\nindex 794a466e142..090f30fe4ac 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n", "chunk": "@@ -151,7 +157,8 @@ final class CVLineRecord extends CVSymbolRecord {\n         }\n \n         int getHighAddr() {\n-            return highAddr;\n+            assert !lineEntries.isEmpty();\n+            return lineEntries.get(lineEntries.size() - 1).addr;\n         }\n     }\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNDUwMA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r490414500", "body": "I think you may have inadvertently changed `proclen` to `primaryEntry.getFrameSize()` here (i.e., shouldn't it be `primaryRange.getHi() - primaryRange.getLo()` as it was before).", "bodyText": "I think you may have inadvertently changed proclen to primaryEntry.getFrameSize() here (i.e., shouldn't it be primaryRange.getHi() - primaryRange.getLo() as it was before).", "bodyHTML": "<p dir=\"auto\">I think you may have inadvertently changed <code>proclen</code> to <code>primaryEntry.getFrameSize()</code> here (i.e., shouldn't it be <code>primaryRange.getHi() - primaryRange.getLo()</code> as it was before).</p>", "author": "pejovica", "createdAt": "2020-09-17T16:54:22Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_NOTYPE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_VOID;\n+\n+final class CVSymbolSubsectionBuilder {\n+\n+    private final CVDebugInfo cvDebugInfo;\n+    private final CVSymbolSubsection cvSymbolSubsection;\n+    private CVLineRecordBuilder lineRecordBuilder;\n+    private DebugContext debugContext = null;\n+\n+    private boolean noMainFound = true;\n+\n+    CVSymbolSubsectionBuilder(CVDebugInfo cvDebugInfo) {\n+        this.cvSymbolSubsection = new CVSymbolSubsection(cvDebugInfo);\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    /**\n+     * Build DEBUG_S_SYMBOLS record from all classEntries. (CodeView 4 format allows us to build one\n+     * per class or one per function or one big record - which is what we do here).\n+     *\n+     * The CodeView symbol section Prolog is also a CVSymbolSubsection, but it is not build in this\n+     * class.\n+     */\n+    void build(DebugContext theDebugContext) {\n+        this.debugContext = theDebugContext;\n+        this.lineRecordBuilder = new CVLineRecordBuilder(debugContext, cvDebugInfo);\n+        /* loop over all classes defined in this module. */\n+        for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+            build(classEntry);\n+        }\n+        cvDebugInfo.getCVSymbolSection().addRecord(cvSymbolSubsection);\n+    }\n+\n+    /**\n+     * Build all debug info for a classEntry. (does not yet handle member variables).\n+     *\n+     * @param classEntry current class\n+     */\n+    private void build(ClassEntry classEntry) {\n+        /* Loop over all functions defined in this class. */\n+        for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+            build(primaryEntry);\n+        }\n+    }\n+\n+    /**\n+     * Emit records for each function: PROC32 S_FRAMEPROC S_END and line number records. (later:\n+     * type records as required).\n+     *\n+     * @param primaryEntry primary entry for this function\n+     */\n+    private void build(PrimaryEntry primaryEntry) {\n+        final Range primaryRange = primaryEntry.getPrimary();\n+\n+        /* The name as it will appear in the debugger. */\n+        final String debuggerName = getDebuggerName(primaryRange);\n+\n+        /* The name as exposed to the linker. */\n+        final String externalName = primaryRange.getSymbolName();\n+\n+        /* S_PROC32 add function definition. */\n+        int functionTypeIndex = addTypeRecords(primaryEntry);\n+        byte funcFlags = 0;\n+        CVSymbolSubrecord.CVSymbolGProc32Record proc32 = new CVSymbolSubrecord.CVSymbolGProc32Record(cvDebugInfo, externalName, debuggerName, 0, 0, 0, primaryEntry.getFrameSize(), 0, 0,", "originalCommit": "63c089695709a51471b1a8771431e40da7773b08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk5NzEzMQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r492997131", "bodyText": "Done, thanks.", "author": "stooke", "createdAt": "2020-09-22T19:57:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNDUwMA=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\nindex 11f51e773f5..f0eac5086e0 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n", "chunk": "@@ -95,8 +95,8 @@ final class CVSymbolSubsectionBuilder {\n         /* S_PROC32 add function definition. */\n         int functionTypeIndex = addTypeRecords(primaryEntry);\n         byte funcFlags = 0;\n-        CVSymbolSubrecord.CVSymbolGProc32Record proc32 = new CVSymbolSubrecord.CVSymbolGProc32Record(cvDebugInfo, externalName, debuggerName, 0, 0, 0, primaryEntry.getFrameSize(), 0, 0,\n-                        functionTypeIndex, primaryRange.getLo(), (short) 0, funcFlags);\n+        CVSymbolSubrecord.CVSymbolGProc32Record proc32 = new CVSymbolSubrecord.CVSymbolGProc32Record(cvDebugInfo, externalName, debuggerName, 0, 0, 0, primaryRange.getHi() - primaryRange.getLo(), 0,\n+                        0, functionTypeIndex, primaryRange.getLo(), (short) 0, funcFlags);\n         addToSymbolSubsection(proc32);\n \n         /* S_FRAMEPROC add frame definitions. */\n", "next_change": {"commit": "4caf93deee510084247c88599752478fc53bd73d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\nindex f0eac5086e0..ec33be0b99f 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n", "chunk": "@@ -93,7 +88,7 @@ final class CVSymbolSubsectionBuilder {\n         final String externalName = primaryRange.getSymbolName();\n \n         /* S_PROC32 add function definition. */\n-        int functionTypeIndex = addTypeRecords(primaryEntry);\n+        int functionTypeIndex = addTypeRecords(compiledEntry);\n         byte funcFlags = 0;\n         CVSymbolSubrecord.CVSymbolGProc32Record proc32 = new CVSymbolSubrecord.CVSymbolGProc32Record(cvDebugInfo, externalName, debuggerName, 0, 0, 0, primaryRange.getHi() - primaryRange.getLo(), 0,\n                         0, functionTypeIndex, primaryRange.getLo(), (short) 0, funcFlags);\n", "next_change": {"commit": "77e3a7479e429a3279d3061496d260e35f21f000", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\nindex ec33be0b99f..dd2b8e972f8 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n", "chunk": "@@ -91,54 +130,28 @@ final class CVSymbolSubsectionBuilder {\n         int functionTypeIndex = addTypeRecords(compiledEntry);\n         byte funcFlags = 0;\n         CVSymbolSubrecord.CVSymbolGProc32Record proc32 = new CVSymbolSubrecord.CVSymbolGProc32Record(cvDebugInfo, externalName, debuggerName, 0, 0, 0, primaryRange.getHi() - primaryRange.getLo(), 0,\n-                        0, functionTypeIndex, primaryRange.getLo(), (short) 0, funcFlags);\n-        addToSymbolSubsection(proc32);\n+                        0, functionTypeIndex, (short) 0, funcFlags);\n+        addSymbolRecord(proc32);\n \n         /* S_FRAMEPROC add frame definitions. */\n         int asynceh = 1 << 9; /* Async exception handling (vc++ uses 1, clang uses 0). */\n+        /* TODO: This may change in the presence of isolates. */\n         int localBP = 1 << 14; /* Local base pointer = SP (0=none, 1=sp, 2=bp 3=r13). */\n         int paramBP = 1 << 16; /* Param base pointer = SP. */\n         int frameFlags = asynceh + localBP + paramBP; /* NB: LLVM uses 0x14000. */\n-        addToSymbolSubsection(new CVSymbolSubrecord.CVSymbolFrameProcRecord(cvDebugInfo, compiledEntry.getFrameSize(), frameFlags));\n+        addSymbolRecord(new CVSymbolSubrecord.CVSymbolFrameProcRecord(cvDebugInfo, compiledEntry.getFrameSize(), frameFlags));\n \n+        /* TODO: add parameter definitions (types have been added already). */\n         /* TODO: add local variables, and their types. */\n         /* TODO: add block definitions. */\n \n         /* S_END add end record. */\n-        addToSymbolSubsection(new CVSymbolSubrecord.CVSymbolEndRecord(cvDebugInfo));\n+        addSymbolRecord(new CVSymbolSubrecord.CVSymbolEndRecord(cvDebugInfo));\n \n         /* Add line number records. */\n         addLineNumberRecords(compiledEntry);\n     }\n \n-    /**\n-     * Rename function names for usability or functionality.\n-     *\n-     * First encountered main function becomes class.main. This is for usability.\n-     *\n-     * All other functions become class.function.999 (where 999 is a hash of the arglist). This is\n-     * because The standard link.exe can't handle odd characters (parentheses or commas, for\n-     * example) in debug information.\n-     *\n-     * This does not affect external symbols used by linker.\n-     *\n-     * TODO: strip illegal characters from arg lists instead (\"link.exe\" - safe names)\n-     *\n-     * @param range Range contained in the method of interest\n-     * @return user debugger friendly method name\n-     */\n-    private String getDebuggerName(Range range) {\n-        final String methodName;\n-        if (noMainFound && range.getMethodName().equals(\"main\")) {\n-            noMainFound = false;\n-            methodName = range.getFullMethodName();\n-        } else {\n-            /* In the future, use a more user-friendly name instead of a hash function. */\n-            methodName = range.getSymbolName();\n-        }\n-        return methodName;\n-    }\n-\n     private void addLineNumberRecords(CompiledMethodEntry compiledEntry) {\n         CVLineRecord record = lineRecordBuilder.build(compiledEntry);\n         /*\n", "next_change": null}]}}, {"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\nindex f0eac5086e0..ec33be0b99f 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n", "chunk": "@@ -104,7 +99,7 @@ final class CVSymbolSubsectionBuilder {\n         int localBP = 1 << 14; /* Local base pointer = SP (0=none, 1=sp, 2=bp 3=r13). */\n         int paramBP = 1 << 16; /* Param base pointer = SP. */\n         int frameFlags = asynceh + localBP + paramBP; /* NB: LLVM uses 0x14000. */\n-        addToSymbolSubsection(new CVSymbolSubrecord.CVSymbolFrameProcRecord(cvDebugInfo, primaryEntry.getFrameSize(), frameFlags));\n+        addToSymbolSubsection(new CVSymbolSubrecord.CVSymbolFrameProcRecord(cvDebugInfo, compiledEntry.getFrameSize(), frameFlags));\n \n         /* TODO: add local variables, and their types. */\n         /* TODO: add block definitions. */\n", "next_change": {"commit": "77e3a7479e429a3279d3061496d260e35f21f000", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\nindex ec33be0b99f..dd2b8e972f8 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java\n", "chunk": "@@ -91,54 +130,28 @@ final class CVSymbolSubsectionBuilder {\n         int functionTypeIndex = addTypeRecords(compiledEntry);\n         byte funcFlags = 0;\n         CVSymbolSubrecord.CVSymbolGProc32Record proc32 = new CVSymbolSubrecord.CVSymbolGProc32Record(cvDebugInfo, externalName, debuggerName, 0, 0, 0, primaryRange.getHi() - primaryRange.getLo(), 0,\n-                        0, functionTypeIndex, primaryRange.getLo(), (short) 0, funcFlags);\n-        addToSymbolSubsection(proc32);\n+                        0, functionTypeIndex, (short) 0, funcFlags);\n+        addSymbolRecord(proc32);\n \n         /* S_FRAMEPROC add frame definitions. */\n         int asynceh = 1 << 9; /* Async exception handling (vc++ uses 1, clang uses 0). */\n+        /* TODO: This may change in the presence of isolates. */\n         int localBP = 1 << 14; /* Local base pointer = SP (0=none, 1=sp, 2=bp 3=r13). */\n         int paramBP = 1 << 16; /* Param base pointer = SP. */\n         int frameFlags = asynceh + localBP + paramBP; /* NB: LLVM uses 0x14000. */\n-        addToSymbolSubsection(new CVSymbolSubrecord.CVSymbolFrameProcRecord(cvDebugInfo, compiledEntry.getFrameSize(), frameFlags));\n+        addSymbolRecord(new CVSymbolSubrecord.CVSymbolFrameProcRecord(cvDebugInfo, compiledEntry.getFrameSize(), frameFlags));\n \n+        /* TODO: add parameter definitions (types have been added already). */\n         /* TODO: add local variables, and their types. */\n         /* TODO: add block definitions. */\n \n         /* S_END add end record. */\n-        addToSymbolSubsection(new CVSymbolSubrecord.CVSymbolEndRecord(cvDebugInfo));\n+        addSymbolRecord(new CVSymbolSubrecord.CVSymbolEndRecord(cvDebugInfo));\n \n         /* Add line number records. */\n         addLineNumberRecords(compiledEntry);\n     }\n \n-    /**\n-     * Rename function names for usability or functionality.\n-     *\n-     * First encountered main function becomes class.main. This is for usability.\n-     *\n-     * All other functions become class.function.999 (where 999 is a hash of the arglist). This is\n-     * because The standard link.exe can't handle odd characters (parentheses or commas, for\n-     * example) in debug information.\n-     *\n-     * This does not affect external symbols used by linker.\n-     *\n-     * TODO: strip illegal characters from arg lists instead (\"link.exe\" - safe names)\n-     *\n-     * @param range Range contained in the method of interest\n-     * @return user debugger friendly method name\n-     */\n-    private String getDebuggerName(Range range) {\n-        final String methodName;\n-        if (noMainFound && range.getMethodName().equals(\"main\")) {\n-            noMainFound = false;\n-            methodName = range.getFullMethodName();\n-        } else {\n-            /* In the future, use a more user-friendly name instead of a hash function. */\n-            methodName = range.getSymbolName();\n-        }\n-        return methodName;\n-    }\n-\n     private void addLineNumberRecords(CompiledMethodEntry compiledEntry) {\n         CVLineRecord record = lineRecordBuilder.build(compiledEntry);\n         /*\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM4NDkyNA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r502384924", "body": "This comment should be updated.", "bodyText": "This comment should be updated.", "bodyHTML": "<p dir=\"auto\">This comment should be updated.</p>", "author": "pejovica", "createdAt": "2020-10-09T12:13:57Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/*\n+ * A CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file.\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    final int computeFullContents(byte[] buffer, int initialPos) {\n+        subrecordStartPosition = initialPos;\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* Save room for length (not including length bytes). */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(pos=0x%06x cmd=0x%04x)\", subrecordStartPosition, cmd);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* find the full path to object file we will produce. */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Infer object filename from first class definition. */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* Signature is currently set to 0. */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"S_OBJNAME \" + objName;\n+        }\n+    }\n+\n+    public static final class CVCompile3Record extends CVSymbolSubrecord {\n+\n+        private static final byte HAS_DEBUG_FLAG = 0;\n+        @SuppressWarnings(\"unused\") private static final byte HAS_NO_DEBUG_FLAG = (byte) 0x80;\n+\n+        private byte language;\n+        private byte cf1;\n+        private byte cf2;\n+        private byte padding;\n+        private short machine;\n+        private short feMajor;\n+        private short feMinor;\n+        private short feBuild;\n+        private short feQFE;\n+        private short beMajor;\n+        private short beMinor;\n+        private short beBuild;\n+        private short beQFE;\n+        private String compiler;\n+\n+        CVCompile3Record(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_COMPILE3);\n+            language = 0;\n+            cf1 = HAS_DEBUG_FLAG;\n+            cf2 = (byte) 0;\n+            padding = (byte) 0;\n+            machine = (short) 208;\n+            feMajor = (short) 2;\n+            feMinor = (short) 3;\n+            feBuild = (short) 4;\n+            feQFE = (short) 5;\n+            beMajor = (short) 6;\n+            beMinor = (short) 7;\n+            beBuild = (short) 8;\n+            beQFE = (short) 9;\n+            compiler = \"graal\";\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putByte(language, buffer, initialPos);\n+            pos = CVUtil.putByte(cf1, buffer, pos);\n+            pos = CVUtil.putByte(cf2, buffer, pos);\n+            pos = CVUtil.putByte(padding, buffer, pos);\n+            pos = CVUtil.putShort(machine, buffer, pos);\n+            pos = CVUtil.putShort(feMajor, buffer, pos);\n+            pos = CVUtil.putShort(feMinor, buffer, pos);\n+            pos = CVUtil.putShort(feBuild, buffer, pos);\n+            pos = CVUtil.putShort(feQFE, buffer, pos);\n+            pos = CVUtil.putShort(beMajor, buffer, pos);\n+            pos = CVUtil.putShort(beMinor, buffer, pos);\n+            pos = CVUtil.putShort(beBuild, buffer, pos);\n+            pos = CVUtil.putShort(beQFE, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(compiler, buffer, pos);  // inline null terminated\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_COMPILE3 machine=%d fe=%d.%d.%d.%d be=%d.%d.%d%d compiler=%s\", machine, feMajor, feMinor, feBuild, feQFE, beMajor, beMinor, beBuild, beQFE, compiler);\n+        }\n+    }\n+\n+    public static final class CVEnvBlockRecord extends CVSymbolSubrecord {\n+\n+        private static final int ENVMAP_INITIAL_CAPACITY = 10;\n+\n+        private Map<String, String> map = new HashMap<>(ENVMAP_INITIAL_CAPACITY);\n+\n+        /*-\n+         * Example contents of the environment block:\n+         *   cwd = C:\\tmp\\graal-8\n+         *   cl = C:\\tmp\\graal-8\\ojdkbuild\\tools\\toolchain\\vs2010e\\VC\\Bin\\x86_amd64\\cl.exe\n+         *   cmd = -Zi -MT -IC:\\tmp\\graal-8\\tools\\toolchain\\vs2010e\\VC\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE\\gl -TC -X\n+         *   src = helloworld.java\n+         *   pdb = C:\\tmp\\graal-8\\vc100.pdb\n+         */\n+        CVEnvBlockRecord(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_ENVBLOCK);\n+\n+            /* Current directory. */\n+            map.put(\"cwd\", System.getProperty(\"user.dir\"));\n+\n+            /*\n+             * Define the primary source file - ideally, the source file containing main(). (Note\n+             * that if Graal were to be used to compile a library, there may not be a main()). Since\n+             * Graal doesn't work with java source files, use the source file associated with the\n+             * first class that has a source file.\n+             */\n+            String fn = findFirstFile(cvDebugInfo);\n+            if (fn != null) {\n+                map.put(\"src\", fn);\n+            }\n+        }\n+\n+        private static String findFirstFile(CVDebugInfo cvDebugInfo) {\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            /* Flags. */\n+            int pos = CVUtil.putByte((byte) 0, buffer, initialPos);\n+\n+            /* Key/value pairs. */\n+            for (Map.Entry<String, String> entry : map.entrySet()) {\n+                pos = CVUtil.putUTF8StringBytes(entry.getKey(), buffer, pos);\n+                pos = CVUtil.putUTF8StringBytes(entry.getValue(), buffer, pos);\n+            }\n+\n+            /* End marker. */\n+            pos = CVUtil.putUTF8StringBytes(\"\", buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"S_ENVBLOCK \" + map.size() + \" entries\";\n+        }\n+    }\n+\n+    /*\n+     * Creating a proc32 record has side effects: a global symbol is added to the COFF symbol\n+     * section, and two relocation entries are added to the section relocation table, they refer\n+     * back to the global symbol.\n+     */", "originalCommit": "ab2c9a00f48883b83383fd411956082da9f0ac28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzkyNTU1NA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r503925554", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-10-13T12:53:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM4NDkyNA=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex 3aac0dc0800..ddb43d1039c 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -247,9 +247,8 @@ abstract class CVSymbolSubrecord {\n     }\n \n     /*\n-     * Creating a proc32 record has side effects: a global symbol is added to the COFF symbol\n-     * section, and two relocation entries are added to the section relocation table, they refer\n-     * back to the global symbol.\n+     * Creating a proc32 record has a side effect: two relocation entries are added to the section\n+     * relocation table; they refer back to the global symbol.\n      */\n     public static class CVSymbolGProc32Record extends CVSymbolSubrecord {\n \n", "next_change": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex ddb43d1039c..0a30db69e94 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -252,24 +251,24 @@ abstract class CVSymbolSubrecord {\n      */\n     public static class CVSymbolGProc32Record extends CVSymbolSubrecord {\n \n-        int pparent;\n-        int pend;\n-        int pnext;\n-        int proclen;\n-        int debugStart;\n-        int debugEnd;\n-        int typeIndex;\n-        int offset;\n-        short segment;\n-        byte flags;\n-        String externalName;\n-        String debuggerName;\n-\n-        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, short cmd, String externalName, String debuggerName, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex,\n+        private final int pparent;\n+        private final int pend;\n+        private final int pnext;\n+        private final int proclen;\n+        private final int debugStart;\n+        private final int debugEnd;\n+        private final int typeIndex;\n+        private final int offset;\n+        private final short segment;\n+        private final byte flags;\n+        private final String symbolName;\n+        private final String displayName;\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, short cmd, String symbolName, String displayName, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex,\n                         int offset, short segment, byte flags) {\n             super(cvDebugInfo, cmd);\n-            this.externalName = externalName;\n-            this.debuggerName = debuggerName;\n+            this.symbolName = symbolName;\n+            this.displayName = displayName;\n             this.pparent = pparent;\n             this.pend = pend;\n             this.pnext = pnext;\n", "next_change": {"commit": "77e3a7479e429a3279d3061496d260e35f21f000", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex 0a30db69e94..29d819c743f 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -258,15 +344,14 @@ abstract class CVSymbolSubrecord {\n         private final int debugStart;\n         private final int debugEnd;\n         private final int typeIndex;\n-        private final int offset;\n         private final short segment;\n         private final byte flags;\n         private final String symbolName;\n         private final String displayName;\n \n-        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, short cmd, String symbolName, String displayName, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex,\n-                        int offset, short segment, byte flags) {\n-            super(cvDebugInfo, cmd);\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, String symbolName, String displayName, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex,\n+                        short segment, byte flags) {\n+            super(cvDebugInfo, CVDebugConstants.S_GPROC32);\n             this.symbolName = symbolName;\n             this.displayName = displayName;\n             this.pparent = pparent;\n", "next_change": null}, {"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\nindex 0a30db69e94..29d819c743f 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java\n", "chunk": "@@ -276,16 +361,10 @@ abstract class CVSymbolSubrecord {\n             this.debugStart = debugStart;\n             this.debugEnd = debugEnd;\n             this.typeIndex = typeIndex;\n-            this.offset = offset;\n             this.segment = segment;\n             this.flags = flags;\n         }\n \n-        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, String symbolName, String displayName, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset,\n-                        short segment, byte flags) {\n-            this(cvDebugInfo, CVDebugConstants.S_GPROC32, symbolName, displayName, pparent, pend, pnext, proclen, debugStart, debugEnd, typeIndex, offset, segment, flags);\n-        }\n-\n         @Override\n         protected int computeContents(byte[] buffer, int initialPos) {\n             int pos = CVUtil.putInt(pparent, buffer, initialPos);\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ5MjI0Mw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r502492243", "body": "I don't think this is correct. What prevents two records of different types from having the same hash code?", "bodyText": "I don't think this is correct. What prevents two records of different types from having the same hash code?", "bodyHTML": "<p dir=\"auto\">I don't think this is correct. What prevents two records of different types from having the same hash code?</p>", "author": "pejovica", "createdAt": "2020-10-09T15:02:23Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SIGNATURE_C13;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SYMBOL_SECTION_NAME;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_TYPE_SECTION_NAME;\n+\n+public final class CVTypeSectionImpl extends CVSectionImpl {\n+\n+    private static final int CV_RECORD_INITIAL_CAPACITY = 200;\n+\n+    private int sequenceCounter = 0x1000;\n+    private ArrayList<CVTypeRecord> cvRecords = new ArrayList<>(CV_RECORD_INITIAL_CAPACITY);\n+    private Map<Integer, CVTypeRecord> typeMap = new HashMap<>();\n+\n+    CVTypeSectionImpl() {\n+    }\n+\n+    @Override\n+    public String getSectionName() {\n+        return CV_TYPE_SECTION_NAME;\n+    }\n+\n+    @Override\n+    public void createContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext);\n+        log(debugContext, \"CVTypeSectionImpl.createContent() adding records\");\n+        addRecords();\n+        log(debugContext, \"CVTypeSectionImpl.createContent() start\");\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, null, pos);\n+        for (CVTypeRecord record : cvRecords) {\n+            pos = record.computeFullSize(pos);\n+        }\n+        byte[] buffer = new byte[pos];\n+        super.setContent(buffer);\n+        log(debugContext, \"CVTypeSectionImpl.createContent() end\");\n+    }\n+\n+    @Override\n+    public void writeContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext);\n+        log(debugContext, \"CVTypeSectionImpl.writeContent() start\");\n+        byte[] buffer = getContent();\n+        verboseLog(debugContext, \"  [0x%08x] CV_SIGNATURE_C13\", pos);\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, buffer, pos);\n+        for (CVTypeRecord record : cvRecords) {\n+            verboseLog(debugContext, \"  [0x%08x] 0x%06x %s\", pos, record.getSequenceNumber(), record.toString());\n+            pos = record.computeFullContents(buffer, pos);\n+        }\n+        verboseLog(debugContext, \"CVTypeSectionImpl.writeContent() end\");\n+    }\n+\n+    /**\n+     * Add all relevant type records to the type section.\n+     */\n+    private void addRecords() {\n+        /* if an external PDB file is generated, add CVTypeServer2Record */\n+        /* for each class, add all members, types, etc */\n+    }\n+\n+    /**\n+     * Add a record to the type section if it has a unique hash.\n+     *\n+     * @param <T> type of new record.\n+     * @param newRecord record to add\n+     * @return newRecord if the hash is unique, or the existing record already in the type table\n+     */\n+    <T extends CVTypeRecord> T addRecord(T newRecord) {\n+        return addOrReference(newRecord);\n+    }\n+\n+    /**\n+     * Add a record (that has a unique hashcode) to the type section.\n+     *\n+     * @param r the record to add\n+     */\n+    private void addUniqueRecord(CVTypeRecord r) {\n+        cvRecords.add(r);\n+    }\n+\n+    /**\n+     * Return either the caller-created instance or a matching existing instance. Every entry in\n+     * typeMap is a T, because it is ONLY this function which inserts entries (of type T).\n+     *\n+     * @param <T> type of new record\n+     * @param newRecord record to add if an existing record with same hash hasn't already been added\n+     * @return the record (if previously unseen) or old record\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private <T extends CVTypeRecord> T addOrReference(T newRecord) {\n+        final T record;\n+        final int hashCode = newRecord.hashCode();\n+        if (typeMap.containsKey(hashCode)) {\n+            record = (T) typeMap.get(hashCode);", "originalCommit": "ab2c9a00f48883b83383fd411956082da9f0ac28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk4MjAyMg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r503982022", "bodyText": "I was holding this change off until the type information has been added in a follow-up PR.  Currently there are only two type records, (an empty arglist record and a \"void proc()\" record), so it makes no difference.\nI have added full equals() implementation to avoid this situation.  Note that my design must allow for two type records to differ in type index but still be considered the same.", "author": "stooke", "createdAt": "2020-10-13T14:07:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ5MjI0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\nindex 4b5e25ef42f..ac22c2be305 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\n", "chunk": "@@ -126,15 +107,13 @@ public final class CVTypeSectionImpl extends CVSectionImpl {\n      * @return the record (if previously unseen) or old record\n      */\n     @SuppressWarnings(\"unchecked\")\n-    private <T extends CVTypeRecord> T addOrReference(T newRecord) {\n+    public <T extends CVTypeRecord> T addOrReference(T newRecord) {\n         final T record;\n-        final int hashCode = newRecord.hashCode();\n-        if (typeMap.containsKey(hashCode)) {\n-            record = (T) typeMap.get(hashCode);\n+        if (typeMap.containsKey(newRecord)) {\n+            record = (T) typeMap.get(newRecord);\n         } else {\n             newRecord.setSequenceNumber(sequenceCounter++);\n-            typeMap.put(hashCode, newRecord);\n-            addUniqueRecord(newRecord);\n+            typeMap.put(newRecord, newRecord);\n             record = newRecord;\n         }\n         return record;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU5MTIxNw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r502591217", "body": "This can be moved into `computeHeader`, i.e., it's no longer necessary to pass `highAddr` as an argument.\r\n\r\nAlso, you could change `computeHeader` to return `pos` and move the call to the beginning of this method.", "bodyText": "This can be moved into computeHeader, i.e., it's no longer necessary to pass highAddr as an argument.\nAlso, you could change computeHeader to return pos and move the call to the beginning of this method.", "bodyHTML": "<p dir=\"auto\">This can be moved into <code>computeHeader</code>, i.e., it's no longer necessary to pass <code>highAddr</code> as an argument.</p>\n<p dir=\"auto\">Also, you could change <code>computeHeader</code> to return <code>pos</code> and move the call to the beginning of this method.</p>", "author": "pejovica", "createdAt": "2020-10-09T18:01:42Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.ObjectFile;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A line record (DEBUG_S_LINES) consists of a list of (file block record + subrecords).\n+ * Graal will generate one CVLineRecord per function.\n+ */\n+final class CVLineRecord extends CVSymbolRecord {\n+\n+    /* Header: addr (4 bytes):section (2 bytes) flags (2 bytes) chunck length (4 bytes). */\n+    private static final int LINE_RECORD_HEADER_SIZE = Integer.BYTES + Short.BYTES * 2 + Integer.BYTES;\n+\n+    private static final int DEFAULT_LINE_BLOCK_COUNT = 100;\n+    private static final int DEFAULT_LINE_ENTRY_COUNT = 100;\n+\n+    /* has colummns flag = 0x80 - not supported */\n+    private static final short CB_HAS_NO_COLUMNS_FLAG = 0x00;\n+\n+    private String symbolName;\n+    private ArrayList<FileBlock> fileBlocks = new ArrayList<>(DEFAULT_LINE_BLOCK_COUNT);\n+\n+    CVLineRecord(CVDebugInfo cvDebugInfo, String symbolName) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_LINES);\n+        this.symbolName = symbolName;\n+    }\n+\n+    void addNewFile(FileEntry file) {\n+        CVFileTableRecord fr = cvDebugInfo.getCVSymbolSection().getFileTableRecord();\n+        int fileId = fr.addFile(file);\n+        fileBlocks.add(new FileBlock(fileId));\n+    }\n+\n+    void addNewLine(int addr, int line) {\n+        fileBlocks.get(fileBlocks.size() - 1).addEntry(new LineEntry(addr, line));\n+    }\n+\n+    @Override\n+    protected int computeSize(int initialPos) {\n+        /* Line record header. */\n+        int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n+        /* All blocks. */\n+        for (FileBlock fileBlock : fileBlocks) {\n+            pos = fileBlock.computeSize(pos);\n+        }\n+        return pos;\n+    }\n+\n+    private void computeHeader(byte[] buffer, int initialPos, int length) {\n+\n+        assert symbolName != null;\n+        int pos = initialPos;\n+\n+        if (buffer != null) {\n+            cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, symbolName, false, 1L);\n+        }\n+        pos = CVUtil.putInt(0, buffer, pos);\n+\n+        if (buffer != null) {\n+            cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, symbolName, false, 1L);\n+        }\n+        pos = CVUtil.putShort((short) 0, buffer, pos);\n+\n+        pos = CVUtil.putShort(CB_HAS_NO_COLUMNS_FLAG, buffer, pos); /* flags */\n+        CVUtil.putInt(length, buffer, pos);\n+    }\n+\n+    boolean isEmpty() {\n+        return fileBlocks.isEmpty();\n+    }\n+\n+    @Override\n+    protected int computeContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n+        for (FileBlock fileBlock : fileBlocks) {\n+            pos = fileBlock.computeContents(buffer, pos);\n+        }\n+        /* Length of this chunk in object file (= highAddr since it's zero based. */\n+        int highAddr = fileBlocks.isEmpty() ? 0 : fileBlocks.get(fileBlocks.size() - 1).getHighAddr();", "originalCommit": "ab2c9a00f48883b83383fd411956082da9f0ac28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA1MDUzMQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r504050531", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-10-13T15:31:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU5MTIxNw=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\nindex 90a52788946..090f30fe4ac 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n", "chunk": "@@ -64,52 +61,56 @@ final class CVLineRecord extends CVSymbolRecord {\n         fileBlocks.get(fileBlocks.size() - 1).addEntry(new LineEntry(addr, line));\n     }\n \n+    int getCurrentFileId() {\n+        assert !fileBlocks.isEmpty();\n+        return fileBlocks.get(fileBlocks.size() - 1).fileId;\n+    }\n+\n     @Override\n     protected int computeSize(int initialPos) {\n+        return computeContents(null, initialPos);\n+    }\n+\n+    @Override\n+    protected int computeContents(byte[] buffer, int initialPos) {\n         /* Line record header. */\n-        int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n+        int pos = computeHeader(buffer, initialPos);\n         /* All blocks. */\n         for (FileBlock fileBlock : fileBlocks) {\n-            pos = fileBlock.computeSize(pos);\n+            pos = fileBlock.computeContents(buffer, pos);\n         }\n         return pos;\n     }\n \n-    private void computeHeader(byte[] buffer, int initialPos, int length) {\n+    private int computeHeader(byte[] buffer, int initialPos) {\n+\n+        if (buffer == null) {\n+            return initialPos + LINE_RECORD_HEADER_SIZE;\n+        }\n \n         assert symbolName != null;\n         int pos = initialPos;\n \n-        if (buffer != null) {\n-            cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, symbolName, false, 1L);\n-        }\n+        /* Emit addr:section relocation records. */\n+        cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, symbolName, false, 1L);\n         pos = CVUtil.putInt(0, buffer, pos);\n-\n-        if (buffer != null) {\n-            cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, symbolName, false, 1L);\n-        }\n+        cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, symbolName, false, 1L);\n         pos = CVUtil.putShort((short) 0, buffer, pos);\n \n-        pos = CVUtil.putShort(CB_HAS_NO_COLUMNS_FLAG, buffer, pos); /* flags */\n-        CVUtil.putInt(length, buffer, pos);\n+        /* Emit flags. */\n+        pos = CVUtil.putShort(CB_HAS_NO_COLUMNS_FLAG, buffer, pos);\n+\n+        /* Length of this chunk in object file (= highAddr since it's zero based. */\n+        assert !fileBlocks.isEmpty();\n+        int length = fileBlocks.get(fileBlocks.size() - 1).getHighAddr();\n+        pos = CVUtil.putInt(length, buffer, pos);\n+        return pos;\n     }\n \n     boolean isEmpty() {\n         return fileBlocks.isEmpty();\n     }\n \n-    @Override\n-    protected int computeContents(byte[] buffer, int initialPos) {\n-        int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n-        for (FileBlock fileBlock : fileBlocks) {\n-            pos = fileBlock.computeContents(buffer, pos);\n-        }\n-        /* Length of this chunk in object file (= highAddr since it's zero based. */\n-        int highAddr = fileBlocks.isEmpty() ? 0 : fileBlocks.get(fileBlocks.size() - 1).getHighAddr();\n-        computeHeader(buffer, initialPos, highAddr);\n-        return pos;\n-    }\n-\n     @Override\n     public String toString() {\n         return String.format(\"CVLineRecord(type=0x%04x pos=0x%05x size=0x%d)\", type, recordStartPosition, fileBlocks.size());\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjYxODM2OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r502618368", "body": "I'd change this check to an assertion, e.g.:\r\n```java\r\nassert !s.contains(\"\\0\");\r\n```\r\nPlus, then you could simply delegate to `putBytes`.", "bodyText": "I'd change this check to an assertion, e.g.:\nassert !s.contains(\"\\0\");\nPlus, then you could simply delegate to putBytes.", "bodyHTML": "<p dir=\"auto\">I'd change this check to an assertion, e.g.:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"assert !s.contains(&quot;\\0&quot;);\"><pre><span class=\"pl-k\">assert</span> <span class=\"pl-k\">!</span>s<span class=\"pl-k\">.</span>contains(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"pl-cce\">\\0</span><span class=\"pl-pds\">\"</span></span>);</pre></div>\n<p dir=\"auto\">Plus, then you could simply delegate to <code>putBytes</code>.</p>", "author": "pejovica", "createdAt": "2020-10-09T18:58:15Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.io.Utf8;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+abstract class CVUtil {\n+\n+    static int putByte(byte b, byte[] buffer, int initialPos) {\n+        if (buffer == null) {\n+            return initialPos + Byte.BYTES;\n+        }\n+        int pos = initialPos;\n+        buffer[pos++] = b;\n+        return pos;\n+    }\n+\n+    static int putShort(short s, byte[] buffer, int initialPos) {\n+        if (buffer == null) {\n+            return initialPos + Short.BYTES;\n+        }\n+        int pos = initialPos;\n+        buffer[pos++] = (byte) (s & 0xff);\n+        buffer[pos++] = (byte) ((s >> 8) & 0xff);\n+        return pos;\n+    }\n+\n+    static int putInt(int i, byte[] buffer, int initialPos) {\n+        if (buffer == null) {\n+            return initialPos + Integer.BYTES;\n+        }\n+        int pos = initialPos;\n+        buffer[pos++] = (byte) (i & 0xff);\n+        buffer[pos++] = (byte) ((i >> 8) & 0xff);\n+        buffer[pos++] = (byte) ((i >> 16) & 0xff);\n+        buffer[pos++] = (byte) ((i >> 24) & 0xff);\n+        return pos;\n+    }\n+\n+    @SuppressWarnings(\"unused\")\n+    static int putLong(long l, byte[] buffer, int initialPos) {\n+        if (buffer == null) {\n+            return initialPos + Long.BYTES;\n+        }\n+        int pos = initialPos;\n+        buffer[pos++] = (byte) (l & 0xff);\n+        buffer[pos++] = (byte) ((l >> 8) & 0xff);\n+        buffer[pos++] = (byte) ((l >> 16) & 0xff);\n+        buffer[pos++] = (byte) ((l >> 24) & 0xff);\n+        buffer[pos++] = (byte) ((l >> 32) & 0xff);\n+        buffer[pos++] = (byte) ((l >> 40) & 0xff);\n+        buffer[pos++] = (byte) ((l >> 48) & 0xff);\n+        buffer[pos++] = (byte) ((l >> 56) & 0xff);\n+        return pos;\n+    }\n+\n+    static int putBytes(byte[] inbuff, byte[] buffer, int initialPos) {\n+        if (buffer == null) {\n+            return initialPos + inbuff.length;\n+        }\n+        int pos = initialPos;\n+        for (byte b : inbuff) {\n+            buffer[pos++] = b;\n+        }\n+        return pos;\n+    }\n+\n+    static int putUTF8StringBytes(String s, byte[] buffer, int initialPos) {\n+        if (buffer == null) {\n+            return initialPos + Utf8.utf8Length(s) + 1;\n+        }\n+        byte[] buff = s.getBytes(UTF_8);\n+        int pos = initialPos;\n+        for (byte b : buff) {\n+            if (b == 0) {\n+                throw new RuntimeException(\"oops : string has internal NULL character! \" + s);\n+            }", "originalCommit": "ab2c9a00f48883b83383fd411956082da9f0ac28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzkzMzAzNA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r503933034", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-10-13T13:04:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjYxODM2OA=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java\nindex 23c37dd3a06..d825143c67d 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java\n", "chunk": "@@ -92,17 +92,12 @@ abstract class CVUtil {\n     }\n \n     static int putUTF8StringBytes(String s, byte[] buffer, int initialPos) {\n+        assert !s.contains(\"\\0\");\n         if (buffer == null) {\n             return initialPos + Utf8.utf8Length(s) + 1;\n         }\n         byte[] buff = s.getBytes(UTF_8);\n-        int pos = initialPos;\n-        for (byte b : buff) {\n-            if (b == 0) {\n-                throw new RuntimeException(\"oops : string has internal NULL character! \" + s);\n-            }\n-            buffer[pos++] = b;\n-        }\n+        int pos = putBytes(buff, buffer, initialPos);\n         buffer[pos++] = '\\0';\n         return pos;\n     }\n", "next_change": {"commit": "77e3a7479e429a3279d3061496d260e35f21f000", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java\nindex d825143c67d..8cec084ccc1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java\n", "chunk": "@@ -102,6 +140,38 @@ abstract class CVUtil {\n         return pos;\n     }\n \n+    /**\n+     * Some CodeView numeric fields can be variable length, depending on the value.\n+     *\n+     * @param value value to store\n+     * @param buffer buffer to store value in\n+     * @param initialPos initial position in buffer\n+     * @return position in buffer following stored value\n+     */\n+    static int putLfNumeric(long value, byte[] buffer, int initialPos) {\n+        if (0 <= value && value < 0x8000) {\n+            return putShort((short) value, buffer, initialPos);\n+        } else if (Byte.MIN_VALUE <= value && value <= Byte.MAX_VALUE) {\n+            int pos = putShort(LF_CHAR, buffer, initialPos);\n+            return putByte((byte) value, buffer, pos);\n+        } else if (Short.MIN_VALUE <= value && value <= Short.MAX_VALUE) {\n+            int pos = putShort(LF_SHORT, buffer, initialPos);\n+            return putShort((short) value, buffer, pos);\n+        } else if (0 <= value && value <= 0xffff) {\n+            int pos = putShort(LF_USHORT, buffer, initialPos);\n+            return putShort((short) value, buffer, pos);\n+        } else if (Integer.MIN_VALUE <= value && value <= Integer.MAX_VALUE) {\n+            int pos = putShort(LF_LONG, buffer, initialPos);\n+            return putInt((int) value, buffer, pos);\n+        } else if (0 <= value && value <= 0xffffffffL) {\n+            int pos = putShort(LF_ULONG, buffer, initialPos);\n+            return putInt((int) value, buffer, pos);\n+        } else {\n+            int pos = putShort(LF_QUADWORD, buffer, initialPos);\n+            return putLong(value, buffer, pos);\n+        }\n+    }\n+\n     /**\n      * Align on 4 byte boundary.\n      *\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc4MDgzMg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r502780832", "body": "In case you apply the changes from the following comment, I'd remove this check in favor of the one in `processRange`.", "bodyText": "In case you apply the changes from the following comment, I'd remove this check in favor of the one in processRange.", "bodyHTML": "<p dir=\"auto\">In case you apply the changes from the following comment, I'd remove this check in favor of the one in <code>processRange</code>.</p>", "author": "pejovica", "createdAt": "2020-10-10T11:33:46Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+\n+/*\n+ * In CV4, the line table consists of a series of file headers followed by line number entries.\n+ * If this is a different file, then update the length of the previous file header, write the\n+ * new file header and write the new range At the very end, make sure we update the last file header.\n+ */\n+public class CVLineRecordBuilder {\n+\n+    private CVDebugInfo cvDebugInfo;\n+    private DebugContext debugContext;\n+    private CVLineRecord lineRecord;\n+    private PrimaryEntry primaryEntry;\n+\n+    CVLineRecordBuilder(DebugContext theDebugContext, CVDebugInfo cvDebugInfo) {\n+        this.debugContext = theDebugContext;\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    public void debug(String format, Object... args) {\n+        cvDebugInfo.getCVSymbolSection().verboseLog(debugContext, format, args);\n+    }\n+\n+    /**\n+     * Build line number records for a function.\n+     *\n+     * @param entry function to build line number table for\n+     * @return CVLineRecord containing any entries generated, or null if no entries generated\n+     */\n+    CVLineRecord build(PrimaryEntry entry) {\n+        this.primaryEntry = entry;\n+        Range primaryRange = primaryEntry.getPrimary();\n+\n+        debug(\"DEBUG_S_LINES linerecord for 0x%05x file: %s:%d\\n\", primaryRange.getLo(), primaryRange.getFileName(), primaryRange.getLine());\n+        this.lineRecord = new CVLineRecord(cvDebugInfo, primaryRange.getSymbolName());\n+        debug(\"CVLineRecord.computeContents: processing primary range %s\\n\", primaryRange);\n+        Range previousRange = processRange(primaryRange, null);\n+\n+        for (Range subRange : primaryEntry.getSubranges()) {\n+            debug(\"CVLineRecord.computeContents: processing range %s\\n\", subRange);\n+            FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subRange);\n+            if (subFileEntry == null) {\n+                continue;\n+            }", "originalCommit": "ab2c9a00f48883b83383fd411956082da9f0ac28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk0MzA0MQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r503943041", "bodyText": "Done and done.", "author": "stooke", "createdAt": "2020-10-13T13:18:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc4MDgzMg=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\nindex a7488f99995..1156522fb8e 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n", "chunk": "@@ -65,15 +65,11 @@ public class CVLineRecordBuilder {\n         debug(\"DEBUG_S_LINES linerecord for 0x%05x file: %s:%d\\n\", primaryRange.getLo(), primaryRange.getFileName(), primaryRange.getLine());\n         this.lineRecord = new CVLineRecord(cvDebugInfo, primaryRange.getSymbolName());\n         debug(\"CVLineRecord.computeContents: processing primary range %s\\n\", primaryRange);\n-        Range previousRange = processRange(primaryRange, null);\n \n+        processRange(primaryRange);\n         for (Range subRange : primaryEntry.getSubranges()) {\n             debug(\"CVLineRecord.computeContents: processing range %s\\n\", subRange);\n-            FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subRange);\n-            if (subFileEntry == null) {\n-                continue;\n-            }\n-            previousRange = processRange(subRange, previousRange);\n+            processRange(subRange);\n         }\n         return lineRecord;\n     }\n", "next_change": {"commit": "268c33256b26217c50339f452adea942fb48818f", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\nindex 1156522fb8e..37daba6cda7 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n", "chunk": "@@ -67,7 +69,9 @@ public class CVLineRecordBuilder {\n         debug(\"CVLineRecord.computeContents: processing primary range %s\\n\", primaryRange);\n \n         processRange(primaryRange);\n-        for (Range subRange : primaryEntry.getSubranges()) {\n+        Iterator<Range> iterator = primaryEntry.leafRangeIterator();\n+        while (iterator.hasNext()) {\n+            Range subRange = iterator.next();\n             debug(\"CVLineRecord.computeContents: processing range %s\\n\", subRange);\n             processRange(subRange);\n         }\n", "next_change": {"commit": "6d209109480ecec08ebf137288371d4c56064ba0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\nindex 37daba6cda7..2e83cf343d2 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n", "chunk": "@@ -64,15 +61,15 @@ public class CVLineRecordBuilder {\n         this.primaryEntry = entry;\n         Range primaryRange = primaryEntry.getPrimary();\n \n-        debug(\"DEBUG_S_LINES linerecord for 0x%05x file: %s:%d\\n\", primaryRange.getLo(), primaryRange.getFileName(), primaryRange.getLine());\n+        debug(\"DEBUG_S_LINES linerecord for 0x%05x file: %s:%d\", primaryRange.getLo(), primaryRange.getFileName(), primaryRange.getLine());\n         this.lineRecord = new CVLineRecord(cvDebugInfo, primaryRange.getSymbolName());\n-        debug(\"CVLineRecord.computeContents: processing primary range %s\\n\", primaryRange);\n+        debug(\"CVLineRecord.computeContents: processing primary range %s\", primaryRange);\n \n         processRange(primaryRange);\n         Iterator<Range> iterator = primaryEntry.leafRangeIterator();\n         while (iterator.hasNext()) {\n             Range subRange = iterator.next();\n-            debug(\"CVLineRecord.computeContents: processing range %s\\n\", subRange);\n+            debug(\"CVLineRecord.computeContents: processing range %s\", subRange);\n             processRange(subRange);\n         }\n         return lineRecord;\n", "next_change": {"commit": "4caf93deee510084247c88599752478fc53bd73d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\nindex 2e83cf343d2..34598cf5e9f 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n", "chunk": "@@ -57,16 +57,16 @@ public class CVLineRecordBuilder {\n      * @param entry function to build line number table for\n      * @return CVLineRecord containing any entries generated, or null if no entries generated\n      */\n-    CVLineRecord build(PrimaryEntry entry) {\n-        this.primaryEntry = entry;\n-        Range primaryRange = primaryEntry.getPrimary();\n+    CVLineRecord build(CompiledMethodEntry entry) {\n+        this.compiledEntry = entry;\n+        Range primaryRange = compiledEntry.getPrimary();\n \n         debug(\"DEBUG_S_LINES linerecord for 0x%05x file: %s:%d\", primaryRange.getLo(), primaryRange.getFileName(), primaryRange.getLine());\n         this.lineRecord = new CVLineRecord(cvDebugInfo, primaryRange.getSymbolName());\n         debug(\"CVLineRecord.computeContents: processing primary range %s\", primaryRange);\n \n         processRange(primaryRange);\n-        Iterator<Range> iterator = primaryEntry.leafRangeIterator();\n+        Iterator<Range> iterator = compiledEntry.leafRangeIterator();\n         while (iterator.hasNext()) {\n             Range subRange = iterator.next();\n             debug(\"CVLineRecord.computeContents: processing range %s\", subRange);\n", "next_change": {"commit": "9acf1c5d597e38f3e832360ce3f372ad94b16e9e", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\nindex 34598cf5e9f..dd7f777b3bb 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n", "chunk": "@@ -66,9 +67,9 @@ public class CVLineRecordBuilder {\n         debug(\"CVLineRecord.computeContents: processing primary range %s\", primaryRange);\n \n         processRange(primaryRange);\n-        Iterator<Range> iterator = compiledEntry.leafRangeIterator();\n+        Iterator<SubRange> iterator = compiledEntry.leafRangeIterator();\n         while (iterator.hasNext()) {\n-            Range subRange = iterator.next();\n+            SubRange subRange = iterator.next();\n             debug(\"CVLineRecord.computeContents: processing range %s\", subRange);\n             processRange(subRange);\n         }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc4NTEwMw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r502785103", "body": "What do you think about `CVLineRecord` deciding if we need a new file?\r\n\r\nIt already contains the necessary data, so adding a method (e.g., `maybeAddNewFile`) that would add a new file and return `true` only if the new `fileId` differs from the `fileId` of the current `FileBlock` should be easy.\r\n\r\nThat would allow this method to be simplified as follows (and you could also completely remove `previousRange` processing).\r\n```suggestion\r\n        FileEntry file = cvDebugInfo.findFile(range.getFileAsPath());\r\n        if (file == null) {\r\n            debug(\"processRange: range has no file: %s\\n\", range);\r\n            return;\r\n        }\r\n\r\n        if (range.getLine() == -1) {\r\n            debug(\"processRange: ignoring: bad line number\\n\");\r\n            return;\r\n        }\r\n\r\n        if (lineRecord.maybeAddNewFile(file)) {\r\n            debug(\"processRange: added new file: %s\\n\", file);\r\n        }\r\n```", "bodyText": "What do you think about CVLineRecord deciding if we need a new file?\nIt already contains the necessary data, so adding a method (e.g., maybeAddNewFile) that would add a new file and return true only if the new fileId differs from the fileId of the current FileBlock should be easy.\nThat would allow this method to be simplified as follows (and you could also completely remove previousRange processing).\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n                    Range previousRange = oldPreviousRange;\n          \n          \n            \n            \n          \n          \n            \n                    if (range.getLine() == -1) {\n          \n          \n            \n                        debug(\"     processRange: ignoring: bad line number\\n\");\n          \n          \n            \n                        return previousRange;\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    /* Is this a new file? if so emit a new file record. */\n          \n          \n            \n                    boolean wantNewFile = previousRange == null || !previousRange.getFileAsPath().equals(range.getFileAsPath());\n          \n          \n            \n                    if (wantNewFile) {\n          \n          \n            \n                        FileEntry file = cvDebugInfo.findFile(range.getFileAsPath());\n          \n          \n            \n                        if (file != null && file.getFileName() != null) {\n          \n          \n            \n                            debug(\"processRange: addNewFile: %s\\n\", file);\n          \n          \n            \n                            lineRecord.addNewFile(file);\n          \n          \n            \n                        } else {\n          \n          \n            \n                            debug(\"processRange: range has no file: %s\\n\", range);\n          \n          \n            \n                            return previousRange;\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    FileEntry file = cvDebugInfo.findFile(range.getFileAsPath());\n          \n          \n            \n                    if (file == null) {\n          \n          \n            \n                        debug(\"processRange: range has no file: %s\\n\", range);\n          \n          \n            \n                        return;\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    if (range.getLine() == -1) {\n          \n          \n            \n                        debug(\"processRange: ignoring: bad line number\\n\");\n          \n          \n            \n                        return;\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    if (lineRecord.maybeAddNewFile(file)) {\n          \n          \n            \n                        debug(\"processRange: added new file: %s\\n\", file);\n          \n          \n            \n                    }", "bodyHTML": "<p dir=\"auto\">What do you think about <code>CVLineRecord</code> deciding if we need a new file?</p>\n<p dir=\"auto\">It already contains the necessary data, so adding a method (e.g., <code>maybeAddNewFile</code>) that would add a new file and return <code>true</code> only if the new <code>fileId</code> differs from the <code>fileId</code> of the current <code>FileBlock</code> should be easy.</p>\n<p dir=\"auto\">That would allow this method to be simplified as follows (and you could also completely remove <code>previousRange</code> processing).</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"100\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"101\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-smi\">Range</span> previousRange <span class=\"pl-k\">=</span> oldPreviousRange;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"102\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"103\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">if</span> (range<span class=\"pl-k\">.</span>getLine() <span class=\"pl-k\">==</span> <span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"104\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            debug(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>     processRange: ignoring: bad line number<span class=\"pl-cce\">\\n</span><span class=\"pl-pds\">\"</span></span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"105\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-k\">return</span> previousRange;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"106\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"107\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"108\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-c\"><span class=\"pl-c\">/*</span> Is this a new file? if so emit a new file record. <span class=\"pl-c\">*/</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"109\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">boolean</span> wantNewFile <span class=\"pl-k\">=</span> previousRange <span class=\"pl-k\">==</span> <span class=\"pl-c1\">null</span> <span class=\"pl-k\">||</span> <span class=\"pl-k\">!</span>previousRange<span class=\"pl-k\">.</span>getFileAsPath()<span class=\"pl-k\">.</span>equals(range<span class=\"pl-k\">.</span>getFileAsPath());</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"110\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">if</span> (wantNewFile) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"111\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-smi\">FileEntry</span> file <span class=\"pl-k\">=</span> cvDebugInfo<span class=\"pl-k\">.</span>findFile(range<span class=\"pl-k\">.</span>getFileAsPath());</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"112\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-k\">if</span> (file <span class=\"pl-k\">!=</span> <span class=\"pl-c1\">null</span> <span class=\"pl-k\">&amp;&amp;</span> file<span class=\"pl-k\">.</span>getFileName() <span class=\"pl-k\">!=</span> <span class=\"pl-c1\">null</span>) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"113\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                debug(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>processRange: addNewFile: %s<span class=\"pl-cce\">\\n</span><span class=\"pl-pds\">\"</span></span>, file);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"114\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                lineRecord<span class=\"pl-k\">.</span>addNewFile(file);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"115\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            } <span class=\"pl-k\">else</span> {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"116\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                debug(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>processRange: range has no file: %s<span class=\"pl-cce\">\\n</span><span class=\"pl-pds\">\"</span></span>, range);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"117\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                <span class=\"pl-k\">return</span> previousRange;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"118\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"119\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"100\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-smi\">FileEntry</span> file <span class=\"pl-k\">=</span> cvDebugInfo<span class=\"pl-k\">.</span>findFile(range<span class=\"pl-k\">.</span>getFileAsPath());</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"101\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">if</span> (file <span class=\"pl-k\">==</span> <span class=\"pl-c1\">null</span>) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"102\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            debug(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>processRange: range has no file: %s<span class=\"pl-cce\">\\n</span><span class=\"pl-pds\">\"</span></span>, range);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"103\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            <span class=\"pl-k\">return</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"104\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"105\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"106\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">if</span> (range<span class=\"pl-k\">.</span>getLine() <span class=\"pl-k\">==</span> <span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"107\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            debug(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>processRange: ignoring: bad line number<span class=\"pl-cce\">\\n</span><span class=\"pl-pds\">\"</span></span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"108\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            <span class=\"pl-k\">return</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"109\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"110\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"111\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">if</span> (lineRecord<span class=\"pl-k\">.</span>maybeAddNewFile(file)) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"112\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            debug(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>processRange: added new file: %s<span class=\"pl-cce\">\\n</span><span class=\"pl-pds\">\"</span></span>, file);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"113\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        }</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pejovica", "createdAt": "2020-10-10T12:23:37Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+\n+/*\n+ * In CV4, the line table consists of a series of file headers followed by line number entries.\n+ * If this is a different file, then update the length of the previous file header, write the\n+ * new file header and write the new range At the very end, make sure we update the last file header.\n+ */\n+public class CVLineRecordBuilder {\n+\n+    private CVDebugInfo cvDebugInfo;\n+    private DebugContext debugContext;\n+    private CVLineRecord lineRecord;\n+    private PrimaryEntry primaryEntry;\n+\n+    CVLineRecordBuilder(DebugContext theDebugContext, CVDebugInfo cvDebugInfo) {\n+        this.debugContext = theDebugContext;\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    public void debug(String format, Object... args) {\n+        cvDebugInfo.getCVSymbolSection().verboseLog(debugContext, format, args);\n+    }\n+\n+    /**\n+     * Build line number records for a function.\n+     *\n+     * @param entry function to build line number table for\n+     * @return CVLineRecord containing any entries generated, or null if no entries generated\n+     */\n+    CVLineRecord build(PrimaryEntry entry) {\n+        this.primaryEntry = entry;\n+        Range primaryRange = primaryEntry.getPrimary();\n+\n+        debug(\"DEBUG_S_LINES linerecord for 0x%05x file: %s:%d\\n\", primaryRange.getLo(), primaryRange.getFileName(), primaryRange.getLine());\n+        this.lineRecord = new CVLineRecord(cvDebugInfo, primaryRange.getSymbolName());\n+        debug(\"CVLineRecord.computeContents: processing primary range %s\\n\", primaryRange);\n+        Range previousRange = processRange(primaryRange, null);\n+\n+        for (Range subRange : primaryEntry.getSubranges()) {\n+            debug(\"CVLineRecord.computeContents: processing range %s\\n\", subRange);\n+            FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subRange);\n+            if (subFileEntry == null) {\n+                continue;\n+            }\n+            previousRange = processRange(subRange, previousRange);\n+        }\n+        return lineRecord;\n+    }\n+\n+    /**\n+     * Merge input Range structures into line number table. The Range structures are assumed to be\n+     * ordered by ascending address.\n+     *\n+     * @param range to be merged or added to line number record\n+     * @param oldPreviousRange the previously processed Range\n+     * @return new value for previousRange in caller\n+     */\n+    private Range processRange(Range range, Range oldPreviousRange) {\n+\n+        Range previousRange = oldPreviousRange;\n+\n+        if (range.getLine() == -1) {\n+            debug(\"     processRange: ignoring: bad line number\\n\");\n+            return previousRange;\n+        }\n+\n+        /* Is this a new file? if so emit a new file record. */\n+        boolean wantNewFile = previousRange == null || !previousRange.getFileAsPath().equals(range.getFileAsPath());\n+        if (wantNewFile) {\n+            FileEntry file = cvDebugInfo.findFile(range.getFileAsPath());\n+            if (file != null && file.getFileName() != null) {\n+                debug(\"processRange: addNewFile: %s\\n\", file);\n+                lineRecord.addNewFile(file);\n+            } else {\n+                debug(\"processRange: range has no file: %s\\n\", range);\n+                return previousRange;\n+            }\n+        }", "originalCommit": "ab2c9a00f48883b83383fd411956082da9f0ac28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExNjk4MQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r504116981", "bodyText": "I'd rather not to this at this time, for a couple of reasons.  First, I'd like to keep all the decisions in the builder, and have the LineRecord class be dumb.  Secondly, I hope to provide a separate PR that reworks this code to (optionally) skip over Graal intrinsics.  In an IDE like Visudal Studio, the constant flipping between source files can be very distracting.", "author": "stooke", "createdAt": "2020-10-13T17:01:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc4NTEwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjI2OTk0Mw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r506269943", "bodyText": "I understand that there will be more changes in this code, but at the moment it seems too complicated for what it actually does. In particular, managing previousRange seems completely unnecessary given that CVLineRecord already keeps track of that.\nAs for the first point, let's keep all the logic in the builder then. Assuming that getCurrentFileId returns fileId of the current FileBlock, and that addNewFile is simplified to accept fileId (should resemble addNewLine), how about something like this?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n                    Range previousRange = oldPreviousRange;\n          \n          \n            \n            \n          \n          \n            \n                    if (range.getLine() == -1) {\n          \n          \n            \n                        debug(\"     processRange: ignoring: bad line number\\n\");\n          \n          \n            \n                        return previousRange;\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    /* Is this a new file? if so emit a new file record. */\n          \n          \n            \n                    boolean wantNewFile = previousRange == null || !previousRange.getFileAsPath().equals(range.getFileAsPath());\n          \n          \n            \n                    if (wantNewFile) {\n          \n          \n            \n                        FileEntry file = cvDebugInfo.findFile(range.getFileAsPath());\n          \n          \n            \n                        if (file != null && file.getFileName() != null) {\n          \n          \n            \n                            debug(\"processRange: addNewFile: %s\\n\", file);\n          \n          \n            \n                            lineRecord.addNewFile(file);\n          \n          \n            \n                        } else {\n          \n          \n            \n                            debug(\"processRange: range has no file: %s\\n\", range);\n          \n          \n            \n                            return previousRange;\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    FileEntry file = cvDebugInfo.findFile(range.getFileAsPath());\n          \n          \n            \n                    if (file == null) {\n          \n          \n            \n                        debug(\"processRange: range has no file: %s\\n\", range);\n          \n          \n            \n                        return;\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    if (range.getLine() == -1) {\n          \n          \n            \n                        debug(\"processRange: ignoring: bad line number\\n\");\n          \n          \n            \n                        return;\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    int fileId = cvDebugInfo.getCVSymbolSection().getFileTableRecord().addFile(file);\n          \n          \n            \n                    if (lineRecord.isEmpty() || lineRecord.getCurrentFileId() != fileId) {\n          \n          \n            \n                        debug(\"processRange: addNewFile: %s\\n\", file);\n          \n          \n            \n                        lineRecord.addNewFile(fileId);\n          \n          \n            \n                    }", "author": "pejovica", "createdAt": "2020-10-16T10:29:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc4NTEwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI3NTI1MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r510275250", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-10-22T15:55:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc4NTEwMw=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\nindex a7488f99995..1156522fb8e 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n", "chunk": "@@ -83,38 +79,31 @@ public class CVLineRecordBuilder {\n      * ordered by ascending address.\n      *\n      * @param range to be merged or added to line number record\n-     * @param oldPreviousRange the previously processed Range\n-     * @return new value for previousRange in caller\n      */\n-    private Range processRange(Range range, Range oldPreviousRange) {\n+    private void processRange(Range range) {\n \n-        Range previousRange = oldPreviousRange;\n+        FileEntry file = cvDebugInfo.findFile(range.getFileAsPath());\n+        if (file == null) {\n+            debug(\"processRange: range has no file: %s\\n\", range);\n+            return;\n+        }\n \n         if (range.getLine() == -1) {\n-            debug(\"     processRange: ignoring: bad line number\\n\");\n-            return previousRange;\n+            debug(\"processRange: ignoring: bad line number\\n\");\n+            return;\n         }\n \n-        /* Is this a new file? if so emit a new file record. */\n-        boolean wantNewFile = previousRange == null || !previousRange.getFileAsPath().equals(range.getFileAsPath());\n-        if (wantNewFile) {\n-            FileEntry file = cvDebugInfo.findFile(range.getFileAsPath());\n-            if (file != null && file.getFileName() != null) {\n-                debug(\"processRange: addNewFile: %s\\n\", file);\n-                lineRecord.addNewFile(file);\n-            } else {\n-                debug(\"processRange: range has no file: %s\\n\", range);\n-                return previousRange;\n-            }\n+        int fileId = cvDebugInfo.getCVSymbolSection().getFileTableRecord().addFile(file);\n+        if (lineRecord.isEmpty() || lineRecord.getCurrentFileId() != fileId) {\n+            debug(\"processRange: addNewFile: %s\\n\", file);\n+            lineRecord.addNewFile(fileId);\n         }\n \n         /* Add line record. */\n         /* An optimization would be to merge adjacent line records. */\n-        previousRange = range;\n         int lineLoAddr = range.getLo() - primaryEntry.getPrimary().getLo();\n         int line = Math.max(range.getLine(), 1);\n         debug(\"processRange:   addNewLine: 0x%05x %s\\n\", lineLoAddr, line);\n         lineRecord.addNewLine(lineLoAddr, line);\n-        return previousRange;\n     }\n }\n", "next_change": {"commit": "6d209109480ecec08ebf137288371d4c56064ba0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\nindex 1156522fb8e..2e83cf343d2 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n", "chunk": "@@ -103,7 +104,7 @@ public class CVLineRecordBuilder {\n         /* An optimization would be to merge adjacent line records. */\n         int lineLoAddr = range.getLo() - primaryEntry.getPrimary().getLo();\n         int line = Math.max(range.getLine(), 1);\n-        debug(\"processRange:   addNewLine: 0x%05x %s\\n\", lineLoAddr, line);\n+        debug(\"  processRange:   addNewLine: 0x%05x-0x%05x %s\", lineLoAddr, range.getLo() - primaryEntry.getPrimary().getHi(), line);\n         lineRecord.addNewLine(lineLoAddr, line);\n     }\n }\n", "next_change": {"commit": "20496a00704b8c5b6445a353f1bd114181ae7d91", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\nindex 2e83cf343d2..714f0194fc8 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n", "chunk": "@@ -101,10 +101,9 @@ public class CVLineRecordBuilder {\n         }\n \n         /* Add line record. */\n-        /* An optimization would be to merge adjacent line records. */\n         int lineLoAddr = range.getLo() - primaryEntry.getPrimary().getLo();\n         int line = Math.max(range.getLine(), 1);\n-        debug(\"  processRange:   addNewLine: 0x%05x-0x%05x %s\", lineLoAddr, range.getLo() - primaryEntry.getPrimary().getHi(), line);\n+        debug(\"  processRange:   addNewLine: 0x%05x-0x%05x %s\", lineLoAddr, range.getHi() - primaryEntry.getPrimary().getLo(), line);\n         lineRecord.addNewLine(lineLoAddr, line);\n     }\n }\n", "next_change": {"commit": "4caf93deee510084247c88599752478fc53bd73d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\nindex 714f0194fc8..34598cf5e9f 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java\n", "chunk": "@@ -101,9 +101,9 @@ public class CVLineRecordBuilder {\n         }\n \n         /* Add line record. */\n-        int lineLoAddr = range.getLo() - primaryEntry.getPrimary().getLo();\n+        int lineLoAddr = range.getLo() - compiledEntry.getPrimary().getLo();\n         int line = Math.max(range.getLine(), 1);\n-        debug(\"  processRange:   addNewLine: 0x%05x-0x%05x %s\", lineLoAddr, range.getHi() - primaryEntry.getPrimary().getLo(), line);\n+        debug(\"  processRange:   addNewLine: 0x%05x-0x%05x %s\", lineLoAddr, range.getHi() - compiledEntry.getPrimary().getLo(), line);\n         lineRecord.addNewLine(lineLoAddr, line);\n     }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgwNTQzMQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r502805431", "body": "This is more of an observation, and while I think it would be good to address this, it\u2019s okay to do it in a follow-up PR as well.\r\n\r\nI find that `CVStringTable` and `CVFileTable` are conceptually similar enough that their implementations and use in code should follow similar patterns. However, this is not the case at the moment.\r\n\r\n`CVStringTable` is a separate class that is passed around directly, and `CVStringTableRecord` is merely a wrapper. On the other hand, `CVFileTableRecord` is both a table and a record (there is no separate class `CVFileTable`), which is accessed via `CVDebugInfo`. In principle, I don't mind either approach, but what I don't like is that we have both.", "bodyText": "This is more of an observation, and while I think it would be good to address this, it\u2019s okay to do it in a follow-up PR as well.\nI find that CVStringTable and CVFileTable are conceptually similar enough that their implementations and use in code should follow similar patterns. However, this is not the case at the moment.\nCVStringTable is a separate class that is passed around directly, and CVStringTableRecord is merely a wrapper. On the other hand, CVFileTableRecord is both a table and a record (there is no separate class CVFileTable), which is accessed via CVDebugInfo. In principle, I don't mind either approach, but what I don't like is that we have both.", "bodyHTML": "<p dir=\"auto\">This is more of an observation, and while I think it would be good to address this, it\u2019s okay to do it in a follow-up PR as well.</p>\n<p dir=\"auto\">I find that <code>CVStringTable</code> and <code>CVFileTable</code> are conceptually similar enough that their implementations and use in code should follow similar patterns. However, this is not the case at the moment.</p>\n<p dir=\"auto\"><code>CVStringTable</code> is a separate class that is passed around directly, and <code>CVStringTableRecord</code> is merely a wrapper. On the other hand, <code>CVFileTableRecord</code> is both a table and a record (there is no separate class <code>CVFileTable</code>), which is accessed via <code>CVDebugInfo</code>. In principle, I don't mind either approach, but what I don't like is that we have both.</p>", "author": "pejovica", "createdAt": "2020-10-10T16:05:12Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import com.oracle.objectfile.io.Utf8;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SIGNATURE_C13;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SYMBOL_SECTION_NAME;\n+public final class CVSymbolSectionImpl extends CVSectionImpl {\n+\n+    private static final int CV_VECTOR_DEFAULT_SIZE = 200;\n+    private static final int CV_STRINGTABLE_DEFAULT_SIZE = 200;\n+\n+    private final CVDebugInfo cvDebugInfo;\n+    private final ArrayList<CVSymbolRecord> cvRecords;\n+    private final CVStringTable stringTable;\n+    private final CVFileTableRecord fileTableRecord;\n+\n+    CVSymbolSectionImpl(CVDebugInfo cvDebugInfo) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cvRecords = new ArrayList<>(CV_VECTOR_DEFAULT_SIZE);\n+        this.stringTable = new CVStringTable(CV_STRINGTABLE_DEFAULT_SIZE);\n+        this.fileTableRecord = new CVFileTableRecord(cvDebugInfo, stringTable);\n+    }\n+\n+    @Override\n+    public String getSectionName() {\n+        return CV_SYMBOL_SECTION_NAME;\n+    }\n+\n+    /*\n+     * Any (there may be sewveral) CodeView symbol section (\"debug$S\") is actually a list of\n+     * records, some of which containing sub-records.\n+     */\n+    @Override\n+    public void createContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() adding records\");\n+        addRecords(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() start\");\n+        /* Add header size. */\n+        pos += Integer.BYTES;\n+        /* Add sum of all record sizes. */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            pos = record.computeFullSize(pos);\n+        }\n+        /* Create a buffer that holds it all. */\n+        byte[] buffer = new byte[pos];\n+        super.setContent(buffer);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() end\");\n+    }\n+\n+    @Override\n+    public void writeContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() start recordcount=%d\", cvRecords.size());\n+        byte[] buffer = getContent();\n+        /* Write section header. */\n+        log(debugContext, \"  [0x%08x] CV_SIGNATURE_C13\", pos);\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, buffer, pos);\n+        /* Write all records. */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            log(debugContext, \"  [0x%08x] %s\", pos, record.toString());\n+            record.logContents(debugContext);\n+            pos = record.computeFullContents(buffer, pos);\n+        }\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() end\");\n+    }\n+\n+    private void addRecords(DebugContext debugContext) {\n+        addPrologueRecord();\n+        addFunctionRecords(debugContext);\n+        addFileRecord();\n+        addStringTableRecord();\n+    }\n+\n+    private void addPrologueRecord() {\n+        CVSymbolSubsection prologue = new CVSymbolSubsection(cvDebugInfo);\n+        CVSymbolSubrecord.CVObjectNameRecord objectNameRecord = new CVSymbolSubrecord.CVObjectNameRecord(cvDebugInfo);\n+        if (objectNameRecord.isValid()) {\n+            prologue.addRecord(objectNameRecord);\n+        }\n+        prologue.addRecord(new CVSymbolSubrecord.CVCompile3Record(cvDebugInfo));\n+        prologue.addRecord(new CVSymbolSubrecord.CVEnvBlockRecord(cvDebugInfo));\n+        addRecord(prologue);\n+    }\n+\n+    private void addFunctionRecords(DebugContext debugContext) {\n+        /* This will build and add many records for each function. */\n+        new CVSymbolSubsectionBuilder(cvDebugInfo).build(debugContext);\n+    }\n+\n+    private void addFileRecord() {\n+        /* Files are added to this record during function record building. */\n+        addRecord(fileTableRecord);\n+    }\n+\n+    CVFileTableRecord getFileTableRecord() {\n+        return this.fileTableRecord;\n+    }\n+\n+    private void addStringTableRecord() {\n+        CVSymbolRecord stringTableRecord = new CVStringTableRecord(cvDebugInfo, stringTable);\n+        addRecord(stringTableRecord);\n+    }\n+\n+    static final class CVStringTable {", "originalCommit": "ab2c9a00f48883b83383fd411956082da9f0ac28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA0MDE5OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r504040198", "bodyText": "There's also the StringTable in the debugentry package.  I'd leave this to a separate PR.", "author": "stooke", "createdAt": "2020-10-13T15:20:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgwNTQzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\nindex 5b0c2dd6a40..694e3bf7c7d 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java\n", "chunk": "@@ -135,7 +136,7 @@ public final class CVSymbolSectionImpl extends CVSectionImpl {\n     }\n \n     private void addStringTableRecord() {\n-        CVSymbolRecord stringTableRecord = new CVStringTableRecord(cvDebugInfo, stringTable);\n+        CVSymbolRecord stringTableRecord = new CVStringTableRecord(getCvDebugInfo(), stringTable);\n         addRecord(stringTableRecord);\n     }\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU1ODM5Ng==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r505558396", "body": "To avoid code duplication, I'd move the comments to `computeContents` and replace this with\r\n```suggestion\r\n        return computeContents(null, initialPos);\r\n```", "bodyText": "To avoid code duplication, I'd move the comments to computeContents and replace this with\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    /* Line record header. */\n          \n          \n            \n                    int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n          \n          \n            \n                    /* All blocks. */\n          \n          \n            \n                    for (FileBlock fileBlock : fileBlocks) {\n          \n          \n            \n                        pos = fileBlock.computeSize(pos);\n          \n          \n            \n                    }\n          \n          \n            \n                    return pos;\n          \n          \n            \n                    return computeContents(null, initialPos);", "bodyHTML": "<p dir=\"auto\">To avoid code duplication, I'd move the comments to <code>computeContents</code> and replace this with</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"82\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-c\"><span class=\"pl-c\">/*</span> Line record header. <span class=\"pl-c\">*/</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"83\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">int</span> pos <span class=\"pl-k\">=</span> initialPos <span class=\"pl-k\">+</span> <span class=\"pl-c1\">LINE_RECORD_HEADER_SIZE</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"84\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-c\"><span class=\"pl-c\">/*</span> All blocks. <span class=\"pl-c\">*/</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"85\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">for</span> (<span class=\"pl-smi\">FileBlock</span> fileBlock <span class=\"pl-k\">:</span> fileBlocks) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"86\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            pos <span class=\"pl-k\">=</span> fileBlock<span class=\"pl-k\">.</span>computeSize(pos);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"87\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"88\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">return</span> pos;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"82\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">return</span> computeContents(<span class=\"pl-c1\">null</span>, initialPos);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pejovica", "createdAt": "2020-10-15T13:50:18Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.ObjectFile;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A line record (DEBUG_S_LINES) consists of a list of (file block record + subrecords).\n+ * Graal will generate one CVLineRecord per function.\n+ */\n+final class CVLineRecord extends CVSymbolRecord {\n+\n+    /* Header: addr (4 bytes):section (2 bytes) flags (2 bytes) chunck length (4 bytes). */\n+    private static final int LINE_RECORD_HEADER_SIZE = Integer.BYTES + Short.BYTES * 2 + Integer.BYTES;\n+\n+    private static final int DEFAULT_LINE_BLOCK_COUNT = 100;\n+    private static final int DEFAULT_LINE_ENTRY_COUNT = 100;\n+\n+    /* Has colummns flag = 0x80 - not supported. */\n+    private static final short CB_HAS_NO_COLUMNS_FLAG = 0x00;\n+\n+    private String symbolName;\n+    private ArrayList<FileBlock> fileBlocks = new ArrayList<>(DEFAULT_LINE_BLOCK_COUNT);\n+\n+    CVLineRecord(CVDebugInfo cvDebugInfo, String symbolName) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_LINES);\n+        this.symbolName = symbolName;\n+    }\n+\n+    void addNewFile(FileEntry file) {\n+        CVFileTableRecord fr = cvDebugInfo.getCVSymbolSection().getFileTableRecord();\n+        int fileId = fr.addFile(file);\n+        fileBlocks.add(new FileBlock(fileId));\n+    }\n+\n+    void addNewLine(int addr, int line) {\n+        fileBlocks.get(fileBlocks.size() - 1).addEntry(new LineEntry(addr, line));\n+    }\n+\n+    @Override\n+    protected int computeSize(int initialPos) {\n+        /* Line record header. */\n+        int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n+        /* All blocks. */\n+        for (FileBlock fileBlock : fileBlocks) {\n+            pos = fileBlock.computeSize(pos);\n+        }\n+        return pos;", "originalCommit": "332525ad8af0236272ef3d88bd757b69c8fea09b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI0NzM2NA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r510247364", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-10-22T15:18:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU1ODM5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\nindex 6def3675538..090f30fe4ac 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n", "chunk": "@@ -64,13 +61,23 @@ final class CVLineRecord extends CVSymbolRecord {\n         fileBlocks.get(fileBlocks.size() - 1).addEntry(new LineEntry(addr, line));\n     }\n \n+    int getCurrentFileId() {\n+        assert !fileBlocks.isEmpty();\n+        return fileBlocks.get(fileBlocks.size() - 1).fileId;\n+    }\n+\n     @Override\n     protected int computeSize(int initialPos) {\n+        return computeContents(null, initialPos);\n+    }\n+\n+    @Override\n+    protected int computeContents(byte[] buffer, int initialPos) {\n         /* Line record header. */\n-        int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n+        int pos = computeHeader(buffer, initialPos);\n         /* All blocks. */\n         for (FileBlock fileBlock : fileBlocks) {\n-            pos = fileBlock.computeSize(pos);\n+            pos = fileBlock.computeContents(buffer, pos);\n         }\n         return pos;\n     }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU2OTk0OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r505569948", "body": "And I'd modify this so that it can optimally compute the size as well.\r\n```suggestion\r\n        int computeContents(byte[] buffer, int initialPos) {\r\n            if (buffer == null) {\r\n                return computeSize(initialPos);\r\n            }\r\n```", "bodyText": "And I'd modify this so that it can optimally compute the size as well.\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    int computeContents(byte[] buffer, int initialPos) {\n          \n          \n            \n                    int computeContents(byte[] buffer, int initialPos) {\n          \n          \n            \n                        if (buffer == null) {\n          \n          \n            \n                            return computeSize(initialPos);\n          \n          \n            \n                        }", "bodyHTML": "<p dir=\"auto\">And I'd modify this so that it can optimally compute the size as well.</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"141\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">int</span> computeContents(<span class=\"pl-k\">byte</span>[] buffer, <span class=\"pl-k\">int</span> initialPos) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"141\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">int</span> computeContents(<span class=\"pl-k\">byte</span>[] buffer, <span class=\"pl-k\">int</span> initialPos) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"142\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            <span class=\"pl-k\">if</span> (buffer <span class=\"pl-k\">==</span> <span class=\"pl-c1\">null</span>) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"143\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                <span class=\"pl-k\">return</span> computeSize(initialPos);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"144\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            }</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pejovica", "createdAt": "2020-10-15T14:04:32Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.ObjectFile;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A line record (DEBUG_S_LINES) consists of a list of (file block record + subrecords).\n+ * Graal will generate one CVLineRecord per function.\n+ */\n+final class CVLineRecord extends CVSymbolRecord {\n+\n+    /* Header: addr (4 bytes):section (2 bytes) flags (2 bytes) chunck length (4 bytes). */\n+    private static final int LINE_RECORD_HEADER_SIZE = Integer.BYTES + Short.BYTES * 2 + Integer.BYTES;\n+\n+    private static final int DEFAULT_LINE_BLOCK_COUNT = 100;\n+    private static final int DEFAULT_LINE_ENTRY_COUNT = 100;\n+\n+    /* Has colummns flag = 0x80 - not supported. */\n+    private static final short CB_HAS_NO_COLUMNS_FLAG = 0x00;\n+\n+    private String symbolName;\n+    private ArrayList<FileBlock> fileBlocks = new ArrayList<>(DEFAULT_LINE_BLOCK_COUNT);\n+\n+    CVLineRecord(CVDebugInfo cvDebugInfo, String symbolName) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_LINES);\n+        this.symbolName = symbolName;\n+    }\n+\n+    void addNewFile(FileEntry file) {\n+        CVFileTableRecord fr = cvDebugInfo.getCVSymbolSection().getFileTableRecord();\n+        int fileId = fr.addFile(file);\n+        fileBlocks.add(new FileBlock(fileId));\n+    }\n+\n+    void addNewLine(int addr, int line) {\n+        fileBlocks.get(fileBlocks.size() - 1).addEntry(new LineEntry(addr, line));\n+    }\n+\n+    @Override\n+    protected int computeSize(int initialPos) {\n+        /* Line record header. */\n+        int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n+        /* All blocks. */\n+        for (FileBlock fileBlock : fileBlocks) {\n+            pos = fileBlock.computeSize(pos);\n+        }\n+        return pos;\n+    }\n+\n+    private int computeHeader(byte[] buffer, int initialPos) {\n+\n+        if (buffer == null) {\n+            return initialPos + LINE_RECORD_HEADER_SIZE;\n+        }\n+\n+        assert symbolName != null;\n+        int pos = initialPos;\n+\n+        /* Emit addr:section relocation records. */\n+        cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, symbolName, false, 1L);\n+        pos = CVUtil.putInt(0, buffer, pos);\n+        cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, symbolName, false, 1L);\n+        pos = CVUtil.putShort((short) 0, buffer, pos);\n+\n+        /* Emit flags. */\n+        pos = CVUtil.putShort(CB_HAS_NO_COLUMNS_FLAG, buffer, pos);\n+\n+        /* Length of this chunk in object file (= highAddr since it's zero based. */\n+        int length = fileBlocks.isEmpty() ? 0 : fileBlocks.get(fileBlocks.size() - 1).getHighAddr();\n+        pos = CVUtil.putInt(length, buffer, pos);\n+        return pos;\n+    }\n+\n+    @Override\n+    protected int computeContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos + computeHeader(buffer, initialPos);\n+        for (FileBlock fileBlock : fileBlocks) {\n+            pos = fileBlock.computeContents(buffer, pos);\n+        }\n+        return pos;\n+    }\n+\n+    boolean isEmpty() {\n+        return fileBlocks.isEmpty();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVLineRecord(type=0x%04x pos=0x%05x size=0x%d)\", type, recordStartPosition, fileBlocks.size());\n+    }\n+\n+    /*\n+     * FileBlock is a section of contiguous code in a compilation unit, associated with a single\n+     * source file. If a function includes inlined code, that code needs its own FileBlock,\n+     * surrounded by FileBlocks describing the enclosing source file. A FileBlock consists of a list\n+     * of LineEntries.\n+     */\n+    private static class FileBlock {\n+\n+        /* Fileblock header: fileId (4 bytes) lineEntry count (4 bytes) tablesize (4 bytes) */\n+        static final int FILE_BLOCK_HEADER_SIZE = Integer.BYTES * 3;\n+\n+        private ArrayList<LineEntry> lineEntries = new ArrayList<>(DEFAULT_LINE_ENTRY_COUNT);\n+        private int fileId;\n+\n+        FileBlock(int fileId) {\n+            this.fileId = fileId;\n+        }\n+\n+        void addEntry(LineEntry le) {\n+            lineEntries.add(le);\n+        }\n+\n+        int computeContents(byte[] buffer, int initialPos) {", "originalCommit": "332525ad8af0236272ef3d88bd757b69c8fea09b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI1NDA5OQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r510254099", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-10-22T15:27:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU2OTk0OA=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\nindex 6def3675538..090f30fe4ac 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n", "chunk": "@@ -140,6 +139,9 @@ final class CVLineRecord extends CVSymbolRecord {\n         }\n \n         int computeContents(byte[] buffer, int initialPos) {\n+            if (buffer == null) {\n+                return computeSize(initialPos);\n+            }\n             int pos = initialPos;\n             pos = CVUtil.putInt(fileId, buffer, pos);\n             pos = CVUtil.putInt(lineEntries.size(), buffer, pos);\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYwMDMwMQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r505600301", "body": "You have an extra `initialPos` here.\r\n```suggestion\r\n        int pos = computeHeader(buffer, initialPos);\r\n```", "bodyText": "You have an extra initialPos here.\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    int pos = initialPos + computeHeader(buffer, initialPos);\n          \n          \n            \n                    int pos = computeHeader(buffer, initialPos);", "bodyHTML": "<p dir=\"auto\">You have an extra <code>initialPos</code> here.</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">int</span> pos <span class=\"pl-k\">=</span> <span class=\"x x-first\">initialPos </span><span class=\"pl-k x\">+</span><span class=\"x x-last\"> </span>computeHeader(buffer, initialPos);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">int</span> pos <span class=\"pl-k\">=</span> computeHeader(buffer, initialPos);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pejovica", "createdAt": "2020-10-15T14:43:08Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.ObjectFile;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A line record (DEBUG_S_LINES) consists of a list of (file block record + subrecords).\n+ * Graal will generate one CVLineRecord per function.\n+ */\n+final class CVLineRecord extends CVSymbolRecord {\n+\n+    /* Header: addr (4 bytes):section (2 bytes) flags (2 bytes) chunck length (4 bytes). */\n+    private static final int LINE_RECORD_HEADER_SIZE = Integer.BYTES + Short.BYTES * 2 + Integer.BYTES;\n+\n+    private static final int DEFAULT_LINE_BLOCK_COUNT = 100;\n+    private static final int DEFAULT_LINE_ENTRY_COUNT = 100;\n+\n+    /* Has colummns flag = 0x80 - not supported. */\n+    private static final short CB_HAS_NO_COLUMNS_FLAG = 0x00;\n+\n+    private String symbolName;\n+    private ArrayList<FileBlock> fileBlocks = new ArrayList<>(DEFAULT_LINE_BLOCK_COUNT);\n+\n+    CVLineRecord(CVDebugInfo cvDebugInfo, String symbolName) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_LINES);\n+        this.symbolName = symbolName;\n+    }\n+\n+    void addNewFile(FileEntry file) {\n+        CVFileTableRecord fr = cvDebugInfo.getCVSymbolSection().getFileTableRecord();\n+        int fileId = fr.addFile(file);\n+        fileBlocks.add(new FileBlock(fileId));\n+    }\n+\n+    void addNewLine(int addr, int line) {\n+        fileBlocks.get(fileBlocks.size() - 1).addEntry(new LineEntry(addr, line));\n+    }\n+\n+    @Override\n+    protected int computeSize(int initialPos) {\n+        /* Line record header. */\n+        int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n+        /* All blocks. */\n+        for (FileBlock fileBlock : fileBlocks) {\n+            pos = fileBlock.computeSize(pos);\n+        }\n+        return pos;\n+    }\n+\n+    private int computeHeader(byte[] buffer, int initialPos) {\n+\n+        if (buffer == null) {\n+            return initialPos + LINE_RECORD_HEADER_SIZE;\n+        }\n+\n+        assert symbolName != null;\n+        int pos = initialPos;\n+\n+        /* Emit addr:section relocation records. */\n+        cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, symbolName, false, 1L);\n+        pos = CVUtil.putInt(0, buffer, pos);\n+        cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, symbolName, false, 1L);\n+        pos = CVUtil.putShort((short) 0, buffer, pos);\n+\n+        /* Emit flags. */\n+        pos = CVUtil.putShort(CB_HAS_NO_COLUMNS_FLAG, buffer, pos);\n+\n+        /* Length of this chunk in object file (= highAddr since it's zero based. */\n+        int length = fileBlocks.isEmpty() ? 0 : fileBlocks.get(fileBlocks.size() - 1).getHighAddr();\n+        pos = CVUtil.putInt(length, buffer, pos);\n+        return pos;\n+    }\n+\n+    @Override\n+    protected int computeContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos + computeHeader(buffer, initialPos);", "originalCommit": "332525ad8af0236272ef3d88bd757b69c8fea09b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk5MDgzNw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r507990837", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-10-19T18:57:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYwMDMwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\nindex 6def3675538..090f30fe4ac 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n", "chunk": "@@ -94,20 +101,12 @@ final class CVLineRecord extends CVSymbolRecord {\n         pos = CVUtil.putShort(CB_HAS_NO_COLUMNS_FLAG, buffer, pos);\n \n         /* Length of this chunk in object file (= highAddr since it's zero based. */\n-        int length = fileBlocks.isEmpty() ? 0 : fileBlocks.get(fileBlocks.size() - 1).getHighAddr();\n+        assert !fileBlocks.isEmpty();\n+        int length = fileBlocks.get(fileBlocks.size() - 1).getHighAddr();\n         pos = CVUtil.putInt(length, buffer, pos);\n         return pos;\n     }\n \n-    @Override\n-    protected int computeContents(byte[] buffer, int initialPos) {\n-        int pos = initialPos + computeHeader(buffer, initialPos);\n-        for (FileBlock fileBlock : fileBlocks) {\n-            pos = fileBlock.computeContents(buffer, pos);\n-        }\n-        return pos;\n-    }\n-\n     boolean isEmpty() {\n         return fileBlocks.isEmpty();\n     }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYyMzk5OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r505623998", "body": "Perhaps a `LinkedHashMap` would be a better fit here as it would allow you to remove `cvRecords` and consolidate the related `add*` methods.", "bodyText": "Perhaps a LinkedHashMap would be a better fit here as it would allow you to remove cvRecords and consolidate the related add* methods.", "bodyHTML": "<p dir=\"auto\">Perhaps a <code>LinkedHashMap</code> would be a better fit here as it would allow you to remove <code>cvRecords</code> and consolidate the related <code>add*</code> methods.</p>", "author": "pejovica", "createdAt": "2020-10-15T15:11:40Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SIGNATURE_C13;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SYMBOL_SECTION_NAME;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_TYPE_SECTION_NAME;\n+\n+public final class CVTypeSectionImpl extends CVSectionImpl {\n+\n+    private static final int CV_RECORD_INITIAL_CAPACITY = 200;\n+\n+    /* CodeView 4 type records below 1000 are pre-defined. */\n+    private int sequenceCounter = 0x1000;\n+\n+    /* A sequential list of type records, starting at 1000 */\n+    private ArrayList<CVTypeRecord> cvRecords = new ArrayList<>(CV_RECORD_INITIAL_CAPACITY);\n+\n+    /* A map to ensure we can efficiently find and reuse records. */\n+    private Map<CVTypeRecord, CVTypeRecord> typeMap = new HashMap<>();", "originalCommit": "332525ad8af0236272ef3d88bd757b69c8fea09b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE2NTgzOA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r510165838", "bodyText": "Good idea.  Done.", "author": "stooke", "createdAt": "2020-10-22T13:34:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYyMzk5OA=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\nindex fefac0e66b5..ac22c2be305 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\n", "chunk": "@@ -49,11 +48,8 @@ public final class CVTypeSectionImpl extends CVSectionImpl {\n     /* CodeView 4 type records below 1000 are pre-defined. */\n     private int sequenceCounter = 0x1000;\n \n-    /* A sequential list of type records, starting at 1000 */\n-    private ArrayList<CVTypeRecord> cvRecords = new ArrayList<>(CV_RECORD_INITIAL_CAPACITY);\n-\n-    /* A map to ensure we can efficiently find and reuse records. */\n-    private Map<CVTypeRecord, CVTypeRecord> typeMap = new HashMap<>();\n+    /* A sequential map of type records, starting at 1000 */\n+    private Map<CVTypeRecord, CVTypeRecord> typeMap = new LinkedHashMap<>(CV_RECORD_INITIAL_CAPACITY);\n \n     CVTypeSectionImpl() {\n     }\n", "next_change": {"commit": "a1855223ff574e0d22ab361137a61ebe67565ee5", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\nindex ac22c2be305..89a552626bf 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\n", "chunk": "@@ -49,9 +49,10 @@ public final class CVTypeSectionImpl extends CVSectionImpl {\n     private int sequenceCounter = 0x1000;\n \n     /* A sequential map of type records, starting at 1000 */\n-    private Map<CVTypeRecord, CVTypeRecord> typeMap = new LinkedHashMap<>(CV_RECORD_INITIAL_CAPACITY);\n+    private final Map<CVTypeRecord, CVTypeRecord> typeMap = new LinkedHashMap<>(CV_RECORD_INITIAL_CAPACITY);\n \n-    CVTypeSectionImpl() {\n+    CVTypeSectionImpl(CVDebugInfo cvDebugInfo) {\n+        super(cvDebugInfo);\n     }\n \n     @Override\n", "next_change": {"commit": "77e3a7479e429a3279d3061496d260e35f21f000", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\nindex 89a552626bf..696b9434c9a 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java\n", "chunk": "@@ -49,10 +51,17 @@ public final class CVTypeSectionImpl extends CVSectionImpl {\n     private int sequenceCounter = 0x1000;\n \n     /* A sequential map of type records, starting at 1000 */\n+    /* This map is used to implement deduplication. */\n     private final Map<CVTypeRecord, CVTypeRecord> typeMap = new LinkedHashMap<>(CV_RECORD_INITIAL_CAPACITY);\n \n+    private final CVTypeSectionBuilder builder;\n+\n     CVTypeSectionImpl(CVDebugInfo cvDebugInfo) {\n+        /*\n+         * At this point, there is no debugContext in debugInfo, so no logging should be attempted.\n+         */\n         super(cvDebugInfo);\n+        builder = new CVTypeSectionBuilder(this);\n     }\n \n     @Override\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxMDU0OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r505710548", "body": "I don't think this cast is safe without first checking if `super.equals(obj)` is `true`.", "bodyText": "I don't think this cast is safe without first checking if super.equals(obj) is true.", "bodyHTML": "<p dir=\"auto\">I don't think this cast is safe without first checking if <code>super.equals(obj)</code> is <code>true</code>.</p>", "author": "pejovica", "createdAt": "2020-10-15T17:18:33Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import java.util.ArrayList;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_ARGLIST;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD1;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD2;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD3;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PROCEDURE;\n+\n+/*\n+ * CV Type Record format (little-endian):\n+ * uint16 length\n+ * uint16 leaf (a.k.a. record type)\n+ * (contents)\n+ */\n+abstract class CVTypeRecord {\n+\n+    protected final short type;\n+    private int startPosition;\n+    private int sequenceNumber; /* CodeView type records are numbered 1000 on up. */\n+\n+    CVTypeRecord(short type) {\n+        this.type = type;\n+        this.startPosition = -1;\n+        this.sequenceNumber = -1;\n+    }\n+\n+    int getSequenceNumber() {\n+        return sequenceNumber;\n+    }\n+\n+    void setSequenceNumber(int sequenceNumber) {\n+        this.sequenceNumber = sequenceNumber;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.startPosition = initialPos;\n+        int pos = initialPos + Short.BYTES * 2; /* Save room for length and leaf type. */\n+        pos = computeSize(pos);\n+        pos = alignPadded4(null, pos);\n+        return pos;\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos + Short.BYTES; /* Save room for length short. */\n+        pos = CVUtil.putShort(type, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        /* Length does not include record length (2 bytes)) but does include end padding. */\n+        pos = alignPadded4(buffer, pos);\n+        int length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort((short) length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    protected abstract int computeSize(int initialPos);\n+\n+    protected abstract int computeContents(byte[] buffer, int initialPos);\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null || obj.getClass() != this.getClass()) {\n+            return false;\n+        }\n+        return this.type == ((CVTypeRecord)obj).type;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVTypeRecord seq=0x%04x type=0x%04x pos=0x%04x \", sequenceNumber, type, startPosition);\n+    }\n+\n+    private static int alignPadded4(byte[] buffer, int originalpos) {\n+        int pos = originalpos;\n+        int align = pos & 3;\n+        if (align == 1) {\n+            byte[] p3 = {LF_PAD3, LF_PAD2, LF_PAD1};\n+            pos = CVUtil.putBytes(p3, buffer, pos);\n+        } else if (align == 2) {\n+            pos = CVUtil.putByte(LF_PAD2, buffer, pos);\n+            pos = CVUtil.putByte(LF_PAD1, buffer, pos);\n+        } else if (align == 3) {\n+            pos = CVUtil.putByte(LF_PAD1, buffer, pos);\n+        }\n+        return pos;\n+    }\n+\n+    static final class CVTypeProcedureRecord extends CVTypeRecord {\n+\n+        int returnType = -1;\n+        CVTypeArglistRecord argList = null;\n+\n+        CVTypeProcedureRecord() {\n+            super(LF_PROCEDURE);\n+        }\n+\n+        public CVTypeProcedureRecord returnType(int leaf) {\n+            this.returnType = leaf;\n+            return this;\n+        }\n+\n+        public CVTypeProcedureRecord returnType(CVTypeRecord leaf) {\n+            this.returnType = leaf.getSequenceNumber();\n+            return this;\n+        }\n+\n+        CVTypeProcedureRecord argList(CVTypeArglistRecord leaf) {\n+            this.argList = leaf;\n+            return this;\n+        }\n+\n+        @Override\n+        public int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(returnType, buffer, initialPos);\n+            pos = CVUtil.putByte((byte) 0, buffer, pos); /* callType */\n+            pos = CVUtil.putByte((byte) 0, buffer, pos); /* funcAttr */\n+            pos = CVUtil.putShort((short) argList.getSize(), buffer, pos);\n+            pos = CVUtil.putInt(argList.getSequenceNumber(), buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LF_PROCEDURE 0x%04x ret=0x%04x arg=0x%04x \", getSequenceNumber(), returnType, argList.getSequenceNumber());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = type;\n+            h = 31 * h + returnType;\n+            h = 31 * h + argList.hashCode();\n+            /* callType and funcAttr are always zero so do not add them to the hash */\n+            return h;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            CVTypeProcedureRecord other = (CVTypeProcedureRecord)obj;", "originalCommit": "332525ad8af0236272ef3d88bd757b69c8fea09b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk5MTMwNw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r507991307", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-10-19T18:57:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxMDU0OA=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\nindex 950bbcf68e3..2b8f1de74e9 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\n", "chunk": "@@ -169,8 +172,11 @@ abstract class CVTypeRecord {\n \n         @Override\n         public boolean equals(Object obj) {\n-            CVTypeProcedureRecord other = (CVTypeProcedureRecord)obj;\n-            return super.equals(obj) && this.returnType == other.returnType && this.argList == other.argList;\n+            if (!super.equals(obj)) {\n+                return false;\n+            }\n+            CVTypeProcedureRecord other = (CVTypeProcedureRecord) obj;\n+            return this.returnType == other.returnType && this.argList == other.argList;\n         }\n     }\n \n", "next_change": {"commit": "77e3a7479e429a3279d3061496d260e35f21f000", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\nindex 2b8f1de74e9..94dfc59bd8b 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\n", "chunk": "@@ -175,22 +352,21 @@ abstract class CVTypeRecord {\n             if (!super.equals(obj)) {\n                 return false;\n             }\n-            CVTypeProcedureRecord other = (CVTypeProcedureRecord) obj;\n-            return this.returnType == other.returnType && this.argList == other.argList;\n+            CVTypeStringIdRecord other = (CVTypeStringIdRecord) obj;\n+            return this.string.equals(other.string) && this.substringListIndex == other.substringListIndex;\n         }\n     }\n \n     static final class CVTypeArglistRecord extends CVTypeRecord {\n \n-        ArrayList<Integer> args = new ArrayList<>();\n+        private final ArrayList<Integer> args = new ArrayList<>();\n \n         CVTypeArglistRecord() {\n             super(LF_ARGLIST);\n         }\n \n-        CVTypeArglistRecord add(int argType) {\n+        void add(int argType) {\n             args.add(argType);\n-            return this;\n         }\n \n         @Override\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxMTA5NA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r505711094", "body": "Same for this cast.", "bodyText": "Same for this cast.", "bodyHTML": "<p dir=\"auto\">Same for this cast.</p>", "author": "pejovica", "createdAt": "2020-10-15T17:19:27Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import java.util.ArrayList;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_ARGLIST;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD1;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD2;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD3;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PROCEDURE;\n+\n+/*\n+ * CV Type Record format (little-endian):\n+ * uint16 length\n+ * uint16 leaf (a.k.a. record type)\n+ * (contents)\n+ */\n+abstract class CVTypeRecord {\n+\n+    protected final short type;\n+    private int startPosition;\n+    private int sequenceNumber; /* CodeView type records are numbered 1000 on up. */\n+\n+    CVTypeRecord(short type) {\n+        this.type = type;\n+        this.startPosition = -1;\n+        this.sequenceNumber = -1;\n+    }\n+\n+    int getSequenceNumber() {\n+        return sequenceNumber;\n+    }\n+\n+    void setSequenceNumber(int sequenceNumber) {\n+        this.sequenceNumber = sequenceNumber;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.startPosition = initialPos;\n+        int pos = initialPos + Short.BYTES * 2; /* Save room for length and leaf type. */\n+        pos = computeSize(pos);\n+        pos = alignPadded4(null, pos);\n+        return pos;\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos + Short.BYTES; /* Save room for length short. */\n+        pos = CVUtil.putShort(type, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        /* Length does not include record length (2 bytes)) but does include end padding. */\n+        pos = alignPadded4(buffer, pos);\n+        int length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort((short) length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    protected abstract int computeSize(int initialPos);\n+\n+    protected abstract int computeContents(byte[] buffer, int initialPos);\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null || obj.getClass() != this.getClass()) {\n+            return false;\n+        }\n+        return this.type == ((CVTypeRecord)obj).type;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVTypeRecord seq=0x%04x type=0x%04x pos=0x%04x \", sequenceNumber, type, startPosition);\n+    }\n+\n+    private static int alignPadded4(byte[] buffer, int originalpos) {\n+        int pos = originalpos;\n+        int align = pos & 3;\n+        if (align == 1) {\n+            byte[] p3 = {LF_PAD3, LF_PAD2, LF_PAD1};\n+            pos = CVUtil.putBytes(p3, buffer, pos);\n+        } else if (align == 2) {\n+            pos = CVUtil.putByte(LF_PAD2, buffer, pos);\n+            pos = CVUtil.putByte(LF_PAD1, buffer, pos);\n+        } else if (align == 3) {\n+            pos = CVUtil.putByte(LF_PAD1, buffer, pos);\n+        }\n+        return pos;\n+    }\n+\n+    static final class CVTypeProcedureRecord extends CVTypeRecord {\n+\n+        int returnType = -1;\n+        CVTypeArglistRecord argList = null;\n+\n+        CVTypeProcedureRecord() {\n+            super(LF_PROCEDURE);\n+        }\n+\n+        public CVTypeProcedureRecord returnType(int leaf) {\n+            this.returnType = leaf;\n+            return this;\n+        }\n+\n+        public CVTypeProcedureRecord returnType(CVTypeRecord leaf) {\n+            this.returnType = leaf.getSequenceNumber();\n+            return this;\n+        }\n+\n+        CVTypeProcedureRecord argList(CVTypeArglistRecord leaf) {\n+            this.argList = leaf;\n+            return this;\n+        }\n+\n+        @Override\n+        public int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(returnType, buffer, initialPos);\n+            pos = CVUtil.putByte((byte) 0, buffer, pos); /* callType */\n+            pos = CVUtil.putByte((byte) 0, buffer, pos); /* funcAttr */\n+            pos = CVUtil.putShort((short) argList.getSize(), buffer, pos);\n+            pos = CVUtil.putInt(argList.getSequenceNumber(), buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LF_PROCEDURE 0x%04x ret=0x%04x arg=0x%04x \", getSequenceNumber(), returnType, argList.getSequenceNumber());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = type;\n+            h = 31 * h + returnType;\n+            h = 31 * h + argList.hashCode();\n+            /* callType and funcAttr are always zero so do not add them to the hash */\n+            return h;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            CVTypeProcedureRecord other = (CVTypeProcedureRecord)obj;\n+            return super.equals(obj) && this.returnType == other.returnType && this.argList == other.argList;\n+        }\n+    }\n+\n+    static final class CVTypeArglistRecord extends CVTypeRecord {\n+\n+        ArrayList<Integer> args = new ArrayList<>();\n+\n+        CVTypeArglistRecord() {\n+            super(LF_ARGLIST);\n+        }\n+\n+        CVTypeArglistRecord add(int argType) {\n+            args.add(argType);\n+            return this;\n+        }\n+\n+        @Override\n+        public int computeSize(int initialPos) {\n+            return initialPos + Integer.BYTES + Integer.BYTES * args.size();\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(args.size(), buffer, initialPos);\n+            for (Integer at : args) {\n+                pos = CVUtil.putInt(at, buffer, pos);\n+            }\n+            return pos;\n+        }\n+\n+        int getSize() {\n+            return args.size();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            StringBuilder s = new StringBuilder(String.format(\"LF_ARGLIST 0x%04x [\", getSequenceNumber()));\n+            for (Integer at : args) {\n+                s.append(String.format(\" 0x%04x\", at));\n+            }\n+            s.append(\"])\");\n+            return s.toString();\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = type;\n+            h = h * 31 + args.size();\n+            for (Integer r : args) {\n+                h = 31 * h + r.hashCode();\n+            }\n+            return h;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            CVTypeArglistRecord other = (CVTypeArglistRecord)obj;", "originalCommit": "332525ad8af0236272ef3d88bd757b69c8fea09b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk5MTQzOQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r507991439", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-10-19T18:57:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxMTA5NA=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\nindex 950bbcf68e3..2b8f1de74e9 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\n", "chunk": "@@ -217,18 +223,16 @@ abstract class CVTypeRecord {\n \n         @Override\n         public int hashCode() {\n-            int h = type;\n-            h = h * 31 + args.size();\n-            for (Integer r : args) {\n-                h = 31 * h + r.hashCode();\n-            }\n-            return h;\n+            return type * 31 + args.hashCode();\n         }\n \n         @Override\n         public boolean equals(Object obj) {\n-            CVTypeArglistRecord other = (CVTypeArglistRecord)obj;\n-            return super.equals(obj) && this.args.equals(other.args);\n+            if (!super.equals(obj)) {\n+                return false;\n+            }\n+            CVTypeArglistRecord other = (CVTypeArglistRecord) obj;\n+            return this.args.equals(other.args);\n         }\n     }\n }\n", "next_change": {"commit": "77e3a7479e429a3279d3061496d260e35f21f000", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\nindex 2b8f1de74e9..94dfc59bd8b 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\n", "chunk": "@@ -235,4 +411,795 @@ abstract class CVTypeRecord {\n             return this.args.equals(other.args);\n         }\n     }\n+\n+    static final class CVTypeMFunctionRecord extends CVTypeRecord {\n+\n+        private int returnType = -1;\n+        private int classType = -1;\n+        private int thisType = -1;\n+        private byte callType = CV_CALL_NEAR_C;\n+        private byte funcAttr = 0;\n+        private int thisAdjust = 0;\n+\n+        private CVTypeArglistRecord argList = null;\n+\n+        CVTypeMFunctionRecord() {\n+            super(LF_MFUNCTION);\n+        }\n+\n+        void setReturnType(int returnType) {\n+            this.returnType = returnType;\n+        }\n+\n+        void setClassType(int classType) {\n+            this.classType = classType;\n+        }\n+\n+        void setThisType(int thisType) {\n+            this.thisType = thisType;\n+        }\n+\n+        @SuppressWarnings(\"SameParameterValue\")\n+        void setCallType(byte callType) {\n+            this.callType = callType;\n+        }\n+\n+        void setFuncAttr(byte funcAttr) {\n+            this.funcAttr = funcAttr;\n+        }\n+\n+        @SuppressWarnings(\"unused\")\n+        void setThisAdjust(int thisAdjust) {\n+            this.thisAdjust = thisAdjust;\n+        }\n+\n+        void setArgList(CVTypeArglistRecord argList) {\n+            this.argList = argList;\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(returnType, buffer, initialPos);\n+            pos = CVUtil.putInt(classType, buffer, pos);\n+            pos = CVUtil.putInt(thisType, buffer, pos);\n+            pos = CVUtil.putByte(callType, buffer, pos);\n+            pos = CVUtil.putByte(funcAttr, buffer, pos);\n+            pos = CVUtil.putShort((short) argList.getSize(), buffer, pos);\n+            pos = CVUtil.putInt(argList.getSequenceNumber(), buffer, pos);\n+            pos = CVUtil.putInt(thisAdjust, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String attrString = (funcAttr & FUNC_IS_CONSTRUCTOR) == FUNC_IS_CONSTRUCTOR ? \"(ctor)\" : \"\";\n+            return String.format(\"LF_MFUNCTION 0x%04x ret=0x%04x this=0x%04x *this=0x%04x+%d calltype=0x%x attr=0x%x%s, argcount=0x%04x \", getSequenceNumber(), returnType, classType, thisType,\n+                            thisAdjust, callType, funcAttr, attrString, argList.getSequenceNumber());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = type;\n+            h = 31 * h + returnType;\n+            h = 31 * h + classType;\n+            h = 31 * h + thisType;\n+            h = 31 * h + callType;\n+            h = 31 * h + funcAttr;\n+            h = 31 * h + thisAdjust;\n+            h = 31 * h + argList.getSequenceNumber();\n+            return h;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (!super.equals(obj)) {\n+                return false;\n+            }\n+            CVTypeMFunctionRecord other = (CVTypeMFunctionRecord) obj;\n+            return this.returnType == other.returnType && this.classType == other.classType && this.thisType == other.thisType && this.callType == other.callType && this.funcAttr == other.funcAttr &&\n+                            this.thisAdjust == other.thisAdjust && this.argList.getSequenceNumber() == other.argList.getSequenceNumber();\n+        }\n+    }\n+\n+    static final class CVTypeMethodListRecord extends CVTypeRecord {\n+\n+        static class MDef extends CVOneMethodRecord {\n+\n+            MDef(short attrs, int funcIdx, int vtbleOffset, String name) {\n+                super(attrs, funcIdx, vtbleOffset, name);\n+            }\n+\n+            @Override\n+            public int computeContents(byte[] buffer, int initialPos) {\n+                int pos = initialPos;\n+                pos = CVUtil.putShort(attrs, buffer, pos);\n+                /* Two bytes of padding. */\n+                pos = CVUtil.putShort((short) 0, buffer, pos);\n+                pos = CVUtil.putInt(funcIdx, buffer, pos);\n+                if (hasVtableOffset()) {\n+                    assert vtbleOffset >= 0;\n+                    pos = CVUtil.putInt(vtbleOffset, buffer, pos);\n+                }\n+                return pos;\n+            }\n+        }\n+\n+        static final int INITIAL_CAPACITY = 10;\n+\n+        private final ArrayList<MDef> methods = new ArrayList<>(INITIAL_CAPACITY);\n+\n+        CVTypeMethodListRecord() {\n+            super(LF_METHODLIST);\n+        }\n+\n+        public void add(short attrs, int idx, int offset, String name) {\n+            methods.add(new MDef(attrs, idx, offset, name));\n+        }\n+\n+        public int count() {\n+            return methods.size();\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = initialPos;\n+            for (MDef f : methods) {\n+                pos = f.computeContents(buffer, pos);\n+            }\n+            return pos;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = type;\n+            h = 31 * h + methods.hashCode();\n+            return h;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (!super.equals(obj)) {\n+                return false;\n+            }\n+            CVTypeMethodListRecord other = (CVTypeMethodListRecord) obj;\n+            return this.methods.equals(other.methods);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LF_METHODLIST idx=0x%04x count=%d\", getSequenceNumber(), methods.size());\n+        }\n+    }\n+\n+    static String attrString(short attrs) {\n+        final StringBuilder sb = new StringBuilder();\n+\n+        /* Low byte. */\n+        if ((attrs & MPROP_PPP_MASK) != 0) {\n+            String[] aStr = {\"\", \"private\", \"protected\", \"public\"};\n+            sb.append(aStr[attrs & MPROP_PPP_MASK]);\n+        }\n+        if ((attrs & MPROP_VSF_MASK) != 0) {\n+            int p = (attrs & MPROP_VSF_MASK) >> 2;\n+            String[] pStr = {\"\", \" virtual\", \" static\", \" friend\", \" intro\", \" pure\", \" intro-pure\", \" (*7*)\"};\n+            sb.append(pStr[p]);\n+        }\n+        if ((attrs & MPROP_PSEUDO) != 0) {\n+            sb.append(\" pseudo\");\n+        }\n+        if ((attrs & MPROP_FINAL_CLASS) != 0) {\n+            sb.append(\" final-class\");\n+        }\n+        if ((attrs & MPROP_ABSTRACT) != 0) {\n+            sb.append(\" abstract\");\n+        }\n+        if ((attrs & MPROP_COMPGENX) != 0) {\n+            sb.append(\" compgenx\");\n+        }\n+        if ((attrs & MPROP_FINAL_METHOD) != 0) {\n+            sb.append(\" final-method\");\n+        }\n+        return sb.toString();\n+    }\n+\n+    abstract static class FieldRecord {\n+\n+        protected final short type;\n+        protected final short attrs; /* property attribute field (prop_t) */\n+        protected final String name;\n+\n+        protected FieldRecord(short leafType, short attrs, String name) {\n+            assert name != null;\n+            this.type = leafType;\n+            this.attrs = attrs;\n+            this.name = name;\n+        }\n+\n+        protected FieldRecord(short leafType) {\n+            this(leafType, (short) 0, \"\");\n+        }\n+\n+        public int computeSize() {\n+            return computeContents(null, 0);\n+        }\n+\n+        public abstract int computeContents(byte[] buffer, int initialPos);\n+\n+        @Override\n+        public int hashCode() {\n+            int h = type;\n+            h = 31 * h + attrs;\n+            h = 31 * h + name.hashCode();\n+            return h;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj == null || obj.getClass() != this.getClass()) {\n+                return false;\n+            }\n+            FieldRecord other = (FieldRecord) obj;\n+            return this.type == other.type && this.attrs == other.attrs && this.name.equals(other.name);\n+        }\n+    }\n+\n+    static final class CVOverloadedMethodRecord extends FieldRecord {\n+\n+        private final int methodListIndex; /* index of method list record */\n+        private final short count;\n+\n+        CVOverloadedMethodRecord(short count, int methodListIndex, String methodName) {\n+            super(LF_METHOD, (short) 0, methodName);\n+            this.methodListIndex = methodListIndex;\n+            this.count = count;\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putShort(type, buffer, initialPos);\n+            pos = CVUtil.putShort(count, buffer, pos);\n+            pos = CVUtil.putInt(methodListIndex, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(name, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LF_METHOD(0x%04x) count=0x%x listIdx=0x%04x %s\", type, count, methodListIndex, name);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = super.hashCode();\n+            h = 31 * h + methodListIndex;\n+            h = 31 + h + count;\n+            return h;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (!super.equals(obj)) {\n+                return false;\n+            }\n+            CVOverloadedMethodRecord other = (CVOverloadedMethodRecord) obj;\n+            return this.methodListIndex == other.methodListIndex && this.count == other.count;\n+        }\n+    }\n+\n+    static final class CVIndexRecord extends FieldRecord {\n+\n+        private final int index; /* index of continuation record */\n+\n+        CVIndexRecord(int index) {\n+            super(LF_INDEX);\n+            this.index = index;\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putShort(type, buffer, initialPos);\n+            pos = CVUtil.putShort((short) 0, buffer, pos); /* padding. */\n+            pos = CVUtil.putInt(index, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LF_INDEX(0x%04x) index=0x%04x\", type, index);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = super.hashCode();\n+            h = 31 * h + index;\n+            return h;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (!super.equals(obj)) {\n+                return false;\n+            }\n+            CVIndexRecord other = (CVIndexRecord) obj;\n+            return this.index == other.index;\n+        }\n+    }\n+\n+    static final class CVMemberRecord extends FieldRecord {\n+\n+        private final int underlyingTypeIndex; /* type index of member type */\n+        private int offset;\n+\n+        CVMemberRecord(short attrs, int underlyingTypeIndex, int offset, String name) {\n+            super(LF_MEMBER, attrs, name);\n+            this.underlyingTypeIndex = underlyingTypeIndex;\n+            this.offset = offset;\n+        }\n+\n+        public void setOffset(int offset) {\n+            this.offset = offset;\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putShort(type, buffer, initialPos);\n+            pos = CVUtil.putShort(attrs, buffer, pos);\n+            pos = CVUtil.putInt(underlyingTypeIndex, buffer, pos);\n+            pos = CVUtil.putLfNumeric(offset, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(name, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LF_MEMBER(0x%04x) attr=0x%x(%s) t=0x%x off=%d 0x%x %s\", type, attrs, attrString(attrs), underlyingTypeIndex, offset, offset & 0xffff, name);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = super.hashCode();\n+            h = 31 * h + underlyingTypeIndex;\n+            h = 31 * h + offset;\n+            return h;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (!super.equals(obj)) {\n+                return false;\n+            }\n+            CVMemberRecord other = (CVMemberRecord) obj;\n+            return this.offset == other.offset && this.underlyingTypeIndex == other.underlyingTypeIndex;\n+        }\n+    }\n+\n+    static final class CVStaticMemberRecord extends FieldRecord {\n+\n+        /* Type index of member type. */\n+        private final int underlyingTypeIndex;\n+\n+        CVStaticMemberRecord(short attrs, int underlyingTypeIndex, String name) {\n+            super(LF_STMEMBER, attrs, name);\n+            this.underlyingTypeIndex = underlyingTypeIndex;\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putShort(type, buffer, initialPos);\n+            pos = CVUtil.putShort(attrs, buffer, pos);\n+            pos = CVUtil.putInt(underlyingTypeIndex, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(name, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LF_STMEMBER(0x%04x) attr=0x%x(%s) t=0x%x %s\", type, attrs, attrString(attrs), underlyingTypeIndex, name);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = super.hashCode();\n+            h = 31 * h + underlyingTypeIndex;\n+            return h;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (!super.equals(obj)) {\n+                return false;\n+            }\n+            CVStaticMemberRecord other = (CVStaticMemberRecord) obj;\n+            return this.underlyingTypeIndex == other.underlyingTypeIndex;\n+        }\n+    }\n+\n+    static class CVOneMethodRecord extends FieldRecord {\n+\n+        protected final int funcIdx; /* type index of member type */\n+        protected final int vtbleOffset;\n+\n+        CVOneMethodRecord(short attrs, int funcIdx, int vtbleOffset, String name) {\n+            super(LF_ONEMETHOD, attrs, name);\n+            this.funcIdx = funcIdx;\n+            this.vtbleOffset = vtbleOffset;\n+        }\n+\n+        boolean hasVtableOffset() {\n+            return (attrs & MPROP_VSF_MASK) == MPROP_IVIRTUAL || (attrs & MPROP_VSF_MASK) == MPROP_PURE_IVIRTUAL;\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putShort(type, buffer, initialPos);\n+            pos = CVUtil.putShort(attrs, buffer, pos);\n+            pos = CVUtil.putInt(funcIdx, buffer, pos);\n+            if (hasVtableOffset()) {\n+                assert vtbleOffset >= 0;\n+                pos = CVUtil.putInt(vtbleOffset, buffer, pos);\n+            }\n+            pos = CVUtil.putUTF8StringBytes(name, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LF_ONEMETHOD(0x%04x) attr=0x%x(%s) funcIdx=0x%x vtbloffet=0x%x %s\", type, attrs, attrString(attrs), funcIdx, vtbleOffset, name);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = super.hashCode();\n+            h = 31 * h + funcIdx;\n+            h = 31 * h + vtbleOffset;\n+            return h;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (!super.equals(obj)) {\n+                return false;\n+            }\n+            CVOneMethodRecord other = (CVOneMethodRecord) obj;\n+            return this.vtbleOffset == other.vtbleOffset && this.funcIdx == other.funcIdx;\n+        }\n+    }\n+\n+    static class CVBaseMemberRecord extends FieldRecord {\n+\n+        private final int basetypeIndex; /* type index of member type */\n+        private final int offset; /* in java, usually 0 as there is no multiple inheritance. */\n+\n+        CVBaseMemberRecord(short attrs, int basetypeIndex, int offset) {\n+            super(LF_BCLASS, attrs, \"\");\n+            this.basetypeIndex = basetypeIndex;\n+            this.offset = offset;\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putShort(type, buffer, initialPos);\n+            pos = CVUtil.putShort(attrs, buffer, pos);\n+            pos = CVUtil.putInt(basetypeIndex, buffer, pos);\n+            pos = CVUtil.putLfNumeric(offset, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LF_BCLASS(0x%04x) attr=0x%04x(%s ?) baseIdx=0x%04x offset=0x%x\", LF_BCLASS, attrs, attrString(attrs), basetypeIndex, offset);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = super.hashCode();\n+            h = 31 * h + basetypeIndex;\n+            h = 31 * h + offset;\n+            return h;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (!super.equals(obj)) {\n+                return false;\n+            }\n+            CVBaseMemberRecord other = (CVBaseMemberRecord) obj;\n+            return this.basetypeIndex == other.basetypeIndex && this.offset == other.offset;\n+        }\n+    }\n+\n+    static class CVClassRecord extends CVTypeRecord {\n+\n+        static final int ATTR_FORWARD_REF = 0x0080;\n+        static final int ATTR_HAS_UNIQUENAME = 0x0200;\n+\n+        /* Count of number of elements in class field list. */\n+        private final short count;\n+\n+        /* Property attribute field (prop_t). */\n+        private final short propertyAttributes;\n+\n+        /* Type index of LF_FIELDLIST descriptor list. */\n+        private final int fieldIndex;\n+\n+        /* Type index of derived from list if not zero */\n+        /*\n+         * For Java, there is only one class, so LF_BCLASS is in the member list and\n+         * derivedFromIndex is 0.\n+         */\n+        private final int derivedFromIndex;\n+\n+        /* Type index of vshape table for this class. */\n+        private final int vshapeIndex;\n+\n+        /* Size (in bytes) of an instance. */\n+        private final long size;\n+\n+        /* Class name. */\n+        private final String className;\n+\n+        /* Linker class name. */\n+        private final String uniqueName;\n+\n+        CVClassRecord(short recType, short count, short attrs, int fieldIndex, int derivedFromIndex, int vshapeIndex, long size, String className, String uniqueName) {\n+            super(recType);\n+            this.count = count;\n+            this.propertyAttributes = (short) (attrs | (short) (uniqueName != null ? ATTR_HAS_UNIQUENAME : 0));\n+            this.fieldIndex = fieldIndex;\n+            this.derivedFromIndex = derivedFromIndex;\n+            this.vshapeIndex = vshapeIndex;\n+            this.size = size;\n+            this.className = className;\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        @SuppressWarnings(\"unused\")\n+        CVClassRecord(short count, short attrs, int fieldIndex, int derivedFromIndex, int vshapeIndex, long size, String className, String uniqueName) {\n+            this(LF_CLASS, count, attrs, fieldIndex, derivedFromIndex, vshapeIndex, size, className, uniqueName);\n+        }\n+\n+        CVClassRecord(short attrs, String className, String uniqueName) {\n+            this(LF_CLASS, (short) 0, attrs, 0, 0, 0, 0, className, uniqueName);\n+        }\n+\n+        String getClassName() {\n+            return className;\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putShort(count, buffer, initialPos);\n+            pos = CVUtil.putShort(propertyAttributes, buffer, pos);\n+            pos = CVUtil.putInt(fieldIndex, buffer, pos);\n+            pos = CVUtil.putInt(derivedFromIndex, buffer, pos);\n+            pos = CVUtil.putInt(vshapeIndex, buffer, pos);\n+            pos = CVUtil.putLfNumeric(size, buffer, pos);\n+            String fixedName = CVNames.typeNameToCodeViewName(className);\n+            pos = CVUtil.putUTF8StringBytes(fixedName, buffer, pos);\n+            if (hasUniqueName()) {\n+                assert uniqueName != null;\n+                pos = CVUtil.putUTF8StringBytes(uniqueName, buffer, pos);\n+            }\n+            return pos;\n+        }\n+\n+        boolean isForwardRef() {\n+            return (propertyAttributes & ATTR_FORWARD_REF) != 0;\n+        }\n+\n+        @SuppressWarnings(\"unused\")\n+        public boolean hasUniqueName() {\n+            return (propertyAttributes & ATTR_HAS_UNIQUENAME) != 0;\n+        }\n+\n+        protected String toString(String lfTypeStr) {\n+            return String.format(\"%s 0x%04x count=%d attr=0x%x(%s) fld=0x%x super=0x%x vshape=0x%x size=%d %s%s\", lfTypeStr, getSequenceNumber(), count, propertyAttributes,\n+                            propertyString(propertyAttributes), fieldIndex, derivedFromIndex,\n+                            vshapeIndex, size, className, uniqueName != null ? \" (\" + uniqueName + \")\" : \"\");\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return toString(\"LF_CLASS\");\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = type;\n+            h = 31 * h + count;\n+            h = 31 * h + propertyAttributes;\n+            h = 31 * h + fieldIndex;\n+            h = 31 * h + derivedFromIndex;\n+            h = 31 * h + (int) size;\n+            h = 31 * h + className.hashCode();\n+            if (uniqueName != null) {\n+                h = 31 * h + uniqueName.hashCode();\n+            }\n+            h = 31 * h + vshapeIndex;\n+            return h;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (!super.equals(obj)) {\n+                return false;\n+            }\n+            CVClassRecord other = (CVClassRecord) obj;\n+            return this.count == other.count && this.propertyAttributes == other.propertyAttributes && this.fieldIndex == other.fieldIndex && this.derivedFromIndex == other.derivedFromIndex &&\n+                            this.size == other.size && this.className.equals(other.className) && (this.uniqueName != null ? this.uniqueName.equals(other.uniqueName) : other.uniqueName == null) &&\n+                            this.vshapeIndex == other.vshapeIndex;\n+        }\n+    }\n+\n+    static final class CVFieldListRecord extends CVTypeRecord {\n+\n+        static final int INITIAL_CAPACITY = 10;\n+\n+        /* Size includes type field but not record length field. */\n+        private int estimatedSize = CVUtil.align4(Short.BYTES);\n+\n+        private final ArrayList<FieldRecord> members = new ArrayList<>(INITIAL_CAPACITY);\n+\n+        CVFieldListRecord() {\n+            super(LF_FIELDLIST);\n+        }\n+\n+        void add(FieldRecord m) {\n+            /* Keep a running total. */\n+            estimatedSize += CVUtil.align4(m.computeSize());\n+            members.add(m);\n+        }\n+\n+        int getEstimatedSize() {\n+            return estimatedSize;\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = initialPos;\n+            for (FieldRecord field : members) {\n+                pos = field.computeContents(buffer, pos);\n+                pos = CVTypeRecord.alignPadded4(buffer, pos);\n+            }\n+            return pos;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int hash = type;\n+            hash = 31 * hash + members.hashCode();\n+            return hash;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (!super.equals(obj)) {\n+                return false;\n+            }\n+            CVFieldListRecord other = (CVFieldListRecord) obj;\n+            return this.members.equals(other.members);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LF_FIELDLIST idx=0x%x count=%d\", getSequenceNumber(), members.size());\n+        }\n+    }\n+\n+    static final class CVTypeArrayRecord extends CVTypeRecord {\n+\n+        private final int elementTypeIndex;\n+        private final int indexType;\n+        private final int length;\n+        private final String name;\n+\n+        CVTypeArrayRecord(int elementTypeIndex, int indexType, int length, String name) {\n+            super(LF_ARRAY);\n+            this.elementTypeIndex = elementTypeIndex;\n+            this.indexType = indexType;\n+            this.length = length;\n+            this.name = name;\n+        }\n+\n+        CVTypeArrayRecord(int elementTypeIndex, int indexType, int length) {\n+            this(elementTypeIndex, indexType, length, \"\");\n+        }\n+\n+        @SuppressWarnings(\"unused\")\n+        CVTypeArrayRecord(int elementTypeIndex, int length) {\n+            this(elementTypeIndex, T_UINT8, length);\n+        }\n+\n+        @SuppressWarnings(\"unused\")\n+        CVTypeArrayRecord(CVTypeRecord elementType, int length) {\n+            this(elementType.getSequenceNumber(), T_UINT8, length);\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(elementTypeIndex, buffer, initialPos);\n+            pos = CVUtil.putInt(indexType, buffer, pos);\n+            pos = CVUtil.putLfNumeric(length, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(name, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LF_ARRAY 0x%04x type=0x%04x len=%d indexType=0x%04x%s\", getSequenceNumber(), elementTypeIndex, length, indexType, name.isEmpty() ? \"\" : \"name=\" + name);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = type;\n+            h = 31 * h + elementTypeIndex;\n+            h = 31 * h + indexType;\n+            h = 31 * h + length;\n+            h = 31 * h + name.hashCode();\n+            return h;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (!super.equals(obj)) {\n+                return false;\n+            }\n+            CVTypeArrayRecord other = (CVTypeArrayRecord) obj;\n+            return this.elementTypeIndex == other.elementTypeIndex && this.indexType == other.indexType && this.length == other.length && this.name.equals(other.name);\n+        }\n+    }\n+\n+    static String propertyString(int properties) {\n+        final StringBuilder sb = new StringBuilder();\n+\n+        /* Low byte. */\n+        if ((properties & 0x0001) != 0) {\n+            sb.append(\" packed\");\n+        }\n+        if ((properties & 0x0002) != 0) {\n+            sb.append(\" ctor\");\n+        }\n+        if ((properties & 0x0004) != 0) {\n+            sb.append(\" ovlops\");\n+        }\n+        if ((properties & 0x0008) != 0) {\n+            sb.append(\" isnested\");\n+        }\n+        if ((properties & 0x0010) != 0) {\n+            sb.append(\" cnested\");\n+        }\n+        if ((properties & 0x0020) != 0) {\n+            sb.append(\" opassign\");\n+        }\n+        if ((properties & 0x0040) != 0) {\n+            sb.append(\" opcast\");\n+        }\n+        if ((properties & 0x0080) != 0) {\n+            sb.append(\" forwardref\");\n+        }\n+\n+        /* High byte. */\n+        if ((properties & 0x0100) != 0) {\n+            sb.append(\" scope\");\n+        }\n+        if ((properties & 0x0200) != 0) {\n+            sb.append(\" hasuniquename\");\n+        }\n+        if ((properties & 0x0400) != 0) {\n+            sb.append(\" sealed\");\n+        }\n+        if ((properties & 0x1800) != 0) {\n+            sb.append(\" hfa...\");\n+        }\n+        if ((properties & 0x2000) != 0) {\n+            sb.append(\" intrinsic\");\n+        }\n+        if ((properties & 0xc000) != 0) {\n+            sb.append(\" macom...\");\n+        }\n+        return sb.toString();\n+    }\n }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxNTg1Mg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r505715852", "body": "Why didn't you use `args.hashCode` here?", "bodyText": "Why didn't you use args.hashCode here?", "bodyHTML": "<p dir=\"auto\">Why didn't you use <code>args.hashCode</code> here?</p>", "author": "pejovica", "createdAt": "2020-10-15T17:27:44Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import java.util.ArrayList;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_ARGLIST;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD1;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD2;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD3;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PROCEDURE;\n+\n+/*\n+ * CV Type Record format (little-endian):\n+ * uint16 length\n+ * uint16 leaf (a.k.a. record type)\n+ * (contents)\n+ */\n+abstract class CVTypeRecord {\n+\n+    protected final short type;\n+    private int startPosition;\n+    private int sequenceNumber; /* CodeView type records are numbered 1000 on up. */\n+\n+    CVTypeRecord(short type) {\n+        this.type = type;\n+        this.startPosition = -1;\n+        this.sequenceNumber = -1;\n+    }\n+\n+    int getSequenceNumber() {\n+        return sequenceNumber;\n+    }\n+\n+    void setSequenceNumber(int sequenceNumber) {\n+        this.sequenceNumber = sequenceNumber;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.startPosition = initialPos;\n+        int pos = initialPos + Short.BYTES * 2; /* Save room for length and leaf type. */\n+        pos = computeSize(pos);\n+        pos = alignPadded4(null, pos);\n+        return pos;\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos + Short.BYTES; /* Save room for length short. */\n+        pos = CVUtil.putShort(type, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        /* Length does not include record length (2 bytes)) but does include end padding. */\n+        pos = alignPadded4(buffer, pos);\n+        int length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort((short) length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    protected abstract int computeSize(int initialPos);\n+\n+    protected abstract int computeContents(byte[] buffer, int initialPos);\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null || obj.getClass() != this.getClass()) {\n+            return false;\n+        }\n+        return this.type == ((CVTypeRecord)obj).type;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVTypeRecord seq=0x%04x type=0x%04x pos=0x%04x \", sequenceNumber, type, startPosition);\n+    }\n+\n+    private static int alignPadded4(byte[] buffer, int originalpos) {\n+        int pos = originalpos;\n+        int align = pos & 3;\n+        if (align == 1) {\n+            byte[] p3 = {LF_PAD3, LF_PAD2, LF_PAD1};\n+            pos = CVUtil.putBytes(p3, buffer, pos);\n+        } else if (align == 2) {\n+            pos = CVUtil.putByte(LF_PAD2, buffer, pos);\n+            pos = CVUtil.putByte(LF_PAD1, buffer, pos);\n+        } else if (align == 3) {\n+            pos = CVUtil.putByte(LF_PAD1, buffer, pos);\n+        }\n+        return pos;\n+    }\n+\n+    static final class CVTypeProcedureRecord extends CVTypeRecord {\n+\n+        int returnType = -1;\n+        CVTypeArglistRecord argList = null;\n+\n+        CVTypeProcedureRecord() {\n+            super(LF_PROCEDURE);\n+        }\n+\n+        public CVTypeProcedureRecord returnType(int leaf) {\n+            this.returnType = leaf;\n+            return this;\n+        }\n+\n+        public CVTypeProcedureRecord returnType(CVTypeRecord leaf) {\n+            this.returnType = leaf.getSequenceNumber();\n+            return this;\n+        }\n+\n+        CVTypeProcedureRecord argList(CVTypeArglistRecord leaf) {\n+            this.argList = leaf;\n+            return this;\n+        }\n+\n+        @Override\n+        public int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(returnType, buffer, initialPos);\n+            pos = CVUtil.putByte((byte) 0, buffer, pos); /* callType */\n+            pos = CVUtil.putByte((byte) 0, buffer, pos); /* funcAttr */\n+            pos = CVUtil.putShort((short) argList.getSize(), buffer, pos);\n+            pos = CVUtil.putInt(argList.getSequenceNumber(), buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LF_PROCEDURE 0x%04x ret=0x%04x arg=0x%04x \", getSequenceNumber(), returnType, argList.getSequenceNumber());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = type;\n+            h = 31 * h + returnType;\n+            h = 31 * h + argList.hashCode();\n+            /* callType and funcAttr are always zero so do not add them to the hash */\n+            return h;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            CVTypeProcedureRecord other = (CVTypeProcedureRecord)obj;\n+            return super.equals(obj) && this.returnType == other.returnType && this.argList == other.argList;\n+        }\n+    }\n+\n+    static final class CVTypeArglistRecord extends CVTypeRecord {\n+\n+        ArrayList<Integer> args = new ArrayList<>();\n+\n+        CVTypeArglistRecord() {\n+            super(LF_ARGLIST);\n+        }\n+\n+        CVTypeArglistRecord add(int argType) {\n+            args.add(argType);\n+            return this;\n+        }\n+\n+        @Override\n+        public int computeSize(int initialPos) {\n+            return initialPos + Integer.BYTES + Integer.BYTES * args.size();\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(args.size(), buffer, initialPos);\n+            for (Integer at : args) {\n+                pos = CVUtil.putInt(at, buffer, pos);\n+            }\n+            return pos;\n+        }\n+\n+        int getSize() {\n+            return args.size();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            StringBuilder s = new StringBuilder(String.format(\"LF_ARGLIST 0x%04x [\", getSequenceNumber()));\n+            for (Integer at : args) {\n+                s.append(String.format(\" 0x%04x\", at));\n+            }\n+            s.append(\"])\");\n+            return s.toString();\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = type;\n+            h = h * 31 + args.size();\n+            for (Integer r : args) {\n+                h = 31 * h + r.hashCode();\n+            }", "originalCommit": "332525ad8af0236272ef3d88bd757b69c8fea09b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA0OTQ5Mw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r508049493", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-10-19T20:42:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxNTg1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\nindex 950bbcf68e3..2b8f1de74e9 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\n", "chunk": "@@ -217,18 +223,16 @@ abstract class CVTypeRecord {\n \n         @Override\n         public int hashCode() {\n-            int h = type;\n-            h = h * 31 + args.size();\n-            for (Integer r : args) {\n-                h = 31 * h + r.hashCode();\n-            }\n-            return h;\n+            return type * 31 + args.hashCode();\n         }\n \n         @Override\n         public boolean equals(Object obj) {\n-            CVTypeArglistRecord other = (CVTypeArglistRecord)obj;\n-            return super.equals(obj) && this.args.equals(other.args);\n+            if (!super.equals(obj)) {\n+                return false;\n+            }\n+            CVTypeArglistRecord other = (CVTypeArglistRecord) obj;\n+            return this.args.equals(other.args);\n         }\n     }\n }\n", "next_change": {"commit": "77e3a7479e429a3279d3061496d260e35f21f000", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\nindex 2b8f1de74e9..94dfc59bd8b 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java\n", "chunk": "@@ -235,4 +411,795 @@ abstract class CVTypeRecord {\n             return this.args.equals(other.args);\n         }\n     }\n+\n+    static final class CVTypeMFunctionRecord extends CVTypeRecord {\n+\n+        private int returnType = -1;\n+        private int classType = -1;\n+        private int thisType = -1;\n+        private byte callType = CV_CALL_NEAR_C;\n+        private byte funcAttr = 0;\n+        private int thisAdjust = 0;\n+\n+        private CVTypeArglistRecord argList = null;\n+\n+        CVTypeMFunctionRecord() {\n+            super(LF_MFUNCTION);\n+        }\n+\n+        void setReturnType(int returnType) {\n+            this.returnType = returnType;\n+        }\n+\n+        void setClassType(int classType) {\n+            this.classType = classType;\n+        }\n+\n+        void setThisType(int thisType) {\n+            this.thisType = thisType;\n+        }\n+\n+        @SuppressWarnings(\"SameParameterValue\")\n+        void setCallType(byte callType) {\n+            this.callType = callType;\n+        }\n+\n+        void setFuncAttr(byte funcAttr) {\n+            this.funcAttr = funcAttr;\n+        }\n+\n+        @SuppressWarnings(\"unused\")\n+        void setThisAdjust(int thisAdjust) {\n+            this.thisAdjust = thisAdjust;\n+        }\n+\n+        void setArgList(CVTypeArglistRecord argList) {\n+            this.argList = argList;\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(returnType, buffer, initialPos);\n+            pos = CVUtil.putInt(classType, buffer, pos);\n+            pos = CVUtil.putInt(thisType, buffer, pos);\n+            pos = CVUtil.putByte(callType, buffer, pos);\n+            pos = CVUtil.putByte(funcAttr, buffer, pos);\n+            pos = CVUtil.putShort((short) argList.getSize(), buffer, pos);\n+            pos = CVUtil.putInt(argList.getSequenceNumber(), buffer, pos);\n+            pos = CVUtil.putInt(thisAdjust, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String attrString = (funcAttr & FUNC_IS_CONSTRUCTOR) == FUNC_IS_CONSTRUCTOR ? \"(ctor)\" : \"\";\n+            return String.format(\"LF_MFUNCTION 0x%04x ret=0x%04x this=0x%04x *this=0x%04x+%d calltype=0x%x attr=0x%x%s, argcount=0x%04x \", getSequenceNumber(), returnType, classType, thisType,\n+                            thisAdjust, callType, funcAttr, attrString, argList.getSequenceNumber());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = type;\n+            h = 31 * h + returnType;\n+            h = 31 * h + classType;\n+            h = 31 * h + thisType;\n+            h = 31 * h + callType;\n+            h = 31 * h + funcAttr;\n+            h = 31 * h + thisAdjust;\n+            h = 31 * h + argList.getSequenceNumber();\n+            return h;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (!super.equals(obj)) {\n+                return false;\n+            }\n+            CVTypeMFunctionRecord other = (CVTypeMFunctionRecord) obj;\n+            return this.returnType == other.returnType && this.classType == other.classType && this.thisType == other.thisType && this.callType == other.callType && this.funcAttr == other.funcAttr &&\n+                            this.thisAdjust == other.thisAdjust && this.argList.getSequenceNumber() == other.argList.getSequenceNumber();\n+        }\n+    }\n+\n+    static final class CVTypeMethodListRecord extends CVTypeRecord {\n+\n+        static class MDef extends CVOneMethodRecord {\n+\n+            MDef(short attrs, int funcIdx, int vtbleOffset, String name) {\n+                super(attrs, funcIdx, vtbleOffset, name);\n+            }\n+\n+            @Override\n+            public int computeContents(byte[] buffer, int initialPos) {\n+                int pos = initialPos;\n+                pos = CVUtil.putShort(attrs, buffer, pos);\n+                /* Two bytes of padding. */\n+                pos = CVUtil.putShort((short) 0, buffer, pos);\n+                pos = CVUtil.putInt(funcIdx, buffer, pos);\n+                if (hasVtableOffset()) {\n+                    assert vtbleOffset >= 0;\n+                    pos = CVUtil.putInt(vtbleOffset, buffer, pos);\n+                }\n+                return pos;\n+            }\n+        }\n+\n+        static final int INITIAL_CAPACITY = 10;\n+\n+        private final ArrayList<MDef> methods = new ArrayList<>(INITIAL_CAPACITY);\n+\n+        CVTypeMethodListRecord() {\n+            super(LF_METHODLIST);\n+        }\n+\n+        public void add(short attrs, int idx, int offset, String name) {\n+            methods.add(new MDef(attrs, idx, offset, name));\n+        }\n+\n+        public int count() {\n+            return methods.size();\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = initialPos;\n+            for (MDef f : methods) {\n+                pos = f.computeContents(buffer, pos);\n+            }\n+            return pos;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = type;\n+            h = 31 * h + methods.hashCode();\n+            return h;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (!super.equals(obj)) {\n+                return false;\n+            }\n+            CVTypeMethodListRecord other = (CVTypeMethodListRecord) obj;\n+            return this.methods.equals(other.methods);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LF_METHODLIST idx=0x%04x count=%d\", getSequenceNumber(), methods.size());\n+        }\n+    }\n+\n+    static String attrString(short attrs) {\n+        final StringBuilder sb = new StringBuilder();\n+\n+        /* Low byte. */\n+        if ((attrs & MPROP_PPP_MASK) != 0) {\n+            String[] aStr = {\"\", \"private\", \"protected\", \"public\"};\n+            sb.append(aStr[attrs & MPROP_PPP_MASK]);\n+        }\n+        if ((attrs & MPROP_VSF_MASK) != 0) {\n+            int p = (attrs & MPROP_VSF_MASK) >> 2;\n+            String[] pStr = {\"\", \" virtual\", \" static\", \" friend\", \" intro\", \" pure\", \" intro-pure\", \" (*7*)\"};\n+            sb.append(pStr[p]);\n+        }\n+        if ((attrs & MPROP_PSEUDO) != 0) {\n+            sb.append(\" pseudo\");\n+        }\n+        if ((attrs & MPROP_FINAL_CLASS) != 0) {\n+            sb.append(\" final-class\");\n+        }\n+        if ((attrs & MPROP_ABSTRACT) != 0) {\n+            sb.append(\" abstract\");\n+        }\n+        if ((attrs & MPROP_COMPGENX) != 0) {\n+            sb.append(\" compgenx\");\n+        }\n+        if ((attrs & MPROP_FINAL_METHOD) != 0) {\n+            sb.append(\" final-method\");\n+        }\n+        return sb.toString();\n+    }\n+\n+    abstract static class FieldRecord {\n+\n+        protected final short type;\n+        protected final short attrs; /* property attribute field (prop_t) */\n+        protected final String name;\n+\n+        protected FieldRecord(short leafType, short attrs, String name) {\n+            assert name != null;\n+            this.type = leafType;\n+            this.attrs = attrs;\n+            this.name = name;\n+        }\n+\n+        protected FieldRecord(short leafType) {\n+            this(leafType, (short) 0, \"\");\n+        }\n+\n+        public int computeSize() {\n+            return computeContents(null, 0);\n+        }\n+\n+        public abstract int computeContents(byte[] buffer, int initialPos);\n+\n+        @Override\n+        public int hashCode() {\n+            int h = type;\n+            h = 31 * h + attrs;\n+            h = 31 * h + name.hashCode();\n+            return h;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj == null || obj.getClass() != this.getClass()) {\n+                return false;\n+            }\n+            FieldRecord other = (FieldRecord) obj;\n+            return this.type == other.type && this.attrs == other.attrs && this.name.equals(other.name);\n+        }\n+    }\n+\n+    static final class CVOverloadedMethodRecord extends FieldRecord {\n+\n+        private final int methodListIndex; /* index of method list record */\n+        private final short count;\n+\n+        CVOverloadedMethodRecord(short count, int methodListIndex, String methodName) {\n+            super(LF_METHOD, (short) 0, methodName);\n+            this.methodListIndex = methodListIndex;\n+            this.count = count;\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putShort(type, buffer, initialPos);\n+            pos = CVUtil.putShort(count, buffer, pos);\n+            pos = CVUtil.putInt(methodListIndex, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(name, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LF_METHOD(0x%04x) count=0x%x listIdx=0x%04x %s\", type, count, methodListIndex, name);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = super.hashCode();\n+            h = 31 * h + methodListIndex;\n+            h = 31 + h + count;\n+            return h;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (!super.equals(obj)) {\n+                return false;\n+            }\n+            CVOverloadedMethodRecord other = (CVOverloadedMethodRecord) obj;\n+            return this.methodListIndex == other.methodListIndex && this.count == other.count;\n+        }\n+    }\n+\n+    static final class CVIndexRecord extends FieldRecord {\n+\n+        private final int index; /* index of continuation record */\n+\n+        CVIndexRecord(int index) {\n+            super(LF_INDEX);\n+            this.index = index;\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putShort(type, buffer, initialPos);\n+            pos = CVUtil.putShort((short) 0, buffer, pos); /* padding. */\n+            pos = CVUtil.putInt(index, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LF_INDEX(0x%04x) index=0x%04x\", type, index);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = super.hashCode();\n+            h = 31 * h + index;\n+            return h;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (!super.equals(obj)) {\n+                return false;\n+            }\n+            CVIndexRecord other = (CVIndexRecord) obj;\n+            return this.index == other.index;\n+        }\n+    }\n+\n+    static final class CVMemberRecord extends FieldRecord {\n+\n+        private final int underlyingTypeIndex; /* type index of member type */\n+        private int offset;\n+\n+        CVMemberRecord(short attrs, int underlyingTypeIndex, int offset, String name) {\n+            super(LF_MEMBER, attrs, name);\n+            this.underlyingTypeIndex = underlyingTypeIndex;\n+            this.offset = offset;\n+        }\n+\n+        public void setOffset(int offset) {\n+            this.offset = offset;\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putShort(type, buffer, initialPos);\n+            pos = CVUtil.putShort(attrs, buffer, pos);\n+            pos = CVUtil.putInt(underlyingTypeIndex, buffer, pos);\n+            pos = CVUtil.putLfNumeric(offset, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(name, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LF_MEMBER(0x%04x) attr=0x%x(%s) t=0x%x off=%d 0x%x %s\", type, attrs, attrString(attrs), underlyingTypeIndex, offset, offset & 0xffff, name);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = super.hashCode();\n+            h = 31 * h + underlyingTypeIndex;\n+            h = 31 * h + offset;\n+            return h;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (!super.equals(obj)) {\n+                return false;\n+            }\n+            CVMemberRecord other = (CVMemberRecord) obj;\n+            return this.offset == other.offset && this.underlyingTypeIndex == other.underlyingTypeIndex;\n+        }\n+    }\n+\n+    static final class CVStaticMemberRecord extends FieldRecord {\n+\n+        /* Type index of member type. */\n+        private final int underlyingTypeIndex;\n+\n+        CVStaticMemberRecord(short attrs, int underlyingTypeIndex, String name) {\n+            super(LF_STMEMBER, attrs, name);\n+            this.underlyingTypeIndex = underlyingTypeIndex;\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putShort(type, buffer, initialPos);\n+            pos = CVUtil.putShort(attrs, buffer, pos);\n+            pos = CVUtil.putInt(underlyingTypeIndex, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(name, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LF_STMEMBER(0x%04x) attr=0x%x(%s) t=0x%x %s\", type, attrs, attrString(attrs), underlyingTypeIndex, name);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = super.hashCode();\n+            h = 31 * h + underlyingTypeIndex;\n+            return h;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (!super.equals(obj)) {\n+                return false;\n+            }\n+            CVStaticMemberRecord other = (CVStaticMemberRecord) obj;\n+            return this.underlyingTypeIndex == other.underlyingTypeIndex;\n+        }\n+    }\n+\n+    static class CVOneMethodRecord extends FieldRecord {\n+\n+        protected final int funcIdx; /* type index of member type */\n+        protected final int vtbleOffset;\n+\n+        CVOneMethodRecord(short attrs, int funcIdx, int vtbleOffset, String name) {\n+            super(LF_ONEMETHOD, attrs, name);\n+            this.funcIdx = funcIdx;\n+            this.vtbleOffset = vtbleOffset;\n+        }\n+\n+        boolean hasVtableOffset() {\n+            return (attrs & MPROP_VSF_MASK) == MPROP_IVIRTUAL || (attrs & MPROP_VSF_MASK) == MPROP_PURE_IVIRTUAL;\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putShort(type, buffer, initialPos);\n+            pos = CVUtil.putShort(attrs, buffer, pos);\n+            pos = CVUtil.putInt(funcIdx, buffer, pos);\n+            if (hasVtableOffset()) {\n+                assert vtbleOffset >= 0;\n+                pos = CVUtil.putInt(vtbleOffset, buffer, pos);\n+            }\n+            pos = CVUtil.putUTF8StringBytes(name, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LF_ONEMETHOD(0x%04x) attr=0x%x(%s) funcIdx=0x%x vtbloffet=0x%x %s\", type, attrs, attrString(attrs), funcIdx, vtbleOffset, name);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = super.hashCode();\n+            h = 31 * h + funcIdx;\n+            h = 31 * h + vtbleOffset;\n+            return h;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (!super.equals(obj)) {\n+                return false;\n+            }\n+            CVOneMethodRecord other = (CVOneMethodRecord) obj;\n+            return this.vtbleOffset == other.vtbleOffset && this.funcIdx == other.funcIdx;\n+        }\n+    }\n+\n+    static class CVBaseMemberRecord extends FieldRecord {\n+\n+        private final int basetypeIndex; /* type index of member type */\n+        private final int offset; /* in java, usually 0 as there is no multiple inheritance. */\n+\n+        CVBaseMemberRecord(short attrs, int basetypeIndex, int offset) {\n+            super(LF_BCLASS, attrs, \"\");\n+            this.basetypeIndex = basetypeIndex;\n+            this.offset = offset;\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putShort(type, buffer, initialPos);\n+            pos = CVUtil.putShort(attrs, buffer, pos);\n+            pos = CVUtil.putInt(basetypeIndex, buffer, pos);\n+            pos = CVUtil.putLfNumeric(offset, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LF_BCLASS(0x%04x) attr=0x%04x(%s ?) baseIdx=0x%04x offset=0x%x\", LF_BCLASS, attrs, attrString(attrs), basetypeIndex, offset);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = super.hashCode();\n+            h = 31 * h + basetypeIndex;\n+            h = 31 * h + offset;\n+            return h;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (!super.equals(obj)) {\n+                return false;\n+            }\n+            CVBaseMemberRecord other = (CVBaseMemberRecord) obj;\n+            return this.basetypeIndex == other.basetypeIndex && this.offset == other.offset;\n+        }\n+    }\n+\n+    static class CVClassRecord extends CVTypeRecord {\n+\n+        static final int ATTR_FORWARD_REF = 0x0080;\n+        static final int ATTR_HAS_UNIQUENAME = 0x0200;\n+\n+        /* Count of number of elements in class field list. */\n+        private final short count;\n+\n+        /* Property attribute field (prop_t). */\n+        private final short propertyAttributes;\n+\n+        /* Type index of LF_FIELDLIST descriptor list. */\n+        private final int fieldIndex;\n+\n+        /* Type index of derived from list if not zero */\n+        /*\n+         * For Java, there is only one class, so LF_BCLASS is in the member list and\n+         * derivedFromIndex is 0.\n+         */\n+        private final int derivedFromIndex;\n+\n+        /* Type index of vshape table for this class. */\n+        private final int vshapeIndex;\n+\n+        /* Size (in bytes) of an instance. */\n+        private final long size;\n+\n+        /* Class name. */\n+        private final String className;\n+\n+        /* Linker class name. */\n+        private final String uniqueName;\n+\n+        CVClassRecord(short recType, short count, short attrs, int fieldIndex, int derivedFromIndex, int vshapeIndex, long size, String className, String uniqueName) {\n+            super(recType);\n+            this.count = count;\n+            this.propertyAttributes = (short) (attrs | (short) (uniqueName != null ? ATTR_HAS_UNIQUENAME : 0));\n+            this.fieldIndex = fieldIndex;\n+            this.derivedFromIndex = derivedFromIndex;\n+            this.vshapeIndex = vshapeIndex;\n+            this.size = size;\n+            this.className = className;\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        @SuppressWarnings(\"unused\")\n+        CVClassRecord(short count, short attrs, int fieldIndex, int derivedFromIndex, int vshapeIndex, long size, String className, String uniqueName) {\n+            this(LF_CLASS, count, attrs, fieldIndex, derivedFromIndex, vshapeIndex, size, className, uniqueName);\n+        }\n+\n+        CVClassRecord(short attrs, String className, String uniqueName) {\n+            this(LF_CLASS, (short) 0, attrs, 0, 0, 0, 0, className, uniqueName);\n+        }\n+\n+        String getClassName() {\n+            return className;\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putShort(count, buffer, initialPos);\n+            pos = CVUtil.putShort(propertyAttributes, buffer, pos);\n+            pos = CVUtil.putInt(fieldIndex, buffer, pos);\n+            pos = CVUtil.putInt(derivedFromIndex, buffer, pos);\n+            pos = CVUtil.putInt(vshapeIndex, buffer, pos);\n+            pos = CVUtil.putLfNumeric(size, buffer, pos);\n+            String fixedName = CVNames.typeNameToCodeViewName(className);\n+            pos = CVUtil.putUTF8StringBytes(fixedName, buffer, pos);\n+            if (hasUniqueName()) {\n+                assert uniqueName != null;\n+                pos = CVUtil.putUTF8StringBytes(uniqueName, buffer, pos);\n+            }\n+            return pos;\n+        }\n+\n+        boolean isForwardRef() {\n+            return (propertyAttributes & ATTR_FORWARD_REF) != 0;\n+        }\n+\n+        @SuppressWarnings(\"unused\")\n+        public boolean hasUniqueName() {\n+            return (propertyAttributes & ATTR_HAS_UNIQUENAME) != 0;\n+        }\n+\n+        protected String toString(String lfTypeStr) {\n+            return String.format(\"%s 0x%04x count=%d attr=0x%x(%s) fld=0x%x super=0x%x vshape=0x%x size=%d %s%s\", lfTypeStr, getSequenceNumber(), count, propertyAttributes,\n+                            propertyString(propertyAttributes), fieldIndex, derivedFromIndex,\n+                            vshapeIndex, size, className, uniqueName != null ? \" (\" + uniqueName + \")\" : \"\");\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return toString(\"LF_CLASS\");\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = type;\n+            h = 31 * h + count;\n+            h = 31 * h + propertyAttributes;\n+            h = 31 * h + fieldIndex;\n+            h = 31 * h + derivedFromIndex;\n+            h = 31 * h + (int) size;\n+            h = 31 * h + className.hashCode();\n+            if (uniqueName != null) {\n+                h = 31 * h + uniqueName.hashCode();\n+            }\n+            h = 31 * h + vshapeIndex;\n+            return h;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (!super.equals(obj)) {\n+                return false;\n+            }\n+            CVClassRecord other = (CVClassRecord) obj;\n+            return this.count == other.count && this.propertyAttributes == other.propertyAttributes && this.fieldIndex == other.fieldIndex && this.derivedFromIndex == other.derivedFromIndex &&\n+                            this.size == other.size && this.className.equals(other.className) && (this.uniqueName != null ? this.uniqueName.equals(other.uniqueName) : other.uniqueName == null) &&\n+                            this.vshapeIndex == other.vshapeIndex;\n+        }\n+    }\n+\n+    static final class CVFieldListRecord extends CVTypeRecord {\n+\n+        static final int INITIAL_CAPACITY = 10;\n+\n+        /* Size includes type field but not record length field. */\n+        private int estimatedSize = CVUtil.align4(Short.BYTES);\n+\n+        private final ArrayList<FieldRecord> members = new ArrayList<>(INITIAL_CAPACITY);\n+\n+        CVFieldListRecord() {\n+            super(LF_FIELDLIST);\n+        }\n+\n+        void add(FieldRecord m) {\n+            /* Keep a running total. */\n+            estimatedSize += CVUtil.align4(m.computeSize());\n+            members.add(m);\n+        }\n+\n+        int getEstimatedSize() {\n+            return estimatedSize;\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = initialPos;\n+            for (FieldRecord field : members) {\n+                pos = field.computeContents(buffer, pos);\n+                pos = CVTypeRecord.alignPadded4(buffer, pos);\n+            }\n+            return pos;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int hash = type;\n+            hash = 31 * hash + members.hashCode();\n+            return hash;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (!super.equals(obj)) {\n+                return false;\n+            }\n+            CVFieldListRecord other = (CVFieldListRecord) obj;\n+            return this.members.equals(other.members);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LF_FIELDLIST idx=0x%x count=%d\", getSequenceNumber(), members.size());\n+        }\n+    }\n+\n+    static final class CVTypeArrayRecord extends CVTypeRecord {\n+\n+        private final int elementTypeIndex;\n+        private final int indexType;\n+        private final int length;\n+        private final String name;\n+\n+        CVTypeArrayRecord(int elementTypeIndex, int indexType, int length, String name) {\n+            super(LF_ARRAY);\n+            this.elementTypeIndex = elementTypeIndex;\n+            this.indexType = indexType;\n+            this.length = length;\n+            this.name = name;\n+        }\n+\n+        CVTypeArrayRecord(int elementTypeIndex, int indexType, int length) {\n+            this(elementTypeIndex, indexType, length, \"\");\n+        }\n+\n+        @SuppressWarnings(\"unused\")\n+        CVTypeArrayRecord(int elementTypeIndex, int length) {\n+            this(elementTypeIndex, T_UINT8, length);\n+        }\n+\n+        @SuppressWarnings(\"unused\")\n+        CVTypeArrayRecord(CVTypeRecord elementType, int length) {\n+            this(elementType.getSequenceNumber(), T_UINT8, length);\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(elementTypeIndex, buffer, initialPos);\n+            pos = CVUtil.putInt(indexType, buffer, pos);\n+            pos = CVUtil.putLfNumeric(length, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(name, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LF_ARRAY 0x%04x type=0x%04x len=%d indexType=0x%04x%s\", getSequenceNumber(), elementTypeIndex, length, indexType, name.isEmpty() ? \"\" : \"name=\" + name);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = type;\n+            h = 31 * h + elementTypeIndex;\n+            h = 31 * h + indexType;\n+            h = 31 * h + length;\n+            h = 31 * h + name.hashCode();\n+            return h;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (!super.equals(obj)) {\n+                return false;\n+            }\n+            CVTypeArrayRecord other = (CVTypeArrayRecord) obj;\n+            return this.elementTypeIndex == other.elementTypeIndex && this.indexType == other.indexType && this.length == other.length && this.name.equals(other.name);\n+        }\n+    }\n+\n+    static String propertyString(int properties) {\n+        final StringBuilder sb = new StringBuilder();\n+\n+        /* Low byte. */\n+        if ((properties & 0x0001) != 0) {\n+            sb.append(\" packed\");\n+        }\n+        if ((properties & 0x0002) != 0) {\n+            sb.append(\" ctor\");\n+        }\n+        if ((properties & 0x0004) != 0) {\n+            sb.append(\" ovlops\");\n+        }\n+        if ((properties & 0x0008) != 0) {\n+            sb.append(\" isnested\");\n+        }\n+        if ((properties & 0x0010) != 0) {\n+            sb.append(\" cnested\");\n+        }\n+        if ((properties & 0x0020) != 0) {\n+            sb.append(\" opassign\");\n+        }\n+        if ((properties & 0x0040) != 0) {\n+            sb.append(\" opcast\");\n+        }\n+        if ((properties & 0x0080) != 0) {\n+            sb.append(\" forwardref\");\n+        }\n+\n+        /* High byte. */\n+        if ((properties & 0x0100) != 0) {\n+            sb.append(\" scope\");\n+        }\n+        if ((properties & 0x0200) != 0) {\n+            sb.append(\" hasuniquename\");\n+        }\n+        if ((properties & 0x0400) != 0) {\n+            sb.append(\" sealed\");\n+        }\n+        if ((properties & 0x1800) != 0) {\n+            sb.append(\" hfa...\");\n+        }\n+        if ((properties & 0x2000) != 0) {\n+            sb.append(\" intrinsic\");\n+        }\n+        if ((properties & 0xc000) != 0) {\n+            sb.append(\" macom...\");\n+        }\n+        return sb.toString();\n+    }\n }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ1NjE2MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r510456160", "body": "Since the builder already ensures that this is only called if `fileBlocks` is not empty, this is not a problem at the moment, but I think that `0` may not be the best choice because it is a valid `fileId`.\r\n\r\nPerhaps it would be better to simply assert here that `fileBlocks` is not empty and expect the caller to take care of it.\r\n```suggestion\r\n        assert !fileBlocks.isEmpty();\r\n        return fileBlocks.get(fileBlocks.size() - 1).fileId;\r\n```", "bodyText": "Since the builder already ensures that this is only called if fileBlocks is not empty, this is not a problem at the moment, but I think that 0 may not be the best choice because it is a valid fileId.\nPerhaps it would be better to simply assert here that fileBlocks is not empty and expect the caller to take care of it.\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return fileBlocks.isEmpty() ? 0 : fileBlocks.get(fileBlocks.size() - 1).fileId;\n          \n          \n            \n                    assert !fileBlocks.isEmpty();\n          \n          \n            \n                    return fileBlocks.get(fileBlocks.size() - 1).fileId;", "bodyHTML": "<p dir=\"auto\">Since the builder already ensures that this is only called if <code>fileBlocks</code> is not empty, this is not a problem at the moment, but I think that <code>0</code> may not be the best choice because it is a valid <code>fileId</code>.</p>\n<p dir=\"auto\">Perhaps it would be better to simply assert here that <code>fileBlocks</code> is not empty and expect the caller to take care of it.</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k x x-first\">return</span><span class=\"x x-last\"> </span>fileBlocks<span class=\"pl-k\">.</span>isEmpty()<span class=\"x x-first\"> </span><span class=\"pl-k x\">?</span><span class=\"x\"> </span><span class=\"pl-c1 x\">0</span><span class=\"x\"> </span><span class=\"pl-k x\">:</span><span class=\"x\"> fileBlocks</span><span class=\"pl-k x\">.</span><span class=\"x\">get(fileBlocks</span><span class=\"pl-k x\">.</span><span class=\"x\">size() </span><span class=\"pl-k x\">-</span><span class=\"x\"> </span><span class=\"pl-c1 x\">1</span><span class=\"x\">)</span><span class=\"pl-k x\">.</span><span class=\"x x-last\">fileId</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k x x-first\">assert</span><span class=\"x\"> </span><span class=\"pl-k x x-last\">!</span>fileBlocks<span class=\"pl-k\">.</span>isEmpty();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">return</span> fileBlocks<span class=\"pl-k\">.</span>get(fileBlocks<span class=\"pl-k\">.</span>size() <span class=\"pl-k\">-</span> <span class=\"pl-c1\">1</span>)<span class=\"pl-k\">.</span>fileId;</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pejovica", "createdAt": "2020-10-22T21:04:30Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A line record (DEBUG_S_LINES) consists of a list of (file block record + subrecords).\n+ * Graal will generate one CVLineRecord per function.\n+ */\n+final class CVLineRecord extends CVSymbolRecord {\n+\n+    /* Header: addr (4 bytes):section (2 bytes) flags (2 bytes) chunck length (4 bytes). */\n+    private static final int LINE_RECORD_HEADER_SIZE = Integer.BYTES + Short.BYTES * 2 + Integer.BYTES;\n+\n+    private static final int DEFAULT_LINE_BLOCK_COUNT = 100;\n+    private static final int DEFAULT_LINE_ENTRY_COUNT = 100;\n+\n+    /* Has columns flag = 0x80 - not supported. */\n+    private static final short CB_HAS_NO_COLUMNS_FLAG = 0x00;\n+\n+    private String symbolName;\n+    private ArrayList<FileBlock> fileBlocks = new ArrayList<>(DEFAULT_LINE_BLOCK_COUNT);\n+\n+    CVLineRecord(CVDebugInfo cvDebugInfo, String symbolName) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_LINES);\n+        this.symbolName = symbolName;\n+    }\n+\n+    void addNewFile(int fileId) {\n+        fileBlocks.add(new FileBlock(fileId));\n+    }\n+\n+    void addNewLine(int addr, int line) {\n+        fileBlocks.get(fileBlocks.size() - 1).addEntry(new LineEntry(addr, line));\n+    }\n+\n+    int getCurrentFileId() {\n+        return fileBlocks.isEmpty() ? 0 : fileBlocks.get(fileBlocks.size() - 1).fileId;", "originalCommit": "79594415eb46dc9a9729d50486c7f8d8f1d0e61c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDgzMjY0MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r510832640", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-10-23T11:58:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ1NjE2MA=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\nindex c97d80a1499..090f30fe4ac 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n", "chunk": "@@ -62,7 +62,8 @@ final class CVLineRecord extends CVSymbolRecord {\n     }\n \n     int getCurrentFileId() {\n-        return fileBlocks.isEmpty() ? 0 : fileBlocks.get(fileBlocks.size() - 1).fileId;\n+        assert !fileBlocks.isEmpty();\n+        return fileBlocks.get(fileBlocks.size() - 1).fileId;\n     }\n \n     @Override\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ2NTM2Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r510465367", "body": "Similarly here. Since the builder already ensures that `lineEntries` is not empty, it's not a problem at the moment, but I think `0` would be the wrong value if only the last file block was empty.\r\n\r\nSo, again, it might be better to simply assert here that `lineEntries` is not empty and expect the caller to take care of it.\r\n```suggestion\r\n            assert !lineEntries.isEmpty();\r\n            return lineEntries.get(lineEntries.size() - 1).addr;\r\n```", "bodyText": "Similarly here. Since the builder already ensures that lineEntries is not empty, it's not a problem at the moment, but I think 0 would be the wrong value if only the last file block was empty.\nSo, again, it might be better to simply assert here that lineEntries is not empty and expect the caller to take care of it.\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return lineEntries.isEmpty() ? 0 : lineEntries.get(lineEntries.size() - 1).addr;\n          \n          \n            \n                        assert !lineEntries.isEmpty();\n          \n          \n            \n                        return lineEntries.get(lineEntries.size() - 1).addr;", "bodyHTML": "<p dir=\"auto\">Similarly here. Since the builder already ensures that <code>lineEntries</code> is not empty, it's not a problem at the moment, but I think <code>0</code> would be the wrong value if only the last file block was empty.</p>\n<p dir=\"auto\">So, again, it might be better to simply assert here that <code>lineEntries</code> is not empty and expect the caller to take care of it.</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-k x x-first\">return</span><span class=\"x x-last\"> </span>lineEntries<span class=\"pl-k\">.</span>isEmpty()<span class=\"x x-first\"> </span><span class=\"pl-k x\">?</span><span class=\"x\"> </span><span class=\"pl-c1 x\">0</span><span class=\"x\"> </span><span class=\"pl-k x\">:</span><span class=\"x\"> lineEntries</span><span class=\"pl-k x\">.</span><span class=\"x\">get(lineEntries</span><span class=\"pl-k x\">.</span><span class=\"x\">size() </span><span class=\"pl-k x\">-</span><span class=\"x\"> </span><span class=\"pl-c1 x\">1</span><span class=\"x\">)</span><span class=\"pl-k x\">.</span><span class=\"x x-last\">addr</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            <span class=\"pl-k x x-first\">assert</span><span class=\"x\"> </span><span class=\"pl-k x x-last\">!</span>lineEntries<span class=\"pl-k\">.</span>isEmpty();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            <span class=\"pl-k\">return</span> lineEntries<span class=\"pl-k\">.</span>get(lineEntries<span class=\"pl-k\">.</span>size() <span class=\"pl-k\">-</span> <span class=\"pl-c1\">1</span>)<span class=\"pl-k\">.</span>addr;</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pejovica", "createdAt": "2020-10-22T21:22:11Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A line record (DEBUG_S_LINES) consists of a list of (file block record + subrecords).\n+ * Graal will generate one CVLineRecord per function.\n+ */\n+final class CVLineRecord extends CVSymbolRecord {\n+\n+    /* Header: addr (4 bytes):section (2 bytes) flags (2 bytes) chunck length (4 bytes). */\n+    private static final int LINE_RECORD_HEADER_SIZE = Integer.BYTES + Short.BYTES * 2 + Integer.BYTES;\n+\n+    private static final int DEFAULT_LINE_BLOCK_COUNT = 100;\n+    private static final int DEFAULT_LINE_ENTRY_COUNT = 100;\n+\n+    /* Has columns flag = 0x80 - not supported. */\n+    private static final short CB_HAS_NO_COLUMNS_FLAG = 0x00;\n+\n+    private String symbolName;\n+    private ArrayList<FileBlock> fileBlocks = new ArrayList<>(DEFAULT_LINE_BLOCK_COUNT);\n+\n+    CVLineRecord(CVDebugInfo cvDebugInfo, String symbolName) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_LINES);\n+        this.symbolName = symbolName;\n+    }\n+\n+    void addNewFile(int fileId) {\n+        fileBlocks.add(new FileBlock(fileId));\n+    }\n+\n+    void addNewLine(int addr, int line) {\n+        fileBlocks.get(fileBlocks.size() - 1).addEntry(new LineEntry(addr, line));\n+    }\n+\n+    int getCurrentFileId() {\n+        return fileBlocks.isEmpty() ? 0 : fileBlocks.get(fileBlocks.size() - 1).fileId;\n+    }\n+\n+    @Override\n+    protected int computeSize(int initialPos) {\n+        return computeContents(null, initialPos);\n+    }\n+\n+    @Override\n+    protected int computeContents(byte[] buffer, int initialPos) {\n+        /* Line record header. */\n+        int pos = computeHeader(buffer, initialPos);\n+        /* All blocks. */\n+        for (FileBlock fileBlock : fileBlocks) {\n+            pos = fileBlock.computeContents(buffer, pos);\n+        }\n+        return pos;\n+    }\n+\n+    private int computeHeader(byte[] buffer, int initialPos) {\n+\n+        if (buffer == null) {\n+            return initialPos + LINE_RECORD_HEADER_SIZE;\n+        }\n+\n+        assert symbolName != null;\n+        int pos = initialPos;\n+\n+        /* Emit addr:section relocation records. */\n+        cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, symbolName, false, 1L);\n+        pos = CVUtil.putInt(0, buffer, pos);\n+        cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, symbolName, false, 1L);\n+        pos = CVUtil.putShort((short) 0, buffer, pos);\n+\n+        /* Emit flags. */\n+        pos = CVUtil.putShort(CB_HAS_NO_COLUMNS_FLAG, buffer, pos);\n+\n+        /* Length of this chunk in object file (= highAddr since it's zero based. */\n+        int length = fileBlocks.isEmpty() ? 0 : fileBlocks.get(fileBlocks.size() - 1).getHighAddr();\n+        pos = CVUtil.putInt(length, buffer, pos);\n+        return pos;\n+    }\n+\n+    boolean isEmpty() {\n+        return fileBlocks.isEmpty();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVLineRecord(type=0x%04x pos=0x%05x size=0x%d)\", type, recordStartPosition, fileBlocks.size());\n+    }\n+\n+    /*\n+     * FileBlock is a section of contiguous code in a compilation unit, associated with a single\n+     * source file. If a function includes inlined code, that code needs its own FileBlock,\n+     * surrounded by FileBlocks describing the enclosing source file. A FileBlock consists of a list\n+     * of LineEntries.\n+     */\n+    private static class FileBlock {\n+\n+        /* Fileblock header: fileId (4 bytes) lineEntry count (4 bytes) tablesize (4 bytes) */\n+        static final int FILE_BLOCK_HEADER_SIZE = Integer.BYTES * 3;\n+\n+        private ArrayList<LineEntry> lineEntries = new ArrayList<>(DEFAULT_LINE_ENTRY_COUNT);\n+        private int fileId;\n+\n+        FileBlock(int fileId) {\n+            this.fileId = fileId;\n+        }\n+\n+        void addEntry(LineEntry le) {\n+            lineEntries.add(le);\n+        }\n+\n+        int computeContents(byte[] buffer, int initialPos) {\n+            if (buffer == null) {\n+                return computeSize(initialPos);\n+            }\n+            int pos = initialPos;\n+            pos = CVUtil.putInt(fileId, buffer, pos);\n+            pos = CVUtil.putInt(lineEntries.size(), buffer, pos);\n+            pos = CVUtil.putInt(computeSize(0), buffer, pos);\n+            for (LineEntry lineEntry : lineEntries) {\n+                pos = lineEntry.computeContents(buffer, pos);\n+            }\n+            return pos;\n+        }\n+\n+        int computeSize(int initialPos) {\n+            return initialPos + FILE_BLOCK_HEADER_SIZE + LineEntry.LINE_ENTRY_SIZE * lineEntries.size();\n+        }\n+\n+        int getHighAddr() {\n+            return lineEntries.isEmpty() ? 0 : lineEntries.get(lineEntries.size() - 1).addr;", "originalCommit": "79594415eb46dc9a9729d50486c7f8d8f1d0e61c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDgzOTE0OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r510839148", "bodyText": "Done. (and another assert at line 104).", "author": "stooke", "createdAt": "2020-10-23T12:11:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ2NTM2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\nindex c97d80a1499..090f30fe4ac 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java\n", "chunk": "@@ -155,7 +157,8 @@ final class CVLineRecord extends CVSymbolRecord {\n         }\n \n         int getHighAddr() {\n-            return lineEntries.isEmpty() ? 0 : lineEntries.get(lineEntries.size() - 1).addr;\n+            assert !lineEntries.isEmpty();\n+            return lineEntries.get(lineEntries.size() - 1).addr;\n         }\n     }\n \n", "next_change": null}]}}, {"oid": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "url": "https://github.com/oracle/graal/commit/f50a7b99b286efa7c5dafccc49b5c4add62af841", "message": "Add Windows PE/COFF debug information prototype", "committedDate": "2020-10-23T15:29:44Z", "type": "commit"}, {"oid": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "url": "https://github.com/oracle/graal/commit/f50a7b99b286efa7c5dafccc49b5c4add62af841", "message": "Add Windows PE/COFF debug information prototype", "committedDate": "2020-10-23T15:29:44Z", "type": "forcePushed"}]}