{"pr_number": 183, "pr_title": "Status json code locations", "pr_createdAt": "2020-06-04T16:53:42Z", "pr_url": "https://github.com/blackducksoftware/synopsys-detect/pull/183", "merge_commit": "a19768f37c93a9f20c341018fa53b1b0a1ef93c9", "timeline": [{"oid": "73d77215e6404c86314b9dc86aee3d6d8eb993be", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/73d77215e6404c86314b9dc86aee3d6d8eb993be", "message": "feat: Incorporate code location data from all tools into status.json file (IDETECT-2035)", "committedDate": "2020-06-02T22:27:10Z", "type": "commit"}, {"oid": "bceb8e6212fed3082d20be6ad97643970517f875", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/bceb8e6212fed3082d20be6ad97643970517f875", "message": "fix: Revert BazelExtractor", "committedDate": "2020-06-04T16:38:45Z", "type": "commit"}, {"oid": "1f5b0dc60a91e1f1c15d9faaeb3e635c1b408072", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/1f5b0dc60a91e1f1c15d9faaeb3e635c1b408072", "message": "fix: Remove unnecessary comment", "committedDate": "2020-06-04T16:45:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxOTAwNA==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/183#discussion_r435419004", "body": "I don't like that this is called \"collectCodeLocationNames\" when it really \"creates\" code location names. ", "bodyText": "I don't like that this is called \"collectCodeLocationNames\" when it really \"creates\" code location names.", "bodyHTML": "<p dir=\"auto\">I don't like that this is called \"collectCodeLocationNames\" when it really \"creates\" code location names.</p>", "author": "taikuukaits", "createdAt": "2020-06-04T17:15:22Z", "path": "src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java", "diffHunk": "@@ -409,4 +414,14 @@ private void runBlackDuckProduct(final ProductRunData productRunData, final Dete\n         }\n     }\n \n+    private Set<String> collectCodeLocationNames(DetectableToolResult detectableToolResult, CodeLocationNameManager codeLocationNameManager, DirectoryManager directoryManager) {", "originalCommit": "1f5b0dc60a91e1f1c15d9faaeb3e635c1b408072", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1MDk5Mw==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/183#discussion_r435450993", "bodyText": "that seems like a reasonable renaming", "author": "crowleySynopsys", "createdAt": "2020-06-04T18:09:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxOTAwNA=="}], "type": "inlineReview", "revised_code": {"commit": "77f5bc128db3ea50db4eca2b4b70abec3af00b35", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\nindex 05e2ee37f..15bcda8b3 100644\n--- a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n", "chunk": "@@ -414,7 +414,7 @@ public class RunManager {\n         }\n     }\n \n-    private Set<String> collectCodeLocationNames(DetectableToolResult detectableToolResult, CodeLocationNameManager codeLocationNameManager, DirectoryManager directoryManager) {\n+    private Set<String> createCodeLocationNames(DetectableToolResult detectableToolResult, CodeLocationNameManager codeLocationNameManager, DirectoryManager directoryManager) {\n         if (detectableToolResult.getDetectToolProjectInfo().isPresent()) {\n             NameVersion projectNameVersion = detectableToolResult.getDetectToolProjectInfo().get().getSuggestedNameVersion();\n             return detectableToolResult.getDetectCodeLocations().stream()\n", "next_change": null}]}, "revised_code_in_main": {"commit": "a19768f37c93a9f20c341018fa53b1b0a1ef93c9", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\nindex 05e2ee37f..d2cf38574 100644\n--- a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n", "chunk": "@@ -414,7 +414,7 @@ public class RunManager {\n         }\n     }\n \n-    private Set<String> collectCodeLocationNames(DetectableToolResult detectableToolResult, CodeLocationNameManager codeLocationNameManager, DirectoryManager directoryManager) {\n+    private Set<String> createCodeLocationNames(DetectableToolResult detectableToolResult, CodeLocationNameManager codeLocationNameManager, DirectoryManager directoryManager) {\n         if (detectableToolResult.getDetectToolProjectInfo().isPresent()) {\n             NameVersion projectNameVersion = detectableToolResult.getDetectToolProjectInfo().get().getSuggestedNameVersion();\n             return detectableToolResult.getDetectCodeLocations().stream()\n", "next_change": {"commit": "4ce0d86b56ba026bc4817429dff2165ec4c84501", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\nindex d2cf38574..18b57fcee 100644\n--- a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n", "chunk": "@@ -414,14 +413,4 @@ public class RunManager {\n         }\n     }\n \n-    private Set<String> createCodeLocationNames(DetectableToolResult detectableToolResult, CodeLocationNameManager codeLocationNameManager, DirectoryManager directoryManager) {\n-        if (detectableToolResult.getDetectToolProjectInfo().isPresent()) {\n-            NameVersion projectNameVersion = detectableToolResult.getDetectToolProjectInfo().get().getSuggestedNameVersion();\n-            return detectableToolResult.getDetectCodeLocations().stream()\n-                       .map(detectCodeLocation -> codeLocationNameManager.createCodeLocationName(detectCodeLocation, directoryManager.getSourceDirectory(), projectNameVersion.getName(), projectNameVersion.getVersion(), null, null))\n-                       .collect(Collectors.toSet());\n-        }\n-        return new HashSet<>();\n-    }\n-\n }\n", "next_change": {"commit": "16b2a37284b600bbc93fff3228fc82398e32b8c1", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\nindex 18b57fcee..d8d9d8daf 100644\n--- a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n", "chunk": "@@ -413,4 +418,14 @@ public class RunManager {\n         }\n     }\n \n+    private Set<String> createCodeLocationNames(DetectableToolResult detectableToolResult, CodeLocationNameManager codeLocationNameManager, DirectoryManager directoryManager) {\n+        if (detectableToolResult.getDetectToolProjectInfo().isPresent()) {\n+            NameVersion projectNameVersion = detectableToolResult.getDetectToolProjectInfo().get().getSuggestedNameVersion();\n+            return detectableToolResult.getDetectCodeLocations().stream()\n+                       .map(detectCodeLocation -> codeLocationNameManager.createCodeLocationName(detectCodeLocation, directoryManager.getSourceDirectory(), projectNameVersion.getName(), projectNameVersion.getVersion(), null, null))\n+                       .collect(Collectors.toSet());\n+        }\n+        return new HashSet<>();\n+    }\n+\n }\n", "next_change": {"commit": "07dc7418d99917974facb437535917728c7533d2", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\nindex d8d9d8daf..8a5861371 100644\n--- a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n", "chunk": "@@ -418,14 +465,4 @@ public class RunManager {\n         }\n     }\n \n-    private Set<String> createCodeLocationNames(DetectableToolResult detectableToolResult, CodeLocationNameManager codeLocationNameManager, DirectoryManager directoryManager) {\n-        if (detectableToolResult.getDetectToolProjectInfo().isPresent()) {\n-            NameVersion projectNameVersion = detectableToolResult.getDetectToolProjectInfo().get().getSuggestedNameVersion();\n-            return detectableToolResult.getDetectCodeLocations().stream()\n-                       .map(detectCodeLocation -> codeLocationNameManager.createCodeLocationName(detectCodeLocation, directoryManager.getSourceDirectory(), projectNameVersion.getName(), projectNameVersion.getVersion(), null, null))\n-                       .collect(Collectors.toSet());\n-        }\n-        return new HashSet<>();\n-    }\n-\n }\n", "next_change": {"commit": "4f2ba16d878930a66019d4584570a1ab4b962aeb", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\nindex 8a5861371..fbc7482d1 100644\n--- a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n", "chunk": "@@ -345,124 +347,128 @@ public class RunManager {\n         BdioResult bdioResult = bdioManager.createBdioFiles(bdioOptions, aggregateOptions, projectNameVersion, runResult.getDetectCodeLocations(), runOptions.shouldUseBdio2());\n         eventSystem.publishEvent(Event.DetectCodeLocationNamesCalculated, bdioResult.getCodeLocationNamesResult());\n \n-        CodeLocationAccumulator codeLocationAccumulator = new CodeLocationAccumulator();\n-        if (!bdioResult.getUploadTargets().isEmpty()) {\n-            logger.info(String.format(\"Created %d BDIO files.\", bdioResult.getUploadTargets().size()));\n-            if (blackDuckRunData.isOnline()) {\n-                logger.debug(\"Uploading BDIO files.\");\n-                BlackDuckServicesFactory blackDuckServicesFactory = onlineBlackDuckRunData.getBlackDuckServicesFactory();\n-                DetectBdioUploadService detectBdioUploadService = new DetectBdioUploadService();\n-                CodeLocationCreationData<UploadBatchOutput> uploadBatchOutputCodeLocationCreationData = detectBdioUploadService.uploadBdioFiles(bdioResult, blackDuckServicesFactory.createBdioUploadService(), blackDuckServicesFactory.createBdio2UploadService());\n-                codeLocationAccumulator.addWaitableCodeLocation(uploadBatchOutputCodeLocationCreationData);\n-            }\n+        if (runOptions.shouldPerformDeveloperModeScan()) {\n+            logger.info(ReportConstants.RUN_SEPARATOR);\n+            BlackDuckDeveloperMode developerMode = new BlackDuckDeveloperMode(blackDuckRunData, blackDuckServicesFactory, detectConfigurationFactory);\n+            List<DeveloperScanComponentResultView> results = developerMode.run(bdioResult);\n+            BlackDuckDeveloperPostActions postActions = new BlackDuckDeveloperPostActions(gson, eventSystem, directoryManager);\n+            postActions.perform(projectNameVersion, results);\n         } else {\n-            logger.debug(\"Did not create any BDIO files.\");\n-        }\n-\n-        logger.debug(\"Completed Detect Code Location processing.\");\n-\n-        logger.info(ReportConstants.RUN_SEPARATOR);\n-        if (detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN)) {\n-            logger.info(\"Will include the signature scanner tool.\");\n-            BlackDuckSignatureScannerOptions blackDuckSignatureScannerOptions = detectConfigurationFactory.createBlackDuckSignatureScannerOptions();\n-            BlackDuckSignatureScannerTool blackDuckSignatureScannerTool = new BlackDuckSignatureScannerTool(blackDuckSignatureScannerOptions, detectContext);\n-            BlackDuckServerConfig blackDuckServerConfig = null;\n-            CodeLocationCreationService codeLocationCreationService = null;\n-            if (blackDuckRunData.isOnline()) {\n-                BlackDuckServicesFactory blackDuckServicesFactory = onlineBlackDuckRunData.getBlackDuckServicesFactory();\n-                codeLocationCreationService = blackDuckServicesFactory.createCodeLocationCreationService();\n-                blackDuckServerConfig = onlineBlackDuckRunData.getBlackDuckServerConfig();\n+            CodeLocationAccumulator codeLocationAccumulator = new CodeLocationAccumulator();\n+            if (!bdioResult.getUploadTargets().isEmpty()) {\n+                logger.info(String.format(\"Created %d BDIO files.\", bdioResult.getUploadTargets().size()));\n+                if (null != blackDuckServicesFactory) {\n+                    logger.debug(\"Uploading BDIO files.\");\n+                    DetectBdioUploadService detectBdioUploadService = new DetectBdioUploadService();\n+                    CodeLocationCreationData<UploadBatchOutput> uploadBatchOutputCodeLocationCreationData = detectBdioUploadService.uploadBdioFiles(bdioResult, blackDuckServicesFactory);\n+                    codeLocationAccumulator.addWaitableCodeLocation(uploadBatchOutputCodeLocationCreationData);\n+                }\n+            } else {\n+                logger.debug(\"Did not create any BDIO files.\");\n             }\n-            SignatureScannerToolResult signatureScannerToolResult = blackDuckSignatureScannerTool.runScanTool(codeLocationCreationService, blackDuckServerConfig, projectNameVersion, runResult.getDockerTar());\n-            if (signatureScannerToolResult.getResult() == Result.SUCCESS && signatureScannerToolResult.getCreationData().isPresent()) {\n-                codeLocationAccumulator.addWaitableCodeLocation(signatureScannerToolResult.getCreationData().get());\n-            } else if (signatureScannerToolResult.getResult() != Result.SUCCESS) {\n-                eventSystem.publishEvent(Event.StatusSummary, new Status(\"SIGNATURE_SCAN\", StatusType.FAILURE));\n-                eventSystem.publishEvent(Event.Issue, new DetectIssue(DetectIssueType.SIGNATURE_SCANNER, Arrays.asList(signatureScannerToolResult.getResult().toString())));\n+\n+            logger.debug(\"Completed Detect Code Location processing.\");\n+\n+            logger.info(ReportConstants.RUN_SEPARATOR);\n+            if (detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN)) {\n+                logger.info(\"Will include the signature scanner tool.\");\n+                BlackDuckSignatureScannerOptions blackDuckSignatureScannerOptions = detectConfigurationFactory.createBlackDuckSignatureScannerOptions();\n+                BlackDuckSignatureScannerTool blackDuckSignatureScannerTool = new BlackDuckSignatureScannerTool(blackDuckSignatureScannerOptions, detectContext);\n+                SignatureScannerToolResult signatureScannerToolResult = blackDuckSignatureScannerTool.runScanTool(blackDuckRunData, projectNameVersion, runResult.getDockerTar());\n+                if (signatureScannerToolResult.getResult() == Result.SUCCESS && signatureScannerToolResult.getCreationData().isPresent()) {\n+                    codeLocationAccumulator.addWaitableCodeLocation(signatureScannerToolResult.getCreationData().get());\n+                } else if (signatureScannerToolResult.getResult() != Result.SUCCESS) {\n+                    eventSystem.publishEvent(Event.StatusSummary, new Status(\"SIGNATURE_SCAN\", StatusType.FAILURE));\n+                    eventSystem.publishEvent(Event.Issue, new DetectIssue(DetectIssueType.SIGNATURE_SCANNER, Arrays.asList(signatureScannerToolResult.getResult().toString())));\n+                }\n+                logger.info(\"Signature scanner actions finished.\");\n+            } else {\n+                logger.info(\"Signature scan tool will not be run.\");\n             }\n-            logger.info(\"Signature scanner actions finished.\");\n-        } else {\n-            logger.info(\"Signature scan tool will not be run.\");\n-        }\n \n-        logger.info(ReportConstants.RUN_SEPARATOR);\n-        if (detectToolFilter.shouldInclude(DetectTool.BINARY_SCAN)) {\n-            logger.info(\"Will include the binary scanner tool.\");\n-            if (blackDuckRunData.isOnline()) {\n-                BlackDuckServicesFactory blackDuckServicesFactory = onlineBlackDuckRunData.getBlackDuckServicesFactory();\n-                BinaryScanOptions binaryScanOptions = detectConfigurationFactory.createBinaryScanOptions();\n-                BlackDuckBinaryScannerTool blackDuckBinaryScanner = new BlackDuckBinaryScannerTool(eventSystem, codeLocationNameManager, directoryManager, new WildcardFileFinder(), binaryScanOptions, blackDuckServicesFactory.createBinaryScanUploadService());\n-                if (blackDuckBinaryScanner.shouldRun()) {\n-                    BinaryScanToolResult result = blackDuckBinaryScanner.performBinaryScanActions(projectNameVersion);\n-                    if (result.isSuccessful()) {\n-                        codeLocationAccumulator.addWaitableCodeLocation(result.getCodeLocationCreationData());\n+            logger.info(ReportConstants.RUN_SEPARATOR);\n+            if (detectToolFilter.shouldInclude(DetectTool.BINARY_SCAN)) {\n+                logger.info(\"Will include the binary scanner tool.\");\n+                if (null != blackDuckServicesFactory) {\n+                    BinaryScanOptions binaryScanOptions = detectConfigurationFactory.createBinaryScanOptions();\n+                    BlackDuckBinaryScannerTool blackDuckBinaryScanner = new BlackDuckBinaryScannerTool(eventSystem, codeLocationNameManager, directoryManager, new WildcardFileFinder(), binaryScanOptions, blackDuckServicesFactory);\n+                    if (blackDuckBinaryScanner.shouldRun()) {\n+                        BinaryScanToolResult result = blackDuckBinaryScanner.performBinaryScanActions(projectNameVersion);\n+                        if (result.isSuccessful()) {\n+                            codeLocationAccumulator.addWaitableCodeLocation(result.getCodeLocationCreationData());\n+                        }\n                     }\n                 }\n+                logger.info(\"Binary scanner actions finished.\");\n+            } else {\n+                logger.info(\"Binary scan tool will not be run.\");\n             }\n-            logger.info(\"Binary scanner actions finished.\");\n-        } else {\n-            logger.info(\"Binary scan tool will not be run.\");\n-        }\n \n-        logger.info(ReportConstants.RUN_SEPARATOR);\n-        BlackDuckImpactAnalysisTool blackDuckImpactAnalysisTool;\n-        if (blackDuckRunData.isOnline()) {\n-            BlackDuckServicesFactory blackDuckServicesFactory = onlineBlackDuckRunData.getBlackDuckServicesFactory();\n-            ImpactAnalysisBatchRunner impactAnalysisBatchRunner = new ImpactAnalysisBatchRunner(blackDuckServicesFactory.getLogger(), blackDuckServicesFactory.getBlackDuckApiClient(), new NoThreadExecutorService(), blackDuckServicesFactory.getGson());\n-            ImpactAnalysisUploadService impactAnalysisUploadService = new ImpactAnalysisUploadService(impactAnalysisBatchRunner, blackDuckServicesFactory.createCodeLocationCreationService());\n-            blackDuckImpactAnalysisTool = BlackDuckImpactAnalysisTool.ONLINE(directoryManager, codeLocationNameManager, impactAnalysisOptions, blackDuckServicesFactory.getBlackDuckApiClient(), impactAnalysisUploadService, blackDuckServicesFactory.createCodeLocationService(), eventSystem);\n-        } else {\n-            blackDuckImpactAnalysisTool = BlackDuckImpactAnalysisTool.OFFLINE(directoryManager, codeLocationNameManager, impactAnalysisOptions, eventSystem);\n-        }\n-        if (detectToolFilter.shouldInclude(DetectTool.IMPACT_ANALYSIS) && blackDuckImpactAnalysisTool.shouldRun()) {\n-            logger.info(\"Will include the Vulnerability Impact Analysis tool.\");\n-            ImpactAnalysisToolResult impactAnalysisToolResult = blackDuckImpactAnalysisTool.performImpactAnalysisActions(projectNameVersion, projectVersionWrapper);\n+            logger.info(ReportConstants.RUN_SEPARATOR);\n+            BlackDuckImpactAnalysisTool blackDuckImpactAnalysisTool;\n+            if (null != blackDuckServicesFactory) {\n+                blackDuckImpactAnalysisTool = BlackDuckImpactAnalysisTool.ONLINE(directoryManager, codeLocationNameManager, impactAnalysisOptions, blackDuckServicesFactory, eventSystem);\n+            } else {\n+                blackDuckImpactAnalysisTool = BlackDuckImpactAnalysisTool.OFFLINE(directoryManager, codeLocationNameManager, impactAnalysisOptions, eventSystem);\n+            }\n+            if (detectToolFilter.shouldInclude(DetectTool.IMPACT_ANALYSIS) && blackDuckImpactAnalysisTool.shouldRun()) {\n+                logger.info(\"Will include the Vulnerability Impact Analysis tool.\");\n+                ImpactAnalysisToolResult impactAnalysisToolResult = blackDuckImpactAnalysisTool.performImpactAnalysisActions(projectNameVersion, projectVersionWrapper);\n+\n+                /* TODO: There is currently no mechanism within Black Duck for checking the completion status of an Impact Analysis code location. Waiting should happen here when such a mechanism exists. See HUB-25142. JM - 08/2020 */\n+                codeLocationAccumulator.addNonWaitableCodeLocation(impactAnalysisToolResult.getCodeLocationNames());\n \n-            /* TODO: There is currently no mechanism within Black Duck for checking the completion status of an Impact Analysis code location. Waiting should happen here when such a mechanism exists. See HUB-25142. JM - 08/2020 */\n-            codeLocationAccumulator.addNonWaitableCodeLocation(impactAnalysisToolResult.getCodeLocationNames());\n+                if (impactAnalysisToolResult.isSuccessful()) {\n+                    logger.info(\"Vulnerability Impact Analysis successful.\");\n+                } else {\n+                    logger.warn(\"Something went wrong with the Vulnerability Impact Analysis tool.\");\n+                }\n \n-            if (impactAnalysisToolResult.isSuccessful()) {\n-                logger.info(\"Vulnerability Impact Analysis successful.\");\n+                logger.info(\"Vulnerability Impact Analysis tool actions finished.\");\n+            } else if (blackDuckImpactAnalysisTool.shouldRun()) {\n+                logger.info(\"Vulnerability Impact Analysis tool is enabled but will not run due to tool configuration.\");\n             } else {\n-                logger.warn(\"Something went wrong with the Vulnerability Impact Analysis tool.\");\n+                logger.info(\"Vulnerability Impact Analysis tool will not be run.\");\n             }\n \n-            logger.info(\"Vulnerability Impact Analysis tool actions finished.\");\n-        } else if (blackDuckImpactAnalysisTool.shouldRun()) {\n-            logger.info(\"Vulnerability Impact Analysis tool is enabled but will not run due to tool configuration.\");\n-        } else {\n-            logger.info(\"Vulnerability Impact Analysis tool will not be run.\");\n-        }\n-\n-        logger.info(ReportConstants.RUN_SEPARATOR);\n-        //We have finished code locations.\n-        CodeLocationResultCalculator waitCalculator = new CodeLocationResultCalculator();\n-        CodeLocationResults codeLocationResults = waitCalculator.calculateCodeLocationResults(codeLocationAccumulator);\n-        eventSystem.publishEvent(Event.CodeLocationsCompleted, codeLocationResults.getAllCodeLocationNames());\n-\n-        if (blackDuckRunData.isOnline()) {\n-            logger.info(\"Will perform Black Duck post actions.\");\n-            BlackDuckServicesFactory blackDuckServicesFactory = onlineBlackDuckRunData.getBlackDuckServicesFactory();\n-            BlackDuckPostOptions blackDuckPostOptions = detectConfigurationFactory.createBlackDuckPostOptions();\n-            BlackDuckPostActions blackDuckPostActions = new BlackDuckPostActions(blackDuckServicesFactory.createCodeLocationCreationService(), eventSystem, blackDuckServicesFactory.getBlackDuckApiClient(),\n-                blackDuckServicesFactory.createProjectBomService(), blackDuckServicesFactory.createReportService(detectConfigurationFactory.findTimeoutInSeconds() * 1000));\n-            blackDuckPostActions.perform(blackDuckPostOptions, codeLocationResults.getCodeLocationWaitData(), projectVersionWrapper, projectNameVersion, detectConfigurationFactory.findTimeoutInSeconds());\n-\n-            if ((!bdioResult.getUploadTargets().isEmpty() || detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN))) {\n-                Optional<String> componentsLink = Optional.ofNullable(projectVersionWrapper)\n-                                                      .map(ProjectVersionWrapper::getProjectVersionView)\n-                                                      .flatMap(projectVersionView -> projectVersionView.getFirstLinkSafely(ProjectVersionView.COMPONENTS_LINK))\n-                                                      .map(HttpUrl::string);\n-\n-                if (componentsLink.isPresent()) {\n-                    DetectResult detectResult = new BlackDuckBomDetectResult(componentsLink.get());\n-                    eventSystem.publishEvent(Event.ResultProduced, detectResult);\n+            logger.info(ReportConstants.RUN_SEPARATOR);\n+            //We have finished code locations.\n+            CodeLocationResultCalculator waitCalculator = new CodeLocationResultCalculator();\n+            CodeLocationResults codeLocationResults = waitCalculator.calculateCodeLocationResults(codeLocationAccumulator);\n+            eventSystem.publishEvent(Event.CodeLocationsCompleted, codeLocationResults.getAllCodeLocationNames());\n+\n+            if (null != blackDuckServicesFactory) {\n+                logger.info(\"Will perform Black Duck post actions.\");\n+                BlackDuckPostOptions blackDuckPostOptions = detectConfigurationFactory.createBlackDuckPostOptions();\n+                BlackDuckPostActions blackDuckPostActions = new BlackDuckPostActions(blackDuckServicesFactory, eventSystem);\n+                blackDuckPostActions.perform(blackDuckPostOptions, codeLocationResults.getCodeLocationWaitData(), projectVersionWrapper, projectNameVersion, detectConfigurationFactory.findTimeoutInSeconds());\n+\n+                if ((!bdioResult.getUploadTargets().isEmpty() || detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN))) {\n+                    Optional<String> componentsLink = Optional.ofNullable(projectVersionWrapper)\n+                                                          .map(ProjectVersionWrapper::getProjectVersionView)\n+                                                          .flatMap(projectVersionView -> projectVersionView.getFirstLinkSafely(ProjectVersionView.COMPONENTS_LINK))\n+                                                          .map(HttpUrl::string);\n+\n+                    if (componentsLink.isPresent()) {\n+                        DetectResult detectResult = new BlackDuckBomDetectResult(componentsLink.get());\n+                        eventSystem.publishEvent(Event.ResultProduced, detectResult);\n+                    }\n                 }\n+                logger.info(\"Black Duck actions have finished.\");\n+            } else {\n+                logger.debug(\"Will not perform Black Duck post actions: Detect is not online.\");\n             }\n-            logger.info(\"Black Duck actions have finished.\");\n-        } else {\n-            logger.debug(\"Will not perform Black Duck post actions: Detect is not online.\");\n         }\n     }\n \n+    private Set<String> createCodeLocationNames(DetectableToolResult detectableToolResult, CodeLocationNameManager codeLocationNameManager, DirectoryManager directoryManager) {\n+        if (detectableToolResult.getDetectToolProjectInfo().isPresent()) {\n+            NameVersion projectNameVersion = detectableToolResult.getDetectToolProjectInfo().get().getSuggestedNameVersion();\n+            return detectableToolResult.getDetectCodeLocations().stream()\n+                       .map(detectCodeLocation -> codeLocationNameManager.createCodeLocationName(detectCodeLocation, directoryManager.getSourceDirectory(), projectNameVersion.getName(), projectNameVersion.getVersion(), null, null))\n+                       .collect(Collectors.toSet());\n+        }\n+        return new HashSet<>();\n+    }\n+\n }\n", "next_change": {"commit": "b746ab8169a39089379db85a218c89398a097da8", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\nindex fbc7482d1..814ed7c05 100644\n--- a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n", "chunk": "@@ -347,128 +339,124 @@ public class RunManager {\n         BdioResult bdioResult = bdioManager.createBdioFiles(bdioOptions, aggregateOptions, projectNameVersion, runResult.getDetectCodeLocations(), runOptions.shouldUseBdio2());\n         eventSystem.publishEvent(Event.DetectCodeLocationNamesCalculated, bdioResult.getCodeLocationNamesResult());\n \n-        if (runOptions.shouldPerformDeveloperModeScan()) {\n-            logger.info(ReportConstants.RUN_SEPARATOR);\n-            BlackDuckDeveloperMode developerMode = new BlackDuckDeveloperMode(blackDuckRunData, blackDuckServicesFactory, detectConfigurationFactory);\n-            List<DeveloperScanComponentResultView> results = developerMode.run(bdioResult);\n-            BlackDuckDeveloperPostActions postActions = new BlackDuckDeveloperPostActions(gson, eventSystem, directoryManager);\n-            postActions.perform(projectNameVersion, results);\n-        } else {\n-            CodeLocationAccumulator codeLocationAccumulator = new CodeLocationAccumulator();\n-            if (!bdioResult.getUploadTargets().isEmpty()) {\n-                logger.info(String.format(\"Created %d BDIO files.\", bdioResult.getUploadTargets().size()));\n-                if (null != blackDuckServicesFactory) {\n-                    logger.debug(\"Uploading BDIO files.\");\n-                    DetectBdioUploadService detectBdioUploadService = new DetectBdioUploadService();\n-                    CodeLocationCreationData<UploadBatchOutput> uploadBatchOutputCodeLocationCreationData = detectBdioUploadService.uploadBdioFiles(bdioResult, blackDuckServicesFactory);\n-                    codeLocationAccumulator.addWaitableCodeLocation(uploadBatchOutputCodeLocationCreationData);\n-                }\n-            } else {\n-                logger.debug(\"Did not create any BDIO files.\");\n+        CodeLocationAccumulator codeLocationAccumulator = new CodeLocationAccumulator();\n+        if (!bdioResult.getUploadTargets().isEmpty()) {\n+            logger.info(String.format(\"Created %d BDIO files.\", bdioResult.getUploadTargets().size()));\n+            if (blackDuckRunData.isOnline()) {\n+                logger.debug(\"Uploading BDIO files.\");\n+                BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n+                DetectBdioUploadService detectBdioUploadService = new DetectBdioUploadService();\n+                CodeLocationCreationData<UploadBatchOutput> uploadBatchOutputCodeLocationCreationData = detectBdioUploadService.uploadBdioFiles(bdioResult, blackDuckServicesFactory.createBdioUploadService(), blackDuckServicesFactory.createBdio2UploadService());\n+                codeLocationAccumulator.addWaitableCodeLocation(uploadBatchOutputCodeLocationCreationData);\n             }\n+        } else {\n+            logger.debug(\"Did not create any BDIO files.\");\n+        }\n \n-            logger.debug(\"Completed Detect Code Location processing.\");\n-\n-            logger.info(ReportConstants.RUN_SEPARATOR);\n-            if (detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN)) {\n-                logger.info(\"Will include the signature scanner tool.\");\n-                BlackDuckSignatureScannerOptions blackDuckSignatureScannerOptions = detectConfigurationFactory.createBlackDuckSignatureScannerOptions();\n-                BlackDuckSignatureScannerTool blackDuckSignatureScannerTool = new BlackDuckSignatureScannerTool(blackDuckSignatureScannerOptions, detectContext);\n-                SignatureScannerToolResult signatureScannerToolResult = blackDuckSignatureScannerTool.runScanTool(blackDuckRunData, projectNameVersion, runResult.getDockerTar());\n-                if (signatureScannerToolResult.getResult() == Result.SUCCESS && signatureScannerToolResult.getCreationData().isPresent()) {\n-                    codeLocationAccumulator.addWaitableCodeLocation(signatureScannerToolResult.getCreationData().get());\n-                } else if (signatureScannerToolResult.getResult() != Result.SUCCESS) {\n-                    eventSystem.publishEvent(Event.StatusSummary, new Status(\"SIGNATURE_SCAN\", StatusType.FAILURE));\n-                    eventSystem.publishEvent(Event.Issue, new DetectIssue(DetectIssueType.SIGNATURE_SCANNER, Arrays.asList(signatureScannerToolResult.getResult().toString())));\n-                }\n-                logger.info(\"Signature scanner actions finished.\");\n-            } else {\n-                logger.info(\"Signature scan tool will not be run.\");\n+        logger.debug(\"Completed Detect Code Location processing.\");\n+\n+        logger.info(ReportConstants.RUN_SEPARATOR);\n+        if (detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN)) {\n+            logger.info(\"Will include the signature scanner tool.\");\n+            BlackDuckSignatureScannerOptions blackDuckSignatureScannerOptions = detectConfigurationFactory.createBlackDuckSignatureScannerOptions();\n+            BlackDuckSignatureScannerTool blackDuckSignatureScannerTool = new BlackDuckSignatureScannerTool(blackDuckSignatureScannerOptions, detectContext);\n+            BlackDuckServerConfig blackDuckServerConfig = null;\n+            CodeLocationCreationService codeLocationCreationService = null;\n+            if (blackDuckRunData.isOnline()) {\n+                BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n+                codeLocationCreationService = blackDuckServicesFactory.createCodeLocationCreationService();\n+                blackDuckServerConfig = blackDuckRunData.getBlackDuckServerConfig();\n             }\n+            SignatureScannerToolResult signatureScannerToolResult = blackDuckSignatureScannerTool.runScanTool(codeLocationCreationService, blackDuckServerConfig, projectNameVersion, runResult.getDockerTar());\n+            if (signatureScannerToolResult.getResult() == Result.SUCCESS && signatureScannerToolResult.getCreationData().isPresent()) {\n+                codeLocationAccumulator.addWaitableCodeLocation(signatureScannerToolResult.getCreationData().get());\n+            } else if (signatureScannerToolResult.getResult() != Result.SUCCESS) {\n+                eventSystem.publishEvent(Event.StatusSummary, new Status(\"SIGNATURE_SCAN\", StatusType.FAILURE));\n+                eventSystem.publishEvent(Event.Issue, new DetectIssue(DetectIssueType.SIGNATURE_SCANNER, Arrays.asList(signatureScannerToolResult.getResult().toString())));\n+            }\n+            logger.info(\"Signature scanner actions finished.\");\n+        } else {\n+            logger.info(\"Signature scan tool will not be run.\");\n+        }\n \n-            logger.info(ReportConstants.RUN_SEPARATOR);\n-            if (detectToolFilter.shouldInclude(DetectTool.BINARY_SCAN)) {\n-                logger.info(\"Will include the binary scanner tool.\");\n-                if (null != blackDuckServicesFactory) {\n-                    BinaryScanOptions binaryScanOptions = detectConfigurationFactory.createBinaryScanOptions();\n-                    BlackDuckBinaryScannerTool blackDuckBinaryScanner = new BlackDuckBinaryScannerTool(eventSystem, codeLocationNameManager, directoryManager, new WildcardFileFinder(), binaryScanOptions, blackDuckServicesFactory);\n-                    if (blackDuckBinaryScanner.shouldRun()) {\n-                        BinaryScanToolResult result = blackDuckBinaryScanner.performBinaryScanActions(projectNameVersion);\n-                        if (result.isSuccessful()) {\n-                            codeLocationAccumulator.addWaitableCodeLocation(result.getCodeLocationCreationData());\n-                        }\n+        logger.info(ReportConstants.RUN_SEPARATOR);\n+        if (detectToolFilter.shouldInclude(DetectTool.BINARY_SCAN)) {\n+            logger.info(\"Will include the binary scanner tool.\");\n+            if (blackDuckRunData.isOnline()) {\n+                BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n+                BinaryScanOptions binaryScanOptions = detectConfigurationFactory.createBinaryScanOptions();\n+                BlackDuckBinaryScannerTool blackDuckBinaryScanner = new BlackDuckBinaryScannerTool(eventSystem, codeLocationNameManager, directoryManager, new WildcardFileFinder(), binaryScanOptions, blackDuckServicesFactory.createBinaryScanUploadService());\n+                if (blackDuckBinaryScanner.shouldRun()) {\n+                    BinaryScanToolResult result = blackDuckBinaryScanner.performBinaryScanActions(projectNameVersion);\n+                    if (result.isSuccessful()) {\n+                        codeLocationAccumulator.addWaitableCodeLocation(result.getCodeLocationCreationData());\n                     }\n                 }\n-                logger.info(\"Binary scanner actions finished.\");\n-            } else {\n-                logger.info(\"Binary scan tool will not be run.\");\n-            }\n-\n-            logger.info(ReportConstants.RUN_SEPARATOR);\n-            BlackDuckImpactAnalysisTool blackDuckImpactAnalysisTool;\n-            if (null != blackDuckServicesFactory) {\n-                blackDuckImpactAnalysisTool = BlackDuckImpactAnalysisTool.ONLINE(directoryManager, codeLocationNameManager, impactAnalysisOptions, blackDuckServicesFactory, eventSystem);\n-            } else {\n-                blackDuckImpactAnalysisTool = BlackDuckImpactAnalysisTool.OFFLINE(directoryManager, codeLocationNameManager, impactAnalysisOptions, eventSystem);\n             }\n-            if (detectToolFilter.shouldInclude(DetectTool.IMPACT_ANALYSIS) && blackDuckImpactAnalysisTool.shouldRun()) {\n-                logger.info(\"Will include the Vulnerability Impact Analysis tool.\");\n-                ImpactAnalysisToolResult impactAnalysisToolResult = blackDuckImpactAnalysisTool.performImpactAnalysisActions(projectNameVersion, projectVersionWrapper);\n+            logger.info(\"Binary scanner actions finished.\");\n+        } else {\n+            logger.info(\"Binary scan tool will not be run.\");\n+        }\n \n-                /* TODO: There is currently no mechanism within Black Duck for checking the completion status of an Impact Analysis code location. Waiting should happen here when such a mechanism exists. See HUB-25142. JM - 08/2020 */\n-                codeLocationAccumulator.addNonWaitableCodeLocation(impactAnalysisToolResult.getCodeLocationNames());\n+        logger.info(ReportConstants.RUN_SEPARATOR);\n+        BlackDuckImpactAnalysisTool blackDuckImpactAnalysisTool;\n+        if (blackDuckRunData.isOnline()) {\n+            BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n+            ImpactAnalysisBatchRunner impactAnalysisBatchRunner = new ImpactAnalysisBatchRunner(blackDuckServicesFactory.getLogger(), blackDuckServicesFactory.getBlackDuckApiClient(), new NoThreadExecutorService(), blackDuckServicesFactory.getGson());\n+            ImpactAnalysisUploadService impactAnalysisUploadService = new ImpactAnalysisUploadService(impactAnalysisBatchRunner, blackDuckServicesFactory.createCodeLocationCreationService());\n+            blackDuckImpactAnalysisTool = BlackDuckImpactAnalysisTool.ONLINE(directoryManager, codeLocationNameManager, impactAnalysisOptions, blackDuckServicesFactory.getBlackDuckApiClient(), impactAnalysisUploadService, blackDuckServicesFactory.createCodeLocationService(), eventSystem);\n+        } else {\n+            blackDuckImpactAnalysisTool = BlackDuckImpactAnalysisTool.OFFLINE(directoryManager, codeLocationNameManager, impactAnalysisOptions, eventSystem);\n+        }\n+        if (detectToolFilter.shouldInclude(DetectTool.IMPACT_ANALYSIS) && blackDuckImpactAnalysisTool.shouldRun()) {\n+            logger.info(\"Will include the Vulnerability Impact Analysis tool.\");\n+            ImpactAnalysisToolResult impactAnalysisToolResult = blackDuckImpactAnalysisTool.performImpactAnalysisActions(projectNameVersion, projectVersionWrapper);\n \n-                if (impactAnalysisToolResult.isSuccessful()) {\n-                    logger.info(\"Vulnerability Impact Analysis successful.\");\n-                } else {\n-                    logger.warn(\"Something went wrong with the Vulnerability Impact Analysis tool.\");\n-                }\n+            /* TODO: There is currently no mechanism within Black Duck for checking the completion status of an Impact Analysis code location. Waiting should happen here when such a mechanism exists. See HUB-25142. JM - 08/2020 */\n+            codeLocationAccumulator.addNonWaitableCodeLocation(impactAnalysisToolResult.getCodeLocationNames());\n \n-                logger.info(\"Vulnerability Impact Analysis tool actions finished.\");\n-            } else if (blackDuckImpactAnalysisTool.shouldRun()) {\n-                logger.info(\"Vulnerability Impact Analysis tool is enabled but will not run due to tool configuration.\");\n+            if (impactAnalysisToolResult.isSuccessful()) {\n+                logger.info(\"Vulnerability Impact Analysis successful.\");\n             } else {\n-                logger.info(\"Vulnerability Impact Analysis tool will not be run.\");\n+                logger.warn(\"Something went wrong with the Vulnerability Impact Analysis tool.\");\n             }\n \n-            logger.info(ReportConstants.RUN_SEPARATOR);\n-            //We have finished code locations.\n-            CodeLocationResultCalculator waitCalculator = new CodeLocationResultCalculator();\n-            CodeLocationResults codeLocationResults = waitCalculator.calculateCodeLocationResults(codeLocationAccumulator);\n-            eventSystem.publishEvent(Event.CodeLocationsCompleted, codeLocationResults.getAllCodeLocationNames());\n-\n-            if (null != blackDuckServicesFactory) {\n-                logger.info(\"Will perform Black Duck post actions.\");\n-                BlackDuckPostOptions blackDuckPostOptions = detectConfigurationFactory.createBlackDuckPostOptions();\n-                BlackDuckPostActions blackDuckPostActions = new BlackDuckPostActions(blackDuckServicesFactory, eventSystem);\n-                blackDuckPostActions.perform(blackDuckPostOptions, codeLocationResults.getCodeLocationWaitData(), projectVersionWrapper, projectNameVersion, detectConfigurationFactory.findTimeoutInSeconds());\n-\n-                if ((!bdioResult.getUploadTargets().isEmpty() || detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN))) {\n-                    Optional<String> componentsLink = Optional.ofNullable(projectVersionWrapper)\n-                                                          .map(ProjectVersionWrapper::getProjectVersionView)\n-                                                          .flatMap(projectVersionView -> projectVersionView.getFirstLinkSafely(ProjectVersionView.COMPONENTS_LINK))\n-                                                          .map(HttpUrl::string);\n-\n-                    if (componentsLink.isPresent()) {\n-                        DetectResult detectResult = new BlackDuckBomDetectResult(componentsLink.get());\n-                        eventSystem.publishEvent(Event.ResultProduced, detectResult);\n-                    }\n-                }\n-                logger.info(\"Black Duck actions have finished.\");\n-            } else {\n-                logger.debug(\"Will not perform Black Duck post actions: Detect is not online.\");\n-            }\n+            logger.info(\"Vulnerability Impact Analysis tool actions finished.\");\n+        } else if (blackDuckImpactAnalysisTool.shouldRun()) {\n+            logger.info(\"Vulnerability Impact Analysis tool is enabled but will not run due to tool configuration.\");\n+        } else {\n+            logger.info(\"Vulnerability Impact Analysis tool will not be run.\");\n         }\n-    }\n \n-    private Set<String> createCodeLocationNames(DetectableToolResult detectableToolResult, CodeLocationNameManager codeLocationNameManager, DirectoryManager directoryManager) {\n-        if (detectableToolResult.getDetectToolProjectInfo().isPresent()) {\n-            NameVersion projectNameVersion = detectableToolResult.getDetectToolProjectInfo().get().getSuggestedNameVersion();\n-            return detectableToolResult.getDetectCodeLocations().stream()\n-                       .map(detectCodeLocation -> codeLocationNameManager.createCodeLocationName(detectCodeLocation, directoryManager.getSourceDirectory(), projectNameVersion.getName(), projectNameVersion.getVersion(), null, null))\n-                       .collect(Collectors.toSet());\n+        logger.info(ReportConstants.RUN_SEPARATOR);\n+        //We have finished code locations.\n+        CodeLocationResultCalculator waitCalculator = new CodeLocationResultCalculator();\n+        CodeLocationResults codeLocationResults = waitCalculator.calculateCodeLocationResults(codeLocationAccumulator);\n+        eventSystem.publishEvent(Event.CodeLocationsCompleted, codeLocationResults.getAllCodeLocationNames());\n+\n+        if (blackDuckRunData.isOnline()) {\n+            logger.info(\"Will perform Black Duck post actions.\");\n+            BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n+            BlackDuckPostOptions blackDuckPostOptions = detectConfigurationFactory.createBlackDuckPostOptions();\n+            BlackDuckPostActions blackDuckPostActions = new BlackDuckPostActions(blackDuckServicesFactory.createCodeLocationCreationService(), eventSystem, blackDuckServicesFactory.getBlackDuckApiClient(),\n+                blackDuckServicesFactory.createProjectBomService(), blackDuckServicesFactory.createReportService(detectConfigurationFactory.findTimeoutInSeconds() * 1000));\n+            blackDuckPostActions.perform(blackDuckPostOptions, codeLocationResults.getCodeLocationWaitData(), projectVersionWrapper, projectNameVersion, detectConfigurationFactory.findTimeoutInSeconds());\n+\n+            if ((!bdioResult.getUploadTargets().isEmpty() || detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN))) {\n+                Optional<String> componentsLink = Optional.ofNullable(projectVersionWrapper)\n+                                                      .map(ProjectVersionWrapper::getProjectVersionView)\n+                                                      .flatMap(projectVersionView -> projectVersionView.getFirstLinkSafely(ProjectVersionView.COMPONENTS_LINK))\n+                                                      .map(HttpUrl::string);\n+\n+                if (componentsLink.isPresent()) {\n+                    DetectResult detectResult = new BlackDuckBomDetectResult(componentsLink.get());\n+                    eventSystem.publishEvent(Event.ResultProduced, detectResult);\n+                }\n+            }\n+            logger.info(\"Black Duck actions have finished.\");\n+        } else {\n+            logger.debug(\"Will not perform Black Duck post actions: Detect is not online.\");\n         }\n-        return new HashSet<>();\n     }\n \n }\n", "next_change": {"commit": "8d5e738bae67fc7d53e266c08b1a551631efef04", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\nindex 814ed7c05..749ffade6 100644\n--- a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n", "chunk": "@@ -339,124 +347,128 @@ public class RunManager {\n         BdioResult bdioResult = bdioManager.createBdioFiles(bdioOptions, aggregateOptions, projectNameVersion, runResult.getDetectCodeLocations(), runOptions.shouldUseBdio2());\n         eventSystem.publishEvent(Event.DetectCodeLocationNamesCalculated, bdioResult.getCodeLocationNamesResult());\n \n-        CodeLocationAccumulator codeLocationAccumulator = new CodeLocationAccumulator();\n-        if (!bdioResult.getUploadTargets().isEmpty()) {\n-            logger.info(String.format(\"Created %d BDIO files.\", bdioResult.getUploadTargets().size()));\n-            if (blackDuckRunData.isOnline()) {\n-                logger.debug(\"Uploading BDIO files.\");\n-                BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n-                DetectBdioUploadService detectBdioUploadService = new DetectBdioUploadService();\n-                CodeLocationCreationData<UploadBatchOutput> uploadBatchOutputCodeLocationCreationData = detectBdioUploadService.uploadBdioFiles(bdioResult, blackDuckServicesFactory.createBdioUploadService(), blackDuckServicesFactory.createBdio2UploadService());\n-                codeLocationAccumulator.addWaitableCodeLocation(uploadBatchOutputCodeLocationCreationData);\n-            }\n+        if (runOptions.shouldPerformDeveloperModeScan()) {\n+            logger.info(ReportConstants.RUN_SEPARATOR);\n+            BlackDuckDeveloperMode developerMode = new BlackDuckDeveloperMode(blackDuckRunData, blackDuckServicesFactory, detectConfigurationFactory);\n+            List<DeveloperScanComponentResultView> results = developerMode.run(bdioResult);\n+            BlackDuckDeveloperPostActions postActions = new BlackDuckDeveloperPostActions(gson, eventSystem, directoryManager);\n+            postActions.perform(projectNameVersion, results);\n         } else {\n-            logger.debug(\"Did not create any BDIO files.\");\n-        }\n-\n-        logger.debug(\"Completed Detect Code Location processing.\");\n-\n-        logger.info(ReportConstants.RUN_SEPARATOR);\n-        if (detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN)) {\n-            logger.info(\"Will include the signature scanner tool.\");\n-            BlackDuckSignatureScannerOptions blackDuckSignatureScannerOptions = detectConfigurationFactory.createBlackDuckSignatureScannerOptions();\n-            BlackDuckSignatureScannerTool blackDuckSignatureScannerTool = new BlackDuckSignatureScannerTool(blackDuckSignatureScannerOptions, detectContext);\n-            BlackDuckServerConfig blackDuckServerConfig = null;\n-            CodeLocationCreationService codeLocationCreationService = null;\n-            if (blackDuckRunData.isOnline()) {\n-                BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n-                codeLocationCreationService = blackDuckServicesFactory.createCodeLocationCreationService();\n-                blackDuckServerConfig = blackDuckRunData.getBlackDuckServerConfig();\n+            CodeLocationAccumulator codeLocationAccumulator = new CodeLocationAccumulator();\n+            if (!bdioResult.getUploadTargets().isEmpty()) {\n+                logger.info(String.format(\"Created %d BDIO files.\", bdioResult.getUploadTargets().size()));\n+                if (null != blackDuckServicesFactory) {\n+                    logger.debug(\"Uploading BDIO files.\");\n+                    DetectBdioUploadService detectBdioUploadService = new DetectBdioUploadService();\n+                    CodeLocationCreationData<UploadBatchOutput> uploadBatchOutputCodeLocationCreationData = detectBdioUploadService.uploadBdioFiles(bdioResult, blackDuckServicesFactory);\n+                    codeLocationAccumulator.addWaitableCodeLocation(uploadBatchOutputCodeLocationCreationData);\n+                }\n+            } else {\n+                logger.debug(\"Did not create any BDIO files.\");\n             }\n-            SignatureScannerToolResult signatureScannerToolResult = blackDuckSignatureScannerTool.runScanTool(codeLocationCreationService, blackDuckServerConfig, projectNameVersion, runResult.getDockerTar());\n-            if (signatureScannerToolResult.getResult() == Result.SUCCESS && signatureScannerToolResult.getCreationData().isPresent()) {\n-                codeLocationAccumulator.addWaitableCodeLocation(signatureScannerToolResult.getCreationData().get());\n-            } else if (signatureScannerToolResult.getResult() != Result.SUCCESS) {\n-                eventSystem.publishEvent(Event.StatusSummary, new Status(\"SIGNATURE_SCAN\", StatusType.FAILURE));\n-                eventSystem.publishEvent(Event.Issue, new DetectIssue(DetectIssueType.SIGNATURE_SCANNER, Arrays.asList(signatureScannerToolResult.getResult().toString())));\n+\n+            logger.debug(\"Completed Detect Code Location processing.\");\n+\n+            logger.info(ReportConstants.RUN_SEPARATOR);\n+            if (detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN)) {\n+                logger.info(\"Will include the signature scanner tool.\");\n+                BlackDuckSignatureScannerOptions blackDuckSignatureScannerOptions = detectConfigurationFactory.createBlackDuckSignatureScannerOptions();\n+                BlackDuckSignatureScannerTool blackDuckSignatureScannerTool = new BlackDuckSignatureScannerTool(blackDuckSignatureScannerOptions, detectContext);\n+                SignatureScannerToolResult signatureScannerToolResult = blackDuckSignatureScannerTool.runScanTool(blackDuckRunData, projectNameVersion, runResult.getDockerTar());\n+                if (signatureScannerToolResult.getResult() == Result.SUCCESS && signatureScannerToolResult.getCreationData().isPresent()) {\n+                    codeLocationAccumulator.addWaitableCodeLocation(signatureScannerToolResult.getCreationData().get());\n+                } else if (signatureScannerToolResult.getResult() != Result.SUCCESS) {\n+                    eventSystem.publishEvent(Event.StatusSummary, new Status(\"SIGNATURE_SCAN\", StatusType.FAILURE));\n+                    eventSystem.publishEvent(Event.Issue, new DetectIssue(DetectIssueType.SIGNATURE_SCANNER, Arrays.asList(signatureScannerToolResult.getResult().toString())));\n+                }\n+                logger.info(\"Signature scanner actions finished.\");\n+            } else {\n+                logger.info(\"Signature scan tool will not be run.\");\n             }\n-            logger.info(\"Signature scanner actions finished.\");\n-        } else {\n-            logger.info(\"Signature scan tool will not be run.\");\n-        }\n \n-        logger.info(ReportConstants.RUN_SEPARATOR);\n-        if (detectToolFilter.shouldInclude(DetectTool.BINARY_SCAN)) {\n-            logger.info(\"Will include the binary scanner tool.\");\n-            if (blackDuckRunData.isOnline()) {\n-                BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n-                BinaryScanOptions binaryScanOptions = detectConfigurationFactory.createBinaryScanOptions();\n-                BlackDuckBinaryScannerTool blackDuckBinaryScanner = new BlackDuckBinaryScannerTool(eventSystem, codeLocationNameManager, directoryManager, new WildcardFileFinder(), binaryScanOptions, blackDuckServicesFactory.createBinaryScanUploadService());\n-                if (blackDuckBinaryScanner.shouldRun()) {\n-                    BinaryScanToolResult result = blackDuckBinaryScanner.performBinaryScanActions(projectNameVersion);\n-                    if (result.isSuccessful()) {\n-                        codeLocationAccumulator.addWaitableCodeLocation(result.getCodeLocationCreationData());\n+            logger.info(ReportConstants.RUN_SEPARATOR);\n+            if (detectToolFilter.shouldInclude(DetectTool.BINARY_SCAN)) {\n+                logger.info(\"Will include the binary scanner tool.\");\n+                if (null != blackDuckServicesFactory) {\n+                    BinaryScanOptions binaryScanOptions = detectConfigurationFactory.createBinaryScanOptions();\n+                    BlackDuckBinaryScannerTool blackDuckBinaryScanner = new BlackDuckBinaryScannerTool(eventSystem, codeLocationNameManager, directoryManager, new WildcardFileFinder(), binaryScanOptions, blackDuckServicesFactory);\n+                    if (blackDuckBinaryScanner.shouldRun()) {\n+                        BinaryScanToolResult result = blackDuckBinaryScanner.performBinaryScanActions(projectNameVersion);\n+                        if (result.isSuccessful()) {\n+                            codeLocationAccumulator.addWaitableCodeLocation(result.getCodeLocationCreationData());\n+                        }\n                     }\n                 }\n+                logger.info(\"Binary scanner actions finished.\");\n+            } else {\n+                logger.info(\"Binary scan tool will not be run.\");\n             }\n-            logger.info(\"Binary scanner actions finished.\");\n-        } else {\n-            logger.info(\"Binary scan tool will not be run.\");\n-        }\n \n-        logger.info(ReportConstants.RUN_SEPARATOR);\n-        BlackDuckImpactAnalysisTool blackDuckImpactAnalysisTool;\n-        if (blackDuckRunData.isOnline()) {\n-            BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n-            ImpactAnalysisBatchRunner impactAnalysisBatchRunner = new ImpactAnalysisBatchRunner(blackDuckServicesFactory.getLogger(), blackDuckServicesFactory.getBlackDuckApiClient(), new NoThreadExecutorService(), blackDuckServicesFactory.getGson());\n-            ImpactAnalysisUploadService impactAnalysisUploadService = new ImpactAnalysisUploadService(impactAnalysisBatchRunner, blackDuckServicesFactory.createCodeLocationCreationService());\n-            blackDuckImpactAnalysisTool = BlackDuckImpactAnalysisTool.ONLINE(directoryManager, codeLocationNameManager, impactAnalysisOptions, blackDuckServicesFactory.getBlackDuckApiClient(), impactAnalysisUploadService, blackDuckServicesFactory.createCodeLocationService(), eventSystem);\n-        } else {\n-            blackDuckImpactAnalysisTool = BlackDuckImpactAnalysisTool.OFFLINE(directoryManager, codeLocationNameManager, impactAnalysisOptions, eventSystem);\n-        }\n-        if (detectToolFilter.shouldInclude(DetectTool.IMPACT_ANALYSIS) && blackDuckImpactAnalysisTool.shouldRun()) {\n-            logger.info(\"Will include the Vulnerability Impact Analysis tool.\");\n-            ImpactAnalysisToolResult impactAnalysisToolResult = blackDuckImpactAnalysisTool.performImpactAnalysisActions(projectNameVersion, projectVersionWrapper);\n+            logger.info(ReportConstants.RUN_SEPARATOR);\n+            BlackDuckImpactAnalysisTool blackDuckImpactAnalysisTool;\n+            if (null != blackDuckServicesFactory) {\n+                blackDuckImpactAnalysisTool = BlackDuckImpactAnalysisTool.ONLINE(directoryManager, codeLocationNameManager, impactAnalysisOptions, blackDuckServicesFactory, eventSystem);\n+            } else {\n+                blackDuckImpactAnalysisTool = BlackDuckImpactAnalysisTool.OFFLINE(directoryManager, codeLocationNameManager, impactAnalysisOptions, eventSystem);\n+            }\n+            if (detectToolFilter.shouldInclude(DetectTool.IMPACT_ANALYSIS) && blackDuckImpactAnalysisTool.shouldRun()) {\n+                logger.info(\"Will include the Vulnerability Impact Analysis tool.\");\n+                ImpactAnalysisToolResult impactAnalysisToolResult = blackDuckImpactAnalysisTool.performImpactAnalysisActions(projectNameVersion, projectVersionWrapper);\n+\n+                /* TODO: There is currently no mechanism within Black Duck for checking the completion status of an Impact Analysis code location. Waiting should happen here when such a mechanism exists. See HUB-25142. JM - 08/2020 */\n+                codeLocationAccumulator.addNonWaitableCodeLocation(impactAnalysisToolResult.getCodeLocationNames());\n \n-            /* TODO: There is currently no mechanism within Black Duck for checking the completion status of an Impact Analysis code location. Waiting should happen here when such a mechanism exists. See HUB-25142. JM - 08/2020 */\n-            codeLocationAccumulator.addNonWaitableCodeLocation(impactAnalysisToolResult.getCodeLocationNames());\n+                if (impactAnalysisToolResult.isSuccessful()) {\n+                    logger.info(\"Vulnerability Impact Analysis successful.\");\n+                } else {\n+                    logger.warn(\"Something went wrong with the Vulnerability Impact Analysis tool.\");\n+                }\n \n-            if (impactAnalysisToolResult.isSuccessful()) {\n-                logger.info(\"Vulnerability Impact Analysis successful.\");\n+                logger.info(\"Vulnerability Impact Analysis tool actions finished.\");\n+            } else if (blackDuckImpactAnalysisTool.shouldRun()) {\n+                logger.info(\"Vulnerability Impact Analysis tool is enabled but will not run due to tool configuration.\");\n             } else {\n-                logger.warn(\"Something went wrong with the Vulnerability Impact Analysis tool.\");\n+                logger.info(\"Vulnerability Impact Analysis tool will not be run.\");\n             }\n \n-            logger.info(\"Vulnerability Impact Analysis tool actions finished.\");\n-        } else if (blackDuckImpactAnalysisTool.shouldRun()) {\n-            logger.info(\"Vulnerability Impact Analysis tool is enabled but will not run due to tool configuration.\");\n-        } else {\n-            logger.info(\"Vulnerability Impact Analysis tool will not be run.\");\n-        }\n-\n-        logger.info(ReportConstants.RUN_SEPARATOR);\n-        //We have finished code locations.\n-        CodeLocationResultCalculator waitCalculator = new CodeLocationResultCalculator();\n-        CodeLocationResults codeLocationResults = waitCalculator.calculateCodeLocationResults(codeLocationAccumulator);\n-        eventSystem.publishEvent(Event.CodeLocationsCompleted, codeLocationResults.getAllCodeLocationNames());\n-\n-        if (blackDuckRunData.isOnline()) {\n-            logger.info(\"Will perform Black Duck post actions.\");\n-            BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n-            BlackDuckPostOptions blackDuckPostOptions = detectConfigurationFactory.createBlackDuckPostOptions();\n-            BlackDuckPostActions blackDuckPostActions = new BlackDuckPostActions(blackDuckServicesFactory.createCodeLocationCreationService(), eventSystem, blackDuckServicesFactory.getBlackDuckApiClient(),\n-                blackDuckServicesFactory.createProjectBomService(), blackDuckServicesFactory.createReportService(detectConfigurationFactory.findTimeoutInSeconds() * 1000));\n-            blackDuckPostActions.perform(blackDuckPostOptions, codeLocationResults.getCodeLocationWaitData(), projectVersionWrapper, projectNameVersion, detectConfigurationFactory.findTimeoutInSeconds());\n-\n-            if ((!bdioResult.getUploadTargets().isEmpty() || detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN))) {\n-                Optional<String> componentsLink = Optional.ofNullable(projectVersionWrapper)\n-                                                      .map(ProjectVersionWrapper::getProjectVersionView)\n-                                                      .flatMap(projectVersionView -> projectVersionView.getFirstLinkSafely(ProjectVersionView.COMPONENTS_LINK))\n-                                                      .map(HttpUrl::string);\n-\n-                if (componentsLink.isPresent()) {\n-                    DetectResult detectResult = new BlackDuckBomDetectResult(componentsLink.get());\n-                    eventSystem.publishEvent(Event.ResultProduced, detectResult);\n+            logger.info(ReportConstants.RUN_SEPARATOR);\n+            //We have finished code locations.\n+            CodeLocationResultCalculator waitCalculator = new CodeLocationResultCalculator();\n+            CodeLocationResults codeLocationResults = waitCalculator.calculateCodeLocationResults(codeLocationAccumulator);\n+            eventSystem.publishEvent(Event.CodeLocationsCompleted, codeLocationResults.getAllCodeLocationNames());\n+\n+            if (null != blackDuckServicesFactory) {\n+                logger.info(\"Will perform Black Duck post actions.\");\n+                BlackDuckPostOptions blackDuckPostOptions = detectConfigurationFactory.createBlackDuckPostOptions();\n+                BlackDuckPostActions blackDuckPostActions = new BlackDuckPostActions(blackDuckServicesFactory, eventSystem);\n+                blackDuckPostActions.perform(blackDuckPostOptions, codeLocationResults.getCodeLocationWaitData(), projectVersionWrapper, projectNameVersion, detectConfigurationFactory.findTimeoutInSeconds());\n+\n+                if ((!bdioResult.getUploadTargets().isEmpty() || detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN))) {\n+                    Optional<String> componentsLink = Optional.ofNullable(projectVersionWrapper)\n+                                                          .map(ProjectVersionWrapper::getProjectVersionView)\n+                                                          .flatMap(projectVersionView -> projectVersionView.getFirstLinkSafely(ProjectVersionView.COMPONENTS_LINK))\n+                                                          .map(HttpUrl::string);\n+\n+                    if (componentsLink.isPresent()) {\n+                        DetectResult detectResult = new BlackDuckBomDetectResult(componentsLink.get());\n+                        eventSystem.publishEvent(Event.ResultProduced, detectResult);\n+                    }\n                 }\n+                logger.info(\"Black Duck actions have finished.\");\n+            } else {\n+                logger.debug(\"Will not perform Black Duck post actions: Detect is not online.\");\n             }\n-            logger.info(\"Black Duck actions have finished.\");\n-        } else {\n-            logger.debug(\"Will not perform Black Duck post actions: Detect is not online.\");\n         }\n     }\n \n+    private Set<String> createCodeLocationNames(DetectableToolResult detectableToolResult, CodeLocationNameManager codeLocationNameManager, DirectoryManager directoryManager) {\n+        if (detectableToolResult.getDetectToolProjectInfo().isPresent()) {\n+            NameVersion projectNameVersion = detectableToolResult.getDetectToolProjectInfo().get().getSuggestedNameVersion();\n+            return detectableToolResult.getDetectCodeLocations().stream()\n+                       .map(detectCodeLocation -> codeLocationNameManager.createCodeLocationName(detectCodeLocation, directoryManager.getSourceDirectory(), projectNameVersion.getName(), projectNameVersion.getVersion(), null, null))\n+                       .collect(Collectors.toSet());\n+        }\n+        return new HashSet<>();\n+    }\n+\n }\n", "next_change": {"commit": "f5aa7a0c24828bc262bfea68219845cfb3adef28", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\nindex 749ffade6..5f925d87c 100644\n--- a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n", "chunk": "@@ -461,14 +484,4 @@ public class RunManager {\n         }\n     }\n \n-    private Set<String> createCodeLocationNames(DetectableToolResult detectableToolResult, CodeLocationNameManager codeLocationNameManager, DirectoryManager directoryManager) {\n-        if (detectableToolResult.getDetectToolProjectInfo().isPresent()) {\n-            NameVersion projectNameVersion = detectableToolResult.getDetectToolProjectInfo().get().getSuggestedNameVersion();\n-            return detectableToolResult.getDetectCodeLocations().stream()\n-                       .map(detectCodeLocation -> codeLocationNameManager.createCodeLocationName(detectCodeLocation, directoryManager.getSourceDirectory(), projectNameVersion.getName(), projectNameVersion.getVersion(), null, null))\n-                       .collect(Collectors.toSet());\n-        }\n-        return new HashSet<>();\n-    }\n-\n }\n", "next_change": {"commit": "796cec7992add8ce41bebd0c027cfdb7bce8a444", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\nindex 5f925d87c..6d7b8129b 100644\n--- a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n", "chunk": "@@ -454,34 +228,17 @@ public class RunManager {\n \n             logger.info(ReportConstants.RUN_SEPARATOR);\n             //We have finished code locations.\n-            CodeLocationResultCalculator waitCalculator = new CodeLocationResultCalculator();\n-            CodeLocationResults codeLocationResults = waitCalculator.calculateCodeLocationResults(codeLocationAccumulator);\n-            eventSystem.publishEvent(Event.CodeLocationsCompleted, codeLocationResults.getAllCodeLocationNames());\n+            CodeLocationResults codeLocationResults = operationFactory.createCodeLocationResultOperation().execute(codeLocationAccumulator);\n \n             if (blackDuckRunData.isOnline()) {\n                 logger.info(\"Will perform Black Duck post actions.\");\n                 BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n-                BlackDuckPostOptions blackDuckPostOptions = detectConfigurationFactory.createBlackDuckPostOptions();\n-                BlackDuckPostActions blackDuckPostActions = new BlackDuckPostActions(blackDuckServicesFactory.createCodeLocationCreationService(), eventSystem, blackDuckServicesFactory.getBlackDuckApiClient(),\n-                    blackDuckServicesFactory.createProjectBomService(), blackDuckServicesFactory.createReportService(detectConfigurationFactory.findTimeoutInSeconds() * 1000));\n-                blackDuckPostActions.perform(blackDuckPostOptions, codeLocationResults.getCodeLocationWaitData(), projectVersionWrapper, projectNameVersion, detectConfigurationFactory.findTimeoutInSeconds());\n-\n-                if ((!bdioResult.getUploadTargets().isEmpty() || detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN))) {\n-                    Optional<String> componentsLink = Optional.ofNullable(projectVersionWrapper)\n-                                                          .map(ProjectVersionWrapper::getProjectVersionView)\n-                                                          .flatMap(projectVersionView -> projectVersionView.getFirstLinkSafely(ProjectVersionView.COMPONENTS_LINK))\n-                                                          .map(HttpUrl::string);\n-\n-                    if (componentsLink.isPresent()) {\n-                        DetectResult detectResult = new BlackDuckBomDetectResult(componentsLink.get());\n-                        eventSystem.publishEvent(Event.ResultProduced, detectResult);\n-                    }\n-                }\n+                FullScanPostProcessingInput fullScanPostProcessingInput = new FullScanPostProcessingInput(projectNameVersion, bdioResult, codeLocationResults, projectVersionWrapper);\n+                operationFactory.createFullScanPostProcessingOperation().execute(blackDuckServicesFactory, fullScanPostProcessingInput);\n                 logger.info(\"Black Duck actions have finished.\");\n             } else {\n                 logger.debug(\"Will not perform Black Duck post actions: Detect is not online.\");\n             }\n         }\n     }\n-\n }\n", "next_change": {"commit": "f42aa793ea922b8a661aac13cb523640b469e5ba", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\nindex 6d7b8129b..ccb05fd5f 100644\n--- a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n", "chunk": "@@ -228,17 +454,34 @@ public class RunManager {\n \n             logger.info(ReportConstants.RUN_SEPARATOR);\n             //We have finished code locations.\n-            CodeLocationResults codeLocationResults = operationFactory.createCodeLocationResultOperation().execute(codeLocationAccumulator);\n+            CodeLocationResultCalculator waitCalculator = new CodeLocationResultCalculator();\n+            CodeLocationResults codeLocationResults = waitCalculator.calculateCodeLocationResults(codeLocationAccumulator);\n+            eventSystem.publishEvent(Event.CodeLocationsCompleted, codeLocationResults.getAllCodeLocationNames());\n \n             if (blackDuckRunData.isOnline()) {\n                 logger.info(\"Will perform Black Duck post actions.\");\n                 BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n-                FullScanPostProcessingInput fullScanPostProcessingInput = new FullScanPostProcessingInput(projectNameVersion, bdioResult, codeLocationResults, projectVersionWrapper);\n-                operationFactory.createFullScanPostProcessingOperation().execute(blackDuckServicesFactory, fullScanPostProcessingInput);\n+                BlackDuckPostOptions blackDuckPostOptions = detectConfigurationFactory.createBlackDuckPostOptions();\n+                BlackDuckPostActions blackDuckPostActions = new BlackDuckPostActions(blackDuckServicesFactory.createCodeLocationCreationService(), eventSystem, blackDuckServicesFactory.getBlackDuckApiClient(),\n+                    blackDuckServicesFactory.createProjectBomService(), blackDuckServicesFactory.createReportService(detectConfigurationFactory.findTimeoutInSeconds() * 1000));\n+                blackDuckPostActions.perform(blackDuckPostOptions, codeLocationResults.getCodeLocationWaitData(), projectVersionWrapper, projectNameVersion, detectConfigurationFactory.findTimeoutInSeconds());\n+\n+                if ((!bdioResult.getUploadTargets().isEmpty() || detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN))) {\n+                    Optional<String> componentsLink = Optional.ofNullable(projectVersionWrapper)\n+                                                          .map(ProjectVersionWrapper::getProjectVersionView)\n+                                                          .flatMap(projectVersionView -> projectVersionView.getFirstLinkSafely(ProjectVersionView.COMPONENTS_LINK))\n+                                                          .map(HttpUrl::string);\n+\n+                    if (componentsLink.isPresent()) {\n+                        DetectResult detectResult = new BlackDuckBomDetectResult(componentsLink.get());\n+                        eventSystem.publishEvent(Event.ResultProduced, detectResult);\n+                    }\n+                }\n                 logger.info(\"Black Duck actions have finished.\");\n             } else {\n                 logger.debug(\"Will not perform Black Duck post actions: Detect is not online.\");\n             }\n         }\n     }\n+\n }\n", "next_change": {"commit": "620ed822ead4ec354f4f40285b749e3e48177c22", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\nindex ccb05fd5f..7c198e5cb 100644\n--- a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n", "chunk": "@@ -454,34 +230,17 @@ public class RunManager {\n \n             logger.info(ReportConstants.RUN_SEPARATOR);\n             //We have finished code locations.\n-            CodeLocationResultCalculator waitCalculator = new CodeLocationResultCalculator();\n-            CodeLocationResults codeLocationResults = waitCalculator.calculateCodeLocationResults(codeLocationAccumulator);\n-            eventSystem.publishEvent(Event.CodeLocationsCompleted, codeLocationResults.getAllCodeLocationNames());\n+            CodeLocationResults codeLocationResults = operationFactory.createCodeLocationResultCalculationOperation().execute(codeLocationAccumulator);\n \n             if (blackDuckRunData.isOnline()) {\n                 logger.info(\"Will perform Black Duck post actions.\");\n                 BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n-                BlackDuckPostOptions blackDuckPostOptions = detectConfigurationFactory.createBlackDuckPostOptions();\n-                BlackDuckPostActions blackDuckPostActions = new BlackDuckPostActions(blackDuckServicesFactory.createCodeLocationCreationService(), eventSystem, blackDuckServicesFactory.getBlackDuckApiClient(),\n-                    blackDuckServicesFactory.createProjectBomService(), blackDuckServicesFactory.createReportService(detectConfigurationFactory.findTimeoutInSeconds() * 1000));\n-                blackDuckPostActions.perform(blackDuckPostOptions, codeLocationResults.getCodeLocationWaitData(), projectVersionWrapper, projectNameVersion, detectConfigurationFactory.findTimeoutInSeconds());\n-\n-                if ((!bdioResult.getUploadTargets().isEmpty() || detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN))) {\n-                    Optional<String> componentsLink = Optional.ofNullable(projectVersionWrapper)\n-                                                          .map(ProjectVersionWrapper::getProjectVersionView)\n-                                                          .flatMap(projectVersionView -> projectVersionView.getFirstLinkSafely(ProjectVersionView.COMPONENTS_LINK))\n-                                                          .map(HttpUrl::string);\n-\n-                    if (componentsLink.isPresent()) {\n-                        DetectResult detectResult = new BlackDuckBomDetectResult(componentsLink.get());\n-                        eventSystem.publishEvent(Event.ResultProduced, detectResult);\n-                    }\n-                }\n+                FullScanPostProcessingInput fullScanPostProcessingInput = new FullScanPostProcessingInput(projectNameVersion, bdioResult, codeLocationResults, projectVersionWrapper);\n+                operationFactory.createFullScanPostProcessingOperation().execute(blackDuckServicesFactory, fullScanPostProcessingInput);\n                 logger.info(\"Black Duck actions have finished.\");\n             } else {\n                 logger.debug(\"Will not perform Black Duck post actions: Detect is not online.\");\n             }\n         }\n     }\n-\n }\n", "next_change": {"commit": "79f1919fbf38dc4c90d82b7d2e629b581e631c94", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\nindex 7c198e5cb..d3aa6a860 100644\n--- a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n", "chunk": "@@ -236,7 +242,7 @@ public class RunManager {\n                 logger.info(\"Will perform Black Duck post actions.\");\n                 BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n                 FullScanPostProcessingInput fullScanPostProcessingInput = new FullScanPostProcessingInput(projectNameVersion, bdioResult, codeLocationResults, projectVersionWrapper);\n-                operationFactory.createFullScanPostProcessingOperation().execute(blackDuckServicesFactory, fullScanPostProcessingInput);\n+                operationFactory.createFullScanPostProcessingOperation(detectToolFilter).execute(blackDuckServicesFactory, fullScanPostProcessingInput);\n                 logger.info(\"Black Duck actions have finished.\");\n             } else {\n                 logger.debug(\"Will not perform Black Duck post actions: Detect is not online.\");\n", "next_change": {"commit": "6c880cc789b07b3b42c3de8b781bfd06683fe7d1", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\nindex d3aa6a860..238db2227 100644\n--- a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n", "chunk": "@@ -1,252 +1,259 @@\n-/*\n- * synopsys-detect\n- *\n- * Copyright (c) 2021 Synopsys, Inc.\n- *\n- * Use subject to the terms and conditions of the Synopsys End User Software License and Maintenance Agreement. All rights reserved worldwide.\n- */\n-package com.synopsys.integration.detect.lifecycle.run;\n-\n-import java.util.Optional;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.synopsys.integration.blackduck.codelocation.CodeLocationCreationData;\n-import com.synopsys.integration.blackduck.codelocation.bdioupload.UploadBatchOutput;\n-import com.synopsys.integration.blackduck.codelocation.binaryscanner.BinaryScanBatchOutput;\n-import com.synopsys.integration.blackduck.codelocation.signaturescanner.ScanBatchOutput;\n-import com.synopsys.integration.blackduck.service.BlackDuckServicesFactory;\n-import com.synopsys.integration.blackduck.service.model.ProjectVersionWrapper;\n-import com.synopsys.integration.detect.configuration.DetectUserFriendlyException;\n-import com.synopsys.integration.detect.configuration.enumeration.DetectTool;\n-import com.synopsys.integration.detect.lifecycle.run.data.BlackDuckRunData;\n-import com.synopsys.integration.detect.lifecycle.run.data.ProductRunData;\n-import com.synopsys.integration.detect.lifecycle.run.operation.OperationFactory;\n-import com.synopsys.integration.detect.lifecycle.run.operation.blackduck.ImpactAnalysisOperation;\n-import com.synopsys.integration.detect.lifecycle.run.operation.input.BdioInput;\n-import com.synopsys.integration.detect.lifecycle.run.operation.input.FullScanPostProcessingInput;\n-import com.synopsys.integration.detect.lifecycle.run.operation.input.ImpactAnalysisInput;\n-import com.synopsys.integration.detect.lifecycle.run.operation.input.RapidScanInput;\n-import com.synopsys.integration.detect.lifecycle.run.operation.input.SignatureScanInput;\n-import com.synopsys.integration.detect.lifecycle.shutdown.ExitCodeManager;\n-import com.synopsys.integration.detect.tool.DetectableToolResult;\n-import com.synopsys.integration.detect.tool.UniversalToolsResult;\n-import com.synopsys.integration.detect.tool.detector.DetectorToolResult;\n-import com.synopsys.integration.detect.tool.impactanalysis.ImpactAnalysisToolResult;\n-import com.synopsys.integration.detect.util.filter.DetectToolFilter;\n-import com.synopsys.integration.detect.workflow.bdio.AggregateDecision;\n-import com.synopsys.integration.detect.workflow.bdio.BdioResult;\n-import com.synopsys.integration.detect.workflow.blackduck.codelocation.CodeLocationAccumulator;\n-import com.synopsys.integration.detect.workflow.blackduck.codelocation.CodeLocationResults;\n-import com.synopsys.integration.detect.workflow.phonehome.PhoneHomeManager;\n-import com.synopsys.integration.detect.workflow.project.ProjectEventPublisher;\n-import com.synopsys.integration.detect.workflow.report.util.ReportConstants;\n-import com.synopsys.integration.detect.workflow.status.OperationSystem;\n-import com.synopsys.integration.exception.IntegrationException;\n-import com.synopsys.integration.util.NameVersion;\n-\n-public class RunManager {\n-    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n-    private ExitCodeManager exitCodeManager;\n-\n-    public RunManager(ExitCodeManager exitCodeManager) {\n-        this.exitCodeManager = exitCodeManager;\n-    }\n-\n-    public void run(RunContext runContext) {\n-        try {\n-            RunResult runResult = new RunResult();\n-            ProductRunData productRunData = runContext.getProductRunData();\n-            OperationFactory operationFactory = new OperationFactory(runContext);\n-            ProjectEventPublisher projectEventPublisher = runContext.getProjectEventPublisher();\n-            DetectToolFilter detectToolFilter = productRunData.getDetectToolFilter();\n-\n-            logger.info(ReportConstants.RUN_SEPARATOR);\n-            if (runContext.getProductRunData().shouldUsePolarisProduct()) {\n-                runPolarisProduct(operationFactory, detectToolFilter);\n-            } else {\n-                logger.info(\"Polaris tools will not be run.\");\n-            }\n-\n-            UniversalToolsResult universalToolsResult = runUniversalProjectTools(operationFactory, detectToolFilter, projectEventPublisher, runResult);\n-\n-            if (productRunData.shouldUseBlackDuckProduct()) {\n-                AggregateDecision aggregateDecision = operationFactory.createAggregateOptionsOperation().execute(universalToolsResult.anyFailed());\n-                runBlackDuckProduct(productRunData.getBlackDuckRunData(), operationFactory, detectToolFilter, runResult,\n-                    universalToolsResult.getNameVersion(), aggregateDecision);\n-            } else {\n-                logger.info(\"Black Duck tools will not be run.\");\n-            }\n-\n-            logger.info(\"All tools have finished.\");\n-            logger.info(ReportConstants.RUN_SEPARATOR);\n-        } catch (Exception e) {\n-            if (e.getMessage() != null) {\n-                logger.error(\"Detect run failed: {}\", e.getMessage());\n-            } else {\n-                logger.error(\"Detect run failed: {}\", e.getClass().getSimpleName());\n-            }\n-            logger.debug(\"An exception was thrown during the detect run.\", e);\n-            exitCodeManager.requestExitCode(e);\n-        } finally {\n-            OperationSystem operationSystem = runContext.getOperationSystem();\n-            operationSystem.publishOperations();\n-        }\n-    }\n-\n-    private UniversalToolsResult runUniversalProjectTools(\n-        OperationFactory operationFactory,\n-        DetectToolFilter detectToolFilter,\n-        ProjectEventPublisher projectEventPublisher,\n-        RunResult runResult\n-    ) throws DetectUserFriendlyException, IntegrationException {\n-        boolean anythingFailed = false;\n-\n-        logger.info(ReportConstants.RUN_SEPARATOR);\n-        if (detectToolFilter.shouldInclude(DetectTool.DOCKER)) {\n-            logger.info(\"Will include the Docker tool.\");\n-            DetectableToolResult detectableToolResult = operationFactory.createDockerOperation().execute();\n-            runResult.addDetectableToolResult(detectableToolResult);\n-            anythingFailed = anythingFailed || detectableToolResult.isFailure();\n-            logger.info(\"Docker actions finished.\");\n-        } else {\n-            logger.info(\"Docker tool will not be run.\");\n-        }\n-\n-        logger.info(ReportConstants.RUN_SEPARATOR);\n-        if (detectToolFilter.shouldInclude(DetectTool.BAZEL)) {\n-            logger.info(\"Will include the Bazel tool.\");\n-            DetectableToolResult detectableToolResult = operationFactory.createBazelOperation().execute();\n-            runResult.addDetectableToolResult(detectableToolResult);\n-            anythingFailed = anythingFailed || detectableToolResult.isFailure();\n-            logger.info(\"Bazel actions finished.\");\n-        } else {\n-            logger.info(\"Bazel tool will not be run.\");\n-        }\n-        logger.info(ReportConstants.RUN_SEPARATOR);\n-        if (detectToolFilter.shouldInclude(DetectTool.DETECTOR)) {\n-            logger.info(\"Will include the detector tool.\");\n-            DetectorToolResult detectorToolResult = operationFactory.createDetectorOperation().execute();\n-            detectorToolResult.getBomToolProjectNameVersion().ifPresent(it -> runResult.addToolNameVersion(DetectTool.DETECTOR, new NameVersion(it.getName(), it.getVersion())));\n-            runResult.addDetectCodeLocations(detectorToolResult.getBomToolCodeLocations());\n-            anythingFailed = anythingFailed || detectorToolResult.anyDetectorsFailed();\n-            logger.info(\"Detector actions finished.\");\n-        } else {\n-            logger.info(\"Detector tool will not be run.\");\n-        }\n-\n-        logger.info(ReportConstants.RUN_SEPARATOR);\n-        logger.debug(\"Completed code location tools.\");\n-\n-        logger.debug(\"Determining project info.\");\n-\n-        NameVersion projectNameVersion = operationFactory.createProjectDecisionOperation().execute(runResult.getDetectToolProjectInfo());\n-\n-        logger.info(String.format(\"Project name: %s\", projectNameVersion.getName()));\n-        logger.info(String.format(\"Project version: %s\", projectNameVersion.getVersion()));\n-\n-        projectEventPublisher.publishProjectNameVersionChosen(projectNameVersion);\n-\n-        if (anythingFailed) {\n-            return UniversalToolsResult.failure(projectNameVersion);\n-        } else {\n-            return UniversalToolsResult.success(projectNameVersion);\n-        }\n-    }\n-\n-    private void runPolarisProduct(OperationFactory operationFactory, DetectToolFilter detectToolFilter) {\n-        logger.info(ReportConstants.RUN_SEPARATOR);\n-        if (detectToolFilter.shouldInclude(DetectTool.POLARIS)) {\n-            logger.info(\"Will include the Polaris tool.\");\n-            operationFactory.createPolarisOperation().execute();\n-            logger.info(\"Polaris actions finished.\");\n-        } else {\n-            logger.info(\"Polaris CLI tool will not be run.\");\n-        }\n-    }\n-\n-    private void runBlackDuckProduct(BlackDuckRunData blackDuckRunData, OperationFactory operationFactory, DetectToolFilter detectToolFilter, RunResult runResult, NameVersion projectNameVersion,\n-        AggregateDecision aggregateDecision)\n-        throws IntegrationException, DetectUserFriendlyException {\n-\n-        logger.debug(\"Black Duck tools will run.\");\n-\n-        ProjectVersionWrapper projectVersionWrapper = null;\n-\n-        BdioInput bdioInput = new BdioInput(aggregateDecision, projectNameVersion, runResult.getDetectCodeLocations());\n-        BdioResult bdioResult = operationFactory.createBdioFileGenerationOperation().execute(bdioInput);\n-        if (blackDuckRunData.isRapid()) {\n-            logger.info(ReportConstants.RUN_SEPARATOR);\n-            RapidScanInput rapidScanInput = new RapidScanInput(projectNameVersion, bdioResult);\n-            operationFactory.createRapidScanOperation().execute(blackDuckRunData, blackDuckRunData.getBlackDuckServicesFactory(), rapidScanInput);\n-        } else {\n-            if (blackDuckRunData.isOnline()) {\n-                blackDuckRunData.getPhoneHomeManager().ifPresent(PhoneHomeManager::startPhoneHome);\n-                BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n-                logger.debug(\"Getting or creating project.\");\n-                projectVersionWrapper = operationFactory.createProjectCreationOperation().execute(blackDuckServicesFactory, projectNameVersion);\n-            } else {\n-                logger.debug(\"Detect is not online, and will not create the project.\");\n-            }\n-\n-            logger.debug(\"Completed project and version actions.\");\n-            logger.debug(\"Processing Detect Code Locations.\");\n-\n-            CodeLocationAccumulator codeLocationAccumulator = new CodeLocationAccumulator<>();\n-            Optional<CodeLocationCreationData<UploadBatchOutput>> uploadResult = operationFactory.createBdioUploadOperation().execute(blackDuckRunData, bdioResult);\n-            uploadResult.ifPresent(codeLocationAccumulator::addWaitableCodeLocation);\n-\n-            logger.debug(\"Completed Detect Code Location processing.\");\n-\n-            logger.info(ReportConstants.RUN_SEPARATOR);\n-            if (detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN)) {\n-                logger.info(\"Will include the signature scanner tool.\");\n-                SignatureScanInput signatureScanInput = new SignatureScanInput(projectNameVersion, runResult.getDockerTargetData().orElse(null));\n-                Optional<CodeLocationCreationData<ScanBatchOutput>> signatureScanResult = operationFactory.createSignatureScanOperation().execute(signatureScanInput);\n-                signatureScanResult.ifPresent(codeLocationAccumulator::addWaitableCodeLocation);\n-                logger.info(\"Signature scanner actions finished.\");\n-            } else {\n-                logger.info(\"Signature scan tool will not be run.\");\n-            }\n-\n-            logger.info(ReportConstants.RUN_SEPARATOR);\n-            if (detectToolFilter.shouldInclude(DetectTool.BINARY_SCAN)) {\n-                logger.info(\"Will include the binary scanner tool.\");\n-                if (blackDuckRunData.isOnline()) {\n-                    Optional<CodeLocationCreationData<BinaryScanBatchOutput>> binaryScanResult = operationFactory.createBinaryScanOperation().execute(projectNameVersion, runResult.getDockerTargetData().orElse(null));\n-                    binaryScanResult.ifPresent(codeLocationAccumulator::addWaitableCodeLocation);\n-                }\n-                logger.info(\"Binary scanner actions finished.\");\n-            } else {\n-                logger.info(\"Binary scan tool will not be run.\");\n-            }\n-            ImpactAnalysisOperation impactAnalysisOperation = operationFactory.createImpactAnalysisOperation();\n-            logger.info(ReportConstants.RUN_SEPARATOR);\n-            if (detectToolFilter.shouldInclude(DetectTool.IMPACT_ANALYSIS)) {\n-                logger.info(\"Will include the Vulnerability Impact Analysis tool.\");\n-                ImpactAnalysisInput impactAnalysisInput = new ImpactAnalysisInput(projectNameVersion, projectVersionWrapper);\n-                ImpactAnalysisToolResult impactAnalysisToolResult = impactAnalysisOperation.execute(impactAnalysisInput);\n-                /* TODO: There is currently no mechanism within Black Duck for checking the completion status of an Impact Analysis code location. Waiting should happen here when such a mechanism exists. See HUB-25142. JM - 08/2020 */\n-                codeLocationAccumulator.addNonWaitableCodeLocation(impactAnalysisToolResult.getCodeLocationNames());\n-                logger.info(\"Vulnerability Impact Analysis tool actions finished.\");\n-            } else {\n-                logger.info(\"Vulnerability Impact Analysis tool will not be run.\");\n-            }\n-\n-            logger.info(ReportConstants.RUN_SEPARATOR);\n-            //We have finished code locations.\n-            CodeLocationResults codeLocationResults = operationFactory.createCodeLocationResultCalculationOperation().execute(codeLocationAccumulator);\n-\n-            if (blackDuckRunData.isOnline()) {\n-                logger.info(\"Will perform Black Duck post actions.\");\n-                BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n-                FullScanPostProcessingInput fullScanPostProcessingInput = new FullScanPostProcessingInput(projectNameVersion, bdioResult, codeLocationResults, projectVersionWrapper);\n-                operationFactory.createFullScanPostProcessingOperation(detectToolFilter).execute(blackDuckServicesFactory, fullScanPostProcessingInput);\n-                logger.info(\"Black Duck actions have finished.\");\n-            } else {\n-                logger.debug(\"Will not perform Black Duck post actions: Detect is not online.\");\n-            }\n-        }\n-    }\n-}\n+///*\n+// * synopsys-detect\n+// *\n+// * Copyright (c) 2021 Synopsys, Inc.\n+// *\n+// * Use subject to the terms and conditions of the Synopsys End User Software License and Maintenance Agreement. All rights reserved worldwide.\n+// */\n+//package com.synopsys.integration.detect.lifecycle.run;\n+//\n+//import java.util.Optional;\n+//\n+//import org.slf4j.Logger;\n+//import org.slf4j.LoggerFactory;\n+//\n+//import com.synopsys.integration.blackduck.codelocation.CodeLocationCreationData;\n+//import com.synopsys.integration.blackduck.codelocation.binaryscanner.BinaryScanBatchOutput;\n+//import com.synopsys.integration.blackduck.codelocation.signaturescanner.ScanBatchOutput;\n+//import com.synopsys.integration.blackduck.codelocation.upload.UploadBatchOutput;\n+//import com.synopsys.integration.blackduck.service.BlackDuckServicesFactory;\n+//import com.synopsys.integration.blackduck.service.model.ProjectVersionWrapper;\n+//import com.synopsys.integration.detect.configuration.DetectUserFriendlyException;\n+//import com.synopsys.integration.detect.configuration.enumeration.DetectTool;\n+//import com.synopsys.integration.detect.lifecycle.run.data.BlackDuckRunData;\n+//import com.synopsys.integration.detect.lifecycle.run.data.ProductRunData;\n+//import com.synopsys.integration.detect.lifecycle.run.operation.OperationFactory;\n+//import com.synopsys.integration.detect.lifecycle.run.operation.blackduck.ImpactAnalysisOperation;\n+//import com.synopsys.integration.detect.lifecycle.run.operation.input.BdioInput;\n+//import com.synopsys.integration.detect.lifecycle.run.operation.input.FullScanPostProcessingInput;\n+//import com.synopsys.integration.detect.lifecycle.run.operation.input.ImpactAnalysisInput;\n+//import com.synopsys.integration.detect.lifecycle.run.operation.input.SignatureScanInput;\n+//import com.synopsys.integration.detect.lifecycle.run.singleton.BootSingletons;\n+//import com.synopsys.integration.detect.lifecycle.run.singleton.EventSingletons;\n+//import com.synopsys.integration.detect.lifecycle.run.singleton.SingletonFactory;\n+//import com.synopsys.integration.detect.lifecycle.run.singleton.UtilitySingletons;\n+//import com.synopsys.integration.detect.lifecycle.shutdown.ExitCodeManager;\n+//import com.synopsys.integration.detect.tool.DetectableToolResult;\n+//import com.synopsys.integration.detect.tool.UniversalToolsResult;\n+//import com.synopsys.integration.detect.tool.detector.DetectorToolResult;\n+//import com.synopsys.integration.detect.tool.detector.factory.DetectorFactory;\n+//import com.synopsys.integration.detect.tool.impactanalysis.ImpactAnalysisToolResult;\n+//import com.synopsys.integration.detect.util.filter.DetectToolFilter;\n+//import com.synopsys.integration.detect.workflow.bdio.AggregateDecision;\n+//import com.synopsys.integration.detect.workflow.bdio.BdioResult;\n+//import com.synopsys.integration.detect.workflow.blackduck.codelocation.CodeLocationAccumulator;\n+//import com.synopsys.integration.detect.workflow.blackduck.codelocation.CodeLocationResults;\n+//import com.synopsys.integration.detect.workflow.blackduck.developer.RapidScanDetectResult;\n+//import com.synopsys.integration.detect.workflow.phonehome.PhoneHomeManager;\n+//import com.synopsys.integration.detect.workflow.project.ProjectEventPublisher;\n+//import com.synopsys.integration.detect.workflow.report.util.ReportConstants;\n+//import com.synopsys.integration.detect.workflow.status.OperationSystem;\n+//import com.synopsys.integration.exception.IntegrationException;\n+//import com.synopsys.integration.util.NameVersion;\n+//\n+//public class RunManager {\n+//    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n+//    private final ExitCodeManager exitCodeManager;\n+//\n+//    public RunManager(ExitCodeManager exitCodeManager) {\n+//        this.exitCodeManager = exitCodeManager;\n+//    }\n+//\n+//    public void run(BootSingletons bootSingletons) {\n+//        OperationSystem operationSystem = null;\n+//        try {\n+//            RunResult runResult = new RunResult();\n+//            ProductRunData productRunData = bootSingletons.getProductRunData();\n+//\n+//            SingletonFactory singletonFactory = new SingletonFactory(bootSingletons);\n+//            EventSingletons eventSingletons = singletonFactory.createEventSingletons();\n+//            UtilitySingletons utilitySingletons = singletonFactory.createUtilitySingletons(eventSingletons);\n+//            operationSystem = utilitySingletons.getOperationSystem();\n+//\n+//            DetectorFactory detectorFactory = new DetectorFactory(bootSingletons, utilitySingletons);\n+//            DetectFontLoaderFactory detectFontLoaderFactory = new DetectFontLoaderFactory(bootSingletons, utilitySingletons);\n+//            OperationFactory operationFactory = new OperationFactory(detectorFactory.detectDetectableFactory(), detectFontLoaderFactory, bootSingletons, utilitySingletons, eventSingletons);\n+//\n+//            // know singleton -\n+//            ProjectEventPublisher projectEventPublisher = eventSingletons.getProjectEventPublisher();\n+//            DetectToolFilter detectToolFilter = productRunData.getDetectToolFilter();\n+//\n+//            UniversalToolsResult universalToolsResult = runUniversalProjectTools(operationFactory, detectToolFilter, projectEventPublisher, runResult);\n+//\n+//            if (productRunData.shouldUseBlackDuckProduct()) {\n+//                AggregateDecision aggregateDecision = operationFactory.createAggregateOptionsOperation().execute(universalToolsResult.anyFailed());\n+//                runBlackDuckProduct(productRunData.getBlackDuckRunData(), operationFactory, detectToolFilter, runResult,\n+//                    universalToolsResult.getNameVersion(), aggregateDecision);\n+//            } else {\n+//                logger.info(\"Black Duck tools will not be run.\");\n+//            }\n+//\n+//            logger.info(\"All tools have finished.\");\n+//            logger.info(ReportConstants.RUN_SEPARATOR);\n+//        } catch (Exception e) {\n+//            if (e.getMessage() != null) {\n+//                logger.error(\"Detect run failed: {}\", e.getMessage());\n+//            } else {\n+//                logger.error(\"Detect run failed: {}\", e.getClass().getSimpleName());\n+//            }\n+//            logger.debug(\"An exception was thrown during the detect run.\", e);\n+//            exitCodeManager.requestExitCode(e);\n+//        } finally {\n+//            if (operationSystem != null) {\n+//                operationSystem.publishOperations();\n+//            }\n+//        }\n+//    }\n+//\n+//    private UniversalToolsResult runUniversalProjectTools(\n+//        OperationFactory operationFactory,\n+//        DetectToolFilter detectToolFilter,\n+//        ProjectEventPublisher projectEventPublisher,\n+//        RunResult runResult\n+//    ) throws DetectUserFriendlyException, IntegrationException {\n+//        boolean anythingFailed = false;\n+//\n+//        logger.info(ReportConstants.RUN_SEPARATOR);\n+//        if (detectToolFilter.shouldInclude(DetectTool.DOCKER)) {\n+//            logger.info(\"Will include the Docker tool.\");\n+//            DetectableToolResult detectableToolResult = operationFactory.createDockerOperation().execute();\n+//            runResult.addDetectableToolResult(detectableToolResult);\n+//            anythingFailed = anythingFailed || detectableToolResult.isFailure();\n+//            logger.info(\"Docker actions finished.\");\n+//        } else {\n+//            logger.info(\"Docker tool will not be run.\");\n+//        }\n+//\n+//        logger.info(ReportConstants.RUN_SEPARATOR);\n+//        if (detectToolFilter.shouldInclude(DetectTool.BAZEL)) {\n+//            logger.info(\"Will include the Bazel tool.\");\n+//            DetectableToolResult detectableToolResult = operationFactory.createBazelOperation().execute();\n+//            runResult.addDetectableToolResult(detectableToolResult);\n+//            anythingFailed = anythingFailed || detectableToolResult.isFailure();\n+//            logger.info(\"Bazel actions finished.\");\n+//        } else {\n+//            logger.info(\"Bazel tool will not be run.\");\n+//        }\n+//        logger.info(ReportConstants.RUN_SEPARATOR);\n+//        if (detectToolFilter.shouldInclude(DetectTool.DETECTOR)) {\n+//            logger.info(\"Will include the detector tool.\");\n+//            DetectorToolResult detectorToolResult = operationFactory.createDetectorOperation().execute();\n+//            detectorToolResult.getBomToolProjectNameVersion().ifPresent(it -> runResult.addToolNameVersion(DetectTool.DETECTOR, new NameVersion(it.getName(), it.getVersion())));\n+//            runResult.addDetectCodeLocations(detectorToolResult.getBomToolCodeLocations());\n+//            anythingFailed = anythingFailed || detectorToolResult.anyDetectorsFailed();\n+//            logger.info(\"Detector actions finished.\");\n+//        } else {\n+//            logger.info(\"Detector tool will not be run.\");\n+//        }\n+//\n+//        logger.info(ReportConstants.RUN_SEPARATOR);\n+//        logger.debug(\"Completed code location tools.\");\n+//\n+//        logger.debug(\"Determining project info.\");\n+//\n+//        NameVersion projectNameVersion = operationFactory.createProjectDecisionOperation().execute(runResult.getDetectToolProjectInfo());\n+//\n+//        logger.info(String.format(\"Project name: %s\", projectNameVersion.getName()));\n+//        logger.info(String.format(\"Project version: %s\", projectNameVersion.getVersion()));\n+//\n+//        projectEventPublisher.publishProjectNameVersionChosen(projectNameVersion);\n+//\n+//        if (anythingFailed) {\n+//            return UniversalToolsResult.failure(projectNameVersion);\n+//        } else {\n+//            return UniversalToolsResult.success(projectNameVersion);\n+//        }\n+//    }\n+//\n+//    private void runRapidScan(BlackDuckRunData blackDuckRunData, NameVersion projectNameVersion, BdioResult bdioResult) {\n+//        operationFactory.phoneHome();\n+//        File results = operationFactory.performRapidScan();\n+//        File jsonFile = operationFactory.generateRapidJsonFile(results);\n+//        File summary = operationFactory.logRapidReport(results);\n+//        statusEventPublisher.publishDetectResult(new RapidScanDetectResult(jsonFile.getCanonicalPath(), summary));\n+//    }\n+//\n+//    private void runBlackDuckProduct(BlackDuckRunData blackDuckRunData, OperationFactory operationFactory, DetectToolFilter detectToolFilter, RunResult runResult, NameVersion projectNameVersion,\n+//        AggregateDecision aggregateDecision)\n+//        throws IntegrationException, DetectUserFriendlyException {\n+//\n+//        logger.debug(\"Black Duck tools will run.\");\n+//\n+//        ProjectVersionWrapper projectVersionWrapper = null;\n+//\n+//        BdioInput bdioInput = new BdioInput(aggregateDecision, projectNameVersion, runResult.getDetectCodeLocations());\n+//        BdioResult bdioResult = operationFactory.createBdioFileGenerationOperation().execute(bdioInput);\n+//        if (blackDuckRunData.isRapid() && blackDuckRunData.isOnline()) {\n+//            blackDuckRunData.getPhoneHomeManager().ifPresent(PhoneHomeManager::startPhoneHome);\n+//            logger.info(ReportConstants.RUN_SEPARATOR);\n+//            runRapidScan();\n+//        } else {\n+//            if (blackDuckRunData.isOnline()) {\n+//                blackDuckRunData.getPhoneHomeManager().ifPresent(PhoneHomeManager::startPhoneHome);\n+//                BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n+//                logger.debug(\"Getting or creating project.\");\n+//                projectVersionWrapper = operationFactory.createProjectCreationOperation().execute(blackDuckServicesFactory, projectNameVersion);\n+//            } else {\n+//                logger.debug(\"Detect is not online, and will not create the project.\");\n+//            }\n+//\n+//            logger.debug(\"Completed project and version actions.\");\n+//            logger.debug(\"Processing Detect Code Locations.\");\n+//\n+//            CodeLocationAccumulator codeLocationAccumulator = new CodeLocationAccumulator<>();\n+//            Optional<CodeLocationCreationData<UploadBatchOutput>> uploadResult = operationFactory.createBdioUploadOperation().execute(blackDuckRunData.getScanMode(), blackDuckRunData, bdioResult);\n+//            uploadResult.ifPresent(codeLocationAccumulator::addWaitableCodeLocation);\n+//\n+//            logger.debug(\"Completed Detect Code Location processing.\");\n+//\n+//            logger.info(ReportConstants.RUN_SEPARATOR);\n+//            if (detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN)) {\n+//                logger.info(\"Will include the signature scanner tool.\");\n+//                SignatureScanInput signatureScanInput = new SignatureScanInput(projectNameVersion, runResult.getDockerTargetData().orElse(null));\n+//                Optional<CodeLocationCreationData<ScanBatchOutput>> signatureScanResult = operationFactory.createSignatureScanOperation().execute(signatureScanInput);\n+//                signatureScanResult.ifPresent(codeLocationAccumulator::addWaitableCodeLocation);\n+//                logger.info(\"Signature scanner actions finished.\");\n+//            } else {\n+//                logger.info(\"Signature scan tool will not be run.\");\n+//            }\n+//\n+//            logger.info(ReportConstants.RUN_SEPARATOR);\n+//            if (detectToolFilter.shouldInclude(DetectTool.BINARY_SCAN)) {\n+//                logger.info(\"Will include the binary scanner tool.\");\n+//                if (blackDuckRunData.isOnline()) {\n+//                    Optional<CodeLocationCreationData<BinaryScanBatchOutput>> binaryScanResult = operationFactory.createBinaryScanOperation().execute(projectNameVersion, runResult.getDockerTargetData().orElse(null));\n+//                    binaryScanResult.ifPresent(codeLocationAccumulator::addWaitableCodeLocation);\n+//                }\n+//                logger.info(\"Binary scanner actions finished.\");\n+//            } else {\n+//                logger.info(\"Binary scan tool will not be run.\");\n+//            }\n+//            ImpactAnalysisOperation impactAnalysisOperation = operationFactory.createImpactAnalysisOperation();\n+//            logger.info(ReportConstants.RUN_SEPARATOR);\n+//            if (detectToolFilter.shouldInclude(DetectTool.IMPACT_ANALYSIS)) {\n+//                logger.info(\"Will include the Vulnerability Impact Analysis tool.\");\n+//                ImpactAnalysisInput impactAnalysisInput = new ImpactAnalysisInput(projectNameVersion, projectVersionWrapper);\n+//                ImpactAnalysisToolResult impactAnalysisToolResult = impactAnalysisOperation.execute(impactAnalysisInput);\n+//                /* TODO: There is currently no mechanism within Black Duck for checking the completion status of an Impact Analysis code location. Waiting should happen here when such a mechanism exists. See HUB-25142. JM - 08/2020 */\n+//                codeLocationAccumulator.addNonWaitableCodeLocation(impactAnalysisToolResult.getCodeLocationNames());\n+//                logger.info(\"Vulnerability Impact Analysis tool actions finished.\");\n+//            } else {\n+//                logger.info(\"Vulnerability Impact Analysis tool will not be run.\");\n+//            }\n+//\n+//            logger.info(ReportConstants.RUN_SEPARATOR);\n+//            //We have finished code locations.\n+//            CodeLocationResults codeLocationResults = operationFactory.createCodeLocationResultCalculationOperation().execute(codeLocationAccumulator);\n+//\n+//            if (blackDuckRunData.isOnline()) {\n+//                logger.info(\"Will perform Black Duck post actions.\");\n+//                BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n+//                FullScanPostProcessingInput fullScanPostProcessingInput = new FullScanPostProcessingInput(projectNameVersion, bdioResult, codeLocationResults, projectVersionWrapper);\n+//                operationFactory.createFullScanPostProcessingOperation(detectToolFilter).execute(blackDuckServicesFactory, fullScanPostProcessingInput);\n+//                logger.info(\"Black Duck actions have finished.\");\n+//            } else {\n+//                logger.debug(\"Will not perform Black Duck post actions: Detect is not online.\");\n+//            }\n+//        }\n+//    }\n+//}\n", "next_change": {"commit": "678c90e318030a91013aab90358529e9ca9a746b", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java b/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\ndeleted file mode 100644\nindex 238db2227..000000000\n--- a/src/main/java/com/synopsys/integration/detect/lifecycle/run/RunManager.java\n+++ /dev/null\n", "chunk": "@@ -1,259 +0,0 @@\n-///*\n-// * synopsys-detect\n-// *\n-// * Copyright (c) 2021 Synopsys, Inc.\n-// *\n-// * Use subject to the terms and conditions of the Synopsys End User Software License and Maintenance Agreement. All rights reserved worldwide.\n-// */\n-//package com.synopsys.integration.detect.lifecycle.run;\n-//\n-//import java.util.Optional;\n-//\n-//import org.slf4j.Logger;\n-//import org.slf4j.LoggerFactory;\n-//\n-//import com.synopsys.integration.blackduck.codelocation.CodeLocationCreationData;\n-//import com.synopsys.integration.blackduck.codelocation.binaryscanner.BinaryScanBatchOutput;\n-//import com.synopsys.integration.blackduck.codelocation.signaturescanner.ScanBatchOutput;\n-//import com.synopsys.integration.blackduck.codelocation.upload.UploadBatchOutput;\n-//import com.synopsys.integration.blackduck.service.BlackDuckServicesFactory;\n-//import com.synopsys.integration.blackduck.service.model.ProjectVersionWrapper;\n-//import com.synopsys.integration.detect.configuration.DetectUserFriendlyException;\n-//import com.synopsys.integration.detect.configuration.enumeration.DetectTool;\n-//import com.synopsys.integration.detect.lifecycle.run.data.BlackDuckRunData;\n-//import com.synopsys.integration.detect.lifecycle.run.data.ProductRunData;\n-//import com.synopsys.integration.detect.lifecycle.run.operation.OperationFactory;\n-//import com.synopsys.integration.detect.lifecycle.run.operation.blackduck.ImpactAnalysisOperation;\n-//import com.synopsys.integration.detect.lifecycle.run.operation.input.BdioInput;\n-//import com.synopsys.integration.detect.lifecycle.run.operation.input.FullScanPostProcessingInput;\n-//import com.synopsys.integration.detect.lifecycle.run.operation.input.ImpactAnalysisInput;\n-//import com.synopsys.integration.detect.lifecycle.run.operation.input.SignatureScanInput;\n-//import com.synopsys.integration.detect.lifecycle.run.singleton.BootSingletons;\n-//import com.synopsys.integration.detect.lifecycle.run.singleton.EventSingletons;\n-//import com.synopsys.integration.detect.lifecycle.run.singleton.SingletonFactory;\n-//import com.synopsys.integration.detect.lifecycle.run.singleton.UtilitySingletons;\n-//import com.synopsys.integration.detect.lifecycle.shutdown.ExitCodeManager;\n-//import com.synopsys.integration.detect.tool.DetectableToolResult;\n-//import com.synopsys.integration.detect.tool.UniversalToolsResult;\n-//import com.synopsys.integration.detect.tool.detector.DetectorToolResult;\n-//import com.synopsys.integration.detect.tool.detector.factory.DetectorFactory;\n-//import com.synopsys.integration.detect.tool.impactanalysis.ImpactAnalysisToolResult;\n-//import com.synopsys.integration.detect.util.filter.DetectToolFilter;\n-//import com.synopsys.integration.detect.workflow.bdio.AggregateDecision;\n-//import com.synopsys.integration.detect.workflow.bdio.BdioResult;\n-//import com.synopsys.integration.detect.workflow.blackduck.codelocation.CodeLocationAccumulator;\n-//import com.synopsys.integration.detect.workflow.blackduck.codelocation.CodeLocationResults;\n-//import com.synopsys.integration.detect.workflow.blackduck.developer.RapidScanDetectResult;\n-//import com.synopsys.integration.detect.workflow.phonehome.PhoneHomeManager;\n-//import com.synopsys.integration.detect.workflow.project.ProjectEventPublisher;\n-//import com.synopsys.integration.detect.workflow.report.util.ReportConstants;\n-//import com.synopsys.integration.detect.workflow.status.OperationSystem;\n-//import com.synopsys.integration.exception.IntegrationException;\n-//import com.synopsys.integration.util.NameVersion;\n-//\n-//public class RunManager {\n-//    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n-//    private final ExitCodeManager exitCodeManager;\n-//\n-//    public RunManager(ExitCodeManager exitCodeManager) {\n-//        this.exitCodeManager = exitCodeManager;\n-//    }\n-//\n-//    public void run(BootSingletons bootSingletons) {\n-//        OperationSystem operationSystem = null;\n-//        try {\n-//            RunResult runResult = new RunResult();\n-//            ProductRunData productRunData = bootSingletons.getProductRunData();\n-//\n-//            SingletonFactory singletonFactory = new SingletonFactory(bootSingletons);\n-//            EventSingletons eventSingletons = singletonFactory.createEventSingletons();\n-//            UtilitySingletons utilitySingletons = singletonFactory.createUtilitySingletons(eventSingletons);\n-//            operationSystem = utilitySingletons.getOperationSystem();\n-//\n-//            DetectorFactory detectorFactory = new DetectorFactory(bootSingletons, utilitySingletons);\n-//            DetectFontLoaderFactory detectFontLoaderFactory = new DetectFontLoaderFactory(bootSingletons, utilitySingletons);\n-//            OperationFactory operationFactory = new OperationFactory(detectorFactory.detectDetectableFactory(), detectFontLoaderFactory, bootSingletons, utilitySingletons, eventSingletons);\n-//\n-//            // know singleton -\n-//            ProjectEventPublisher projectEventPublisher = eventSingletons.getProjectEventPublisher();\n-//            DetectToolFilter detectToolFilter = productRunData.getDetectToolFilter();\n-//\n-//            UniversalToolsResult universalToolsResult = runUniversalProjectTools(operationFactory, detectToolFilter, projectEventPublisher, runResult);\n-//\n-//            if (productRunData.shouldUseBlackDuckProduct()) {\n-//                AggregateDecision aggregateDecision = operationFactory.createAggregateOptionsOperation().execute(universalToolsResult.anyFailed());\n-//                runBlackDuckProduct(productRunData.getBlackDuckRunData(), operationFactory, detectToolFilter, runResult,\n-//                    universalToolsResult.getNameVersion(), aggregateDecision);\n-//            } else {\n-//                logger.info(\"Black Duck tools will not be run.\");\n-//            }\n-//\n-//            logger.info(\"All tools have finished.\");\n-//            logger.info(ReportConstants.RUN_SEPARATOR);\n-//        } catch (Exception e) {\n-//            if (e.getMessage() != null) {\n-//                logger.error(\"Detect run failed: {}\", e.getMessage());\n-//            } else {\n-//                logger.error(\"Detect run failed: {}\", e.getClass().getSimpleName());\n-//            }\n-//            logger.debug(\"An exception was thrown during the detect run.\", e);\n-//            exitCodeManager.requestExitCode(e);\n-//        } finally {\n-//            if (operationSystem != null) {\n-//                operationSystem.publishOperations();\n-//            }\n-//        }\n-//    }\n-//\n-//    private UniversalToolsResult runUniversalProjectTools(\n-//        OperationFactory operationFactory,\n-//        DetectToolFilter detectToolFilter,\n-//        ProjectEventPublisher projectEventPublisher,\n-//        RunResult runResult\n-//    ) throws DetectUserFriendlyException, IntegrationException {\n-//        boolean anythingFailed = false;\n-//\n-//        logger.info(ReportConstants.RUN_SEPARATOR);\n-//        if (detectToolFilter.shouldInclude(DetectTool.DOCKER)) {\n-//            logger.info(\"Will include the Docker tool.\");\n-//            DetectableToolResult detectableToolResult = operationFactory.createDockerOperation().execute();\n-//            runResult.addDetectableToolResult(detectableToolResult);\n-//            anythingFailed = anythingFailed || detectableToolResult.isFailure();\n-//            logger.info(\"Docker actions finished.\");\n-//        } else {\n-//            logger.info(\"Docker tool will not be run.\");\n-//        }\n-//\n-//        logger.info(ReportConstants.RUN_SEPARATOR);\n-//        if (detectToolFilter.shouldInclude(DetectTool.BAZEL)) {\n-//            logger.info(\"Will include the Bazel tool.\");\n-//            DetectableToolResult detectableToolResult = operationFactory.createBazelOperation().execute();\n-//            runResult.addDetectableToolResult(detectableToolResult);\n-//            anythingFailed = anythingFailed || detectableToolResult.isFailure();\n-//            logger.info(\"Bazel actions finished.\");\n-//        } else {\n-//            logger.info(\"Bazel tool will not be run.\");\n-//        }\n-//        logger.info(ReportConstants.RUN_SEPARATOR);\n-//        if (detectToolFilter.shouldInclude(DetectTool.DETECTOR)) {\n-//            logger.info(\"Will include the detector tool.\");\n-//            DetectorToolResult detectorToolResult = operationFactory.createDetectorOperation().execute();\n-//            detectorToolResult.getBomToolProjectNameVersion().ifPresent(it -> runResult.addToolNameVersion(DetectTool.DETECTOR, new NameVersion(it.getName(), it.getVersion())));\n-//            runResult.addDetectCodeLocations(detectorToolResult.getBomToolCodeLocations());\n-//            anythingFailed = anythingFailed || detectorToolResult.anyDetectorsFailed();\n-//            logger.info(\"Detector actions finished.\");\n-//        } else {\n-//            logger.info(\"Detector tool will not be run.\");\n-//        }\n-//\n-//        logger.info(ReportConstants.RUN_SEPARATOR);\n-//        logger.debug(\"Completed code location tools.\");\n-//\n-//        logger.debug(\"Determining project info.\");\n-//\n-//        NameVersion projectNameVersion = operationFactory.createProjectDecisionOperation().execute(runResult.getDetectToolProjectInfo());\n-//\n-//        logger.info(String.format(\"Project name: %s\", projectNameVersion.getName()));\n-//        logger.info(String.format(\"Project version: %s\", projectNameVersion.getVersion()));\n-//\n-//        projectEventPublisher.publishProjectNameVersionChosen(projectNameVersion);\n-//\n-//        if (anythingFailed) {\n-//            return UniversalToolsResult.failure(projectNameVersion);\n-//        } else {\n-//            return UniversalToolsResult.success(projectNameVersion);\n-//        }\n-//    }\n-//\n-//    private void runRapidScan(BlackDuckRunData blackDuckRunData, NameVersion projectNameVersion, BdioResult bdioResult) {\n-//        operationFactory.phoneHome();\n-//        File results = operationFactory.performRapidScan();\n-//        File jsonFile = operationFactory.generateRapidJsonFile(results);\n-//        File summary = operationFactory.logRapidReport(results);\n-//        statusEventPublisher.publishDetectResult(new RapidScanDetectResult(jsonFile.getCanonicalPath(), summary));\n-//    }\n-//\n-//    private void runBlackDuckProduct(BlackDuckRunData blackDuckRunData, OperationFactory operationFactory, DetectToolFilter detectToolFilter, RunResult runResult, NameVersion projectNameVersion,\n-//        AggregateDecision aggregateDecision)\n-//        throws IntegrationException, DetectUserFriendlyException {\n-//\n-//        logger.debug(\"Black Duck tools will run.\");\n-//\n-//        ProjectVersionWrapper projectVersionWrapper = null;\n-//\n-//        BdioInput bdioInput = new BdioInput(aggregateDecision, projectNameVersion, runResult.getDetectCodeLocations());\n-//        BdioResult bdioResult = operationFactory.createBdioFileGenerationOperation().execute(bdioInput);\n-//        if (blackDuckRunData.isRapid() && blackDuckRunData.isOnline()) {\n-//            blackDuckRunData.getPhoneHomeManager().ifPresent(PhoneHomeManager::startPhoneHome);\n-//            logger.info(ReportConstants.RUN_SEPARATOR);\n-//            runRapidScan();\n-//        } else {\n-//            if (blackDuckRunData.isOnline()) {\n-//                blackDuckRunData.getPhoneHomeManager().ifPresent(PhoneHomeManager::startPhoneHome);\n-//                BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n-//                logger.debug(\"Getting or creating project.\");\n-//                projectVersionWrapper = operationFactory.createProjectCreationOperation().execute(blackDuckServicesFactory, projectNameVersion);\n-//            } else {\n-//                logger.debug(\"Detect is not online, and will not create the project.\");\n-//            }\n-//\n-//            logger.debug(\"Completed project and version actions.\");\n-//            logger.debug(\"Processing Detect Code Locations.\");\n-//\n-//            CodeLocationAccumulator codeLocationAccumulator = new CodeLocationAccumulator<>();\n-//            Optional<CodeLocationCreationData<UploadBatchOutput>> uploadResult = operationFactory.createBdioUploadOperation().execute(blackDuckRunData.getScanMode(), blackDuckRunData, bdioResult);\n-//            uploadResult.ifPresent(codeLocationAccumulator::addWaitableCodeLocation);\n-//\n-//            logger.debug(\"Completed Detect Code Location processing.\");\n-//\n-//            logger.info(ReportConstants.RUN_SEPARATOR);\n-//            if (detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN)) {\n-//                logger.info(\"Will include the signature scanner tool.\");\n-//                SignatureScanInput signatureScanInput = new SignatureScanInput(projectNameVersion, runResult.getDockerTargetData().orElse(null));\n-//                Optional<CodeLocationCreationData<ScanBatchOutput>> signatureScanResult = operationFactory.createSignatureScanOperation().execute(signatureScanInput);\n-//                signatureScanResult.ifPresent(codeLocationAccumulator::addWaitableCodeLocation);\n-//                logger.info(\"Signature scanner actions finished.\");\n-//            } else {\n-//                logger.info(\"Signature scan tool will not be run.\");\n-//            }\n-//\n-//            logger.info(ReportConstants.RUN_SEPARATOR);\n-//            if (detectToolFilter.shouldInclude(DetectTool.BINARY_SCAN)) {\n-//                logger.info(\"Will include the binary scanner tool.\");\n-//                if (blackDuckRunData.isOnline()) {\n-//                    Optional<CodeLocationCreationData<BinaryScanBatchOutput>> binaryScanResult = operationFactory.createBinaryScanOperation().execute(projectNameVersion, runResult.getDockerTargetData().orElse(null));\n-//                    binaryScanResult.ifPresent(codeLocationAccumulator::addWaitableCodeLocation);\n-//                }\n-//                logger.info(\"Binary scanner actions finished.\");\n-//            } else {\n-//                logger.info(\"Binary scan tool will not be run.\");\n-//            }\n-//            ImpactAnalysisOperation impactAnalysisOperation = operationFactory.createImpactAnalysisOperation();\n-//            logger.info(ReportConstants.RUN_SEPARATOR);\n-//            if (detectToolFilter.shouldInclude(DetectTool.IMPACT_ANALYSIS)) {\n-//                logger.info(\"Will include the Vulnerability Impact Analysis tool.\");\n-//                ImpactAnalysisInput impactAnalysisInput = new ImpactAnalysisInput(projectNameVersion, projectVersionWrapper);\n-//                ImpactAnalysisToolResult impactAnalysisToolResult = impactAnalysisOperation.execute(impactAnalysisInput);\n-//                /* TODO: There is currently no mechanism within Black Duck for checking the completion status of an Impact Analysis code location. Waiting should happen here when such a mechanism exists. See HUB-25142. JM - 08/2020 */\n-//                codeLocationAccumulator.addNonWaitableCodeLocation(impactAnalysisToolResult.getCodeLocationNames());\n-//                logger.info(\"Vulnerability Impact Analysis tool actions finished.\");\n-//            } else {\n-//                logger.info(\"Vulnerability Impact Analysis tool will not be run.\");\n-//            }\n-//\n-//            logger.info(ReportConstants.RUN_SEPARATOR);\n-//            //We have finished code locations.\n-//            CodeLocationResults codeLocationResults = operationFactory.createCodeLocationResultCalculationOperation().execute(codeLocationAccumulator);\n-//\n-//            if (blackDuckRunData.isOnline()) {\n-//                logger.info(\"Will perform Black Duck post actions.\");\n-//                BlackDuckServicesFactory blackDuckServicesFactory = blackDuckRunData.getBlackDuckServicesFactory();\n-//                FullScanPostProcessingInput fullScanPostProcessingInput = new FullScanPostProcessingInput(projectNameVersion, bdioResult, codeLocationResults, projectVersionWrapper);\n-//                operationFactory.createFullScanPostProcessingOperation(detectToolFilter).execute(blackDuckServicesFactory, fullScanPostProcessingInput);\n-//                logger.info(\"Black Duck actions have finished.\");\n-//            } else {\n-//                logger.debug(\"Will not perform Black Duck post actions: Detect is not online.\");\n-//            }\n-//        }\n-//    }\n-//}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "a19768f37c93a9f20c341018fa53b1b0a1ef93c9", "message": "Merge commit", "committedDate": null}, {"oid": "4ce0d86b56ba026bc4817429dff2165ec4c84501", "committedDate": "2020-06-16 13:07:43 -0400", "message": "feat: Added DetectIssueTypes for binary and signature scanner, published issues found by each tool"}, {"oid": "16b2a37284b600bbc93fff3228fc82398e32b8c1", "committedDate": "2020-06-16 13:12:30 -0400", "message": "Merged master"}, {"oid": "06e208c26529236c163073c12f919f070a1e40c9", "committedDate": "2020-06-17 18:09:47 -0400", "message": "refactor: Moving issue publishing to detector tool instead of in reporting."}, {"oid": "2ea4a5cabd2603eb3ba14fa233ab1273c39eb742", "committedDate": "2020-06-18 16:02:45 -0400", "message": "refactor(sonar): Reduced cognitive complexity by moving logic chunks into methods."}, {"oid": "c699a68233ce114be7be659e18897f33d3942e35", "committedDate": "2020-06-19 11:10:33 -0400", "message": "Merge branch 'master' into cognitive-complexity"}, {"oid": "49dc94ceb364912c83d0de18be0cbffdce756b98", "committedDate": "2020-06-19 12:07:03 -0400", "message": "fix(sonar): Fixing compilation errors introduced by sonar refactor."}, {"oid": "f2fe709acfeae2d5d62c04dfc2630c249d8b4aea", "committedDate": "2020-06-24 13:04:33 -0400", "message": "feat(impact-analysis): Added Vulnerability Impact Analysis tool."}, {"oid": "4243b28e006d362ccb38a2491d602ce2eca04a17", "committedDate": "2020-06-25 12:34:42 -0400", "message": "fix(impact-analysis): Added code location name generation for impact analysis."}, {"oid": "41e225d3c98e200b51ecca34390ebef7116576c7", "committedDate": "2020-06-29 12:45:59 -0400", "message": "feat(impact-analysis): Added ability to upload impact analysis report."}, {"oid": "cfc8e8485e1c76e02c066b9b437b7f512c1905a7", "committedDate": "2020-06-29 14:52:27 -0400", "message": "refactor(impact-analysis): Moved service to separate package."}, {"oid": "acbcad90d90662700f6191e405adaaa483467810", "committedDate": "2020-06-30 11:40:31 -0400", "message": "Merge branch 'master' into impact-analysis"}, {"oid": "31b71fbeff6d3d6342f769a1194b69407ce15f20", "committedDate": "2020-07-13 14:24:07 -0400", "message": "fix: Remove redundant event publish for bazel code locations (IDETECT-2035)"}, {"oid": "15d524eae2e8cfd1595744ad4ce38fafa5e534de", "committedDate": "2020-07-20 09:10:23 -0400", "message": "feat(docker): adding windows support"}, {"oid": "eae61c93cc5338b263084ab1869d14cdf8689f11", "committedDate": "2020-07-20 11:56:10 -0400", "message": "feat: Replaced usages of kotlin detect properties with Java equivalent"}, {"oid": "ffe8180ada57551bf2334b49a1e5fbc4b577de57", "committedDate": "2020-07-21 16:48:39 -0400", "message": "Merge branch 'master' into impact-analysis"}, {"oid": "4e6da05224e1508ba1282f2481d5e77388e58926", "committedDate": "2020-07-24 16:52:41 -0400", "message": "Merge branch 'master' into sb_dockerOnWindows"}, {"oid": "363f07fee3ec2236cebc1e4664bb2efecfa78df2", "committedDate": "2020-07-27 12:23:55 -0400", "message": "feat(impact-analysis): Added property to enable impact analysis."}, {"oid": "6dba4eead5e9cd559c1b2d3d5c33d67af17f7945", "committedDate": "2020-07-29 12:41:21 -0400", "message": "fix(sonar): Fixed code smell introduced by impact analysis."}, {"oid": "7e014a6302e706cc420e8e7e7a234e907bf701cd", "committedDate": "2020-08-05 14:12:42 -0400", "message": "refactor(impact-analysis): Copied model from BinaryScanner."}, {"oid": "41f5e5d7d31edb4e2b8b2cf103554ef8c165c2c2", "committedDate": "2020-08-06 11:58:10 -0400", "message": "fix(impact-analysis): Added code location mapping. (IDETECT-2130)"}, {"oid": "0dacafb07cc534e9c71272f582e3a89cf82facc4", "committedDate": "2020-08-11 11:48:12 -0400", "message": "refactor(impact-analysis): The BlackDuckImpactAnalysisTool now has clearer requirements for an online/offline state. Fixed some typos."}, {"oid": "670ec41e2c1c8d464f58c0fa8705fe050af9c809", "committedDate": "2020-08-11 11:53:22 -0400", "message": "fix(impact-analysis): Removed code location waiting since there is no mechanism for checking status. (Completes IDETECT-2130, Fixes IDETECT-2168)"}, {"oid": "ba5dfeb6008b6ef3c142efd7af1913824606f181", "committedDate": "2020-08-11 12:14:25 -0400", "message": "style(todo): Updated TODO."}, {"oid": "68eadf771327f278bb0f3be6c4c35f384255126e", "committedDate": "2020-08-11 12:51:48 -0400", "message": "Merge branch '6.5.0'"}, {"oid": "5c9254e98c8f6840b330d68630fe7a1ab59c527b", "committedDate": "2020-08-12 13:17:26 -0400", "message": "feat: Updated blackduck common to 49.1.0 (Fixes IDETECT-977, IDETECT-2102)"}, {"oid": "2c97a1f196c465e1975266e4720fc8c22deec76f", "committedDate": "2020-08-12 13:34:08 -0400", "message": "Merge branch 'master' of https://github.com/blackducksoftware/synopsys-detect"}, {"oid": "4338b55cf94adce3a26b20d97e379aa185151edb", "committedDate": "2020-08-24 09:58:02 -0400", "message": "feat(impact-analysis): Reduced verbosity of info level logs."}, {"oid": "c0ffc511982badf1a660498835afecdb85b7de60", "committedDate": "2020-08-24 11:19:31 -0400", "message": "Merge branch '6.5.0'"}, {"oid": "240ee15f94f6216db0a6373a6424d5afe8ed62db", "committedDate": "2020-08-26 19:31:30 -0400", "message": "refactor: Simplified aggregate bdio files so code location name events could be unified and event system could be removed from WaitData. (Fixes IDETECT-2148)"}, {"oid": "106b9b77267a10fd33e6cc857b57d5719b63ee32", "committedDate": "2020-08-26 19:32:57 -0400", "message": "Merge branch 'master' of https://github.com/blackducksoftware/synopsys-detect"}, {"oid": "27ccb27f8dc2d0170727c790d8ed12d34797ccfe", "committedDate": "2020-08-31 15:06:12 -0400", "message": "refactor: Accumulating code locations and calculating wait data at the end of the run. (Fixes IDETECT-2148)"}, {"oid": "037023060642fbc8d7c8584ab2bf984361b13606", "committedDate": "2020-09-08 14:51:44 -0400", "message": "feat: Merged master."}, {"oid": "6e30dd25ca43839313237a471c58eab3d6560c22", "committedDate": "2020-09-08 15:06:15 -0400", "message": "feat: Merge master."}, {"oid": "b8d89f290c842dbc3dc0dc3ac3cc30c6b64bc8c7", "committedDate": "2020-10-06 14:14:56 -0400", "message": "refactor: Moved file finder and executable resolvers to main where able."}, {"oid": "2810ca638236ebb93baad257912fdeb852d8b0dc", "committedDate": "2020-10-12 15:56:41 -0400", "message": "refactor: Moved enumerations to common package."}, {"oid": "f10455934f667fe7333a024aadd48787698dae69", "committedDate": "2020-10-12 16:39:51 -0400", "message": "refactor: Removed detect-configuration module and moved code into main."}, {"oid": "793925713c58b3f35f5eedef14592fa104fda7b1", "committedDate": "2020-10-14 13:32:51 -0400", "message": "refactor: Polaris is now a module and using the latest black duck common."}, {"oid": "64f4d8239b7da2a161b4c6d806186a30a6fc77fc", "committedDate": "2020-10-21 14:34:29 -0400", "message": "refactor: Switched executables from private detect executable runner to shared integration common runner."}, {"oid": "b6c4ed0e22a5a096117a1aa94d622cea5ddd5e9d", "committedDate": "2020-11-04 15:12:06 -0500", "message": "refactor: Inject the dependencies with method arguments."}, {"oid": "887f0813e5a17856d58571afd8eda4a54fc69b1a", "committedDate": "2020-12-18 12:46:26 -0500", "message": "chore: port to blackduck-common 51."}, {"oid": "dcf8c836b3eb424d6239b117e29fdae2e76e3693", "committedDate": "2020-12-21 12:24:37 -0500", "message": "feat: Add developer mode property."}, {"oid": "47e397ea86791eb606b1d105af393d15a92b0f64", "committedDate": "2020-12-21 13:06:19 -0500", "message": "Merge remote-tracking branch 'origin/master' into ps_developer_mode"}, {"oid": "f617e91a0cb531abd4876b30d693769a4df8e471", "committedDate": "2020-12-21 15:47:21 -0500", "message": "feat: Implement developer scan process and use bdio2 if developer scan enabled."}, {"oid": "2c15151f212099c69ee9d43bb59e21f0e5d9665a", "committedDate": "2020-12-22 13:34:31 -0500", "message": "feat: Add the post processing of the result for policy violations."}, {"oid": "676e4bff2f40e2ca50fd9cf3aee4605903ae9ec1", "committedDate": "2021-01-04 10:24:38 -0500", "message": "chore: Update the copyright headers."}, {"oid": "2497ac25c19fda42daad5e6ed55ebafa41c9c0c3", "committedDate": "2021-01-04 10:55:34 -0500", "message": "Merge remote-tracking branch 'origin/master' into ps_developer_mode"}, {"oid": "04031ac8ab85ebf8b79248772053e0deee91eee9", "committedDate": "2021-01-19 17:37:10 -0500", "message": "refactor: Favoring dependency injection over passing in a factory"}, {"oid": "07dc7418d99917974facb437535917728c7533d2", "committedDate": "2021-01-20 14:44:02 -0500", "message": "refactor: moving factory back into OnlineBlackDuckRunData"}, {"oid": "4f2ba16d878930a66019d4584570a1ab4b962aeb", "committedDate": "2021-01-20 14:44:36 -0500", "message": "feat: Add the ability to create a JSON file of developer mode results."}, {"oid": "b746ab8169a39089379db85a218c89398a097da8", "committedDate": "2021-01-20 17:07:56 -0500", "message": "refactor: Improved the api of BlackDuckRunData"}, {"oid": "8d5e738bae67fc7d53e266c08b1a551631efef04", "committedDate": "2021-01-22 06:42:18 -0500", "message": "feat: Disable Bazel, Docker Inspector, and Polaris for dev mode scan."}, {"oid": "28c0b46bb0f3fd124ac7c43009692cfb2da76a24", "committedDate": "2021-01-22 12:42:59 -0500", "message": "refactor: Iplement first round of review feedback."}, {"oid": "fe63a63280ccc6e90243bfdc870314bea9540c73", "committedDate": "2021-01-22 16:19:17 -0500", "message": "refactor: Use the Product decisions to validate the parameters and run rapid_mode scan."}, {"oid": "f5aa7a0c24828bc262bfea68219845cfb3adef28", "committedDate": "2021-01-22 16:52:47 -0500", "message": "Merge remote-tracking branch 'origin/master' into ps_developer_mode"}, {"oid": "399ab2f23e01f6a949c2c34408781effa6d2e94a", "committedDate": "2021-02-01 11:30:30 -0500", "message": "feat: Implement initial workflows with operations."}, {"oid": "a8369516076c23fa2634df2eba9703db75f5c6d9", "committedDate": "2021-02-02 06:46:19 -0500", "message": "refactor: Move workflow into RunOptions."}, {"oid": "6c30182dc5446b63eb6b58f7343f58bba9a9ec2d", "committedDate": "2021-02-03 15:10:47 -0500", "message": "refactor: Update rapid scan output and use blackduck-common 52."}, {"oid": "796cec7992add8ce41bebd0c027cfdb7bce8a444", "committedDate": "2021-02-03 17:33:18 -0500", "message": "refactor: Use operations with original runManager."}, {"oid": "cabc36bb74c9dd158057de7363bbe3708719e3c9", "committedDate": "2021-02-03 19:04:34 -0500", "message": "refactor: Update the operations based on feedback."}, {"oid": "6fbec8af0e92b5c13c5efbf428be2d38d218b058", "committedDate": "2021-02-03 19:44:44 -0500", "message": "refactor: Remove the Workflow property and use the existing scan mode."}, {"oid": "f42aa793ea922b8a661aac13cb523640b469e5ba", "committedDate": "2021-02-04 09:37:11 -0500", "message": "fix: Check if BlackDuck is online before running Rapid Scan."}, {"oid": "43fbf3c47121e97e3ef4bfb3c92158d713affa0a", "committedDate": "2021-02-04 13:30:35 -0500", "message": "refactor: Update based on PR feedback."}, {"oid": "620ed822ead4ec354f4f40285b749e3e48177c22", "committedDate": "2021-02-04 15:19:09 -0500", "message": "Merge remote-tracking branch 'origin/master' into ps_workflow_2"}, {"oid": "d906ea6ed2a645b8dce109115312cb87965a622f", "committedDate": "2021-02-04 15:25:58 -0500", "message": "fix: Ensure blackduck online for rapid scan."}, {"oid": "390db53034c483bee3423231fd223f9a711ecb09", "committedDate": "2021-02-26 13:25:27 -0500", "message": "chore: Update headers to the new format."}, {"oid": "402c8f066ad33d04cbd5a2945e74423e84c75da0", "committedDate": "2021-03-11 08:42:32 -0500", "message": "refactor: Don't mutate RunResult in some operations and add new event classes."}, {"oid": "3522ba51d67252717cdbfa0670db9980afc43d80", "committedDate": "2021-03-11 13:13:21 -0500", "message": "refactor: Create classes to publish events and replace EventSystem."}, {"oid": "56f27dcd4dd53c096ea05633dafe23a45549583b", "committedDate": "2021-03-17 14:20:37 -0400", "message": "refactor: Move the try catch block into RunManager to use RunContext for OperationSystem."}, {"oid": "5a5c465921e71249eacf1bf01b053bde45ec2731", "committedDate": "2021-03-22 17:11:39 -0400", "message": "refactor: Update to the latest blackduck-common changes."}, {"oid": "0423579df206691c24651fb9bf7624ade63cda7d", "committedDate": "2021-03-23 14:41:12 -0400", "message": "refactor: Update imports to the latest blackduck-common."}, {"oid": "b8e6f2cbef6d772f1b9a7401bf42dd3b3093ebc3", "committedDate": "2021-03-24 13:09:37 -0400", "message": "refactor(aggregate): Renamed to Aggregate Decision from Options."}, {"oid": "1f9d044c8e8fa01ffdb49e07e1d400877e1a176b", "committedDate": "2021-03-25 12:52:27 -0400", "message": "refactor: Using decisions to predict as much up front as possible."}, {"oid": "2f0d33f24265eefe47af59b5ea4791f5c1f82dcd", "committedDate": "2021-03-25 18:41:52 -0400", "message": "refactor: Simplifying decisions around some tools."}, {"oid": "c8bf57016f94250a4f0d9bc7c055b84ad759cd75", "committedDate": "2021-03-29 14:06:35 -0400", "message": "feat: Passing docker tar to binary but using docker target object instead of single docker file."}, {"oid": "79f1919fbf38dc4c90d82b7d2e629b581e631c94", "committedDate": "2021-03-29 16:42:16 -0400", "message": "refactor: Moving specific tool decisions to tool filter."}, {"oid": "8c8fe00bbb99ae6fdea5fd28f65d5c9d138fba06", "committedDate": "2021-03-29 18:01:40 -0400", "message": "Merge branch 'master' into detect.target.type"}, {"oid": "25f3cdac1a930ee6499183e2dac8b432be40ea5f", "committedDate": "2021-04-13 17:13:10 -0400", "message": "refactor: first pass at removing polaris code"}, {"oid": "f5fd63207bdf63efed9074b462badf6a80f86c55", "committedDate": "2021-04-22 11:36:27 -0400", "message": "refactor: Removed detect context and detect configuration so instead of beans, detect using singletons and factories."}, {"oid": "6c880cc789b07b3b42c3de8b781bfd06683fe7d1", "committedDate": "2021-05-03 17:01:17 -0400", "message": "refactor: Introduced step runners to handle conditional running of atomic operations."}, {"oid": "9a6db387a1392364886d4bc7b11ac32974b17eba", "committedDate": "2021-05-20 16:05:32 -0400", "message": "chore: Updating headers."}, {"oid": "678c90e318030a91013aab90358529e9ca9a746b", "committedDate": "2021-05-27 14:59:05 -0400", "message": "refactor: Removing no longer used run manager."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxOTUzNQ==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/183#discussion_r435419535", "body": "This isn't after calculation though, this is after we add it to wait data. Doesn't seem like the event matches up.", "bodyText": "This isn't after calculation though, this is after we add it to wait data. Doesn't seem like the event matches up.", "bodyHTML": "<p dir=\"auto\">This isn't after calculation though, this is after we add it to wait data. Doesn't seem like the event matches up.</p>", "author": "taikuukaits", "createdAt": "2020-06-04T17:16:16Z", "path": "src/main/java/com/synopsys/integration/detect/workflow/blackduck/CodeLocationWaitData.java", "diffHunk": "@@ -24,19 +24,26 @@\n \n import java.util.Date;\n import java.util.HashSet;\n+import java.util.List;\n import java.util.Set;\n \n import com.synopsys.integration.blackduck.codelocation.CodeLocationCreationData;\n import com.synopsys.integration.blackduck.service.model.NotificationTaskRange;\n+import com.synopsys.integration.detect.workflow.event.Event;\n+import com.synopsys.integration.detect.workflow.event.EventSystem;\n \n public class CodeLocationWaitData {\n     private NotificationTaskRange notificationRange;\n     private Set<String> codeLocationNames = new HashSet<>();\n     private int expectedNotificationCount = 0;\n \n-    public void addWaitForCreationData(CodeLocationCreationData codeLocationCreationData) {\n+    public void addWaitForCreationData(CodeLocationCreationData codeLocationCreationData, EventSystem eventSystem) {\n         expectedNotificationCount += codeLocationCreationData.getOutput().getExpectedNotificationCount();\n-        codeLocationNames.addAll(codeLocationCreationData.getOutput().getSuccessfulCodeLocationNames());\n+\n+        Set<String> codeLocationNames = codeLocationCreationData.getOutput().getSuccessfulCodeLocationNames();\n+        this.codeLocationNames.addAll(codeLocationNames);\n+        eventSystem.publishEvent(Event.CodeLocationNamesCalculated, codeLocationNames);", "originalCommit": "1f5b0dc60a91e1f1c15d9faaeb3e635c1b408072", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1Mjk3NA==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/183#discussion_r435452974", "bodyText": "is the name of the event what you have an issue with?", "author": "crowleySynopsys", "createdAt": "2020-06-04T18:12:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxOTUzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwNDE4MA==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/183#discussion_r436004180", "bodyText": "I'm concerned that publishing the events is not the responsibility of the WaitData, because as a consumer of that class I would assume I could call \"addWaitForCreationData\" multiple times but those events imply that it is called once. Did you consider having the caller send the event? My interpretation is that WaitData is like a DateRange where I can extend the range (extendToIncludeDays is to addWaitForCreationData) so I wouldn't expect it to have any logic (such as publishing events) and would put that on the caller.", "author": "taikuukaits", "createdAt": "2020-06-05T15:39:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxOTUzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxOTIzNA==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/183#discussion_r436019234", "bodyText": "I see.  Yeah I just figured I'd publish within the method since it was already extracting the names I wanted sent to the event system, and otherwise I'd be doing so every time the method was called.  The event would be more appropriately named CodeLocationNamesAdded, as it is a mechanism to update the code location names found by all the different tools on a rolling basis.  If you think that publishing an event is confusing the role of the class, though, I'd be fine delegating to the caller", "author": "crowleySynopsys", "createdAt": "2020-06-05T16:05:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxOTUzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAzNzkxMw==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/183#discussion_r436037913", "bodyText": "Ah I see, then it is the event name and the class name that I am reacting to. If it was CodeLocationNamesAdded and CodeLocationWaitController (to me data means that it doesn't have the logic) then I think I would be OK with it.", "author": "taikuukaits", "createdAt": "2020-06-05T16:41:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxOTUzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1MzMyMw==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/183#discussion_r436053323", "bodyText": "Okay cool, those name changes seem reasonable to me.", "author": "crowleySynopsys", "createdAt": "2020-06-05T17:12:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxOTUzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "a8a6789d12b30cbc88cf39e7ea167867ceb0b358", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/workflow/blackduck/CodeLocationWaitData.java b/src/main/java/com/synopsys/integration/detect/workflow/blackduck/CodeLocationWaitController.java\nsimilarity index 95%\nrename from src/main/java/com/synopsys/integration/detect/workflow/blackduck/CodeLocationWaitData.java\nrename to src/main/java/com/synopsys/integration/detect/workflow/blackduck/CodeLocationWaitController.java\nindex 4c509f4a6..65cd4b001 100644\n--- a/src/main/java/com/synopsys/integration/detect/workflow/blackduck/CodeLocationWaitData.java\n+++ b/src/main/java/com/synopsys/integration/detect/workflow/blackduck/CodeLocationWaitController.java\n", "chunk": "@@ -42,7 +41,7 @@ public class CodeLocationWaitData {\n \n         Set<String> codeLocationNames = codeLocationCreationData.getOutput().getSuccessfulCodeLocationNames();\n         this.codeLocationNames.addAll(codeLocationNames);\n-        eventSystem.publishEvent(Event.CodeLocationNamesCalculated, codeLocationNames);\n+        eventSystem.publishEvent(Event.CodeLocationNamesAdded, codeLocationNames);\n \n         if (null == notificationRange) {\n             notificationRange = codeLocationCreationData.getNotificationTaskRange();\n", "next_change": null}]}}, {"oid": "77f5bc128db3ea50db4eca2b4b70abec3af00b35", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/77f5bc128db3ea50db4eca2b4b70abec3af00b35", "message": "fix: Renamed collectCodeLocationNames to createCodeLocationNames", "committedDate": "2020-06-05T14:29:01Z", "type": "commit"}, {"oid": "a8a6789d12b30cbc88cf39e7ea167867ceb0b358", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/a8a6789d12b30cbc88cf39e7ea167867ceb0b358", "message": "style: renamed Event.CodeLocationNamesCalculated Event.CodeLocationNamesAdded -> , CodeLocationWaitData -> CodeLocationWaitController", "committedDate": "2020-06-05T17:19:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU2Mjc0MQ==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/183#discussion_r437562741", "body": "Shouldn't this be renamed to `codeLocationsAdded`?", "bodyText": "Shouldn't this be renamed to codeLocationsAdded?", "bodyHTML": "<p dir=\"auto\">Shouldn't this be renamed to <code>codeLocationsAdded</code>?</p>", "author": "JakeMathews", "createdAt": "2020-06-09T16:27:59Z", "path": "src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java", "diffHunk": "@@ -130,8 +130,8 @@ private void detectorsComplete(final DetectorToolResult detectorToolResult) {\n         this.detectorToolResult = detectorToolResult;\n     }\n \n-    private void codeLocationsCalculated(final BdioCodeLocationResult bdioCodeLocationResult) {\n-        this.bdioCodeLocationResult = bdioCodeLocationResult;\n+    private void codeLocationsCalculated(final Collection<String> codeLocations) {", "originalCommit": "a8a6789d12b30cbc88cf39e7ea167867ceb0b358", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c1c95687a4c3d578ed9cb626bbf816d5bd6cb657", "changed_code": [{"header": "diff --git a/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java b/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\nindex c55e80a48..1ec442b24 100644\n--- a/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\n+++ b/src/main/java/com/synopsys/integration/detect/workflow/report/output/FormattedOutputManager.java\n", "chunk": "@@ -130,7 +130,7 @@ public class FormattedOutputManager {\n         this.detectorToolResult = detectorToolResult;\n     }\n \n-    private void codeLocationsCalculated(final Collection<String> codeLocations) {\n+    private void codeLocationsAdded(final Collection<String> codeLocations) {\n         this.codeLocations.addAll(codeLocations);\n     }\n \n", "next_change": null}]}}, {"oid": "c1c95687a4c3d578ed9cb626bbf816d5bd6cb657", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/c1c95687a4c3d578ed9cb626bbf816d5bd6cb657", "message": "refactor: Renamed FormattedOutputManager.codeLocationsCalculated to FormattedOutputManager.codeLocationsAdded", "committedDate": "2020-06-09T17:12:39Z", "type": "commit"}, {"oid": "8f431ae1bcb91f141782eda213a2479dd2ef3852", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/8f431ae1bcb91f141782eda213a2479dd2ef3852", "message": "Merge branch 'master' into statusJsonCodeLocations", "committedDate": "2020-06-09T17:24:18Z", "type": "commit"}, {"oid": "7780d24c03b20eaac655bdb33450d4c79ca7dfb5", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/7780d24c03b20eaac655bdb33450d4c79ca7dfb5", "message": "fix: Resolving errors from merge conflict resolutions", "committedDate": "2020-06-09T17:28:23Z", "type": "commit"}]}