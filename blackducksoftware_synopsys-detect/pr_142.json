{"pr_number": 142, "pr_title": "Sb sonarcloud issues", "pr_createdAt": "2020-03-30T22:05:22Z", "pr_url": "https://github.com/blackducksoftware/synopsys-detect/pull/142", "merge_commit": "0cad8d9ebff835cf43e60cdc9a3c699447389c36", "timeline": [{"oid": "cc4e59c91ccabb498143c3b023d8496d50913ded", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/cc4e59c91ccabb498143c3b023d8496d50913ded", "message": "refactor: bazel: sonarqube issues", "committedDate": "2020-03-30T21:43:03Z", "type": "commit"}, {"oid": "30e8b17b848443fd309dff2713df5d86cc1b5769", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/30e8b17b848443fd309dff2713df5d86cc1b5769", "message": "refactor: clang: sonarcloud issues", "committedDate": "2020-03-30T21:43:39Z", "type": "commit"}, {"oid": "7f2d0c848b2bca4974533f4c627d9cdbfa0aac9e", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/7f2d0c848b2bca4974533f4c627d9cdbfa0aac9e", "message": "refactor: clang: sonarcloud issue (complexity)", "committedDate": "2020-03-30T21:52:22Z", "type": "commit"}, {"oid": "6868ccfe8746a34981739c3f5b3d94f990f1f547", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/6868ccfe8746a34981739c3f5b3d94f990f1f547", "message": "refactor: whitespace", "committedDate": "2020-03-30T21:52:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU0MzMwNg==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/142#discussion_r400543306", "body": "I'd prefer we changed this as it reads strangely to me. So instead of \"isLastCharWasEscapeChar\" we could do \"wasLastCharEscapeChar\".", "bodyText": "I'd prefer we changed this as it reads strangely to me. So instead of \"isLastCharWasEscapeChar\" we could do \"wasLastCharEscapeChar\".", "bodyHTML": "<p dir=\"auto\">I'd prefer we changed this as it reads strangely to me. So instead of \"isLastCharWasEscapeChar\" we could do \"wasLastCharEscapeChar\".</p>", "author": "taikuukaits", "createdAt": "2020-03-30T22:55:23Z", "path": "detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java", "diffHunk": "@@ -103,38 +104,74 @@ private String unEscapeDoubleQuotes(final String givenString) {\n \n     private String escapeQuotedWhitespace(final String givenString) {\n         final StringBuilder newString = new StringBuilder();\n-        boolean lastCharWasEscapeChar = false;\n-        boolean inQuotes = false;\n-        boolean quoteTypeIsDouble = false;\n+        final ParserState parserState = new ParserState();\n         for (int i = 0; i < givenString.length(); i++) {\n             final char c = givenString.charAt(i);\n-            if (!inQuotes) {\n-                if (!lastCharWasEscapeChar && (c == SINGLE_QUOTE_CHAR)) {\n-                    inQuotes = true;\n-                    quoteTypeIsDouble = false;\n-                } else if (!lastCharWasEscapeChar && (c == DOUBLE_QUOTE_CHAR)) {\n-                    inQuotes = true;\n-                    quoteTypeIsDouble = true;\n-                } else {\n-                    newString.append(c);\n-                }\n+            if (!parserState.isInQuotes()) {\n+                processNonQuotedChar(parserState, c, newString);\n             } else {\n-                // Currently inside a quoted substring\n-                if (!lastCharWasEscapeChar && (c == SINGLE_QUOTE_CHAR) && !quoteTypeIsDouble) {\n-                    inQuotes = false;\n-                } else if (!lastCharWasEscapeChar && (c == DOUBLE_QUOTE_CHAR) && quoteTypeIsDouble) {\n-                    inQuotes = false;\n-                } else if (c == SPACE_CHAR) {\n-                    newString.append(ESCAPE_SEQUENCE_FOR_SPACE_CHAR);\n-                } else if (c == TAB_CHAR) {\n-                    newString.append(ESCAPE_SEQUENCE_FOR_TAB_CHAR);\n-                } else {\n-                    newString.append(c);\n-                }\n+                processQuotedChar(parserState, c, newString);\n             }\n-            lastCharWasEscapeChar = (c == ESCAPE_CHAR);\n+            parserState.setLastCharWasEscapeChar(c == ESCAPE_CHAR);\n         }\n         logger.trace(String.format(\"escapeQuotedWhitespace() changed %s to %s\", givenString, newString.toString()));\n         return newString.toString();\n     }\n+\n+    private void processQuotedChar(final ParserState parserState, final char c, final StringBuilder newString) {\n+        // Currently inside a quoted substring\n+        if (!parserState.isLastCharWasEscapeChar() && (c == SINGLE_QUOTE_CHAR) && !parserState.isQuoteTypeIsDouble()) {\n+            parserState.setInQuotes(false);\n+        } else if (!parserState.isLastCharWasEscapeChar() && (c == DOUBLE_QUOTE_CHAR) && parserState.isQuoteTypeIsDouble()) {\n+            parserState.setInQuotes(false);\n+        } else if (c == SPACE_CHAR) {\n+            newString.append(ESCAPE_SEQUENCE_FOR_SPACE_CHAR);\n+        } else if (c == TAB_CHAR) {\n+            newString.append(ESCAPE_SEQUENCE_FOR_TAB_CHAR);\n+        } else {\n+            newString.append(c);\n+        }\n+    }\n+\n+    private void processNonQuotedChar(final ParserState parserState, final char c, final StringBuilder newString) {\n+        if (!parserState.isLastCharWasEscapeChar() && (c == SINGLE_QUOTE_CHAR)) {\n+            parserState.setInQuotes(true);\n+            parserState.setQuoteTypeIsDouble(false);\n+        } else if (!parserState.isLastCharWasEscapeChar() && (c == DOUBLE_QUOTE_CHAR)) {\n+            parserState.setInQuotes(true);\n+            parserState.setQuoteTypeIsDouble(true);\n+        } else {\n+            newString.append(c);\n+        }\n+    }\n+\n+    private class ParserState {\n+        private boolean lastCharWasEscapeChar = false;\n+        private boolean inQuotes = false;\n+        private boolean quoteTypeIsDouble = false;\n+\n+        public boolean isLastCharWasEscapeChar() {", "originalCommit": "6868ccfe8746a34981739c3f5b3d94f990f1f547", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU0MzUwNQ==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/142#discussion_r400543505", "bodyText": "Or if we wanted to keep the \"is\" maybe \"isLastCharEscapeChar\".", "author": "taikuukaits", "createdAt": "2020-03-30T22:55:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU0MzMwNg=="}], "type": "inlineReview", "revised_code": {"commit": "66dd30b8f3eac44ee951aab4225d61deb1b61c22", "changed_code": [{"header": "diff --git a/detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java b/detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java\nindex 11f1c20d4..7616f90ca 100644\n--- a/detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java\n+++ b/detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java\n", "chunk": "@@ -150,7 +150,7 @@ public class CompileCommandParser {\n         private boolean inQuotes = false;\n         private boolean quoteTypeIsDouble = false;\n \n-        public boolean isLastCharWasEscapeChar() {\n+        public boolean isLastCharEscapeChar() {\n             return lastCharWasEscapeChar;\n         }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "0cad8d9ebff835cf43e60cdc9a3c699447389c36", "changed_code": [{"header": "diff --git a/detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java b/detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java\nindex 11f1c20d4..7616f90ca 100644\n--- a/detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java\n+++ b/detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java\n", "chunk": "@@ -150,7 +150,7 @@ public class CompileCommandParser {\n         private boolean inQuotes = false;\n         private boolean quoteTypeIsDouble = false;\n \n-        public boolean isLastCharWasEscapeChar() {\n+        public boolean isLastCharEscapeChar() {\n             return lastCharWasEscapeChar;\n         }\n \n", "next_change": {"commit": "65a4b782be69ad82653b1b21566642258e6a8694", "changed_code": [{"header": "diff --git a/detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java b/detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java\nindex 7616f90ca..5309a87f0 100644\n--- a/detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java\n+++ b/detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java\n", "chunk": "@@ -133,45 +139,45 @@ public class CompileCommandParser {\n         }\n     }\n \n-    private void processNonQuotedChar(final ParserState parserState, final char c, final StringBuilder newString) {\n+    private void processNonQuotedChar(ParserState parserState, char c, StringBuilder newString) {\n         if (!parserState.isLastCharEscapeChar() && (c == SINGLE_QUOTE_CHAR)) {\n-            parserState.setInQuotes(true);\n-            parserState.setQuoteTypeIsDouble(false);\n+            parserState.setQuoteType(QuoteType.SINGLE);\n         } else if (!parserState.isLastCharEscapeChar() && (c == DOUBLE_QUOTE_CHAR)) {\n-            parserState.setInQuotes(true);\n-            parserState.setQuoteTypeIsDouble(true);\n+            parserState.setQuoteType(QuoteType.DOUBLE);\n+        } else if (parserState.isLastCharEscapeChar() && (c == DOUBLE_QUOTE_CHAR)) {\n+            parserState.setQuoteType(QuoteType.ESCAPED_DOUBLE);\n+            newString.append(ESCAPE_CHAR);\n+            newString.append(c);\n         } else {\n             newString.append(c);\n         }\n     }\n \n-    private class ParserState {\n+    private enum QuoteType {\n+        NONE,\n+        SINGLE,\n+        DOUBLE,\n+        ESCAPED_DOUBLE\n+    }\n+\n+    private class ParserState extends Stringable {\n         private boolean lastCharWasEscapeChar = false;\n-        private boolean inQuotes = false;\n-        private boolean quoteTypeIsDouble = false;\n+        private QuoteType quoteType = QuoteType.NONE;\n \n         public boolean isLastCharEscapeChar() {\n             return lastCharWasEscapeChar;\n         }\n \n-        public boolean isInQuotes() {\n-            return inQuotes;\n+        public QuoteType getQuoteType() {\n+            return quoteType;\n         }\n \n-        public boolean isDoubleQuoteType() {\n-            return quoteTypeIsDouble;\n-        }\n-\n-        public void setLastCharWasEscapeChar(final boolean lastCharWasEscapeChar) {\n+        public void setLastCharWasEscapeChar(boolean lastCharWasEscapeChar) {\n             this.lastCharWasEscapeChar = lastCharWasEscapeChar;\n         }\n \n-        public void setInQuotes(final boolean inQuotes) {\n-            this.inQuotes = inQuotes;\n-        }\n-\n-        public void setQuoteTypeIsDouble(final boolean quoteTypeIsDouble) {\n-            this.quoteTypeIsDouble = quoteTypeIsDouble;\n+        public void setQuoteType(QuoteType quoteType) {\n+            this.quoteType = quoteType;\n         }\n     }\n }\n", "next_change": {"commit": "5e2e21fadc65ff0f0112fb4d26bafc932d096ffc", "changed_code": [{"header": "diff --git a/detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java b/detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java\nindex 5309a87f0..610fe3a5a 100644\n--- a/detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java\n+++ b/detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java\n", "chunk": "@@ -54,130 +20,6 @@ public class CompileCommandParser {\n         if (StringUtils.isBlank(commandString)) {\n             commandString = String.join(\" \", compileCommand.arguments);\n         }\n-        List<String> commandList = parseCommandString(commandString, optionOverrides);\n-        return commandList;\n-    }\n-\n-    public List<String> parseCommandString(String commandString, Map<String, String> optionOverrides) {\n-        logger.trace(String.format(\"origCompileCommand         : %s\", commandString));\n-        String quotesRemovedCompileCommand = escapeQuotedWhitespace(commandString);\n-        logger.trace(String.format(\"quotesRemovedCompileCommand: %s\", quotesRemovedCompileCommand));\n-        StringTokenizer tokenizer = new StringTokenizer(quotesRemovedCompileCommand);\n-        tokenizer.setQuoteMatcher(StringMatcherFactory.INSTANCE.quoteMatcher());\n-        List<String> commandList = new ArrayList<>();\n-        String lastPart = \"\";\n-        int partIndex = 0;\n-        while (tokenizer.hasNext()) {\n-            String part = unEscapeDoubleQuotes(restoreWhitespace(tokenizer.nextToken()));\n-            if (partIndex > 0) {\n-                String optionValueOverride = null;\n-                for (String optionToOverride : optionOverrides.keySet()) {\n-                    if (optionToOverride.equals(lastPart)) {\n-                        optionValueOverride = optionOverrides.get(optionToOverride);\n-                    }\n-                }\n-                if (optionValueOverride != null) {\n-                    commandList.add(optionValueOverride);\n-                } else {\n-                    commandList.add(part);\n-                }\n-            } else {\n-                commandList.add(part);\n-            }\n-            lastPart = part;\n-            partIndex++;\n-        }\n-        return commandList;\n-    }\n-\n-    private String restoreWhitespace(String givenString) {\n-        String newString = givenString\n-                               .replace(ESCAPE_SEQUENCE_FOR_SPACE_CHAR, SPACE_CHAR_AS_STRING)\n-                               .replace(ESCAPE_SEQUENCE_FOR_TAB_CHAR, TAB_CHAR_AS_STRING);\n-        logger.trace(String.format(\"restoreWhitespace() changed %s to %s\", givenString, newString));\n-        return newString;\n-    }\n-\n-    private String unEscapeDoubleQuotes(String givenString) {\n-        String newString = givenString.replaceAll(ESCAPED_DOUBLE_QUOTE, DOUBLE_QUOTE);\n-        logger.trace(String.format(\"unEscapeDoubleQuotes() changed %s to %s\", givenString, newString));\n-        return newString;\n-    }\n-\n-    private String escapeQuotedWhitespace(String givenString) {\n-        StringBuilder newString = new StringBuilder();\n-        ParserState parserState = new ParserState();\n-        for (int i = 0; i < givenString.length(); i++) {\n-            char c = givenString.charAt(i);\n-            if (parserState.getQuoteType() != QuoteType.NONE) {\n-                processQuotedChar(parserState, c, newString);\n-            } else {\n-                processNonQuotedChar(parserState, c, newString);\n-            }\n-            parserState.setLastCharWasEscapeChar(c == ESCAPE_CHAR);\n-        }\n-        logger.trace(String.format(\"escapeQuotedWhitespace() changed %s to %s\", givenString, newString.toString()));\n-        return newString.toString();\n-    }\n-\n-    private void processQuotedChar(ParserState parserState, char c, StringBuilder newString) {\n-        // Currently inside a quoted substring\n-        if (!parserState.isLastCharEscapeChar() && (c == SINGLE_QUOTE_CHAR) && (parserState.getQuoteType() == QuoteType.SINGLE)) {\n-            parserState.setQuoteType(QuoteType.NONE);\n-        } else if (!parserState.isLastCharEscapeChar() && (c == DOUBLE_QUOTE_CHAR) && (parserState.getQuoteType() == QuoteType.DOUBLE)) {\n-            parserState.setQuoteType(QuoteType.NONE);\n-        } else if (parserState.isLastCharEscapeChar() && (c == DOUBLE_QUOTE_CHAR) && parserState.getQuoteType() == QuoteType.ESCAPED_DOUBLE) {\n-            parserState.setQuoteType(QuoteType.NONE);\n-            newString.append(ESCAPE_CHAR);\n-            newString.append(c);\n-        } else if (c == SPACE_CHAR) {\n-            newString.append(ESCAPE_SEQUENCE_FOR_SPACE_CHAR);\n-        } else if (c == TAB_CHAR) {\n-            newString.append(ESCAPE_SEQUENCE_FOR_TAB_CHAR);\n-        } else {\n-            newString.append(c);\n-        }\n-    }\n-\n-    private void processNonQuotedChar(ParserState parserState, char c, StringBuilder newString) {\n-        if (!parserState.isLastCharEscapeChar() && (c == SINGLE_QUOTE_CHAR)) {\n-            parserState.setQuoteType(QuoteType.SINGLE);\n-        } else if (!parserState.isLastCharEscapeChar() && (c == DOUBLE_QUOTE_CHAR)) {\n-            parserState.setQuoteType(QuoteType.DOUBLE);\n-        } else if (parserState.isLastCharEscapeChar() && (c == DOUBLE_QUOTE_CHAR)) {\n-            parserState.setQuoteType(QuoteType.ESCAPED_DOUBLE);\n-            newString.append(ESCAPE_CHAR);\n-            newString.append(c);\n-        } else {\n-            newString.append(c);\n-        }\n-    }\n-\n-    private enum QuoteType {\n-        NONE,\n-        SINGLE,\n-        DOUBLE,\n-        ESCAPED_DOUBLE\n-    }\n-\n-    private class ParserState extends Stringable {\n-        private boolean lastCharWasEscapeChar = false;\n-        private QuoteType quoteType = QuoteType.NONE;\n-\n-        public boolean isLastCharEscapeChar() {\n-            return lastCharWasEscapeChar;\n-        }\n-\n-        public QuoteType getQuoteType() {\n-            return quoteType;\n-        }\n-\n-        public void setLastCharWasEscapeChar(boolean lastCharWasEscapeChar) {\n-            this.lastCharWasEscapeChar = lastCharWasEscapeChar;\n-        }\n-\n-        public void setQuoteType(QuoteType quoteType) {\n-            this.quoteType = quoteType;\n-        }\n+        return commandParser.parseCommandString(commandString, optionOverrides);\n     }\n }\n", "next_change": {"commit": "a5bb016dab03c1be90114901153142c0f0d14ec4", "changed_code": [{"header": "diff --git a/detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java b/detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java\nindex 610fe3a5a..691d57eb7 100644\n--- a/detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java\n+++ b/detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java\n", "chunk": "@@ -1,25 +1,56 @@\n+/*\n+ * detectable\n+ *\n+ * Copyright (c) 2021 Synopsys, Inc.\n+ *\n+ * Use subject to the terms and conditions of the Synopsys End User Software License and Maintenance Agreement. All rights reserved worldwide.\n+ */\n package com.synopsys.integration.detectable.detectables.clang.compilecommand;\n \n import java.util.List;\n import java.util.Map;\n \n import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n import com.synopsys.integration.common.util.parse.CommandParser;\n \n public class CompileCommandParser {\n     private final CommandParser commandParser;\n+    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n \n     public CompileCommandParser(CommandParser commandParser) {\n         this.commandParser = commandParser;\n     }\n \n     public List<String> parseCommand(CompileCommand compileCommand, Map<String, String> optionOverrides) {\n-\n         String commandString = compileCommand.command;\n         if (StringUtils.isBlank(commandString)) {\n             commandString = String.join(\" \", compileCommand.arguments);\n         }\n-        return commandParser.parseCommandString(commandString, optionOverrides);\n+        List<String> options = commandParser.parseCommandString(commandString);\n+\n+        try {\n+            performOverrides(options, optionOverrides);\n+        } catch (OverrideOptionWithNoValueException e) {\n+            logger.debug(String.format(\"Failed option override in command %s:  %s\", commandString, e.getMessage()));\n+        }\n+\n+        return options;\n+    }\n+\n+    private static void performOverrides(List<String> options, Map<String, String> optionOverrides) throws OverrideOptionWithNoValueException {\n+        for (Map.Entry<String, String> override : optionOverrides.entrySet()) {\n+            String optionToOverride = override.getKey();\n+            if (options.contains(optionToOverride)) {\n+                int indexOfOptionToOverride = options.indexOf(optionToOverride);\n+                if (indexOfOptionToOverride < options.size() - 1) {\n+                    options.set(indexOfOptionToOverride + 1, override.getValue());\n+                } else {\n+                    throw new OverrideOptionWithNoValueException(String.format(\"Option %s could not be overrode since it does not have a value\", optionToOverride));\n+                }\n+            }\n+        }\n     }\n }\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "0cad8d9ebff835cf43e60cdc9a3c699447389c36", "message": "Merge commit", "committedDate": null}, {"oid": "3d8c00bd7ce8c5211ce78c8badd4685a3b8438d3", "committedDate": "2020-06-11 14:12:51 -0400", "message": "test(clang): test for double escaped quotes in command"}, {"oid": "65a4b782be69ad82653b1b21566642258e6a8694", "committedDate": "2020-06-12 19:41:36 -0400", "message": "fix(clang): nested/escaped quoting fix"}, {"oid": "8872d82ee65491e227274813c2eeaee76928d8bb", "committedDate": "2020-06-12 22:12:14 -0400", "message": "fix(clang): more fixes to parser for more accurate parsing"}, {"oid": "babe614a4c673a3fea98ce89bb25217c07e37c0e", "committedDate": "2020-06-12 22:21:27 -0400", "message": "refactor(clang): naming"}, {"oid": "1c94dc65f4f0d13e551cb026befc5d29731d853e", "committedDate": "2020-06-12 22:51:22 -0400", "message": "refactor: code smells"}, {"oid": "56c36b297bec83aab71b35fa1c7d3bf6422b6d0d", "committedDate": "2021-01-05 11:24:39 -0500", "message": "chore: Update headers to 2021."}, {"oid": "857c9cb3864a97157227ce03a73490cd612373af", "committedDate": "2021-01-06 16:44:03 +0800", "message": "memory: add static to some inner classes to reduce memory used."}, {"oid": "390db53034c483bee3423231fd223f9a711ecb09", "committedDate": "2021-02-26 13:25:27 -0500", "message": "chore: Update headers to the new format."}, {"oid": "b73de5f78ced198443edac5614c2ebc523acf148", "committedDate": "2021-02-26 16:59:18 -0500", "message": "refactor(maven): Rename CompileCommandParser to ArgumentParser, have DetectableFactory instantiate ArgumentParser."}, {"oid": "5e2e21fadc65ff0f0112fb4d26bafc932d096ffc", "committedDate": "2021-03-16 13:45:03 -0400", "message": "refactor: Move CommandParser to 'common' subproject, decouple CompileCommand from CommandParser."}, {"oid": "0741382fc9245315094388689859e39fc8137f65", "committedDate": "2021-03-16 14:08:58 -0400", "message": "fix: Pass correct parser to filePathGenerator."}, {"oid": "a5bb016dab03c1be90114901153142c0f0d14ec4", "committedDate": "2021-03-16 16:54:02 -0400", "message": "refactor: Delegate option overriding to caller of CommandParser."}, {"oid": "3f196b31e259f76f0bafc65ebc076a6e7fcd1194", "committedDate": "2021-09-23 16:02:20 -0400", "message": "refactor(clang): Refactoring to fix long outstanding sonar issues."}, {"oid": "e3b0d3fdd43339e87cb5e704fbafce7240a7b153", "committedDate": "2021-12-03 15:00:57 -0500", "message": "refactor(detectable): Removed license headers and applied formatter to Detectables A-C"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU0Mzg1NQ==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/142#discussion_r400543855", "body": "Similarly this reads strangely. Maybe \"isDoubleQuoteType\" instead.", "bodyText": "Similarly this reads strangely. Maybe \"isDoubleQuoteType\" instead.", "bodyHTML": "<p dir=\"auto\">Similarly this reads strangely. Maybe \"isDoubleQuoteType\" instead.</p>", "author": "taikuukaits", "createdAt": "2020-03-30T22:56:52Z", "path": "detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java", "diffHunk": "@@ -103,38 +104,74 @@ private String unEscapeDoubleQuotes(final String givenString) {\n \n     private String escapeQuotedWhitespace(final String givenString) {\n         final StringBuilder newString = new StringBuilder();\n-        boolean lastCharWasEscapeChar = false;\n-        boolean inQuotes = false;\n-        boolean quoteTypeIsDouble = false;\n+        final ParserState parserState = new ParserState();\n         for (int i = 0; i < givenString.length(); i++) {\n             final char c = givenString.charAt(i);\n-            if (!inQuotes) {\n-                if (!lastCharWasEscapeChar && (c == SINGLE_QUOTE_CHAR)) {\n-                    inQuotes = true;\n-                    quoteTypeIsDouble = false;\n-                } else if (!lastCharWasEscapeChar && (c == DOUBLE_QUOTE_CHAR)) {\n-                    inQuotes = true;\n-                    quoteTypeIsDouble = true;\n-                } else {\n-                    newString.append(c);\n-                }\n+            if (!parserState.isInQuotes()) {\n+                processNonQuotedChar(parserState, c, newString);\n             } else {\n-                // Currently inside a quoted substring\n-                if (!lastCharWasEscapeChar && (c == SINGLE_QUOTE_CHAR) && !quoteTypeIsDouble) {\n-                    inQuotes = false;\n-                } else if (!lastCharWasEscapeChar && (c == DOUBLE_QUOTE_CHAR) && quoteTypeIsDouble) {\n-                    inQuotes = false;\n-                } else if (c == SPACE_CHAR) {\n-                    newString.append(ESCAPE_SEQUENCE_FOR_SPACE_CHAR);\n-                } else if (c == TAB_CHAR) {\n-                    newString.append(ESCAPE_SEQUENCE_FOR_TAB_CHAR);\n-                } else {\n-                    newString.append(c);\n-                }\n+                processQuotedChar(parserState, c, newString);\n             }\n-            lastCharWasEscapeChar = (c == ESCAPE_CHAR);\n+            parserState.setLastCharWasEscapeChar(c == ESCAPE_CHAR);\n         }\n         logger.trace(String.format(\"escapeQuotedWhitespace() changed %s to %s\", givenString, newString.toString()));\n         return newString.toString();\n     }\n+\n+    private void processQuotedChar(final ParserState parserState, final char c, final StringBuilder newString) {\n+        // Currently inside a quoted substring\n+        if (!parserState.isLastCharWasEscapeChar() && (c == SINGLE_QUOTE_CHAR) && !parserState.isQuoteTypeIsDouble()) {\n+            parserState.setInQuotes(false);\n+        } else if (!parserState.isLastCharWasEscapeChar() && (c == DOUBLE_QUOTE_CHAR) && parserState.isQuoteTypeIsDouble()) {\n+            parserState.setInQuotes(false);\n+        } else if (c == SPACE_CHAR) {\n+            newString.append(ESCAPE_SEQUENCE_FOR_SPACE_CHAR);\n+        } else if (c == TAB_CHAR) {\n+            newString.append(ESCAPE_SEQUENCE_FOR_TAB_CHAR);\n+        } else {\n+            newString.append(c);\n+        }\n+    }\n+\n+    private void processNonQuotedChar(final ParserState parserState, final char c, final StringBuilder newString) {\n+        if (!parserState.isLastCharWasEscapeChar() && (c == SINGLE_QUOTE_CHAR)) {\n+            parserState.setInQuotes(true);\n+            parserState.setQuoteTypeIsDouble(false);\n+        } else if (!parserState.isLastCharWasEscapeChar() && (c == DOUBLE_QUOTE_CHAR)) {\n+            parserState.setInQuotes(true);\n+            parserState.setQuoteTypeIsDouble(true);\n+        } else {\n+            newString.append(c);\n+        }\n+    }\n+\n+    private class ParserState {\n+        private boolean lastCharWasEscapeChar = false;\n+        private boolean inQuotes = false;\n+        private boolean quoteTypeIsDouble = false;\n+\n+        public boolean isLastCharWasEscapeChar() {\n+            return lastCharWasEscapeChar;\n+        }\n+\n+        public boolean isInQuotes() {\n+            return inQuotes;\n+        }\n+\n+        public boolean isQuoteTypeIsDouble() {", "originalCommit": "6868ccfe8746a34981739c3f5b3d94f990f1f547", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "66dd30b8f3eac44ee951aab4225d61deb1b61c22", "changed_code": [{"header": "diff --git a/detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java b/detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java\nindex 11f1c20d4..7616f90ca 100644\n--- a/detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java\n+++ b/detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java\n", "chunk": "@@ -150,7 +150,7 @@ public class CompileCommandParser {\n         private boolean inQuotes = false;\n         private boolean quoteTypeIsDouble = false;\n \n-        public boolean isLastCharWasEscapeChar() {\n+        public boolean isLastCharEscapeChar() {\n             return lastCharWasEscapeChar;\n         }\n \n", "next_change": null}, {"header": "diff --git a/detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java b/detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java\nindex 11f1c20d4..7616f90ca 100644\n--- a/detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java\n+++ b/detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java\n", "chunk": "@@ -158,7 +158,7 @@ public class CompileCommandParser {\n             return inQuotes;\n         }\n \n-        public boolean isQuoteTypeIsDouble() {\n+        public boolean isDoubleQuoteType() {\n             return quoteTypeIsDouble;\n         }\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA4Mjk4Mg==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/142#discussion_r401082982", "body": "Small nitpick, but could we swap the if so we aren't negating the statement? I think it makes it easier to read.", "bodyText": "Small nitpick, but could we swap the if so we aren't negating the statement? I think it makes it easier to read.", "bodyHTML": "<p dir=\"auto\">Small nitpick, but could we swap the if so we aren't negating the statement? I think it makes it easier to read.</p>", "author": "JakeMathews", "createdAt": "2020-03-31T17:19:40Z", "path": "detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java", "diffHunk": "@@ -103,38 +104,74 @@ private String unEscapeDoubleQuotes(final String givenString) {\n \n     private String escapeQuotedWhitespace(final String givenString) {\n         final StringBuilder newString = new StringBuilder();\n-        boolean lastCharWasEscapeChar = false;\n-        boolean inQuotes = false;\n-        boolean quoteTypeIsDouble = false;\n+        final ParserState parserState = new ParserState();\n         for (int i = 0; i < givenString.length(); i++) {\n             final char c = givenString.charAt(i);\n-            if (!inQuotes) {\n-                if (!lastCharWasEscapeChar && (c == SINGLE_QUOTE_CHAR)) {\n-                    inQuotes = true;\n-                    quoteTypeIsDouble = false;\n-                } else if (!lastCharWasEscapeChar && (c == DOUBLE_QUOTE_CHAR)) {\n-                    inQuotes = true;\n-                    quoteTypeIsDouble = true;\n-                } else {\n-                    newString.append(c);\n-                }\n+            if (!parserState.isInQuotes()) {\n+                processNonQuotedChar(parserState, c, newString);\n             } else {", "originalCommit": "6868ccfe8746a34981739c3f5b3d94f990f1f547", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "66dd30b8f3eac44ee951aab4225d61deb1b61c22", "changed_code": [{"header": "diff --git a/detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java b/detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java\nindex 11f1c20d4..7616f90ca 100644\n--- a/detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java\n+++ b/detectable/src/main/java/com/synopsys/integration/detectable/detectables/clang/compilecommand/CompileCommandParser.java\n", "chunk": "@@ -107,10 +107,10 @@ public class CompileCommandParser {\n         final ParserState parserState = new ParserState();\n         for (int i = 0; i < givenString.length(); i++) {\n             final char c = givenString.charAt(i);\n-            if (!parserState.isInQuotes()) {\n-                processNonQuotedChar(parserState, c, newString);\n-            } else {\n+            if (parserState.isInQuotes()) {\n                 processQuotedChar(parserState, c, newString);\n+            } else {\n+                processNonQuotedChar(parserState, c, newString);\n             }\n             parserState.setLastCharWasEscapeChar(c == ESCAPE_CHAR);\n         }\n", "next_change": null}]}}, {"oid": "66dd30b8f3eac44ee951aab4225d61deb1b61c22", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/66dd30b8f3eac44ee951aab4225d61deb1b61c22", "message": "refactor: updates for PR feedback", "committedDate": "2020-03-31T18:42:52Z", "type": "commit"}]}