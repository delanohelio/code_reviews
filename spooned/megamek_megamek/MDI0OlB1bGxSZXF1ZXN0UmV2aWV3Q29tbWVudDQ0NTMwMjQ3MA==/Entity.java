[CompilationUnitImpl][CtCommentImpl]/* MegaMek -
Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005 Ben Mazur (bmazur@sev.org)
Copyright (C) 2018 The MegaMek Team

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
details.
 */
[CtPackageDeclarationImpl]package megamek.common;
[CtUnresolvedImport]import megamek.common.weapons.capitalweapons.CapitalMissileWeapon;
[CtUnresolvedImport]import megamek.common.weapons.AlamoMissileWeapon;
[CtUnresolvedImport]import megamek.common.weapons.AltitudeBombAttack;
[CtUnresolvedImport]import megamek.common.weapons.CapitalMissileBearingsOnlyHandler;
[CtImportImpl]import java.util.HashMap;
[CtUnresolvedImport]import megamek.common.weapons.bombs.BombArrowIV;
[CtImportImpl]import java.util.ArrayList;
[CtUnresolvedImport]import megamek.common.weapons.bombs.ISASMissileWeapon;
[CtImportImpl]import java.util.Comparator;
[CtUnresolvedImport]import megamek.common.weapons.bombs.ISBombTAG;
[CtUnresolvedImport]import megamek.common.actions.ChargeAttackAction;
[CtUnresolvedImport]import megamek.common.preference.PreferenceManager;
[CtUnresolvedImport]import megamek.common.weapons.other.TSEMPWeapon;
[CtUnresolvedImport]import megamek.common.actions.DfaAttackAction;
[CtImportImpl]import java.util.Vector;
[CtImportImpl]import java.util.List;
[CtImportImpl]import java.util.UUID;
[CtUnresolvedImport]import megamek.common.Building.BasementType;
[CtImportImpl]import java.util.HashSet;
[CtImportImpl]import java.util.Collections;
[CtImportImpl]import java.util.stream.Collectors;
[CtUnresolvedImport]import megamek.common.options.OptionsConstants;
[CtImportImpl]import java.util.LinkedList;
[CtImportImpl]import java.util.Optional;
[CtUnresolvedImport]import megamek.common.options.IOption;
[CtUnresolvedImport]import megamek.common.IGame.Phase;
[CtUnresolvedImport]import megamek.common.weapons.bombs.CLAAAMissileWeapon;
[CtUnresolvedImport]import megamek.common.weapons.bombs.CLLAAMissileWeapon;
[CtUnresolvedImport]import megamek.common.weapons.bombs.CLBombTAG;
[CtUnresolvedImport]import megamek.common.actions.TeleMissileAttackAction;
[CtUnresolvedImport]import megamek.common.weapons.bayweapons.CapitalMissileBayWeapon;
[CtUnresolvedImport]import megamek.common.options.Quirks;
[CtUnresolvedImport]import megamek.common.weapons.bombs.ISASEWMissileWeapon;
[CtUnresolvedImport]import megamek.common.weapons.SpaceBombAttack;
[CtImportImpl]import java.math.BigInteger;
[CtImportImpl]import java.util.Collection;
[CtUnresolvedImport]import megamek.common.actions.EntityAction;
[CtUnresolvedImport]import megamek.common.actions.AttackAction;
[CtUnresolvedImport]import megamek.common.util.StringUtil;
[CtImportImpl]import java.util.Map;
[CtUnresolvedImport]import megamek.common.options.GameOptions;
[CtUnresolvedImport]import megamek.common.weapons.bombs.BombISRL10;
[CtUnresolvedImport]import megamek.common.weapons.bayweapons.TeleOperatedMissileBayWeapon;
[CtImportImpl]import java.util.Set;
[CtUnresolvedImport]import megamek.common.MovePath.MoveStepType;
[CtUnresolvedImport]import megamek.common.actions.PushAttackAction;
[CtUnresolvedImport]import megamek.common.weapons.Weapon;
[CtUnresolvedImport]import megamek.common.actions.WeaponAttackAction;
[CtUnresolvedImport]import megamek.common.options.IOptionGroup;
[CtUnresolvedImport]import megamek.common.weapons.bayweapons.AR10BayWeapon;
[CtImportImpl]import java.util.concurrent.ConcurrentHashMap;
[CtUnresolvedImport]import megamek.common.actions.DisplacementAttackAction;
[CtUnresolvedImport]import megamek.common.weapons.bombs.CLASEWMissileWeapon;
[CtImportImpl]import java.util.Iterator;
[CtUnresolvedImport]import megamek.common.weapons.bombs.ISAAAMissileWeapon;
[CtUnresolvedImport]import megamek.common.weapons.bombs.CLASMissileWeapon;
[CtUnresolvedImport]import megamek.common.weapons.bayweapons.BayWeapon;
[CtUnresolvedImport]import megamek.common.weapons.WeaponHandler;
[CtUnresolvedImport]import megamek.common.weapons.DiveBombAttack;
[CtUnresolvedImport]import megamek.common.annotations.Nullable;
[CtImportImpl]import java.util.Enumeration;
[CtUnresolvedImport]import megamek.client.ui.swing.GUIPreferences;
[CtUnresolvedImport]import megamek.common.event.GameEntityChangeEvent;
[CtUnresolvedImport]import megamek.common.actions.AbstractAttackAction;
[CtUnresolvedImport]import megamek.common.weapons.battlearmor.ISBAPopUpMineLauncher;
[CtUnresolvedImport]import megamek.common.weapons.bombs.ISLAAMissileWeapon;
[CtImportImpl]import java.text.NumberFormat;
[CtUnresolvedImport]import megamek.common.options.PartialRepairs;
[CtClassImpl][CtJavaDocImpl]/**
 * Entity is a master class for basically anything on the board except terrain.
 */
public abstract class Entity extends [CtTypeReferenceImpl]megamek.common.TurnOrdered implements [CtTypeReferenceImpl]megamek.common.Transporter , [CtTypeReferenceImpl]megamek.common.Targetable , [CtTypeReferenceImpl]megamek.common.RoundUpdated , [CtTypeReferenceImpl]megamek.common.PhaseUpdated , [CtTypeReferenceImpl]megamek.common.ITechnology {
    [CtFieldImpl][CtJavaDocImpl]/**
     */
    private static final [CtTypeReferenceImpl]long serialVersionUID = [CtLiteralImpl]1430806396279853295L;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]int DOES_NOT_TRACK_HEAT = [CtLiteralImpl]999;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]int UNLIMITED_JUMP_DOWN = [CtLiteralImpl]999;

    [CtFieldImpl][CtJavaDocImpl]/**
     * Entity Type Id Definitions These are used to identify the type of Entity,
     * such as 'mech or aero.
     */
    public static final [CtTypeReferenceImpl]long ETYPE_MECH = [CtLiteralImpl]1L;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]long ETYPE_BIPED_MECH = [CtBinaryOperatorImpl][CtLiteralImpl]1L << [CtLiteralImpl]1;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]long ETYPE_LAND_AIR_MECH = [CtBinaryOperatorImpl][CtLiteralImpl]1L << [CtLiteralImpl]2;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]long ETYPE_QUAD_MECH = [CtBinaryOperatorImpl][CtLiteralImpl]1L << [CtLiteralImpl]3;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]long ETYPE_ARMLESS_MECH = [CtBinaryOperatorImpl][CtLiteralImpl]1L << [CtLiteralImpl]4;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]long ETYPE_AERO = [CtBinaryOperatorImpl][CtLiteralImpl]1L << [CtLiteralImpl]5;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]long ETYPE_JUMPSHIP = [CtBinaryOperatorImpl][CtLiteralImpl]1L << [CtLiteralImpl]6;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]long ETYPE_WARSHIP = [CtBinaryOperatorImpl][CtLiteralImpl]1L << [CtLiteralImpl]7;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]long ETYPE_SPACE_STATION = [CtBinaryOperatorImpl][CtLiteralImpl]1L << [CtLiteralImpl]8;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]long ETYPE_CONV_FIGHTER = [CtBinaryOperatorImpl][CtLiteralImpl]1L << [CtLiteralImpl]9;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]long ETYPE_FIXED_WING_SUPPORT = [CtBinaryOperatorImpl][CtLiteralImpl]1L << [CtLiteralImpl]10;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]long ETYPE_FIGHTER_SQUADRON = [CtBinaryOperatorImpl][CtLiteralImpl]1L << [CtLiteralImpl]11;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]long ETYPE_SMALL_CRAFT = [CtBinaryOperatorImpl][CtLiteralImpl]1L << [CtLiteralImpl]12;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]long ETYPE_DROPSHIP = [CtBinaryOperatorImpl][CtLiteralImpl]1L << [CtLiteralImpl]13;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]long ETYPE_TELEMISSILE = [CtBinaryOperatorImpl][CtLiteralImpl]1L << [CtLiteralImpl]14;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]long ETYPE_INFANTRY = [CtBinaryOperatorImpl][CtLiteralImpl]1L << [CtLiteralImpl]15;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]long ETYPE_BATTLEARMOR = [CtBinaryOperatorImpl][CtLiteralImpl]1L << [CtLiteralImpl]16;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]long ETYPE_MECHWARRIOR = [CtBinaryOperatorImpl][CtLiteralImpl]1L << [CtLiteralImpl]17;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]long ETYPE_PROTOMECH = [CtBinaryOperatorImpl][CtLiteralImpl]1L << [CtLiteralImpl]18;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]long ETYPE_TANK = [CtBinaryOperatorImpl][CtLiteralImpl]1L << [CtLiteralImpl]19;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]long ETYPE_GUN_EMPLACEMENT = [CtBinaryOperatorImpl][CtLiteralImpl]1L << [CtLiteralImpl]20;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]long ETYPE_SUPER_HEAVY_TANK = [CtBinaryOperatorImpl][CtLiteralImpl]1L << [CtLiteralImpl]21;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]long ETYPE_SUPPORT_TANK = [CtBinaryOperatorImpl][CtLiteralImpl]1L << [CtLiteralImpl]22;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]long ETYPE_LARGE_SUPPORT_TANK = [CtBinaryOperatorImpl][CtLiteralImpl]1L << [CtLiteralImpl]23;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]long ETYPE_VTOL = [CtBinaryOperatorImpl][CtLiteralImpl]1L << [CtLiteralImpl]24;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]long ETYPE_SUPPORT_VTOL = [CtBinaryOperatorImpl][CtLiteralImpl]1L << [CtLiteralImpl]25;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]long ETYPE_TRIPOD_MECH = [CtBinaryOperatorImpl][CtLiteralImpl]1L << [CtLiteralImpl]26;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]long ETYPE_QUADVEE = [CtBinaryOperatorImpl][CtLiteralImpl]1L << [CtLiteralImpl]27;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]int NONE = [CtUnaryOperatorImpl]-[CtLiteralImpl]1;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]int LOC_NONE = [CtUnaryOperatorImpl]-[CtLiteralImpl]1;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]int LOC_DESTROYED = [CtUnaryOperatorImpl]-[CtLiteralImpl]2;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]int MAX_C3_NODES = [CtLiteralImpl]12;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]int MAX_C3i_NODES = [CtLiteralImpl]6;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]int GRAPPLE_BOTH = [CtLiteralImpl]0;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]int GRAPPLE_RIGHT = [CtLiteralImpl]1;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]int GRAPPLE_LEFT = [CtLiteralImpl]2;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]int DMG_NONE = [CtLiteralImpl]0;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]int DMG_LIGHT = [CtLiteralImpl]1;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]int DMG_MODERATE = [CtLiteralImpl]2;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]int DMG_HEAVY = [CtLiteralImpl]3;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]int DMG_CRIPPLED = [CtLiteralImpl]4;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]int USE_STRUCTURAL_RATING = [CtUnaryOperatorImpl]-[CtLiteralImpl]1;

    [CtFieldImpl]public static final [CtTypeReferenceImpl]java.lang.String ENTITY_AIR_TO_GROUND_SENSOR_RANGE = [CtInvocationImpl][CtTypeAccessImpl]megamek.common.Messages.getString([CtLiteralImpl]"Entity.sensor_range_vs_ground_target");

    [CtEnumImpl][CtCommentImpl]// Weapon sort order defines
    public static enum WeaponSortOrder {

        [CtEnumValueImpl]DEFAULT([CtLiteralImpl]"DEFAULT"),
        [CtEnumValueImpl]RANGE_LH([CtLiteralImpl]"RANGE_LH"),
        [CtEnumValueImpl]RANGE_HL([CtLiteralImpl]"RANGE_HL"),
        [CtEnumValueImpl]DAMAGE_LH([CtLiteralImpl]"DAMAGE_LH"),
        [CtEnumValueImpl]DAMAGE_HL([CtLiteralImpl]"DAMAGE_HL"),
        [CtEnumValueImpl]ARC([CtLiteralImpl]"ARC"),
        [CtEnumValueImpl]CUSTOM([CtLiteralImpl]"CUSTOM");
        [CtFieldImpl]public final [CtTypeReferenceImpl]java.lang.String i18nEntry;

        [CtConstructorImpl]WeaponSortOrder([CtParameterImpl][CtTypeReferenceImpl]java.lang.String s) [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl]i18nEntry = [CtVariableReadImpl]s;
        }
    }

    [CtFieldImpl]protected transient [CtTypeReferenceImpl]megamek.common.IGame game;

    [CtFieldImpl]protected [CtTypeReferenceImpl]int id = [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE;

    [CtFieldImpl]protected [CtTypeReferenceImpl]java.lang.String camoCategory = [CtFieldReadImpl]IPlayer.NO_CAMO;

    [CtFieldImpl]protected [CtTypeReferenceImpl]java.lang.String camoFileName = [CtLiteralImpl]null;

    [CtFieldImpl][CtJavaDocImpl]/**
     * ID settable by external sources (such as mm.net)
     */
    protected [CtTypeReferenceImpl]java.lang.String externalId = [CtLiteralImpl]"-1";

    [CtFieldImpl]protected [CtTypeReferenceImpl]double weight;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean omni = [CtLiteralImpl]false;

    [CtFieldImpl]protected [CtTypeReferenceImpl]java.lang.String chassis;

    [CtFieldImpl]protected [CtTypeReferenceImpl]java.lang.String model;

    [CtFieldImpl]protected [CtTypeReferenceImpl]int year = [CtLiteralImpl]3071;

    [CtFieldImpl]protected [CtTypeReferenceImpl]int techLevel;

    [CtFieldImpl]private [CtTypeReferenceImpl]megamek.common.CompositeTechLevel compositeTechLevel;

    [CtFieldImpl][CtJavaDocImpl]/**
     * Used by support vehicles to define the structural tech rating
     * (TM pg 117).  The values should come from EquipmentType.RATING_A-X.
     */
    protected [CtTypeReferenceImpl]int structuralTechRating = [CtFieldReadImpl]EquipmentType.RATING_A;

    [CtFieldImpl][CtJavaDocImpl]/**
     * Used by support vehicles to define tech rating of armor.  Default value
     * indicates that structural tech rating should be used, as in most cases
     * the armor and structural tech ratings match.
     */
    protected [CtTypeReferenceImpl]int armorTechRating = [CtFieldReadImpl]megamek.common.Entity.USE_STRUCTURAL_RATING;

    [CtFieldImpl][CtJavaDocImpl]/**
     * Used by support vehicles to define tech rating of armor.  Default value
     * indicates that structural tech rating should be used, as in most cases
     * the engine and structural tech ratings match.
     */
    protected [CtTypeReferenceImpl]int engineTechRating = [CtFieldReadImpl]megamek.common.Entity.USE_STRUCTURAL_RATING;

    [CtFieldImpl][CtJavaDocImpl]/**
     * Used by omni support vehicles to track the weight of optional fire control systems.
     */
    private [CtTypeReferenceImpl]double baseChassisFireConWeight = [CtLiteralImpl]0.0;

    [CtFieldImpl][CtJavaDocImpl]/**
     * Year to use calculating engine and control system weight and fuel efficiency for primitive
     * support vehicles and aerospace units. This needs to be tracked separately from intro year to
     * account for refits that change the intro year but don't affect the structural components
     */
    private [CtTypeReferenceImpl]int originalBuildYear = [CtUnaryOperatorImpl]-[CtLiteralImpl]1;

    [CtFieldImpl]private [CtTypeReferenceImpl]megamek.common.Engine engine;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean mixedTech = [CtLiteralImpl]false;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean designValid = [CtLiteralImpl]true;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean useManualBV = [CtLiteralImpl]false;

    [CtFieldImpl]protected [CtTypeReferenceImpl]int manualBV = [CtUnaryOperatorImpl]-[CtLiteralImpl]1;

    [CtFieldImpl]protected [CtTypeReferenceImpl]int initialBV = [CtUnaryOperatorImpl]-[CtLiteralImpl]1;

    [CtFieldImpl]protected [CtTypeReferenceImpl]java.lang.String displayName = [CtLiteralImpl]null;

    [CtFieldImpl]protected [CtTypeReferenceImpl]java.lang.String shortName = [CtLiteralImpl]null;

    [CtFieldImpl]public [CtTypeReferenceImpl]int duplicateMarker = [CtLiteralImpl]1;

    [CtFieldImpl]protected transient [CtTypeReferenceImpl]megamek.common.IPlayer owner;

    [CtFieldImpl]protected [CtTypeReferenceImpl]int ownerId;

    [CtFieldImpl]protected [CtTypeReferenceImpl]int traitorId = [CtUnaryOperatorImpl]-[CtLiteralImpl]1;

    [CtFieldImpl]protected [CtTypeReferenceImpl]int targetBay = [CtUnaryOperatorImpl]-[CtLiteralImpl]1;

    [CtFieldImpl]private [CtTypeReferenceImpl]int startingPos = [CtFieldReadImpl]Board.START_NONE;

    [CtFieldImpl][CtJavaDocImpl]/**
     * The pilot of the entity. Even infantry has a 'pilot'.
     */
    private [CtTypeReferenceImpl]megamek.common.Crew crew;

    [CtFieldImpl][CtCommentImpl]// Crew and passenger numbers
    protected [CtTypeReferenceImpl]int nCrew;

    [CtFieldImpl]protected [CtTypeReferenceImpl]int nPassenger;

    [CtFieldImpl]protected [CtTypeReferenceImpl]int nMarines;

    [CtFieldImpl]private [CtTypeReferenceImpl]megamek.common.options.Quirks quirks = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.options.Quirks();

    [CtFieldImpl]private [CtTypeReferenceImpl]megamek.common.options.PartialRepairs partReps = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.options.PartialRepairs();

    [CtFieldImpl][CtCommentImpl]// Variable for manually shutdown mechs.
    protected [CtTypeReferenceImpl]boolean manualShutdown = [CtLiteralImpl]false;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean startupThisPhase = [CtLiteralImpl]false;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean shutDown = [CtLiteralImpl]false;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean shutDownThisPhase = [CtLiteralImpl]false;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean doomed = [CtLiteralImpl]false;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean destroyed = [CtLiteralImpl]false;

    [CtFieldImpl]private [CtTypeReferenceImpl]megamek.common.Coords position = [CtLiteralImpl]null;

    [CtFieldImpl][CtJavaDocImpl]/**
     * Used for Entities that are bigger than a single hex. This contains the
     * central hex plus all of the other hexes this entity occupies. The central
     * hex is important for drawing multi-hex sprites.
     */
    protected [CtTypeReferenceImpl]java.util.Map<[CtTypeReferenceImpl]java.lang.Integer, [CtTypeReferenceImpl]megamek.common.Coords> secondaryPositions = [CtLiteralImpl]null;

    [CtFieldImpl]protected [CtTypeReferenceImpl]int facing = [CtLiteralImpl]0;

    [CtFieldImpl]protected [CtTypeReferenceImpl]int sec_facing = [CtLiteralImpl]0;

    [CtFieldImpl]protected [CtTypeReferenceImpl]int walkMP = [CtLiteralImpl]0;

    [CtFieldImpl]protected [CtTypeReferenceImpl]int jumpMP = [CtLiteralImpl]0;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean done = [CtLiteralImpl]false;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean prone = [CtLiteralImpl]false;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean hullDown = [CtLiteralImpl]false;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean findingClub = [CtLiteralImpl]false;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean armsFlipped = [CtLiteralImpl]false;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean unjammingRAC = [CtLiteralImpl]false;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean selfDestructing = [CtLiteralImpl]false;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean selfDestructInitiated = [CtLiteralImpl]false;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean selfDestructedThisTurn = [CtLiteralImpl]false;

    [CtFieldImpl][CtJavaDocImpl]/**
     * Variable to store the state of a possible externally mounted searchlight.
     * True if an operable searchlight is externally mounted, false if one isn't
     * mounted or if it is destroyed. Other searchlights may be mounted as
     * equipment on the entity.
     */
    protected [CtTypeReferenceImpl]boolean hasExternalSpotlight = [CtLiteralImpl]false;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean illuminated = [CtLiteralImpl]false;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean spotlightIsActive = [CtLiteralImpl]false;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean usedSearchlight = [CtLiteralImpl]false;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean stuckInSwamp = [CtLiteralImpl]false;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean canUnstickByJumping = [CtLiteralImpl]false;

    [CtFieldImpl]protected [CtTypeReferenceImpl]int taggedBy = [CtUnaryOperatorImpl]-[CtLiteralImpl]1;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean layingMines = [CtLiteralImpl]false;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean _isEMId = [CtLiteralImpl]false;

    [CtFieldImpl]protected [CtArrayTypeReferenceImpl]boolean[] hardenedArmorDamaged;

    [CtFieldImpl]protected [CtArrayTypeReferenceImpl]boolean[] locationBlownOff;

    [CtFieldImpl]protected [CtArrayTypeReferenceImpl]boolean[] locationBlownOffThisPhase;

    [CtFieldImpl]protected [CtArrayTypeReferenceImpl]int[] armorType;

    [CtFieldImpl]protected [CtArrayTypeReferenceImpl]int[] armorTechLevel;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean isJumpingNow = [CtLiteralImpl]false;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean convertingNow = [CtLiteralImpl]false;

    [CtFieldImpl]private [CtTypeReferenceImpl]int conversionMode = [CtLiteralImpl]0;

    [CtFieldImpl]protected [CtTypeReferenceImpl]megamek.common.EntityMovementMode previousMovementMode;

    [CtFieldImpl]protected [CtTypeReferenceImpl]megamek.common.actions.DisplacementAttackAction displacementAttack = [CtLiteralImpl]null;

    [CtFieldImpl]public [CtTypeReferenceImpl]int heat = [CtLiteralImpl]0;

    [CtFieldImpl]public [CtTypeReferenceImpl]int heatBuildup = [CtLiteralImpl]0;

    [CtFieldImpl]public [CtTypeReferenceImpl]int heatFromExternal = [CtLiteralImpl]0;

    [CtFieldImpl]public [CtTypeReferenceImpl]int coolFromExternal = [CtLiteralImpl]0;

    [CtFieldImpl]public [CtTypeReferenceImpl]int delta_distance = [CtLiteralImpl]0;

    [CtFieldImpl]public [CtTypeReferenceImpl]int mpUsed = [CtLiteralImpl]0;

    [CtFieldImpl]public [CtTypeReferenceImpl]megamek.common.EntityMovementType moved = [CtFieldReadImpl]EntityMovementType.MOVE_NONE;

    [CtFieldImpl]public [CtTypeReferenceImpl]megamek.common.EntityMovementType movedLastRound = [CtFieldReadImpl]EntityMovementType.MOVE_NONE;

    [CtFieldImpl]private [CtTypeReferenceImpl]boolean movedBackwards = [CtLiteralImpl]false;

    [CtFieldImpl][CtJavaDocImpl]/**
     * Used to keep track of usage of the power reverse quirk, which allows a
     * combat vehicle to use flank MP in reverse.  If power reverse is used and
     * a PSR is required, it adds a +1 modifier to the PSR.
     */
    private [CtTypeReferenceImpl]boolean isPowerReverse = [CtLiteralImpl]false;

    [CtFieldImpl]private [CtTypeReferenceImpl]boolean wigeLiftoffHover = [CtLiteralImpl]false;

    [CtFieldImpl]protected [CtTypeReferenceImpl]int mpUsedLastRound = [CtLiteralImpl]0;

    [CtFieldImpl]public [CtTypeReferenceImpl]boolean gotPavementBonus = [CtLiteralImpl]false;

    [CtFieldImpl]public [CtTypeReferenceImpl]int wigeBonus = [CtLiteralImpl]0;

    [CtFieldImpl]public [CtTypeReferenceImpl]boolean hitThisRoundByAntiTSM = [CtLiteralImpl]false;

    [CtFieldImpl]public [CtTypeReferenceImpl]boolean inReverse = [CtLiteralImpl]false;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean struck = [CtLiteralImpl]false;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean fell = [CtLiteralImpl]false;

    [CtFieldImpl]private [CtArrayTypeReferenceImpl]int[] exposure;

    [CtFieldImpl]private [CtArrayTypeReferenceImpl]int[] armor;

    [CtFieldImpl]private [CtArrayTypeReferenceImpl]int[] internal;

    [CtFieldImpl]private [CtArrayTypeReferenceImpl]int[] orig_armor;

    [CtFieldImpl]private [CtArrayTypeReferenceImpl]int[] orig_internal;

    [CtFieldImpl]public [CtTypeReferenceImpl]int damageThisPhase;

    [CtFieldImpl]public [CtTypeReferenceImpl]int damageThisRound;

    [CtFieldImpl]public [CtTypeReferenceImpl]int engineHitsThisPhase;

    [CtFieldImpl]public [CtTypeReferenceImpl]boolean rolledForEngineExplosion = [CtLiteralImpl]false;[CtCommentImpl]// So that we don't roll


    [CtFieldImpl][CtCommentImpl]// twice in one round
    public [CtTypeReferenceImpl]boolean dodging;

    [CtFieldImpl]public [CtTypeReferenceImpl]boolean reckless;

    [CtFieldImpl]private [CtTypeReferenceImpl]boolean evading = [CtLiteralImpl]false;

    [CtFieldImpl]public [CtTypeReferenceImpl]boolean spotting;

    [CtFieldImpl]private [CtTypeReferenceImpl]boolean clearingMinefield = [CtLiteralImpl]false;

    [CtFieldImpl]protected [CtTypeReferenceImpl]int killerId = [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE;

    [CtFieldImpl]private [CtTypeReferenceImpl]int offBoardDistance = [CtLiteralImpl]0;

    [CtFieldImpl]private [CtTypeReferenceImpl]megamek.common.OffBoardDirection offBoardDirection = [CtFieldReadImpl]OffBoardDirection.NONE;

    [CtFieldImpl]private [CtTypeReferenceImpl]megamek.common.OffBoardDirection retreatedDirection = [CtFieldReadImpl]OffBoardDirection.NONE;

    [CtFieldImpl]protected [CtArrayTypeReferenceImpl]int[] vectors = [CtNewArrayImpl]new int[]{ [CtLiteralImpl]0, [CtLiteralImpl]0, [CtLiteralImpl]0, [CtLiteralImpl]0, [CtLiteralImpl]0, [CtLiteralImpl]0 };

    [CtFieldImpl]private [CtTypeReferenceImpl]int recoveryTurn = [CtLiteralImpl]0;

    [CtFieldImpl][CtCommentImpl]// need to keep a list of areas that this entity has passed through on the
    [CtCommentImpl]// current turn
    private [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Coords> passedThrough = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Coords>();

    [CtFieldImpl]private [CtTypeReferenceImpl]java.util.List<[CtTypeReferenceImpl]java.lang.Integer> passedThroughFacing = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.ArrayList<>();

    [CtFieldImpl][CtJavaDocImpl]/**
     * Stores the player selected hex ground to air targeting.
     * For ground to air, distance to target for the ground unit is determined
     * by the closest hex in the flight path of the airborne unit.  It's
     * possible that there are multiple equidistance hexes in the flight path
     * and in some cases, one of those hexes will be better than the other (ie,
     * one could be side arc and one rear).  By default, MM picks the first hex,
     * but the user should be able to distinguish between multiple equi-distant
     * hexes.
     */
    private [CtTypeReferenceImpl]java.util.Map<[CtTypeReferenceImpl]java.lang.Integer, [CtTypeReferenceImpl]megamek.common.Coords> playerPickedPassThrough = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.HashMap<>();

    [CtFieldImpl]private [CtTypeReferenceImpl]boolean ramming;

    [CtFieldImpl][CtCommentImpl]// to determine what arcs have fired for large craft
    private [CtArrayTypeReferenceImpl]boolean[] frontArcFired;

    [CtFieldImpl]private [CtArrayTypeReferenceImpl]boolean[] rearArcFired;

    [CtFieldImpl][CtJavaDocImpl]/**
     * The object that tracks this unit's Inferno round hits.
     */
    public [CtTypeReferenceImpl]megamek.common.InfernoTracker infernos = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.InfernoTracker();

    [CtFieldImpl]public [CtTypeReferenceImpl]megamek.common.ArtilleryTracker aTracker = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.ArtilleryTracker();

    [CtFieldImpl]public [CtTypeReferenceImpl]megamek.common.TeleMissileTracker tmTracker = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.TeleMissileTracker();

    [CtFieldImpl]protected [CtTypeReferenceImpl]java.lang.String c3NetIdString = [CtLiteralImpl]null;

    [CtFieldImpl]protected [CtTypeReferenceImpl]int c3Master = [CtFieldReadImpl]megamek.common.Entity.NONE;

    [CtFieldImpl]protected [CtTypeReferenceImpl]int c3CompanyMasterIndex = [CtFieldReadImpl]megamek.common.Entity.LOC_DESTROYED;

    [CtFieldImpl]private [CtTypeReferenceImpl]java.lang.String c3UUID = [CtLiteralImpl]null;

    [CtFieldImpl]private [CtTypeReferenceImpl]java.lang.String c3MasterIsUUID = [CtLiteralImpl]null;

    [CtFieldImpl]private [CtArrayTypeReferenceImpl]java.lang.String[] c3iUUIDs = [CtNewArrayImpl]new [CtTypeReferenceImpl]java.lang.String[[CtFieldReadImpl]megamek.common.Entity.MAX_C3i_NODES];

    [CtFieldImpl]private [CtArrayTypeReferenceImpl]java.lang.String[] NC3UUIDs = [CtNewArrayImpl]new [CtTypeReferenceImpl]java.lang.String[[CtFieldReadImpl]megamek.common.Entity.MAX_C3i_NODES];

    [CtFieldImpl]private [CtTypeReferenceImpl]boolean networkBAP = [CtLiteralImpl]false;

    [CtFieldImpl]protected [CtTypeReferenceImpl]int structureType = [CtFieldReadImpl]EquipmentType.T_STRUCTURE_UNKNOWN;

    [CtFieldImpl]protected [CtTypeReferenceImpl]int structureTechLevel = [CtFieldReadImpl]TechConstants.T_TECH_UNKNOWN;

    [CtFieldImpl]protected [CtTypeReferenceImpl]java.lang.String source = [CtLiteralImpl]"";

    [CtFieldImpl][CtJavaDocImpl]/**
     * Keeps track of whether this Entity was hit by a TSEMP this turn.
     */
    private [CtTypeReferenceImpl]int tsempHitsThisTurn = [CtLiteralImpl]0;

    [CtFieldImpl][CtJavaDocImpl]/**
     * Keeps track of the current TSEMP effect on this entity
     */
    private [CtTypeReferenceImpl]int tsempEffect = [CtFieldReadImpl]megamek.common.weapons.other.TSEMPWeapon.TSEMP_EFFECT_NONE;

    [CtFieldImpl][CtJavaDocImpl]/**
     * Keeps track of the current ASEW effect on this entity
     */
    protected [CtTypeReferenceImpl]int asewAffectedTurns = [CtLiteralImpl]0;

    [CtFieldImpl][CtJavaDocImpl]/**
     * Keeps track of whether this Entity fired a TSEMP this turn
     */
    private [CtTypeReferenceImpl]boolean firedTsempThisTurn = [CtLiteralImpl]false;

    [CtFieldImpl][CtJavaDocImpl]/**
     * Keeps track of whether this Entity has ever fired a TSEMP.  This is used
     * to avoid having to iterate over all weapons looking for TSEMPs to reset
     * at the start of every round.
     */
    private [CtTypeReferenceImpl]boolean hasFiredTsemp = [CtLiteralImpl]false;

    [CtFieldImpl][CtJavaDocImpl]/**
     * A list of all mounted equipment. (Weapons, ammo, and misc)
     */
    protected [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.Mounted> equipmentList = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.Mounted>();

    [CtFieldImpl][CtJavaDocImpl]/**
     * A list of all mounted weapons. This only includes regular weapons, not
     * bay mounts or grouped weapon mounts.
     */
    protected [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.Mounted> weaponList = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.Mounted>();

    [CtFieldImpl][CtJavaDocImpl]/**
     * A list of all mounted weapon bays
     */
    protected [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.Mounted> weaponBayList = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.Mounted>();

    [CtFieldImpl][CtJavaDocImpl]/**
     * A list of all mounted weapon groups
     */
    protected [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.Mounted> weaponGroupList = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.Mounted>();

    [CtFieldImpl][CtJavaDocImpl]/**
     * A list of every weapon mount, including bay mounts and weapon group
     * mounts
     */
    protected [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.Mounted> totalWeaponList = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.Mounted>();

    [CtFieldImpl][CtJavaDocImpl]/**
     * A list of all mounted ammo.
     */
    protected [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.Mounted> ammoList = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.Mounted>();

    [CtFieldImpl][CtJavaDocImpl]/**
     * A list of all mounted bombs.
     */
    protected [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.Mounted> bombList = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.Mounted>();

    [CtFieldImpl][CtJavaDocImpl]/**
     * A list of all remaining equipment.
     */
    protected [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.Mounted> miscList = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.Mounted>();

    [CtFieldImpl]protected [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.INarcPod> pendingINarcPods = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.INarcPod>();

    [CtFieldImpl]protected [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.INarcPod> iNarcPods = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.INarcPod>();

    [CtFieldImpl]protected [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.NarcPod> pendingNarcPods = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.NarcPod>();

    [CtFieldImpl]protected [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.NarcPod> narcPods = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.NarcPod>();

    [CtFieldImpl]protected [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]java.lang.String> failedEquipmentList = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]java.lang.String>();

    [CtFieldImpl][CtCommentImpl]// which teams have NARCd us? a long allows for 64 teams.
    protected [CtTypeReferenceImpl]long m_lNarcedBy = [CtLiteralImpl]0;

    [CtFieldImpl]protected [CtTypeReferenceImpl]long m_lPendingNarc = [CtLiteralImpl]0;

    [CtFieldImpl][CtJavaDocImpl]/**
     * This matrix stores critical slots in the format [location][slot #]. What
     * locations entities have and how many slots there are in each is
     * determined by the subclasses of Entity such as Mech.
     */
    protected [CtArrayTypeReferenceImpl]megamek.common.CriticalSlot[][] crits;[CtCommentImpl]// [loc][slot]


    [CtFieldImpl][CtJavaDocImpl]/**
     * Stores the current movement mode.
     */
    protected [CtTypeReferenceImpl]megamek.common.EntityMovementMode movementMode = [CtFieldReadImpl]EntityMovementMode.NONE;

    [CtFieldImpl][CtJavaDocImpl]/**
     * Flag that determines if this Entity is a hidden unit or not (see TW pg
     * 259).
     */
    protected [CtTypeReferenceImpl]boolean isHidden = [CtLiteralImpl]false;

    [CtFieldImpl][CtJavaDocImpl]/**
     * Used to determine if this Entity has made a pointblank shot so far this
     * round.
     */
    protected [CtTypeReferenceImpl]boolean madePointblankShot = [CtLiteralImpl]false;

    [CtFieldImpl][CtJavaDocImpl]/**
     * Keeps track of whether this Entity should activate in a particular game
     * phase.  Generally this will be null, indicating the unit isn't
     * activating.
     */
    protected [CtTypeReferenceImpl]megamek.common.IGame.Phase hiddenActivationPhase = [CtLiteralImpl]null;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean carcass = [CtLiteralImpl]false;

    [CtFieldImpl][CtJavaDocImpl]/**
     * The components of this entity that can transport other entities.
     */
    private [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Transporter> transports = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Transporter>();

    [CtFieldImpl][CtJavaDocImpl]/**
     * The components of this entity that can transport other entities and occupy
     * pod space of an omni unit.
     */
    private [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Transporter> omniPodTransports = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Transporter>();

    [CtFieldImpl][CtJavaDocImpl]/**
     * The ids of the MechWarriors this entity has picked up
     */
    private [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]java.lang.Integer> pickedUpMechWarriors = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]java.lang.Integer>();

    [CtFieldImpl][CtJavaDocImpl]/**
     * The ID of the <code>Entity</code> that has loaded this unit.
     */
    private [CtTypeReferenceImpl]int conveyance = [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE;

    [CtFieldImpl][CtJavaDocImpl]/**
     * Set to <code>true</code> if this unit was unloaded this turn.
     */
    private [CtTypeReferenceImpl]boolean unloadedThisTurn = [CtLiteralImpl]false;

    [CtFieldImpl][CtJavaDocImpl]/**
     * Set to <code>true</code> if this unit was loaded this turn.
     */
    private [CtTypeReferenceImpl]boolean loadedThisTurn = [CtLiteralImpl]false;

    [CtFieldImpl][CtJavaDocImpl]/**
     * Need to keep a vector of entity IDs loaded in the chat lounge
     */
    private [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]java.lang.Integer> loadedKeepers = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]java.lang.Integer>();

    [CtFieldImpl][CtJavaDocImpl]/**
     * The id of the <code>Entity</code> that is the current target of a swarm
     * attack by this unit.
     */
    private [CtTypeReferenceImpl]int swarmTargetId = [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE;

    [CtFieldImpl][CtJavaDocImpl]/**
     * The id of the <code>Entity</code> that is attacking this unit with a
     * swarm attack.
     */
    private [CtTypeReferenceImpl]int swarmAttackerId = [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE;

    [CtFieldImpl][CtJavaDocImpl]/**
     * Flag that indicates that the unit can still be salvaged (given enough
     * time and parts).
     */
    private [CtTypeReferenceImpl]boolean salvageable = [CtLiteralImpl]true;

    [CtFieldImpl][CtJavaDocImpl]/**
     * The removal condition is set when the entitiy is removed from the game.
     */
    private [CtTypeReferenceImpl]int removalCondition = [CtFieldReadImpl]IEntityRemovalConditions.REMOVE_UNKNOWN;

    [CtFieldImpl][CtJavaDocImpl]/**
     * The round this unit will be deployed
     */
    private [CtTypeReferenceImpl]int deployRound = [CtLiteralImpl]0;

    [CtFieldImpl][CtJavaDocImpl]/**
     * Marks an entity as having been deployed
     */
    private [CtTypeReferenceImpl]boolean deployed = [CtLiteralImpl]false;

    [CtFieldImpl][CtJavaDocImpl]/**
     * Tracks if this entity was never deployed
     */
    private [CtTypeReferenceImpl]boolean neverDeployed = [CtLiteralImpl]true;

    [CtFieldImpl][CtJavaDocImpl]/**
     * The unit number of this entity. All entities which are members of the
     * same low-level unit are expected to share the same unit number. Future
     * implementations may store multiple unit designations in the same unit
     * number (e.g. battalion, company, platoon, and lance).
     */
    private [CtTypeReferenceImpl]short unitNumber = [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE;

    [CtFieldImpl][CtJavaDocImpl]/**
     * Indicates whether this entity has been seen by the enemy during the
     * course of this game. Used in double-blind.
     */
    private [CtTypeReferenceImpl]boolean everSeenByEnemy = [CtLiteralImpl]false;

    [CtFieldImpl][CtJavaDocImpl]/**
     * Indicates whether this entity can currently be seen by the enemy. Used in
     * double-blind.
     */
    private [CtTypeReferenceImpl]boolean visibleToEnemy = [CtLiteralImpl]false;

    [CtFieldImpl][CtJavaDocImpl]/**
     * Flag that indicates whether this entity has been detected by sensors by
     * an enemy.
     */
    private [CtTypeReferenceImpl]boolean detectedByEnemy;

    [CtFieldImpl][CtJavaDocImpl]/**
     * Check to see who has seen this Entity Used for Double Blind Reports.
     */
    private [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.IPlayer> entitySeenBy = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.IPlayer>();

    [CtFieldImpl][CtJavaDocImpl]/**
     * Check to see what players have detected this entity with sensors, for
     * double blind play.
     */
    private [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.IPlayer> entityDetectedBy = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.IPlayer>();

    [CtFieldImpl][CtJavaDocImpl]/**
     * Contains the ids of all entities that have been detected by this entity's sensors.
     * Used for double-blind on space maps - SO p117
     *
     * Entities need only be cleared from this when they move out of range,
     * are destroyed, or move off the board
     */
    public [CtTypeReferenceImpl]java.util.Set<[CtTypeReferenceImpl]java.lang.Integer> sensorContacts = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.HashSet<[CtTypeReferenceImpl]java.lang.Integer>();

    [CtFieldImpl][CtJavaDocImpl]/**
     * Contains the ids of all entities that this entity has established a firing solution on.
     * Used for double-blind on space maps - SO p117
     *
     * Entities need only be cleared from this when they move out of range,
     * are destroyed, or move off the board
     */
    public [CtTypeReferenceImpl]java.util.Set<[CtTypeReferenceImpl]java.lang.Integer> firingSolutions = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.HashSet<[CtTypeReferenceImpl]java.lang.Integer>();

    [CtFieldImpl][CtJavaDocImpl]/**
     * Whether this entity is captured or not.
     */
    private [CtTypeReferenceImpl]boolean captured = [CtLiteralImpl]false;

    [CtFieldImpl][CtJavaDocImpl]/**
     * this is the elevation of the Entity--with respect to the surface of the
     * hex it's in. In other words, this may need to *change* as it moves from
     * hex to hex--without it going up or down. I.e.--level 0 hex, elevation
     * 5--it moves to a level 2 hex, without going up or down. elevation is now
     * 3.
     */
    protected [CtTypeReferenceImpl]int elevation = [CtLiteralImpl]0;

    [CtFieldImpl][CtJavaDocImpl]/**
     * altitude is different from elevation. It is used to measure the vertical
     * distance of Aero units from the ground on low atmosphere and ground maps.
     */
    protected [CtTypeReferenceImpl]int altitude = [CtLiteralImpl]0;

    [CtFieldImpl][CtJavaDocImpl]/**
     * 2 vectors holding entity and weapon ids. to see who hit us this round
     * with a swarm volley from what launcher. This vector holds the Entity ids.
     *
     * @see megamek.common.Entity#hitBySwarmsWeapon
     */
    private [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]java.lang.Integer> hitBySwarmsEntity = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]java.lang.Integer>();

    [CtFieldImpl][CtJavaDocImpl]/**
     * A vector that stores from which launcher we where hit by a swarm weapon
     * this round. This vector holds the weapon ID's.
     *
     * @see megamek.common.Entity#hitBySwarmsEntity
     */
    private [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]java.lang.Integer> hitBySwarmsWeapon = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]java.lang.Integer>();

    [CtFieldImpl][CtJavaDocImpl]/**
     * True if and only if this is a canon (published) unit.
     */
    private [CtTypeReferenceImpl]boolean canon;

    [CtFieldImpl]private [CtTypeReferenceImpl]int assaultDropInProgress = [CtLiteralImpl]0;

    [CtFieldImpl]private [CtTypeReferenceImpl]boolean climbMode = [CtInvocationImpl][CtInvocationImpl][CtTypeAccessImpl]megamek.client.ui.swing.GUIPreferences.getInstance().getBoolean([CtTypeAccessImpl]GUIPreferences.ADVANCED_MOVE_DEFAULT_CLIMB_MODE);

    [CtFieldImpl]protected [CtTypeReferenceImpl]int lastTarget = [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE;

    [CtFieldImpl]protected [CtTypeReferenceImpl]java.lang.String lastTargetDisplayName = [CtLiteralImpl]"";

    [CtFieldImpl][CtJavaDocImpl]/**
     * the entity id of our current spot-target
     */
    private [CtTypeReferenceImpl]int spotTargetId = [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE;

    [CtFieldImpl]private [CtTypeReferenceImpl]boolean isCommander = [CtLiteralImpl]false;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean isCarefulStanding = [CtLiteralImpl]false;

    [CtFieldImpl][CtJavaDocImpl]/**
     * a vector of currently active sensors that might be able to check range
     */
    private [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Sensor> sensors = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Sensor>();

    [CtFieldImpl][CtCommentImpl]// the currently selected sensor
    private [CtTypeReferenceImpl]megamek.common.Sensor activeSensor;

    [CtFieldImpl][CtCommentImpl]// the sensor chosen for next turn
    private [CtTypeReferenceImpl]megamek.common.Sensor nextSensor;

    [CtFieldImpl][CtCommentImpl]// roll for sensor check
    private [CtTypeReferenceImpl]int sensorCheck;

    [CtFieldImpl][CtCommentImpl]// the roll for ghost targets
    private [CtTypeReferenceImpl]int ghostTargetRoll;

    [CtFieldImpl][CtCommentImpl]// the roll to override ghost targets
    private [CtTypeReferenceImpl]int ghostTargetOverride;

    [CtFieldImpl][CtCommentImpl]// Tac Ops HeatSink Coolant Failure number
    protected [CtTypeReferenceImpl]int heatSinkCoolantFailureFactor;

    [CtFieldImpl][CtCommentImpl]// for how many rounds should this unit stay shutdown due to tasering
    protected [CtTypeReferenceImpl]int taserShutdownRounds = [CtLiteralImpl]0;

    [CtFieldImpl][CtCommentImpl]// is this unit shutdown by a BA taser?
    protected [CtTypeReferenceImpl]boolean shutdownByBATaser = [CtLiteralImpl]false;

    [CtFieldImpl][CtCommentImpl]// for how many more rounds does this unit suffer from taser feedback?
    protected [CtTypeReferenceImpl]int taserFeedBackRounds = [CtLiteralImpl]0;

    [CtFieldImpl]protected [CtTypeReferenceImpl]int taserInterference = [CtLiteralImpl]0;

    [CtFieldImpl]protected [CtTypeReferenceImpl]int taserInterferenceRounds = [CtLiteralImpl]0;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean taserInterferenceHeat = [CtLiteralImpl]false;

    [CtFieldImpl][CtCommentImpl]// contains a HTML string describing BV calculation
    protected [CtTypeReferenceImpl]java.lang.StringBuffer bvText = [CtLiteralImpl]null;

    [CtFieldImpl]protected [CtTypeReferenceImpl]java.lang.String startTable = [CtLiteralImpl]"<TABLE>";

    [CtFieldImpl]protected [CtTypeReferenceImpl]java.lang.String endTable = [CtLiteralImpl]"</TABLE>";

    [CtFieldImpl]protected [CtTypeReferenceImpl]java.lang.String startRow = [CtLiteralImpl]"<TR>";

    [CtFieldImpl]protected [CtTypeReferenceImpl]java.lang.String endRow = [CtLiteralImpl]"</TR>";

    [CtFieldImpl]protected [CtTypeReferenceImpl]java.lang.String startColumn = [CtLiteralImpl]"<TD>";

    [CtFieldImpl]protected [CtTypeReferenceImpl]java.lang.String endColumn = [CtLiteralImpl]"</TD>";

    [CtFieldImpl]protected [CtTypeReferenceImpl]java.lang.String nl = [CtLiteralImpl]"<BR>";

    [CtFieldImpl][CtCommentImpl]// for how many rounds has blueshield been active?
    private [CtTypeReferenceImpl]int blueShieldRounds = [CtLiteralImpl]0;

    [CtFieldImpl][CtCommentImpl]// Entity fluff object for use with MegaMekLab
    protected [CtTypeReferenceImpl]megamek.common.EntityFluff fluff;

    [CtFieldImpl][CtCommentImpl]// a settable armor tonnage for use with MML - this is not what
    [CtCommentImpl]// is calculated by getArmorTonnage
    protected [CtTypeReferenceImpl]double armorTonnage;

    [CtFieldImpl]protected static [CtArrayTypeReferenceImpl]int[] MASC_FAILURE = [CtNewArrayImpl]new int[]{ [CtLiteralImpl]3, [CtLiteralImpl]5, [CtLiteralImpl]7, [CtLiteralImpl]11, [CtLiteralImpl]13, [CtLiteralImpl]13, [CtLiteralImpl]13 };

    [CtFieldImpl]protected static [CtArrayTypeReferenceImpl]int[] ALTERNATE_MASC_FAILURE = [CtNewArrayImpl]new int[]{ [CtLiteralImpl]0, [CtLiteralImpl]3, [CtLiteralImpl]5, [CtLiteralImpl]7, [CtLiteralImpl]11, [CtLiteralImpl]13, [CtLiteralImpl]13, [CtLiteralImpl]13 };

    [CtFieldImpl]protected static [CtArrayTypeReferenceImpl]int[] ALTERNATE_MASC_FAILURE_ENHANCED = [CtNewArrayImpl]new int[]{ [CtLiteralImpl]0, [CtLiteralImpl]3, [CtLiteralImpl]3, [CtLiteralImpl]5, [CtLiteralImpl]7, [CtLiteralImpl]11, [CtLiteralImpl]13, [CtLiteralImpl]13, [CtLiteralImpl]13 };

    [CtFieldImpl][CtCommentImpl]// MASCLevel is the # of turns MASC has been used previously
    protected [CtTypeReferenceImpl]int nMASCLevel = [CtLiteralImpl]0;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean bMASCWentUp = [CtLiteralImpl]false;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean usedMASC = [CtLiteralImpl]false;[CtCommentImpl]// Has masc been used?


    [CtFieldImpl][CtJavaDocImpl]/**
     * Nova CEWS can adjust the network on the fly. This keeps track of the C3
     * net ID to be switched to on the next turn.
     */
    private [CtTypeReferenceImpl]java.lang.String newC3NetIdString = [CtLiteralImpl]null;

    [CtFieldImpl][CtJavaDocImpl]/**
     * Keeps track of the number of iATM improved magnetic pulse (IMP) his this
     * entity took this turn.
     */
    private [CtTypeReferenceImpl]int impThisTurn = [CtLiteralImpl]0;

    [CtFieldImpl][CtJavaDocImpl]/**
     * Keeps track of the number of iATM improved magnetic pulse (IMP) his this
     * entity took last turn.
     */
    private [CtTypeReferenceImpl]int impLastTurn = [CtLiteralImpl]0;

    [CtFieldImpl]private [CtTypeReferenceImpl]int impThisTurnHeatHelp = [CtLiteralImpl]0;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean military;

    [CtFieldImpl][CtJavaDocImpl]/**
     * Keeps track of whether or not this Entity has a critically hit radical
     * heat sink.  Using a flag will prevent having to iterate over all of the
     * Entity's mounted equipment
     */
    protected [CtTypeReferenceImpl]boolean hasDamagedRHS = [CtLiteralImpl]false;

    [CtFieldImpl][CtJavaDocImpl]/**
     * Keeps track of the number of consecutive turns a radical heat sink has
     * been used.
     */
    protected [CtTypeReferenceImpl]int consecutiveRHSUses = [CtLiteralImpl]0;

    [CtFieldImpl][CtJavaDocImpl]/**
     * Flag that can be used to indicate whether this Entity should use a
     * geometric mean when computing BV.
     */
    protected [CtTypeReferenceImpl]boolean useGeometricBV = [CtLiteralImpl]false;

    [CtFieldImpl]protected [CtTypeReferenceImpl]boolean useReducedOverheatModifierBV = [CtLiteralImpl]false;

    [CtFieldImpl]private final [CtTypeReferenceImpl]java.util.Set<[CtTypeReferenceImpl]java.lang.Integer> attackedByThisTurn = [CtInvocationImpl][CtTypeAccessImpl]java.util.Collections.newSetFromMap([CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.concurrent.ConcurrentHashMap<[CtTypeReferenceImpl]java.lang.Integer, [CtTypeReferenceImpl]java.lang.Boolean>());

    [CtFieldImpl][CtJavaDocImpl]/**
     * Determines the sort order for weapons in the UnitDisplay weapon list.
     */
    private [CtTypeReferenceImpl]megamek.common.Entity.WeaponSortOrder weaponSortOrder;

    [CtFieldImpl][CtJavaDocImpl]/**
     * Maps a weapon id to a user-specified index, used to get a custom ordering
     * for weapons.
     */
    private [CtTypeReferenceImpl]java.util.Map<[CtTypeReferenceImpl]java.lang.Integer, [CtTypeReferenceImpl]java.lang.Integer> customWeapOrder = [CtLiteralImpl]null;

    [CtFieldImpl][CtJavaDocImpl]/**
     * Flag that indicates weapon sort order has changed (included ordering for
     * custom sort order).
     */
    private [CtTypeReferenceImpl]boolean weapOrderChanged = [CtLiteralImpl]false;

    [CtFieldImpl][CtJavaDocImpl]/**
     * Set of team IDs that have observed this entity making attacks from off-board
     */
    private [CtTypeReferenceImpl]java.util.Set<[CtTypeReferenceImpl]java.lang.Integer> offBoardShotObservers;

    [CtConstructorImpl][CtJavaDocImpl]/**
     * Generates a new, blank, entity.
     */
    public Entity() [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]crew = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.Crew([CtInvocationImpl]defaultCrewType());
        [CtAssignmentImpl][CtFieldWriteImpl]nCrew = [CtLiteralImpl]0;
        [CtAssignmentImpl][CtFieldWriteImpl]nPassenger = [CtLiteralImpl]0;
        [CtAssignmentImpl][CtFieldWriteImpl]nMarines = [CtLiteralImpl]0;
        [CtAssignmentImpl][CtFieldWriteImpl]armor = [CtNewArrayImpl]new [CtTypeReferenceImpl]int[[CtInvocationImpl]locations()];
        [CtAssignmentImpl][CtFieldWriteImpl]internal = [CtNewArrayImpl]new [CtTypeReferenceImpl]int[[CtInvocationImpl]locations()];
        [CtAssignmentImpl][CtFieldWriteImpl]orig_armor = [CtNewArrayImpl]new [CtTypeReferenceImpl]int[[CtInvocationImpl]locations()];
        [CtAssignmentImpl][CtFieldWriteImpl]orig_internal = [CtNewArrayImpl]new [CtTypeReferenceImpl]int[[CtInvocationImpl]locations()];
        [CtAssignmentImpl][CtFieldWriteImpl]crits = [CtNewArrayImpl]new [CtTypeReferenceImpl]megamek.common.CriticalSlot[[CtInvocationImpl]locations()][];
        [CtAssignmentImpl][CtFieldWriteImpl]exposure = [CtNewArrayImpl]new [CtTypeReferenceImpl]int[[CtInvocationImpl]locations()];
        [CtAssignmentImpl][CtFieldWriteImpl]armorType = [CtNewArrayImpl]new [CtTypeReferenceImpl]int[[CtInvocationImpl]locations()];
        [CtAssignmentImpl][CtFieldWriteImpl]armorTechLevel = [CtNewArrayImpl]new [CtTypeReferenceImpl]int[[CtInvocationImpl]locations()];
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtInvocationImpl]locations(); [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtAssignmentImpl][CtArrayWriteImpl][CtFieldReadImpl]crits[[CtVariableReadImpl]i] = [CtNewArrayImpl]new [CtTypeReferenceImpl]megamek.common.CriticalSlot[[CtInvocationImpl]getNumberOfCriticals([CtVariableReadImpl]i)];
            [CtAssignmentImpl][CtArrayWriteImpl][CtFieldReadImpl]armorType[[CtVariableReadImpl]i] = [CtFieldReadImpl]EquipmentType.T_ARMOR_UNKNOWN;
            [CtAssignmentImpl][CtArrayWriteImpl][CtFieldReadImpl]armorTechLevel[[CtVariableReadImpl]i] = [CtFieldReadImpl]TechConstants.T_TECH_UNKNOWN;
        }
        [CtAssignmentImpl][CtFieldWriteImpl]hardenedArmorDamaged = [CtNewArrayImpl]new [CtTypeReferenceImpl]boolean[[CtInvocationImpl]locations()];
        [CtAssignmentImpl][CtFieldWriteImpl]locationBlownOff = [CtNewArrayImpl]new [CtTypeReferenceImpl]boolean[[CtInvocationImpl]locations()];
        [CtAssignmentImpl][CtFieldWriteImpl]locationBlownOffThisPhase = [CtNewArrayImpl]new [CtTypeReferenceImpl]boolean[[CtInvocationImpl]locations()];
        [CtInvocationImpl]setC3NetId([CtThisAccessImpl]this);
        [CtInvocationImpl][CtFieldReadImpl]quirks.initialize();
        [CtAssignmentImpl][CtFieldWriteImpl]secondaryPositions = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.HashMap<[CtTypeReferenceImpl]java.lang.Integer, [CtTypeReferenceImpl]megamek.common.Coords>();
        [CtAssignmentImpl][CtFieldWriteImpl]fluff = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.EntityFluff();
        [CtAssignmentImpl][CtFieldWriteImpl]impThisTurn = [CtLiteralImpl]0;
        [CtAssignmentImpl][CtFieldWriteImpl]impLastTurn = [CtLiteralImpl]0;
        [CtAssignmentImpl][CtFieldWriteImpl]weaponSortOrder = [CtArrayReadImpl][CtInvocationImpl][CtTypeAccessImpl]megamek.common.Entity.WeaponSortOrder.values()[[CtInvocationImpl][CtInvocationImpl][CtTypeAccessImpl]megamek.client.ui.swing.GUIPreferences.getInstance().getDefaultWeaponSortOrder()];
        [CtAssignmentImpl][CtCommentImpl]// set a random UUID for external ID, this will help us sort enemy salvage and prisoners in MHQ
        [CtCommentImpl]// and should have no effect on MM (but need to make sure it doesnt screw up MekWars)
        [CtFieldWriteImpl]externalId = [CtInvocationImpl][CtInvocationImpl][CtTypeAccessImpl]java.util.UUID.randomUUID().toString();
        [CtInvocationImpl]initTechAdvancement();
        [CtAssignmentImpl][CtFieldWriteImpl]offBoardShotObservers = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.HashSet<>();
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @see {@link UnitType}
     */
    public abstract [CtTypeReferenceImpl]int getUnitType();

    [CtMethodImpl]public [CtTypeReferenceImpl]megamek.common.CrewType defaultCrewType() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]CrewType.SINGLE;
    }

    [CtMethodImpl]protected [CtTypeReferenceImpl]void initMilitary() [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]military = [CtInvocationImpl]hasViableWeapons();
    }

    [CtMethodImpl]protected [CtTypeReferenceImpl]boolean hasViableWeapons() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int totalDmg = [CtLiteralImpl]0;
        [CtLocalVariableImpl][CtTypeReferenceImpl]boolean hasRangeSixPlus = [CtLiteralImpl]false;
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.List<[CtTypeReferenceImpl]megamek.common.Mounted> weaponList = [CtInvocationImpl]getTotalWeaponList();
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted weapon : [CtVariableReadImpl]weaponList) [CtBlockImpl]{
            [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]weapon.isCrippled()) [CtBlockImpl]{
                [CtContinueImpl]continue;
            }
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.WeaponType type = [CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.WeaponType) ([CtVariableReadImpl]weapon.getType()));
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]type.getDamage() == [CtFieldReadImpl]WeaponType.DAMAGE_VARIABLE) [CtBlockImpl]{
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]type.getDamage() == [CtFieldReadImpl]WeaponType.DAMAGE_ARTILLERY) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]type.getDamage() == [CtFieldReadImpl]WeaponType.DAMAGE_BY_CLUSTERTABLE) [CtBlockImpl]{
                [CtOperatorAssignmentImpl][CtVariableWriteImpl]totalDmg += [CtInvocationImpl][CtVariableReadImpl]type.getRackSize();
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]type.getDamage() == [CtFieldReadImpl]WeaponType.DAMAGE_SPECIAL) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]type instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.battlearmor.ISBAPopUpMineLauncher) [CtBlockImpl]{
                    [CtOperatorAssignmentImpl][CtVariableWriteImpl]totalDmg += [CtLiteralImpl]4;
                }
            } else [CtBlockImpl]{
                [CtOperatorAssignmentImpl][CtVariableWriteImpl]totalDmg += [CtInvocationImpl][CtVariableReadImpl]type.getDamage();
            }
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]type.getLongRange() >= [CtLiteralImpl]6) [CtBlockImpl]{
                [CtAssignmentImpl][CtVariableWriteImpl]hasRangeSixPlus = [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]totalDmg >= [CtLiteralImpl]5) || [CtVariableReadImpl]hasRangeSixPlus;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Restores the entity after serialization
     */
    public [CtTypeReferenceImpl]void restore() [CtBlockImpl]{
        [CtForEachImpl][CtCommentImpl]// restore all mounted equipments
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted : [CtFieldReadImpl]equipmentList) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]mounted.restore();
        }
        [CtInvocationImpl][CtCommentImpl]// set game options, we derive some equipment's modes from this
        setGameOptions();
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the ID number of this Entity.
     *
     * @return ID Number.
     */
    public [CtTypeReferenceImpl]int getId() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]id;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Sets the ID number of this Entity, which will also set the display name
     * and short name to null.
     *
     * @param id
     * 		the new ID.
     */
    public [CtTypeReferenceImpl]void setId([CtParameterImpl][CtTypeReferenceImpl]int id) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.id = [CtVariableReadImpl]id;
        [CtAssignmentImpl][CtFieldWriteImpl]displayName = [CtLiteralImpl]null;
        [CtAssignmentImpl][CtFieldWriteImpl]shortName = [CtLiteralImpl]null;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * This returns the external ID.
     * <p>
     * Taharqa: I am changing
     * externalId to a string so I can use UUIDs in MHQ. It should only require
     * a simple parseInt to be added to it to return an integer for other
     * programs (i.e. MekWars).
     *
     * @return the ID settable by external sources (such as mm.net)
     * @throws NumberFormatException
     * 		if the stored ID is not an integer
     * @see megamek.common.Entity#externalId
     */
    public [CtTypeReferenceImpl]int getExternalId() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtTypeAccessImpl]java.lang.Integer.parseInt([CtFieldReadImpl]externalId);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.lang.String getExternalIdAsString() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]externalId;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * This sets the external ID.
     *
     * @param externalId
     * 		the new external ID for this Entity.
     * @see megamek.common.Entity#externalId
     */
    public [CtTypeReferenceImpl]void setExternalIdAsString([CtParameterImpl][CtTypeReferenceImpl]java.lang.String externalId) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.externalId = [CtVariableReadImpl]externalId;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setExternalId([CtParameterImpl][CtTypeReferenceImpl]int id) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]externalId = [CtInvocationImpl][CtTypeAccessImpl]java.lang.Integer.toString([CtVariableReadImpl]id);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * This returns the game this Entity belongs to.
     *
     * @return the game.
     */
    public [CtTypeReferenceImpl]megamek.common.IGame getGame() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]game;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * This sets the game the entity belongs to. It also restores the entity and
     * checks that the game is in a consistent state. This function takes care
     * of the units transported by this entity.
     *
     * @param game
     * 		the game.
     */
    [CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]void setGame([CtParameterImpl][CtTypeReferenceImpl]megamek.common.IGame game) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.game = [CtVariableReadImpl]game;
        [CtInvocationImpl]restore();
        [CtIfImpl][CtCommentImpl]// Make sure the owner is set.
        if ([CtBinaryOperatorImpl][CtLiteralImpl]null == [CtFieldReadImpl]owner) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE == [CtFieldReadImpl]ownerId) [CtBlockImpl]{
                [CtThrowImpl]throw [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.lang.IllegalStateException([CtLiteralImpl]"Entity doesn't know its owner's ID.");
            }
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.IPlayer player = [CtInvocationImpl][CtVariableReadImpl]game.getPlayer([CtFieldReadImpl]ownerId);
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtLiteralImpl]null == [CtVariableReadImpl]player) [CtBlockImpl]{
                [CtInvocationImpl][CtFieldReadImpl][CtTypeAccessImpl]java.lang.System.[CtFieldReferenceImpl]err.println([CtBinaryOperatorImpl][CtLiteralImpl]"Entity can't find player #" + [CtFieldReadImpl]ownerId);
            } else [CtBlockImpl]{
                [CtInvocationImpl]setOwner([CtVariableReadImpl]player);
            }
        }
        [CtForEachImpl][CtCommentImpl]// also set game for our transports
        [CtCommentImpl]// they need it to return correct entites, because they store just the
        [CtCommentImpl]// IDs
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter transport : [CtInvocationImpl]getTransports()) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]transport.setGame([CtVariableReadImpl]game);
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the unit code for this entity.
     */
    public [CtTypeReferenceImpl]java.lang.String getModel() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]model;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Sets the unit code for this Entity.
     *
     * @param model
     * 		The unit code.
     */
    public [CtTypeReferenceImpl]void setModel([CtParameterImpl][CtTypeReferenceImpl]java.lang.String model) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.model = [CtVariableReadImpl]model;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the chassis name for this entity.
     */
    public [CtTypeReferenceImpl]java.lang.String getChassis() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]chassis;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * sets the chassis name for this entity.
     *
     * @param chassis
     * 		The chassis name.
     */
    public [CtTypeReferenceImpl]void setChassis([CtParameterImpl][CtTypeReferenceImpl]java.lang.String chassis) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.chassis = [CtVariableReadImpl]chassis;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the fluff for this entity.
     */
    public [CtTypeReferenceImpl]megamek.common.EntityFluff getFluff() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]fluff;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the unit tech for this entity.
     */
    public [CtTypeReferenceImpl]int getTechLevel() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]techLevel;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Sets the tech level for this Entity.
     *
     * @param techLevel
     * 		The tech level, it must be one of the
     * 		{@link megamek.common.TechConstants TechConstants}.
     */
    public [CtTypeReferenceImpl]void setTechLevel([CtParameterImpl][CtTypeReferenceImpl]int techLevel) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.techLevel = [CtVariableReadImpl]techLevel;
        [CtInvocationImpl]recalculateTechAdvancement();
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Sets initial TechAdvancement without equipment based on construction options.
     */
    protected [CtTypeReferenceImpl]void initTechAdvancement() [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]compositeTechLevel = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.CompositeTechLevel([CtThisAccessImpl]this, [CtFieldReadImpl]F_NONE);
        [CtInvocationImpl]addSystemTechAdvancement([CtFieldReadImpl]compositeTechLevel);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]megamek.common.CompositeTechLevel factionTechLevel([CtParameterImpl][CtTypeReferenceImpl]int techFaction) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]techFaction == [CtFieldReadImpl]F_NONE) [CtBlockImpl]{
            [CtReturnImpl]return [CtFieldReadImpl]compositeTechLevel;
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.CompositeTechLevel retVal = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.CompositeTechLevel([CtThisAccessImpl]this, [CtVariableReadImpl]techFaction);
        [CtInvocationImpl]addSystemTechAdvancement([CtVariableReadImpl]retVal);
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getEquipment()) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]retVal.addComponent([CtInvocationImpl][CtVariableReadImpl]m.getType());
            [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]m.isArmored()) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]retVal.addComponent([CtFieldReadImpl]megamek.common.Entity.TA_ARMORED_COMPONENT);
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]retVal;
    }

    [CtMethodImpl]protected [CtTypeReferenceImpl]void addTechComponent([CtParameterImpl][CtTypeReferenceImpl]megamek.common.ITechnology tech) [CtBlockImpl]{
        [CtInvocationImpl][CtFieldReadImpl]compositeTechLevel.addComponent([CtVariableReadImpl]tech);
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]boolean isIntroLevel() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]compositeTechLevel.isIntroLevel();
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]boolean isUnofficial() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]compositeTechLevel.isUnofficial();
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]int getIntroductionDate() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]year;
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]int getIntroductionDate([CtParameterImpl][CtTypeReferenceImpl]boolean clan, [CtParameterImpl][CtTypeReferenceImpl]int faction) [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]year;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @return The earliest date this unit could be built, based on the latest intro date
    of the components.
     */
    public [CtTypeReferenceImpl]int getEarliestTechDate() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]compositeTechLevel.getEarliestTechDate();
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]int getPrototypeDate() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]compositeTechLevel.getPrototypeDate();
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]int getPrototypeDate([CtParameterImpl][CtTypeReferenceImpl]boolean clan, [CtParameterImpl][CtTypeReferenceImpl]int faction) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]compositeTechLevel.getPrototypeDate([CtVariableReadImpl]clan, [CtVariableReadImpl]faction);
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]int getProductionDate() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]compositeTechLevel.getProductionDate();
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]int getProductionDate([CtParameterImpl][CtTypeReferenceImpl]boolean clan, [CtParameterImpl][CtTypeReferenceImpl]int faction) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]compositeTechLevel.getProductionDate([CtVariableReadImpl]clan, [CtVariableReadImpl]faction);
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]int getCommonDate() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]compositeTechLevel.getCommonDate();
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]int getExtinctionDate() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]compositeTechLevel.getExtinctionDate();
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]int getExtinctionDate([CtParameterImpl][CtTypeReferenceImpl]boolean clan, [CtParameterImpl][CtTypeReferenceImpl]int faction) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]compositeTechLevel.getExtinctionDate([CtVariableReadImpl]clan, [CtVariableReadImpl]faction);
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]int getReintroductionDate() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]compositeTechLevel.getReintroductionDate();
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]int getReintroductionDate([CtParameterImpl][CtTypeReferenceImpl]boolean clan, [CtParameterImpl][CtTypeReferenceImpl]int faction) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]compositeTechLevel.getReintroductionDate([CtVariableReadImpl]clan, [CtVariableReadImpl]faction);
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]int getTechRating() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]compositeTechLevel.getTechRating();
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]megamek.common.SimpleTechLevel getStaticTechLevel() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]compositeTechLevel.getStaticTechLevel();
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]int getBaseAvailability([CtParameterImpl][CtTypeReferenceImpl]int era) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]compositeTechLevel.getBaseAvailability([CtVariableReadImpl]era);
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]java.lang.String getExtinctionRange() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]compositeTechLevel.getExtinctionRange();
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * return - the base construction option tech advancement
     */
    public abstract [CtTypeReferenceImpl]megamek.common.TechAdvancement getConstructionTechAdvancement();

    [CtMethodImpl][CtJavaDocImpl]/**
     * Resets techAdvancement to initial value and adjusts for all installed equipment.
     */
    public [CtTypeReferenceImpl]void recalculateTechAdvancement() [CtBlockImpl]{
        [CtInvocationImpl]initTechAdvancement();
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getEquipment()) [CtBlockImpl]{
            [CtInvocationImpl][CtFieldReadImpl]compositeTechLevel.addComponent([CtInvocationImpl][CtVariableReadImpl]m.getType());
            [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]m.isArmored()) [CtBlockImpl]{
                [CtInvocationImpl][CtFieldReadImpl]compositeTechLevel.addComponent([CtFieldReadImpl]megamek.common.Entity.TA_ARMORED_COMPONENT);
            }
        }
    }

    [CtFieldImpl]protected static final [CtTypeReferenceImpl]megamek.common.TechAdvancement TA_OMNI = [CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.TechAdvancement([CtFieldReadImpl]TECH_BASE_ALL).setISAdvancement([CtTypeAccessImpl]megamek.common.DATE_NONE, [CtTypeAccessImpl]megamek.common.DATE_NONE, [CtLiteralImpl]3052).setClanAdvancement([CtLiteralImpl]2854, [CtLiteralImpl]2856, [CtLiteralImpl]2864).setClanApproximate([CtLiteralImpl]true).setPrototypeFactions([CtTypeAccessImpl]megamek.common.F_CCY, [CtTypeAccessImpl]megamek.common.F_CSF).setProductionFactions([CtTypeAccessImpl]megamek.common.F_CCY, [CtTypeAccessImpl]megamek.common.F_DC).setTechRating([CtTypeAccessImpl]megamek.common.RATING_E).setAvailability([CtTypeAccessImpl]megamek.common.RATING_X, [CtTypeAccessImpl]megamek.common.RATING_E, [CtTypeAccessImpl]megamek.common.RATING_E, [CtTypeAccessImpl]megamek.common.RATING_D).setStaticTechLevel([CtTypeAccessImpl]SimpleTechLevel.STANDARD);

    [CtFieldImpl][CtCommentImpl]// This is not in the rules anywhere, but is implied by the existence of the Badger and Bandit
    [CtCommentImpl]// tanks used by Wolf's Dragoons and sold to the merc market as early as 3008.
    private static final [CtTypeReferenceImpl]megamek.common.TechAdvancement TA_OMNIVEHICLE = [CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.TechAdvancement([CtFieldReadImpl]TECH_BASE_ALL).setISAdvancement([CtLiteralImpl]3008, [CtTypeAccessImpl]megamek.common.DATE_NONE, [CtLiteralImpl]3052).setISApproximate([CtLiteralImpl]true).setClanAdvancement([CtLiteralImpl]2854, [CtLiteralImpl]2856, [CtLiteralImpl]2864).setClanApproximate([CtLiteralImpl]true).setPrototypeFactions([CtTypeAccessImpl]megamek.common.F_CCY, [CtTypeAccessImpl]megamek.common.F_CSF, [CtTypeAccessImpl]megamek.common.F_MERC).setProductionFactions([CtTypeAccessImpl]megamek.common.F_CCY, [CtTypeAccessImpl]megamek.common.F_DC).setTechRating([CtTypeAccessImpl]megamek.common.RATING_E).setAvailability([CtTypeAccessImpl]megamek.common.RATING_X, [CtTypeAccessImpl]megamek.common.RATING_E, [CtTypeAccessImpl]megamek.common.RATING_E, [CtTypeAccessImpl]megamek.common.RATING_D).setStaticTechLevel([CtTypeAccessImpl]SimpleTechLevel.STANDARD);

    [CtFieldImpl]protected static final [CtTypeReferenceImpl]megamek.common.TechAdvancement TA_PATCHWORK_ARMOR = [CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.TechAdvancement([CtFieldReadImpl]TECH_BASE_ALL).setAdvancement([CtTypeAccessImpl]megamek.common.DATE_PS, [CtLiteralImpl]3075, [CtLiteralImpl]3080).setApproximate([CtLiteralImpl]false, [CtLiteralImpl]false, [CtLiteralImpl]true).setTechRating([CtTypeAccessImpl]megamek.common.RATING_A).setAvailability([CtTypeAccessImpl]megamek.common.RATING_E, [CtTypeAccessImpl]megamek.common.RATING_D, [CtTypeAccessImpl]megamek.common.RATING_E, [CtTypeAccessImpl]megamek.common.RATING_E).setStaticTechLevel([CtTypeAccessImpl]SimpleTechLevel.ADVANCED);

    [CtFieldImpl]protected static final [CtTypeReferenceImpl]megamek.common.TechAdvancement TA_MIXED_TECH = [CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.TechAdvancement([CtFieldReadImpl]TECH_BASE_ALL).setISAdvancement([CtLiteralImpl]3050, [CtLiteralImpl]3082, [CtLiteralImpl]3115).setClanAdvancement([CtLiteralImpl]2820, [CtLiteralImpl]3082, [CtLiteralImpl]3115).setApproximate([CtLiteralImpl]true, [CtLiteralImpl]true, [CtLiteralImpl]true).setPrototypeFactions([CtTypeAccessImpl]megamek.common.F_CLAN, [CtTypeAccessImpl]megamek.common.F_DC, [CtTypeAccessImpl]megamek.common.F_FS, [CtTypeAccessImpl]megamek.common.F_LC).setTechRating([CtTypeAccessImpl]megamek.common.RATING_A).setAvailability([CtTypeAccessImpl]megamek.common.RATING_X, [CtTypeAccessImpl]megamek.common.RATING_X, [CtTypeAccessImpl]megamek.common.RATING_E, [CtTypeAccessImpl]megamek.common.RATING_D).setStaticTechLevel([CtTypeAccessImpl]SimpleTechLevel.ADVANCED);

    [CtFieldImpl]protected static final [CtTypeReferenceImpl]megamek.common.TechAdvancement TA_ARMORED_COMPONENT = [CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.TechAdvancement([CtFieldReadImpl]TECH_BASE_ALL).setISAdvancement([CtLiteralImpl]3061, [CtLiteralImpl]3082).setClanAdvancement([CtLiteralImpl]3061, [CtLiteralImpl]3077).setPrototypeFactions([CtTypeAccessImpl]megamek.common.F_CSF, [CtTypeAccessImpl]megamek.common.F_FW).setProductionFactions([CtTypeAccessImpl]megamek.common.F_CJF, [CtTypeAccessImpl]megamek.common.F_FW).setTechRating([CtTypeAccessImpl]megamek.common.RATING_E).setAvailability([CtTypeAccessImpl]megamek.common.RATING_X, [CtTypeAccessImpl]megamek.common.RATING_X, [CtTypeAccessImpl]megamek.common.RATING_F, [CtTypeAccessImpl]megamek.common.RATING_E).setStaticTechLevel([CtTypeAccessImpl]SimpleTechLevel.EXPERIMENTAL);

    [CtMethodImpl]public static [CtTypeReferenceImpl]megamek.common.TechAdvancement getOmniAdvancement() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]megamek.common.Entity.getOmniAdvancement([CtLiteralImpl]null);
    }

    [CtMethodImpl]public static [CtTypeReferenceImpl]megamek.common.TechAdvancement getOmniAdvancement([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Entity en) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]en instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Tank) [CtBlockImpl]{
            [CtReturnImpl]return [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.TechAdvancement([CtFieldReadImpl]megamek.common.Entity.TA_OMNIVEHICLE);
        } else [CtBlockImpl]{
            [CtReturnImpl]return [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.TechAdvancement([CtFieldReadImpl]megamek.common.Entity.TA_OMNI);
        }
    }

    [CtMethodImpl]public static [CtTypeReferenceImpl]megamek.common.TechAdvancement getPatchworkArmorAdvancement() [CtBlockImpl]{
        [CtReturnImpl]return [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.TechAdvancement([CtFieldReadImpl]megamek.common.Entity.TA_PATCHWORK_ARMOR);
    }

    [CtMethodImpl]public static [CtTypeReferenceImpl]megamek.common.TechAdvancement getMixedTechAdvancement() [CtBlockImpl]{
        [CtReturnImpl]return [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.TechAdvancement([CtFieldReadImpl]megamek.common.Entity.TA_MIXED_TECH);
    }

    [CtMethodImpl]public static [CtTypeReferenceImpl]megamek.common.TechAdvancement getArmoredComponentTechAdvancement() [CtBlockImpl]{
        [CtReturnImpl]return [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.TechAdvancement([CtFieldReadImpl]megamek.common.Entity.TA_ARMORED_COMPONENT);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Incorporate dates for components that are not in the equipment list, such as engines and structure.
     */
    protected [CtTypeReferenceImpl]void addSystemTechAdvancement([CtParameterImpl][CtTypeReferenceImpl]megamek.common.CompositeTechLevel ctl) [CtBlockImpl]{
        [CtIfImpl]if ([CtInvocationImpl]hasEngine()) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]ctl.addComponent([CtInvocationImpl]getEngine());
        }
        [CtIfImpl]if ([CtInvocationImpl]isOmni()) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]ctl.addComponent([CtFieldReadImpl]megamek.common.Entity.TA_OMNI);
        }
        [CtIfImpl]if ([CtInvocationImpl]hasPatchworkArmor()) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]ctl.addComponent([CtFieldReadImpl]megamek.common.Entity.TA_PATCHWORK_ARMOR);
            [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int loc = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]loc < [CtInvocationImpl]locations(); [CtUnaryOperatorImpl][CtVariableWriteImpl]loc++) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]ctl.addComponent([CtInvocationImpl][CtTypeAccessImpl]megamek.common.EquipmentType.getArmorTechAdvancement([CtArrayReadImpl][CtFieldReadImpl]armorType[[CtVariableReadImpl]loc], [CtInvocationImpl][CtTypeAccessImpl]megamek.common.TechConstants.isClan([CtArrayReadImpl][CtFieldReadImpl]armorTechLevel[[CtVariableReadImpl]loc])));
            }
        } else [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]ctl.addComponent([CtInvocationImpl][CtTypeAccessImpl]megamek.common.EquipmentType.getArmorTechAdvancement([CtArrayReadImpl][CtFieldReadImpl]armorType[[CtLiteralImpl]0], [CtInvocationImpl][CtTypeAccessImpl]megamek.common.TechConstants.isClan([CtArrayReadImpl][CtFieldReadImpl]armorTechLevel[[CtLiteralImpl]0])));
        }
        [CtIfImpl]if ([CtInvocationImpl]isMixedTech()) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]ctl.addComponent([CtFieldReadImpl]megamek.common.Entity.TA_MIXED_TECH);
        }
        [CtInvocationImpl][CtVariableReadImpl]ctl.addComponent([CtInvocationImpl][CtTypeAccessImpl]megamek.common.EquipmentType.getStructureTechAdvancement([CtFieldReadImpl]structureType, [CtInvocationImpl][CtTypeAccessImpl]megamek.common.TechConstants.isClan([CtFieldReadImpl]structureTechLevel)));
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getRecoveryTurn() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]recoveryTurn;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setRecoveryTurn([CtParameterImpl][CtTypeReferenceImpl]int r) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]recoveryTurn = [CtVariableReadImpl]r;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isManualShutdown() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]manualShutdown;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setManualShutdown([CtParameterImpl][CtTypeReferenceImpl]boolean tf) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]manualShutdown = [CtVariableReadImpl]tf;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void performManualShutdown() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl]isManualShutdown() || [CtBinaryOperatorImpl]([CtInvocationImpl]getTaserShutdownRounds() != [CtLiteralImpl]0)) || [CtInvocationImpl]isShutDown()) [CtBlockImpl]{
            [CtReturnImpl]return;
        }
        [CtInvocationImpl]setShutDown([CtLiteralImpl]true);
        [CtInvocationImpl]setManualShutdown([CtLiteralImpl]true);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void performManualStartup() [CtBlockImpl]{
        [CtIfImpl]if ([CtUnaryOperatorImpl]![CtInvocationImpl]isManualShutdown()) [CtBlockImpl]{
            [CtReturnImpl]return;
        }
        [CtInvocationImpl]setManualShutdown([CtLiteralImpl]false);
        [CtIfImpl][CtCommentImpl]// Can't startup if a taser shutdown or a TSEMP shutdown
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl]getTaserShutdownRounds() == [CtLiteralImpl]0) && [CtBinaryOperatorImpl]([CtInvocationImpl]getTsempEffect() != [CtFieldReadImpl]megamek.common.weapons.other.TSEMPWeapon.TSEMP_EFFECT_SHUTDOWN)) [CtBlockImpl]{
            [CtInvocationImpl]setShutDown([CtLiteralImpl]false);
            [CtInvocationImpl]setStartupThisPhase([CtLiteralImpl]true);
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks if this is a clan unit. It is determined by tech level.
     *
     * @return true if this unit is a clan unit.
     * @see megamek.common.Entity#setTechLevel(int)
     */
    public [CtTypeReferenceImpl]boolean isClan() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtFieldReadImpl]techLevel == [CtFieldReadImpl]TechConstants.T_CLAN_TW) || [CtBinaryOperatorImpl]([CtFieldReadImpl]techLevel == [CtFieldReadImpl]TechConstants.T_CLAN_ADVANCED)) || [CtBinaryOperatorImpl]([CtFieldReadImpl]techLevel == [CtFieldReadImpl]TechConstants.T_CLAN_EXPERIMENTAL)) || [CtBinaryOperatorImpl]([CtFieldReadImpl]techLevel == [CtFieldReadImpl]TechConstants.T_CLAN_UNOFFICIAL);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isClanArmor([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]getArmorTechLevel([CtVariableReadImpl]loc) == [CtFieldReadImpl]TechConstants.T_TECH_UNKNOWN) [CtBlockImpl]{
            [CtReturnImpl]return [CtInvocationImpl]isClan();
        }
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]getArmorTechLevel([CtVariableReadImpl]loc) == [CtFieldReadImpl]TechConstants.T_CLAN_TW) || [CtBinaryOperatorImpl]([CtInvocationImpl]getArmorTechLevel([CtVariableReadImpl]loc) == [CtFieldReadImpl]TechConstants.T_CLAN_ADVANCED)) || [CtBinaryOperatorImpl]([CtInvocationImpl]getArmorTechLevel([CtVariableReadImpl]loc) == [CtFieldReadImpl]TechConstants.T_CLAN_EXPERIMENTAL)) || [CtBinaryOperatorImpl]([CtInvocationImpl]getArmorTechLevel([CtVariableReadImpl]loc) == [CtFieldReadImpl]TechConstants.T_CLAN_UNOFFICIAL);
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]int getTechBase() [CtBlockImpl]{
        [CtReturnImpl]return [CtConditionalImpl][CtInvocationImpl]isClan() ? [CtFieldReadImpl]TECH_BASE_CLAN : [CtFieldReadImpl]TECH_BASE_IS;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isMixedTech() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]mixedTech;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setMixedTech([CtParameterImpl][CtTypeReferenceImpl]boolean mixedTech) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.mixedTech = [CtVariableReadImpl]mixedTech;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isDesignValid() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]designValid;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setDesignValid([CtParameterImpl][CtTypeReferenceImpl]boolean designValid) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.designValid = [CtVariableReadImpl]designValid;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getYear() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]year;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setYear([CtParameterImpl][CtTypeReferenceImpl]int year) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.year = [CtVariableReadImpl]year;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @return the tonnage of the Entity, not its weight
     */
    public [CtTypeReferenceImpl]double getWeight() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]weight;
    }

    [CtMethodImpl][CtCommentImpl]// TODO: WeightClass is no longer correct. See the Tech Manual
    public [CtTypeReferenceImpl]int getWeightClass() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtTypeAccessImpl]megamek.common.EntityWeightClass.getWeightClass([CtInvocationImpl]getWeight(), [CtThisAccessImpl]this);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.lang.String getWeightClassName() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtTypeAccessImpl]megamek.common.EntityWeightClass.getClassName([CtInvocationImpl]getWeightClass(), [CtThisAccessImpl]this);
    }

    [CtMethodImpl][CtCommentImpl]// Since this varies by unit type, it will be defined as overrides in each relevant class
    public [CtTypeReferenceImpl]boolean isSuperHeavy() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setWeight([CtParameterImpl][CtTypeReferenceImpl]double weight) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.weight = [CtVariableReadImpl]weight;
        [CtInvocationImpl][CtCommentImpl]// Any time the weight is reset we need to reset the crew size
        [CtFieldReadImpl]crew.setSize([CtInvocationImpl][CtTypeAccessImpl]megamek.common.Compute.getFullCrewSize([CtThisAccessImpl]this));
        [CtInvocationImpl][CtFieldReadImpl]crew.setCurrentSize([CtInvocationImpl][CtFieldReadImpl]crew.getSize());
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isOmni() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]omni;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setOmni([CtParameterImpl][CtTypeReferenceImpl]boolean omni) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.omni = [CtVariableReadImpl]omni;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the number of locations in the entity
     */
    public abstract [CtTypeReferenceImpl]int locations();

    [CtMethodImpl][CtJavaDocImpl]/**
     * Determines where to place equipment that does not require a specific location. What
     * this means varies by {@link Entity} type.
     *
     * @return The location to place equipment that is not required to be assigned a location,
    defaulting to Entity.LOC_NONE for unit types that do not have such a location.
     */
    public [CtTypeReferenceImpl]int getBodyLocation() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]megamek.common.Entity.LOC_NONE;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the player that "owns" this entity.
     */
    public [CtTypeReferenceImpl]megamek.common.IPlayer getOwner() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]owner;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setOwner([CtParameterImpl][CtTypeReferenceImpl]megamek.common.IPlayer player) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]owner = [CtVariableReadImpl]player;
        [CtAssignmentImpl][CtFieldWriteImpl]ownerId = [CtInvocationImpl][CtVariableReadImpl]player.getId();
        [CtInvocationImpl]generateDisplayName();
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getOwnerId() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]ownerId;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns true if the other entity is an enemy of this entity. This is more
     * reliable than Player.isEnemyOf since it knows that an entity will never
     * be an enemy of itself.
     */
    public [CtTypeReferenceImpl]boolean isEnemyOf([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Entity other) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtLiteralImpl]null == [CtVariableReadImpl]other) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtLiteralImpl]null == [CtFieldReadImpl]owner) [CtBlockImpl]{
            [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtFieldReadImpl]id != [CtInvocationImpl][CtVariableReadImpl]other.getId()) && [CtBinaryOperatorImpl]([CtFieldReadImpl]ownerId != [CtFieldReadImpl][CtVariableReadImpl]other.ownerId);
        }
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtFieldReadImpl]id != [CtInvocationImpl][CtVariableReadImpl]other.getId()) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtLiteralImpl]null == [CtInvocationImpl][CtVariableReadImpl]other.getOwner()) || [CtInvocationImpl][CtFieldReadImpl]owner.isEnemyOf([CtInvocationImpl][CtVariableReadImpl]other.getOwner()));
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]megamek.common.Crew getCrew() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]crew;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setCrew([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Crew crew) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.crew = [CtVariableReadImpl]crew;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @return The total number of crew available to supplement marines on boarding actions.
    Includes officers, enlisted, and bay personnel, but not marines/ba or passengers.
     */
    public [CtTypeReferenceImpl]int getNCrew() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]nCrew;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setNCrew([CtParameterImpl][CtTypeReferenceImpl]int crew) [CtBlockImpl]{
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the number of passengers on this unit
     * Intended for spacecraft, where we want to get the crews of transported units
     * plus actual passengers assigned to quarters
     *
     * @return  */
    public [CtTypeReferenceImpl]int getNPassenger() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]nPassenger;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setNPassenger([CtParameterImpl][CtTypeReferenceImpl]int pass) [CtBlockImpl]{
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @return The number conventional marines available to vessels for boarding actions.
     */
    public [CtTypeReferenceImpl]int getNMarines() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]nMarines;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Updates the number of marines aboard
     *
     * @param marines
     * 		The number of marines to add/subtract
     */
    public [CtTypeReferenceImpl]void setNMarines([CtParameterImpl][CtTypeReferenceImpl]int marines) [CtBlockImpl]{
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Units with a cockpit command console provide an initiative bonus to their side, provided
     * that the commander is not currently functioning as pilot, the unit has advanced fire control,
     * and the unit is heavy or assault weight class.
     *
     * @return Whether the Entity qualifies for initiative bonus from cockpit command console.
     */
    public [CtTypeReferenceImpl]boolean hasCommandConsoleBonus() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isShutDown() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]shutDown;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setShutDown([CtParameterImpl][CtTypeReferenceImpl]boolean shutDown) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.shutDown = [CtVariableReadImpl]shutDown;
        [CtInvocationImpl]setShutDownThisPhase([CtVariableReadImpl]shutDown);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setShutDownThisPhase([CtParameterImpl][CtTypeReferenceImpl]boolean shutDown) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]shutDownThisPhase = [CtVariableReadImpl]shutDown;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isShutDownThisPhase() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]shutDownThisPhase;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setStartupThisPhase([CtParameterImpl][CtTypeReferenceImpl]boolean shutDown) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]startupThisPhase = [CtVariableReadImpl]shutDown;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isStartupThisPhase() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]startupThisPhase;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isDoomed() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]doomed;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setDoomed([CtParameterImpl][CtTypeReferenceImpl]boolean doomed) [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// Doomed entities aren't in retreat.
        if ([CtVariableReadImpl]doomed) [CtBlockImpl]{
            [CtInvocationImpl]setRemovalCondition([CtTypeAccessImpl]IEntityRemovalConditions.REMOVE_SALVAGEABLE);
        }
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.doomed = [CtVariableReadImpl]doomed;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isDestroyed() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]destroyed;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setDestroyed([CtParameterImpl][CtTypeReferenceImpl]boolean destroyed) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.destroyed = [CtVariableReadImpl]destroyed;
    }

    [CtMethodImpl][CtCommentImpl]// Targetable interface
    [CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]int getTargetType() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]Targetable.TYPE_ENTITY;
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]int getTargetId() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getId();
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]int getHeight() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]height();
    }

    [CtMethodImpl][CtCommentImpl]// End Targetable interface
    public [CtTypeReferenceImpl]boolean isDone() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]done;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setDone([CtParameterImpl][CtTypeReferenceImpl]boolean done) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.done = [CtVariableReadImpl]done;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * This method should <strong>only</stong> be called when needed to remove a
     * dead swarmer's game turn.
     */
    public [CtTypeReferenceImpl]void setUnloaded([CtParameterImpl][CtTypeReferenceImpl]boolean unloaded) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]unloadedThisTurn = [CtVariableReadImpl]unloaded;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setLoadedThisTurn([CtParameterImpl][CtTypeReferenceImpl]boolean loaded) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]loadedThisTurn = [CtVariableReadImpl]loaded;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Determine if this entity participate in the current game phase.
     *
     * @return <code>true</code> if this entity is not shut down, is not
    destroyed, has an active crew, and was not unloaded from a
    transport this turn. <code>false</code> otherwise.
     */
    public [CtTypeReferenceImpl]boolean isActive() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtThisAccessImpl]this.isActive([CtUnaryOperatorImpl]-[CtLiteralImpl]1);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isActive([CtParameterImpl][CtTypeReferenceImpl]int turn) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]boolean isActive = [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtUnaryOperatorImpl](![CtFieldReadImpl]shutDown) && [CtUnaryOperatorImpl](![CtInvocationImpl]isManualShutdown())) && [CtUnaryOperatorImpl](![CtFieldReadImpl]destroyed)) && [CtInvocationImpl][CtInvocationImpl]getCrew().isActive()) && [CtUnaryOperatorImpl](![CtFieldReadImpl]unloadedThisTurn);
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]turn > [CtUnaryOperatorImpl](-[CtLiteralImpl]1)) && [CtVariableReadImpl]isActive) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]isActive = [CtBinaryOperatorImpl][CtUnaryOperatorImpl](![CtFieldReadImpl]deployed) && [CtInvocationImpl]shouldDeploy([CtVariableReadImpl]turn);
        } else [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]isActive = [CtBinaryOperatorImpl][CtVariableReadImpl]isActive && [CtFieldReadImpl]deployed;
        }
        [CtReturnImpl]return [CtVariableReadImpl]isActive;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns true if this entity is selectable for action. Transported
     * entities can not be selected.
     */
    public [CtTypeReferenceImpl]boolean isSelectableThisTurn() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtUnaryOperatorImpl](![CtFieldReadImpl]done) && [CtBinaryOperatorImpl]([CtFieldReadImpl]conveyance == [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE)) && [CtUnaryOperatorImpl](![CtFieldReadImpl]unloadedThisTurn)) && [CtUnaryOperatorImpl](![CtInvocationImpl]isClearingMinefield())) && [CtUnaryOperatorImpl](![CtInvocationImpl]isCarcass());
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns true if this entity could potentially be loaded (did not move
     * from starting hex)
     */
    public [CtTypeReferenceImpl]boolean isLoadableThisTurn() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtFieldReadImpl]delta_distance == [CtLiteralImpl]0) && [CtBinaryOperatorImpl]([CtFieldReadImpl]conveyance == [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE)) && [CtUnaryOperatorImpl](![CtFieldReadImpl]unloadedThisTurn)) && [CtUnaryOperatorImpl](![CtInvocationImpl]isClearingMinefield())) && [CtBinaryOperatorImpl]([CtInvocationImpl]getTractor() == [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Determine if this <code>Entity</code> was unloaded previously this turn.
     *
     * @return <code>true</code> if this entity was unloaded for any reason
    during this turn.
     */
    public [CtTypeReferenceImpl]boolean isUnloadedThisTurn() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]unloadedThisTurn;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean wasLoadedThisTurn() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]loadedThisTurn;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns true if this entity is targetable for attacks.  A unit is
     * targetable if it is not destroyed, not doomed, deployed, not off board,
     * not being transported, and not captured.
     */
    public [CtTypeReferenceImpl]boolean isTargetable() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtUnaryOperatorImpl](![CtFieldReadImpl]destroyed) && [CtUnaryOperatorImpl](![CtFieldReadImpl]doomed)) && [CtFieldReadImpl]deployed) && [CtUnaryOperatorImpl](![CtInvocationImpl]isOffBoard())) && [CtBinaryOperatorImpl]([CtFieldReadImpl]conveyance == [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE)) && [CtUnaryOperatorImpl](![CtFieldReadImpl]captured)) && [CtBinaryOperatorImpl]([CtInvocationImpl]getPosition() != [CtLiteralImpl]null);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isProne() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]prone;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setProne([CtParameterImpl][CtTypeReferenceImpl]boolean prone) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.prone = [CtVariableReadImpl]prone;
        [CtIfImpl]if ([CtVariableReadImpl]prone) [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl]hullDown = [CtLiteralImpl]false;
        }
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isHullDown() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]hullDown;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setHullDown([CtParameterImpl][CtTypeReferenceImpl]boolean down) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]hullDown = [CtVariableReadImpl]down;
        [CtIfImpl]if ([CtFieldReadImpl]hullDown) [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl]prone = [CtLiteralImpl]false;
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Is this entity shut down or is the crew unconscious?
     */
    [CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]boolean isImmobile() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtInvocationImpl]isShutDown() || [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtFieldReadImpl]crew != [CtLiteralImpl]null) && [CtInvocationImpl][CtFieldReadImpl]crew.isUnconscious());
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * This method returns true if a unit is permanently immobilized either
     * because its crew is dead/gone or because of damage
     *
     * @return true if unit is permanently immobile
     */
    public [CtTypeReferenceImpl]boolean isPermanentlyImmobilized([CtParameterImpl][CtTypeReferenceImpl]boolean checkCrew) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]checkCrew && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]getCrew() == [CtLiteralImpl]null) || [CtInvocationImpl][CtInvocationImpl]getCrew().isDead())) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]true;
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]getOriginalWalkMP() > [CtLiteralImpl]0) || [CtBinaryOperatorImpl]([CtInvocationImpl]getOriginalRunMP() > [CtLiteralImpl]0)) || [CtBinaryOperatorImpl]([CtInvocationImpl]getOriginalJumpMP() > [CtLiteralImpl]0)) && [CtBinaryOperatorImpl][CtCommentImpl]/* Need to make sure here that we're ignoring heat because
        that's not actually "permanent":
         */
        ([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]getWalkMP([CtLiteralImpl]true, [CtLiteralImpl]true, [CtLiteralImpl]false) == [CtLiteralImpl]0) && [CtBinaryOperatorImpl]([CtInvocationImpl]getRunMP([CtLiteralImpl]true, [CtLiteralImpl]true, [CtLiteralImpl]false) == [CtLiteralImpl]0)) && [CtBinaryOperatorImpl]([CtInvocationImpl]getJumpMP() == [CtLiteralImpl]0))) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]true;
        } else [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isCharging() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtFieldReadImpl]displacementAttack instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.actions.ChargeAttackAction;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isPushing() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtFieldReadImpl]displacementAttack instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.actions.PushAttackAction;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isMakingDfa() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtFieldReadImpl]displacementAttack instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.actions.DfaAttackAction;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean hasDisplacementAttack() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtFieldReadImpl]displacementAttack != [CtLiteralImpl]null;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]megamek.common.actions.DisplacementAttackAction getDisplacementAttack() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]displacementAttack;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setDisplacementAttack([CtParameterImpl][CtTypeReferenceImpl]megamek.common.actions.DisplacementAttackAction displacementAttack) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.displacementAttack = [CtVariableReadImpl]displacementAttack;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns true if any other entities this entity knows of are making a
     * displacement attack on this entity.
     */
    public [CtTypeReferenceImpl]boolean isTargetOfDisplacementAttack() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtInvocationImpl]findTargetedDisplacement() != [CtLiteralImpl]null;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns any known displacement attacks (should only be one) that this
     * entity is a target of.
     */
    public [CtTypeReferenceImpl]megamek.common.actions.DisplacementAttackAction findTargetedDisplacement() [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity other : [CtInvocationImpl][CtFieldReadImpl]game.getEntitiesVector()) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]other.hasDisplacementAttack() && [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]other.getDisplacementAttack().getTargetId() == [CtFieldReadImpl]id)) [CtBlockImpl]{
                [CtReturnImpl]return [CtInvocationImpl][CtVariableReadImpl]other.getDisplacementAttack();
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]null;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isUnjammingRAC() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]unjammingRAC;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setUnjammingRAC([CtParameterImpl][CtTypeReferenceImpl]boolean u) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]unjammingRAC = [CtVariableReadImpl]u;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isFindingClub() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]findingClub;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setFindingClub([CtParameterImpl][CtTypeReferenceImpl]boolean findingClub) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.findingClub = [CtVariableReadImpl]findingClub;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Set whether or not the mech's arms are flipped to the rear
     */
    public [CtTypeReferenceImpl]void setArmsFlipped([CtParameterImpl][CtTypeReferenceImpl]boolean armsFlipped) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.armsFlipped = [CtVariableReadImpl]armsFlipped;
        [CtInvocationImpl][CtFieldReadImpl]game.processGameEvent([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.event.GameEntityChangeEvent([CtThisAccessImpl]this, [CtThisAccessImpl]this));
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns true if the mech's arms are flipped to the rear
     */
    public [CtTypeReferenceImpl]boolean getArmsFlipped() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]armsFlipped;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @return true if the VTOL or LAM is making a VTOL strafe or VTOL/AirMech bomb attack
     */
    public [CtTypeReferenceImpl]boolean isMakingVTOLGroundAttack() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the current position of this entity on the board. This is not
     * named getLocation(), since I want the word location to refer to hit
     * locations on a mech or vehicle.
     */
    [CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]megamek.common.Coords getPosition() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]position;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns a set of the coords this Entity occupies
     *
     * @return  */
    public [CtTypeReferenceImpl]java.util.HashSet<[CtTypeReferenceImpl]megamek.common.Coords> getOccupiedCoords() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.HashSet<[CtTypeReferenceImpl]megamek.common.Coords> positions = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.HashSet<[CtTypeReferenceImpl]megamek.common.Coords>();
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl]getSecondaryPositions() != [CtLiteralImpl]null) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl]getSecondaryPositions().size() != [CtLiteralImpl]0)) [CtBlockImpl]{
            [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int key : [CtInvocationImpl][CtInvocationImpl]getSecondaryPositions().keySet()) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]positions.add([CtInvocationImpl][CtInvocationImpl]getSecondaryPositions().get([CtVariableReadImpl]key));
            }
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]getPosition() != [CtLiteralImpl]null) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]positions.add([CtInvocationImpl]getPosition());
        }
        [CtReturnImpl]return [CtVariableReadImpl]positions;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setPosition([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords position) [CtBlockImpl]{
        [CtInvocationImpl]setPosition([CtVariableReadImpl]position, [CtLiteralImpl]true);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Sets the current position of this entity on the board.
     *
     * @param position
     * 		the new position.
     */
    public [CtTypeReferenceImpl]void setPosition([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords position, [CtParameterImpl][CtTypeReferenceImpl]boolean gameUpdate) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.HashSet<[CtTypeReferenceImpl]megamek.common.Coords> oldPositions = [CtLiteralImpl]null;
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtFieldReadImpl]game != [CtLiteralImpl]null) && [CtVariableReadImpl]gameUpdate) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]oldPositions = [CtInvocationImpl]getOccupiedCoords();
        }
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.position = [CtVariableReadImpl]position;
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtFieldReadImpl]game != [CtLiteralImpl]null) && [CtVariableReadImpl]gameUpdate) [CtBlockImpl]{
            [CtInvocationImpl][CtFieldReadImpl]game.updateEntityPositionLookup([CtThisAccessImpl]this, [CtVariableReadImpl]oldPositions);
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @return the coords of the second to last position on the passed through
    vector or the current position if too small
     */
    public [CtTypeReferenceImpl]megamek.common.Coords getPriorPosition() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtFieldReadImpl]passedThrough.size() < [CtLiteralImpl]2) [CtBlockImpl]{
            [CtReturnImpl]return [CtInvocationImpl]getPosition();
        }
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]passedThrough.elementAt([CtBinaryOperatorImpl][CtInvocationImpl][CtFieldReadImpl]passedThrough.size() - [CtLiteralImpl]2);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Sets the current elevation of this entity above the ground.  This is the
     * number of levels the unit is above the level of the hex.
     *
     * @param elevation
     * 		an <code>int</code> representing the new elevation.
     */
    public [CtTypeReferenceImpl]void setElevation([CtParameterImpl][CtTypeReferenceImpl]int elevation) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.elevation = [CtVariableReadImpl]elevation;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * A helper function for fiddling with elevation. Takes the current hex, a
     * hex being moved to, returns the elevation the Entity will be considered
     * to be at w/r/t it's new hex.
     */
    public [CtTypeReferenceImpl]int calcElevation([CtParameterImpl][CtTypeReferenceImpl]megamek.common.IHex current, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.IHex next, [CtParameterImpl][CtTypeReferenceImpl]int assumedElevation, [CtParameterImpl][CtTypeReferenceImpl]boolean climb, [CtParameterImpl][CtTypeReferenceImpl]boolean wigeEndClimbPrevious) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int retVal = [CtVariableReadImpl]assumedElevation;
        [CtIfImpl]if ([CtInvocationImpl]isAero()) [CtBlockImpl]{
            [CtReturnImpl]return [CtVariableReadImpl]retVal;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]getMovementMode() == [CtFieldReadImpl]EntityMovementMode.WIGE) [CtBlockImpl]{
            [CtLocalVariableImpl][CtCommentImpl]// Airborne WiGEs remain 1 elevation above underlying terrain, unless climb mode is
            [CtCommentImpl]// on, then they maintain current absolute elevation  as long as it is at least
            [CtCommentImpl]// one level above the ground.
            [CtCommentImpl]// WiGEs treat the tops of buildings as the underlying terrain, but must pay an additional
            [CtCommentImpl]// 2 MP to climb.
            [CtCommentImpl]// See http://bg.battletech.com/forums/index.php?topic=51081.msg1297747#msg1297747
            [CtCommentImpl]// Find level equivalent of current elevation
            [CtTypeReferenceImpl]int level = [CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]current.surface() + [CtVariableReadImpl]assumedElevation;
            [CtLocalVariableImpl][CtCommentImpl]// For WiGE purposes, the surface of a hex with a building is the roof; otherwise it's the surface of the hex.
            [CtTypeReferenceImpl]int curSurface = [CtInvocationImpl][CtVariableReadImpl]current.surface();
            [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]current.containsTerrain([CtTypeAccessImpl]Terrains.BLDG_ELEV)) [CtBlockImpl]{
                [CtOperatorAssignmentImpl][CtVariableWriteImpl]curSurface += [CtInvocationImpl][CtVariableReadImpl]current.terrainLevel([CtTypeAccessImpl]Terrains.BLDG_ELEV);
            }
            [CtLocalVariableImpl][CtTypeReferenceImpl]int nextSurface = [CtInvocationImpl][CtVariableReadImpl]next.surface();
            [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]next.containsTerrain([CtTypeAccessImpl]Terrains.BLDG_ELEV)) [CtBlockImpl]{
                [CtOperatorAssignmentImpl][CtVariableWriteImpl]nextSurface += [CtInvocationImpl][CtVariableReadImpl]next.terrainLevel([CtTypeAccessImpl]Terrains.BLDG_ELEV);
            }
            [CtLocalVariableImpl][CtTypeReferenceImpl]int nextLevel;
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]level - [CtVariableReadImpl]curSurface) <= [CtLiteralImpl]0) [CtBlockImpl]{
                [CtAssignmentImpl][CtCommentImpl]// If we are not above the effective surface, we are not airborne and the next level
                [CtCommentImpl]// is the effective surface of the next hex.
                [CtVariableWriteImpl]nextLevel = [CtVariableReadImpl]nextSurface;
            } else [CtIfImpl]if ([CtVariableReadImpl]climb) [CtBlockImpl]{
                [CtAssignmentImpl][CtCommentImpl]// If climb mode is on, we maintain the same level unless the next surface requires climbing.
                [CtCommentImpl]// is the effective surface of the next hex.
                [CtVariableWriteImpl]nextLevel = [CtInvocationImpl][CtTypeAccessImpl]java.lang.Math.max([CtVariableReadImpl]level, [CtBinaryOperatorImpl][CtVariableReadImpl]nextSurface + [CtLiteralImpl]1);
            } else [CtBlockImpl]{
                [CtAssignmentImpl][CtCommentImpl]// Otherwise we move to one elevation level above the effective surface.
                [CtVariableWriteImpl]nextLevel = [CtBinaryOperatorImpl][CtVariableReadImpl]nextSurface + [CtLiteralImpl]1;
            }
            [CtAssignmentImpl][CtCommentImpl]// Elevation is this height of the level above the actual surface elevation of the hex.
            [CtVariableWriteImpl]retVal = [CtBinaryOperatorImpl][CtVariableReadImpl]nextLevel - [CtInvocationImpl][CtVariableReadImpl]next.surface();
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() == [CtFieldReadImpl]EntityMovementMode.SUBMARINE) || [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() == [CtFieldReadImpl]EntityMovementMode.INF_UMU) && [CtInvocationImpl][CtVariableReadImpl]next.containsTerrain([CtTypeAccessImpl]Terrains.WATER)) && [CtInvocationImpl][CtVariableReadImpl]current.containsTerrain([CtTypeAccessImpl]Terrains.WATER))) || [CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() == [CtFieldReadImpl]EntityMovementMode.VTOL)) || [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() == [CtFieldReadImpl]EntityMovementMode.QUAD_SWIM) && [CtInvocationImpl]hasUMU())) || [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() == [CtFieldReadImpl]EntityMovementMode.BIPED_SWIM) && [CtInvocationImpl]hasUMU())) [CtBlockImpl]{
            [CtOperatorAssignmentImpl][CtVariableWriteImpl]retVal += [CtInvocationImpl][CtVariableReadImpl]current.surface();
            [CtOperatorAssignmentImpl][CtVariableWriteImpl]retVal -= [CtInvocationImpl][CtVariableReadImpl]next.surface();
        } else [CtBlockImpl]{
            [CtIfImpl][CtCommentImpl]// if we're a hovercraft, surface ship, WIGE or a "fully amphibious" vehicle, we go on the water surface
            [CtCommentImpl]// without adjusting elevation
            if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() != [CtFieldReadImpl]EntityMovementMode.HOVER) && [CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() != [CtFieldReadImpl]EntityMovementMode.NAVAL)) && [CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() != [CtFieldReadImpl]EntityMovementMode.HYDROFOIL)) && [CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() != [CtFieldReadImpl]EntityMovementMode.WIGE)) && [CtUnaryOperatorImpl](![CtInvocationImpl]hasWorkingMisc([CtTypeAccessImpl]MiscType.F_FULLY_AMPHIBIOUS))) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]int prevWaterLevel = [CtLiteralImpl]0;
                [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]current.containsTerrain([CtTypeAccessImpl]Terrains.WATER)) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]prevWaterLevel = [CtInvocationImpl][CtVariableReadImpl]current.terrainLevel([CtTypeAccessImpl]Terrains.WATER);
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]current.containsTerrain([CtTypeAccessImpl]Terrains.ICE)) || [CtBinaryOperatorImpl]([CtVariableReadImpl]assumedElevation < [CtLiteralImpl]0)) [CtBlockImpl]{
                        [CtOperatorAssignmentImpl][CtCommentImpl]// count water, only if the entity isn't on ice surface
                        [CtVariableWriteImpl]retVal += [CtInvocationImpl][CtVariableReadImpl]current.terrainLevel([CtTypeAccessImpl]Terrains.WATER);
                    }
                }
                [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]next.containsTerrain([CtTypeAccessImpl]Terrains.WATER)) [CtBlockImpl]{
                    [CtLocalVariableImpl][CtTypeReferenceImpl]int waterLevel = [CtInvocationImpl][CtVariableReadImpl]next.terrainLevel([CtTypeAccessImpl]Terrains.WATER);
                    [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]next.containsTerrain([CtTypeAccessImpl]Terrains.ICE)) [CtBlockImpl]{
                        [CtIfImpl][CtCommentImpl]// a mech can only climb out onto ice in depth 2 or
                        [CtCommentImpl]// shallower water
                        [CtCommentImpl]// mech on the surface will stay on the surface
                        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]waterLevel == [CtLiteralImpl]1) && [CtBinaryOperatorImpl]([CtVariableReadImpl]prevWaterLevel == [CtLiteralImpl]1)) || [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]prevWaterLevel <= [CtLiteralImpl]2) && [CtVariableReadImpl]climb)) || [CtBinaryOperatorImpl]([CtVariableReadImpl]assumedElevation >= [CtLiteralImpl]0)) [CtBlockImpl]{
                            [CtOperatorAssignmentImpl][CtVariableWriteImpl]retVal += [CtVariableReadImpl]waterLevel;
                        }
                    }
                    [CtOperatorAssignmentImpl][CtVariableWriteImpl]retVal -= [CtVariableReadImpl]waterLevel;
                }
            }
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]next.containsTerrain([CtTypeAccessImpl]Terrains.BUILDING) || [CtInvocationImpl][CtVariableReadImpl]current.containsTerrain([CtTypeAccessImpl]Terrains.BUILDING)) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]int bldcur = [CtInvocationImpl][CtTypeAccessImpl]java.lang.Math.max([CtUnaryOperatorImpl]-[CtInvocationImpl][CtVariableReadImpl]current.depth([CtLiteralImpl]true), [CtInvocationImpl][CtVariableReadImpl]current.terrainLevel([CtTypeAccessImpl]Terrains.BLDG_ELEV));
                [CtLocalVariableImpl][CtTypeReferenceImpl]int bldnex = [CtInvocationImpl][CtTypeAccessImpl]java.lang.Math.max([CtUnaryOperatorImpl]-[CtInvocationImpl][CtVariableReadImpl]next.depth([CtLiteralImpl]true), [CtInvocationImpl][CtVariableReadImpl]next.terrainLevel([CtTypeAccessImpl]Terrains.BLDG_ELEV));
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]assumedElevation == [CtVariableReadImpl]bldcur) && [CtBinaryOperatorImpl]([CtVariableReadImpl]climb || [CtFieldReadImpl]isJumpingNow)) && [CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Mech)) || [CtBinaryOperatorImpl]([CtVariableReadImpl]retVal > [CtVariableReadImpl]bldnex)) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]retVal = [CtVariableReadImpl]bldnex;
                } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]bldnex + [CtInvocationImpl][CtVariableReadImpl]next.surface()) > [CtBinaryOperatorImpl]([CtVariableReadImpl]bldcur + [CtInvocationImpl][CtVariableReadImpl]current.surface())) [CtBlockImpl]{
                    [CtLocalVariableImpl][CtTypeReferenceImpl]int nextBasement = [CtInvocationImpl][CtVariableReadImpl]next.terrainLevel([CtTypeAccessImpl]Terrains.BLDG_BASEMENT_TYPE);
                    [CtLocalVariableImpl][CtTypeReferenceImpl]int collapsedBasement = [CtInvocationImpl][CtVariableReadImpl]next.terrainLevel([CtTypeAccessImpl]Terrains.BLDG_BASE_COLLAPSED);
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]climb || [CtFieldReadImpl]isJumpingNow) [CtBlockImpl]{
                        [CtAssignmentImpl][CtVariableWriteImpl]retVal = [CtBinaryOperatorImpl][CtVariableReadImpl]bldnex + [CtInvocationImpl][CtVariableReadImpl]next.surface();
                        [CtCommentImpl]// If the basement is collapsed, there is no level 0
                    } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]assumedElevation == [CtLiteralImpl]0) && [CtBinaryOperatorImpl]([CtVariableReadImpl]nextBasement > [CtInvocationImpl][CtTypeAccessImpl]BasementType.NONE.getValue())) && [CtBinaryOperatorImpl]([CtVariableReadImpl]collapsedBasement > [CtLiteralImpl]0)) [CtBlockImpl]{
                        [CtOperatorAssignmentImpl][CtVariableWriteImpl]retVal -= [CtInvocationImpl][CtInvocationImpl][CtTypeAccessImpl]megamek.common.Building.BasementType.getType([CtInvocationImpl][CtVariableReadImpl]next.terrainLevel([CtTypeAccessImpl]Terrains.BLDG_BASEMENT_TYPE)).getDepth();
                    } else [CtBlockImpl]{
                        [CtOperatorAssignmentImpl][CtVariableWriteImpl]retVal += [CtInvocationImpl][CtVariableReadImpl]current.surface();
                        [CtOperatorAssignmentImpl][CtVariableWriteImpl]retVal -= [CtInvocationImpl][CtVariableReadImpl]next.surface();
                    }
                } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]elevation == [CtUnaryOperatorImpl](-[CtInvocationImpl][CtVariableReadImpl]current.depth([CtLiteralImpl]true))) [CtBlockImpl]{
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]climb || [CtFieldReadImpl]isJumpingNow) [CtBlockImpl]{
                        [CtAssignmentImpl][CtVariableWriteImpl]retVal = [CtBinaryOperatorImpl][CtVariableReadImpl]bldnex + [CtInvocationImpl][CtVariableReadImpl]next.surface();
                    } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]current.terrainLevel([CtTypeAccessImpl]Terrains.BLDG_BASEMENT_TYPE) > [CtInvocationImpl][CtTypeAccessImpl]BasementType.NONE.getValue()) && [CtBinaryOperatorImpl]([CtVariableReadImpl]assumedElevation == [CtUnaryOperatorImpl](-[CtInvocationImpl][CtInvocationImpl][CtTypeAccessImpl]megamek.common.Building.BasementType.getType([CtInvocationImpl][CtVariableReadImpl]current.terrainLevel([CtTypeAccessImpl]Terrains.BLDG_BASEMENT_TYPE)).getDepth()))) [CtBlockImpl]{
                        [CtAssignmentImpl][CtVariableWriteImpl]retVal = [CtUnaryOperatorImpl]-[CtInvocationImpl][CtInvocationImpl][CtTypeAccessImpl]megamek.common.Building.BasementType.getType([CtInvocationImpl][CtVariableReadImpl]next.terrainLevel([CtTypeAccessImpl]Terrains.BLDG_BASEMENT_TYPE)).getDepth();
                    } else [CtBlockImpl]{
                        [CtOperatorAssignmentImpl][CtVariableWriteImpl]retVal += [CtInvocationImpl][CtVariableReadImpl]current.surface();
                        [CtOperatorAssignmentImpl][CtVariableWriteImpl]retVal -= [CtInvocationImpl][CtVariableReadImpl]next.surface();
                    }
                }
            }
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() != [CtFieldReadImpl]EntityMovementMode.NAVAL) && [CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() != [CtFieldReadImpl]EntityMovementMode.HYDROFOIL)) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]next.containsTerrain([CtTypeAccessImpl]Terrains.BRIDGE) || [CtInvocationImpl][CtVariableReadImpl]current.containsTerrain([CtTypeAccessImpl]Terrains.BRIDGE))) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]int bridgeElev;
                [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]next.containsTerrain([CtTypeAccessImpl]Terrains.BRIDGE)) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]bridgeElev = [CtInvocationImpl][CtVariableReadImpl]next.terrainLevel([CtTypeAccessImpl]Terrains.BRIDGE_ELEV);
                } else [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]bridgeElev = [CtLiteralImpl]0;
                }
                [CtLocalVariableImpl][CtTypeReferenceImpl]int elevDiff = [CtInvocationImpl][CtTypeAccessImpl]java.lang.Math.abs([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]next.surface() + [CtVariableReadImpl]bridgeElev) - [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]current.surface() + [CtVariableReadImpl]assumedElevation));
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]elevDiff <= [CtInvocationImpl]getMaxElevationChange()) [CtBlockImpl]{
                    [CtIfImpl][CtCommentImpl]// bridge is reachable at least
                    if ([CtBinaryOperatorImpl][CtVariableReadImpl]climb || [CtUnaryOperatorImpl](![CtInvocationImpl]isElevationValid([CtVariableReadImpl]retVal, [CtVariableReadImpl]next))) [CtBlockImpl]{
                        [CtAssignmentImpl][CtCommentImpl]// use bridge if you can't use the base terrain or if
                        [CtCommentImpl]// you prefer to by climb mode
                        [CtVariableWriteImpl]retVal = [CtVariableReadImpl]bridgeElev;
                    }
                }
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]retVal;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int calcElevation([CtParameterImpl][CtTypeReferenceImpl]megamek.common.IHex current, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.IHex next) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]calcElevation([CtVariableReadImpl]current, [CtVariableReadImpl]next, [CtFieldReadImpl]elevation, [CtLiteralImpl]false, [CtLiteralImpl]false);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the elevation of this entity, relative to the current Hex's
     * surface
     */
    [CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]int getElevation() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE != [CtInvocationImpl]getTransportId()) [CtBlockImpl]{
            [CtReturnImpl]return [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getEntity([CtInvocationImpl]getTransportId()).getElevation();
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtLiteralImpl]null == [CtInvocationImpl]getPosition()) && [CtInvocationImpl]isDeployed()) [CtBlockImpl]{
            [CtThrowImpl]throw [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.lang.IllegalStateException([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtLiteralImpl]"Entity #" + [CtInvocationImpl]getId()) + [CtLiteralImpl]" does not know its position.");
        }
        [CtIfImpl]if ([CtInvocationImpl]isOffBoard()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]0;
        }
        [CtReturnImpl]return [CtFieldReadImpl]elevation;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean canGoDown() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]canGoDown([CtFieldReadImpl]elevation, [CtInvocationImpl]getPosition());
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * is it possible to go down, or are we landed/just above the
     * water/treeline? assuming passed elevation.
     */
    public [CtTypeReferenceImpl]boolean canGoDown([CtParameterImpl][CtTypeReferenceImpl]int assumedElevation, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords assumedPos) [CtBlockImpl]{
        [CtIfImpl]if ([CtUnaryOperatorImpl]![CtInvocationImpl][CtInvocationImpl][CtInvocationImpl]getGame().getBoard().contains([CtVariableReadImpl]assumedPos)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]boolean inWaterOrWoods = [CtLiteralImpl]false;
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.IHex hex = [CtInvocationImpl][CtInvocationImpl][CtInvocationImpl]getGame().getBoard().getHex([CtVariableReadImpl]assumedPos);
        [CtLocalVariableImpl][CtTypeReferenceImpl]int assumedAlt = [CtBinaryOperatorImpl][CtVariableReadImpl]assumedElevation + [CtInvocationImpl][CtVariableReadImpl]hex.surface();
        [CtLocalVariableImpl][CtTypeReferenceImpl]int minAlt = [CtInvocationImpl][CtVariableReadImpl]hex.surface();
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]hex.containsTerrain([CtTypeAccessImpl]Terrains.WOODS) || [CtInvocationImpl][CtVariableReadImpl]hex.containsTerrain([CtTypeAccessImpl]Terrains.WATER)) || [CtInvocationImpl][CtVariableReadImpl]hex.containsTerrain([CtTypeAccessImpl]Terrains.JUNGLE)) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]inWaterOrWoods = [CtLiteralImpl]true;
        }
        [CtSwitchImpl]switch ([CtInvocationImpl]getMovementMode()) {
            [CtCaseImpl]case [CtFieldReadImpl]INF_JUMP :
            [CtCaseImpl]case [CtFieldReadImpl]INF_LEG :
            [CtCaseImpl]case [CtFieldReadImpl]INF_MOTORIZED :
                [CtOperatorAssignmentImpl][CtVariableWriteImpl]minAlt -= [CtInvocationImpl][CtTypeAccessImpl]java.lang.Math.max([CtLiteralImpl]0, [CtInvocationImpl][CtInvocationImpl][CtTypeAccessImpl]megamek.common.Building.BasementType.getType([CtInvocationImpl][CtVariableReadImpl]hex.terrainLevel([CtTypeAccessImpl]Terrains.BLDG_BASEMENT_TYPE)).getDepth());
                [CtBreakImpl]break;
            [CtCaseImpl]case [CtFieldReadImpl]WIGE :
                [CtIfImpl][CtCommentImpl]// Per errata, WiGEs have flotation hull, which makes no sense unless it changes the rule
                [CtCommentImpl]// in TW that they cannot land on water.
                [CtCommentImpl]// See
                if ([CtInvocationImpl]isAirborne()) [CtBlockImpl]{
                    [CtReturnImpl]return [CtLiteralImpl]false;
                }
                [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]hex.containsTerrain([CtTypeAccessImpl]Terrains.WATER)) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]minAlt = [CtInvocationImpl][CtVariableReadImpl]hex.surface();
                    [CtBreakImpl]break;
                }
                [CtCommentImpl]// else fall through
            [CtCaseImpl]case [CtFieldReadImpl]VTOL :
                [CtAssignmentImpl][CtVariableWriteImpl]minAlt = [CtInvocationImpl][CtVariableReadImpl]hex.ceiling();
                [CtIfImpl]if ([CtVariableReadImpl]inWaterOrWoods) [CtBlockImpl]{
                    [CtUnaryOperatorImpl][CtVariableWriteImpl]minAlt++;[CtCommentImpl]// can't land here

                }
                [CtBreakImpl]break;
            [CtCaseImpl]case [CtFieldReadImpl]AERODYNE :
            [CtCaseImpl]case [CtFieldReadImpl]SPHEROID :
                [CtAssignmentImpl][CtVariableWriteImpl]assumedAlt = [CtVariableReadImpl]assumedElevation;
                [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().inAtmosphere()) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]minAlt = [CtBinaryOperatorImpl][CtInvocationImpl][CtTypeAccessImpl]java.lang.Math.max([CtLiteralImpl]0, [CtInvocationImpl][CtVariableReadImpl]hex.ceiling([CtLiteralImpl]true)) + [CtLiteralImpl]1;
                } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().onGround() && [CtInvocationImpl]isAirborne()) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]minAlt = [CtLiteralImpl]1;
                }
                [CtIfImpl][CtCommentImpl]// if sensors are damaged then, one higher
                if ([CtBinaryOperatorImpl][CtInvocationImpl]isAero() && [CtBinaryOperatorImpl]([CtInvocationImpl][CtThisAccessImpl](([CtTypeReferenceImpl]megamek.common.IAero) (this)).getSensorHits() > [CtLiteralImpl]0)) [CtBlockImpl]{
                    [CtUnaryOperatorImpl][CtVariableWriteImpl]minAlt++;
                }
                [CtBreakImpl]break;
            [CtCaseImpl]case [CtFieldReadImpl]INF_UMU :
                [CtIfImpl][CtCommentImpl]/* non-mechanized SCUBA infantry have a maximum depth of 2 */
                if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Infantry) && [CtInvocationImpl][CtThisAccessImpl](([CtTypeReferenceImpl]megamek.common.Infantry) (this)).hasSpecialization([CtTypeAccessImpl]Infantry.SCUBA)) && [CtInvocationImpl][CtVariableReadImpl]hex.containsTerrain([CtTypeAccessImpl]Terrains.WATER)) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]minAlt = [CtInvocationImpl][CtTypeAccessImpl]java.lang.Math.max([CtInvocationImpl][CtVariableReadImpl]hex.floor(), [CtUnaryOperatorImpl]-[CtLiteralImpl]2);
                } else [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]minAlt = [CtInvocationImpl][CtVariableReadImpl]hex.floor();
                }
                [CtBreakImpl]break;
            [CtCaseImpl]case [CtFieldReadImpl]SUBMARINE :
            [CtCaseImpl]case [CtFieldReadImpl]BIPED_SWIM :
            [CtCaseImpl]case [CtFieldReadImpl]QUAD_SWIM :
                [CtAssignmentImpl][CtVariableWriteImpl]minAlt = [CtInvocationImpl][CtVariableReadImpl]hex.floor();
                [CtBreakImpl]break;
            [CtCaseImpl]case [CtFieldReadImpl]BIPED :
            [CtCaseImpl]case [CtFieldReadImpl]QUAD :
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Protomech) [CtBlockImpl]{
                    [CtOperatorAssignmentImpl][CtVariableWriteImpl]minAlt -= [CtInvocationImpl][CtTypeAccessImpl]java.lang.Math.max([CtLiteralImpl]0, [CtInvocationImpl][CtInvocationImpl][CtTypeAccessImpl]megamek.common.Building.BasementType.getType([CtInvocationImpl][CtVariableReadImpl]hex.terrainLevel([CtTypeAccessImpl]Terrains.BLDG_BASEMENT_TYPE)).getDepth());
                } else [CtBlockImpl]{
                    [CtReturnImpl]return [CtLiteralImpl]false;
                }
                [CtBreakImpl]break;
            [CtCaseImpl]default :
                [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtVariableReadImpl]assumedAlt > [CtVariableReadImpl]minAlt;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * is it possible to go up, or are we at maximum altitude? assuming passed
     * elevation.
     */
    public [CtTypeReferenceImpl]boolean canGoUp([CtParameterImpl][CtTypeReferenceImpl]int assumedElevation, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords assumedPos) [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// Could have a hex off the board
        if ([CtUnaryOperatorImpl]![CtInvocationImpl][CtInvocationImpl][CtInvocationImpl]getGame().getBoard().contains([CtVariableReadImpl]assumedPos)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.IHex hex = [CtInvocationImpl][CtInvocationImpl][CtInvocationImpl]getGame().getBoard().getHex([CtVariableReadImpl]assumedPos);
        [CtLocalVariableImpl][CtTypeReferenceImpl]int assumedAlt = [CtBinaryOperatorImpl][CtVariableReadImpl]assumedElevation + [CtInvocationImpl][CtVariableReadImpl]hex.surface();
        [CtLocalVariableImpl][CtTypeReferenceImpl]int maxAlt = [CtInvocationImpl][CtVariableReadImpl]hex.surface();
        [CtSwitchImpl]switch ([CtInvocationImpl]getMovementMode()) {
            [CtCaseImpl]case [CtFieldReadImpl]INF_JUMP :
            [CtCaseImpl]case [CtFieldReadImpl]INF_LEG :
            [CtCaseImpl]case [CtFieldReadImpl]INF_MOTORIZED :
                [CtOperatorAssignmentImpl][CtVariableWriteImpl]maxAlt += [CtInvocationImpl][CtTypeAccessImpl]java.lang.Math.max([CtLiteralImpl]0, [CtInvocationImpl][CtVariableReadImpl]hex.terrainLevel([CtTypeAccessImpl]Terrains.BLDG_ELEV));
                [CtBreakImpl]break;
            [CtCaseImpl]case [CtFieldReadImpl]VTOL :
                [CtAssignmentImpl][CtVariableWriteImpl]maxAlt = [CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]hex.surface() + [CtLiteralImpl]50;
                [CtBreakImpl]break;
            [CtCaseImpl]case [CtFieldReadImpl]AERODYNE :
            [CtCaseImpl]case [CtFieldReadImpl]SPHEROID :
                [CtIfImpl]if ([CtUnaryOperatorImpl]![CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().inSpace()) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]assumedAlt = [CtVariableReadImpl]assumedElevation;
                    [CtAssignmentImpl][CtVariableWriteImpl]maxAlt = [CtLiteralImpl]10;
                }
                [CtBreakImpl]break;
            [CtCaseImpl]case [CtFieldReadImpl]SUBMARINE :
                [CtAssignmentImpl][CtVariableWriteImpl]maxAlt = [CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]hex.surface() - [CtInvocationImpl]getHeight();
                [CtBreakImpl]break;
            [CtCaseImpl]case [CtFieldReadImpl]INF_UMU :
            [CtCaseImpl]case [CtFieldReadImpl]BIPED_SWIM :
            [CtCaseImpl]case [CtFieldReadImpl]QUAD_SWIM :
                [CtAssignmentImpl][CtCommentImpl]// UMU's won't allow the entity to break the surface of the
                [CtCommentImpl]// water
                [CtVariableWriteImpl]maxAlt = [CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]hex.surface() - [CtBinaryOperatorImpl]([CtInvocationImpl]getHeight() + [CtLiteralImpl]1);
                [CtBreakImpl]break;
            [CtCaseImpl]case [CtFieldReadImpl]WIGE :
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.LandAirMech) [CtBlockImpl]{
                    [CtIfImpl]if ([CtInvocationImpl]isAirborne()) [CtBlockImpl]{
                        [CtReturnImpl]return [CtLiteralImpl]false;
                    }
                    [CtAssignmentImpl][CtVariableWriteImpl]maxAlt = [CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]hex.surface() + [CtLiteralImpl]25;
                } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Protomech) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]maxAlt = [CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]hex.surface() + [CtLiteralImpl]12;
                } else [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]hex.containsTerrain([CtTypeAccessImpl]Terrains.BLDG_ELEV)) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]maxAlt = [CtBinaryOperatorImpl][CtInvocationImpl][CtTypeAccessImpl]java.lang.Math.max([CtInvocationImpl][CtVariableReadImpl]hex.surface(), [CtInvocationImpl][CtVariableReadImpl]hex.terrainLevel([CtTypeAccessImpl]Terrains.BLDG_ELEV)) + [CtLiteralImpl]1;
                } else [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]maxAlt = [CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]hex.surface() + [CtLiteralImpl]1;
                }
                [CtBreakImpl]break;
            [CtCaseImpl]case [CtFieldReadImpl]BIPED :
            [CtCaseImpl]case [CtFieldReadImpl]QUAD :
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Protomech) [CtBlockImpl]{
                    [CtOperatorAssignmentImpl][CtVariableWriteImpl]maxAlt += [CtInvocationImpl][CtTypeAccessImpl]java.lang.Math.max([CtLiteralImpl]0, [CtInvocationImpl][CtVariableReadImpl]hex.terrainLevel([CtTypeAccessImpl]Terrains.BLDG_ELEV));
                } else [CtBlockImpl]{
                    [CtReturnImpl]return [CtLiteralImpl]false;
                }
                [CtBreakImpl]break;
            [CtCaseImpl]default :
                [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtVariableReadImpl]assumedAlt < [CtVariableReadImpl]maxAlt;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Check if this entity can legally occupy the requested elevation. Does not
     * check stacking, only terrain limitations
     */
    public [CtTypeReferenceImpl]boolean isElevationValid([CtParameterImpl][CtTypeReferenceImpl]int assumedElevation, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.IHex hex) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int assumedAlt = [CtBinaryOperatorImpl][CtVariableReadImpl]assumedElevation + [CtInvocationImpl][CtVariableReadImpl]hex.surface();
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]getMovementMode() == [CtFieldReadImpl]EntityMovementMode.VTOL) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Infantry) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]hex.containsTerrain([CtTypeAccessImpl]Terrains.BUILDING) || [CtInvocationImpl][CtVariableReadImpl]hex.containsTerrain([CtTypeAccessImpl]Terrains.WOODS)) || [CtInvocationImpl][CtVariableReadImpl]hex.containsTerrain([CtTypeAccessImpl]Terrains.JUNGLE))) [CtBlockImpl]{
                [CtReturnImpl][CtCommentImpl]// VTOL BA (sylph) can move as ground unit as well
                return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]assumedElevation <= [CtLiteralImpl]50) && [CtBinaryOperatorImpl]([CtVariableReadImpl]assumedAlt >= [CtInvocationImpl][CtVariableReadImpl]hex.floor());
            } else [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]hex.containsTerrain([CtTypeAccessImpl]Terrains.BRIDGE_ELEV)) [CtBlockImpl]{
                [CtReturnImpl][CtCommentImpl]// fly under a bridge as long as there is enough clearance below and above the unit
                return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]assumedElevation <= [CtLiteralImpl]50) && [CtBinaryOperatorImpl]([CtVariableReadImpl]assumedElevation > [CtInvocationImpl][CtVariableReadImpl]hex.floor())) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]assumedElevation > [CtInvocationImpl][CtVariableReadImpl]hex.terrainLevel([CtTypeAccessImpl]Terrains.BRIDGE_ELEV)) || [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]assumedElevation + [CtInvocationImpl]height()) < [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]hex.terrainLevel([CtTypeAccessImpl]Terrains.BRIDGE_ELEV) - [CtLiteralImpl]1)));
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]hex.containsTerrain([CtTypeAccessImpl]Terrains.WOODS) || [CtInvocationImpl][CtVariableReadImpl]hex.containsTerrain([CtTypeAccessImpl]Terrains.WATER)) || [CtInvocationImpl][CtVariableReadImpl]hex.containsTerrain([CtTypeAccessImpl]Terrains.JUNGLE)) [CtBlockImpl]{
                [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]assumedElevation <= [CtLiteralImpl]50) && [CtBinaryOperatorImpl]([CtVariableReadImpl]assumedAlt > [CtInvocationImpl][CtVariableReadImpl]hex.ceiling());
            }
            [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]assumedElevation <= [CtLiteralImpl]50) && [CtBinaryOperatorImpl]([CtVariableReadImpl]assumedAlt >= [CtInvocationImpl][CtVariableReadImpl]hex.ceiling());
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() == [CtFieldReadImpl]EntityMovementMode.SUBMARINE) || [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() == [CtFieldReadImpl]EntityMovementMode.INF_UMU) && [CtInvocationImpl][CtVariableReadImpl]hex.containsTerrain([CtTypeAccessImpl]Terrains.WATER))) || [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() == [CtFieldReadImpl]EntityMovementMode.QUAD_SWIM) && [CtInvocationImpl]hasUMU())) || [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() == [CtFieldReadImpl]EntityMovementMode.BIPED_SWIM) && [CtInvocationImpl]hasUMU())) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Infantry) && [CtInvocationImpl][CtThisAccessImpl](([CtTypeReferenceImpl]megamek.common.Infantry) (this)).hasSpecialization([CtTypeAccessImpl]Infantry.SCUBA)) && [CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() == [CtFieldReadImpl]EntityMovementMode.INF_UMU)) [CtBlockImpl]{
                [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]assumedAlt >= [CtInvocationImpl][CtTypeAccessImpl]java.lang.Math.max([CtInvocationImpl][CtVariableReadImpl]hex.floor(), [CtUnaryOperatorImpl]-[CtLiteralImpl]2)) && [CtBinaryOperatorImpl]([CtVariableReadImpl]assumedAlt <= [CtInvocationImpl][CtVariableReadImpl]hex.surface());
            }
            [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]assumedAlt >= [CtInvocationImpl][CtVariableReadImpl]hex.floor()) && [CtBinaryOperatorImpl]([CtVariableReadImpl]assumedAlt <= [CtInvocationImpl][CtVariableReadImpl]hex.surface());
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() == [CtFieldReadImpl]EntityMovementMode.HYDROFOIL) || [CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() == [CtFieldReadImpl]EntityMovementMode.NAVAL)) [CtBlockImpl]{
            [CtReturnImpl]return [CtBinaryOperatorImpl][CtVariableReadImpl]assumedAlt == [CtInvocationImpl][CtVariableReadImpl]hex.surface();
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]getMovementMode() == [CtFieldReadImpl]EntityMovementMode.WIGE) [CtBlockImpl]{
            [CtReturnImpl][CtCommentImpl]// WiGEs can possibly be at any location above or on the surface
            return [CtBinaryOperatorImpl][CtVariableReadImpl]assumedAlt >= [CtInvocationImpl][CtVariableReadImpl]hex.floor();
        } else [CtBlockImpl]{
            [CtIfImpl][CtCommentImpl]// regular ground units
            if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]hex.containsTerrain([CtTypeAccessImpl]Terrains.ICE) || [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() == [CtFieldReadImpl]EntityMovementMode.HOVER) || [CtInvocationImpl]hasWorkingMisc([CtTypeAccessImpl]MiscType.F_FULLY_AMPHIBIOUS)) && [CtInvocationImpl][CtVariableReadImpl]hex.containsTerrain([CtTypeAccessImpl]Terrains.WATER))) [CtBlockImpl]{
                [CtIfImpl][CtCommentImpl]// surface of ice is OK, surface of water is OK for hovers and "fully amphibious" units
                if ([CtBinaryOperatorImpl][CtVariableReadImpl]assumedAlt == [CtInvocationImpl][CtVariableReadImpl]hex.surface()) [CtBlockImpl]{
                    [CtReturnImpl]return [CtLiteralImpl]true;
                }
            }
            [CtIfImpl][CtCommentImpl]// only mechs can move underwater
            if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]hex.containsTerrain([CtTypeAccessImpl]Terrains.WATER) && [CtBinaryOperatorImpl]([CtVariableReadImpl]assumedAlt < [CtInvocationImpl][CtVariableReadImpl]hex.surface())) && [CtUnaryOperatorImpl](![CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Mech))) && [CtUnaryOperatorImpl](![CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Protomech))) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]false;
            }
            [CtIfImpl][CtCommentImpl]// can move on the ground unless its underwater
            if ([CtBinaryOperatorImpl][CtVariableReadImpl]assumedAlt == [CtInvocationImpl][CtVariableReadImpl]hex.floor()) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
            [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]hex.containsTerrain([CtTypeAccessImpl]Terrains.BRIDGE)) [CtBlockImpl]{
                [CtIfImpl][CtCommentImpl]// can move on top of a bridge
                if ([CtBinaryOperatorImpl][CtVariableReadImpl]assumedElevation == [CtInvocationImpl][CtVariableReadImpl]hex.terrainLevel([CtTypeAccessImpl]Terrains.BRIDGE_ELEV)) [CtBlockImpl]{
                    [CtReturnImpl]return [CtLiteralImpl]true;
                }
            }
            [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]hex.containsTerrain([CtTypeAccessImpl]Terrains.BUILDING)) [CtBlockImpl]{
                [CtIfImpl][CtCommentImpl]// Any unit can fall into a basement
                if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]assumedAlt < [CtLiteralImpl]0) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]hex.depth([CtLiteralImpl]true) > [CtLiteralImpl]0)) [CtBlockImpl]{
                    [CtReturnImpl]return [CtLiteralImpl]true;
                }
                [CtIfImpl][CtCommentImpl]// Mechs, protos and infantry can occupy any floor in the
                [CtCommentImpl]// building
                if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Mech) || [CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Protomech)) || [CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Infantry)) [CtBlockImpl]{
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]assumedAlt >= [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]hex.surface() - [CtInvocationImpl][CtVariableReadImpl]hex.depth([CtLiteralImpl]true))) && [CtBinaryOperatorImpl]([CtVariableReadImpl]assumedAlt <= [CtInvocationImpl][CtVariableReadImpl]hex.ceiling())) [CtBlockImpl]{
                        [CtReturnImpl]return [CtLiteralImpl]true;
                    }
                }
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the height of the unit, that is, how many levels above its
     * elevation it is for LOS purposes. Default is 0.
     */
    public [CtTypeReferenceImpl]int height() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]0;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the elevation of the entity's highest point relative to
     * the surface of the hex the entity is in , i.e.
     * relHeight() == getElevation() + getHeight()
     */
    [CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]int relHeight() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtInvocationImpl]getElevation() + [CtInvocationImpl]height();
    }

    [CtMethodImpl][CtCommentImpl]/* Convenience method to determine whether this entity is on a ground map with an atmosphere */
    public [CtTypeReferenceImpl]boolean isOnAtmosphericGroundMap() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtInvocationImpl]getGame().getPlanetaryConditions().getAtmosphere() != [CtFieldReadImpl]PlanetaryConditions.ATMO_VACUUM) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtInvocationImpl]getGame().getPlanetaryConditions().getAtmosphere() != [CtFieldReadImpl]PlanetaryConditions.ATMO_TRACE)) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtInvocationImpl]getGame().getBoard().onGround() || [CtInvocationImpl][CtCommentImpl]// doesn't make sense in english, but "atmospheric" map actually
        [CtCommentImpl]// covers maps that are within a planet's gravity well
        [CtInvocationImpl][CtInvocationImpl]getGame().getBoard().inAtmosphere());
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Convenience method to determine whether this entity should be treated as an airborne aero on a ground map.
     *
     * @return True if this is an airborne aircraft on a ground map.
     */
    public [CtTypeReferenceImpl]boolean isAirborneAeroOnGroundMap() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl]isAero() && [CtInvocationImpl]isAirborne()) && [CtInvocationImpl][CtInvocationImpl][CtInvocationImpl]getGame().getBoard().onGround();
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the display name for this entity.
     */
    [CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]java.lang.String getDisplayName() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]displayName == [CtLiteralImpl]null) [CtBlockImpl]{
            [CtInvocationImpl]generateDisplayName();
        }
        [CtReturnImpl]return [CtFieldReadImpl]displayName;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Generates the display name for this entity.
     * <p/>
     * Sub-classes are allowed to override this method. The display name is in
     * the format [Chassis] [Model] ([Player Name]).
     */
    public [CtTypeReferenceImpl]void generateDisplayName() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.lang.StringBuffer nbuf = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.lang.StringBuffer();
        [CtInvocationImpl][CtVariableReadImpl]nbuf.append([CtFieldReadImpl]chassis);
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtFieldReadImpl]model != [CtLiteralImpl]null) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtFieldReadImpl]model.length() > [CtLiteralImpl]0)) [CtBlockImpl]{
            [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]nbuf.append([CtLiteralImpl]" ").append([CtFieldReadImpl]model);
        }
        [CtIfImpl][CtCommentImpl]// if show unit id is on, append the id
        if ([CtInvocationImpl][CtInvocationImpl][CtTypeAccessImpl]megamek.common.preference.PreferenceManager.getClientPreferences().getShowUnitId()) [CtBlockImpl]{
            [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]nbuf.append([CtLiteralImpl]" ID:").append([CtInvocationImpl]getId());
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]duplicateMarker > [CtLiteralImpl]1) [CtBlockImpl]{
            [CtInvocationImpl][CtCommentImpl]// if not, and a player has more than one unit with the same name,
            [CtCommentImpl]// append "#N" after the model to differentiate.
            [CtVariableReadImpl]nbuf.append([CtBinaryOperatorImpl][CtLiteralImpl]" #" + [CtFieldReadImpl]duplicateMarker);
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]getOwner() != [CtLiteralImpl]null) [CtBlockImpl]{
            [CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]nbuf.append([CtLiteralImpl]" (").append([CtInvocationImpl][CtInvocationImpl]getOwner().getName()).append([CtLiteralImpl]")");
        }
        [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtTypeAccessImpl]megamek.common.preference.PreferenceManager.getClientPreferences().getShowUnitId()) [CtBlockImpl]{
            [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]nbuf.append([CtLiteralImpl]" ID:").append([CtInvocationImpl]getId());
        }
        [CtAssignmentImpl][CtFieldWriteImpl]displayName = [CtInvocationImpl][CtVariableReadImpl]nbuf.toString();
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * A short name, suitable for displaying above a unit icon. The short name
     * is basically the same as the display name, minus the player name.
     */
    public [CtTypeReferenceImpl]java.lang.String getShortName() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]shortName == [CtLiteralImpl]null) [CtBlockImpl]{
            [CtInvocationImpl]generateShortName();
        }
        [CtReturnImpl]return [CtFieldReadImpl]shortName;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Generate the short name for a unit
     * <p/>
     * Sub-classes are allowed to override this method. The display name is in
     * the format [Chassis] [Model].
     */
    public [CtTypeReferenceImpl]void generateShortName() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.lang.StringBuffer nbuf = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.lang.StringBuffer();
        [CtInvocationImpl][CtVariableReadImpl]nbuf.append([CtFieldReadImpl]chassis);
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtFieldReadImpl]model != [CtLiteralImpl]null) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtFieldReadImpl]model.length() > [CtLiteralImpl]0)) [CtBlockImpl]{
            [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]nbuf.append([CtLiteralImpl]" ").append([CtFieldReadImpl]model);
        }
        [CtIfImpl][CtCommentImpl]// if show unit id is on, append the id
        if ([CtInvocationImpl][CtInvocationImpl][CtTypeAccessImpl]megamek.common.preference.PreferenceManager.getClientPreferences().getShowUnitId()) [CtBlockImpl]{
            [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]nbuf.append([CtLiteralImpl]" ID:").append([CtInvocationImpl]getId());
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]duplicateMarker > [CtLiteralImpl]1) [CtBlockImpl]{
            [CtInvocationImpl][CtCommentImpl]// if not, and a player has more than one unit with the same name,
            [CtCommentImpl]// append "#N" after the model to differentiate.
            [CtVariableReadImpl]nbuf.append([CtBinaryOperatorImpl][CtLiteralImpl]" #" + [CtFieldReadImpl]duplicateMarker);
        }
        [CtAssignmentImpl][CtFieldWriteImpl]shortName = [CtInvocationImpl][CtVariableReadImpl]nbuf.toString();
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.lang.String getShortNameRaw() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.lang.StringBuffer nbuf = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.lang.StringBuffer();
        [CtInvocationImpl][CtVariableReadImpl]nbuf.append([CtFieldReadImpl]chassis);
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtFieldReadImpl]model != [CtLiteralImpl]null) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtFieldReadImpl]model.length() > [CtLiteralImpl]0)) [CtBlockImpl]{
            [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]nbuf.append([CtLiteralImpl]" ").append([CtFieldReadImpl]model);
        }
        [CtReturnImpl]return [CtInvocationImpl][CtVariableReadImpl]nbuf.toString();
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the primary facing, or -1 if n/a
     */
    public [CtTypeReferenceImpl]int getFacing() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE != [CtFieldReadImpl]conveyance) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity transporter = [CtInvocationImpl][CtFieldReadImpl]game.getEntity([CtFieldReadImpl]conveyance);
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]transporter == [CtLiteralImpl]null) [CtBlockImpl]{
                [CtAssignmentImpl][CtVariableWriteImpl]transporter = [CtInvocationImpl][CtFieldReadImpl]game.getOutOfGameEntity([CtFieldReadImpl]conveyance);
            }
            [CtReturnImpl]return [CtInvocationImpl][CtVariableReadImpl]transporter.getFacing();
        }
        [CtReturnImpl]return [CtFieldReadImpl]facing;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Sets the primary facing.
     */
    public [CtTypeReferenceImpl]void setFacing([CtParameterImpl][CtTypeReferenceImpl]int facing) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.facing = [CtVariableReadImpl]facing;
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]game != [CtLiteralImpl]null) [CtBlockImpl]{
            [CtInvocationImpl][CtFieldReadImpl]game.processGameEvent([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.event.GameEntityChangeEvent([CtThisAccessImpl]this, [CtThisAccessImpl]this));
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the secondary facing, or -1 if n/a
     */
    public [CtTypeReferenceImpl]int getSecondaryFacing() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]sec_facing;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Sets the secondary facing.
     */
    public [CtTypeReferenceImpl]void setSecondaryFacing([CtParameterImpl][CtTypeReferenceImpl]int sec_facing) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.sec_facing = [CtVariableReadImpl]sec_facing;
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]game != [CtLiteralImpl]null) [CtBlockImpl]{
            [CtInvocationImpl][CtFieldReadImpl]game.processGameEvent([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.event.GameEntityChangeEvent([CtThisAccessImpl]this, [CtThisAccessImpl]this));
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Can this entity change secondary facing at all?
     */
    public abstract [CtTypeReferenceImpl]boolean canChangeSecondaryFacing();

    [CtMethodImpl][CtJavaDocImpl]/**
     * Can this entity torso/turret twist the given direction?
     */
    public abstract [CtTypeReferenceImpl]boolean isValidSecondaryFacing([CtParameterImpl][CtTypeReferenceImpl]int dir);

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the closest valid secondary facing to the given direction.
     *
     * @return the the closest valid secondary facing.
     */
    public abstract [CtTypeReferenceImpl]int clipSecondaryFacing([CtParameterImpl][CtTypeReferenceImpl]int dir);

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns true if the entity has an RAC which is jammed and not destroyed
     * As of 5/22/2012 also returns true if there is a jammed and not destroyed
     * Ultra AC and the unofficial options is enabled.  Jammed ACs and LACs can
     * also be unjammed if rapid-fire ACs is turned on.
     */
    public [CtTypeReferenceImpl]boolean canUnjamRAC() [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted : [CtInvocationImpl]getTotalWeaponList()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.WeaponType wtype = [CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.WeaponType) ([CtVariableReadImpl]mounted.getType()));
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]wtype.getAmmoType() == [CtFieldReadImpl]AmmoType.T_AC_ROTARY) && [CtInvocationImpl][CtVariableReadImpl]mounted.isJammed()) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]mounted.isDestroyed())) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]wtype.getAmmoType() == [CtFieldReadImpl]AmmoType.T_AC_ULTRA) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]wtype.getAmmoType() == [CtFieldReadImpl]AmmoType.T_AC_ULTRA_THB)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]wtype.getAmmoType() == [CtFieldReadImpl]AmmoType.T_AC)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]wtype.getAmmoType() == [CtFieldReadImpl]AmmoType.T_LAC)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]wtype.getAmmoType() == [CtFieldReadImpl]AmmoType.T_AC_IMP)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]wtype.getAmmoType() == [CtFieldReadImpl]AmmoType.T_PAC)) && [CtInvocationImpl][CtVariableReadImpl]mounted.isJammed()) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]mounted.isDestroyed())) && [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVCOMBAT_UNJAM_UAC)) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns true if the entity can flip its arms
     */
    public [CtTypeReferenceImpl]boolean canFlipArms() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns this entity's original walking movement points
     */
    public [CtTypeReferenceImpl]int getOriginalWalkMP() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]walkMP;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Sets this entity's original walking movement points
     */
    public [CtTypeReferenceImpl]void setOriginalWalkMP([CtParameterImpl][CtTypeReferenceImpl]int walkMP) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.walkMP = [CtVariableReadImpl]walkMP;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns this entity's walking/cruising mp, factored for heat and gravity.
     */
    public [CtTypeReferenceImpl]int getWalkMP() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getWalkMP([CtLiteralImpl]true, [CtLiteralImpl]false);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns this entity's walking/cruising mp, factored for heat and possibly
     * gravity.
     *
     * @param gravity
     * 		Should the movement be factored for gravity
     * @param ignoreheat
     * 		Should heat be ignored?
     */
    public [CtTypeReferenceImpl]int getWalkMP([CtParameterImpl][CtTypeReferenceImpl]boolean gravity, [CtParameterImpl][CtTypeReferenceImpl]boolean ignoreheat) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getWalkMP([CtVariableReadImpl]gravity, [CtVariableReadImpl]ignoreheat, [CtLiteralImpl]false);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getWalkMP([CtParameterImpl][CtTypeReferenceImpl]boolean gravity, [CtParameterImpl][CtTypeReferenceImpl]boolean ignoreheat, [CtParameterImpl][CtTypeReferenceImpl]boolean ignoremodulararmor) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int mp = [CtInvocationImpl]getOriginalWalkMP();
        [CtIfImpl]if ([CtUnaryOperatorImpl]![CtVariableReadImpl]ignoreheat) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]mp = [CtInvocationImpl][CtTypeAccessImpl]java.lang.Math.max([CtLiteralImpl]0, [CtBinaryOperatorImpl][CtVariableReadImpl]mp - [CtInvocationImpl]getHeatMPReduction());
        }
        [CtAssignmentImpl][CtVariableWriteImpl]mp = [CtInvocationImpl][CtTypeAccessImpl]java.lang.Math.max([CtBinaryOperatorImpl][CtVariableReadImpl]mp - [CtInvocationImpl]getCargoMpReduction([CtThisAccessImpl]this), [CtLiteralImpl]0);
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtLiteralImpl]null != [CtFieldReadImpl]game) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]int weatherMod = [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getPlanetaryConditions().getMovementMods([CtThisAccessImpl]this);
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]weatherMod != [CtLiteralImpl]0) [CtBlockImpl]{
                [CtAssignmentImpl][CtVariableWriteImpl]mp = [CtInvocationImpl][CtTypeAccessImpl]java.lang.Math.max([CtBinaryOperatorImpl][CtVariableReadImpl]mp + [CtVariableReadImpl]weatherMod, [CtLiteralImpl]0);
            }
        }
        [CtIfImpl]if ([CtVariableReadImpl]gravity) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]mp = [CtInvocationImpl]applyGravityEffectsOnMP([CtVariableReadImpl]mp);
        }
        [CtReturnImpl]return [CtVariableReadImpl]mp;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * This returns how much MP is removed due to heat
     *
     * @return  */
    public [CtTypeReferenceImpl]int getHeatMPReduction() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int minus;
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtFieldReadImpl]game != [CtLiteralImpl]null) && [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVCOMBAT_TACOPS_HEAT)) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]heat < [CtLiteralImpl]30) [CtBlockImpl]{
                [CtAssignmentImpl][CtVariableWriteImpl]minus = [CtBinaryOperatorImpl][CtFieldReadImpl]heat / [CtLiteralImpl]5;
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]heat >= [CtLiteralImpl]49) [CtBlockImpl]{
                [CtAssignmentImpl][CtVariableWriteImpl]minus = [CtLiteralImpl]9;
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]heat >= [CtLiteralImpl]43) [CtBlockImpl]{
                [CtAssignmentImpl][CtVariableWriteImpl]minus = [CtLiteralImpl]8;
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]heat >= [CtLiteralImpl]37) [CtBlockImpl]{
                [CtAssignmentImpl][CtVariableWriteImpl]minus = [CtLiteralImpl]7;
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]heat >= [CtLiteralImpl]31) [CtBlockImpl]{
                [CtAssignmentImpl][CtVariableWriteImpl]minus = [CtLiteralImpl]6;
            } else [CtBlockImpl]{
                [CtAssignmentImpl][CtVariableWriteImpl]minus = [CtLiteralImpl]5;
            }
        } else [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]minus = [CtBinaryOperatorImpl][CtFieldReadImpl]heat / [CtLiteralImpl]5;
        }
        [CtReturnImpl]return [CtVariableReadImpl]minus;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * get the heat generated by this Entity when standing still
     */
    public [CtTypeReferenceImpl]int getStandingHeat() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]0;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * get the heat generated by this Entity when walking/cruising
     */
    public [CtTypeReferenceImpl]int getWalkHeat() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]0;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns this entity's unmodified running/flank mp.
     */
    public [CtTypeReferenceImpl]int getOriginalRunMP() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl](([CtTypeReferenceImpl]int) ([CtTypeAccessImpl]java.lang.Math.ceil([CtBinaryOperatorImpl][CtInvocationImpl]getOriginalWalkMP() * [CtLiteralImpl]1.5)));
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns this entity's running/flank mp modified for heat and gravity.
     */
    public [CtTypeReferenceImpl]int getRunMP() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getRunMP([CtLiteralImpl]true, [CtLiteralImpl]false, [CtLiteralImpl]false);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getRunMP([CtParameterImpl][CtTypeReferenceImpl]boolean gravity, [CtParameterImpl][CtTypeReferenceImpl]boolean ignoreheat, [CtParameterImpl][CtTypeReferenceImpl]boolean ignoremodulararmor) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl](([CtTypeReferenceImpl]int) ([CtTypeAccessImpl]java.lang.Math.ceil([CtBinaryOperatorImpl][CtInvocationImpl]getWalkMP([CtVariableReadImpl]gravity, [CtVariableReadImpl]ignoreheat, [CtVariableReadImpl]ignoremodulararmor) * [CtLiteralImpl]1.5)));
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns run MP without considering MASC
     */
    public [CtTypeReferenceImpl]int getRunMPwithoutMASC() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getRunMPwithoutMASC([CtLiteralImpl]true, [CtLiteralImpl]false, [CtLiteralImpl]false);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns run MP without considering MASC, optionally figuring in gravity
     * and possibly ignoring heat
     */
    public abstract [CtTypeReferenceImpl]int getRunMPwithoutMASC([CtParameterImpl][CtTypeReferenceImpl]boolean gravity, [CtParameterImpl][CtTypeReferenceImpl]boolean ignoreheat, [CtParameterImpl][CtTypeReferenceImpl]boolean ignoremodulararmor);

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns this entity's running/flank mp as a string.
     */
    public [CtTypeReferenceImpl]java.lang.String getRunMPasString() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtTypeAccessImpl]java.lang.Integer.toString([CtInvocationImpl]getRunMP());
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * get the heat generated by this Entity when running/flanking
     */
    public [CtTypeReferenceImpl]int getRunHeat() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]0;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns this entity's unmodified sprint mp.
     */
    protected [CtTypeReferenceImpl]int getOriginalSprintMP() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getOriginalRunMP();
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns this entity's running/flank mp modified for heat and gravity.
     */
    public [CtTypeReferenceImpl]int getSprintMP() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getRunMP();
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getSprintMP([CtParameterImpl][CtTypeReferenceImpl]boolean gravity, [CtParameterImpl][CtTypeReferenceImpl]boolean ignoreheat, [CtParameterImpl][CtTypeReferenceImpl]boolean ignoremodulararmor) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getRunMP([CtVariableReadImpl]gravity, [CtVariableReadImpl]ignoreheat, [CtVariableReadImpl]ignoremodulararmor);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns sprint MP without considering MASC
     */
    public [CtTypeReferenceImpl]int getSprintMPwithoutMASC() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getRunMPwithoutMASC();
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns sprint MP without considering MASC, optionally figuring in
     * gravity and possibly ignoring heat
     */
    public [CtTypeReferenceImpl]int getSprintMPwithoutMASC([CtParameterImpl][CtTypeReferenceImpl]boolean gravity, [CtParameterImpl][CtTypeReferenceImpl]boolean ignoreheat, [CtParameterImpl][CtTypeReferenceImpl]boolean ignoremodulararmor) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getRunMPwithoutMASC([CtVariableReadImpl]gravity, [CtVariableReadImpl]ignoreheat, [CtVariableReadImpl]ignoremodulararmor);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns this entity's sprint mp as a string.
     */
    public [CtTypeReferenceImpl]java.lang.String getSprintMPasString() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtTypeAccessImpl]java.lang.Integer.toString([CtInvocationImpl]getSprintMP());
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * get the heat generated by this Entity when sprinting
     */
    public [CtTypeReferenceImpl]int getSprintHeat() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]3;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * get the gravity limit for ground movement
     */
    public [CtTypeReferenceImpl]int getRunningGravityLimit() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getRunMP([CtLiteralImpl]false, [CtLiteralImpl]false, [CtLiteralImpl]false);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns this entity's original jumping mp.
     */
    public [CtTypeReferenceImpl]int getOriginalJumpMP() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getOriginalJumpMP([CtLiteralImpl]false);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getOriginalJumpMP([CtParameterImpl][CtTypeReferenceImpl]boolean ignoreModularArmor) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtUnaryOperatorImpl](![CtVariableReadImpl]ignoreModularArmor) && [CtInvocationImpl]hasModularArmor()) [CtBlockImpl]{
            [CtReturnImpl]return [CtInvocationImpl][CtTypeAccessImpl]java.lang.Math.max([CtLiteralImpl]0, [CtBinaryOperatorImpl][CtFieldReadImpl]jumpMP - [CtLiteralImpl]1);
        }
        [CtReturnImpl]return [CtFieldReadImpl]jumpMP;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Sets this entity's original jump movement points
     */
    public [CtTypeReferenceImpl]void setOriginalJumpMP([CtParameterImpl][CtTypeReferenceImpl]int jumpMP) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.jumpMP = [CtVariableReadImpl]jumpMP;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns this entity's current jumping MP, not affected by terrain,
     * factored for gravity.
     */
    public [CtTypeReferenceImpl]int getJumpMP() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getJumpMP([CtLiteralImpl]true);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * return this entity's current jump MP, possibly affected by gravity
     *
     * @param gravity
     * @return  */
    public [CtTypeReferenceImpl]int getJumpMP([CtParameterImpl][CtTypeReferenceImpl]boolean gravity) [CtBlockImpl]{
        [CtIfImpl]if ([CtVariableReadImpl]gravity) [CtBlockImpl]{
            [CtReturnImpl]return [CtInvocationImpl]applyGravityEffectsOnMP([CtInvocationImpl]getOriginalJumpMP());
        }
        [CtReturnImpl]return [CtInvocationImpl]getOriginalJumpMP();
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getJumpType() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]0;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * get the heat generated by this Entity when jumping for a certain amount
     * of MP
     *
     * @param movedMP
     * 		the number of movement points spent
     */
    public [CtTypeReferenceImpl]int getJumpHeat([CtParameterImpl][CtTypeReferenceImpl]int movedMP) [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]0;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns this entity's current jumping MP, affected by terrain (like
     * water.)
     */
    public [CtTypeReferenceImpl]int getJumpMPWithTerrain() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getJumpMP();
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Tanks and certain other units can get a +1 bonus to MP if their move is entirely on pavement.
     *
     * @return true if the <code>Entity</code> gets a movement bonus on pavement
     */
    public [CtTypeReferenceImpl]boolean isEligibleForPavementBonus() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the absolute elevation above ground level 0 that this entity
     * would be on if it were placed into the specified hex.
     * Hovercraft, naval vessels, and hydrofoils move on the
     * surface of the water
     */
    public [CtTypeReferenceImpl]int elevationOccupied([CtParameterImpl][CtTypeReferenceImpl]megamek.common.IHex hex) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]elevationOccupied([CtVariableReadImpl]hex, [CtInvocationImpl]getElevation());
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int elevationOccupied([CtParameterImpl][CtTypeReferenceImpl]megamek.common.IHex hex, [CtParameterImpl][CtTypeReferenceImpl]int elevation) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]hex == [CtLiteralImpl]null) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]0;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtFieldReadImpl]movementMode == [CtFieldReadImpl]EntityMovementMode.VTOL) || [CtBinaryOperatorImpl]([CtFieldReadImpl]movementMode == [CtFieldReadImpl]EntityMovementMode.WIGE)) [CtBlockImpl]{
            [CtReturnImpl]return [CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]hex.surface() + [CtVariableReadImpl]elevation;
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtFieldReadImpl]movementMode == [CtFieldReadImpl]EntityMovementMode.HOVER) || [CtBinaryOperatorImpl]([CtFieldReadImpl]movementMode == [CtFieldReadImpl]EntityMovementMode.NAVAL)) || [CtBinaryOperatorImpl]([CtFieldReadImpl]movementMode == [CtFieldReadImpl]EntityMovementMode.HYDROFOIL)) || [CtInvocationImpl][CtVariableReadImpl]hex.containsTerrain([CtTypeAccessImpl]Terrains.ICE)) && [CtInvocationImpl][CtVariableReadImpl]hex.containsTerrain([CtTypeAccessImpl]Terrains.WATER)) [CtBlockImpl]{
            [CtReturnImpl]return [CtInvocationImpl][CtVariableReadImpl]hex.surface();
        } else [CtBlockImpl]{
            [CtReturnImpl]return [CtInvocationImpl][CtVariableReadImpl]hex.floor();
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns true if the specified hex contains some sort of prohibited
     * terrain.
     */
    public [CtTypeReferenceImpl]boolean isLocationProhibited([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords c) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]isLocationProhibited([CtVariableReadImpl]c, [CtFieldReadImpl]elevation);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns true if the specified hex contains some sort of prohibited
     * terrain if the Entity is at the specified elevation.  Elevation generally
     * only matters for units like WiGEs or VTOLs.
     *
     * @param c
     * @param currElevation
     * @return  */
    public [CtTypeReferenceImpl]boolean isLocationProhibited([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords c, [CtParameterImpl][CtTypeReferenceImpl]int currElevation) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.IHex hex = [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().getHex([CtVariableReadImpl]c);
        [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]hex.containsTerrain([CtTypeAccessImpl]Terrains.IMPASSABLE)) [CtBlockImpl]{
            [CtReturnImpl]return [CtUnaryOperatorImpl]![CtInvocationImpl]isAirborne();
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]hex.containsTerrain([CtTypeAccessImpl]Terrains.SPACE) && [CtInvocationImpl]doomedInSpace()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]true;
        }
        [CtIfImpl][CtCommentImpl]// Additional restrictions for hidden units
        if ([CtInvocationImpl]isHidden()) [CtBlockImpl]{
            [CtIfImpl][CtCommentImpl]// Can't deploy in paved hexes
            if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]hex.containsTerrain([CtTypeAccessImpl]Terrains.PAVEMENT) || [CtInvocationImpl][CtVariableReadImpl]hex.containsTerrain([CtTypeAccessImpl]Terrains.ROAD)) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
            [CtIfImpl][CtCommentImpl]// Can't deploy on a bridge
            if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]hex.terrainLevel([CtTypeAccessImpl]Terrains.BRIDGE_ELEV) == [CtVariableReadImpl]currElevation) && [CtInvocationImpl][CtVariableReadImpl]hex.containsTerrain([CtTypeAccessImpl]Terrains.BRIDGE)) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
            [CtIfImpl][CtCommentImpl]// Can't deploy on the surface of water
            if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]hex.containsTerrain([CtTypeAccessImpl]Terrains.WATER) && [CtBinaryOperatorImpl]([CtVariableReadImpl]currElevation == [CtLiteralImpl]0)) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns true if the the given board is prohibited
     */
    public [CtTypeReferenceImpl]boolean isBoardProhibited([CtParameterImpl][CtTypeReferenceImpl]int mapType) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]mapType == [CtFieldReadImpl]Board.T_GROUND) && [CtInvocationImpl]doomedOnGround()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]true;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]mapType == [CtFieldReadImpl]Board.T_ATMOSPHERE) && [CtInvocationImpl]doomedInAtmosphere()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]true;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]mapType == [CtFieldReadImpl]Board.T_SPACE) && [CtInvocationImpl]doomedInSpace()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]true;
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the name of the type of movement used.
     */
    public abstract [CtTypeReferenceImpl]java.lang.String getMovementString([CtParameterImpl][CtTypeReferenceImpl]megamek.common.EntityMovementType mtype);

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the abbreviation of the name of the type of movement used.
     */
    public abstract [CtTypeReferenceImpl]java.lang.String getMovementAbbr([CtParameterImpl][CtTypeReferenceImpl]megamek.common.EntityMovementType mtype);

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the name of the location specified.
     */
    public [CtTypeReferenceImpl]java.lang.String getLocationName([CtParameterImpl][CtTypeReferenceImpl]megamek.common.HitData hit) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getLocationName([CtInvocationImpl][CtVariableReadImpl]hit.getLocation());
    }

    [CtMethodImpl]public abstract [CtArrayTypeReferenceImpl]java.lang.String[] getLocationNames();

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the name of the location specified.
     */
    public [CtTypeReferenceImpl]java.lang.String getLocationName([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtLocalVariableImpl][CtArrayTypeReferenceImpl]java.lang.String[] locationNames = [CtInvocationImpl]getLocationNames();
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtLiteralImpl]null == [CtVariableReadImpl]locationNames) || [CtBinaryOperatorImpl]([CtVariableReadImpl]loc >= [CtFieldReadImpl][CtVariableReadImpl]locationNames.length)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"";
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]loc < [CtLiteralImpl]0) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"None";
        }
        [CtReturnImpl]return [CtArrayReadImpl][CtVariableReadImpl]locationNames[[CtVariableReadImpl]loc];
    }

    [CtMethodImpl]public abstract [CtArrayTypeReferenceImpl]java.lang.String[] getLocationAbbrs();

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the abbreviated name of the location specified.
     */
    public [CtTypeReferenceImpl]java.lang.String getLocationAbbr([CtParameterImpl][CtTypeReferenceImpl]megamek.common.HitData hit) [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl]getLocationAbbr([CtInvocationImpl][CtVariableReadImpl]hit.getLocation()) + [CtConditionalImpl]([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]hit.isRear() && [CtInvocationImpl]hasRearArmor([CtInvocationImpl][CtVariableReadImpl]hit.getLocation()) ? [CtLiteralImpl]"R" : [CtLiteralImpl]"")) + [CtConditionalImpl]([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]hit.getEffect() & [CtFieldReadImpl]HitData.EFFECT_CRITICAL) == [CtFieldReadImpl]HitData.EFFECT_CRITICAL ? [CtLiteralImpl]" (critical)" : [CtLiteralImpl]"");
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the abbreviated name of the location specified.
     */
    public [CtTypeReferenceImpl]java.lang.String getLocationAbbr([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtLocalVariableImpl][CtArrayTypeReferenceImpl]java.lang.String[] locationAbbrs = [CtInvocationImpl]getLocationAbbrs();
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtLiteralImpl]null == [CtVariableReadImpl]locationAbbrs) || [CtBinaryOperatorImpl]([CtVariableReadImpl]loc >= [CtFieldReadImpl][CtVariableReadImpl]locationAbbrs.length)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"";
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]loc == [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]LOC_NONE) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"None";
        }
        [CtReturnImpl]return [CtArrayReadImpl][CtVariableReadImpl]locationAbbrs[[CtVariableReadImpl]loc];
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the location that the specified abbreviation indicates
     */
    public [CtTypeReferenceImpl]int getLocationFromAbbr([CtParameterImpl][CtTypeReferenceImpl]java.lang.String abbr) [CtBlockImpl]{
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtInvocationImpl]locations(); [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl]getLocationAbbr([CtVariableReadImpl]i).equalsIgnoreCase([CtVariableReadImpl]abbr)) [CtBlockImpl]{
                [CtReturnImpl]return [CtVariableReadImpl]i;
            }
        }
        [CtReturnImpl]return [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]LOC_NONE;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Rolls the to-hit number
     */
    public abstract [CtTypeReferenceImpl]megamek.common.HitData rollHitLocation([CtParameterImpl][CtTypeReferenceImpl]int table, [CtParameterImpl][CtTypeReferenceImpl]int side, [CtParameterImpl][CtTypeReferenceImpl]int aimedLocation, [CtParameterImpl][CtTypeReferenceImpl]int aimingMode, [CtParameterImpl][CtTypeReferenceImpl]int cover);

    [CtMethodImpl][CtJavaDocImpl]/**
     * Rolls up a hit location
     */
    public abstract [CtTypeReferenceImpl]megamek.common.HitData rollHitLocation([CtParameterImpl][CtTypeReferenceImpl]int table, [CtParameterImpl][CtTypeReferenceImpl]int side);

    [CtMethodImpl][CtJavaDocImpl]/**
     * Gets the location that excess damage transfers to. That is, one location
     * inwards.
     */
    public abstract [CtTypeReferenceImpl]megamek.common.HitData getTransferLocation([CtParameterImpl][CtTypeReferenceImpl]megamek.common.HitData hit);

    [CtMethodImpl][CtJavaDocImpl]/**
     * int version
     */
    public [CtTypeReferenceImpl]int getTransferLocation([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtInvocationImpl]getTransferLocation([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.HitData([CtVariableReadImpl]loc)).getLocation();
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Gets the location that is destroyed recursively. That is, one location
     * outwards.
     */
    public abstract [CtTypeReferenceImpl]int getDependentLocation([CtParameterImpl][CtTypeReferenceImpl]int loc);

    [CtMethodImpl][CtJavaDocImpl]/**
     * Does this location have rear armor?
     */
    public abstract [CtTypeReferenceImpl]boolean hasRearArmor([CtParameterImpl][CtTypeReferenceImpl]int loc);

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the amount of armor in the location specified, or ARMOR_NA, or
     * ARMOR_DESTROYED. Only works on front locations.
     */
    public [CtTypeReferenceImpl]int getArmor([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getArmor([CtVariableReadImpl]loc, [CtLiteralImpl]false);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the amount of armor in the location hit, or IArmorState.ARMOR_NA,
     * or IArmorState.ARMOR_DESTROYED.
     */
    public [CtTypeReferenceImpl]int getArmor([CtParameterImpl][CtTypeReferenceImpl]megamek.common.HitData hit) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getArmor([CtInvocationImpl][CtVariableReadImpl]hit.getLocation(), [CtInvocationImpl][CtVariableReadImpl]hit.isRear());
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the amount of armor in the location specified, or
     * IArmorState.ARMOR_NA, or IArmorState.ARMOR_DESTROYED.
     */
    public [CtTypeReferenceImpl]int getArmor([CtParameterImpl][CtTypeReferenceImpl]int loc, [CtParameterImpl][CtTypeReferenceImpl]boolean rear) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]loc >= [CtFieldReadImpl][CtFieldReadImpl][CtFieldReferenceImpl]armor.length) [CtBlockImpl]{
            [CtReturnImpl]return [CtFieldReadImpl]IArmorState.ARMOR_NA;
        }
        [CtReturnImpl]return [CtInvocationImpl]getArmorForReal([CtVariableReadImpl]loc, [CtVariableReadImpl]rear);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getArmorForReal([CtParameterImpl][CtTypeReferenceImpl]int loc, [CtParameterImpl][CtTypeReferenceImpl]boolean rear) [CtBlockImpl]{
        [CtReturnImpl]return [CtArrayReadImpl][CtFieldReadImpl]armor[[CtVariableReadImpl]loc];
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getArmorForReal([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getArmorForReal([CtVariableReadImpl]loc, [CtLiteralImpl]false);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the original amount of armor in the location specified. Only
     * works on front locations.
     */
    public [CtTypeReferenceImpl]int getOArmor([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getOArmor([CtVariableReadImpl]loc, [CtLiteralImpl]false);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the original amount of armor in the location hit.
     */
    public [CtTypeReferenceImpl]int getOArmor([CtParameterImpl][CtTypeReferenceImpl]megamek.common.HitData hit) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getOArmor([CtInvocationImpl][CtVariableReadImpl]hit.getLocation(), [CtInvocationImpl][CtVariableReadImpl]hit.isRear());
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the original amount of armor in the location specified, or
     * ARMOR_NA, or ARMOR_DESTROYED.
     *
     * @param loc
     * 		the location to check.
     * @param rear
     * 		if true inspect the rear armor, else check the front.
     */
    public [CtTypeReferenceImpl]int getOArmor([CtParameterImpl][CtTypeReferenceImpl]int loc, [CtParameterImpl][CtTypeReferenceImpl]boolean rear) [CtBlockImpl]{
        [CtReturnImpl]return [CtArrayReadImpl][CtFieldReadImpl]orig_armor[[CtVariableReadImpl]loc];
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Sets the amount of armor in the location specified.
     */
    public [CtTypeReferenceImpl]void setArmor([CtParameterImpl][CtTypeReferenceImpl]int val, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.HitData hit) [CtBlockImpl]{
        [CtInvocationImpl]setArmor([CtVariableReadImpl]val, [CtInvocationImpl][CtVariableReadImpl]hit.getLocation(), [CtInvocationImpl][CtVariableReadImpl]hit.isRear());
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Sets the amount of armor in the front location specified.
     */
    public [CtTypeReferenceImpl]void setArmor([CtParameterImpl][CtTypeReferenceImpl]int val, [CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtInvocationImpl]setArmor([CtVariableReadImpl]val, [CtVariableReadImpl]loc, [CtLiteralImpl]false);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Sets the amount of armor in the location specified.
     *
     * @param val
     * 		the value of the armor (eg how many armor points)
     * @param loc
     * 		the location of the armor
     * @param rear
     * 		true iff the armor is rear mounted.
     */
    public [CtTypeReferenceImpl]void setArmor([CtParameterImpl][CtTypeReferenceImpl]int val, [CtParameterImpl][CtTypeReferenceImpl]int loc, [CtParameterImpl][CtTypeReferenceImpl]boolean rear) [CtBlockImpl]{
        [CtAssignmentImpl][CtArrayWriteImpl][CtFieldReadImpl]armor[[CtVariableReadImpl]loc] = [CtVariableReadImpl]val;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void refreshLocations() [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]armor = [CtNewArrayImpl]new [CtTypeReferenceImpl]int[[CtInvocationImpl]locations()];
        [CtAssignmentImpl][CtFieldWriteImpl]internal = [CtNewArrayImpl]new [CtTypeReferenceImpl]int[[CtInvocationImpl]locations()];
        [CtAssignmentImpl][CtFieldWriteImpl]orig_armor = [CtNewArrayImpl]new [CtTypeReferenceImpl]int[[CtInvocationImpl]locations()];
        [CtAssignmentImpl][CtFieldWriteImpl]orig_internal = [CtNewArrayImpl]new [CtTypeReferenceImpl]int[[CtInvocationImpl]locations()];
        [CtAssignmentImpl][CtFieldWriteImpl]crits = [CtNewArrayImpl]new [CtTypeReferenceImpl]megamek.common.CriticalSlot[[CtInvocationImpl]locations()][];
        [CtAssignmentImpl][CtFieldWriteImpl]exposure = [CtNewArrayImpl]new [CtTypeReferenceImpl]int[[CtInvocationImpl]locations()];
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtInvocationImpl]locations(); [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtAssignmentImpl][CtArrayWriteImpl][CtFieldReadImpl]crits[[CtVariableReadImpl]i] = [CtNewArrayImpl]new [CtTypeReferenceImpl]megamek.common.CriticalSlot[[CtInvocationImpl]getNumberOfCriticals([CtVariableReadImpl]i)];
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @return The index of the first armored location (skipping vehicle body, et. al.)
     */
    public [CtTypeReferenceImpl]int firstArmorIndex() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]0;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Initializes the armor on the unit. Sets the original and starting point
     * of the armor to the same number.
     */
    public [CtTypeReferenceImpl]void initializeArmor([CtParameterImpl][CtTypeReferenceImpl]int val, [CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtAssignmentImpl][CtArrayWriteImpl][CtFieldReadImpl]orig_armor[[CtVariableReadImpl]loc] = [CtVariableReadImpl]val;
        [CtInvocationImpl]setArmor([CtVariableReadImpl]val, [CtVariableReadImpl]loc);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the total amount of armor on the entity.
     */
    public [CtTypeReferenceImpl]int getTotalArmor() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int totalArmor = [CtLiteralImpl]0;
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtInvocationImpl]locations(); [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]getArmor([CtVariableReadImpl]i) > [CtLiteralImpl]0) [CtBlockImpl]{
                [CtOperatorAssignmentImpl][CtVariableWriteImpl]totalArmor += [CtInvocationImpl]getArmor([CtVariableReadImpl]i);
            }
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]hasRearArmor([CtVariableReadImpl]i) && [CtBinaryOperatorImpl]([CtInvocationImpl]getArmor([CtVariableReadImpl]i, [CtLiteralImpl]true) > [CtLiteralImpl]0)) [CtBlockImpl]{
                [CtOperatorAssignmentImpl][CtVariableWriteImpl]totalArmor += [CtInvocationImpl]getArmor([CtVariableReadImpl]i, [CtLiteralImpl]true);
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]totalArmor;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the total amount of armor on the entity.
     */
    public [CtTypeReferenceImpl]int getTotalOArmor() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int totalArmor = [CtLiteralImpl]0;
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtInvocationImpl]locations(); [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]getOArmor([CtVariableReadImpl]i) > [CtLiteralImpl]0) [CtBlockImpl]{
                [CtOperatorAssignmentImpl][CtVariableWriteImpl]totalArmor += [CtInvocationImpl]getOArmor([CtVariableReadImpl]i);
            }
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]hasRearArmor([CtVariableReadImpl]i) && [CtBinaryOperatorImpl]([CtInvocationImpl]getOArmor([CtVariableReadImpl]i, [CtLiteralImpl]true) > [CtLiteralImpl]0)) [CtBlockImpl]{
                [CtOperatorAssignmentImpl][CtVariableWriteImpl]totalArmor += [CtInvocationImpl]getOArmor([CtVariableReadImpl]i, [CtLiteralImpl]true);
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]totalArmor;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the percent of the armor remaining
     */
    public [CtTypeReferenceImpl]double getArmorRemainingPercent() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]getTotalOArmor() == [CtLiteralImpl]0) [CtBlockImpl]{
            [CtReturnImpl]return [CtFieldReadImpl]IArmorState.ARMOR_NA;
        }
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtInvocationImpl](([CtTypeReferenceImpl]double) (getTotalArmor())) / [CtInvocationImpl](([CtTypeReferenceImpl]double) (getTotalOArmor()));
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the amount of internal structure in the location hit.
     */
    public [CtTypeReferenceImpl]int getInternal([CtParameterImpl][CtTypeReferenceImpl]megamek.common.HitData hit) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getInternal([CtInvocationImpl][CtVariableReadImpl]hit.getLocation());
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the amount of internal structure in the location specified, or
     * ARMOR_NA, or ARMOR_DESTROYED.
     */
    public [CtTypeReferenceImpl]int getInternal([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getInternalForReal([CtVariableReadImpl]loc);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getInternalForReal([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.GunEmplacement) && [CtBinaryOperatorImpl]([CtVariableReadImpl]loc == [CtFieldReadImpl]Tank.LOC_TURRET)) [CtBlockImpl]{
            [CtReturnImpl]return [CtFieldReadImpl]Tank.LOC_TURRET;
        }
        [CtReturnImpl]return [CtArrayReadImpl][CtFieldReadImpl]internal[[CtVariableReadImpl]loc];
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the original amount of internal structure in the location hit.
     */
    public [CtTypeReferenceImpl]int getOInternal([CtParameterImpl][CtTypeReferenceImpl]megamek.common.HitData hit) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getOInternal([CtInvocationImpl][CtVariableReadImpl]hit.getLocation());
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the original amount of internal structure in the location
     * specified, or ARMOR_NA, or ARMOR_DESTROYED.
     */
    public [CtTypeReferenceImpl]int getOInternal([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtReturnImpl]return [CtArrayReadImpl][CtFieldReadImpl]orig_internal[[CtVariableReadImpl]loc];
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Sets the amount of armor in the location specified.
     */
    public [CtTypeReferenceImpl]void setInternal([CtParameterImpl][CtTypeReferenceImpl]int val, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.HitData hit) [CtBlockImpl]{
        [CtInvocationImpl]setInternal([CtVariableReadImpl]val, [CtInvocationImpl][CtVariableReadImpl]hit.getLocation());
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Sets the amount of armor in the location specified.
     */
    public [CtTypeReferenceImpl]void setInternal([CtParameterImpl][CtTypeReferenceImpl]int val, [CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtAssignmentImpl][CtArrayWriteImpl][CtFieldReadImpl]internal[[CtVariableReadImpl]loc] = [CtVariableReadImpl]val;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Initializes the internal structure on the unit. Sets the original and
     * starting point of the internal structure to the same number.
     */
    public [CtTypeReferenceImpl]void initializeInternal([CtParameterImpl][CtTypeReferenceImpl]int val, [CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtAssignmentImpl][CtArrayWriteImpl][CtFieldReadImpl]orig_internal[[CtVariableReadImpl]loc] = [CtVariableReadImpl]val;
        [CtInvocationImpl]setInternal([CtVariableReadImpl]val, [CtVariableReadImpl]loc);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Set the internal structure to the appropriate value for the mech's weight
     * class
     */
    public abstract [CtTypeReferenceImpl]void autoSetInternal();

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the total amount of internal structure on the entity.
     */
    public [CtTypeReferenceImpl]int getTotalInternal() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int totalInternal = [CtLiteralImpl]0;
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtInvocationImpl]locations(); [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]getInternal([CtVariableReadImpl]i) > [CtLiteralImpl]0) [CtBlockImpl]{
                [CtOperatorAssignmentImpl][CtVariableWriteImpl]totalInternal += [CtInvocationImpl]getInternal([CtVariableReadImpl]i);
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]totalInternal;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the total original amount of internal structure on the entity.
     */
    public [CtTypeReferenceImpl]int getTotalOInternal() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int totalInternal = [CtLiteralImpl]0;
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtInvocationImpl]locations(); [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]getOInternal([CtVariableReadImpl]i) > [CtLiteralImpl]0) [CtBlockImpl]{
                [CtOperatorAssignmentImpl][CtVariableWriteImpl]totalInternal += [CtInvocationImpl]getOInternal([CtVariableReadImpl]i);
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]totalInternal;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the percent of the armor remaining
     */
    public [CtTypeReferenceImpl]double getInternalRemainingPercent() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtInvocationImpl](([CtTypeReferenceImpl]double) (getTotalInternal())) / [CtInvocationImpl](([CtTypeReferenceImpl]double) (getTotalOInternal()));
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Is this location destroyed or breached?
     */
    public [CtTypeReferenceImpl]boolean isLocationBad([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl]getInternal([CtVariableReadImpl]loc) == [CtFieldReadImpl]IArmorState.ARMOR_DESTROYED) || [CtBinaryOperatorImpl]([CtInvocationImpl]isLocationBlownOff([CtVariableReadImpl]loc) && [CtUnaryOperatorImpl](![CtInvocationImpl]isLocationBlownOffThisPhase([CtVariableReadImpl]loc)));
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isLocationTrulyDestroyed([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtArrayReadImpl][CtFieldReadImpl]internal[[CtVariableReadImpl]loc] == [CtFieldReadImpl]IArmorState.ARMOR_DESTROYED;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Is this location destroyed or breached?
     */
    public [CtTypeReferenceImpl]boolean isLocationDoomed([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl]getInternal([CtVariableReadImpl]loc) == [CtFieldReadImpl]IArmorState.ARMOR_DOOMED) || [CtInvocationImpl]isLocationBlownOff([CtVariableReadImpl]loc);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * returns exposure or breached flag for location
     */
    public [CtTypeReferenceImpl]int getLocationStatus([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtReturnImpl]return [CtArrayReadImpl][CtFieldReadImpl]exposure[[CtVariableReadImpl]loc];
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * sets location exposure
     *
     * @param loc
     * 		the location who's exposure is to be set
     * @param status
     * 		the status to set
     */
    public [CtTypeReferenceImpl]void setLocationStatus([CtParameterImpl][CtTypeReferenceImpl]int loc, [CtParameterImpl][CtTypeReferenceImpl]int status) [CtBlockImpl]{
        [CtInvocationImpl]setLocationStatus([CtVariableReadImpl]loc, [CtVariableReadImpl]status, [CtLiteralImpl]false);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * sets location exposure
     *
     * @param loc
     * 		the location who's exposure is to be set
     * @param status
     * 		the status to set
     * @param allowChange
     * 		allow change of breached locations
     */
    public [CtTypeReferenceImpl]void setLocationStatus([CtParameterImpl][CtTypeReferenceImpl]int loc, [CtParameterImpl][CtTypeReferenceImpl]int status, [CtParameterImpl][CtTypeReferenceImpl]boolean allowChange) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]allowChange || [CtBinaryOperatorImpl]([CtArrayReadImpl][CtFieldReadImpl]exposure[[CtVariableReadImpl]loc] > [CtFieldReadImpl]ILocationExposureStatus.BREACHED)) [CtBlockImpl]{
            [CtAssignmentImpl][CtCommentImpl]// can't change BREACHED status
            [CtArrayWriteImpl][CtFieldReadImpl]exposure[[CtVariableReadImpl]loc] = [CtVariableReadImpl]status;
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns true is the location is a leg
     *
     * @param loc
     * 		the location to check.
     */
    public [CtTypeReferenceImpl]boolean locationIsLeg([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns a string representing the armor in the location
     */
    public [CtTypeReferenceImpl]java.lang.String getArmorString([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getArmorString([CtVariableReadImpl]loc, [CtLiteralImpl]false);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns a string representing the armor in the location
     */
    public [CtTypeReferenceImpl]java.lang.String getArmorString([CtParameterImpl][CtTypeReferenceImpl]int loc, [CtParameterImpl][CtTypeReferenceImpl]boolean rear) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtTypeAccessImpl]megamek.common.Entity.armorStringFor([CtInvocationImpl]getArmor([CtVariableReadImpl]loc, [CtVariableReadImpl]rear));
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns a string representing the internal structure in the location
     */
    public [CtTypeReferenceImpl]java.lang.String getInternalString([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtTypeAccessImpl]megamek.common.Entity.armorStringFor([CtInvocationImpl]getInternal([CtVariableReadImpl]loc));
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Parses the game's internal armor representation into a human-readable
     * string.
     */
    public static [CtTypeReferenceImpl]java.lang.String armorStringFor([CtParameterImpl][CtTypeReferenceImpl]int value) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]value == [CtFieldReadImpl]IArmorState.ARMOR_NA) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"N/A";
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]value == [CtFieldReadImpl]IArmorState.ARMOR_DOOMED) || [CtBinaryOperatorImpl]([CtVariableReadImpl]value == [CtFieldReadImpl]IArmorState.ARMOR_DESTROYED)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"***";
        } else [CtBlockImpl]{
            [CtReturnImpl]return [CtInvocationImpl][CtTypeAccessImpl]java.lang.Integer.toString([CtVariableReadImpl]value);
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the modifier to weapons fire due to heat.
     */
    public [CtTypeReferenceImpl]int getHeatFiringModifier() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int mod = [CtLiteralImpl]0;
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]heat >= [CtLiteralImpl]8) [CtBlockImpl]{
            [CtUnaryOperatorImpl][CtVariableWriteImpl]mod++;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]heat >= [CtLiteralImpl]13) [CtBlockImpl]{
            [CtUnaryOperatorImpl][CtVariableWriteImpl]mod++;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]heat >= [CtLiteralImpl]17) [CtBlockImpl]{
            [CtUnaryOperatorImpl][CtVariableWriteImpl]mod++;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]heat >= [CtLiteralImpl]24) [CtBlockImpl]{
            [CtUnaryOperatorImpl][CtVariableWriteImpl]mod++;
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]boolean mtHeat = [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVCOMBAT_TACOPS_HEAT);
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]mtHeat && [CtBinaryOperatorImpl]([CtFieldReadImpl]heat >= [CtLiteralImpl]33)) [CtBlockImpl]{
            [CtUnaryOperatorImpl][CtVariableWriteImpl]mod++;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]mtHeat && [CtBinaryOperatorImpl]([CtFieldReadImpl]heat >= [CtLiteralImpl]41)) [CtBlockImpl]{
            [CtUnaryOperatorImpl][CtVariableWriteImpl]mod++;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]mtHeat && [CtBinaryOperatorImpl]([CtFieldReadImpl]heat >= [CtLiteralImpl]48)) [CtBlockImpl]{
            [CtUnaryOperatorImpl][CtVariableWriteImpl]mod++;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]mod > [CtLiteralImpl]0) && [CtBinaryOperatorImpl]([CtInvocationImpl]getCrew() != [CtLiteralImpl]null)) && [CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.UNOFF_SOME_LIKE_IT_HOT)) [CtBlockImpl]{
            [CtUnaryOperatorImpl][CtVariableWriteImpl]mod--;
        }
        [CtReturnImpl]return [CtVariableReadImpl]mod;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Creates a new mount for this equipment and adds it in.
     */
    public [CtTypeReferenceImpl]megamek.common.Mounted addEquipment([CtParameterImpl][CtTypeReferenceImpl]megamek.common.EquipmentType etype, [CtParameterImpl][CtTypeReferenceImpl]int loc) throws [CtTypeReferenceImpl]megamek.common.LocationFullException [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]addEquipment([CtVariableReadImpl]etype, [CtVariableReadImpl]loc, [CtLiteralImpl]false);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Creates a new mount for this equipment and adds it in.
     */
    public [CtTypeReferenceImpl]megamek.common.Mounted addEquipment([CtParameterImpl][CtTypeReferenceImpl]megamek.common.EquipmentType etype, [CtParameterImpl][CtTypeReferenceImpl]int loc, [CtParameterImpl][CtTypeReferenceImpl]boolean rearMounted) throws [CtTypeReferenceImpl]megamek.common.LocationFullException [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]addEquipment([CtVariableReadImpl]etype, [CtVariableReadImpl]loc, [CtVariableReadImpl]rearMounted, [CtTypeAccessImpl]BattleArmor.MOUNT_LOC_NONE, [CtLiteralImpl]false, [CtLiteralImpl]false, [CtLiteralImpl]false, [CtLiteralImpl]false, [CtLiteralImpl]false);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Creates a new mount for this equipment and adds it in.
     */
    public [CtTypeReferenceImpl]megamek.common.Mounted addEquipment([CtParameterImpl][CtTypeReferenceImpl]megamek.common.EquipmentType etype, [CtParameterImpl][CtTypeReferenceImpl]int loc, [CtParameterImpl][CtTypeReferenceImpl]boolean rearMounted, [CtParameterImpl][CtTypeReferenceImpl]int baMountLoc, [CtParameterImpl][CtTypeReferenceImpl]boolean isArmored, [CtParameterImpl][CtTypeReferenceImpl]boolean isTurreted) throws [CtTypeReferenceImpl]megamek.common.LocationFullException [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]addEquipment([CtVariableReadImpl]etype, [CtVariableReadImpl]loc, [CtVariableReadImpl]rearMounted, [CtVariableReadImpl]baMountLoc, [CtVariableReadImpl]isArmored, [CtVariableReadImpl]isTurreted, [CtLiteralImpl]false, [CtLiteralImpl]false, [CtLiteralImpl]false);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]megamek.common.Mounted addEquipment([CtParameterImpl][CtTypeReferenceImpl]megamek.common.EquipmentType etype, [CtParameterImpl][CtTypeReferenceImpl]int loc, [CtParameterImpl][CtTypeReferenceImpl]boolean rearMounted, [CtParameterImpl][CtTypeReferenceImpl]int baMountLoc, [CtParameterImpl][CtTypeReferenceImpl]boolean isArmored, [CtParameterImpl][CtTypeReferenceImpl]boolean isTurreted, [CtParameterImpl][CtTypeReferenceImpl]boolean isSponsonTurreted) throws [CtTypeReferenceImpl]megamek.common.LocationFullException [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]addEquipment([CtVariableReadImpl]etype, [CtVariableReadImpl]loc, [CtVariableReadImpl]rearMounted, [CtVariableReadImpl]baMountLoc, [CtVariableReadImpl]isArmored, [CtVariableReadImpl]isTurreted, [CtVariableReadImpl]isSponsonTurreted, [CtLiteralImpl]false, [CtLiteralImpl]false);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]megamek.common.Mounted addEquipment([CtParameterImpl][CtTypeReferenceImpl]megamek.common.EquipmentType etype, [CtParameterImpl][CtTypeReferenceImpl]int loc, [CtParameterImpl][CtTypeReferenceImpl]boolean rearMounted, [CtParameterImpl][CtTypeReferenceImpl]int baMountLoc, [CtParameterImpl][CtTypeReferenceImpl]boolean isArmored, [CtParameterImpl][CtTypeReferenceImpl]boolean isTurreted, [CtParameterImpl][CtTypeReferenceImpl]boolean isSponsonTurreted, [CtParameterImpl][CtTypeReferenceImpl]boolean isPintleTurreted) throws [CtTypeReferenceImpl]megamek.common.LocationFullException [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]addEquipment([CtVariableReadImpl]etype, [CtVariableReadImpl]loc, [CtVariableReadImpl]rearMounted, [CtVariableReadImpl]baMountLoc, [CtVariableReadImpl]isArmored, [CtVariableReadImpl]isTurreted, [CtVariableReadImpl]isSponsonTurreted, [CtVariableReadImpl]isPintleTurreted, [CtLiteralImpl]false);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]megamek.common.Mounted addEquipment([CtParameterImpl][CtTypeReferenceImpl]megamek.common.EquipmentType etype, [CtParameterImpl][CtTypeReferenceImpl]int loc, [CtParameterImpl][CtTypeReferenceImpl]boolean rearMounted, [CtParameterImpl][CtTypeReferenceImpl]int baMountLoc, [CtParameterImpl][CtTypeReferenceImpl]boolean isArmored, [CtParameterImpl][CtTypeReferenceImpl]boolean isTurreted, [CtParameterImpl][CtTypeReferenceImpl]boolean isSponsonTurreted, [CtParameterImpl][CtTypeReferenceImpl]boolean isPintleTurreted, [CtParameterImpl][CtTypeReferenceImpl]boolean isOmniPodded) throws [CtTypeReferenceImpl]megamek.common.LocationFullException [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.Mounted([CtThisAccessImpl]this, [CtVariableReadImpl]etype);
        [CtInvocationImpl][CtVariableReadImpl]mounted.setArmored([CtVariableReadImpl]isArmored);
        [CtInvocationImpl][CtVariableReadImpl]mounted.setBaMountLoc([CtVariableReadImpl]baMountLoc);
        [CtInvocationImpl][CtVariableReadImpl]mounted.setMechTurretMounted([CtVariableReadImpl]isTurreted);
        [CtInvocationImpl][CtVariableReadImpl]mounted.setSponsonTurretMounted([CtVariableReadImpl]isSponsonTurreted);
        [CtInvocationImpl][CtVariableReadImpl]mounted.setPintleTurretMounted([CtVariableReadImpl]isPintleTurreted);
        [CtInvocationImpl][CtVariableReadImpl]mounted.setOmniPodMounted([CtVariableReadImpl]isOmniPodded);
        [CtInvocationImpl]addEquipment([CtVariableReadImpl]mounted, [CtVariableReadImpl]loc, [CtVariableReadImpl]rearMounted);
        [CtReturnImpl]return [CtVariableReadImpl]mounted;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * mounting weapons needs to take account of ammo
     *
     * @param etype
     * @param loc
     * @param rearMounted
     * @param nAmmo
     * @return  * @throws LocationFullException
     */
    public [CtTypeReferenceImpl]megamek.common.Mounted addEquipment([CtParameterImpl][CtTypeReferenceImpl]megamek.common.EquipmentType etype, [CtParameterImpl][CtTypeReferenceImpl]int loc, [CtParameterImpl][CtTypeReferenceImpl]boolean rearMounted, [CtParameterImpl][CtTypeReferenceImpl]int nAmmo) throws [CtTypeReferenceImpl]megamek.common.LocationFullException [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.Mounted([CtThisAccessImpl]this, [CtVariableReadImpl]etype);
        [CtInvocationImpl]addEquipment([CtVariableReadImpl]mounted, [CtVariableReadImpl]loc, [CtVariableReadImpl]rearMounted, [CtVariableReadImpl]nAmmo);
        [CtReturnImpl]return [CtVariableReadImpl]mounted;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * indicate whether this is a bomb mount
     */
    public [CtTypeReferenceImpl]megamek.common.Mounted addBomb([CtParameterImpl][CtTypeReferenceImpl]megamek.common.EquipmentType etype, [CtParameterImpl][CtTypeReferenceImpl]int loc) throws [CtTypeReferenceImpl]megamek.common.LocationFullException [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.Mounted([CtThisAccessImpl]this, [CtVariableReadImpl]etype);
        [CtInvocationImpl]addBomb([CtVariableReadImpl]mounted, [CtVariableReadImpl]loc);
        [CtReturnImpl]return [CtVariableReadImpl]mounted;
    }

    [CtMethodImpl]protected [CtTypeReferenceImpl]void addBomb([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted, [CtParameterImpl][CtTypeReferenceImpl]int loc) throws [CtTypeReferenceImpl]megamek.common.LocationFullException [CtBlockImpl]{
        [CtInvocationImpl][CtVariableReadImpl]mounted.setBombMounted([CtLiteralImpl]true);
        [CtInvocationImpl]addEquipment([CtVariableReadImpl]mounted, [CtVariableReadImpl]loc, [CtLiteralImpl]false);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]megamek.common.Mounted addWeaponGroup([CtParameterImpl][CtTypeReferenceImpl]megamek.common.EquipmentType etype, [CtParameterImpl][CtTypeReferenceImpl]int loc) throws [CtTypeReferenceImpl]megamek.common.LocationFullException [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.Mounted([CtThisAccessImpl]this, [CtVariableReadImpl]etype);
        [CtInvocationImpl]addEquipment([CtVariableReadImpl]mounted, [CtVariableReadImpl]loc, [CtLiteralImpl]false, [CtLiteralImpl]true);
        [CtReturnImpl]return [CtVariableReadImpl]mounted;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * indicate whether this is bodymounted for BAs
     */
    public [CtTypeReferenceImpl]megamek.common.Mounted addEquipment([CtParameterImpl][CtTypeReferenceImpl]megamek.common.EquipmentType etype, [CtParameterImpl][CtTypeReferenceImpl]int loc, [CtParameterImpl][CtTypeReferenceImpl]boolean rearMounted, [CtParameterImpl][CtTypeReferenceImpl]int baMountLoc, [CtParameterImpl][CtTypeReferenceImpl]boolean dwpMounted) throws [CtTypeReferenceImpl]megamek.common.LocationFullException [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.Mounted([CtThisAccessImpl]this, [CtVariableReadImpl]etype);
        [CtInvocationImpl][CtVariableReadImpl]mounted.setBaMountLoc([CtVariableReadImpl]baMountLoc);
        [CtInvocationImpl][CtVariableReadImpl]mounted.setDWPMounted([CtVariableReadImpl]dwpMounted);
        [CtInvocationImpl]addEquipment([CtVariableReadImpl]mounted, [CtVariableReadImpl]loc, [CtVariableReadImpl]rearMounted);
        [CtReturnImpl]return [CtVariableReadImpl]mounted;
    }

    [CtMethodImpl]protected [CtTypeReferenceImpl]void addEquipment([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted, [CtParameterImpl][CtTypeReferenceImpl]int loc, [CtParameterImpl][CtTypeReferenceImpl]boolean rearMounted, [CtParameterImpl][CtTypeReferenceImpl]int nAmmo) throws [CtTypeReferenceImpl]megamek.common.LocationFullException [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]mounted.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.AmmoType) && [CtBinaryOperatorImpl]([CtVariableReadImpl]nAmmo > [CtLiteralImpl]1)) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]mounted.setByShot([CtLiteralImpl]true);
            [CtInvocationImpl][CtVariableReadImpl]mounted.setShotsLeft([CtVariableReadImpl]nAmmo);
            [CtInvocationImpl][CtVariableReadImpl]mounted.setOriginalShots([CtVariableReadImpl]nAmmo);
            [CtLocalVariableImpl][CtTypeReferenceImpl]double tonnage = [CtBinaryOperatorImpl][CtInvocationImpl][CtTypeAccessImpl]java.lang.Math.max([CtLiteralImpl]1, [CtBinaryOperatorImpl][CtVariableReadImpl]nAmmo / [CtInvocationImpl][CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.AmmoType) ([CtVariableReadImpl]mounted.getType())).getShots()) * [CtInvocationImpl][CtVariableReadImpl]mounted.getTonnage();
            [CtInvocationImpl][CtVariableReadImpl]mounted.setAmmoCapacity([CtVariableReadImpl]tonnage);
        }
        [CtInvocationImpl]addEquipment([CtVariableReadImpl]mounted, [CtVariableReadImpl]loc, [CtVariableReadImpl]rearMounted);
    }

    [CtMethodImpl]protected [CtTypeReferenceImpl]void addEquipment([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted, [CtParameterImpl][CtTypeReferenceImpl]int loc, [CtParameterImpl][CtTypeReferenceImpl]boolean rearMounted, [CtParameterImpl][CtTypeReferenceImpl]boolean isWeaponGroup) throws [CtTypeReferenceImpl]megamek.common.LocationFullException [CtBlockImpl]{
        [CtInvocationImpl][CtVariableReadImpl]mounted.setWeaponGroup([CtLiteralImpl]true);
        [CtInvocationImpl]addEquipment([CtVariableReadImpl]mounted, [CtVariableReadImpl]loc, [CtVariableReadImpl]rearMounted);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void addEquipment([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted, [CtParameterImpl][CtTypeReferenceImpl]int loc, [CtParameterImpl][CtTypeReferenceImpl]boolean rearMounted) throws [CtTypeReferenceImpl]megamek.common.LocationFullException [CtBlockImpl]{
        [CtInvocationImpl][CtVariableReadImpl]mounted.setLocation([CtVariableReadImpl]loc, [CtVariableReadImpl]rearMounted);
        [CtInvocationImpl][CtFieldReadImpl]equipmentList.add([CtVariableReadImpl]mounted);
        [CtInvocationImpl][CtFieldReadImpl]compositeTechLevel.addComponent([CtInvocationImpl][CtVariableReadImpl]mounted.getType());
        [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]mounted.isArmored()) [CtBlockImpl]{
            [CtInvocationImpl][CtFieldReadImpl]compositeTechLevel.addComponent([CtFieldReadImpl]megamek.common.Entity.TA_ARMORED_COMPONENT);
        }
        [CtIfImpl][CtCommentImpl]// add it to the proper sub-list
        if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.WeaponType) [CtBlockImpl]{
            [CtInvocationImpl][CtFieldReadImpl]totalWeaponList.add([CtVariableReadImpl]mounted);
            [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]mounted.isWeaponGroup()) [CtBlockImpl]{
                [CtInvocationImpl][CtFieldReadImpl]weaponGroupList.add([CtVariableReadImpl]mounted);
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.bayweapons.BayWeapon) [CtBlockImpl]{
                [CtInvocationImpl][CtFieldReadImpl]weaponBayList.add([CtVariableReadImpl]mounted);
            } else [CtBlockImpl]{
                [CtInvocationImpl][CtFieldReadImpl]weaponList.add([CtVariableReadImpl]mounted);
            }
            [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getType().hasFlag([CtTypeAccessImpl]WeaponType.F_ARTILLERY)) [CtBlockImpl]{
                [CtInvocationImpl][CtFieldReadImpl]aTracker.addWeapon([CtVariableReadImpl]mounted);
            }
            [CtIfImpl][CtCommentImpl]// one-shot launchers need their single shot of ammo added.
            if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getType().hasFlag([CtTypeAccessImpl]WeaponType.F_ONESHOT) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtTypeAccessImpl]megamek.common.AmmoType.getOneshotAmmo([CtVariableReadImpl]mounted) != [CtLiteralImpl]null)) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.Mounted([CtThisAccessImpl]this, [CtInvocationImpl][CtTypeAccessImpl]megamek.common.AmmoType.getOneshotAmmo([CtVariableReadImpl]mounted));
                [CtInvocationImpl][CtVariableReadImpl]m.setOmniPodMounted([CtInvocationImpl][CtVariableReadImpl]mounted.isOmniPodMounted());
                [CtLocalVariableImpl][CtTypeReferenceImpl]int shots = [CtLiteralImpl]1;
                [CtIfImpl][CtCommentImpl]// BA pop-up mines can be fired individually and need a shot for each launcher in the squad.
                if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getType().hasFlag([CtTypeAccessImpl]WeaponType.F_BA_INDIVIDUAL)) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]shots = [CtInvocationImpl]getTotalInternal();
                }
                [CtInvocationImpl][CtVariableReadImpl]m.setShotsLeft([CtVariableReadImpl]shots);
                [CtInvocationImpl][CtVariableReadImpl]mounted.setLinked([CtVariableReadImpl]m);
                [CtInvocationImpl][CtCommentImpl]// Oneshot ammo will be identified by having a location
                [CtCommentImpl]// of null. Other areas in the code will rely on this.
                addEquipment([CtVariableReadImpl]m, [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]LOC_NONE, [CtLiteralImpl]false);
                [CtIfImpl][CtCommentImpl]// Fusillade gets a second round, which can be a different munition type so
                [CtCommentImpl]// need to allow for two separate mounts.
                if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getType().hasFlag([CtTypeAccessImpl]WeaponType.F_DOUBLE_ONESHOT)) [CtBlockImpl]{
                    [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m2 = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.Mounted([CtThisAccessImpl]this, [CtInvocationImpl][CtVariableReadImpl]m.getType());
                    [CtInvocationImpl][CtVariableReadImpl]m2.setOmniPodMounted([CtInvocationImpl][CtVariableReadImpl]mounted.isOmniPodMounted());
                    [CtInvocationImpl][CtVariableReadImpl]m2.setShotsLeft([CtVariableReadImpl]shots);
                    [CtInvocationImpl][CtVariableReadImpl]m.setLinked([CtVariableReadImpl]m2);
                    [CtInvocationImpl]addEquipment([CtVariableReadImpl]m2, [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]LOC_NONE, [CtLiteralImpl]false);
                }
            }
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.AmmoType) [CtBlockImpl]{
            [CtInvocationImpl][CtFieldReadImpl]ammoList.add([CtVariableReadImpl]mounted);
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.BombType) [CtBlockImpl]{
            [CtInvocationImpl][CtFieldReadImpl]bombList.add([CtVariableReadImpl]mounted);
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.MiscType) [CtBlockImpl]{
            [CtInvocationImpl][CtFieldReadImpl]miscList.add([CtVariableReadImpl]mounted);
        }
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void addFailedEquipment([CtParameterImpl][CtTypeReferenceImpl]java.lang.String s) [CtBlockImpl]{
        [CtInvocationImpl][CtFieldReadImpl]failedEquipmentList.add([CtVariableReadImpl]s);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the equipment number of the specified equipment, or -1 if
     * equipment is not present.
     */
    public [CtTypeReferenceImpl]int getEquipmentNum([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]mounted != [CtLiteralImpl]null) [CtBlockImpl]{
            [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]equipmentList.indexOf([CtVariableReadImpl]mounted);
        }
        [CtReturnImpl]return [CtUnaryOperatorImpl]-[CtLiteralImpl]1;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns an enumeration of all equipment
     */
    public [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.Mounted> getEquipment() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]equipmentList;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the equipment, specified by number
     */
    public [CtTypeReferenceImpl]megamek.common.Mounted getEquipment([CtParameterImpl][CtTypeReferenceImpl]int index) [CtBlockImpl]{
        [CtTryImpl]try [CtBlockImpl]{
            [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]equipmentList.get([CtVariableReadImpl]index);
        }[CtCatchImpl] catch ([CtCatchVariableImpl][CtTypeReferenceImpl]java.lang.IndexOutOfBoundsException ex) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]null;
        }
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]megamek.common.EquipmentType getEquipmentType([CtParameterImpl][CtTypeReferenceImpl]megamek.common.CriticalSlot cs) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]cs.getType() != [CtFieldReadImpl]CriticalSlot.TYPE_EQUIPMENT) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]null;
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m = [CtInvocationImpl][CtVariableReadImpl]cs.getMount();
        [CtReturnImpl]return [CtInvocationImpl][CtVariableReadImpl]m.getType();
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns an enumeration which contains the name of each piece of equipment
     * that failed to load.
     */
    public [CtTypeReferenceImpl]java.util.Iterator<[CtTypeReferenceImpl]java.lang.String> getFailedEquipment() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]failedEquipmentList.iterator();
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getTotalAmmoOfType([CtParameterImpl][CtTypeReferenceImpl]megamek.common.EquipmentType et) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int totalShotsLeft = [CtLiteralImpl]0;
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted amounted : [CtInvocationImpl]getAmmo()) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]amounted.getType().equals([CtVariableReadImpl]et) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]amounted.isDumping())) [CtBlockImpl]{
                [CtOperatorAssignmentImpl][CtVariableWriteImpl]totalShotsLeft += [CtInvocationImpl][CtVariableReadImpl]amounted.getUsableShotsLeft();
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]totalShotsLeft;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Determine how much ammunition (of all munition types) remains which is
     * compatible with the given ammo.
     *
     * @param et
     * 		- the <code>EquipmentType</code> of the ammo to be found. This
     * 		value may be <code>null</code>.
     * @return the <code>int</code> count of the amount of shots of all
    munitions equivalent to the given ammo type.
     */
    public [CtTypeReferenceImpl]int getTotalMunitionsOfType([CtParameterImpl][CtAnnotationImpl]@megamek.common.annotations.Nullable
    [CtTypeReferenceImpl]megamek.common.EquipmentType et) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int totalShotsLeft = [CtLiteralImpl]0;
        [CtForEachImpl][CtCommentImpl]// specifically don't count caseless munitions as being of the same type as non-caseless
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted amounted : [CtInvocationImpl]getAmmo()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]boolean amCaseless = [CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.AmmoType) ([CtVariableReadImpl]amounted.getType())).getMunitionType() == [CtFieldReadImpl]AmmoType.M_CASELESS;
            [CtLocalVariableImpl][CtTypeReferenceImpl]boolean etCaseless = [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]et != [CtLiteralImpl]null) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.AmmoType) (et)).getMunitionType() == [CtFieldReadImpl]AmmoType.M_CASELESS);
            [CtLocalVariableImpl][CtTypeReferenceImpl]boolean caselessMismatch = [CtBinaryOperatorImpl][CtVariableReadImpl]amCaseless != [CtVariableReadImpl]etCaseless;
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]amounted.getType().equals([CtVariableReadImpl]et) && [CtUnaryOperatorImpl](![CtVariableReadImpl]caselessMismatch)) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]amounted.isDumping())) [CtBlockImpl]{
                [CtOperatorAssignmentImpl][CtVariableWriteImpl]totalShotsLeft += [CtInvocationImpl][CtVariableReadImpl]amounted.getUsableShotsLeft();
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]totalShotsLeft;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the Rules.ARC that the weapon, specified by number, fires into.
     */
    public abstract [CtTypeReferenceImpl]int getWeaponArc([CtParameterImpl][CtTypeReferenceImpl]int wn);

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns true if this weapon fires into the secondary facing arc. If
     * false, assume it fires into the primary.
     */
    public abstract [CtTypeReferenceImpl]boolean isSecondaryArcWeapon([CtParameterImpl][CtTypeReferenceImpl]int weaponId);

    [CtMethodImpl]public [CtTypeReferenceImpl]java.util.Iterator<[CtTypeReferenceImpl]megamek.common.Mounted> getWeapons() [CtBlockImpl]{
        [CtIfImpl]if ([CtInvocationImpl]usesWeaponBays()) [CtBlockImpl]{
            [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]weaponBayList.iterator();
        }
        [CtIfImpl]if ([CtInvocationImpl]isCapitalFighter()) [CtBlockImpl]{
            [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]weaponGroupList.iterator();
        }
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]weaponList.iterator();
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.Mounted> getIndividualWeaponList() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]weaponList;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.Mounted> getWeaponList() [CtBlockImpl]{
        [CtIfImpl]if ([CtInvocationImpl]usesWeaponBays()) [CtBlockImpl]{
            [CtReturnImpl]return [CtFieldReadImpl]weaponBayList;
        }
        [CtIfImpl]if ([CtInvocationImpl]isCapitalFighter()) [CtBlockImpl]{
            [CtReturnImpl]return [CtFieldReadImpl]weaponGroupList;
        }
        [CtReturnImpl]return [CtFieldReadImpl]weaponList;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.util.List<[CtTypeReferenceImpl]megamek.common.Mounted> getTotalWeaponList() [CtBlockImpl]{
        [CtReturnImpl][CtCommentImpl]// return full weapon list even bay mounts and weapon groups
        return [CtFieldReadImpl]totalWeaponList;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.Mounted> getWeaponBayList() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]weaponBayList;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.Mounted> getWeaponGroupList() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]weaponGroupList;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the first ready weapon
     *
     * @return the index number of the first available weapon, or -1 if none are
    ready.
     */
    public [CtTypeReferenceImpl]int getFirstWeapon() [CtBlockImpl]{
        [CtForEachImpl][CtCommentImpl]// Now phase appropriate, since we don't really care to select weapons
        [CtCommentImpl]// we can't use during this phase... do we?
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted : [CtInvocationImpl]getWeaponList()) [CtBlockImpl]{
            [CtIfImpl][CtCommentImpl]// TAG only in the correct phase...
            if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getType().hasFlag([CtTypeAccessImpl]WeaponType.F_TAG) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtFieldReadImpl]game.getPhase() != [CtFieldReadImpl]megamek.common.IGame.Phase.PHASE_OFFBOARD)) || [CtBinaryOperatorImpl]([CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getType().hasFlag([CtTypeAccessImpl]WeaponType.F_TAG)) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtFieldReadImpl]game.getPhase() == [CtFieldReadImpl]megamek.common.IGame.Phase.PHASE_OFFBOARD))) || [CtBinaryOperatorImpl][CtCommentImpl]// No AMS, unless it's in 'weapon' mode
            ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getType().hasFlag([CtTypeAccessImpl]WeaponType.F_AMS) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]mounted.curMode().equals([CtTypeAccessImpl]Weapon.MODE_AMS_MANUAL)))) [CtBlockImpl]{
                [CtContinueImpl]continue;
            }
            [CtIfImpl][CtCommentImpl]// Artillery and Bearings-Only Capital Missiles only in the correct phase...
            if ([CtUnaryOperatorImpl]![CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getType().hasFlag([CtTypeAccessImpl]WeaponType.F_ARTILLERY) || [CtInvocationImpl][CtVariableReadImpl]mounted.isInBearingsOnlyMode()) || [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtThisAccessImpl]this.getAltitude() == [CtLiteralImpl]0) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]mounted.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.capitalweapons.CapitalMissileWeapon)))) [CtBlockImpl]{
                [CtContinueImpl]continue;
            }
            [CtIfImpl][CtCommentImpl]// No linked MGs...
            if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getType().hasFlag([CtTypeAccessImpl]WeaponType.F_MG)) [CtBlockImpl]{
                [CtIfImpl]if ([CtInvocationImpl]hasLinkedMGA([CtVariableReadImpl]mounted)) [CtBlockImpl]{
                    [CtContinueImpl]continue;
                }
            }
            [CtIfImpl][CtCommentImpl]// It must be ready to be used...
            if ([CtInvocationImpl][CtVariableReadImpl]mounted.isReady()) [CtBlockImpl]{
                [CtReturnImpl]return [CtInvocationImpl]getEquipmentNum([CtVariableReadImpl]mounted);
            }
        }
        [CtReturnImpl]return [CtUnaryOperatorImpl]-[CtLiteralImpl]1;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns true if the weapon, specified as a weapon id, is valid for the
     * current phase.
     *
     * @param weapNum
     * @return True if valid, else false
     */
    public [CtTypeReferenceImpl]boolean isWeaponValidForPhase([CtParameterImpl][CtTypeReferenceImpl]int weapNum) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]isWeaponValidForPhase([CtInvocationImpl][CtFieldReadImpl]equipmentList.get([CtVariableReadImpl]weapNum));
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns true if the weapon, specified as a <code>Mounted</code>, is
     * valid for the current phase.
     *
     * @param mounted
     * @return True if valid, else false
     */
    public [CtTypeReferenceImpl]boolean isWeaponValidForPhase([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted) [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// Start reached, now we can attempt to pick a weapon.
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]mounted != [CtLiteralImpl]null) && [CtInvocationImpl][CtVariableReadImpl]mounted.isReady()) && [CtUnaryOperatorImpl](![CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getType().hasFlag([CtTypeAccessImpl]WeaponType.F_AMS) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]mounted.curMode().equals([CtTypeAccessImpl]Weapon.MODE_AMS_ON)))) && [CtUnaryOperatorImpl](![CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getType().hasFlag([CtTypeAccessImpl]WeaponType.F_AMS) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]mounted.curMode().equals([CtTypeAccessImpl]Weapon.MODE_AMS_OFF)))) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getType().hasFlag([CtTypeAccessImpl]WeaponType.F_AMSBAY))) && [CtUnaryOperatorImpl](![CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getType().hasModes() && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]mounted.curMode().equals([CtLiteralImpl]"Point Defense")))) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]mounted.getLinked() == [CtLiteralImpl]null) || [CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getLinked().getType().hasFlag([CtTypeAccessImpl]MiscType.F_AP_MOUNT)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getLinked().getUsableShotsLeft() > [CtLiteralImpl]0))) [CtBlockImpl]{
            [CtIfImpl][CtCommentImpl]// TAG only in the correct phase...
            if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getType().hasFlag([CtTypeAccessImpl]WeaponType.F_TAG) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtFieldReadImpl]game.getPhase() != [CtFieldReadImpl]megamek.common.IGame.Phase.PHASE_OFFBOARD)) || [CtBinaryOperatorImpl]([CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getType().hasFlag([CtTypeAccessImpl]WeaponType.F_TAG)) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtFieldReadImpl]game.getPhase() == [CtFieldReadImpl]megamek.common.IGame.Phase.PHASE_OFFBOARD))) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]false;
            }
            [CtIfImpl][CtCommentImpl]// Artillery or Bearings-only missiles only in the targeting phase...
            if ([CtBinaryOperatorImpl][CtUnaryOperatorImpl](![CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getType().hasFlag([CtTypeAccessImpl]WeaponType.F_ARTILLERY) || [CtInvocationImpl][CtVariableReadImpl]mounted.isInBearingsOnlyMode()) || [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtThisAccessImpl]this.getAltitude() == [CtLiteralImpl]0) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]mounted.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.capitalweapons.CapitalMissileWeapon)))) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtFieldReadImpl]game.getPhase() == [CtFieldReadImpl]megamek.common.IGame.Phase.PHASE_TARGETING)) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]false;
            }
            [CtIfImpl][CtCommentImpl]// No Bearings-only missiles in the firing phase
            if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]mounted.isInBearingsOnlyMode() && [CtBinaryOperatorImpl]([CtInvocationImpl][CtFieldReadImpl]game.getPhase() == [CtFieldReadImpl]megamek.common.IGame.Phase.PHASE_FIRING)) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]false;
            }
            [CtIfImpl][CtCommentImpl]// No linked MGs...
            if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getType().hasFlag([CtTypeAccessImpl]WeaponType.F_MG)) [CtBlockImpl]{
                [CtIfImpl]if ([CtInvocationImpl]hasLinkedMGA([CtVariableReadImpl]mounted)) [CtBlockImpl]{
                    [CtReturnImpl]return [CtLiteralImpl]false;
                }
            }
            [CtReturnImpl]return [CtLiteralImpl]true;
        } else [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Attempts to load all weapons with ammo
     */
    public [CtTypeReferenceImpl]void loadAllWeapons() [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted : [CtInvocationImpl]getTotalWeaponList()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.WeaponType wtype = [CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.WeaponType) ([CtVariableReadImpl]mounted.getType()));
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]wtype.getAmmoType() != [CtFieldReadImpl]AmmoType.T_NA) [CtBlockImpl]{
                [CtInvocationImpl]loadWeapon([CtVariableReadImpl]mounted);
            }
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Tries to load the specified weapon with the first available ammo
     */
    public [CtTypeReferenceImpl]void loadWeapon([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted) [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted mountedAmmo : [CtInvocationImpl]getAmmo()) [CtBlockImpl]{
            [CtIfImpl]if ([CtInvocationImpl]loadWeapon([CtVariableReadImpl]mounted, [CtVariableReadImpl]mountedAmmo)) [CtBlockImpl]{
                [CtBreakImpl]break;
            }
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Tries to load the specified weapon with the first available ammo of the
     * same munition type as currently in use. If this fails, use first ammo.
     *
     * If this is a weapon bay, try to load the weapon with ammo in the same bay,
     * and if it fails, load with compatible ammo in the same location.
     *
     * If this unit is part of a train, also check the vehicles directly connected
     * to it for compatible ammo
     */
    public [CtTypeReferenceImpl]void loadWeaponWithSameAmmo([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted) [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted mountedAmmo : [CtInvocationImpl]getAmmo()) [CtBlockImpl]{
            [CtIfImpl]if ([CtInvocationImpl]loadWeaponWithSameAmmo([CtVariableReadImpl]mounted, [CtVariableReadImpl]mountedAmmo)) [CtBlockImpl]{
                [CtReturnImpl]return;
            }
        }
        [CtIfImpl][CtCommentImpl]// Check the unit towing this one for ammo
        if ([CtBinaryOperatorImpl][CtInvocationImpl]getTowedBy() != [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity ahead = [CtInvocationImpl][CtFieldReadImpl]game.getEntity([CtInvocationImpl]getTowedBy());
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]ahead != [CtLiteralImpl]null) [CtBlockImpl]{
                [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted towedByAmmo : [CtInvocationImpl][CtVariableReadImpl]ahead.getAmmo()) [CtBlockImpl]{
                    [CtIfImpl]if ([CtInvocationImpl]loadWeaponWithSameAmmo([CtVariableReadImpl]mounted, [CtVariableReadImpl]towedByAmmo)) [CtBlockImpl]{
                        [CtReturnImpl]return;
                    }
                }
            }
        }
        [CtIfImpl][CtCommentImpl]// Then check the unit towed by this one for ammo
        if ([CtBinaryOperatorImpl][CtInvocationImpl]getTowing() != [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity behind = [CtInvocationImpl][CtFieldReadImpl]game.getEntity([CtInvocationImpl]getTowing());
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]behind != [CtLiteralImpl]null) [CtBlockImpl]{
                [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted towingAmmo : [CtInvocationImpl][CtVariableReadImpl]behind.getAmmo()) [CtBlockImpl]{
                    [CtIfImpl]if ([CtInvocationImpl]loadWeaponWithSameAmmo([CtVariableReadImpl]mounted, [CtVariableReadImpl]towingAmmo)) [CtBlockImpl]{
                        [CtReturnImpl]return;
                    }
                }
            }
        }
        [CtInvocationImpl][CtCommentImpl]// fall back to use any ammo
        loadWeapon([CtVariableReadImpl]mounted);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Tries to load the specified weapon with the specified ammo. Returns true
     * if successful, false otherwise.
     */
    public [CtTypeReferenceImpl]boolean loadWeapon([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.Mounted mountedAmmo) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]boolean success = [CtLiteralImpl]false;
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.WeaponType wtype = [CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.WeaponType) ([CtVariableReadImpl]mounted.getType()));
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.AmmoType atype = [CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.AmmoType) ([CtVariableReadImpl]mountedAmmo.getType()));
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]mountedAmmo.isAmmoUsable() && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]wtype.hasFlag([CtTypeAccessImpl]WeaponType.F_ONESHOT))) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]atype.getAmmoType() == [CtInvocationImpl][CtVariableReadImpl]wtype.getAmmoType())) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]atype.getRackSize() == [CtInvocationImpl][CtVariableReadImpl]wtype.getRackSize())) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]mounted.setLinked([CtVariableReadImpl]mountedAmmo);
            [CtAssignmentImpl][CtVariableWriteImpl]success = [CtLiteralImpl]true;
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]wtype.hasFlag([CtTypeAccessImpl]WeaponType.F_DOUBLE_ONESHOT) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]mountedAmmo.getLocation() == [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]LOC_NONE)) [CtBlockImpl]{
            [CtForImpl][CtCommentImpl]// Make sure this ammo is in the chain, then move it to the head.
            for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted current = [CtVariableReadImpl]mounted; [CtBinaryOperatorImpl][CtVariableReadImpl]current != [CtLiteralImpl]null; [CtAssignmentImpl][CtVariableWriteImpl]current = [CtInvocationImpl][CtVariableReadImpl]current.getLinked()) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]current == [CtVariableReadImpl]mountedAmmo) [CtBlockImpl]{
                    [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]current.getLinkedBy().setLinked([CtInvocationImpl][CtVariableReadImpl]current.getLinked());
                    [CtInvocationImpl][CtVariableReadImpl]current.setLinked([CtInvocationImpl][CtVariableReadImpl]mounted.getLinked());
                    [CtInvocationImpl][CtVariableReadImpl]mounted.setLinked([CtVariableReadImpl]current);
                    [CtReturnImpl]return [CtLiteralImpl]true;
                }
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]success;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Tries to load the specified weapon with the specified ammo. Returns true
     * if successful, false otherwise.
     */
    public [CtTypeReferenceImpl]boolean loadWeaponWithSameAmmo([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.Mounted mountedAmmo) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.AmmoType atype = [CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.AmmoType) ([CtVariableReadImpl]mountedAmmo.getType()));
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted oldammo = [CtInvocationImpl][CtVariableReadImpl]mounted.getLinked();
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]oldammo != [CtLiteralImpl]null) && [CtBinaryOperatorImpl]([CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.AmmoType) ([CtVariableReadImpl]oldammo.getType())).equals([CtVariableReadImpl]atype)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.AmmoType) ([CtVariableReadImpl]oldammo.getType())).getMunitionType() != [CtInvocationImpl][CtVariableReadImpl]atype.getMunitionType()))) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtReturnImpl]return [CtInvocationImpl]loadWeapon([CtVariableReadImpl]mounted, [CtVariableReadImpl]mountedAmmo);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks whether a weapon has been fired on this unit this turn
     *
     * @return  */
    public [CtTypeReferenceImpl]boolean weaponFired() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]boolean fired = [CtLiteralImpl]false;
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int loc = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]loc < [CtInvocationImpl]locations()) && [CtUnaryOperatorImpl](![CtVariableReadImpl]fired); [CtUnaryOperatorImpl][CtVariableWriteImpl]loc++) [CtBlockImpl]{
            [CtOperatorAssignmentImpl][CtVariableWriteImpl]fired |= [CtInvocationImpl]weaponFiredFrom([CtVariableReadImpl]loc);
        }
        [CtReturnImpl]return [CtVariableReadImpl]fired;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks whether a weapon has been fired from the specified location this
     * turn
     */
    public [CtTypeReferenceImpl]boolean weaponFiredFrom([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtForImpl][CtCommentImpl]// check critical slots for used weapons
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtInvocationImpl][CtThisAccessImpl]this.getNumberOfCriticals([CtVariableReadImpl]loc); [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.CriticalSlot slot = [CtInvocationImpl]getCritical([CtVariableReadImpl]loc, [CtVariableReadImpl]i);
            [CtIfImpl][CtCommentImpl]// ignore empty & system slots
            if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]slot == [CtLiteralImpl]null) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]slot.getType() != [CtFieldReadImpl]CriticalSlot.TYPE_EQUIPMENT)) [CtBlockImpl]{
                [CtContinueImpl]continue;
            }
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted = [CtInvocationImpl][CtVariableReadImpl]slot.getMount();
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]mounted.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.WeaponType) && [CtInvocationImpl][CtVariableReadImpl]mounted.isUsedThisRound()) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.Mounted> getAmmo() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]ammoList;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.Mounted> getMisc() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]miscList;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.util.List<[CtTypeReferenceImpl]megamek.common.Mounted> getBombs() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]bombList;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Mounted> getBombs([CtParameterImpl][CtTypeReferenceImpl]java.math.BigInteger flag) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Mounted> bombs = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Mounted>();
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted bomb : [CtInvocationImpl]getBombs()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.BombType btype = [CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.BombType) ([CtVariableReadImpl]bomb.getType()));
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]bomb.isInoperable()) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]bomb.getUsableShotsLeft() > [CtLiteralImpl]0)) && [CtInvocationImpl][CtVariableReadImpl]btype.hasFlag([CtVariableReadImpl]flag)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]bombs.add([CtVariableReadImpl]bomb);
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]bombs;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Reset bomb attacks according to what bombs are available.
     */
    protected [CtTypeReferenceImpl]void resetBombAttacks() [CtBlockImpl]{
        [CtLocalVariableImpl][CtCommentImpl]// Remove all bomb attacks
        [CtTypeReferenceImpl]java.util.List<[CtTypeReferenceImpl]megamek.common.Mounted> bombAttacksToRemove = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.ArrayList<>();
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.EquipmentType spaceBomb = [CtInvocationImpl][CtTypeAccessImpl]megamek.common.EquipmentType.get([CtTypeAccessImpl]IBomber.SPACE_BOMB_ATTACK);
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.EquipmentType altBomb = [CtInvocationImpl][CtTypeAccessImpl]megamek.common.EquipmentType.get([CtTypeAccessImpl]IBomber.ALT_BOMB_ATTACK);
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.EquipmentType diveBomb = [CtInvocationImpl][CtTypeAccessImpl]megamek.common.EquipmentType.get([CtTypeAccessImpl]IBomber.DIVE_BOMB_ATTACK);
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted eq : [CtFieldReadImpl]equipmentList) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]eq.getType().equals([CtVariableReadImpl]spaceBomb) || [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]eq.getType().equals([CtVariableReadImpl]altBomb)) || [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]eq.getType().equals([CtVariableReadImpl]diveBomb)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]bombAttacksToRemove.add([CtVariableReadImpl]eq);
            }
        }
        [CtInvocationImpl][CtFieldReadImpl]equipmentList.removeAll([CtVariableReadImpl]bombAttacksToRemove);
        [CtInvocationImpl][CtFieldReadImpl]weaponList.removeAll([CtVariableReadImpl]bombAttacksToRemove);
        [CtInvocationImpl][CtFieldReadImpl]totalWeaponList.removeAll([CtVariableReadImpl]bombAttacksToRemove);
        [CtInvocationImpl][CtFieldReadImpl]weaponGroupList.removeAll([CtVariableReadImpl]bombAttacksToRemove);
        [CtInvocationImpl][CtFieldReadImpl]weaponBayList.removeAll([CtVariableReadImpl]bombAttacksToRemove);
        [CtLocalVariableImpl][CtTypeReferenceImpl]boolean foundSpaceBomb = [CtLiteralImpl]false;
        [CtLocalVariableImpl][CtTypeReferenceImpl]int numGroundBombs = [CtLiteralImpl]0;
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getBombs()) [CtBlockImpl]{
            [CtIfImpl][CtCommentImpl]// Add the space bomb attack
            if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtUnaryOperatorImpl](![CtVariableReadImpl]foundSpaceBomb) && [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVAERORULES_STRATOPS_SPACE_BOMB)) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]AmmoType.F_SPACE_BOMB)) && [CtInvocationImpl]isFighter()) && [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().inSpace()) [CtBlockImpl]{
                [CtTryImpl]try [CtBlockImpl]{
                    [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted bomb = [CtInvocationImpl]addEquipment([CtVariableReadImpl]spaceBomb, [CtInvocationImpl][CtVariableReadImpl]m.getLocation(), [CtLiteralImpl]false);
                    [CtIfImpl]if ([CtInvocationImpl]hasETypeFlag([CtFieldReadImpl]megamek.common.Entity.ETYPE_FIGHTER_SQUADRON)) [CtBlockImpl]{
                        [CtInvocationImpl][CtVariableReadImpl]bomb.setWeaponGroup([CtLiteralImpl]true);
                        [CtInvocationImpl][CtFieldReadImpl]weaponGroupList.add([CtVariableReadImpl]bomb);
                    }
                }[CtCatchImpl] catch ([CtCatchVariableImpl][CtTypeReferenceImpl]megamek.common.LocationFullException ex) [CtBlockImpl]{
                }
                [CtAssignmentImpl][CtVariableWriteImpl]foundSpaceBomb = [CtLiteralImpl]true;
            }
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().inSpace()) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]AmmoType.F_GROUND_BOMB)) && [CtUnaryOperatorImpl](![CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.LandAirMech) && [CtBinaryOperatorImpl]([CtInvocationImpl]getConversionMode() == [CtFieldReadImpl]LandAirMech.CONV_MODE_MECH)))) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]numGroundBombs < [CtLiteralImpl]1) [CtBlockImpl]{
                    [CtTryImpl]try [CtBlockImpl]{
                        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted bomb = [CtInvocationImpl]addEquipment([CtVariableReadImpl]diveBomb, [CtInvocationImpl][CtVariableReadImpl]m.getLocation(), [CtLiteralImpl]false);
                        [CtIfImpl]if ([CtInvocationImpl]hasETypeFlag([CtFieldReadImpl]megamek.common.Entity.ETYPE_FIGHTER_SQUADRON)) [CtBlockImpl]{
                            [CtInvocationImpl][CtVariableReadImpl]bomb.setWeaponGroup([CtLiteralImpl]true);
                            [CtInvocationImpl][CtFieldReadImpl]weaponGroupList.add([CtVariableReadImpl]bomb);
                        }
                    }[CtCatchImpl] catch ([CtCatchVariableImpl][CtTypeReferenceImpl]megamek.common.LocationFullException ex) [CtBlockImpl]{
                    }
                }
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]numGroundBombs < [CtLiteralImpl]10) && [CtInvocationImpl]isFighter()) [CtBlockImpl]{
                    [CtTryImpl]try [CtBlockImpl]{
                        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted bomb = [CtInvocationImpl]addEquipment([CtVariableReadImpl]altBomb, [CtInvocationImpl][CtVariableReadImpl]m.getLocation(), [CtLiteralImpl]false);
                        [CtIfImpl]if ([CtInvocationImpl]hasETypeFlag([CtFieldReadImpl]megamek.common.Entity.ETYPE_FIGHTER_SQUADRON)) [CtBlockImpl]{
                            [CtInvocationImpl][CtVariableReadImpl]bomb.setWeaponGroup([CtLiteralImpl]true);
                            [CtInvocationImpl][CtFieldReadImpl]weaponGroupList.add([CtVariableReadImpl]bomb);
                        }
                    }[CtCatchImpl] catch ([CtCatchVariableImpl][CtTypeReferenceImpl]megamek.common.LocationFullException ex) [CtBlockImpl]{
                    }
                }
                [CtUnaryOperatorImpl][CtVariableWriteImpl]numGroundBombs++;
            }
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Removes the first misc eq. whose name equals the specified string. Used
     * for removing broken tree clubs.
     */
    public [CtTypeReferenceImpl]void removeMisc([CtParameterImpl][CtTypeReferenceImpl]java.lang.String toRemove) [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted : [CtInvocationImpl]getMisc()) [CtBlockImpl]{
            [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getName().equals([CtVariableReadImpl]toRemove)) [CtBlockImpl]{
                [CtInvocationImpl][CtFieldReadImpl]miscList.remove([CtVariableReadImpl]mounted);
                [CtInvocationImpl][CtFieldReadImpl]equipmentList.remove([CtVariableReadImpl]mounted);
                [CtBreakImpl]break;
            }
        }
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void removeWeapon([CtParameterImpl][CtTypeReferenceImpl]java.lang.String toRemove) [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted : [CtInvocationImpl]getMisc()) [CtBlockImpl]{
            [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getName().equals([CtVariableReadImpl]toRemove)) [CtBlockImpl]{
                [CtInvocationImpl][CtFieldReadImpl]weaponList.remove([CtVariableReadImpl]mounted);
                [CtInvocationImpl][CtFieldReadImpl]equipmentList.remove([CtVariableReadImpl]mounted);
                [CtBreakImpl]break;
            }
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Clear all bombs and bomb attacks
     */
    public [CtTypeReferenceImpl]void clearBombs() [CtBlockImpl]{
        [CtInvocationImpl][CtFieldReadImpl]bombList.clear();
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Iterator<[CtTypeReferenceImpl]megamek.common.Mounted> i = [CtInvocationImpl][CtFieldReadImpl]equipmentList.iterator(); [CtInvocationImpl][CtVariableReadImpl]i.hasNext();) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m = [CtInvocationImpl][CtVariableReadImpl]i.next();
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.BombType) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.DiveBombAttack)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.SpaceBombAttack)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.AltitudeBombAttack)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.bombs.ISAAAMissileWeapon)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.bombs.CLAAAMissileWeapon)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.bombs.ISASMissileWeapon)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.bombs.ISASEWMissileWeapon)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.bombs.CLASMissileWeapon)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.bombs.CLASEWMissileWeapon)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.bombs.ISLAAMissileWeapon)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.bombs.CLLAAMissileWeapon)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.bombs.BombArrowIV)) || [CtBinaryOperatorImpl][CtCommentImpl]/* || m.getType() instanceof CLBombArrowIV */
            ([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.bombs.CLBombTAG)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.bombs.ISBombTAG)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.bombs.BombISRL10)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.AlamoMissileWeapon)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]i.remove();
            }
        }
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Iterator<[CtTypeReferenceImpl]megamek.common.Mounted> i = [CtInvocationImpl][CtFieldReadImpl]weaponList.iterator(); [CtInvocationImpl][CtVariableReadImpl]i.hasNext();) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m = [CtInvocationImpl][CtVariableReadImpl]i.next();
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.DiveBombAttack) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.SpaceBombAttack)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.AltitudeBombAttack)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.bombs.ISAAAMissileWeapon)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.bombs.CLAAAMissileWeapon)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.bombs.ISASMissileWeapon)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.bombs.ISASEWMissileWeapon)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.bombs.CLASMissileWeapon)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.bombs.CLASEWMissileWeapon)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.bombs.ISLAAMissileWeapon)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.bombs.CLLAAMissileWeapon)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.bombs.BombArrowIV)) || [CtBinaryOperatorImpl][CtCommentImpl]/* || m.getType() instanceof CLBombArrowIV */
            ([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.bombs.CLBombTAG)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.bombs.ISBombTAG)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.bombs.BombISRL10)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.AlamoMissileWeapon)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]i.remove();
            }
        }
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Iterator<[CtTypeReferenceImpl]megamek.common.Mounted> i = [CtInvocationImpl][CtFieldReadImpl]ammoList.iterator(); [CtInvocationImpl][CtVariableReadImpl]i.hasNext();) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m = [CtInvocationImpl][CtVariableReadImpl]i.next();
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.BombType) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]i.remove();
            }
        }
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.util.List<[CtTypeReferenceImpl]megamek.common.Mounted> getClubs() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.List<[CtTypeReferenceImpl]megamek.common.Mounted> rv = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.Mounted>();
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getMisc()) [CtBlockImpl]{
            [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_CLUB)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]rv.add([CtVariableReadImpl]m);
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]rv;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Check if the entity has an arbitrary type of misc equipment
     *
     * @param flag
     * 		A MiscType.F_XXX
     * @return true if at least one ready item.
     */
    public [CtTypeReferenceImpl]boolean hasWorkingMisc([CtParameterImpl][CtTypeReferenceImpl]java.math.BigInteger flag) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]hasWorkingMisc([CtVariableReadImpl]flag, [CtUnaryOperatorImpl]-[CtLiteralImpl]1);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Check if the entity has an arbitrary type of misc equipment
     *
     * @param flag
     * 		A MiscType.F_XXX
     * @param secondary
     * 		A MiscType.S_XXX or -1 for don't care
     * @return true if at least one ready item.
     */
    public [CtTypeReferenceImpl]boolean hasWorkingMisc([CtParameterImpl][CtTypeReferenceImpl]java.math.BigInteger flag, [CtParameterImpl][CtTypeReferenceImpl]long secondary) [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtFieldReadImpl]miscList) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.MiscType) && [CtInvocationImpl][CtVariableReadImpl]m.isReady()) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.MiscType type = [CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.MiscType) ([CtVariableReadImpl]m.getType()));
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]type.hasFlag([CtVariableReadImpl]flag) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]secondary == [CtUnaryOperatorImpl](-[CtLiteralImpl]1)) || [CtInvocationImpl][CtVariableReadImpl]type.hasSubType([CtVariableReadImpl]secondary))) [CtBlockImpl]{
                    [CtReturnImpl]return [CtLiteralImpl]true;
                }
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean hasMisc([CtParameterImpl][CtTypeReferenceImpl]java.math.BigInteger flag) [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtFieldReadImpl]miscList) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.MiscType) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.MiscType type = [CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.MiscType) ([CtVariableReadImpl]m.getType()));
                [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]type.hasFlag([CtVariableReadImpl]flag)) [CtBlockImpl]{
                    [CtReturnImpl]return [CtLiteralImpl]true;
                }
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * return how many misc equipments with the specified flag the unit has
     *
     * @param flag
     * @return  */
    public [CtTypeReferenceImpl]int countWorkingMisc([CtParameterImpl][CtTypeReferenceImpl]java.math.BigInteger flag) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]countWorkingMisc([CtVariableReadImpl]flag, [CtUnaryOperatorImpl]-[CtLiteralImpl]1);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int countWorkingMisc([CtParameterImpl][CtTypeReferenceImpl]java.math.BigInteger flag, [CtParameterImpl][CtTypeReferenceImpl]int location) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int count = [CtLiteralImpl]0;
        [CtForEachImpl]OUTER : for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getMisc()) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]m.isInoperable()) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtVariableReadImpl]flag)) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]location == [CtUnaryOperatorImpl](-[CtLiteralImpl]1)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getLocation() == [CtVariableReadImpl]location))) [CtBlockImpl]{
                [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasModes()) [CtBlockImpl]{
                    [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Enumeration<[CtTypeReferenceImpl]megamek.common.EquipmentMode> e = [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().getModes(); [CtInvocationImpl][CtVariableReadImpl]e.hasMoreElements();) [CtBlockImpl]{
                        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]e.nextElement().equals([CtLiteralImpl]"On") && [CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"On"))) [CtBlockImpl]{
                            [CtContinueImpl]continue OUTER;
                        }
                    }
                }
                [CtUnaryOperatorImpl][CtVariableWriteImpl]count++;
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]count;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Check if the entity has an arbitrary type of misc equipment
     *
     * @param name
     * 		MiscType internal name
     * @return true if at least one ready item.
     */
    public [CtTypeReferenceImpl]boolean hasWorkingMisc([CtParameterImpl][CtTypeReferenceImpl]java.lang.String name) [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtFieldReadImpl]miscList) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.MiscType) && [CtInvocationImpl][CtVariableReadImpl]m.isReady()) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.MiscType type = [CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.MiscType) ([CtVariableReadImpl]m.getType()));
                [CtIfImpl]if ([CtInvocationImpl][CtFieldReadImpl][CtVariableReadImpl]type.internalName.equalsIgnoreCase([CtVariableReadImpl]name)) [CtBlockImpl]{
                    [CtReturnImpl]return [CtLiteralImpl]true;
                }
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Check if the entity has an arbitrary type of misc equipment
     *
     * @param flag
     * 		A MiscType.F_XXX
     * @param secondary
     * 		A MiscType.S_XXX or -1 for don't care
     * @param location
     * 		The location to check e.g. Mech.LOC_LARM
     * @return true if at least one ready item.
     */
    public [CtTypeReferenceImpl]boolean hasWorkingMisc([CtParameterImpl][CtTypeReferenceImpl]java.math.BigInteger flag, [CtParameterImpl][CtTypeReferenceImpl]long secondary, [CtParameterImpl][CtTypeReferenceImpl]int location) [CtBlockImpl]{
        [CtForImpl][CtCommentImpl]// go through the location slot by slot, because of misc equipment that
        [CtCommentImpl]// is spreadable
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]int slot = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]slot < [CtInvocationImpl]getNumberOfCriticals([CtVariableReadImpl]location); [CtUnaryOperatorImpl][CtVariableWriteImpl]slot++) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.CriticalSlot crit = [CtInvocationImpl]getCritical([CtVariableReadImpl]location, [CtVariableReadImpl]slot);
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtLiteralImpl]null != [CtVariableReadImpl]crit) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]crit.getType() == [CtFieldReadImpl]CriticalSlot.TYPE_EQUIPMENT)) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted mount = [CtInvocationImpl][CtVariableReadImpl]crit.getMount();
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]mount == [CtLiteralImpl]null) [CtBlockImpl]{
                    [CtContinueImpl]continue;
                }
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]mount.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.MiscType) && [CtInvocationImpl][CtVariableReadImpl]mount.isReady()) [CtBlockImpl]{
                    [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.MiscType type = [CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.MiscType) ([CtVariableReadImpl]mount.getType()));
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]type.hasFlag([CtVariableReadImpl]flag) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]secondary == [CtUnaryOperatorImpl](-[CtLiteralImpl]1)) || [CtInvocationImpl][CtVariableReadImpl]type.hasSubType([CtVariableReadImpl]secondary))) [CtBlockImpl]{
                        [CtReturnImpl]return [CtLiteralImpl]true;
                    }
                }
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Check if the entity has an arbitrary type of weapon
     *
     * @param flag
     * 		A WeaponType.F_XXX
     */
    public [CtTypeReferenceImpl]boolean hasWorkingWeapon([CtParameterImpl][CtTypeReferenceImpl]java.math.BigInteger flag) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]hasWorkingWeapon([CtVariableReadImpl]flag, [CtUnaryOperatorImpl]-[CtLiteralImpl]1);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Check if the entity has an arbitrary type of weapon
     *
     * @param flag
     * 		A WeaponType.F_XXX
     * @param secondary
     * 		A WeaponType.S_XXX or -1 for don't care
     * @return true if at least one ready item.
     */
    public [CtTypeReferenceImpl]boolean hasWorkingWeapon([CtParameterImpl][CtTypeReferenceImpl]java.math.BigInteger flag, [CtParameterImpl][CtTypeReferenceImpl]long secondary) [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtFieldReadImpl]weaponList) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.WeaponType) && [CtInvocationImpl][CtVariableReadImpl]m.isReady()) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.WeaponType type = [CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.WeaponType) ([CtVariableReadImpl]m.getType()));
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]type.hasFlag([CtVariableReadImpl]flag) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]secondary == [CtUnaryOperatorImpl](-[CtLiteralImpl]1)) || [CtInvocationImpl][CtVariableReadImpl]type.hasSubType([CtVariableReadImpl]secondary))) [CtBlockImpl]{
                    [CtReturnImpl]return [CtLiteralImpl]true;
                }
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Check if the entity has an arbitrary type of weapon
     *
     * @param name
     * 		internal name of the weapon.
     * @return true if at least one ready item.
     */
    public [CtTypeReferenceImpl]boolean hasWorkingWeapon([CtParameterImpl][CtTypeReferenceImpl]java.lang.String name) [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtFieldReadImpl]weaponList) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.WeaponType) && [CtInvocationImpl][CtVariableReadImpl]m.isReady()) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.WeaponType type = [CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.WeaponType) ([CtVariableReadImpl]m.getType()));
                [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]type.getInternalName().equalsIgnoreCase([CtVariableReadImpl]name)) [CtBlockImpl]{
                    [CtReturnImpl]return [CtLiteralImpl]true;
                }
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Check if the entity has an arbitrary type of weapon
     *
     * @param flag
     * 		A WeaponType.F_XXX
     * @param secondary
     * 		A WeaponType.S_XXX or -1 for don't care
     * @param location
     * 		The location to check e.g. Mech.LOC_LARM
     * @return true if at least one ready item.
     */
    public [CtTypeReferenceImpl]boolean hasWorkingWeapon([CtParameterImpl][CtTypeReferenceImpl]java.math.BigInteger flag, [CtParameterImpl][CtTypeReferenceImpl]int secondary, [CtParameterImpl][CtTypeReferenceImpl]int location) [CtBlockImpl]{
        [CtForImpl][CtCommentImpl]// go through the location slot by slot, because of misc equipment that
        [CtCommentImpl]// is spreadable
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]int slot = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]slot < [CtInvocationImpl]getNumberOfCriticals([CtVariableReadImpl]location); [CtUnaryOperatorImpl][CtVariableWriteImpl]slot++) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.CriticalSlot crit = [CtInvocationImpl]getCritical([CtVariableReadImpl]location, [CtVariableReadImpl]slot);
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtLiteralImpl]null != [CtVariableReadImpl]crit) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]crit.getType() == [CtFieldReadImpl]CriticalSlot.TYPE_EQUIPMENT)) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted mount = [CtInvocationImpl][CtVariableReadImpl]crit.getMount();
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]mount == [CtLiteralImpl]null) [CtBlockImpl]{
                    [CtContinueImpl]continue;
                }
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]mount.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.WeaponType) && [CtInvocationImpl][CtVariableReadImpl]mount.isReady()) [CtBlockImpl]{
                    [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.WeaponType type = [CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.WeaponType) ([CtVariableReadImpl]mount.getType()));
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]type.hasFlag([CtVariableReadImpl]flag) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]secondary == [CtUnaryOperatorImpl](-[CtLiteralImpl]1)) || [CtInvocationImpl][CtVariableReadImpl]type.hasSubType([CtVariableReadImpl]secondary))) [CtBlockImpl]{
                        [CtReturnImpl]return [CtLiteralImpl]true;
                    }
                }
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the amount of heat that the entity can sink each turn.
     */
    public [CtTypeReferenceImpl]int getHeatCapacity() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getHeatCapacity([CtLiteralImpl]true);
    }

    [CtMethodImpl]public abstract [CtTypeReferenceImpl]int getHeatCapacity([CtParameterImpl][CtTypeReferenceImpl]boolean radicalHeatSink);

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the amount of heat that the entity can sink each turn, factoring
     * in whether the entity is standing in water.
     */
    public abstract [CtTypeReferenceImpl]int getHeatCapacityWithWater();

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns extra heat generated by engine crits
     */
    public abstract [CtTypeReferenceImpl]int getEngineCritHeat();

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns a critical hit slot
     */
    public [CtTypeReferenceImpl]megamek.common.CriticalSlot getCritical([CtParameterImpl][CtTypeReferenceImpl]int loc, [CtParameterImpl][CtTypeReferenceImpl]int slot) [CtBlockImpl]{
        [CtReturnImpl]return [CtArrayReadImpl][CtArrayReadImpl][CtFieldReadImpl]crits[[CtVariableReadImpl]loc][[CtVariableReadImpl]slot];
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Sets a critical hit slot
     */
    public [CtTypeReferenceImpl]void setCritical([CtParameterImpl][CtTypeReferenceImpl]int loc, [CtParameterImpl][CtTypeReferenceImpl]int slot, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.CriticalSlot cs) [CtBlockImpl]{
        [CtAssignmentImpl][CtArrayWriteImpl][CtArrayReadImpl][CtFieldReadImpl]crits[[CtVariableReadImpl]loc][[CtVariableReadImpl]slot] = [CtVariableReadImpl]cs;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Adds a critical to the first available slot in the location.
     *
     * @return true if there was room for the critical
     */
    public [CtTypeReferenceImpl]boolean addCritical([CtParameterImpl][CtTypeReferenceImpl]int loc, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.CriticalSlot cs) [CtBlockImpl]{
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtInvocationImpl]getNumberOfCriticals([CtVariableReadImpl]loc); [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]getCritical([CtVariableReadImpl]loc, [CtVariableReadImpl]i) == [CtLiteralImpl]null) [CtBlockImpl]{
                [CtAssignmentImpl][CtArrayWriteImpl][CtArrayReadImpl][CtFieldReadImpl]crits[[CtVariableReadImpl]loc][[CtVariableReadImpl]i] = [CtVariableReadImpl]cs;
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;[CtCommentImpl]// no slot available :(

    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Adds a critical to a critical slot, first trying the supplied slot
     * number, and continuing from there if it's full
     *
     * @return true if there was room for the critical
     */
    public [CtTypeReferenceImpl]boolean addCritical([CtParameterImpl][CtTypeReferenceImpl]int loc, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.CriticalSlot cs, [CtParameterImpl][CtTypeReferenceImpl]int slotNumber) [CtBlockImpl]{
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtInvocationImpl]getNumberOfCriticals([CtVariableReadImpl]loc); [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]getCritical([CtVariableReadImpl]loc, [CtVariableReadImpl]slotNumber) == [CtLiteralImpl]null) [CtBlockImpl]{
                [CtAssignmentImpl][CtArrayWriteImpl][CtArrayReadImpl][CtFieldReadImpl]crits[[CtVariableReadImpl]loc][[CtVariableReadImpl]slotNumber] = [CtVariableReadImpl]cs;
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
            [CtAssignmentImpl][CtVariableWriteImpl]slotNumber = [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]slotNumber + [CtLiteralImpl]1) % [CtInvocationImpl]getNumberOfCriticals([CtVariableReadImpl]loc);
        }
        [CtReturnImpl]return [CtLiteralImpl]false;[CtCommentImpl]// no slot available :(

    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Attempts to set the given slot to the given critical. If the desired slot
     * is full, adds the critical to the first available slot.
     *
     * @return true if the crit was succesfully added to any slot
     */
    public [CtTypeReferenceImpl]boolean addCritical([CtParameterImpl][CtTypeReferenceImpl]int loc, [CtParameterImpl][CtTypeReferenceImpl]int slot, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.CriticalSlot cs) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]getCritical([CtVariableReadImpl]loc, [CtVariableReadImpl]slot) == [CtLiteralImpl]null) [CtBlockImpl]{
            [CtInvocationImpl]setCritical([CtVariableReadImpl]loc, [CtVariableReadImpl]slot, [CtVariableReadImpl]cs);
            [CtReturnImpl]return [CtLiteralImpl]true;
        }
        [CtReturnImpl]return [CtInvocationImpl]addCritical([CtVariableReadImpl]loc, [CtVariableReadImpl]cs);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Removes all matching critical slots from the location
     */
    public [CtTypeReferenceImpl]void removeCriticals([CtParameterImpl][CtTypeReferenceImpl]int loc, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.CriticalSlot cs) [CtBlockImpl]{
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtInvocationImpl]getNumberOfCriticals([CtVariableReadImpl]loc); [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl]getCritical([CtVariableReadImpl]loc, [CtVariableReadImpl]i) != [CtLiteralImpl]null) && [CtInvocationImpl][CtInvocationImpl]getCritical([CtVariableReadImpl]loc, [CtVariableReadImpl]i).equals([CtVariableReadImpl]cs)) [CtBlockImpl]{
                [CtInvocationImpl]setCritical([CtVariableReadImpl]loc, [CtVariableReadImpl]i, [CtLiteralImpl]null);
            }
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the number of empty critical slots in a location
     */
    public [CtTypeReferenceImpl]int getEmptyCriticals([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int empty = [CtLiteralImpl]0;
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtInvocationImpl]getNumberOfCriticals([CtVariableReadImpl]loc); [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]getCritical([CtVariableReadImpl]loc, [CtVariableReadImpl]i) == [CtLiteralImpl]null) [CtBlockImpl]{
                [CtUnaryOperatorImpl][CtVariableWriteImpl]empty++;
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]empty;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the number of operational critical slots remaining in a location
     */
    public [CtTypeReferenceImpl]int getHittableCriticals([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int hittable = [CtLiteralImpl]0;
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtInvocationImpl]getNumberOfCriticals([CtVariableReadImpl]loc); [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.CriticalSlot crit = [CtInvocationImpl]getCritical([CtVariableReadImpl]loc, [CtVariableReadImpl]i);
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]crit != [CtLiteralImpl]null) && [CtInvocationImpl][CtInvocationImpl]getCritical([CtVariableReadImpl]loc, [CtVariableReadImpl]i).isHittable()) [CtBlockImpl]{
                [CtUnaryOperatorImpl][CtVariableWriteImpl]hittable++;
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]crit != [CtLiteralImpl]null) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]crit.getType() == [CtFieldReadImpl]CriticalSlot.TYPE_EQUIPMENT)) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]crit.getMount() != [CtLiteralImpl]null)) && [CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]crit.getMount().getType().hasFlag([CtTypeAccessImpl]MiscType.F_REACTIVE)) && [CtBinaryOperatorImpl]([CtInvocationImpl]getArmor([CtVariableReadImpl]loc) > [CtLiteralImpl]0)) [CtBlockImpl]{
                [CtUnaryOperatorImpl][CtVariableWriteImpl]hittable++;
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]hittable;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns true if this location should transfer criticals to the next
     * location inwards. Checks to see that every critical in this location is
     * either already totally destroyed (not just hit) or was never hittable to
     * begin with.
     */
    public [CtTypeReferenceImpl]boolean canTransferCriticals([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtInvocationImpl]getNumberOfCriticals([CtVariableReadImpl]loc); [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.CriticalSlot crit = [CtInvocationImpl]getCritical([CtVariableReadImpl]loc, [CtVariableReadImpl]i);
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]crit != [CtLiteralImpl]null) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]crit.isDestroyed())) && [CtInvocationImpl][CtVariableReadImpl]crit.isEverHittable()) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]false;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]true;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Only Mechs have Gyros but this helps keep the code a bit cleaner.
     *
     * @return <code>-1</code>
     */
    public [CtTypeReferenceImpl]int getGyroType() [CtBlockImpl]{
        [CtReturnImpl]return [CtUnaryOperatorImpl]-[CtLiteralImpl]1;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Only Mechs have gyros, but this helps keep the code a bit cleaner.
     *
     * @return true if the <code>Entity</code> is a Mech and has taken enough gyro hits to destroy it
     */
    public [CtTypeReferenceImpl]boolean isGyroDestroyed() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the number of operational critical slots of the specified type in
     * the location
     */
    public [CtTypeReferenceImpl]int getGoodCriticals([CtParameterImpl][CtTypeReferenceImpl]megamek.common.CriticalSlot cs, [CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getGoodCriticals([CtInvocationImpl][CtVariableReadImpl]cs.getType(), [CtInvocationImpl][CtVariableReadImpl]cs.getIndex(), [CtVariableReadImpl]loc);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the number of operational critical slots of the specified type in
     * the location
     */
    public [CtTypeReferenceImpl]int getGoodCriticals([CtParameterImpl][CtTypeReferenceImpl]int type, [CtParameterImpl][CtTypeReferenceImpl]int index, [CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int operational = [CtLiteralImpl]0;
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m = [CtLiteralImpl]null;
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]type == [CtFieldReadImpl]CriticalSlot.TYPE_EQUIPMENT) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]m = [CtInvocationImpl]getEquipment([CtVariableReadImpl]index);
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]int numberOfCriticals = [CtInvocationImpl]getNumberOfCriticals([CtVariableReadImpl]loc);
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtVariableReadImpl]numberOfCriticals; [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.CriticalSlot ccs = [CtInvocationImpl]getCritical([CtVariableReadImpl]loc, [CtVariableReadImpl]i);
            [CtIfImpl][CtCommentImpl]// Check to see if this crit mounts the supplied item
            [CtCommentImpl]// For systems, we can compare the index, but for equipment we
            [CtCommentImpl]// need to get the Mounted that is mounted in that index and
            [CtCommentImpl]// compare types.  Superheavies may have two Mounted in each crit
            if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]ccs != [CtLiteralImpl]null) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]ccs.getType() == [CtVariableReadImpl]type)) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]ccs.isDestroyed()) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]ccs.isBreached())) [CtBlockImpl]{
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]type == [CtFieldReadImpl]CriticalSlot.TYPE_SYSTEM) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]ccs.getIndex() == [CtVariableReadImpl]index)) [CtBlockImpl]{
                        [CtUnaryOperatorImpl][CtVariableWriteImpl]operational++;
                    } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]type == [CtFieldReadImpl]CriticalSlot.TYPE_EQUIPMENT) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.equals([CtInvocationImpl][CtVariableReadImpl]ccs.getMount()) || [CtInvocationImpl][CtVariableReadImpl]m.equals([CtInvocationImpl][CtVariableReadImpl]ccs.getMount2()))) [CtBlockImpl]{
                        [CtUnaryOperatorImpl][CtVariableWriteImpl]operational++;
                    }
                }
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]operational;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * The number of critical slots that are destroyed or breached in the
     * location or missing along with it (if it was blown off).
     */
    public [CtTypeReferenceImpl]int getBadCriticals([CtParameterImpl][CtTypeReferenceImpl]int type, [CtParameterImpl][CtTypeReferenceImpl]int index, [CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int hits = [CtLiteralImpl]0;
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m = [CtLiteralImpl]null;
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]type == [CtFieldReadImpl]CriticalSlot.TYPE_EQUIPMENT) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]m = [CtInvocationImpl]getEquipment([CtVariableReadImpl]index);
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]int numberOfCriticals = [CtInvocationImpl]getNumberOfCriticals([CtVariableReadImpl]loc);
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtVariableReadImpl]numberOfCriticals; [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.CriticalSlot ccs = [CtInvocationImpl]getCritical([CtVariableReadImpl]loc, [CtVariableReadImpl]i);
            [CtIfImpl][CtCommentImpl]// Check to see if this crit mounts the supplied item
            [CtCommentImpl]// For systems, we can compare the index, but for equipment we
            [CtCommentImpl]// need to get the Mounted that is mounted in that index and
            [CtCommentImpl]// compare types.  Superheavies may have two Mounted in each crit
            if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]ccs != [CtLiteralImpl]null) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]ccs.getType() == [CtVariableReadImpl]type)) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]ccs.isDestroyed() || [CtInvocationImpl][CtVariableReadImpl]ccs.isBreached()) || [CtInvocationImpl][CtVariableReadImpl]ccs.isMissing()) [CtBlockImpl]{
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]type == [CtFieldReadImpl]CriticalSlot.TYPE_SYSTEM) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]ccs.getIndex() == [CtVariableReadImpl]index)) [CtBlockImpl]{
                        [CtUnaryOperatorImpl][CtVariableWriteImpl]hits++;
                    } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]type == [CtFieldReadImpl]CriticalSlot.TYPE_EQUIPMENT) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.equals([CtInvocationImpl][CtVariableReadImpl]ccs.getMount()) || [CtInvocationImpl][CtVariableReadImpl]m.equals([CtInvocationImpl][CtVariableReadImpl]ccs.getMount2()))) [CtBlockImpl]{
                        [CtUnaryOperatorImpl][CtVariableWriteImpl]hits++;
                    }
                }
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]hits;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Number of slots damaged (but not breached) in a location
     */
    public [CtTypeReferenceImpl]int getDamagedCriticals([CtParameterImpl][CtTypeReferenceImpl]int type, [CtParameterImpl][CtTypeReferenceImpl]int index, [CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int hits = [CtLiteralImpl]0;
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m = [CtLiteralImpl]null;
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]type == [CtFieldReadImpl]CriticalSlot.TYPE_EQUIPMENT) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]m = [CtInvocationImpl]getEquipment([CtVariableReadImpl]index);
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]int numberOfCriticals = [CtInvocationImpl]getNumberOfCriticals([CtVariableReadImpl]loc);
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtVariableReadImpl]numberOfCriticals; [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.CriticalSlot ccs = [CtInvocationImpl]getCritical([CtVariableReadImpl]loc, [CtVariableReadImpl]i);
            [CtIfImpl][CtCommentImpl]// Check to see if this crit mounts the supplied item
            [CtCommentImpl]// For systems, we can compare the index, but for equipment we
            [CtCommentImpl]// need to get the Mounted that is mounted in that index and
            [CtCommentImpl]// compare types.  Superheavies may have two Mounted in each crit
            if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]ccs != [CtLiteralImpl]null) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]ccs.getType() == [CtVariableReadImpl]type)) [CtBlockImpl]{
                [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]ccs.isDamaged()) [CtBlockImpl]{
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]type == [CtFieldReadImpl]CriticalSlot.TYPE_SYSTEM) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]ccs.getIndex() == [CtVariableReadImpl]index)) [CtBlockImpl]{
                        [CtUnaryOperatorImpl][CtVariableWriteImpl]hits++;
                    } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]type == [CtFieldReadImpl]CriticalSlot.TYPE_EQUIPMENT) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.equals([CtInvocationImpl][CtVariableReadImpl]ccs.getMount()) || [CtInvocationImpl][CtVariableReadImpl]m.equals([CtInvocationImpl][CtVariableReadImpl]ccs.getMount2()))) [CtBlockImpl]{
                        [CtUnaryOperatorImpl][CtVariableWriteImpl]hits++;
                    }
                }
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]hits;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Number of slots doomed, missing or destroyed in a location
     */
    public [CtTypeReferenceImpl]int getHitCriticals([CtParameterImpl][CtTypeReferenceImpl]int type, [CtParameterImpl][CtTypeReferenceImpl]int index, [CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int hits = [CtLiteralImpl]0;
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m = [CtLiteralImpl]null;
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]type == [CtFieldReadImpl]CriticalSlot.TYPE_EQUIPMENT) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]m = [CtInvocationImpl]getEquipment([CtVariableReadImpl]index);
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]int numberOfCriticals = [CtInvocationImpl]getNumberOfCriticals([CtVariableReadImpl]loc);
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtVariableReadImpl]numberOfCriticals; [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.CriticalSlot ccs = [CtInvocationImpl]getCritical([CtVariableReadImpl]loc, [CtVariableReadImpl]i);
            [CtIfImpl][CtCommentImpl]// Check to see if this crit mounts the supplied item
            [CtCommentImpl]// For systems, we can compare the index, but for equipment we
            [CtCommentImpl]// need to get the Mounted that is mounted in that index and
            [CtCommentImpl]// compare types.  Superheavies may have two Mounted in each crit
            if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]ccs != [CtLiteralImpl]null) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]ccs.getType() == [CtVariableReadImpl]type)) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]ccs.isDamaged() || [CtInvocationImpl][CtVariableReadImpl]ccs.isBreached()) || [CtInvocationImpl][CtVariableReadImpl]ccs.isMissing()) [CtBlockImpl]{
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]type == [CtFieldReadImpl]CriticalSlot.TYPE_SYSTEM) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]ccs.getIndex() == [CtVariableReadImpl]index)) [CtBlockImpl]{
                        [CtUnaryOperatorImpl][CtVariableWriteImpl]hits++;
                    } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]type == [CtFieldReadImpl]CriticalSlot.TYPE_EQUIPMENT) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.equals([CtInvocationImpl][CtVariableReadImpl]ccs.getMount()) || [CtInvocationImpl][CtVariableReadImpl]m.equals([CtInvocationImpl][CtVariableReadImpl]ccs.getMount2()))) [CtBlockImpl]{
                        [CtUnaryOperatorImpl][CtVariableWriteImpl]hits++;
                    }
                }
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]hits;
    }

    [CtMethodImpl]protected abstract [CtArrayTypeReferenceImpl]int[] getNoOfSlots();

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the number of total critical slots in a location
     */
    public [CtTypeReferenceImpl]int getNumberOfCriticals([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtLocalVariableImpl][CtArrayTypeReferenceImpl]int[] noOfSlots = [CtInvocationImpl]getNoOfSlots();
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtLiteralImpl]null == [CtVariableReadImpl]noOfSlots) || [CtBinaryOperatorImpl]([CtVariableReadImpl]loc >= [CtFieldReadImpl][CtVariableReadImpl]noOfSlots.length)) || [CtBinaryOperatorImpl]([CtVariableReadImpl]loc == [CtFieldReadImpl]megamek.common.Entity.LOC_NONE)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]0;
        }
        [CtReturnImpl]return [CtArrayReadImpl][CtVariableReadImpl]noOfSlots[[CtVariableReadImpl]loc];
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the number of critical slots present in the section, destroyed or
     * not.
     */
    public [CtTypeReferenceImpl]int getNumberOfCriticals([CtParameterImpl][CtTypeReferenceImpl]int type, [CtParameterImpl][CtTypeReferenceImpl]int index, [CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int num = [CtLiteralImpl]0;
        [CtLocalVariableImpl][CtTypeReferenceImpl]int numCrits = [CtInvocationImpl]getNumberOfCriticals([CtVariableReadImpl]loc);
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtVariableReadImpl]numCrits; [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.CriticalSlot ccs = [CtInvocationImpl]getCritical([CtVariableReadImpl]loc, [CtVariableReadImpl]i);
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]ccs != [CtLiteralImpl]null) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]ccs.getType() == [CtVariableReadImpl]type)) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]ccs.getIndex() == [CtVariableReadImpl]index)) [CtBlockImpl]{
                [CtUnaryOperatorImpl][CtVariableWriteImpl]num++;
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]num;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the number of critical slots present in the section, destroyed or
     * not.
     */
    public [CtTypeReferenceImpl]int getNumberOfCriticals([CtParameterImpl][CtTypeReferenceImpl]megamek.common.EquipmentType etype, [CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int num = [CtLiteralImpl]0;
        [CtLocalVariableImpl][CtTypeReferenceImpl]int numberOfCriticals = [CtInvocationImpl]getNumberOfCriticals([CtVariableReadImpl]loc);
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtVariableReadImpl]numberOfCriticals; [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.CriticalSlot ccs = [CtInvocationImpl]getCritical([CtVariableReadImpl]loc, [CtVariableReadImpl]i);
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]ccs != [CtLiteralImpl]null) && [CtBinaryOperatorImpl]([CtInvocationImpl]getEquipmentType([CtVariableReadImpl]ccs) != [CtLiteralImpl]null)) && [CtInvocationImpl][CtInvocationImpl]getEquipmentType([CtVariableReadImpl]ccs).equals([CtVariableReadImpl]etype)) [CtBlockImpl]{
                [CtUnaryOperatorImpl][CtVariableWriteImpl]num++;
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]num;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the number of critical slots present in the mech, destroyed or
     * not.
     */
    public [CtTypeReferenceImpl]int getNumberOfCriticals([CtParameterImpl][CtTypeReferenceImpl]megamek.common.EquipmentType etype) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int num = [CtLiteralImpl]0;
        [CtLocalVariableImpl][CtTypeReferenceImpl]int locations = [CtInvocationImpl]locations();
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int l = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]l < [CtVariableReadImpl]locations; [CtUnaryOperatorImpl][CtVariableWriteImpl]l++) [CtBlockImpl]{
            [CtOperatorAssignmentImpl][CtVariableWriteImpl]num += [CtInvocationImpl]getNumberOfCriticals([CtVariableReadImpl]etype, [CtVariableReadImpl]l);
        }
        [CtReturnImpl]return [CtVariableReadImpl]num;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns how many of the given equipment are present in the mech,
     * destroyed or not.
     */
    public [CtTypeReferenceImpl]int getNumberOf([CtParameterImpl][CtTypeReferenceImpl]megamek.common.EquipmentType etype) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int total = [CtLiteralImpl]0;
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtFieldReadImpl]equipmentList) [CtBlockImpl]{
            [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().equals([CtVariableReadImpl]etype)) [CtBlockImpl]{
                [CtUnaryOperatorImpl][CtVariableWriteImpl]total++;
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]total;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns true if the entity has a hip crit. Overridden by sub-classes.
     */
    public [CtTypeReferenceImpl]boolean hasHipCrit() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns true if the entity has a leg actuator crit
     */
    public [CtTypeReferenceImpl]boolean hasLegActuatorCrit() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]boolean hasCrit = [CtLiteralImpl]false;
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtInvocationImpl]locations(); [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtIfImpl]if ([CtInvocationImpl]locationIsLeg([CtVariableReadImpl]i)) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]getBadCriticals([CtTypeAccessImpl]CriticalSlot.TYPE_SYSTEM, [CtTypeAccessImpl]Mech.ACTUATOR_HIP, [CtVariableReadImpl]i) > [CtLiteralImpl]0) || [CtBinaryOperatorImpl]([CtInvocationImpl]getBadCriticals([CtTypeAccessImpl]CriticalSlot.TYPE_SYSTEM, [CtTypeAccessImpl]Mech.ACTUATOR_UPPER_LEG, [CtVariableReadImpl]i) > [CtLiteralImpl]0)) || [CtBinaryOperatorImpl]([CtInvocationImpl]getBadCriticals([CtTypeAccessImpl]CriticalSlot.TYPE_SYSTEM, [CtTypeAccessImpl]Mech.ACTUATOR_LOWER_LEG, [CtVariableReadImpl]i) > [CtLiteralImpl]0)) || [CtBinaryOperatorImpl]([CtInvocationImpl]getBadCriticals([CtTypeAccessImpl]CriticalSlot.TYPE_SYSTEM, [CtTypeAccessImpl]Mech.ACTUATOR_FOOT, [CtVariableReadImpl]i) > [CtLiteralImpl]0)) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]hasCrit = [CtLiteralImpl]true;
                    [CtBreakImpl]break;
                }
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]hasCrit;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns true if there is at least 1 functional system of the type
     * specified in the location
     */
    public [CtTypeReferenceImpl]boolean hasWorkingSystem([CtParameterImpl][CtTypeReferenceImpl]int system, [CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtInvocationImpl]getNumberOfCriticals([CtVariableReadImpl]loc); [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.CriticalSlot ccs = [CtInvocationImpl]getCritical([CtVariableReadImpl]loc, [CtVariableReadImpl]i);
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]ccs != [CtLiteralImpl]null) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]ccs.getType() == [CtFieldReadImpl]CriticalSlot.TYPE_SYSTEM)) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]ccs.getIndex() == [CtVariableReadImpl]system)) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]ccs.isDamaged())) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]ccs.isBreached())) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns false if there is at least one non-repairable critical slot for
     * this system in the given location
     */
    public [CtTypeReferenceImpl]boolean isSystemRepairable([CtParameterImpl][CtTypeReferenceImpl]int system, [CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtInvocationImpl]getNumberOfCriticals([CtVariableReadImpl]loc); [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.CriticalSlot ccs = [CtInvocationImpl]getCritical([CtVariableReadImpl]loc, [CtVariableReadImpl]i);
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]ccs != [CtLiteralImpl]null) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]ccs.getType() == [CtFieldReadImpl]CriticalSlot.TYPE_SYSTEM)) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]ccs.getIndex() == [CtVariableReadImpl]system)) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]ccs.isRepairable())) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]false;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]true;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns true if the the location has a system of the type, whether is
     * destroyed or not
     */
    public [CtTypeReferenceImpl]boolean hasSystem([CtParameterImpl][CtTypeReferenceImpl]int system, [CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtInvocationImpl]getNumberOfCriticals([CtVariableReadImpl]loc); [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.CriticalSlot ccs = [CtInvocationImpl]getCritical([CtVariableReadImpl]loc, [CtVariableReadImpl]i);
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]ccs != [CtLiteralImpl]null) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]ccs.getType() == [CtFieldReadImpl]CriticalSlot.TYPE_SYSTEM)) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]ccs.getIndex() == [CtVariableReadImpl]system)) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks to see if this entity is wielding any vibroblades
     *
     * @return always returns <code>false</code> as Only biped mechs can wield
    vibroblades
     */
    public [CtTypeReferenceImpl]boolean hasVibroblades() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks to see if any heat is given off by an active vibro blade
     *
     * @param location
     * @return always returns <code>0</code> as Only biped mechs can wield
    vibroblades
     */
    public [CtTypeReferenceImpl]int getActiveVibrobladeHeat([CtParameterImpl][CtTypeReferenceImpl]int location) [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]0;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getActiveVibrobladeHeat([CtParameterImpl][CtTypeReferenceImpl]int location, [CtParameterImpl][CtTypeReferenceImpl]boolean ignoreMode) [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]0;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Does the mech have any shields. a mech can have up to 2 shields.
     *
     * @return <code>true</code> if <code>shieldCount</code> is greater than 0
    else <code>false</code>
     */
    public [CtTypeReferenceImpl]boolean hasShield() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Check to see how many shields of a certian size a mek has. you can have
     * up to shields per mech. However they can be of different size and each
     * size has its own draw backs. So check each size and add modifers based on
     * the number shields of that size.
     */
    public [CtTypeReferenceImpl]int getNumberOfShields([CtParameterImpl][CtTypeReferenceImpl]long size) [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]0;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Does the mech have an active shield This should only be called after
     * hasShield has been called.
     */
    public [CtTypeReferenceImpl]boolean hasActiveShield([CtParameterImpl][CtTypeReferenceImpl]int location, [CtParameterImpl][CtTypeReferenceImpl]boolean rear) [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]true;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Does the mech have an active shield This should only be called by
     * hasActiveShield(location,rear)
     */
    public [CtTypeReferenceImpl]boolean hasActiveShield([CtParameterImpl][CtTypeReferenceImpl]int location) [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Does the mech have a passive shield This should only be called after
     * hasShield has been called.
     */
    public [CtTypeReferenceImpl]boolean hasPassiveShield([CtParameterImpl][CtTypeReferenceImpl]int location, [CtParameterImpl][CtTypeReferenceImpl]boolean rear) [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Does the mech have a passive shield This should only be called by
     * hasPassiveShield(location,rear)
     */
    public [CtTypeReferenceImpl]boolean hasPassiveShield([CtParameterImpl][CtTypeReferenceImpl]int location) [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Does the mech have an shield in no defense mode
     */
    public [CtTypeReferenceImpl]boolean hasNoDefenseShield([CtParameterImpl][CtTypeReferenceImpl]int location) [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * This method checks to see if a unit has Underwater Maneuvering Units
     *
     * @return <code>boolean</code> if the entity has usable UMU crits.
     */
    public [CtTypeReferenceImpl]boolean hasUMU() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtInvocationImpl]getActiveUMUCount() > [CtLiteralImpl]0;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * This counts the number of UMU's a Mech has that are still viable
     *
     * @return number <code>int</code>of useable UMU's
     */
    public [CtTypeReferenceImpl]int getActiveUMUCount() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]hasShield() && [CtBinaryOperatorImpl]([CtInvocationImpl]getNumberOfShields([CtTypeAccessImpl]MiscType.S_SHIELD_LARGE) > [CtLiteralImpl]0)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]0;
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]int count = [CtLiteralImpl]0;
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getMisc()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.EquipmentType type = [CtInvocationImpl][CtVariableReadImpl]m.getType();
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]type instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.MiscType) && [CtInvocationImpl][CtVariableReadImpl]type.hasFlag([CtTypeAccessImpl]MiscType.F_UMU)) && [CtUnaryOperatorImpl](![CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.isDestroyed() || [CtInvocationImpl][CtVariableReadImpl]m.isMissing()) || [CtInvocationImpl][CtVariableReadImpl]m.isBreached()))) [CtBlockImpl]{
                [CtUnaryOperatorImpl][CtVariableWriteImpl]count++;
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]count;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * This returns all UMU a mech has.
     *
     * @return <code>int</code>Total number of UMUs a mech has.
     */
    public [CtTypeReferenceImpl]int getAllUMUCount() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]hasShield() && [CtBinaryOperatorImpl]([CtInvocationImpl]getNumberOfShields([CtTypeAccessImpl]MiscType.S_SHIELD_LARGE) > [CtLiteralImpl]0)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]0;
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]int count = [CtLiteralImpl]0;
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getMisc()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.EquipmentType type = [CtInvocationImpl][CtVariableReadImpl]m.getType();
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]type instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.MiscType) && [CtInvocationImpl][CtVariableReadImpl]type.hasFlag([CtTypeAccessImpl]MiscType.F_UMU)) [CtBlockImpl]{
                [CtUnaryOperatorImpl][CtVariableWriteImpl]count++;
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]count;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Does the mech have a functioning ECM unit?
     */
    public [CtTypeReferenceImpl]boolean hasActiveECM() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]hasActiveECM([CtLiteralImpl]false);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * check if we have an active ECM unit for stealth armor purposes
     *
     * @param stealth
     * @return  */
    public [CtTypeReferenceImpl]boolean hasActiveECM([CtParameterImpl][CtTypeReferenceImpl]boolean stealth) [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// no ECM in space unless strat op option enabled
        if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().inSpace() && [CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVAERORULES_STRATOPS_ECM))) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl]if ([CtUnaryOperatorImpl]![CtInvocationImpl]isShutDown()) [CtBlockImpl]{
            [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getMisc()) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.EquipmentType type = [CtInvocationImpl][CtVariableReadImpl]m.getType();
                [CtIfImpl][CtCommentImpl]// EQ equipment does not count for stealth armor
                if ([CtBinaryOperatorImpl][CtVariableReadImpl]stealth && [CtInvocationImpl][CtVariableReadImpl]type.hasFlag([CtTypeAccessImpl]MiscType.F_EW_EQUIPMENT)) [CtBlockImpl]{
                    [CtContinueImpl]continue;
                }
                [CtIfImpl][CtCommentImpl]// TacOps p. 100 Angle ECM can have 1 ECM and 1 ECCM at the same
                [CtCommentImpl]// time
                if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]type instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.MiscType) && [CtInvocationImpl][CtVariableReadImpl]type.hasFlag([CtTypeAccessImpl]MiscType.F_ECM)) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"ECM") || [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"ECM & ECCM")) || [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"ECM & Ghost Targets"))) [CtBlockImpl]{
                    [CtReturnImpl]return [CtUnaryOperatorImpl]![CtInvocationImpl][CtVariableReadImpl]m.isInoperable();
                }
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Does the mech have a functioning ECM unit?
     */
    public [CtTypeReferenceImpl]boolean hasActiveAngelECM() [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// no ECM in space unless strat op option enabled
        if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().inSpace() && [CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVAERORULES_STRATOPS_ECM))) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVANCED_TACOPS_ANGEL_ECM) && [CtUnaryOperatorImpl](![CtInvocationImpl]isShutDown())) [CtBlockImpl]{
            [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getMisc()) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.EquipmentType type = [CtInvocationImpl][CtVariableReadImpl]m.getType();
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]type instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.MiscType) && [CtInvocationImpl][CtVariableReadImpl]type.hasFlag([CtTypeAccessImpl]MiscType.F_ANGEL_ECM)) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"ECM") || [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"ECM & ECCM")) || [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"ECM & Ghost Targets"))) [CtBlockImpl]{
                    [CtReturnImpl]return [CtUnaryOperatorImpl]![CtInvocationImpl][CtVariableReadImpl]m.isInoperable();
                }
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * WOR Does the mech have a functioning ECM unit?
     */
    public [CtTypeReferenceImpl]boolean hasActiveNovaECM() [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// no ECM in space unless strat op option enabled
        if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().inSpace() && [CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVAERORULES_STRATOPS_ECM))) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl]if ([CtUnaryOperatorImpl]![CtInvocationImpl]isShutDown()) [CtBlockImpl]{
            [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getMisc()) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.EquipmentType type = [CtInvocationImpl][CtVariableReadImpl]m.getType();
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]type instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.MiscType) && [CtInvocationImpl][CtVariableReadImpl]type.hasFlag([CtTypeAccessImpl]MiscType.F_NOVA)) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"ECM")) [CtBlockImpl]{
                    [CtReturnImpl]return [CtUnaryOperatorImpl]![CtInvocationImpl][CtVariableReadImpl]m.isInoperable();
                }
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Does the mech have a functioning ECM unit, tuned to ghost target
     * generation?
     */
    [CtJavaDocImpl]/**
     * Does the mech have a functioning ECM unit, tuned to ghost target
     * generation?
     */
    public [CtTypeReferenceImpl]boolean hasGhostTargets([CtParameterImpl][CtTypeReferenceImpl]boolean active) [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// no Ghost Targets in space unless strat op option enabled
        if ([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().inSpace()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl][CtCommentImpl]// if you failed your ghost target PSR, then it doesn't matter
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]active && [CtBinaryOperatorImpl]([CtInvocationImpl]getGhostTargetRollMoS() < [CtLiteralImpl]0)) || [CtInvocationImpl]isShutDown()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]boolean hasGhost = [CtLiteralImpl]false;
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getMisc()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.EquipmentType type = [CtInvocationImpl][CtVariableReadImpl]m.getType();
            [CtIfImpl][CtCommentImpl]// TacOps p. 100 Angle ECM can have ECM/ECCM and Ghost Targets at
            [CtCommentImpl]// the same time
            if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]type instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.MiscType) && [CtInvocationImpl][CtVariableReadImpl]type.hasFlag([CtTypeAccessImpl]MiscType.F_ECM)) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"Ghost Targets") || [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"ECM & Ghost Targets")) || [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"ECCM & Ghost Targets"))) && [CtUnaryOperatorImpl](![CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.isInoperable() || [CtInvocationImpl][CtInvocationImpl]getCrew().isUnconscious()))) [CtBlockImpl]{
                [CtAssignmentImpl][CtVariableWriteImpl]hasGhost = [CtLiteralImpl]true;
            }
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]type instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.MiscType) && [CtInvocationImpl][CtVariableReadImpl]type.hasFlag([CtTypeAccessImpl]MiscType.F_COMMUNICATIONS)) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"Ghost Targets")) && [CtBinaryOperatorImpl]([CtInvocationImpl]getTotalCommGearTons() >= [CtLiteralImpl]7)) && [CtUnaryOperatorImpl](![CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.isInoperable() || [CtInvocationImpl][CtInvocationImpl]getCrew().isUnconscious()))) [CtBlockImpl]{
                [CtAssignmentImpl][CtVariableWriteImpl]hasGhost = [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]hasGhost;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks to see if this entity has a functional ECM unit that is using
     * ECCM.
     *
     * @return <code>true</code> if the entity has angelecm and it is in ECCM
    mode <code>false</code> if the entity does not have angel ecm or
    it is not in eccm mode or it is damaged.
     */
    public [CtTypeReferenceImpl]boolean hasActiveECCM() [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// no ECM in space unless strat op option enabled
        if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().inSpace() && [CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVAERORULES_STRATOPS_ECM))) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVANCED_TACOPS_ECCM) || [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVAERORULES_STRATOPS_ECM)) && [CtUnaryOperatorImpl](![CtInvocationImpl]isShutDown())) [CtBlockImpl]{
            [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getMisc()) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.EquipmentType type = [CtInvocationImpl][CtVariableReadImpl]m.getType();
                [CtIfImpl][CtCommentImpl]// TacOps p. 100 Angle ECM can have 1 ECM and 1 ECCM at the same
                [CtCommentImpl]// time
                if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]type instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.MiscType) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]type.hasFlag([CtTypeAccessImpl]MiscType.F_ECM) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"ECCM") || [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"ECM & ECCM")) || [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"ECCM & Ghost Targets"))) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]type.hasFlag([CtTypeAccessImpl]MiscType.F_COMMUNICATIONS) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"ECCM")))) [CtBlockImpl]{
                    [CtReturnImpl]return [CtUnaryOperatorImpl]![CtInvocationImpl][CtVariableReadImpl]m.isInoperable();
                }
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks to see if this unit has a functional AngelECM unit that is using
     * ECCM.
     *
     * @return <code>true</code> if the entity has angelecm and it is in ECCM
    mode <code>false</code> if the entity does not have angel ecm or
    it is not in eccm mode or it is damaged.
     */
    public [CtTypeReferenceImpl]boolean hasActiveAngelECCM() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVANCED_TACOPS_ANGEL_ECM) && [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVANCED_TACOPS_ECCM)) && [CtUnaryOperatorImpl](![CtInvocationImpl]isShutDown())) [CtBlockImpl]{
            [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getMisc()) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.EquipmentType type = [CtInvocationImpl][CtVariableReadImpl]m.getType();
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]type instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.MiscType) && [CtInvocationImpl][CtVariableReadImpl]type.hasFlag([CtTypeAccessImpl]MiscType.F_ANGEL_ECM)) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"ECCM") || [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"ECM & ECCM")) || [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"ECCM & Ghost Targets"))) [CtBlockImpl]{
                    [CtReturnImpl]return [CtUnaryOperatorImpl]![CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.isDestroyed() || [CtInvocationImpl][CtVariableReadImpl]m.isMissing()) || [CtInvocationImpl][CtVariableReadImpl]m.isBreached()) || [CtInvocationImpl]isShutDown());
                }
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * What's the range of the ECM equipment? Infantry can have ECM that just
     * covers their own hex.
     *
     * @return the <code>int</code> range of this unit's ECM. This value will be
    <code>Entity.NONE</code> if no ECM is active.
     */
    public [CtTypeReferenceImpl]int getECMRange() [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// no ECM in space unless strat op option enabled
        if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().inSpace() && [CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVAERORULES_STRATOPS_ECM))) [CtBlockImpl]{
            [CtReturnImpl]return [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE;
        }
        [CtIfImpl][CtCommentImpl]// If we have stealth up and running, there's no bubble.
        if ([CtInvocationImpl]isStealthOn()) [CtBlockImpl]{
            [CtReturnImpl]return [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE;
        }
        [CtIfImpl]if ([CtUnaryOperatorImpl]![CtInvocationImpl]isShutDown()) [CtBlockImpl]{
            [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getMisc()) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.EquipmentType type = [CtInvocationImpl][CtVariableReadImpl]m.getType();
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]type instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.MiscType) && [CtInvocationImpl][CtVariableReadImpl]type.hasFlag([CtTypeAccessImpl]MiscType.F_ECM)) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]m.isInoperable())) [CtBlockImpl]{
                    [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]type.hasFlag([CtTypeAccessImpl]MiscType.F_SINGLE_HEX_ECM)) [CtBlockImpl]{
                        [CtReturnImpl]return [CtLiteralImpl]0;
                    }
                    [CtLocalVariableImpl][CtTypeReferenceImpl]int toReturn = [CtLiteralImpl]6;
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]type.hasFlag([CtTypeAccessImpl]MiscType.F_ANGEL_ECM) && [CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.BattleArmor)) [CtBlockImpl]{
                        [CtAssignmentImpl][CtVariableWriteImpl]toReturn = [CtLiteralImpl]2;
                    }
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]type.hasFlag([CtTypeAccessImpl]MiscType.F_EW_EQUIPMENT) || [CtInvocationImpl][CtVariableReadImpl]type.hasFlag([CtTypeAccessImpl]MiscType.F_NOVA)) || [CtInvocationImpl][CtVariableReadImpl]type.hasFlag([CtTypeAccessImpl]MiscType.F_WATCHDOG)) [CtBlockImpl]{
                        [CtAssignmentImpl][CtVariableWriteImpl]toReturn = [CtLiteralImpl]3;
                    }
                    [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getPlanetaryConditions().hasEMI()) [CtBlockImpl]{
                        [CtReturnImpl]return [CtBinaryOperatorImpl][CtVariableReadImpl]toReturn * [CtLiteralImpl]2;
                    }
                    [CtReturnImpl]return [CtVariableReadImpl]toReturn;
                }
            }
        }
        [CtReturnImpl]return [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Does the mech have a functioning BAP? This is just for the basic BAP for
     * Beagle BloodHound WatchDog Clan Active or Light.
     */
    public [CtTypeReferenceImpl]boolean hasBAP() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]hasBAP([CtLiteralImpl]true);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Does a unit on the same C3 network have a BAP?
     * Used to share BAP targeting bonuses against targets in woods
     *
     * @return  */
    public [CtTypeReferenceImpl]boolean hasNetworkBAP() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]networkBAP;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setNetworkBAP([CtParameterImpl][CtTypeReferenceImpl]boolean BAP) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]networkBAP = [CtVariableReadImpl]BAP;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean hasBAP([CtParameterImpl][CtTypeReferenceImpl]boolean checkECM) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtFieldReadImpl]game != [CtLiteralImpl]null) && [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getPlanetaryConditions().hasEMI()) || [CtInvocationImpl]isShutDown()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getMisc()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.EquipmentType type = [CtInvocationImpl][CtVariableReadImpl]m.getType();
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]type instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.MiscType) && [CtInvocationImpl][CtVariableReadImpl]type.hasFlag([CtTypeAccessImpl]MiscType.F_BAP)) [CtBlockImpl]{
                [CtIfImpl]if ([CtUnaryOperatorImpl]![CtInvocationImpl][CtVariableReadImpl]m.isInoperable()) [CtBlockImpl]{
                    [CtIfImpl][CtCommentImpl]// Beagle Isn't affected by normal ECM
                    if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]type.getName().equals([CtLiteralImpl]"Beagle Active Probe")) [CtBlockImpl]{
                        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtFieldReadImpl]game != [CtLiteralImpl]null) && [CtVariableReadImpl]checkECM) && [CtInvocationImpl][CtTypeAccessImpl]megamek.common.ComputeECM.isAffectedByAngelECM([CtThisAccessImpl]this, [CtInvocationImpl]getPosition(), [CtInvocationImpl]getPosition())) [CtBlockImpl]{
                            [CtReturnImpl]return [CtLiteralImpl]false;
                        }
                        [CtReturnImpl]return [CtLiteralImpl]true;
                    }
                    [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtUnaryOperatorImpl](![CtVariableReadImpl]checkECM) || [CtBinaryOperatorImpl]([CtFieldReadImpl]game == [CtLiteralImpl]null)) || [CtUnaryOperatorImpl](![CtInvocationImpl][CtTypeAccessImpl]megamek.common.ComputeECM.isAffectedByECM([CtThisAccessImpl]this, [CtInvocationImpl]getPosition(), [CtInvocationImpl]getPosition()));
                }
            }
        }
        [CtIfImpl][CtCommentImpl]// check for Manei Domini implants
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.MD_CYBER_IMP_AUDIO) || [CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.MD_CYBER_IMP_VISUAL)) || [CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.MD_MM_IMPLANTS)) && [CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Infantry)) && [CtUnaryOperatorImpl](![CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.BattleArmor))) || [CtBinaryOperatorImpl]([CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.MD_MM_IMPLANTS) && [CtBinaryOperatorImpl]([CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.MD_VDNI) || [CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.MD_BVDNI)))) [CtBlockImpl]{
            [CtReturnImpl]return [CtBinaryOperatorImpl][CtUnaryOperatorImpl](![CtVariableReadImpl]checkECM) || [CtUnaryOperatorImpl](![CtInvocationImpl][CtTypeAccessImpl]megamek.common.ComputeECM.isAffectedByECM([CtThisAccessImpl]this, [CtInvocationImpl]getPosition(), [CtInvocationImpl]getPosition()));
        }
        [CtIfImpl][CtCommentImpl]// check for quirk
        if ([CtInvocationImpl]hasQuirk([CtTypeAccessImpl]OptionsConstants.QUIRK_POS_IMPROVED_SENSORS)) [CtBlockImpl]{
            [CtReturnImpl]return [CtBinaryOperatorImpl][CtUnaryOperatorImpl](![CtVariableReadImpl]checkECM) || [CtUnaryOperatorImpl](![CtInvocationImpl][CtTypeAccessImpl]megamek.common.ComputeECM.isAffectedByECM([CtThisAccessImpl]this, [CtInvocationImpl]getPosition(), [CtInvocationImpl]getPosition()));
        }
        [CtIfImpl][CtCommentImpl]// check for SPA
        if ([CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.MISC_EAGLE_EYES)) [CtBlockImpl]{
            [CtReturnImpl]return [CtBinaryOperatorImpl][CtUnaryOperatorImpl](![CtVariableReadImpl]checkECM) || [CtUnaryOperatorImpl](![CtInvocationImpl][CtTypeAccessImpl]megamek.common.ComputeECM.isAffectedByECM([CtThisAccessImpl]this, [CtInvocationImpl]getPosition(), [CtInvocationImpl]getPosition()));
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * What's the range of the BAP equipment?
     *
     * @return the <code>int</code> range of this unit's BAP. This value will be
    <code>Entity.NONE</code> if no BAP is active.
     */
    public [CtTypeReferenceImpl]int getBAPRange() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getPlanetaryConditions().hasEMI() || [CtInvocationImpl]isShutDown()) [CtBlockImpl]{
            [CtReturnImpl]return [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE;
        }
        [CtLocalVariableImpl][CtCommentImpl]// check for Manei Domini implants
        [CtTypeReferenceImpl]int cyberBonus = [CtLiteralImpl]0;
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.MD_CYBER_IMP_AUDIO) || [CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.MD_MM_IMPLANTS)) || [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.MD_CYBER_IMP_VISUAL) && [CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Infantry)) && [CtUnaryOperatorImpl](![CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.BattleArmor)))) || [CtBinaryOperatorImpl]([CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.MD_MM_IMPLANTS) && [CtBinaryOperatorImpl]([CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.MD_VDNI) || [CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.MD_BVDNI)))) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]cyberBonus = [CtLiteralImpl]2;
        }
        [CtLocalVariableImpl][CtCommentImpl]// check for quirks
        [CtTypeReferenceImpl]int quirkBonus = [CtLiteralImpl]0;
        [CtIfImpl]if ([CtInvocationImpl]hasQuirk([CtTypeAccessImpl]OptionsConstants.QUIRK_POS_IMPROVED_SENSORS)) [CtBlockImpl]{
            [CtIfImpl]if ([CtInvocationImpl]isClan()) [CtBlockImpl]{
                [CtAssignmentImpl][CtVariableWriteImpl]quirkBonus = [CtLiteralImpl]5;
            } else [CtBlockImpl]{
                [CtAssignmentImpl][CtVariableWriteImpl]quirkBonus = [CtLiteralImpl]4;
            }
        }
        [CtLocalVariableImpl][CtCommentImpl]// check for SPA
        [CtTypeReferenceImpl]int spaBonus = [CtLiteralImpl]0;
        [CtIfImpl]if ([CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.MISC_EAGLE_EYES)) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]spaBonus = [CtLiteralImpl]1;
        }
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getMisc()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.EquipmentType type = [CtInvocationImpl][CtVariableReadImpl]m.getType();
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]type instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.MiscType) && [CtInvocationImpl][CtVariableReadImpl]type.hasFlag([CtTypeAccessImpl]MiscType.F_BAP)) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]m.isInoperable())) [CtBlockImpl]{
                [CtIfImpl][CtCommentImpl]// Quirk bonus is only 2 if equiped with BAP
                if ([CtBinaryOperatorImpl][CtVariableReadImpl]quirkBonus > [CtLiteralImpl]0) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]quirkBonus = [CtLiteralImpl]2;
                }
                [CtIfImpl][CtCommentImpl]// System.err.println("BAP type name: "+m.getName()+"
                [CtCommentImpl]// internalName: "+((MiscType)m.getType()).internalName);
                [CtCommentImpl]// in space the range of all BAPs is given by the mode
                if ([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().inSpace()) [CtBlockImpl]{
                    [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"Medium")) [CtBlockImpl]{
                        [CtReturnImpl]return [CtLiteralImpl]12;
                    }
                    [CtReturnImpl]return [CtLiteralImpl]6;
                }
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getName().equals([CtLiteralImpl]"Bloodhound Active Probe (THB)") || [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getName().equals([CtTypeAccessImpl]Sensor.BAP)) [CtBlockImpl]{
                    [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtLiteralImpl]8 + [CtVariableReadImpl]cyberBonus) + [CtVariableReadImpl]quirkBonus) + [CtVariableReadImpl]spaBonus;
                }
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().getInternalName().equals([CtTypeAccessImpl]Sensor.CLAN_AP) || [CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().getInternalName().equals([CtTypeAccessImpl]Sensor.WATCHDOG)) || [CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().getInternalName().equals([CtTypeAccessImpl]Sensor.NOVA)) [CtBlockImpl]{
                    [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtLiteralImpl]5 + [CtVariableReadImpl]cyberBonus) + [CtVariableReadImpl]quirkBonus) + [CtVariableReadImpl]spaBonus;
                }
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().getInternalName().equals([CtTypeAccessImpl]Sensor.LIGHT_AP) || [CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().getInternalName().equals([CtTypeAccessImpl]Sensor.CLBALIGHT_AP)) || [CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().getInternalName().equals([CtTypeAccessImpl]Sensor.ISBALIGHT_AP)) [CtBlockImpl]{
                    [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtLiteralImpl]3 + [CtVariableReadImpl]cyberBonus) + [CtVariableReadImpl]quirkBonus) + [CtVariableReadImpl]spaBonus;
                }
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().getInternalName().equals([CtTypeAccessImpl]Sensor.ISIMPROVED) || [CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().getInternalName().equals([CtTypeAccessImpl]Sensor.CLIMPROVED)) [CtBlockImpl]{
                    [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtLiteralImpl]2 + [CtVariableReadImpl]cyberBonus) + [CtVariableReadImpl]quirkBonus) + [CtVariableReadImpl]spaBonus;
                }
                [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtLiteralImpl]4 + [CtVariableReadImpl]cyberBonus) + [CtVariableReadImpl]quirkBonus) + [CtVariableReadImpl]spaBonus;[CtCommentImpl]// everthing else should be

                [CtCommentImpl]// range 4
            }
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]cyberBonus + [CtVariableReadImpl]quirkBonus) + [CtVariableReadImpl]spaBonus) > [CtLiteralImpl]0) [CtBlockImpl]{
            [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]cyberBonus + [CtVariableReadImpl]quirkBonus) + [CtVariableReadImpl]spaBonus;
        }
        [CtReturnImpl]return [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns wether or not this entity has a Targeting Computer.
     */
    public [CtTypeReferenceImpl]boolean hasTargComp() [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getMisc()) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.MiscType) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_TARGCOMP)) [CtBlockImpl]{
                [CtReturnImpl]return [CtUnaryOperatorImpl]![CtInvocationImpl][CtVariableReadImpl]m.isInoperable();
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns wether or not this entity has a Targeting Computer that is in
     * aimed shot mode.
     */
    public [CtTypeReferenceImpl]boolean hasAimModeTargComp() [CtBlockImpl]{
        [CtIfImpl]if ([CtInvocationImpl]hasActiveEiCockpit()) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Mech) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtThisAccessImpl](([CtTypeReferenceImpl]megamek.common.Mech) (this)).getCockpitStatus() == [CtFieldReadImpl]Mech.COCKPIT_AIMED_SHOT) [CtBlockImpl]{
                    [CtReturnImpl]return [CtLiteralImpl]true;
                }
            } else [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getMisc()) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.MiscType) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_TARGCOMP)) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"Aimed shot")) [CtBlockImpl]{
                [CtReturnImpl]return [CtUnaryOperatorImpl]![CtInvocationImpl][CtVariableReadImpl]m.isInoperable();
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns whether this 'mech has a C3 Slave or not.
     */
    public [CtTypeReferenceImpl]boolean hasC3S() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]isShutDown() || [CtInvocationImpl]isOffBoard()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getEquipment()) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.MiscType) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_C3S) || [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_C3SBS))) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]m.isInoperable())) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Only Meks can have CASE II so all other entites return false.
     *
     * @return true iff the mech has CASE II.
     */
    public [CtTypeReferenceImpl]boolean hasCASEII() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Only Meks have CASE II so all other entites return false.
     *
     * @param location
     * @return true iff the mech has CASE II at this location.
     */
    public [CtTypeReferenceImpl]boolean hasCASEII([CtParameterImpl][CtTypeReferenceImpl]int location) [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Does this entity have an undamaged HarJel system in this location?
     * (Type-dependent, defaults to false.)
     * Does not include Harjel II or Harjel III, as they do not prevent breach
     * checks like Harjel does.
     *
     * @param location
     * 		the <code>int</code> location to check
     * @return a <code>boolean</code> value indicating a present HarJel system
     */
    public [CtTypeReferenceImpl]boolean hasHarJelIn([CtParameterImpl][CtTypeReferenceImpl]int location) [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted : [CtInvocationImpl]getMisc()) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]mounted.getLocation() == [CtVariableReadImpl]location) && [CtInvocationImpl][CtVariableReadImpl]mounted.isReady()) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getType().hasFlag([CtTypeAccessImpl]MiscType.F_HARJEL)) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean hasBoostedC3() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]isShutDown() || [CtInvocationImpl]isOffBoard()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getEquipment()) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_C3SBS) || [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]WeaponType.F_C3MBS)) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]m.isInoperable())) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks if the entity has a C3 Master.
     *
     * @return true if it has a working C3M computer and has a master.
     */
    public [CtTypeReferenceImpl]boolean hasC3M() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]isShutDown() || [CtInvocationImpl]isOffBoard()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getEquipment()) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.WeaponType) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]WeaponType.F_C3M) || [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]WeaponType.F_C3MBS))) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]m.isInoperable())) [CtBlockImpl]{
                [CtIfImpl][CtCommentImpl]// If this unit is configured as a company commander,
                [CtCommentImpl]// and if this computer is the company master, then
                [CtCommentImpl]// this unit does not have a lance master computer.
                if ([CtBinaryOperatorImpl][CtInvocationImpl]C3MasterIs([CtThisAccessImpl]this) && [CtBinaryOperatorImpl]([CtFieldReadImpl]c3CompanyMasterIndex == [CtInvocationImpl]getEquipmentNum([CtVariableReadImpl]m))) [CtBlockImpl]{
                    [CtReturnImpl]return [CtLiteralImpl]false;
                }
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean hasC3MM() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]isShutDown() || [CtInvocationImpl]isOffBoard()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl][CtCommentImpl]// Have we already determined that there's no company command master?
        if ([CtBinaryOperatorImpl][CtFieldReadImpl]c3CompanyMasterIndex == [CtFieldReadImpl]megamek.common.Entity.LOC_NONE) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl][CtCommentImpl]// Do we need to determine that there's no company command master?
        if ([CtBinaryOperatorImpl][CtFieldReadImpl]c3CompanyMasterIndex == [CtFieldReadImpl]megamek.common.Entity.LOC_DESTROYED) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Iterator<[CtTypeReferenceImpl]megamek.common.Mounted> e = [CtInvocationImpl][CtInvocationImpl]getEquipment().iterator();
            [CtWhileImpl]while ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtFieldReadImpl]c3CompanyMasterIndex == [CtFieldReadImpl]megamek.common.Entity.LOC_DESTROYED) && [CtInvocationImpl][CtVariableReadImpl]e.hasNext()) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m = [CtInvocationImpl][CtVariableReadImpl]e.next();
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.WeaponType) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]WeaponType.F_C3M) || [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]WeaponType.F_C3MBS))) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]m.isInoperable())) [CtBlockImpl]{
                    [CtWhileImpl][CtCommentImpl]// Now look for the company command master.
                    while ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtFieldReadImpl]c3CompanyMasterIndex == [CtFieldReadImpl]megamek.common.Entity.LOC_DESTROYED) && [CtInvocationImpl][CtVariableReadImpl]e.hasNext()) [CtBlockImpl]{
                        [CtAssignmentImpl][CtVariableWriteImpl]m = [CtInvocationImpl][CtVariableReadImpl]e.next();
                        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.WeaponType) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]WeaponType.F_C3M) || [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]WeaponType.F_C3MBS))) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]m.isInoperable())) [CtBlockImpl]{
                            [CtAssignmentImpl][CtCommentImpl]// Found the comany command master
                            [CtFieldWriteImpl]c3CompanyMasterIndex = [CtInvocationImpl]getEquipmentNum([CtVariableReadImpl]m);
                        }
                    } 
                }
            } 
            [CtIfImpl][CtCommentImpl]// If we haven't found the company command master, there is none.
            if ([CtBinaryOperatorImpl][CtFieldReadImpl]c3CompanyMasterIndex == [CtFieldReadImpl]megamek.common.Entity.LOC_DESTROYED) [CtBlockImpl]{
                [CtAssignmentImpl][CtFieldWriteImpl]c3CompanyMasterIndex = [CtFieldReadImpl]megamek.common.Entity.LOC_NONE;
                [CtReturnImpl]return [CtLiteralImpl]false;
            }
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m = [CtInvocationImpl]getEquipment([CtFieldReadImpl]c3CompanyMasterIndex);
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]m.isDestroyed()) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]m.isBreached())) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]true;
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks if it has any type of C3 computer.
     *
     * @return true iff it has a C3 computer.
     */
    public [CtTypeReferenceImpl]boolean hasC3() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl]hasC3S() || [CtInvocationImpl]hasC3M()) || [CtInvocationImpl]hasC3MM();
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks if we have nova CEWS that is not offline.
     *
     * @return  */
    public [CtTypeReferenceImpl]boolean hasActiveNovaCEWS() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]isShutDown() || [CtInvocationImpl]isOffBoard()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getEquipment()) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.MiscType) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_NOVA)) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]m.isInoperable())) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"Off"))) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean hasNovaCEWS() [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getEquipment()) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.MiscType) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_NOVA)) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]m.isInoperable())) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean hasNavalC3() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]isShutDown() || [CtInvocationImpl]isOffBoard()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getEquipment()) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.MiscType) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_NAVAL_C3)) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]m.isInoperable())) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean hasC3i() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]isShutDown() || [CtInvocationImpl]isOffBoard()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getEquipment()) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.MiscType) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_C3I)) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]m.isInoperable())) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtIfImpl][CtCommentImpl]// check for Manei Domini implants
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Infantry) && [CtBinaryOperatorImpl]([CtLiteralImpl]null != [CtFieldReadImpl]crew)) && [CtInvocationImpl][CtCommentImpl]// Fix for Bug Report #1194
        hasAbility([CtTypeAccessImpl]OptionsConstants.MD_ENH_MM_IMPLANTS)) && [CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.MD_BOOST_COMM_IMPLANT)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]true;
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.lang.String getC3NetId() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]c3NetIdString == [CtLiteralImpl]null) [CtBlockImpl]{
            [CtIfImpl]if ([CtInvocationImpl]hasC3()) [CtBlockImpl]{
                [CtAssignmentImpl][CtFieldWriteImpl]c3NetIdString = [CtBinaryOperatorImpl][CtLiteralImpl]"C3." + [CtInvocationImpl]getId();
            } else [CtIfImpl]if ([CtInvocationImpl]hasC3i()) [CtBlockImpl]{
                [CtAssignmentImpl][CtFieldWriteImpl]c3NetIdString = [CtBinaryOperatorImpl][CtLiteralImpl]"C3i." + [CtInvocationImpl]getId();
            } else [CtIfImpl]if ([CtInvocationImpl]hasActiveNovaCEWS()) [CtBlockImpl]{
                [CtAssignmentImpl][CtFieldWriteImpl]c3NetIdString = [CtBinaryOperatorImpl][CtLiteralImpl]"C3Nova." + [CtInvocationImpl]getId();
            } else [CtIfImpl]if ([CtInvocationImpl]hasNavalC3()) [CtBlockImpl]{
                [CtAssignmentImpl][CtFieldWriteImpl]c3NetIdString = [CtBinaryOperatorImpl][CtLiteralImpl]"NC3." + [CtInvocationImpl]getId();
            }
        }
        [CtReturnImpl]return [CtFieldReadImpl]c3NetIdString;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.lang.String getOriginalNovaC3NetId() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtLiteralImpl]"C3Nova." + [CtInvocationImpl]getId();
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Switches the C3 network Id to the new network ID.
     */
    public [CtTypeReferenceImpl]void newRoundNovaNetSwitch() [CtBlockImpl]{
        [CtIfImpl]if ([CtInvocationImpl]hasNovaCEWS()) [CtBlockImpl]{
            [CtAssignmentImpl][CtCommentImpl]// FIXME: no check for network limit of 3 units
            [CtFieldWriteImpl]c3NetIdString = [CtFieldReadImpl]newC3NetIdString;
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Set the C3 network ID to be used on the next turn. Used for reconfiguring
     * a C3 network with Nova CEWS.
     *
     * @param str
     */
    public [CtTypeReferenceImpl]void setNewRoundNovaNetworkString([CtParameterImpl][CtTypeReferenceImpl]java.lang.String str) [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// Only allow Nova CEWS to change
        if ([CtInvocationImpl]hasNovaCEWS()) [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl]newC3NetIdString = [CtVariableReadImpl]str;
        } else [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl]newC3NetIdString = [CtInvocationImpl]getOriginalNovaC3NetId();
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the C3 network id that will be switched to on the next turn.
     *
     * @return  */
    public [CtTypeReferenceImpl]java.lang.String getNewRoundNovaNetworkString() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtFieldReadImpl]newC3NetIdString == [CtLiteralImpl]null) || [CtInvocationImpl][CtFieldReadImpl]newC3NetIdString.isEmpty()) [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl]newC3NetIdString = [CtInvocationImpl]getOriginalNovaC3NetId();
        }
        [CtReturnImpl]return [CtFieldReadImpl]newC3NetIdString;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setC3NetId([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Entity e) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]e == [CtLiteralImpl]null) || [CtInvocationImpl]isEnemyOf([CtVariableReadImpl]e)) [CtBlockImpl]{
            [CtReturnImpl]return;
        }
        [CtAssignmentImpl][CtFieldWriteImpl]c3NetIdString = [CtFieldReadImpl][CtVariableReadImpl]e.c3NetIdString;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setC3NetIdSelf() [CtBlockImpl]{
        [CtIfImpl]if ([CtInvocationImpl]hasActiveNovaCEWS()) [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl]c3NetIdString = [CtBinaryOperatorImpl][CtLiteralImpl]"C3Nova." + [CtInvocationImpl]getId();
        } else [CtIfImpl]if ([CtInvocationImpl]hasNavalC3()) [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl]c3NetIdString = [CtBinaryOperatorImpl][CtLiteralImpl]"NC3." + [CtInvocationImpl]getId();
        } else [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl]c3NetIdString = [CtBinaryOperatorImpl][CtLiteralImpl]"C3i." + [CtInvocationImpl]getId();
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Determine the remaining number of other C3 Master computers that can
     * connect to this <code>Entity</code>.
     * <p/>
     * Please note, if this <code>Entity</code> does not have two C3 Master
     * computers, then it must first be identified as a company commander;
     * otherwise the number of free nodes will be zero.
     *
     * @return a non-negative <code>int</code> value.
     */
    public [CtTypeReferenceImpl]int calculateFreeC3MNodes() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int nodes = [CtLiteralImpl]0;
        [CtIfImpl]if ([CtInvocationImpl]hasC3MM()) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]nodes = [CtLiteralImpl]2;
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]game != [CtLiteralImpl]null) [CtBlockImpl]{
                [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity e : [CtInvocationImpl][CtFieldReadImpl]game.getEntitiesVector()) [CtBlockImpl]{
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]e.hasC3M() && [CtBinaryOperatorImpl]([CtVariableReadImpl]e != [CtThisAccessImpl]this)) [CtBlockImpl]{
                        [CtLocalVariableImpl]final [CtTypeReferenceImpl]megamek.common.Entity m = [CtInvocationImpl][CtVariableReadImpl]e.getC3Master();
                        [CtIfImpl]if ([CtInvocationImpl]equals([CtVariableReadImpl]m)) [CtBlockImpl]{
                            [CtUnaryOperatorImpl][CtVariableWriteImpl]nodes--;
                        }
                        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]nodes <= [CtLiteralImpl]0) [CtBlockImpl]{
                            [CtReturnImpl]return [CtLiteralImpl]0;
                        }
                    }
                }
            }
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]hasC3M() && [CtInvocationImpl]C3MasterIs([CtThisAccessImpl]this)) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]nodes = [CtLiteralImpl]3;
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]game != [CtLiteralImpl]null) [CtBlockImpl]{
                [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity e : [CtInvocationImpl][CtFieldReadImpl]game.getEntitiesVector()) [CtBlockImpl]{
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]e.hasC3() && [CtBinaryOperatorImpl]([CtVariableReadImpl]e != [CtThisAccessImpl]this)) [CtBlockImpl]{
                        [CtLocalVariableImpl]final [CtTypeReferenceImpl]megamek.common.Entity m = [CtInvocationImpl][CtVariableReadImpl]e.getC3Master();
                        [CtIfImpl]if ([CtInvocationImpl]equals([CtVariableReadImpl]m)) [CtBlockImpl]{
                            [CtUnaryOperatorImpl][CtVariableWriteImpl]nodes--;
                        }
                        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]nodes <= [CtLiteralImpl]0) [CtBlockImpl]{
                            [CtReturnImpl]return [CtLiteralImpl]0;
                        }
                    }
                }
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]nodes;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Determine the remaining number of other C3 computers that can connect to
     * this <code>Entity</code>.
     * <p/>
     * Please note, if this <code>Entity</code> has two C3 Master computers,
     * then this function only returns the remaining number of <b>C3 Slave</b>
     * computers that can connect.
     *
     * @return a non-negative <code>int</code> value.
     */
    public [CtTypeReferenceImpl]int calculateFreeC3Nodes() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int nodes = [CtLiteralImpl]0;
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]hasC3i() || [CtInvocationImpl]hasNavalC3()) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]nodes = [CtLiteralImpl]5;
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]game != [CtLiteralImpl]null) [CtBlockImpl]{
                [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity e : [CtInvocationImpl][CtFieldReadImpl]game.getEntitiesVector()) [CtBlockImpl]{
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtUnaryOperatorImpl](![CtInvocationImpl]equals([CtVariableReadImpl]e)) && [CtInvocationImpl]onSameC3NetworkAs([CtVariableReadImpl]e)) [CtBlockImpl]{
                        [CtUnaryOperatorImpl][CtVariableWriteImpl]nodes--;
                        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]nodes <= [CtLiteralImpl]0) [CtBlockImpl]{
                            [CtReturnImpl]return [CtLiteralImpl]0;
                        }
                    }
                }
            }
        } else [CtIfImpl]if ([CtInvocationImpl]hasC3M()) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]nodes = [CtLiteralImpl]3;
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]game != [CtLiteralImpl]null) [CtBlockImpl]{
                [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity e : [CtInvocationImpl][CtFieldReadImpl]game.getEntitiesVector()) [CtBlockImpl]{
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]e.hasC3() && [CtUnaryOperatorImpl](![CtInvocationImpl]equals([CtVariableReadImpl]e))) [CtBlockImpl]{
                        [CtLocalVariableImpl]final [CtTypeReferenceImpl]megamek.common.Entity m = [CtInvocationImpl][CtVariableReadImpl]e.getC3Master();
                        [CtIfImpl]if ([CtInvocationImpl]equals([CtVariableReadImpl]m)) [CtBlockImpl]{
                            [CtIfImpl][CtCommentImpl]// If this unit is a company commander, and has two
                            [CtCommentImpl]// C3 Master computers, only count C3 Slaves here.
                            if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtUnaryOperatorImpl](![CtInvocationImpl]C3MasterIs([CtThisAccessImpl]this)) || [CtUnaryOperatorImpl](![CtInvocationImpl]hasC3MM())) || [CtInvocationImpl][CtVariableReadImpl]e.hasC3S()) [CtBlockImpl]{
                                [CtUnaryOperatorImpl][CtVariableWriteImpl]nodes--;
                            }
                        }
                        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]nodes <= [CtLiteralImpl]0) [CtBlockImpl]{
                            [CtReturnImpl]return [CtLiteralImpl]0;
                        }
                    }
                }
            }
        } else [CtIfImpl]if ([CtInvocationImpl]hasActiveNovaCEWS()) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]nodes = [CtLiteralImpl]2;
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]game != [CtLiteralImpl]null) [CtBlockImpl]{
                [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity e : [CtInvocationImpl][CtFieldReadImpl]game.getEntitiesVector()) [CtBlockImpl]{
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtUnaryOperatorImpl](![CtInvocationImpl]equals([CtVariableReadImpl]e)) && [CtInvocationImpl]onSameC3NetworkAs([CtVariableReadImpl]e)) [CtBlockImpl]{
                        [CtUnaryOperatorImpl][CtVariableWriteImpl]nodes--;
                        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]nodes <= [CtLiteralImpl]0) [CtBlockImpl]{
                            [CtReturnImpl]return [CtLiteralImpl]0;
                        }
                    }
                }
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]nodes;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @return the entity "above" this entity in our c3 network, or this entity
    itself, if none is above this
     */
    public [CtTypeReferenceImpl]megamek.common.Entity getC3Top() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity m = [CtThisAccessImpl]this;
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity master = [CtInvocationImpl][CtVariableReadImpl]m.getC3Master();
        [CtWhileImpl]while ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]master != [CtLiteralImpl]null) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]master.equals([CtVariableReadImpl]m))) && [CtInvocationImpl][CtVariableReadImpl]master.hasC3()) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.hasBoostedC3() && [CtUnaryOperatorImpl](![CtInvocationImpl][CtTypeAccessImpl]megamek.common.ComputeECM.isAffectedByAngelECM([CtVariableReadImpl]m, [CtInvocationImpl][CtVariableReadImpl]m.getPosition(), [CtInvocationImpl][CtVariableReadImpl]master.getPosition()))) || [CtUnaryOperatorImpl](![CtInvocationImpl][CtTypeAccessImpl]megamek.common.ComputeECM.isAffectedByECM([CtVariableReadImpl]m, [CtInvocationImpl][CtVariableReadImpl]m.getPosition(), [CtInvocationImpl][CtVariableReadImpl]master.getPosition())))) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]master.hasBoostedC3() && [CtUnaryOperatorImpl](![CtInvocationImpl][CtTypeAccessImpl]megamek.common.ComputeECM.isAffectedByAngelECM([CtVariableReadImpl]master, [CtInvocationImpl][CtVariableReadImpl]master.getPosition(), [CtInvocationImpl][CtVariableReadImpl]master.getPosition()))) || [CtUnaryOperatorImpl](![CtInvocationImpl][CtTypeAccessImpl]megamek.common.ComputeECM.isAffectedByECM([CtVariableReadImpl]master, [CtInvocationImpl][CtVariableReadImpl]master.getPosition(), [CtInvocationImpl][CtVariableReadImpl]master.getPosition())))) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]m = [CtVariableReadImpl]master;
            [CtAssignmentImpl][CtVariableWriteImpl]master = [CtInvocationImpl][CtVariableReadImpl]m.getC3Master();
        } 
        [CtReturnImpl]return [CtVariableReadImpl]m;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Return the unit that is current master of this unit's C3 network. If the
     * master unit has been destroyed or had it's C3 master computer damaged,
     * then this unit is out of the C3 network for the rest of the game. If the
     * master unit has shut down, then this unit may return to the C3 network at
     * a later time.
     *
     * @return the <code>Entity</code> that is the master of this unit's C3
    network. This value may be <code>null</code>. If the value master
    unit has shut down, then the value will be non-<code>null</code>
    after the master unit restarts.
     */
    public [CtTypeReferenceImpl]megamek.common.Entity getC3Master() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]c3Master == [CtFieldReadImpl]megamek.common.Entity.NONE) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]null;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]hasC3S() && [CtBinaryOperatorImpl]([CtFieldReadImpl]c3Master > [CtFieldReadImpl]megamek.common.Entity.NONE)) [CtBlockImpl]{
            [CtLocalVariableImpl][CtCommentImpl]// since we can't seem to get the check working in setC3Master(),
            [CtCommentImpl]// I'll just do it here, every time. This sucks.
            [CtTypeReferenceImpl]megamek.common.Entity eMaster = [CtInvocationImpl][CtFieldReadImpl]game.getEntity([CtFieldReadImpl]c3Master);
            [CtIfImpl][CtCommentImpl]// Have we lost our C3Master?
            if ([CtBinaryOperatorImpl][CtVariableReadImpl]eMaster == [CtLiteralImpl]null) [CtBlockImpl]{
                [CtAssignmentImpl][CtFieldWriteImpl]c3Master = [CtFieldReadImpl]megamek.common.Entity.NONE;
            } else [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]eMaster.isShutDown()) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]null;
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]eMaster.C3MasterIs([CtVariableReadImpl]eMaster) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]eMaster.hasC3MM())) [CtBlockImpl]{
                [CtAssignmentImpl][CtFieldWriteImpl]c3Master = [CtFieldReadImpl]megamek.common.Entity.NONE;
            } else [CtIfImpl]if ([CtUnaryOperatorImpl]![CtInvocationImpl][CtVariableReadImpl]eMaster.hasC3M()) [CtBlockImpl]{
                [CtAssignmentImpl][CtFieldWriteImpl]c3Master = [CtFieldReadImpl]megamek.common.Entity.NONE;
            }
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]hasC3M() && [CtBinaryOperatorImpl]([CtFieldReadImpl]c3Master > [CtFieldReadImpl]megamek.common.Entity.NONE)) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity eMaster = [CtInvocationImpl][CtFieldReadImpl]game.getEntity([CtFieldReadImpl]c3Master);
            [CtIfImpl][CtCommentImpl]// Have we lost our C3Master?
            if ([CtBinaryOperatorImpl][CtVariableReadImpl]eMaster == [CtLiteralImpl]null) [CtBlockImpl]{
                [CtAssignmentImpl][CtFieldWriteImpl]c3Master = [CtFieldReadImpl]megamek.common.Entity.NONE;
            } else [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]eMaster.isShutDown()) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]null;
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtFieldReadImpl][CtVariableReadImpl]eMaster.c3CompanyMasterIndex > [CtFieldReadImpl]megamek.common.Entity.LOC_NONE) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]eMaster.hasC3MM())) || [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtFieldReadImpl][CtVariableReadImpl]eMaster.c3CompanyMasterIndex <= [CtFieldReadImpl]megamek.common.Entity.LOC_NONE) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]eMaster.hasC3M()))) [CtBlockImpl]{
                [CtAssignmentImpl][CtFieldWriteImpl]c3Master = [CtFieldReadImpl]megamek.common.Entity.NONE;
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]eMaster != [CtThisAccessImpl]this) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity eCompanyMaster = [CtInvocationImpl][CtVariableReadImpl]eMaster.getC3Master();
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]eCompanyMaster != [CtLiteralImpl]null) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]eCompanyMaster.getC3Master() != [CtVariableReadImpl]eCompanyMaster)) [CtBlockImpl]{
                    [CtAssignmentImpl][CtFieldWriteImpl]c3Master = [CtFieldReadImpl]megamek.common.Entity.NONE;
                }
            }
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtUnaryOperatorImpl](![CtInvocationImpl]isShutDown()) && [CtUnaryOperatorImpl](![CtInvocationImpl]hasC3MM())) && [CtBinaryOperatorImpl]([CtFieldReadImpl]c3Master > [CtFieldReadImpl]megamek.common.Entity.NONE)) [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl]c3Master = [CtFieldReadImpl]megamek.common.Entity.NONE;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]c3Master == [CtFieldReadImpl]megamek.common.Entity.NONE) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]null;
        }
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]game.getEntity([CtFieldReadImpl]c3Master);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Get the ID of the master unit in this unit's C3 network. If the master
     * unit has shut down, then the ID will still be returned. The only times
     * when the value, <code>Entity.NONE</code> is returned is when this unit is
     * permanently out of the C3 network, or when it was never in a C3 network.
     *
     * @return the <code>int</code> ID of the unit that is the master of this
    unit's C3 network, or <code>Entity.NONE</code>.
     */
    public [CtTypeReferenceImpl]int getC3MasterId() [CtBlockImpl]{
        [CtInvocationImpl][CtCommentImpl]// Make sure that this unit is still on a C3 network.
        [CtCommentImpl]// N.B. this call may set this.C3Master to NONE.
        getC3Master();
        [CtReturnImpl]return [CtFieldReadImpl]c3Master;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Determines if the passed <code>Entity</code> is the C3 Master of this
     * unit.
     * <p/>
     * Please note, that when an <code>Entity</code> is it's own C3 Master, then
     * it is a company commander.
     * <p/>
     * Also note that when <code>null</code> is the master for this
     * <code>Entity</code>, then it is an independent master.
     *
     * @param e
     * 		- the <code>Entity</code> that may be this unit's C3 Master.
     * @return a <code>boolean</code> that is <code>true</code> when the passed
    <code>Entity</code> is this unit's commander. If the passed unit
    isn't this unit's commander, this routine returns
    <code>false</code>.
     */
    public [CtTypeReferenceImpl]boolean C3MasterIs([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Entity e) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]e == [CtLiteralImpl]null) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]c3Master == [CtFieldReadImpl]megamek.common.Entity.NONE) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
            [CtReturnImpl]return [CtLiteralImpl]false;[CtCommentImpl]// if this entity has a C3Master then null is not

            [CtCommentImpl]// it's master.
        }
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtFieldReadImpl][CtVariableReadImpl]e.id == [CtFieldReadImpl]c3Master;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Set another <code>Entity</code> as our C3 Master
     *
     * @param e
     * 		- the <code>Entity</code> that should be set as our C3 Master.
     */
    public [CtTypeReferenceImpl]void setC3Master([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Entity e, [CtParameterImpl][CtTypeReferenceImpl]boolean reset) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]e == [CtLiteralImpl]null) [CtBlockImpl]{
            [CtInvocationImpl]setC3Master([CtFieldReadImpl]megamek.common.Entity.NONE, [CtVariableReadImpl]reset);
        } else [CtBlockImpl]{
            [CtIfImpl]if ([CtInvocationImpl]isEnemyOf([CtVariableReadImpl]e)) [CtBlockImpl]{
                [CtReturnImpl]return;
            }
            [CtInvocationImpl]setC3Master([CtFieldReadImpl][CtVariableReadImpl]e.id, [CtVariableReadImpl]reset);
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @param entityId
     */
    public [CtTypeReferenceImpl]void setC3Master([CtParameterImpl][CtTypeReferenceImpl]int entityId, [CtParameterImpl][CtTypeReferenceImpl]boolean reset) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]reset && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtFieldReadImpl]id == [CtVariableReadImpl]entityId) != [CtBinaryOperatorImpl]([CtFieldReadImpl]id == [CtFieldReadImpl]c3Master))) [CtBlockImpl]{
            [CtForEachImpl][CtCommentImpl]// this just changed from a company-level to lance-level (or vice
            [CtCommentImpl]// versa); have to disconnect all slaved units to maintain
            [CtCommentImpl]// integrity.
            for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity e : [CtInvocationImpl][CtFieldReadImpl]game.getEntitiesVector()) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]e.C3MasterIs([CtThisAccessImpl]this) && [CtUnaryOperatorImpl](![CtInvocationImpl]equals([CtVariableReadImpl]e))) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]e.setC3Master([CtFieldReadImpl]megamek.common.Entity.NONE, [CtVariableReadImpl]reset);
                }
            }
        }
        [CtIfImpl]if ([CtInvocationImpl]hasC3()) [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl]c3Master = [CtVariableReadImpl]entityId;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]hasC3() && [CtBinaryOperatorImpl]([CtVariableReadImpl]entityId == [CtFieldReadImpl]megamek.common.Entity.NONE)) [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl]c3NetIdString = [CtBinaryOperatorImpl][CtLiteralImpl]"C3." + [CtFieldReadImpl]id;
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]hasC3i() && [CtBinaryOperatorImpl]([CtVariableReadImpl]entityId == [CtFieldReadImpl]megamek.common.Entity.NONE)) [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl]c3NetIdString = [CtBinaryOperatorImpl][CtLiteralImpl]"C3i." + [CtFieldReadImpl]id;
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]hasNavalC3() && [CtBinaryOperatorImpl]([CtVariableReadImpl]entityId == [CtFieldReadImpl]megamek.common.Entity.NONE)) [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl]c3NetIdString = [CtBinaryOperatorImpl][CtLiteralImpl]"NC3." + [CtFieldReadImpl]id;
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl]hasC3() || [CtInvocationImpl]hasC3i()) || [CtInvocationImpl]hasNavalC3()) [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl]c3NetIdString = [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getEntity([CtVariableReadImpl]entityId).getC3NetId();
        }
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity e : [CtInvocationImpl][CtFieldReadImpl]game.getEntitiesVector()) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]e.C3MasterIs([CtThisAccessImpl]this) && [CtUnaryOperatorImpl](![CtInvocationImpl]equals([CtVariableReadImpl]e))) [CtBlockImpl]{
                [CtAssignmentImpl][CtFieldWriteImpl][CtVariableReadImpl]e.c3NetIdString = [CtFieldReadImpl]c3NetIdString;
            }
        }
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean onSameC3NetworkAs([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Entity e) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]onSameC3NetworkAs([CtVariableReadImpl]e, [CtLiteralImpl]false);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks if another entity is on the same c3 network as this entity
     *
     * @param e
     * 		The <code>Entity</code> to check against this entity
     * @param ignoreECM
     * 		a <code>boolean</code> indicating if ECM should be ignored, we
     * 		need this for c3i
     * @return a <code>boolean</code> that is <code>true</code> if the given
    entity is on the same network, <code>false</code> if not.
     */
    public [CtTypeReferenceImpl]boolean onSameC3NetworkAs([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Entity e, [CtParameterImpl][CtTypeReferenceImpl]boolean ignoreECM) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl]isEnemyOf([CtVariableReadImpl]e) || [CtInvocationImpl]isShutDown()) || [CtInvocationImpl][CtVariableReadImpl]e.isShutDown()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl][CtCommentImpl]// Active Mek Stealth prevents entity from participating in C3.
        [CtCommentImpl]// Turn off the stealth, and your back in the network.
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Mech) || [CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Tank)) && [CtInvocationImpl]isStealthActive()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]e instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Mech) || [CtBinaryOperatorImpl]([CtVariableReadImpl]e instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Tank)) && [CtInvocationImpl][CtVariableReadImpl]e.isStealthActive()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl][CtCommentImpl]// C3i is easy - if they both have C3i, and their net ID's match,
        [CtCommentImpl]// they're on the same network!
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl]hasC3i() && [CtInvocationImpl][CtVariableReadImpl]e.hasC3i()) && [CtInvocationImpl][CtInvocationImpl]getC3NetId().equals([CtInvocationImpl][CtVariableReadImpl]e.getC3NetId())) [CtBlockImpl]{
            [CtIfImpl]if ([CtVariableReadImpl]ignoreECM) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
            [CtReturnImpl]return [CtBinaryOperatorImpl][CtUnaryOperatorImpl](![CtInvocationImpl][CtTypeAccessImpl]megamek.common.ComputeECM.isAffectedByECM([CtVariableReadImpl]e, [CtInvocationImpl][CtVariableReadImpl]e.getPosition(), [CtInvocationImpl][CtVariableReadImpl]e.getPosition())) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtTypeAccessImpl]megamek.common.ComputeECM.isAffectedByECM([CtThisAccessImpl]this, [CtInvocationImpl]getPosition(), [CtInvocationImpl]getPosition()));
        }
        [CtIfImpl][CtCommentImpl]// NC3 is easy too - if they both have NC3, and their net ID's match,
        [CtCommentImpl]// they're on the same network!
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl]hasNavalC3() && [CtInvocationImpl][CtVariableReadImpl]e.hasNavalC3()) && [CtInvocationImpl][CtInvocationImpl]getC3NetId().equals([CtInvocationImpl][CtVariableReadImpl]e.getC3NetId())) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]int distance = [CtInvocationImpl][CtTypeAccessImpl]megamek.common.Compute.effectiveDistance([CtFieldReadImpl]game, [CtThisAccessImpl]this, [CtVariableReadImpl]e, [CtLiteralImpl]false);
            [CtIfImpl][CtCommentImpl]// Naval C3 is not affected by ECM, but nodes must be within 60 hexes of one another
            if ([CtBinaryOperatorImpl][CtInvocationImpl][CtFieldReadImpl]game.getRoundCount() > [CtLiteralImpl]0) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]distance > [CtLiteralImpl]60) [CtBlockImpl]{
                    [CtReturnImpl]return [CtLiteralImpl]false;
                }
                [CtIfImpl][CtCommentImpl]// Naval C3 only works in space
                if ([CtUnaryOperatorImpl]![CtInvocationImpl]isSpaceborne()) [CtBlockImpl]{
                    [CtReturnImpl]return [CtLiteralImpl]false;
                }
            }
            [CtReturnImpl]return [CtLiteralImpl]true;
        }
        [CtIfImpl][CtCommentImpl]// Nova is easy - if they both have Nova, and their net ID's match,
        [CtCommentImpl]// they're on the same network!
        [CtCommentImpl]// At least I hope thats how it works.
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl]hasActiveNovaCEWS() && [CtInvocationImpl][CtVariableReadImpl]e.hasActiveNovaCEWS()) && [CtInvocationImpl][CtInvocationImpl]getC3NetId().equals([CtInvocationImpl][CtVariableReadImpl]e.getC3NetId())) [CtBlockImpl]{
            [CtIfImpl]if ([CtVariableReadImpl]ignoreECM) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.ECMInfo srcInfo = [CtInvocationImpl][CtTypeAccessImpl]megamek.common.ComputeECM.getECMEffects([CtVariableReadImpl]e, [CtInvocationImpl][CtVariableReadImpl]e.getPosition(), [CtInvocationImpl][CtVariableReadImpl]e.getPosition(), [CtLiteralImpl]true, [CtLiteralImpl]null);
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.ECMInfo dstInfo = [CtInvocationImpl][CtTypeAccessImpl]megamek.common.ComputeECM.getECMEffects([CtThisAccessImpl]this, [CtInvocationImpl]getPosition(), [CtInvocationImpl]getPosition(), [CtLiteralImpl]true, [CtLiteralImpl]null);
            [CtReturnImpl]return [CtBinaryOperatorImpl][CtUnaryOperatorImpl](![CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]srcInfo != [CtLiteralImpl]null) && [CtInvocationImpl][CtVariableReadImpl]srcInfo.isNovaECM())) && [CtUnaryOperatorImpl](![CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]dstInfo != [CtLiteralImpl]null) && [CtInvocationImpl][CtVariableReadImpl]dstInfo.isNovaECM()));
        }
        [CtIfImpl][CtCommentImpl]// simple sanity check - do they both have C3, and are they both on the
        [CtCommentImpl]// same network?
        if ([CtBinaryOperatorImpl][CtUnaryOperatorImpl](![CtInvocationImpl]hasC3()) || [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]e.hasC3())) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl]getC3Top() == [CtLiteralImpl]null) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]e.getC3Top() == [CtLiteralImpl]null)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtReturnImpl][CtCommentImpl]// got the easy part out of the way, now we need to verify that the
        [CtCommentImpl]// network isn't down
        return [CtInvocationImpl][CtInvocationImpl]getC3Top().equals([CtInvocationImpl][CtVariableReadImpl]e.getC3Top());
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns whether there is CASE protecting the location.
     */
    public [CtTypeReferenceImpl]boolean locationHasCase([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted : [CtInvocationImpl]getMisc()) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]mounted.getLocation() == [CtVariableReadImpl]loc) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getType().hasFlag([CtTypeAccessImpl]MiscType.F_CASE) | [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getType().hasFlag([CtTypeAccessImpl]MiscType.F_CASEP))) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns whether there is CASE anywhere on this {@code Entity}.
     */
    public [CtTypeReferenceImpl]boolean hasCase() [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// Clan Mechs always have CASE!
        if ([CtInvocationImpl]isClan()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]true;
        }
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted : [CtInvocationImpl]getMisc()) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getType().hasFlag([CtTypeAccessImpl]MiscType.F_CASE) || [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getType().hasFlag([CtTypeAccessImpl]MiscType.F_CASEP)) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Hits all criticals of the system occupying the specified critical slot.
     * Used, for example, in a gauss rifle capacitor discharge. Does not apply
     * any special effect of hitting the criticals, like ammo explosion.
     */
    public [CtTypeReferenceImpl]void hitAllCriticals([CtParameterImpl][CtTypeReferenceImpl]int loc, [CtParameterImpl][CtTypeReferenceImpl]int slot) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.CriticalSlot orig = [CtInvocationImpl]getCritical([CtVariableReadImpl]loc, [CtVariableReadImpl]slot);
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtInvocationImpl]getNumberOfCriticals([CtVariableReadImpl]loc); [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.CriticalSlot cs = [CtInvocationImpl]getCritical([CtVariableReadImpl]loc, [CtVariableReadImpl]i);
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]cs != [CtLiteralImpl]null) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]cs.getType() == [CtInvocationImpl][CtVariableReadImpl]orig.getType())) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted csMount = [CtInvocationImpl][CtVariableReadImpl]cs.getMount();
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]csMount != [CtLiteralImpl]null) && [CtInvocationImpl][CtVariableReadImpl]csMount.equals([CtInvocationImpl][CtVariableReadImpl]orig.getMount())) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]cs.setHit([CtLiteralImpl]true);
                }
            }
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Start a new round
     *
     * @param roundNumber
     * 		the <code>int</code> number of the new round
     */
    [CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]void newRound([CtParameterImpl][CtTypeReferenceImpl]int roundNumber) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]fell = [CtLiteralImpl]false;
        [CtAssignmentImpl][CtFieldWriteImpl]struck = [CtLiteralImpl]false;
        [CtAssignmentImpl][CtFieldWriteImpl]unloadedThisTurn = [CtLiteralImpl]false;
        [CtAssignmentImpl][CtFieldWriteImpl]loadedThisTurn = [CtLiteralImpl]false;
        [CtAssignmentImpl][CtFieldWriteImpl]done = [CtLiteralImpl]false;
        [CtAssignmentImpl][CtFieldWriteImpl]delta_distance = [CtLiteralImpl]0;
        [CtAssignmentImpl][CtFieldWriteImpl]mpUsedLastRound = [CtFieldReadImpl]mpUsed;
        [CtAssignmentImpl][CtFieldWriteImpl]mpUsed = [CtLiteralImpl]0;
        [CtAssignmentImpl][CtFieldWriteImpl]isJumpingNow = [CtLiteralImpl]false;
        [CtAssignmentImpl][CtFieldWriteImpl]convertingNow = [CtLiteralImpl]false;
        [CtAssignmentImpl][CtFieldWriteImpl]damageThisRound = [CtLiteralImpl]0;
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]assaultDropInProgress == [CtLiteralImpl]2) [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl]assaultDropInProgress = [CtLiteralImpl]0;
        }
        [CtAssignmentImpl][CtFieldWriteImpl]movedLastRound = [CtFieldReadImpl]moved;
        [CtAssignmentImpl][CtFieldWriteImpl]moved = [CtFieldReadImpl]EntityMovementType.MOVE_NONE;
        [CtAssignmentImpl][CtFieldWriteImpl]movedBackwards = [CtLiteralImpl]false;
        [CtAssignmentImpl][CtFieldWriteImpl]isPowerReverse = [CtLiteralImpl]false;
        [CtAssignmentImpl][CtFieldWriteImpl]wigeLiftoffHover = [CtLiteralImpl]false;
        [CtAssignmentImpl][CtFieldWriteImpl]gotPavementBonus = [CtLiteralImpl]false;
        [CtAssignmentImpl][CtFieldWriteImpl]wigeBonus = [CtLiteralImpl]0;
        [CtAssignmentImpl][CtFieldWriteImpl]hitThisRoundByAntiTSM = [CtLiteralImpl]false;
        [CtAssignmentImpl][CtFieldWriteImpl]inReverse = [CtLiteralImpl]false;
        [CtInvocationImpl][CtFieldReadImpl]hitBySwarmsEntity.clear();
        [CtInvocationImpl][CtFieldReadImpl]hitBySwarmsWeapon.clear();
        [CtInvocationImpl]setTaggedBy([CtUnaryOperatorImpl]-[CtLiteralImpl]1);
        [CtInvocationImpl]setLayingMines([CtLiteralImpl]false);
        [CtInvocationImpl]setArmsFlipped([CtLiteralImpl]false);
        [CtInvocationImpl]setDisplacementAttack([CtLiteralImpl]null);
        [CtInvocationImpl]setFindingClub([CtLiteralImpl]false);
        [CtInvocationImpl]setSpotting([CtLiteralImpl]false);
        [CtAssignmentImpl][CtFieldWriteImpl]spotTargetId = [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE;
        [CtInvocationImpl]setClearingMinefield([CtLiteralImpl]false);
        [CtInvocationImpl]setUnjammingRAC([CtLiteralImpl]false);
        [CtInvocationImpl][CtFieldReadImpl]crew.setKoThisRound([CtLiteralImpl]false);
        [CtOperatorAssignmentImpl][CtFieldWriteImpl]m_lNarcedBy |= [CtFieldReadImpl]m_lPendingNarc;
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtFieldReadImpl]pendingINarcPods.size() > [CtLiteralImpl]0) [CtBlockImpl]{
            [CtInvocationImpl][CtFieldReadImpl]iNarcPods.addAll([CtFieldReadImpl]pendingINarcPods);
            [CtAssignmentImpl][CtFieldWriteImpl]pendingINarcPods = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.INarcPod>();
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtFieldReadImpl]pendingNarcPods.size() > [CtLiteralImpl]0) [CtBlockImpl]{
            [CtInvocationImpl][CtFieldReadImpl]narcPods.addAll([CtFieldReadImpl]pendingNarcPods);
            [CtInvocationImpl][CtFieldReadImpl]pendingNarcPods.clear();
        }
        [CtIfImpl][CtCommentImpl]// update the number of turns we used a blue shield
        if ([CtInvocationImpl]hasActiveBlueShield()) [CtBlockImpl]{
            [CtUnaryOperatorImpl][CtFieldWriteImpl]blueShieldRounds++;
        }
        [CtIfImpl][CtCommentImpl]// for dropping troops, check to see if they are going to land
        [CtCommentImpl]// this turn, if so, then set their assault drop status to true
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl]isAirborne() && [CtUnaryOperatorImpl](![CtInvocationImpl]isAero())) && [CtBinaryOperatorImpl]([CtInvocationImpl]getAltitude() <= [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getPlanetaryConditions().getDropRate())) [CtBlockImpl]{
            [CtInvocationImpl]setAssaultDropInProgress([CtLiteralImpl]true);
        }
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getEquipment()) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]m.newRound([CtVariableReadImpl]roundNumber);
        }
        [CtInvocationImpl]newRoundNovaNetSwitch();
        [CtInvocationImpl]doNewRoundIMP();
        [CtInvocationImpl][CtCommentImpl]// reset hexes passed through
        setPassedThrough([CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Coords>());
        [CtInvocationImpl]setPassedThroughFacing([CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]java.lang.Integer>());
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]playerPickedPassThrough == [CtLiteralImpl]null) [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl]playerPickedPassThrough = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.HashMap<>();
        } else [CtBlockImpl]{
            [CtInvocationImpl][CtFieldReadImpl]playerPickedPassThrough.clear();
        }
        [CtInvocationImpl]resetFiringArcs();
        [CtInvocationImpl]resetBays();
        [CtIfImpl]if ([CtInvocationImpl]isBomber()) [CtBlockImpl]{
            [CtInvocationImpl]resetBombAttacks();
        }
        [CtInvocationImpl][CtCommentImpl]// reset evasion
        setEvading([CtLiteralImpl]false);
        [CtAssignmentImpl][CtCommentImpl]// make sensor checks
        [CtFieldWriteImpl]sensorCheck = [CtInvocationImpl][CtTypeAccessImpl]megamek.common.Compute.d6([CtLiteralImpl]2);
        [CtIfImpl][CtCommentImpl]// if the current sensor is BAP and BAP is critted, then switch to the
        [CtCommentImpl]// first
        [CtCommentImpl]// thing that works
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtLiteralImpl]null != [CtFieldReadImpl]nextSensor) && [CtInvocationImpl][CtFieldReadImpl]nextSensor.isBAP()) && [CtUnaryOperatorImpl](![CtInvocationImpl]hasBAP([CtLiteralImpl]false))) [CtBlockImpl]{
            [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Sensor sensor : [CtInvocationImpl]getSensors()) [CtBlockImpl]{
                [CtIfImpl]if ([CtUnaryOperatorImpl]![CtInvocationImpl][CtVariableReadImpl]sensor.isBAP()) [CtBlockImpl]{
                    [CtAssignmentImpl][CtFieldWriteImpl]nextSensor = [CtVariableReadImpl]sensor;
                    [CtBreakImpl]break;
                }
            }
        }
        [CtIfImpl][CtCommentImpl]// change the active sensor, if requested
        if ([CtBinaryOperatorImpl][CtLiteralImpl]null != [CtFieldReadImpl]nextSensor) [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl]activeSensor = [CtFieldReadImpl]nextSensor;
        }
        [CtAssignmentImpl][CtCommentImpl]// ghost target roll
        [CtFieldWriteImpl]ghostTargetRoll = [CtInvocationImpl][CtTypeAccessImpl]megamek.common.Compute.d6([CtLiteralImpl]2);
        [CtAssignmentImpl][CtFieldWriteImpl]ghostTargetOverride = [CtInvocationImpl][CtTypeAccessImpl]megamek.common.Compute.d6([CtLiteralImpl]2);
        [CtIfImpl][CtCommentImpl]// update fatigue count
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtLiteralImpl]null != [CtFieldReadImpl]crew) && [CtInvocationImpl]isDeployed()) [CtBlockImpl]{
            [CtInvocationImpl][CtFieldReadImpl]crew.incrementFatigueCount();
        }
        [CtInvocationImpl][CtCommentImpl]// Update the inferno tracker.
        [CtFieldReadImpl]infernos.newRound([CtVariableReadImpl]roundNumber);
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]taserShutdownRounds > [CtLiteralImpl]0) [CtBlockImpl]{
            [CtUnaryOperatorImpl][CtFieldWriteImpl]taserShutdownRounds--;
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]taserShutdownRounds == [CtLiteralImpl]0) [CtBlockImpl]{
                [CtAssignmentImpl][CtFieldWriteImpl]shutdownByBATaser = [CtLiteralImpl]false;
            }
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]taserInterferenceRounds > [CtLiteralImpl]0) [CtBlockImpl]{
            [CtUnaryOperatorImpl][CtFieldWriteImpl]taserInterferenceRounds--;
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]taserInterferenceRounds == [CtLiteralImpl]0) [CtBlockImpl]{
                [CtAssignmentImpl][CtFieldWriteImpl]taserInterference = [CtLiteralImpl]0;
                [CtAssignmentImpl][CtFieldWriteImpl]taserInterferenceHeat = [CtLiteralImpl]false;
            }
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]taserFeedBackRounds > [CtLiteralImpl]0) [CtBlockImpl]{
            [CtUnaryOperatorImpl][CtFieldWriteImpl]taserFeedBackRounds--;
        }
        [CtIfImpl][CtCommentImpl]// If we are affected by the TSEMP Shutdown effect, we should remove
        [CtCommentImpl]// it now, so we can startup during the end phase
        if ([CtBinaryOperatorImpl][CtInvocationImpl]getTsempEffect() == [CtFieldReadImpl]megamek.common.weapons.other.TSEMPWeapon.TSEMP_EFFECT_SHUTDOWN) [CtBlockImpl]{
            [CtInvocationImpl]setTsempEffect([CtTypeAccessImpl]TSEMPWeapon.TSEMP_EFFECT_NONE);
            [CtCommentImpl]// The TSEMP interference effect shouldn't be removed until the start
            [CtCommentImpl]// of a round where we didn't have any TSEMP hits and didn't fire a
            [CtCommentImpl]// TSEMP, since we need the effect active during the firing phase
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl]getTsempHitsThisTurn() == [CtLiteralImpl]0) && [CtUnaryOperatorImpl](![CtInvocationImpl]isFiredTsempThisTurn())) [CtBlockImpl]{
            [CtInvocationImpl]setTsempEffect([CtTypeAccessImpl]TSEMPWeapon.TSEMP_EFFECT_NONE);
        }
        [CtIfImpl][CtCommentImpl]// TSEMPs can fire every other round, so if we didn't fire last
        [CtCommentImpl]// round and the TSEMP isn't one-shot, reset it's fired state
        if ([CtInvocationImpl]hasFiredTsemp()) [CtBlockImpl]{
            [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getWeaponList()) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]WeaponType.F_TSEMP) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]WeaponType.F_ONESHOT))) [CtBlockImpl]{
                    [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]m.isTSEMPDowntime()) [CtBlockImpl]{
                        [CtInvocationImpl][CtVariableReadImpl]m.setFired([CtLiteralImpl]false);
                        [CtInvocationImpl][CtVariableReadImpl]m.setTSEMPDowntime([CtLiteralImpl]false);
                    } else [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]m.isFired()) [CtBlockImpl]{
                        [CtInvocationImpl][CtVariableReadImpl]m.setTSEMPDowntime([CtLiteralImpl]true);
                    }
                }
            }
        }
        [CtAssignmentImpl][CtCommentImpl]// Reset TSEMP hits
        [CtFieldWriteImpl]tsempHitsThisTurn = [CtLiteralImpl]0;
        [CtInvocationImpl][CtCommentImpl]// Reset TSEMP firing flag
        setFiredTsempThisTurn([CtLiteralImpl]false);
        [CtIfImpl][CtCommentImpl]// Decrement the number of consecutive turns if not used last turn
        if ([CtUnaryOperatorImpl]![CtInvocationImpl]hasActivatedRadicalHS()) [CtBlockImpl]{
            [CtInvocationImpl]setConsecutiveRHSUses([CtInvocationImpl][CtTypeAccessImpl]java.lang.Math.max([CtLiteralImpl]0, [CtBinaryOperatorImpl][CtInvocationImpl]getConsecutiveRHSUses() - [CtLiteralImpl]1));
        }
        [CtInvocationImpl][CtCommentImpl]// Reset used RHS flag
        deactivateRadicalHS();
        [CtInvocationImpl]clearAttackedByThisTurn();
        [CtInvocationImpl]setMadePointblankShot([CtLiteralImpl]false);
        [CtInvocationImpl]setSelfDestructedThisTurn([CtLiteralImpl]false);
        [CtInvocationImpl]setClimbMode([CtInvocationImpl][CtInvocationImpl][CtTypeAccessImpl]megamek.client.ui.swing.GUIPreferences.getInstance().getBoolean([CtTypeAccessImpl]GUIPreferences.ADVANCED_MOVE_DEFAULT_CLIMB_MODE));
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Applies any damage that the entity has suffered. When anything gets hit
     * it is simply marked as "hit" but does not stop working until this is
     * called.
     */
    public [CtTypeReferenceImpl]void applyDamage() [CtBlockImpl]{
        [CtForEachImpl][CtCommentImpl]// mark all damaged equipment destroyed
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted : [CtInvocationImpl]getEquipment()) [CtBlockImpl]{
            [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]mounted.isHit()) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]mounted.setDestroyed([CtLiteralImpl]true);
            }
        }
        [CtForImpl][CtCommentImpl]// destroy criticals that were hit last phase
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtInvocationImpl]locations(); [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int j = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]j < [CtInvocationImpl]getNumberOfCriticals([CtVariableReadImpl]i); [CtUnaryOperatorImpl][CtVariableWriteImpl]j++) [CtBlockImpl]{
                [CtLocalVariableImpl]final [CtTypeReferenceImpl]megamek.common.CriticalSlot cs = [CtInvocationImpl]getCritical([CtVariableReadImpl]i, [CtVariableReadImpl]j);
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]cs != [CtLiteralImpl]null) && [CtInvocationImpl][CtVariableReadImpl]cs.isHit()) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]cs.setDestroyed([CtLiteralImpl]true);
                }
            }
        }
        [CtForImpl][CtCommentImpl]// Reset any "blown off this phase" markers.
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtInvocationImpl]locations(); [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtInvocationImpl]setLocationBlownOffThisPhase([CtVariableReadImpl]i, [CtLiteralImpl]false);
        }
        [CtForImpl][CtCommentImpl]// destroy armor/internals if the section was removed
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtInvocationImpl]locations(); [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]getInternal([CtVariableReadImpl]i) == [CtFieldReadImpl]IArmorState.ARMOR_DOOMED) [CtBlockImpl]{
                [CtInvocationImpl]setArmor([CtTypeAccessImpl]IArmorState.ARMOR_DESTROYED, [CtVariableReadImpl]i);
                [CtInvocationImpl]setArmor([CtTypeAccessImpl]IArmorState.ARMOR_DESTROYED, [CtVariableReadImpl]i, [CtLiteralImpl]true);
                [CtInvocationImpl]setInternal([CtTypeAccessImpl]IArmorState.ARMOR_DESTROYED, [CtVariableReadImpl]i);
                [CtForImpl][CtCommentImpl]// destroy any Narc beacons
                for ([CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Iterator<[CtTypeReferenceImpl]megamek.common.NarcPod> iter = [CtInvocationImpl][CtFieldReadImpl]narcPods.iterator(); [CtInvocationImpl][CtVariableReadImpl]iter.hasNext();) [CtBlockImpl]{
                    [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.NarcPod p = [CtInvocationImpl][CtVariableReadImpl]iter.next();
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]p.getLocation() == [CtVariableReadImpl]i) [CtBlockImpl]{
                        [CtInvocationImpl][CtVariableReadImpl]iter.remove();
                    }
                }
                [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Iterator<[CtTypeReferenceImpl]megamek.common.INarcPod> iter = [CtInvocationImpl][CtFieldReadImpl]iNarcPods.iterator(); [CtInvocationImpl][CtVariableReadImpl]iter.hasNext();) [CtBlockImpl]{
                    [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.INarcPod p = [CtInvocationImpl][CtVariableReadImpl]iter.next();
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]p.getLocation() == [CtVariableReadImpl]i) [CtBlockImpl]{
                        [CtInvocationImpl][CtVariableReadImpl]iter.remove();
                    }
                }
                [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Iterator<[CtTypeReferenceImpl]megamek.common.NarcPod> iter = [CtInvocationImpl][CtFieldReadImpl]pendingNarcPods.iterator(); [CtInvocationImpl][CtVariableReadImpl]iter.hasNext();) [CtBlockImpl]{
                    [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.NarcPod p = [CtInvocationImpl][CtVariableReadImpl]iter.next();
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]p.getLocation() == [CtVariableReadImpl]i) [CtBlockImpl]{
                        [CtInvocationImpl][CtVariableReadImpl]iter.remove();
                    }
                }
                [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Iterator<[CtTypeReferenceImpl]megamek.common.INarcPod> iter = [CtInvocationImpl][CtFieldReadImpl]pendingINarcPods.iterator(); [CtInvocationImpl][CtVariableReadImpl]iter.hasNext();) [CtBlockImpl]{
                    [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.INarcPod p = [CtInvocationImpl][CtVariableReadImpl]iter.next();
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]p.getLocation() == [CtVariableReadImpl]i) [CtBlockImpl]{
                        [CtInvocationImpl][CtVariableReadImpl]iter.remove();
                    }
                }
            }
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Attempts to reload any empty weapons with the first ammo found
     */
    public [CtTypeReferenceImpl]void reloadEmptyWeapons() [CtBlockImpl]{
        [CtForEachImpl][CtCommentImpl]// try to reload weapons
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted : [CtInvocationImpl]getTotalWeaponList()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.WeaponType wtype = [CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.WeaponType) ([CtVariableReadImpl]mounted.getType()));
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]wtype.getAmmoType() != [CtFieldReadImpl]AmmoType.T_NA) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]mounted.getLinked() == [CtLiteralImpl]null) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getLinked().getUsableShotsLeft() <= [CtLiteralImpl]0)) || [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getLinked().isDumping()) [CtBlockImpl]{
                    [CtInvocationImpl]loadWeaponWithSameAmmo([CtVariableReadImpl]mounted);
                }
            }
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Return the currently operable AMS mounted in this Entity.
     *
     * @return  */
    public [CtTypeReferenceImpl]java.util.List<[CtTypeReferenceImpl]megamek.common.Mounted> getActiveAMS() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.Mounted> ams = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.ArrayList<>();
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted weapon : [CtInvocationImpl]getWeaponList()) [CtBlockImpl]{
            [CtIfImpl][CtCommentImpl]// Skip anything that's not AMS
            if ([CtUnaryOperatorImpl]![CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]weapon.getType().hasFlag([CtTypeAccessImpl]WeaponType.F_AMS)) [CtBlockImpl]{
                [CtContinueImpl]continue;
            }
            [CtIfImpl][CtCommentImpl]// Make sure the AMS is good to go
            if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]weapon.isReady()) || [CtInvocationImpl][CtVariableReadImpl]weapon.isMissing()) || [CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]weapon.curMode().equals([CtTypeAccessImpl]Weapon.MODE_AMS_ON))) [CtBlockImpl]{
                [CtContinueImpl]continue;
            }
            [CtIfImpl][CtCommentImpl]// AMS blocked by transported units can not fire
            if ([CtInvocationImpl]isWeaponBlockedAt([CtInvocationImpl][CtVariableReadImpl]weapon.getLocation(), [CtInvocationImpl][CtVariableReadImpl]weapon.isRearMounted())) [CtBlockImpl]{
                [CtContinueImpl]continue;
            }
            [CtLocalVariableImpl][CtCommentImpl]// Make sure ammo is loaded
            [CtTypeReferenceImpl]boolean baAPDS = [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.BattleArmor) && [CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]weapon.getType().getInternalName().equals([CtLiteralImpl]"ISBAAPDS");
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted ammo = [CtInvocationImpl][CtVariableReadImpl]weapon.getLinked();
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]weapon.getType().hasFlag([CtTypeAccessImpl]WeaponType.F_ENERGY)) && [CtUnaryOperatorImpl](![CtVariableReadImpl]baAPDS)) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]ammo == [CtLiteralImpl]null) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]ammo.getUsableShotsLeft() == [CtLiteralImpl]0)) || [CtInvocationImpl][CtVariableReadImpl]ammo.isDumping())) [CtBlockImpl]{
                [CtInvocationImpl]loadWeapon([CtVariableReadImpl]weapon);
                [CtAssignmentImpl][CtVariableWriteImpl]ammo = [CtInvocationImpl][CtVariableReadImpl]weapon.getLinked();
            }
            [CtIfImpl][CtCommentImpl]// try again
            if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]weapon.getType().hasFlag([CtTypeAccessImpl]WeaponType.F_ENERGY)) && [CtUnaryOperatorImpl](![CtVariableReadImpl]baAPDS)) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]ammo == [CtLiteralImpl]null) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]ammo.getUsableShotsLeft() == [CtLiteralImpl]0)) || [CtInvocationImpl][CtVariableReadImpl]ammo.isDumping())) [CtBlockImpl]{
                [CtContinueImpl][CtCommentImpl]// No ammo for this AMS.
                continue;
            }
            [CtInvocationImpl][CtVariableReadImpl]ams.add([CtVariableReadImpl]weapon);
        }
        [CtReturnImpl]return [CtVariableReadImpl]ams;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Assign AMS systems to incoming telemissile attacks. This
     * allows AMS bays to work against these modified physical attacks
     */
    public [CtTypeReferenceImpl]void assignTMAMS([CtParameterImpl][CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.actions.AttackAction> vTMAttacks) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.HashSet<[CtTypeReferenceImpl]megamek.common.actions.AttackAction> targets = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.HashSet<[CtTypeReferenceImpl]megamek.common.actions.AttackAction>();
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted ams : [CtInvocationImpl]getActiveAMS()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtCommentImpl]// make a new vector of only incoming attacks in arc
            [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.actions.TeleMissileAttackAction> vTMAttacksInArc = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.actions.TeleMissileAttackAction>([CtInvocationImpl][CtVariableReadImpl]vTMAttacks.size());
            [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.actions.AttackAction aa : [CtVariableReadImpl]vTMAttacks) [CtBlockImpl]{
                [CtLocalVariableImpl][CtCommentImpl]// We already made sure these are all telemissile attacks in Server
                [CtTypeReferenceImpl]megamek.common.actions.TeleMissileAttackAction taa = [CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.actions.TeleMissileAttackAction) (aa));
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]targets.contains([CtVariableReadImpl]taa)) && [CtInvocationImpl][CtTypeAccessImpl]megamek.common.Compute.isInArc([CtFieldReadImpl]game, [CtInvocationImpl]getId(), [CtInvocationImpl]getEquipmentNum([CtVariableReadImpl]ams), [CtInvocationImpl][CtFieldReadImpl]game.getEntity([CtInvocationImpl][CtVariableReadImpl]taa.getEntityId()))) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]vTMAttacksInArc.addElement([CtVariableReadImpl]taa);
                }
            }
            [CtIfImpl][CtCommentImpl]// AMS Bays can fire at all incoming attacks each round
            [CtCommentImpl]// Point defense bays are added too. If they haven't fired
            [CtCommentImpl]// at something else already, they can attack now.
            if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]ams.getType().hasFlag([CtTypeAccessImpl]WeaponType.F_AMSBAY) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]ams.getType().hasFlag([CtTypeAccessImpl]WeaponType.F_PDBAY) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]ams.isUsedThisRound()))) [CtBlockImpl]{
                [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.actions.TeleMissileAttackAction taa : [CtVariableReadImpl]vTMAttacksInArc) [CtBlockImpl]{
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]taa != [CtLiteralImpl]null) [CtBlockImpl]{
                        [CtInvocationImpl][CtVariableReadImpl]taa.addCounterEquipment([CtVariableReadImpl]ams);
                    }
                }
            }
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Assign AMS systems to the most dangerous incoming missile attacks. This
     * should only be called once per turn, or AMS will get extra attacks
     */
    public [CtTypeReferenceImpl]void assignAMS([CtParameterImpl][CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.weapons.WeaponHandler> vAttacks) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.HashSet<[CtTypeReferenceImpl]megamek.common.actions.WeaponAttackAction> targets = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.HashSet<[CtTypeReferenceImpl]megamek.common.actions.WeaponAttackAction>();
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted ams : [CtInvocationImpl]getActiveAMS()) [CtBlockImpl]{
            [CtIfImpl][CtCommentImpl]// Ignore APDS, it gets assigned elsewhere
            if ([CtInvocationImpl][CtVariableReadImpl]ams.isAPDS()) [CtBlockImpl]{
                [CtContinueImpl]continue;
            }
            [CtLocalVariableImpl][CtCommentImpl]// make a new vector of only incoming attacks in arc
            [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.actions.WeaponAttackAction> vAttacksInArc = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.actions.WeaponAttackAction>([CtInvocationImpl][CtVariableReadImpl]vAttacks.size());
            [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.weapons.WeaponHandler wr : [CtVariableReadImpl]vAttacks) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]wr instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.CapitalMissileBearingsOnlyHandler) [CtBlockImpl]{
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]targets.contains([CtFieldReadImpl][CtVariableReadImpl]wr.waa)) && [CtInvocationImpl][CtTypeAccessImpl]megamek.common.Compute.isInArc([CtFieldReadImpl]game, [CtInvocationImpl]getId(), [CtInvocationImpl]getEquipmentNum([CtVariableReadImpl]ams), [CtInvocationImpl][CtFieldReadImpl]game.getTarget([CtInvocationImpl][CtFieldReadImpl][CtVariableReadImpl]wr.waa.getOriginalTargetType(), [CtInvocationImpl][CtFieldReadImpl][CtVariableReadImpl]wr.waa.getOriginalTargetId()))) [CtBlockImpl]{
                        [CtInvocationImpl][CtVariableReadImpl]vAttacksInArc.addElement([CtFieldReadImpl][CtVariableReadImpl]wr.waa);
                    }
                } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]targets.contains([CtFieldReadImpl][CtVariableReadImpl]wr.waa)) && [CtInvocationImpl][CtTypeAccessImpl]megamek.common.Compute.isInArc([CtFieldReadImpl]game, [CtInvocationImpl]getId(), [CtInvocationImpl]getEquipmentNum([CtVariableReadImpl]ams), [CtInvocationImpl][CtFieldReadImpl]game.getEntity([CtInvocationImpl][CtFieldReadImpl][CtVariableReadImpl]wr.waa.getEntityId()))) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]vAttacksInArc.addElement([CtFieldReadImpl][CtVariableReadImpl]wr.waa);
                }
            }
            [CtIfImpl][CtCommentImpl]// AMS Bays can fire at all incoming attacks each round
            [CtCommentImpl]// So can standard AMS if the unofficial option is turned on
            if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]ams.getType().hasFlag([CtTypeAccessImpl]WeaponType.F_AMSBAY) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVCOMBAT_MULTI_USE_AMS) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]ams.getType().hasFlag([CtTypeAccessImpl]WeaponType.F_AMS))) [CtBlockImpl]{
                [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.actions.WeaponAttackAction waa : [CtVariableReadImpl]vAttacksInArc) [CtBlockImpl]{
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]waa != [CtLiteralImpl]null) [CtBlockImpl]{
                        [CtInvocationImpl][CtVariableReadImpl]waa.addCounterEquipment([CtVariableReadImpl]ams);
                    }
                }
            } else [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]ams.getType().hasFlag([CtTypeAccessImpl]WeaponType.F_PDBAY)) [CtBlockImpl]{
                [CtLocalVariableImpl][CtCommentImpl]// Point defense bays are assigned to the attack with the greatest threat
                [CtCommentImpl]// Unlike single AMS, PD bays can gang up on 1 attack
                [CtTypeReferenceImpl]megamek.common.actions.WeaponAttackAction waa = [CtInvocationImpl][CtTypeAccessImpl]megamek.common.Compute.getHighestExpectedDamage([CtFieldReadImpl]game, [CtVariableReadImpl]vAttacksInArc, [CtLiteralImpl]true);
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]waa != [CtLiteralImpl]null) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]waa.addCounterEquipment([CtVariableReadImpl]ams);
                }
            } else [CtBlockImpl]{
                [CtLocalVariableImpl][CtCommentImpl]// Otherwise, find the most dangerous salvo by expected damage and target it
                [CtCommentImpl]// this ensures that only 1 AMS targets the strike. Use for non-bays.
                [CtTypeReferenceImpl]megamek.common.actions.WeaponAttackAction waa = [CtInvocationImpl][CtTypeAccessImpl]megamek.common.Compute.getHighestExpectedDamage([CtFieldReadImpl]game, [CtVariableReadImpl]vAttacksInArc, [CtLiteralImpl]true);
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]waa != [CtLiteralImpl]null) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]waa.addCounterEquipment([CtVariableReadImpl]ams);
                    [CtInvocationImpl][CtVariableReadImpl]targets.add([CtVariableReadImpl]waa);
                }
            }
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * has the team attached a narc pod to me?
     */
    public [CtTypeReferenceImpl]boolean isNarcedBy([CtParameterImpl][CtTypeReferenceImpl]int nTeamID) [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.NarcPod p : [CtFieldReadImpl]narcPods) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]p.getTeam() == [CtVariableReadImpl]nTeamID) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * add a narc pod from this team to the mech. Unremovable
     *
     * @param pod
     * 		The <code>NarcPod</code> to be attached.
     */
    public [CtTypeReferenceImpl]void attachNarcPod([CtParameterImpl][CtTypeReferenceImpl]megamek.common.NarcPod pod) [CtBlockImpl]{
        [CtInvocationImpl][CtFieldReadImpl]pendingNarcPods.add([CtVariableReadImpl]pod);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * attach an iNarcPod
     *
     * @param pod
     * 		The <code>INarcPod</code> to be attached.
     */
    public [CtTypeReferenceImpl]void attachINarcPod([CtParameterImpl][CtTypeReferenceImpl]megamek.common.INarcPod pod) [CtBlockImpl]{
        [CtInvocationImpl][CtFieldReadImpl]pendingINarcPods.add([CtVariableReadImpl]pod);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Have we been iNarced with a homing pod from that team?
     *
     * @param nTeamID
     * 		The id of the team that we are wondering about.
     * @return true if the Entity is narced by that team.
     */
    public [CtTypeReferenceImpl]boolean isINarcedBy([CtParameterImpl][CtTypeReferenceImpl]int nTeamID) [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.INarcPod pod : [CtFieldReadImpl]iNarcPods) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]pod.getTeam() == [CtVariableReadImpl]nTeamID) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]pod.getType() == [CtFieldReadImpl]INarcPod.HOMING)) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Have we been iNarced with the named pod from any team?
     *
     * @param type
     * 		the <code>int</code> type of iNarc pod.
     * @return <code>true</code> if we have.
     */
    public [CtTypeReferenceImpl]boolean isINarcedWith([CtParameterImpl][CtTypeReferenceImpl]long type) [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.INarcPod pod : [CtFieldReadImpl]iNarcPods) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]pod.getType() == [CtVariableReadImpl]type) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Remove all attached iNarc Pods
     */
    public [CtTypeReferenceImpl]void removeAllINarcPods() [CtBlockImpl]{
        [CtInvocationImpl][CtFieldReadImpl]iNarcPods.clear();
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Do we have any iNarc Pods attached?
     *
     * @return true iff one or more iNarcPods are attached.
     */
    public [CtTypeReferenceImpl]boolean hasINarcPodsAttached() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtFieldReadImpl]iNarcPods.size() > [CtLiteralImpl]0) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]true;
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Get an <code>Enumeration</code> of <code>INarcPod</code>s that are
     * attached to this entity.
     *
     * @return an <code>Enumeration</code> of <code>INarcPod</code>s.
     */
    public [CtTypeReferenceImpl]java.util.Iterator<[CtTypeReferenceImpl]megamek.common.INarcPod> getINarcPodsAttached() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]iNarcPods.iterator();
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Remove an <code>INarcPod</code> from this entity.
     *
     * @param pod
     * 		the <code>INarcPod</code> to be removed.
     * @return <code>true</code> if the pod was removed, <code>false</code> if
    the pod was not attached to this entity.
     */
    public [CtTypeReferenceImpl]boolean removeINarcPod([CtParameterImpl][CtTypeReferenceImpl]megamek.common.INarcPod pod) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]iNarcPods.remove([CtVariableReadImpl]pod);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Calculates the battle value of this entity
     */
    public abstract [CtTypeReferenceImpl]int calculateBattleValue();

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean useGeometricMeanBV() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtFieldReadImpl]useGeometricBV || [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtFieldReadImpl]game != [CtLiteralImpl]null) && [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVANCED_GEOMETRIC_MEAN_BV));
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean useReducedOverheatModifierBV() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtFieldReadImpl]useReducedOverheatModifierBV || [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtFieldReadImpl]game != [CtLiteralImpl]null) && [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVANCED_REDUCED_OVERHEAT_MODIFIER_BV));
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Calculates the battle value of this mech. If the parameter is true, then
     * the battle value for c3 will be added whether the mech is currently part
     * of a network or not. This should be overwritten if necessary
     *
     * @param ignoreC3
     * 		if the contribution of the C3 computer should be ignored when
     * 		calculating BV.
     * @param ignorePilot
     * 		if the extra BV due to piloting skill should be ignore, needed
     * 		for c3 bv
     */
    public [CtTypeReferenceImpl]int calculateBattleValue([CtParameterImpl][CtTypeReferenceImpl]boolean ignoreC3, [CtParameterImpl][CtTypeReferenceImpl]boolean ignorePilot) [CtBlockImpl]{
        [CtIfImpl]if ([CtFieldReadImpl]useManualBV) [CtBlockImpl]{
            [CtReturnImpl]return [CtFieldReadImpl]manualBV;
        }
        [CtReturnImpl]return [CtInvocationImpl]calculateBattleValue();
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Generates a vector containing reports on all useful information about
     * this entity.
     */
    public abstract [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Report> victoryReport();

    [CtMethodImpl][CtJavaDocImpl]/**
     * Two entities are equal if their ids are equal
     */
    [CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]boolean equals([CtParameterImpl][CtTypeReferenceImpl]java.lang.Object obj) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtThisAccessImpl]this == [CtVariableReadImpl]obj) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]true;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtLiteralImpl]null == [CtVariableReadImpl]obj) || [CtBinaryOperatorImpl]([CtInvocationImpl]getClass() != [CtInvocationImpl][CtVariableReadImpl]obj.getClass())) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtLocalVariableImpl]final [CtTypeReferenceImpl]megamek.common.Entity other = [CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.Entity) (obj));
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtFieldReadImpl]id == [CtFieldReadImpl][CtVariableReadImpl]other.id;
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]int hashCode() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]id;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Get the movement mode of the entity
     */
    public [CtTypeReferenceImpl]megamek.common.EntityMovementMode getMovementMode() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]movementMode;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Get the movement mode of the entity as a String.
     */
    public [CtTypeReferenceImpl]java.lang.String getMovementModeAsString() [CtBlockImpl]{
        [CtSwitchImpl]switch ([CtInvocationImpl]getMovementMode()) {
            [CtCaseImpl]case [CtFieldReadImpl]megamek.common.Entity.NONE :
                [CtReturnImpl]return [CtLiteralImpl]"None";
            [CtCaseImpl]case [CtFieldReadImpl]BIPED :
            [CtCaseImpl]case [CtFieldReadImpl]BIPED_SWIM :
                [CtReturnImpl]return [CtLiteralImpl]"Biped";
            [CtCaseImpl]case [CtFieldReadImpl]QUAD :
            [CtCaseImpl]case [CtFieldReadImpl]QUAD_SWIM :
                [CtReturnImpl]return [CtLiteralImpl]"Quad";
            [CtCaseImpl]case [CtFieldReadImpl]TRACKED :
                [CtReturnImpl]return [CtLiteralImpl]"Tracked";
            [CtCaseImpl]case [CtFieldReadImpl]WHEELED :
                [CtReturnImpl]return [CtLiteralImpl]"Wheeled";
            [CtCaseImpl]case [CtFieldReadImpl]HOVER :
                [CtReturnImpl]return [CtLiteralImpl]"Hover";
            [CtCaseImpl]case [CtFieldReadImpl]VTOL :
                [CtReturnImpl]return [CtLiteralImpl]"VTOL";
            [CtCaseImpl]case [CtFieldReadImpl]NAVAL :
                [CtReturnImpl]return [CtLiteralImpl]"Naval";
            [CtCaseImpl]case [CtFieldReadImpl]HYDROFOIL :
                [CtReturnImpl]return [CtLiteralImpl]"Hydrofoil";
            [CtCaseImpl]case [CtFieldReadImpl]SUBMARINE :
                [CtReturnImpl]return [CtLiteralImpl]"Submarine";
            [CtCaseImpl]case [CtFieldReadImpl]INF_UMU :
                [CtReturnImpl]return [CtLiteralImpl]"UMU";
            [CtCaseImpl]case [CtFieldReadImpl]INF_LEG :
                [CtReturnImpl]return [CtLiteralImpl]"Leg";
            [CtCaseImpl]case [CtFieldReadImpl]INF_MOTORIZED :
                [CtReturnImpl]return [CtLiteralImpl]"Motorized";
            [CtCaseImpl]case [CtFieldReadImpl]INF_JUMP :
                [CtReturnImpl]return [CtLiteralImpl]"Jump";
            [CtCaseImpl]case [CtFieldReadImpl]WIGE :
                [CtReturnImpl]return [CtLiteralImpl]"WiGE";
            [CtCaseImpl]case [CtFieldReadImpl]AERODYNE :
                [CtReturnImpl]return [CtLiteralImpl]"Aerodyne";
            [CtCaseImpl]case [CtFieldReadImpl]SPHEROID :
                [CtReturnImpl]return [CtLiteralImpl]"Spheroid";
            [CtCaseImpl]case [CtFieldReadImpl]RAIL :
                [CtReturnImpl]return [CtLiteralImpl]"Rail";
            [CtCaseImpl]case [CtFieldReadImpl]MAGLEV :
                [CtReturnImpl]return [CtLiteralImpl]"MagLev";
            [CtCaseImpl]case [CtFieldReadImpl]STATION_KEEPING :
                [CtReturnImpl]return [CtLiteralImpl]"Station-Keeping";
            [CtCaseImpl]default :
                [CtReturnImpl]return [CtLiteralImpl]"ERROR";
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Set the movement type of the entity
     */
    public [CtTypeReferenceImpl]void setMovementMode([CtParameterImpl][CtTypeReferenceImpl]megamek.common.EntityMovementMode movementMode) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.movementMode = [CtVariableReadImpl]movementMode;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Helper function to determine if a entity is a biped
     */
    public [CtTypeReferenceImpl]boolean entityIsBiped() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtInvocationImpl]getMovementMode() == [CtFieldReadImpl]EntityMovementMode.BIPED;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Helper function to determine if a entity is a quad
     */
    public [CtTypeReferenceImpl]boolean entityIsQuad() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtInvocationImpl]getMovementMode() == [CtFieldReadImpl]EntityMovementMode.QUAD;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns true is the entity needs a roll to stand up
     */
    public [CtTypeReferenceImpl]boolean needsRollToStand() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]true;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns an entity's base piloting skill roll needed Only use this version
     * if the entity is through processing movement
     */
    public [CtTypeReferenceImpl]megamek.common.PilotingRollData getBasePilotingRoll() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getBasePilotingRoll([CtFieldReadImpl]moved);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns an entity's base piloting skill roll needed
     */
    public [CtTypeReferenceImpl]megamek.common.PilotingRollData getBasePilotingRoll([CtParameterImpl][CtTypeReferenceImpl]megamek.common.EntityMovementType moveType) [CtBlockImpl]{
        [CtLocalVariableImpl]final [CtTypeReferenceImpl]int entityId = [CtInvocationImpl]getId();
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.PilotingRollData roll;
        [CtIfImpl][CtCommentImpl]// Crew dead?
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl]getCrew().isDead() || [CtInvocationImpl][CtInvocationImpl]getCrew().isDoomed()) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl]getCrew().getHits() >= [CtLiteralImpl]6)) [CtBlockImpl]{
            [CtReturnImpl][CtCommentImpl]// Following line switched from impossible to automatic failure
            [CtCommentImpl]// -- bug fix for dead units taking PSRs
            return [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtVariableReadImpl]entityId, [CtFieldReadImpl]TargetRoll.AUTOMATIC_FAIL, [CtLiteralImpl]"Pilot dead");
        } else [CtIfImpl]if ([CtUnaryOperatorImpl]![CtInvocationImpl][CtInvocationImpl]getCrew().isActive()) [CtBlockImpl]{
            [CtReturnImpl]return [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtVariableReadImpl]entityId, [CtFieldReadImpl]TargetRoll.IMPOSSIBLE, [CtLiteralImpl]"Pilot unconscious");
        }
        [CtIfImpl][CtCommentImpl]// gyro operational? does not apply if using tracked/quadvee vehicle/lam fighter movement
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]isGyroDestroyed() && [CtInvocationImpl]canFall()) && [CtBinaryOperatorImpl]([CtVariableReadImpl]moveType != [CtFieldReadImpl]EntityMovementType.MOVE_VTOL_WALK)) && [CtBinaryOperatorImpl]([CtVariableReadImpl]moveType != [CtFieldReadImpl]EntityMovementType.MOVE_VTOL_RUN)) [CtBlockImpl]{
            [CtReturnImpl]return [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtVariableReadImpl]entityId, [CtFieldReadImpl]TargetRoll.AUTOMATIC_FAIL, [CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl]getCrew().getPiloting() + [CtLiteralImpl]6, [CtLiteralImpl]"Gyro destroyed");
        }
        [CtIfImpl][CtCommentImpl]// both legs present?
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.BipedMech) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtThisAccessImpl](([CtTypeReferenceImpl]megamek.common.BipedMech) (this)).countBadLegs() == [CtLiteralImpl]2)) && [CtBinaryOperatorImpl]([CtVariableReadImpl]moveType != [CtFieldReadImpl]EntityMovementType.MOVE_VTOL_WALK)) && [CtBinaryOperatorImpl]([CtVariableReadImpl]moveType != [CtFieldReadImpl]EntityMovementType.MOVE_VTOL_RUN)) [CtBlockImpl]{
            [CtReturnImpl]return [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtVariableReadImpl]entityId, [CtFieldReadImpl]TargetRoll.AUTOMATIC_FAIL, [CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl]getCrew().getPiloting() + [CtLiteralImpl]10, [CtLiteralImpl]"Both legs destroyed");
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.QuadMech) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtThisAccessImpl](([CtTypeReferenceImpl]megamek.common.QuadMech) (this)).countBadLegs() >= [CtLiteralImpl]3) [CtBlockImpl]{
                [CtReturnImpl]return [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtVariableReadImpl]entityId, [CtFieldReadImpl]TargetRoll.AUTOMATIC_FAIL, [CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl]getCrew().getPiloting() + [CtBinaryOperatorImpl]([CtInvocationImpl][CtThisAccessImpl](([CtTypeReferenceImpl]megamek.common.Mech) (this)).countBadLegs() * [CtLiteralImpl]5), [CtBinaryOperatorImpl][CtInvocationImpl][CtThisAccessImpl](([CtTypeReferenceImpl]megamek.common.Mech) (this)).countBadLegs() + [CtLiteralImpl]" legs destroyed");
            }
        }
        [CtIfImpl][CtCommentImpl]// entity shut down?
        if ([CtBinaryOperatorImpl][CtInvocationImpl]isShutDown() && [CtInvocationImpl]isShutDownThisPhase()) [CtBlockImpl]{
            [CtReturnImpl]return [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtVariableReadImpl]entityId, [CtFieldReadImpl]TargetRoll.AUTOMATIC_FAIL, [CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl]getCrew().getPiloting() + [CtLiteralImpl]3, [CtLiteralImpl]"Reactor shut down");
        } else [CtIfImpl]if ([CtInvocationImpl]isShutDown()) [CtBlockImpl]{
            [CtReturnImpl]return [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtVariableReadImpl]entityId, [CtFieldReadImpl]TargetRoll.AUTOMATIC_FAIL, [CtFieldReadImpl]TargetRoll.IMPOSSIBLE, [CtLiteralImpl]"Reactor shut down");
        }
        [CtAssignmentImpl][CtCommentImpl]// okay, let's figure out the stuff then
        [CtVariableWriteImpl]roll = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtVariableReadImpl]entityId, [CtInvocationImpl][CtInvocationImpl]getCrew().getPiloting([CtVariableReadImpl]moveType), [CtLiteralImpl]"Base piloting skill");
        [CtAssignmentImpl][CtCommentImpl]// Let's see if we have a modifier to our piloting skill roll. We'll
        [CtCommentImpl]// pass in the roll
        [CtCommentImpl]// object and adjust as necessary
        [CtVariableWriteImpl]roll = [CtInvocationImpl]addEntityBonuses([CtVariableReadImpl]roll);
        [CtAssignmentImpl][CtCommentImpl]// add planetary condition modifiers
        [CtVariableWriteImpl]roll = [CtInvocationImpl]addConditionBonuses([CtVariableReadImpl]roll, [CtVariableReadImpl]moveType);
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]isCarefulStand() && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]getWalkMP() - [CtFieldReadImpl]mpUsed) > [CtLiteralImpl]2)) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtUnaryOperatorImpl]-[CtLiteralImpl]2, [CtLiteralImpl]"careful stand");
        }
        [CtIfImpl]if ([CtInvocationImpl]hasQuirk([CtTypeAccessImpl]OptionsConstants.QUIRK_NEG_HARD_PILOT)) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtUnaryOperatorImpl]+[CtLiteralImpl]1, [CtLiteralImpl]"hard to pilot");
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]getPartialRepairs() != [CtLiteralImpl]null) [CtBlockImpl]{
            [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl]getPartialRepairs().booleanOption([CtLiteralImpl]"mech_gyro_1_crit")) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtUnaryOperatorImpl]+[CtLiteralImpl]1, [CtLiteralImpl]"Partial repair of Gyro (+1)");
            }
            [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl]getPartialRepairs().booleanOption([CtLiteralImpl]"mech_gyro_2_crit")) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtUnaryOperatorImpl]+[CtLiteralImpl]1, [CtLiteralImpl]"Partial repair of Gyro (+2)");
            }
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVANCED_TACOPS_FATIGUE) && [CtInvocationImpl][CtFieldReadImpl]crew.isPilotingFatigued()) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtLiteralImpl]1, [CtLiteralImpl]"fatigue");
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]taserInterference > [CtLiteralImpl]0) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtFieldReadImpl]taserInterference, [CtLiteralImpl]"taser interference");
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtFieldReadImpl]game.getPhase() == [CtFieldReadImpl]megamek.common.IGame.Phase.PHASE_MOVEMENT) && [CtInvocationImpl]isPowerReverse()) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtLiteralImpl]1, [CtLiteralImpl]"power reverse");
        }
        [CtReturnImpl]return [CtVariableReadImpl]roll;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Add in any piloting skill mods
     */
    public abstract [CtTypeReferenceImpl]megamek.common.PilotingRollData addEntityBonuses([CtParameterImpl][CtTypeReferenceImpl]megamek.common.PilotingRollData roll);

    [CtMethodImpl][CtJavaDocImpl]/**
     * Add in any modifiers due to global conditions like light/weather/etc.
     */
    public [CtTypeReferenceImpl]megamek.common.PilotingRollData addConditionBonuses([CtParameterImpl][CtTypeReferenceImpl]megamek.common.PilotingRollData roll, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.EntityMovementType moveType) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]moveType == [CtFieldReadImpl]EntityMovementType.MOVE_SPRINT) || [CtBinaryOperatorImpl]([CtVariableReadImpl]moveType == [CtFieldReadImpl]EntityMovementType.MOVE_VTOL_SPRINT)) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtLiteralImpl]2, [CtLiteralImpl]"Sprinting");
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.PlanetaryConditions conditions = [CtInvocationImpl][CtFieldReadImpl]game.getPlanetaryConditions();
        [CtIfImpl][CtCommentImpl]// check light conditions for "running" entities
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]moveType == [CtFieldReadImpl]EntityMovementType.MOVE_RUN) || [CtBinaryOperatorImpl]([CtVariableReadImpl]moveType == [CtFieldReadImpl]EntityMovementType.MOVE_SPRINT)) || [CtBinaryOperatorImpl]([CtVariableReadImpl]moveType == [CtFieldReadImpl]EntityMovementType.MOVE_VTOL_RUN)) || [CtBinaryOperatorImpl]([CtVariableReadImpl]moveType == [CtFieldReadImpl]EntityMovementType.MOVE_OVER_THRUST)) || [CtBinaryOperatorImpl]([CtVariableReadImpl]moveType == [CtFieldReadImpl]EntityMovementType.MOVE_VTOL_SPRINT)) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]int lightPenalty = [CtInvocationImpl][CtVariableReadImpl]conditions.getLightPilotPenalty();
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]lightPenalty > [CtLiteralImpl]0) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtVariableReadImpl]lightPenalty, [CtInvocationImpl][CtVariableReadImpl]conditions.getLightDisplayableName());
            }
        }
        [CtLocalVariableImpl][CtCommentImpl]// check weather conditions for all entities
        [CtTypeReferenceImpl]int weatherMod = [CtInvocationImpl][CtVariableReadImpl]conditions.getWeatherPilotPenalty();
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]weatherMod != [CtLiteralImpl]0) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().inSpace())) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtLiteralImpl]null == [CtFieldReadImpl]crew) || [CtUnaryOperatorImpl](![CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.UNOFF_ALLWEATHER)))) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtVariableReadImpl]weatherMod, [CtInvocationImpl][CtVariableReadImpl]conditions.getWeatherDisplayableName());
        }
        [CtLocalVariableImpl][CtCommentImpl]// check wind conditions for all entities
        [CtTypeReferenceImpl]int windMod = [CtInvocationImpl][CtVariableReadImpl]conditions.getWindPilotPenalty([CtThisAccessImpl]this);
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]windMod != [CtLiteralImpl]0) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().inSpace())) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtLiteralImpl]null == [CtFieldReadImpl]crew) || [CtUnaryOperatorImpl](![CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.UNOFF_ALLWEATHER)))) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtVariableReadImpl]windMod, [CtInvocationImpl][CtVariableReadImpl]conditions.getWindDisplayableName());
        }
        [CtReturnImpl]return [CtVariableReadImpl]roll;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks if the entity is getting up. If so, returns the target roll for
     * the piloting skill check.
     */
    public [CtTypeReferenceImpl]megamek.common.PilotingRollData checkGetUp([CtParameterImpl][CtTypeReferenceImpl]megamek.common.MoveStep step, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.EntityMovementType moveType) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]step == [CtLiteralImpl]null) || [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]step.getType() != [CtFieldReadImpl]megamek.common.MovePath.MoveStepType.GET_UP) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]step.getType() != [CtFieldReadImpl]megamek.common.MovePath.MoveStepType.CAREFUL_STAND))) [CtBlockImpl]{
            [CtReturnImpl]return [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtFieldReadImpl]id, [CtFieldReadImpl]TargetRoll.CHECK_FALSE, [CtLiteralImpl]"Check false: Entity is not attempting to get up.");
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.PilotingRollData roll = [CtInvocationImpl]getBasePilotingRoll([CtVariableReadImpl]moveType);
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.BipedMech) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtThisAccessImpl](([CtTypeReferenceImpl]megamek.common.Mech) (this)).countBadLegs() >= [CtLiteralImpl]1) && [CtBinaryOperatorImpl]([CtInvocationImpl]isLocationBad([CtTypeAccessImpl]Mech.LOC_LARM) && [CtInvocationImpl]isLocationBad([CtTypeAccessImpl]Mech.LOC_RARM))) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtTypeAccessImpl]TargetRoll.IMPOSSIBLE, [CtLiteralImpl]"can't get up with destroyed leg and arms");
                [CtReturnImpl]return [CtVariableReadImpl]roll;
            }
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]isHullDown() && [CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.QuadMech)) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtTypeAccessImpl]TargetRoll.AUTOMATIC_SUCCESS, [CtLiteralImpl]"getting up from hull down");
            [CtReturnImpl]return [CtVariableReadImpl]roll;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtUnaryOperatorImpl](![CtInvocationImpl]needsRollToStand()) && [CtUnaryOperatorImpl](![CtInvocationImpl]isGyroDestroyed())) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtTypeAccessImpl]TargetRoll.AUTOMATIC_SUCCESS, [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtLiteralImpl]"\n" + [CtInvocationImpl]getDisplayName()) + [CtLiteralImpl]" does not need to make a piloting skill check ") + [CtLiteralImpl]"to stand up because it has all four of ") + [CtLiteralImpl]"its legs.");
            [CtReturnImpl]return [CtVariableReadImpl]roll;
        }
        [CtInvocationImpl][CtCommentImpl]// append the reason modifier
        [CtVariableReadImpl]roll.append([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtInvocationImpl]getId(), [CtLiteralImpl]0, [CtLiteralImpl]"getting up"));
        [CtInvocationImpl]addPilotingModifierForTerrain([CtVariableReadImpl]roll, [CtVariableReadImpl]step);
        [CtReturnImpl]return [CtVariableReadImpl]roll;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks if the entity is attempting to run with damage that would force a
     * PSR. If so, returns the target roll for the piloting skill check.
     */
    public [CtTypeReferenceImpl]megamek.common.PilotingRollData checkRunningWithDamage([CtParameterImpl][CtTypeReferenceImpl]megamek.common.EntityMovementType overallMoveType) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.PilotingRollData roll = [CtInvocationImpl]getBasePilotingRoll([CtVariableReadImpl]overallMoveType);
        [CtLocalVariableImpl][CtTypeReferenceImpl]int gyroDamage = [CtInvocationImpl]getBadCriticals([CtTypeAccessImpl]CriticalSlot.TYPE_SYSTEM, [CtTypeAccessImpl]Mech.SYSTEM_GYRO, [CtTypeAccessImpl]Mech.LOC_CT);
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]getGyroType() == [CtFieldReadImpl]Mech.GYRO_HEAVY_DUTY) [CtBlockImpl]{
            [CtUnaryOperatorImpl][CtVariableWriteImpl]gyroDamage--;[CtCommentImpl]// HD gyro ignores 1st damage

        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]overallMoveType == [CtFieldReadImpl]EntityMovementType.MOVE_RUN) || [CtBinaryOperatorImpl]([CtVariableReadImpl]overallMoveType == [CtFieldReadImpl]EntityMovementType.MOVE_SPRINT)) && [CtInvocationImpl]canFall()) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]gyroDamage > [CtLiteralImpl]0) || [CtInvocationImpl]hasHipCrit())) [CtBlockImpl]{
            [CtInvocationImpl][CtCommentImpl]// append the reason modifier
            [CtVariableReadImpl]roll.append([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtInvocationImpl]getId(), [CtLiteralImpl]0, [CtLiteralImpl]"running with damaged hip actuator or gyro"));
        } else [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtTypeAccessImpl]TargetRoll.CHECK_FALSE, [CtLiteralImpl]"Check false: Entity is not attempting to run with damage");
        }
        [CtInvocationImpl]addPilotingModifierForTerrain([CtVariableReadImpl]roll);
        [CtReturnImpl]return [CtVariableReadImpl]roll;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks if the entity is attempting to sprint with MASC engaged. If so,
     * returns the target roll for the piloting skill check.
     */
    public [CtTypeReferenceImpl]megamek.common.PilotingRollData checkSprintingWithMASC([CtParameterImpl][CtTypeReferenceImpl]megamek.common.EntityMovementType overallMoveType, [CtParameterImpl][CtTypeReferenceImpl]int used) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.PilotingRollData roll = [CtInvocationImpl]getBasePilotingRoll([CtVariableReadImpl]overallMoveType);
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]overallMoveType == [CtFieldReadImpl]EntityMovementType.MOVE_SPRINT) || [CtBinaryOperatorImpl]([CtVariableReadImpl]overallMoveType == [CtFieldReadImpl]EntityMovementType.MOVE_VTOL_SPRINT)) && [CtBinaryOperatorImpl]([CtVariableReadImpl]used > [CtInvocationImpl](([CtTypeReferenceImpl]int) ([CtTypeAccessImpl]java.lang.Math.ceil([CtBinaryOperatorImpl][CtLiteralImpl]2.0 * [CtInvocationImpl][CtThisAccessImpl]this.getWalkMP()))))) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.append([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtInvocationImpl]getId(), [CtLiteralImpl]0, [CtLiteralImpl]"sprinting with active MASC/Supercharger"));
        } else [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtTypeAccessImpl]TargetRoll.CHECK_FALSE, [CtLiteralImpl]"Check false: Entity is not attempting to sprint with MASC");
        }
        [CtInvocationImpl]addPilotingModifierForTerrain([CtVariableReadImpl]roll);
        [CtReturnImpl]return [CtVariableReadImpl]roll;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks if the entity is attempting to sprint with supercharger engaged.
     * If so, returns the target roll for the piloting skill check.
     */
    public [CtTypeReferenceImpl]megamek.common.PilotingRollData checkSprintingWithSupercharger([CtParameterImpl][CtTypeReferenceImpl]megamek.common.EntityMovementType overallMoveType, [CtParameterImpl][CtTypeReferenceImpl]int used) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.PilotingRollData roll = [CtInvocationImpl]getBasePilotingRoll([CtVariableReadImpl]overallMoveType);
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]overallMoveType == [CtFieldReadImpl]EntityMovementType.MOVE_SPRINT) || [CtBinaryOperatorImpl]([CtVariableReadImpl]overallMoveType == [CtFieldReadImpl]EntityMovementType.MOVE_VTOL_SPRINT)) && [CtBinaryOperatorImpl]([CtVariableReadImpl]used > [CtInvocationImpl](([CtTypeReferenceImpl]int) ([CtTypeAccessImpl]java.lang.Math.ceil([CtBinaryOperatorImpl][CtLiteralImpl]2.5 * [CtInvocationImpl][CtThisAccessImpl]this.getWalkMP()))))) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.append([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtInvocationImpl]getId(), [CtLiteralImpl]0, [CtLiteralImpl]"sprinting with active MASC/Supercharger"));
        } else [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtTypeAccessImpl]TargetRoll.CHECK_FALSE, [CtLiteralImpl]"Check false: Entity is not attempting to sprint with Supercharger");
        }
        [CtInvocationImpl]addPilotingModifierForTerrain([CtVariableReadImpl]roll);
        [CtReturnImpl]return [CtVariableReadImpl]roll;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks if the entity is attempting to sprint with supercharger engaged.
     * If so, returns the target roll for the piloting skill check.
     */
    public [CtTypeReferenceImpl]megamek.common.PilotingRollData checkUsingOverdrive([CtParameterImpl][CtTypeReferenceImpl]megamek.common.EntityMovementType overallMoveType) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.PilotingRollData roll = [CtInvocationImpl]getBasePilotingRoll([CtVariableReadImpl]overallMoveType);
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]overallMoveType == [CtFieldReadImpl]EntityMovementType.MOVE_SPRINT) || [CtBinaryOperatorImpl]([CtVariableReadImpl]overallMoveType == [CtFieldReadImpl]EntityMovementType.MOVE_VTOL_SPRINT)) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Tank) || [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.QuadVee) && [CtBinaryOperatorImpl]([CtInvocationImpl]getConversionMode() == [CtFieldReadImpl]QuadVee.CONV_MODE_VEHICLE)))) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.append([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtInvocationImpl]getId(), [CtLiteralImpl]0, [CtLiteralImpl]"using overdrive"));
        } else [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtTypeAccessImpl]TargetRoll.CHECK_FALSE, [CtLiteralImpl]"Check false: Entity is not using overdrive");
        }
        [CtReturnImpl]return [CtVariableReadImpl]roll;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks if the entity is attempting to increase two speed categories.
     * If so, returns the target roll for the piloting skill check.
     */
    public [CtTypeReferenceImpl]megamek.common.PilotingRollData checkGunningIt([CtParameterImpl][CtTypeReferenceImpl]megamek.common.EntityMovementType overallMoveType) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.PilotingRollData roll = [CtInvocationImpl]getBasePilotingRoll([CtVariableReadImpl]overallMoveType);
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVGRNDMOV_VEHICLE_ACCELERATION) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Tank) || [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.QuadVee) && [CtBinaryOperatorImpl]([CtInvocationImpl]getConversionMode() == [CtFieldReadImpl]QuadVee.CONV_MODE_VEHICLE)))) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]overallMoveType == [CtFieldReadImpl]EntityMovementType.MOVE_SPRINT) || [CtBinaryOperatorImpl]([CtVariableReadImpl]overallMoveType == [CtFieldReadImpl]EntityMovementType.MOVE_VTOL_SPRINT)) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtFieldReadImpl]movedLastRound == [CtFieldReadImpl]EntityMovementType.MOVE_WALK) || [CtBinaryOperatorImpl]([CtFieldReadImpl]movedLastRound == [CtFieldReadImpl]EntityMovementType.MOVE_VTOL_WALK))) || [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]overallMoveType == [CtFieldReadImpl]EntityMovementType.MOVE_RUN) || [CtBinaryOperatorImpl]([CtVariableReadImpl]overallMoveType == [CtFieldReadImpl]EntityMovementType.MOVE_VTOL_RUN)) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtFieldReadImpl]movedLastRound == [CtFieldReadImpl]EntityMovementType.MOVE_NONE) || [CtBinaryOperatorImpl]([CtFieldReadImpl]movedLastRound == [CtFieldReadImpl]EntityMovementType.MOVE_JUMP)) || [CtBinaryOperatorImpl]([CtFieldReadImpl]movedLastRound == [CtFieldReadImpl]EntityMovementType.MOVE_SKID)))) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]roll.append([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtInvocationImpl]getId(), [CtLiteralImpl]0, [CtLiteralImpl]"gunning it"));
                [CtReturnImpl]return [CtVariableReadImpl]roll;
            }
        }
        [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtTypeAccessImpl]TargetRoll.CHECK_FALSE, [CtLiteralImpl]"Check false: Entity is not gunning it");
        [CtReturnImpl]return [CtVariableReadImpl]roll;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks if an entity is passing through certain terrain while not moving
     * carefully
     */
    public [CtTypeReferenceImpl]megamek.common.PilotingRollData checkRecklessMove([CtParameterImpl][CtTypeReferenceImpl]megamek.common.MoveStep step, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.EntityMovementType moveType, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.IHex curHex, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords lastPos, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords curPos, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.IHex prevHex) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.PilotingRollData roll = [CtInvocationImpl]getBasePilotingRoll([CtVariableReadImpl]moveType);
        [CtIfImpl][CtCommentImpl]// no need to go further if movement is careful
        if ([CtInvocationImpl][CtVariableReadImpl]step.isCareful()) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtTypeAccessImpl]TargetRoll.CHECK_FALSE, [CtLiteralImpl]"moving carefully");
            [CtReturnImpl]return [CtVariableReadImpl]roll;
        }
        [CtLocalVariableImpl][CtCommentImpl]// this only applies in fog, night conditions, or if a hex along the
        [CtCommentImpl]// move path has ice
        [CtTypeReferenceImpl]boolean isFoggy = [CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getPlanetaryConditions().getFog() != [CtFieldReadImpl]PlanetaryConditions.FOG_NONE;
        [CtLocalVariableImpl][CtTypeReferenceImpl]boolean isDark = [CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getPlanetaryConditions().getLight() > [CtFieldReadImpl]PlanetaryConditions.L_DUSK;
        [CtIfImpl][CtCommentImpl]// if we are jumping, then no worries
        if ([CtBinaryOperatorImpl][CtVariableReadImpl]moveType == [CtFieldReadImpl]EntityMovementType.MOVE_JUMP) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtTypeAccessImpl]TargetRoll.CHECK_FALSE, [CtLiteralImpl]"jumping is not reckless?");
            [CtReturnImpl]return [CtVariableReadImpl]roll;
        }
        [CtIfImpl][CtCommentImpl]// we need to make this check on the first move forward and anytime the
        [CtCommentImpl]// hex is not clear or is a level change
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]isFoggy || [CtVariableReadImpl]isDark) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]lastPos.equals([CtVariableReadImpl]curPos))) && [CtInvocationImpl][CtVariableReadImpl]lastPos.equals([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]step.getEntity().getPosition())) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.append([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtInvocationImpl]getId(), [CtLiteralImpl]0, [CtLiteralImpl]"moving recklessly"));
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]isFoggy || [CtVariableReadImpl]isDark) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]lastPos.equals([CtVariableReadImpl]curPos))) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]curHex.movementCost([CtThisAccessImpl]this) > [CtLiteralImpl]0) || [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtLiteralImpl]null != [CtVariableReadImpl]prevHex) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]prevHex.getLevel() != [CtInvocationImpl][CtVariableReadImpl]curHex.getLevel())))) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.append([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtInvocationImpl]getId(), [CtLiteralImpl]0, [CtLiteralImpl]"moving recklessly"));
            [CtCommentImpl]// ice conditions
        } else [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]curHex.containsTerrain([CtTypeAccessImpl]Terrains.ICE)) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.append([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtInvocationImpl]getId(), [CtLiteralImpl]0, [CtLiteralImpl]"moving recklessly"));
        } else [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtTypeAccessImpl]TargetRoll.CHECK_FALSE, [CtLiteralImpl]"not moving recklessly");
        }
        [CtInvocationImpl]adjustDifficultTerrainPSRModifier([CtVariableReadImpl]roll);
        [CtReturnImpl]return [CtVariableReadImpl]roll;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks if the entity is landing (from a jump) with damage that would
     * force a PSR. If so, returns the target roll for the piloting skill check.
     */
    public [CtTypeReferenceImpl]megamek.common.PilotingRollData checkLandingWithDamage([CtParameterImpl][CtTypeReferenceImpl]megamek.common.EntityMovementType overallMoveType) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.PilotingRollData roll = [CtInvocationImpl]getBasePilotingRoll([CtVariableReadImpl]overallMoveType);
        [CtLocalVariableImpl][CtTypeReferenceImpl]int gyroHits = [CtInvocationImpl]getBadCriticals([CtTypeAccessImpl]CriticalSlot.TYPE_SYSTEM, [CtTypeAccessImpl]Mech.SYSTEM_GYRO, [CtTypeAccessImpl]Mech.LOC_CT);
        [CtIfImpl][CtCommentImpl]// Heavy duty gyro does not force PSR until second hit
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl]getGyroType() == [CtFieldReadImpl]Mech.GYRO_HEAVY_DUTY) || [CtBinaryOperatorImpl]([CtInvocationImpl]getGyroType() == [CtFieldReadImpl]Mech.GYRO_SUPERHEAVY)) [CtBlockImpl]{
            [CtUnaryOperatorImpl][CtVariableWriteImpl]gyroHits--;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]gyroHits > [CtLiteralImpl]0) || [CtInvocationImpl]hasLegActuatorCrit()) [CtBlockImpl]{
            [CtInvocationImpl][CtCommentImpl]// append the reason modifier
            [CtVariableReadImpl]roll.append([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtInvocationImpl]getId(), [CtLiteralImpl]0, [CtLiteralImpl]"landing with damaged leg actuator or gyro"));
            [CtInvocationImpl]addPilotingModifierForTerrain([CtVariableReadImpl]roll);
        } else [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtTypeAccessImpl]TargetRoll.CHECK_FALSE, [CtBinaryOperatorImpl][CtLiteralImpl]"Entity does not have gyro or leg actuator damage -- checking for purposes of determining PSR " + [CtLiteralImpl]"after jump.");
        }
        [CtReturnImpl]return [CtVariableReadImpl]roll;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks if the entity is landing (from a jump) with a prototype JJ If so,
     * returns the target roll for the piloting skill check.
     */
    public [CtTypeReferenceImpl]megamek.common.PilotingRollData checkLandingWithPrototypeJJ([CtParameterImpl][CtTypeReferenceImpl]megamek.common.EntityMovementType overallMoveType) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.PilotingRollData roll = [CtInvocationImpl]getBasePilotingRoll([CtVariableReadImpl]overallMoveType);
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]getJumpType() == [CtFieldReadImpl]Mech.JUMP_PROTOTYPE) [CtBlockImpl]{
            [CtInvocationImpl][CtCommentImpl]// append the reason modifier
            [CtVariableReadImpl]roll.append([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtInvocationImpl]getId(), [CtLiteralImpl]3, [CtLiteralImpl]"landing with prototype jump jets"));
            [CtInvocationImpl]addPilotingModifierForTerrain([CtVariableReadImpl]roll);
        } else [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtTypeAccessImpl]TargetRoll.CHECK_FALSE, [CtLiteralImpl]"Entity does not have protype jump jets -- checking for purposes of determining PSR after jump.");
        }
        [CtReturnImpl]return [CtVariableReadImpl]roll;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks if an entity is landing (from a jump) in heavy woods.
     */
    public [CtTypeReferenceImpl]megamek.common.PilotingRollData checkLandingInHeavyWoods([CtParameterImpl][CtTypeReferenceImpl]megamek.common.EntityMovementType overallMoveType, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.IHex curHex) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.PilotingRollData roll = [CtInvocationImpl]getBasePilotingRoll([CtVariableReadImpl]overallMoveType);
        [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]curHex.containsTerrain([CtTypeAccessImpl]Terrains.WOODS, [CtLiteralImpl]2)) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.append([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtInvocationImpl]getId(), [CtLiteralImpl]0, [CtLiteralImpl]"landing in heavy woods"));
            [CtInvocationImpl]addPilotingModifierForTerrain([CtVariableReadImpl]roll);
        } else [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]curHex.containsTerrain([CtTypeAccessImpl]Terrains.WOODS, [CtLiteralImpl]3)) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.append([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtInvocationImpl]getId(), [CtLiteralImpl]0, [CtLiteralImpl]"landing in ultra woods"));
            [CtInvocationImpl]addPilotingModifierForTerrain([CtVariableReadImpl]roll);
        } else [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtTypeAccessImpl]TargetRoll.CHECK_FALSE, [CtLiteralImpl]"hex does not contain heavy or ultra woods");
        }
        [CtReturnImpl]return [CtVariableReadImpl]roll;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks if the entity is landing (from a jump) on ice-covered water.
     */
    public [CtTypeReferenceImpl]megamek.common.PilotingRollData checkLandingOnIce([CtParameterImpl][CtTypeReferenceImpl]megamek.common.EntityMovementType overallMoveType, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.IHex curHex) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.PilotingRollData roll = [CtInvocationImpl]getBasePilotingRoll([CtVariableReadImpl]overallMoveType);
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]curHex.containsTerrain([CtTypeAccessImpl]Terrains.ICE) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]curHex.terrainLevel([CtTypeAccessImpl]Terrains.WATER) > [CtLiteralImpl]0)) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.append([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtInvocationImpl]getId(), [CtLiteralImpl]0, [CtLiteralImpl]"landing on ice-covered water"));
            [CtInvocationImpl]addPilotingModifierForTerrain([CtVariableReadImpl]roll);
            [CtInvocationImpl]adjustDifficultTerrainPSRModifier([CtVariableReadImpl]roll);
        } else [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtTypeAccessImpl]TargetRoll.CHECK_FALSE, [CtLiteralImpl]"hex is not covered by ice");
        }
        [CtReturnImpl]return [CtVariableReadImpl]roll;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * return a <code>PilotingRollData</code> checking for whether this Entity
     * moved too fast due to low gravity
     *
     * @param step
     * @return  */
    public [CtTypeReferenceImpl]megamek.common.PilotingRollData checkMovedTooFast([CtParameterImpl][CtTypeReferenceImpl]megamek.common.MoveStep step, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.EntityMovementType moveType) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.PilotingRollData roll = [CtInvocationImpl]getBasePilotingRoll([CtVariableReadImpl]moveType);
        [CtInvocationImpl]addPilotingModifierForTerrain([CtVariableReadImpl]roll, [CtVariableReadImpl]step);
        [CtLocalVariableImpl][CtTypeReferenceImpl]int maxSafeMP = [CtLiteralImpl]0;
        [CtSwitchImpl]switch ([CtVariableReadImpl]moveType) {
            [CtCaseImpl]case [CtFieldReadImpl]MOVE_JUMP :
                [CtAssignmentImpl][CtVariableWriteImpl]maxSafeMP = [CtInvocationImpl]getJumpMP([CtLiteralImpl]false);
                [CtBreakImpl]break;
            [CtCaseImpl]case [CtFieldReadImpl]MOVE_SPRINT :
            [CtCaseImpl]case [CtFieldReadImpl]MOVE_VTOL_SPRINT :
                [CtAssignmentImpl][CtVariableWriteImpl]maxSafeMP = [CtBinaryOperatorImpl][CtInvocationImpl]getSprintMP([CtLiteralImpl]false, [CtLiteralImpl]true, [CtLiteralImpl]true) + [CtFieldReadImpl]wigeBonus;
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]isEligibleForPavementBonus() && [CtFieldReadImpl]gotPavementBonus) [CtBlockImpl]{
                    [CtUnaryOperatorImpl][CtVariableWriteImpl]maxSafeMP++;
                }
                [CtBreakImpl]break;
            [CtCaseImpl]default :
                [CtAssignmentImpl][CtCommentImpl]// Max safe MP is based on whatever is the current maximum.
                [CtCommentImpl]// http://bg.battletech.com/forums/index.php?topic=6681.msg154097#msg154097
                [CtVariableWriteImpl]maxSafeMP = [CtBinaryOperatorImpl][CtInvocationImpl]getRunMP([CtLiteralImpl]false, [CtLiteralImpl]true, [CtLiteralImpl]true) + [CtFieldReadImpl]wigeBonus;
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]isEligibleForPavementBonus() && [CtFieldReadImpl]gotPavementBonus) [CtBlockImpl]{
                    [CtUnaryOperatorImpl][CtVariableWriteImpl]maxSafeMP++;
                }
                [CtBreakImpl]break;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]step.getMpUsed() > [CtVariableReadImpl]maxSafeMP) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.append([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtInvocationImpl]getId(), [CtLiteralImpl]0, [CtLiteralImpl]"used more MPs than at 1G possible"));
        } else [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtTypeAccessImpl]TargetRoll.CHECK_FALSE, [CtBinaryOperatorImpl][CtLiteralImpl]"Check false: Entity did not use more " + [CtLiteralImpl]"MPs walking/running than possible at 1G");
        }
        [CtReturnImpl]return [CtVariableReadImpl]roll;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks if the entity might skid on pavement. If so, returns the target
     * roll for the piloting skill check.
     */
    public [CtTypeReferenceImpl]megamek.common.PilotingRollData checkSkid([CtParameterImpl][CtTypeReferenceImpl]megamek.common.EntityMovementType moveType, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.IHex prevHex, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.EntityMovementType overallMoveType, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.MoveStep prevStep, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.MoveStep currStep, [CtParameterImpl][CtTypeReferenceImpl]int prevFacing, [CtParameterImpl][CtTypeReferenceImpl]int curFacing, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords lastPos, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords curPos, [CtParameterImpl][CtTypeReferenceImpl]boolean isInfantry, [CtParameterImpl][CtTypeReferenceImpl]int distance) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.PilotingRollData roll = [CtInvocationImpl]getBasePilotingRoll([CtVariableReadImpl]overallMoveType);
        [CtIfImpl][CtCommentImpl]// If we aren't traveling along a road, apply terrain modifiers
        if ([CtUnaryOperatorImpl]![CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]prevStep == [CtLiteralImpl]null) || [CtInvocationImpl][CtVariableReadImpl]prevStep.isPavementStep()) && [CtInvocationImpl][CtVariableReadImpl]currStep.isPavementStep())) [CtBlockImpl]{
            [CtInvocationImpl]addPilotingModifierForTerrain([CtVariableReadImpl]roll, [CtVariableReadImpl]lastPos);
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]isAirborne() || [CtInvocationImpl]isAirborneVTOLorWIGE()) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtTypeAccessImpl]TargetRoll.CHECK_FALSE, [CtLiteralImpl]"Check false: flying entities don't skid");
            [CtReturnImpl]return [CtVariableReadImpl]roll;
        }
        [CtIfImpl]if ([CtVariableReadImpl]isInfantry) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtTypeAccessImpl]TargetRoll.CHECK_FALSE, [CtLiteralImpl]"Check false: infantry don't skid");
            [CtReturnImpl]return [CtVariableReadImpl]roll;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]moveType == [CtFieldReadImpl]EntityMovementType.MOVE_JUMP) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtTypeAccessImpl]TargetRoll.CHECK_FALSE, [CtLiteralImpl]"Check false: jumping entities don't skid");
            [CtReturnImpl]return [CtVariableReadImpl]roll;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtLiteralImpl]null != [CtVariableReadImpl]prevStep) && [CtInvocationImpl][CtVariableReadImpl]prevStep.isHasJustStood()) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtTypeAccessImpl]TargetRoll.CHECK_FALSE, [CtLiteralImpl]"Check false: getting up entities don't skid");
            [CtReturnImpl]return [CtVariableReadImpl]roll;
        }
        [CtLocalVariableImpl][CtCommentImpl]/* IHex curHex = null; if (null != curPos) { curHex =
        game.getBoard().getHex(curPos); }
         */
        [CtTypeReferenceImpl]boolean prevStepPavement;
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]prevStep != [CtLiteralImpl]null) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]prevStepPavement = [CtInvocationImpl][CtVariableReadImpl]prevStep.isPavementStep();
        } else [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]prevStepPavement = [CtInvocationImpl][CtVariableReadImpl]prevHex.hasPavement();
        }
        [CtIfImpl][CtCommentImpl]// TODO: add check for elevation of pavement, road,
        [CtCommentImpl]// or bridge matches entity elevation.
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]prevHex != [CtLiteralImpl]null) && [CtInvocationImpl][CtVariableReadImpl]prevHex.containsTerrain([CtTypeAccessImpl]Terrains.ICE)) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtFieldReadImpl]movementMode != [CtFieldReadImpl]EntityMovementMode.HOVER) && [CtBinaryOperatorImpl]([CtFieldReadImpl]movementMode != [CtFieldReadImpl]EntityMovementMode.WIGE)) || [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtFieldReadImpl]movementMode == [CtFieldReadImpl]EntityMovementMode.HOVER) || [CtBinaryOperatorImpl]([CtFieldReadImpl]movementMode == [CtFieldReadImpl]EntityMovementMode.WIGE)) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getPlanetaryConditions().getWeather() == [CtFieldReadImpl]PlanetaryConditions.WE_HEAVY_SNOW) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getPlanetaryConditions().getWeather() == [CtFieldReadImpl]PlanetaryConditions.WE_BLIZZARD)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getPlanetaryConditions().getWindStrength() >= [CtFieldReadImpl]PlanetaryConditions.WI_STORM))))) && [CtBinaryOperatorImpl]([CtVariableReadImpl]prevFacing != [CtVariableReadImpl]curFacing)) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]lastPos.equals([CtVariableReadImpl]curPos))) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.append([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtInvocationImpl]getId(), [CtInvocationImpl]getMovementBeforeSkidPSRModifier([CtVariableReadImpl]distance), [CtLiteralImpl]"turning on ice"));
            [CtInvocationImpl]adjustDifficultTerrainPSRModifier([CtVariableReadImpl]roll);
            [CtReturnImpl]return [CtVariableReadImpl]roll;
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]prevStepPavement && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]overallMoveType == [CtFieldReadImpl]EntityMovementType.MOVE_RUN) || [CtBinaryOperatorImpl]([CtVariableReadImpl]overallMoveType == [CtFieldReadImpl]EntityMovementType.MOVE_SPRINT))) && [CtBinaryOperatorImpl]([CtFieldReadImpl]movementMode != [CtFieldReadImpl]EntityMovementMode.HOVER)) && [CtBinaryOperatorImpl]([CtFieldReadImpl]movementMode != [CtFieldReadImpl]EntityMovementMode.WIGE)) && [CtBinaryOperatorImpl]([CtVariableReadImpl]prevFacing != [CtVariableReadImpl]curFacing)) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]lastPos.equals([CtVariableReadImpl]curPos))) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Mech) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]roll.append([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtInvocationImpl]getId(), [CtInvocationImpl]getMovementBeforeSkidPSRModifier([CtVariableReadImpl]distance), [CtLiteralImpl]"running & turning on pavement"));
            } else [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]roll.append([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtInvocationImpl]getId(), [CtInvocationImpl]getMovementBeforeSkidPSRModifier([CtVariableReadImpl]distance), [CtLiteralImpl]"reckless driving on pavement"));
            }
            [CtInvocationImpl]adjustDifficultTerrainPSRModifier([CtVariableReadImpl]roll);
            [CtReturnImpl]return [CtVariableReadImpl]roll;
        } else [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtTypeAccessImpl]TargetRoll.CHECK_FALSE, [CtLiteralImpl]"Check false: Entity is not apparently skidding");
            [CtReturnImpl]return [CtVariableReadImpl]roll;
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks if the entity is moving into rubble. If so, returns the target
     * roll for the piloting skill check.
     */
    public [CtTypeReferenceImpl]megamek.common.PilotingRollData checkRubbleMove([CtParameterImpl][CtTypeReferenceImpl]megamek.common.MoveStep step, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.EntityMovementType moveType, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.IHex curHex, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords lastPos, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords curPos, [CtParameterImpl][CtTypeReferenceImpl]boolean isLastStep, [CtParameterImpl][CtTypeReferenceImpl]boolean isPavementStep) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.PilotingRollData roll = [CtInvocationImpl]getBasePilotingRoll([CtVariableReadImpl]moveType);
        [CtLocalVariableImpl][CtTypeReferenceImpl]boolean enteringRubble = [CtLiteralImpl]true;
        [CtInvocationImpl]addPilotingModifierForTerrain([CtVariableReadImpl]roll, [CtVariableReadImpl]curPos, [CtVariableReadImpl]enteringRubble);
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]lastPos.equals([CtVariableReadImpl]curPos)) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]moveType != [CtFieldReadImpl]EntityMovementType.MOVE_JUMP) || [CtVariableReadImpl]isLastStep)) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]curHex.terrainLevel([CtTypeAccessImpl]Terrains.RUBBLE) > [CtLiteralImpl]0)) && [CtUnaryOperatorImpl](![CtVariableReadImpl]isPavementStep)) && [CtInvocationImpl]canFall()) [CtBlockImpl]{
            [CtInvocationImpl]adjustDifficultTerrainPSRModifier([CtVariableReadImpl]roll);
            [CtIfImpl]if ([CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.PILOT_TM_MOUNTAINEER)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtUnaryOperatorImpl]-[CtLiteralImpl]1, [CtLiteralImpl]"Mountaineer");
            }
        } else [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtTypeAccessImpl]TargetRoll.CHECK_FALSE, [CtLiteralImpl]"Check false: Entity is not entering rubble");
        }
        [CtReturnImpl]return [CtVariableReadImpl]roll;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks if the entity is moving into a hex that might cause it to bog
     * down. If so, returns the target roll for the piloting skill check.
     */
    public [CtTypeReferenceImpl]megamek.common.PilotingRollData checkBogDown([CtParameterImpl][CtTypeReferenceImpl]megamek.common.MoveStep step, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.EntityMovementType moveType, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.IHex curHex, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords lastPos, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords curPos, [CtParameterImpl][CtTypeReferenceImpl]int lastElev, [CtParameterImpl][CtTypeReferenceImpl]boolean isPavementStep) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.PilotingRollData roll = [CtInvocationImpl]getBasePilotingRoll([CtVariableReadImpl]moveType);
        [CtLocalVariableImpl][CtTypeReferenceImpl]int bgMod = [CtInvocationImpl][CtVariableReadImpl]curHex.getBogDownModifier([CtInvocationImpl]getMovementMode(), [CtBinaryOperatorImpl][CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.LargeSupportTank);
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]lastPos.equals([CtVariableReadImpl]curPos)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]step.getElevation() != [CtVariableReadImpl]lastElev)) && [CtBinaryOperatorImpl]([CtVariableReadImpl]bgMod != [CtFieldReadImpl]TargetRoll.AUTOMATIC_SUCCESS)) && [CtBinaryOperatorImpl]([CtVariableReadImpl]moveType != [CtFieldReadImpl]EntityMovementType.MOVE_JUMP)) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]step.getElevation() == [CtLiteralImpl]0)) && [CtUnaryOperatorImpl](![CtVariableReadImpl]isPavementStep)) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.append([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtInvocationImpl]getId(), [CtVariableReadImpl]bgMod, [CtLiteralImpl]"avoid bogging down"));
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Mech) && [CtInvocationImpl][CtThisAccessImpl](([CtTypeReferenceImpl]megamek.common.Mech) (this)).isSuperHeavy()) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtLiteralImpl]1, [CtLiteralImpl]"superheavy mech avoiding bogging down");
            }
            [CtIfImpl]if ([CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.PILOT_TM_SWAMP_BEAST)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtUnaryOperatorImpl]-[CtLiteralImpl]1, [CtLiteralImpl]"Swamp Beast");
            }
            [CtInvocationImpl]addPilotingModifierForTerrain([CtVariableReadImpl]roll, [CtVariableReadImpl]curPos, [CtLiteralImpl]false);
            [CtInvocationImpl]adjustDifficultTerrainPSRModifier([CtVariableReadImpl]roll);
        } else [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtTypeAccessImpl]TargetRoll.CHECK_FALSE, [CtBinaryOperatorImpl][CtLiteralImpl]"Check false: Not entering bog-down terrain, " + [CtLiteralImpl]"or jumping/hovering over such terrain");
        }
        [CtReturnImpl]return [CtVariableReadImpl]roll;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks if the entity is moving into depth 1+ water. If so, returns the
     * target roll for the piloting skill check.
     */
    public [CtTypeReferenceImpl]megamek.common.PilotingRollData checkWaterMove([CtParameterImpl][CtTypeReferenceImpl]megamek.common.MoveStep step, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.EntityMovementType moveType, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.IHex curHex, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords lastPos, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords curPos, [CtParameterImpl][CtTypeReferenceImpl]boolean isPavementStep) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]curHex.terrainLevel([CtTypeAccessImpl]Terrains.WATER) > [CtLiteralImpl]0) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]step.getElevation() < [CtLiteralImpl]0)) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]lastPos.equals([CtVariableReadImpl]curPos))) && [CtBinaryOperatorImpl]([CtVariableReadImpl]moveType != [CtFieldReadImpl]EntityMovementType.MOVE_JUMP)) && [CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() != [CtFieldReadImpl]EntityMovementMode.HOVER)) && [CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() != [CtFieldReadImpl]EntityMovementMode.VTOL)) && [CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() != [CtFieldReadImpl]EntityMovementMode.NAVAL)) && [CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() != [CtFieldReadImpl]EntityMovementMode.HYDROFOIL)) && [CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() != [CtFieldReadImpl]EntityMovementMode.SUBMARINE)) && [CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() != [CtFieldReadImpl]EntityMovementMode.INF_UMU)) && [CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() != [CtFieldReadImpl]EntityMovementMode.BIPED_SWIM)) && [CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() != [CtFieldReadImpl]EntityMovementMode.QUAD_SWIM)) && [CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() != [CtFieldReadImpl]EntityMovementMode.WIGE)) && [CtInvocationImpl]canFall()) && [CtUnaryOperatorImpl](![CtVariableReadImpl]isPavementStep)) [CtBlockImpl]{
            [CtReturnImpl]return [CtInvocationImpl]checkWaterMove([CtInvocationImpl][CtVariableReadImpl]curHex.terrainLevel([CtTypeAccessImpl]Terrains.WATER), [CtVariableReadImpl]moveType);
        }
        [CtReturnImpl]return [CtInvocationImpl]checkWaterMove([CtLiteralImpl]0, [CtVariableReadImpl]moveType);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks if the entity is moving into depth 1+ water. If so, returns the
     * target roll for the piloting skill check.
     */
    public [CtTypeReferenceImpl]megamek.common.PilotingRollData checkWaterMove([CtParameterImpl][CtTypeReferenceImpl]int waterLevel, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.EntityMovementType overallMoveType) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.PilotingRollData roll = [CtInvocationImpl]getBasePilotingRoll([CtVariableReadImpl]overallMoveType);
        [CtLocalVariableImpl][CtTypeReferenceImpl]int mod;
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]waterLevel == [CtLiteralImpl]1) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]mod = [CtUnaryOperatorImpl]-[CtLiteralImpl]1;
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]waterLevel == [CtLiteralImpl]2) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]mod = [CtLiteralImpl]0;
        } else [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]mod = [CtLiteralImpl]1;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]waterLevel > [CtLiteralImpl]1) && [CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.PILOT_TM_FROGMAN)) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Mech) || [CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Protomech))) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.append([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtInvocationImpl]getId(), [CtUnaryOperatorImpl]-[CtLiteralImpl]1, [CtLiteralImpl]"Frogman"));
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]waterLevel > [CtLiteralImpl]0) [CtBlockImpl]{
            [CtInvocationImpl][CtCommentImpl]// append the reason modifier
            [CtVariableReadImpl]roll.append([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtInvocationImpl]getId(), [CtVariableReadImpl]mod, [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtLiteralImpl]"entering Depth " + [CtVariableReadImpl]waterLevel) + [CtLiteralImpl]" Water"));
            [CtInvocationImpl]adjustDifficultTerrainPSRModifier([CtVariableReadImpl]roll);
        } else [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtTypeAccessImpl]TargetRoll.CHECK_FALSE, [CtLiteralImpl]"Check false: No water here.");
        }
        [CtReturnImpl]return [CtVariableReadImpl]roll;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks if the entity is being swarmed. If so, returns the target roll for
     * the piloting skill check to dislodge them.
     */
    public [CtTypeReferenceImpl]megamek.common.PilotingRollData checkDislodgeSwarmers([CtParameterImpl][CtTypeReferenceImpl]megamek.common.MoveStep step, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.EntityMovementType moveType) [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// If we're not being swarmed, return CHECK_FALSE
        if ([CtBinaryOperatorImpl][CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE == [CtInvocationImpl]getSwarmAttackerId()) [CtBlockImpl]{
            [CtReturnImpl]return [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtInvocationImpl]getId(), [CtFieldReadImpl]TargetRoll.CHECK_FALSE, [CtLiteralImpl]"Check false: No swarmers attached");
        }
        [CtLocalVariableImpl][CtCommentImpl]// append the reason modifier
        [CtTypeReferenceImpl]megamek.common.PilotingRollData roll = [CtInvocationImpl]getBasePilotingRoll([CtVariableReadImpl]moveType);
        [CtInvocationImpl][CtVariableReadImpl]roll.append([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtInvocationImpl]getId(), [CtLiteralImpl]0, [CtLiteralImpl]"attempting to dislodge swarmers by dropping prone"));
        [CtInvocationImpl]addPilotingModifierForTerrain([CtVariableReadImpl]roll, [CtVariableReadImpl]step);
        [CtReturnImpl]return [CtVariableReadImpl]roll;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks to see if an entity is moving through building walls. Note: this
     * method returns true/false, unlike the other checkStuff() methods above.
     *
     * @return 0, no eligible building; 1, exiting; 2, entering; 3, both; 4,
    stepping on roof, 8 changing elevations within a building
     */
    public [CtTypeReferenceImpl]int checkMovementInBuilding([CtParameterImpl][CtTypeReferenceImpl]megamek.common.MoveStep step, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.MoveStep prevStep, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords curPos, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords prevPos) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]prevPos == [CtLiteralImpl]null) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]prevPos.equals([CtVariableReadImpl]curPos) && [CtUnaryOperatorImpl](![CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Protomech)))) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]0;
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.IHex curHex = [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().getHex([CtVariableReadImpl]curPos);
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.IHex prevHex = [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().getHex([CtVariableReadImpl]prevPos);
        [CtIfImpl][CtCommentImpl]// ineligible because of movement type or unit type
        if ([CtInvocationImpl]isAirborne()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]0;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Infantry) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]step.getMovementType([CtLiteralImpl]false) != [CtFieldReadImpl]EntityMovementType.MOVE_JUMP)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]0;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Protomech) && [CtBinaryOperatorImpl]([CtVariableReadImpl]prevStep != [CtLiteralImpl]null)) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]prevStep.getMovementType([CtLiteralImpl]false) == [CtFieldReadImpl]EntityMovementType.MOVE_JUMP)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]0;
        }
        [CtLocalVariableImpl][CtCommentImpl]// check for movement inside a hangar
        [CtTypeReferenceImpl]megamek.common.Building curBldg = [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().getBuildingAt([CtVariableReadImpl]curPos);
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtLiteralImpl]null != [CtVariableReadImpl]curBldg) && [CtInvocationImpl][CtVariableReadImpl]curBldg.isIn([CtVariableReadImpl]prevPos)) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]curBldg.getBldgClass() == [CtFieldReadImpl]Building.HANGAR)) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]curHex.terrainLevel([CtTypeAccessImpl]Terrains.BLDG_ELEV) > [CtInvocationImpl]height())) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]step.getElevation() < [CtInvocationImpl][CtVariableReadImpl]curHex.terrainLevel([CtTypeAccessImpl]Terrains.BLDG_ELEV))) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]0;
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]int rv = [CtLiteralImpl]0;
        [CtIfImpl][CtCommentImpl]// check current hex for building
        if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]step.getElevation() < [CtInvocationImpl][CtVariableReadImpl]curHex.terrainLevel([CtTypeAccessImpl]Terrains.BLDG_ELEV)) [CtBlockImpl]{
            [CtOperatorAssignmentImpl][CtVariableWriteImpl]rv += [CtLiteralImpl]2;
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]step.getElevation() == [CtInvocationImpl][CtVariableReadImpl]curHex.terrainLevel([CtTypeAccessImpl]Terrains.BLDG_ELEV)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]step.getElevation() == [CtInvocationImpl][CtVariableReadImpl]curHex.terrainLevel([CtTypeAccessImpl]Terrains.BRIDGE_ELEV))) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]step.getMovementType([CtLiteralImpl]false) != [CtFieldReadImpl]EntityMovementType.MOVE_JUMP)) [CtBlockImpl]{
            [CtOperatorAssignmentImpl][CtVariableWriteImpl]rv += [CtLiteralImpl]4;
        }
        [CtIfImpl][CtCommentImpl]// check previous hex for building
        if ([CtBinaryOperatorImpl][CtVariableReadImpl]prevHex != [CtLiteralImpl]null) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]int prevEl = [CtInvocationImpl]getElevation();
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]prevStep != [CtLiteralImpl]null) [CtBlockImpl]{
                [CtAssignmentImpl][CtVariableWriteImpl]prevEl = [CtInvocationImpl][CtVariableReadImpl]prevStep.getElevation();
            }
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]prevEl < [CtInvocationImpl][CtVariableReadImpl]prevHex.terrainLevel([CtTypeAccessImpl]Terrains.BLDG_ELEV)) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]curHex.terrainLevel([CtTypeAccessImpl]Terrains.BLDG_CLASS) != [CtLiteralImpl]1) || [CtBinaryOperatorImpl]([CtInvocationImpl]getHeight() >= [CtInvocationImpl][CtVariableReadImpl]curHex.terrainLevel([CtTypeAccessImpl]Terrains.BLDG_ELEV)))) [CtBlockImpl]{
                [CtOperatorAssignmentImpl][CtVariableWriteImpl]rv += [CtLiteralImpl]1;
            }
        }
        [CtIfImpl][CtCommentImpl]// check to see if its a wall
        if ([CtBinaryOperatorImpl][CtVariableReadImpl]rv > [CtLiteralImpl]1) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Building bldgEntered = [CtLiteralImpl]null;
            [CtAssignmentImpl][CtVariableWriteImpl]bldgEntered = [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().getBuildingAt([CtVariableReadImpl]curPos);
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]bldgEntered.getType() == [CtFieldReadImpl]Building.WALL) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]4;
            }
        }
        [CtIfImpl][CtCommentImpl]// Check for changing levels within a building
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]curPos.equals([CtVariableReadImpl]prevPos) && [CtBinaryOperatorImpl]([CtVariableReadImpl]curBldg != [CtLiteralImpl]null)) && [CtBinaryOperatorImpl]([CtVariableReadImpl]prevStep != [CtLiteralImpl]null)) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]step.getElevation() != [CtInvocationImpl][CtVariableReadImpl]prevStep.getElevation())) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]step.getType() == [CtFieldReadImpl]megamek.common.MovePath.MoveStepType.UP) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]step.getType() == [CtFieldReadImpl]megamek.common.MovePath.MoveStepType.DOWN))) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]rv = [CtLiteralImpl]8;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Infantry) || [CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Protomech)) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]rv != [CtLiteralImpl]2) && [CtBinaryOperatorImpl]([CtVariableReadImpl]rv != [CtLiteralImpl]8)) && [CtBinaryOperatorImpl]([CtVariableReadImpl]rv != [CtLiteralImpl]10)) [CtBlockImpl]{
                [CtAssignmentImpl][CtVariableWriteImpl]rv = [CtLiteralImpl]0;
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]rv;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Calculates and returns the roll for an entity moving in buildings.
     */
    public [CtTypeReferenceImpl]megamek.common.PilotingRollData rollMovementInBuilding([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Building bldg, [CtParameterImpl][CtTypeReferenceImpl]int distance, [CtParameterImpl][CtTypeReferenceImpl]java.lang.String why, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.EntityMovementType overallMoveType) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.PilotingRollData roll = [CtInvocationImpl]getBasePilotingRoll([CtVariableReadImpl]overallMoveType);
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Mech) && [CtInvocationImpl][CtThisAccessImpl](([CtTypeReferenceImpl]megamek.common.Mech) (this)).isSuperHeavy()) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtLiteralImpl]4, [CtLiteralImpl]"superheavy mech moving in building");
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]int mod = [CtLiteralImpl]0;
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.lang.String desc;
        [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]why.equals([CtLiteralImpl]"")) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]desc = [CtLiteralImpl]"moving through ";
        } else [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]desc = [CtBinaryOperatorImpl][CtVariableReadImpl]why + [CtLiteralImpl]" ";
        }
        [CtSwitchImpl]switch ([CtInvocationImpl][CtVariableReadImpl]bldg.getType()) {
            [CtCaseImpl]case [CtFieldReadImpl]Building.LIGHT :
                [CtAssignmentImpl][CtVariableWriteImpl]desc = [CtLiteralImpl]"Light";
                [CtBreakImpl]break;
            [CtCaseImpl]case [CtFieldReadImpl]Building.MEDIUM :
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]bldg.getBldgClass() != [CtFieldReadImpl]Building.HANGAR) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]mod = [CtLiteralImpl]1;
                    [CtAssignmentImpl][CtVariableWriteImpl]desc = [CtLiteralImpl]"Medium";
                }
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]bldg.getBldgClass() >= [CtFieldReadImpl]Building.FORTRESS) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]mod = [CtLiteralImpl]2;
                    [CtAssignmentImpl][CtVariableWriteImpl]desc = [CtBinaryOperatorImpl][CtVariableReadImpl]desc + [CtLiteralImpl]" Fortress";
                }
                [CtBreakImpl]break;
            [CtCaseImpl]case [CtFieldReadImpl]Building.HEAVY :
                [CtAssignmentImpl][CtVariableWriteImpl]mod = [CtLiteralImpl]2;
                [CtAssignmentImpl][CtVariableWriteImpl]desc = [CtLiteralImpl]"Heavy";
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]bldg.getBldgClass() == [CtFieldReadImpl]Building.HANGAR) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]mod = [CtLiteralImpl]1;
                    [CtAssignmentImpl][CtVariableWriteImpl]desc = [CtBinaryOperatorImpl][CtVariableReadImpl]desc + [CtLiteralImpl]" Hangar";
                }
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]bldg.getBldgClass() == [CtFieldReadImpl]Building.FORTRESS) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]mod = [CtLiteralImpl]3;
                    [CtAssignmentImpl][CtVariableWriteImpl]desc = [CtBinaryOperatorImpl][CtVariableReadImpl]desc + [CtLiteralImpl]" Fortress";
                }
                [CtBreakImpl][CtCommentImpl]// if(bldg.getBldgClass() == Building.CASTLE_BRIAN) {
                [CtCommentImpl]// mod = 4;
                [CtCommentImpl]// desc = desc + " Castle Brian";
                [CtCommentImpl]// }
                break;
            [CtCaseImpl]case [CtFieldReadImpl]Building.HARDENED :
                [CtAssignmentImpl][CtVariableWriteImpl]mod = [CtLiteralImpl]5;
                [CtAssignmentImpl][CtVariableWriteImpl]desc = [CtLiteralImpl]"Hardened";
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]bldg.getBldgClass() == [CtFieldReadImpl]Building.HANGAR) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]mod = [CtLiteralImpl]3;
                    [CtAssignmentImpl][CtVariableWriteImpl]desc = [CtBinaryOperatorImpl][CtVariableReadImpl]desc + [CtLiteralImpl]" Hangar";
                }
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]bldg.getBldgClass() == [CtFieldReadImpl]Building.FORTRESS) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]mod = [CtLiteralImpl]4;
                    [CtAssignmentImpl][CtVariableWriteImpl]desc = [CtBinaryOperatorImpl][CtVariableReadImpl]desc + [CtLiteralImpl]" Fortress";
                }
                [CtBreakImpl]break;
            [CtCaseImpl]case [CtFieldReadImpl]Building.WALL :
                [CtAssignmentImpl][CtVariableWriteImpl]mod = [CtLiteralImpl]12;
                [CtAssignmentImpl][CtVariableWriteImpl]desc = [CtLiteralImpl]"";
                [CtBreakImpl]break;
        }
        [CtInvocationImpl][CtCommentImpl]// append the reason modifier
        [CtVariableReadImpl]roll.append([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtInvocationImpl]getId(), [CtVariableReadImpl]mod, [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtLiteralImpl]"moving through " + [CtVariableReadImpl]desc) + [CtLiteralImpl]" ") + [CtInvocationImpl][CtVariableReadImpl]bldg.getName()));
        [CtInvocationImpl]adjustDifficultTerrainPSRModifier([CtVariableReadImpl]roll);
        [CtIfImpl][CtCommentImpl]// Modify the roll by the distance moved so far.
        if ([CtBinaryOperatorImpl][CtVariableReadImpl]distance >= [CtLiteralImpl]25) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtLiteralImpl]6, [CtLiteralImpl]"moved 25+ hexes");
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]distance >= [CtLiteralImpl]18) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtLiteralImpl]5, [CtLiteralImpl]"moved 18-24 hexes");
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]distance >= [CtLiteralImpl]10) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtLiteralImpl]4, [CtLiteralImpl]"moved 10+ hexes");
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]distance >= [CtLiteralImpl]7) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtLiteralImpl]3, [CtLiteralImpl]"moved 7-9 hexes");
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]distance >= [CtLiteralImpl]5) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtLiteralImpl]2, [CtLiteralImpl]"moved 5-6 hexes");
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]distance >= [CtLiteralImpl]3) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtLiteralImpl]1, [CtLiteralImpl]"moved 3-4 hexes");
        }
        [CtReturnImpl]return [CtVariableReadImpl]roll;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Only check for satisfied turn mode for Tanks or QuadVees in vehicle mode, or LAMs in
     * AirMech mode. Except for LAMs, check whether advanced vehicle ground movement is enabled.
     *
     * @return True if this <code>Entity</code> must make a driving check for turning too sharply.
     */
    public [CtTypeReferenceImpl]boolean usesTurnMode() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * If using advanced vehicle ground movement, checks whether the unit is required to make
     * a driving roll for turning, and if so whether it succeeds.
     *
     * @param overallMoveType
     * 		The type move movement used this turn.
     * @param straightLineHexes
     * 		The number of hexes that were moved in a straight line before turning.
     * @param mpUsed
     * 		The total number of movement points used by the entity during the current turn.
     * @param currPos
     * 		The position of the hex where the turn is taking place, which may
     * 		modify a roll for terrain.
     * @return True if the entity failed a driving check due to turning too sharply.
     */
    public [CtTypeReferenceImpl]megamek.common.PilotingRollData checkTurnModeFailure([CtParameterImpl][CtTypeReferenceImpl]megamek.common.EntityMovementType overallMoveType, [CtParameterImpl][CtTypeReferenceImpl]int straightLineHexes, [CtParameterImpl][CtTypeReferenceImpl]int mpUsed, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords currPos) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.PilotingRollData roll = [CtInvocationImpl]getBasePilotingRoll([CtVariableReadImpl]overallMoveType);
        [CtIfImpl][CtCommentImpl]// Turn mode
        if ([CtUnaryOperatorImpl]![CtInvocationImpl]usesTurnMode()) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtTypeAccessImpl]TargetRoll.CHECK_FALSE, [CtLiteralImpl]"Check false: unit does not use turn modes.");
            [CtReturnImpl]return [CtVariableReadImpl]roll;
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]int turnMode = [CtBinaryOperatorImpl][CtVariableReadImpl]mpUsed / [CtLiteralImpl]5;
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]straightLineHexes >= [CtVariableReadImpl]turnMode) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtTypeAccessImpl]TargetRoll.CHECK_FALSE, [CtLiteralImpl]"Check false: unit did not exceed turn mode.");
            [CtReturnImpl]return [CtVariableReadImpl]roll;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl]getWeightClass() < [CtFieldReadImpl]EntityWeightClass.WEIGHT_MEDIUM) || [CtBinaryOperatorImpl]([CtInvocationImpl]getWeightClass() == [CtFieldReadImpl]EntityWeightClass.WEIGHT_SMALL_SUPPORT)) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtUnaryOperatorImpl]-[CtLiteralImpl]1, [CtLiteralImpl]"light vehicle");
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl]getWeightClass() == [CtFieldReadImpl]EntityWeightClass.WEIGHT_ASSAULT) || [CtBinaryOperatorImpl]([CtInvocationImpl]getWeightClass() == [CtFieldReadImpl]EntityWeightClass.WEIGHT_SUPER_HEAVY)) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtUnaryOperatorImpl]+[CtLiteralImpl]1, [CtLiteralImpl]"assault vehicle");
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.IHex currHex = [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().getHex([CtVariableReadImpl]currPos);
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtFieldReadImpl]movementMode != [CtFieldReadImpl]EntityMovementMode.HOVER) && [CtBinaryOperatorImpl]([CtFieldReadImpl]movementMode != [CtFieldReadImpl]EntityMovementMode.VTOL)) && [CtBinaryOperatorImpl]([CtFieldReadImpl]movementMode != [CtFieldReadImpl]EntityMovementMode.WIGE)) [CtBlockImpl]{
            [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]currHex.containsTerrain([CtTypeAccessImpl]Terrains.MUD)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtUnaryOperatorImpl]+[CtLiteralImpl]1, [CtLiteralImpl]"mud");
            }
            [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]currHex.containsTerrain([CtTypeAccessImpl]Terrains.ICE)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtConditionalImpl][CtBinaryOperatorImpl][CtFieldReadImpl]movementMode == [CtFieldReadImpl]EntityMovementMode.TRACKED ? [CtLiteralImpl]1 : [CtLiteralImpl]2, [CtLiteralImpl]"ice");
            }
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getPlanetaryConditions().isSleeting() || [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getPlanetaryConditions().getFog() == [CtFieldReadImpl]PlanetaryConditions.FOG_HEAVY)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getPlanetaryConditions().getWeather() == [CtFieldReadImpl]PlanetaryConditions.WE_HEAVY_RAIN)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getPlanetaryConditions().getWeather() == [CtFieldReadImpl]PlanetaryConditions.WE_GUSTING_RAIN)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getPlanetaryConditions().getWeather() == [CtFieldReadImpl]PlanetaryConditions.WE_DOWNPOUR)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtUnaryOperatorImpl]+[CtLiteralImpl]1, [CtLiteralImpl]"fog/rain");
            }
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getPlanetaryConditions().getWeather() == [CtFieldReadImpl]PlanetaryConditions.WE_HEAVY_SNOW) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getPlanetaryConditions().getWeather() == [CtFieldReadImpl]PlanetaryConditions.WE_BLIZZARD)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtConditionalImpl][CtBinaryOperatorImpl][CtFieldReadImpl]movementMode == [CtFieldReadImpl]EntityMovementMode.TRACKED ? [CtLiteralImpl]1 : [CtLiteralImpl]2, [CtLiteralImpl]"snow");
            }
        }
        [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtBinaryOperatorImpl][CtVariableReadImpl]turnMode - [CtVariableReadImpl]straightLineHexes, [CtLiteralImpl]"did not satisfy turn mode");
        [CtReturnImpl]return [CtVariableReadImpl]roll;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Calculate the piloting skill roll modifier, based upon the number of
     * hexes moved this phase. Used for skidding.
     */
    public [CtTypeReferenceImpl]int getMovementBeforeSkidPSRModifier([CtParameterImpl][CtTypeReferenceImpl]int distance) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int mod = [CtUnaryOperatorImpl]-[CtLiteralImpl]1;
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]distance > [CtLiteralImpl]24) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]mod = [CtLiteralImpl]6;
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]distance > [CtLiteralImpl]17) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]mod = [CtLiteralImpl]5;
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]distance > [CtLiteralImpl]10) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]mod = [CtLiteralImpl]4;
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]distance > [CtLiteralImpl]7) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]mod = [CtLiteralImpl]2;
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]distance > [CtLiteralImpl]4) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]mod = [CtLiteralImpl]1;
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]distance > [CtLiteralImpl]2) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]mod = [CtLiteralImpl]0;
        } else [CtBlockImpl]{
            [CtAssignmentImpl][CtCommentImpl]// 0-2 hexes
            [CtVariableWriteImpl]mod = [CtUnaryOperatorImpl]-[CtLiteralImpl]1;
        }
        [CtIfImpl]if ([CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.PILOT_MANEUVERING_ACE)) [CtBlockImpl]{
            [CtUnaryOperatorImpl][CtVariableWriteImpl]mod--;
        }
        [CtReturnImpl]return [CtVariableReadImpl]mod;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * calculate any changes to the PSR modifier for entering difficult terrain
     */
    private [CtTypeReferenceImpl]void adjustDifficultTerrainPSRModifier([CtParameterImpl][CtTypeReferenceImpl]megamek.common.PilotingRollData psr) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]hasQuirk([CtTypeAccessImpl]OptionsConstants.QUIRK_POS_EASY_PILOT) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl]getCrew().getPiloting() > [CtLiteralImpl]3)) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]psr.addModifier([CtUnaryOperatorImpl]-[CtLiteralImpl]1, [CtLiteralImpl]"easy to pilot");
        }
        [CtIfImpl]if ([CtInvocationImpl]hasQuirk([CtTypeAccessImpl]OptionsConstants.QUIRK_NEG_UNBALANCED)) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]psr.addModifier([CtUnaryOperatorImpl]+[CtLiteralImpl]1, [CtLiteralImpl]"unbalanced");
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * The maximum elevation change the entity can cross
     */
    public abstract [CtTypeReferenceImpl]int getMaxElevationChange();

    [CtMethodImpl][CtJavaDocImpl]/**
     * by default, entities can move as far down as they can move up
     */
    public [CtTypeReferenceImpl]int getMaxElevationDown() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getMaxElevationDown([CtInvocationImpl]getElevation());
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the maximum number of downard elevation changes a unit can make.
     * For some units (namely, WiGEs), this can depend upon their current
     * elevation (since elevation determines if the WiGEs is using WiGE movement
     * or not).
     *
     * @param currElevation
     * @return  */
    public [CtTypeReferenceImpl]int getMaxElevationDown([CtParameterImpl][CtTypeReferenceImpl]int currElevation) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getMaxElevationChange();
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Add a transportation component to this Entity. Please note, this method
     * should only be called during this entity's construction.
     *
     * @param component
     * 		- One of this new entity's <code>Transporter</code>s.
     */
    public [CtTypeReferenceImpl]void addTransporter([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Transporter component) [CtBlockImpl]{
        [CtInvocationImpl]addTransporter([CtVariableReadImpl]component, [CtLiteralImpl]false);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Add a transportation component to this Entity. Please note, this method
     * should only be called during this entity's construction.
     *
     * @param component
     * 		- One of this new entity's <code>Transporter</code>s.
     * @param isOmniPod
     * 		- Whether this is part of an omni unit's pod space.
     */
    public [CtTypeReferenceImpl]void addTransporter([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Transporter component, [CtParameterImpl][CtTypeReferenceImpl]boolean isOmniPod) [CtBlockImpl]{
        [CtInvocationImpl][CtVariableReadImpl]component.setGame([CtFieldReadImpl]game);
        [CtInvocationImpl][CtFieldReadImpl]transports.add([CtVariableReadImpl]component);
        [CtIfImpl]if ([CtVariableReadImpl]isOmniPod) [CtBlockImpl]{
            [CtInvocationImpl][CtFieldReadImpl]omniPodTransports.add([CtVariableReadImpl]component);
        }
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void removeTransporter([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Transporter t) [CtBlockImpl]{
        [CtInvocationImpl][CtFieldReadImpl]transports.remove([CtVariableReadImpl]t);
        [CtInvocationImpl][CtFieldReadImpl]omniPodTransports.remove([CtVariableReadImpl]t);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Remove all transportation components from this Entity. Should probably
     * only be called during construction.
     */
    public [CtTypeReferenceImpl]void removeAllTransporters() [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]transports = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Transporter>();
        [CtInvocationImpl][CtFieldReadImpl]omniPodTransports.clear();
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Determines if this object can accept the given unit. The unit may not be
     * of the appropriate type or there may be no room for the unit.
     *
     * @param unit
     * 		- the <code>Entity</code> to be loaded.
     * @return <code>true</code> if the unit can be loaded, <code>false</code>
    otherwise.
     */
    public [CtTypeReferenceImpl]boolean canLoad([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Entity unit, [CtParameterImpl][CtTypeReferenceImpl]boolean checkElev) [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// For now, if it's infantry, it can't load anything.
        [CtCommentImpl]// Period!
        if ([CtBinaryOperatorImpl][CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Infantry) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl][CtCommentImpl]// one can only load one's own team's units!
        if ([CtUnaryOperatorImpl]![CtInvocationImpl][CtVariableReadImpl]unit.isEnemyOf([CtThisAccessImpl]this)) [CtBlockImpl]{
            [CtLocalVariableImpl][CtCommentImpl]/* Mechanized BA and protomechs occupy the same space, and if one is already
            present the other cannot be loaded. It is still possible for a support vee
            to carry mechanized BA externally and protos in a bay, so we need to check for
            external units first then check for conflicts only for other external mounts.
             */
            [CtTypeReferenceImpl]boolean hasExternalBA = [CtLiteralImpl]false;
            [CtLocalVariableImpl][CtTypeReferenceImpl]boolean hasExternalProtos = [CtLiteralImpl]false;
            [CtLocalVariableImpl][CtTypeReferenceImpl]boolean hasExternalUltraheavy = [CtLiteralImpl]false;
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]unit.hasETypeFlag([CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]ETYPE_BATTLEARMOR) || [CtInvocationImpl][CtVariableReadImpl]unit.hasETypeFlag([CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]ETYPE_PROTOMECH)) [CtBlockImpl]{
                [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter t : [CtFieldReadImpl]transports) [CtBlockImpl]{
                    [CtIfImpl][CtCommentImpl]// ProtomechClampMount is a subclass of BattleArmorHandles so we need to check it first
                    if ([CtBinaryOperatorImpl][CtVariableReadImpl]t instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.ProtomechClampMount) [CtBlockImpl]{
                        [CtOperatorAssignmentImpl][CtVariableWriteImpl]hasExternalProtos |= [CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]t.getUnused() == [CtLiteralImpl]0;
                        [CtOperatorAssignmentImpl][CtVariableWriteImpl]hasExternalUltraheavy |= [CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]t.getLoadedUnits().stream().anyMatch([CtLambdaImpl]([CtParameterImpl] e) -> [CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]e.getWeightClass() == [CtVariableReadImpl]EntityWeightClass.WEIGHT_SUPER_HEAVY);
                    } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]t instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.BattleArmorHandles) [CtBlockImpl]{
                        [CtOperatorAssignmentImpl][CtVariableWriteImpl]hasExternalBA |= [CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]t.getUnused() == [CtLiteralImpl]0;
                    }
                }
            }
            [CtLocalVariableImpl][CtCommentImpl]// We can't mix BA and protos, and we can't mount an ultraheavy proto if already carrying another.
            [CtTypeReferenceImpl]boolean noExternalMount = [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]unit.hasETypeFlag([CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]ETYPE_BATTLEARMOR) && [CtVariableReadImpl]hasExternalProtos) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]unit.hasETypeFlag([CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]ETYPE_PROTOMECH) && [CtVariableReadImpl]hasExternalBA);
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]unit.hasETypeFlag([CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]ETYPE_PROTOMECH) && [CtVariableReadImpl]hasExternalProtos) [CtBlockImpl]{
                [CtOperatorAssignmentImpl][CtVariableWriteImpl]noExternalMount |= [CtBinaryOperatorImpl][CtVariableReadImpl]hasExternalUltraheavy || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]unit.getWeightClass() == [CtFieldReadImpl]EntityWeightClass.WEIGHT_SUPER_HEAVY);
            }
            [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter t : [CtFieldReadImpl]transports) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]t.canLoad([CtVariableReadImpl]unit) && [CtBinaryOperatorImpl]([CtUnaryOperatorImpl](![CtVariableReadImpl]checkElev) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]unit.getElevation() == [CtInvocationImpl]getElevation()))) && [CtUnaryOperatorImpl](![CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]t instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.BattleArmorHandles) && [CtVariableReadImpl]noExternalMount))) [CtBlockImpl]{
                    [CtReturnImpl]return [CtLiteralImpl]true;
                }
            }
        }
        [CtReturnImpl][CtCommentImpl]// If we got here, none of our transports can carry the unit.
        return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]boolean canLoad([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Entity unit) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtThisAccessImpl]this.canLoad([CtVariableReadImpl]unit, [CtLiteralImpl]true);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Load the given unit.
     *
     * @param unit
     * 		- the <code>Entity</code> to be loaded.
     * @throws IllegalArgumentException
     * 		If the unit can't be loaded
     */
    public [CtTypeReferenceImpl]void load([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Entity unit, [CtParameterImpl][CtTypeReferenceImpl]boolean checkElev, [CtParameterImpl][CtTypeReferenceImpl]int bayNumber) [CtBlockImpl]{
        [CtLocalVariableImpl][CtCommentImpl]// Walk through this entity's transport components;
        [CtCommentImpl]// find the one that can load the unit.
        [CtCommentImpl]// Stop looking after the first match.
        [CtTypeReferenceImpl]java.util.Enumeration<[CtTypeReferenceImpl]megamek.common.Transporter> iter = [CtInvocationImpl][CtFieldReadImpl]transports.elements();
        [CtWhileImpl]while ([CtInvocationImpl][CtVariableReadImpl]iter.hasMoreElements()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next = [CtInvocationImpl][CtVariableReadImpl]iter.nextElement();
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]next.canLoad([CtVariableReadImpl]unit) && [CtBinaryOperatorImpl]([CtUnaryOperatorImpl](![CtVariableReadImpl]checkElev) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]unit.getElevation() == [CtInvocationImpl]getElevation()))) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]bayNumber == [CtUnaryOperatorImpl](-[CtLiteralImpl]1)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.Bay) (next)).getBayNumber() == [CtVariableReadImpl]bayNumber))) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]next.load([CtVariableReadImpl]unit);
                [CtInvocationImpl][CtVariableReadImpl]unit.setTargetBay([CtUnaryOperatorImpl]-[CtLiteralImpl]1);[CtCommentImpl]// Reset the target bay for later.

                [CtReturnImpl]return;
            }
        } 
        [CtThrowImpl][CtCommentImpl]// If we got to this point, then we can't load the unit.
        throw [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.lang.IllegalArgumentException([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl]getShortName() + [CtLiteralImpl]" can not load ") + [CtInvocationImpl][CtVariableReadImpl]unit.getShortName());
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void load([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Entity unit, [CtParameterImpl][CtTypeReferenceImpl]boolean checkElev) [CtBlockImpl]{
        [CtInvocationImpl][CtThisAccessImpl]this.load([CtVariableReadImpl]unit, [CtVariableReadImpl]checkElev, [CtUnaryOperatorImpl]-[CtLiteralImpl]1);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void load([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Entity unit, [CtParameterImpl][CtTypeReferenceImpl]int bayNumber) [CtBlockImpl]{
        [CtInvocationImpl][CtThisAccessImpl]this.load([CtVariableReadImpl]unit, [CtLiteralImpl]true, [CtVariableReadImpl]bayNumber);
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]void load([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Entity unit) [CtBlockImpl]{
        [CtInvocationImpl][CtThisAccessImpl]this.load([CtVariableReadImpl]unit, [CtLiteralImpl]true, [CtUnaryOperatorImpl]-[CtLiteralImpl]1);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Recover the given unit. Only for ASF and Small Craft
     *
     * @param unit
     * 		- the <code>Entity</code> to be loaded.
     * @throws IllegalArgumentException
     * 		If the unit can't be loaded
     */
    public [CtTypeReferenceImpl]void recover([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Entity unit) [CtBlockImpl]{
        [CtLocalVariableImpl][CtCommentImpl]// Walk through this entity's transport components;
        [CtCommentImpl]// find those that can load the unit.
        [CtCommentImpl]// load the unit into the best match.
        [CtTypeReferenceImpl]int choice = [CtLiteralImpl]0;
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter nextbay : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]nextbay.canLoad([CtVariableReadImpl]unit) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]unit.getElevation() == [CtInvocationImpl]getElevation())) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]nextbay instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.DockingCollar) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]choice = [CtLiteralImpl]3;
                }
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]nextbay instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.ASFBay) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]choice = [CtLiteralImpl]2;
                }
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]nextbay instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.SmallCraftBay) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]choice = [CtLiteralImpl]1;
                }
            }
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]choice == [CtLiteralImpl]3) [CtBlockImpl]{
            [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter nextbay : [CtFieldReadImpl]transports) [CtBlockImpl]{
                [CtWhileImpl]while ([CtBinaryOperatorImpl][CtVariableReadImpl]nextbay instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.DockingCollar) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.DockingCollar) (nextbay)).recover([CtVariableReadImpl]unit);
                    [CtReturnImpl]return;
                } 
            }
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]choice == [CtLiteralImpl]2) [CtBlockImpl]{
            [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Bay nextbay : [CtInvocationImpl]getTransportBays()) [CtBlockImpl]{
                [CtWhileImpl]while ([CtBinaryOperatorImpl][CtVariableReadImpl]nextbay instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.ASFBay) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.ASFBay) (nextbay)).recover([CtVariableReadImpl]unit);
                    [CtReturnImpl]return;
                } 
            }
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]choice == [CtLiteralImpl]1) [CtBlockImpl]{
            [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Bay nextbay : [CtInvocationImpl]getTransportBays()) [CtBlockImpl]{
                [CtWhileImpl]while ([CtBinaryOperatorImpl][CtVariableReadImpl]nextbay instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.SmallCraftBay) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.SmallCraftBay) (nextbay)).recover([CtVariableReadImpl]unit);
                    [CtReturnImpl]return;
                } 
            }
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * cycle through and update Bays
     */
    public [CtTypeReferenceImpl]void updateBays() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Enumeration<[CtTypeReferenceImpl]megamek.common.Transporter> iter = [CtInvocationImpl][CtFieldReadImpl]transports.elements();
        [CtWhileImpl]while ([CtInvocationImpl][CtVariableReadImpl]iter.hasMoreElements()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next = [CtInvocationImpl][CtVariableReadImpl]iter.nextElement();
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.ASFBay) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.ASFBay nextBay = [CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.ASFBay) (next));
                [CtInvocationImpl][CtVariableReadImpl]nextBay.updateSlots();
            }
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.SmallCraftBay) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.SmallCraftBay nextBay = [CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.SmallCraftBay) (next));
                [CtInvocationImpl][CtVariableReadImpl]nextBay.updateSlots();
            }
        } 
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Damages a randomly determined bay door on the entity, if one exists
     */
    public [CtTypeReferenceImpl]java.lang.String damageBayDoor() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.lang.String bayType = [CtLiteralImpl]"none";
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Bay> potential;
        [CtAssignmentImpl][CtVariableWriteImpl]potential = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Bay>();
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Enumeration<[CtTypeReferenceImpl]megamek.common.Transporter> iter = [CtInvocationImpl][CtFieldReadImpl]transports.elements();
        [CtWhileImpl]while ([CtInvocationImpl][CtVariableReadImpl]iter.hasMoreElements()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next = [CtInvocationImpl][CtVariableReadImpl]iter.nextElement();
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Bay) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Bay nextBay = [CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.Bay) (next));
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]nextBay.getCurrentDoors() > [CtLiteralImpl]0) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]potential.add([CtVariableReadImpl]nextBay);
                }
            }
        } 
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]potential.size() > [CtLiteralImpl]0) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Bay chosenBay = [CtInvocationImpl][CtVariableReadImpl]potential.elementAt([CtInvocationImpl][CtTypeAccessImpl]megamek.common.Compute.randomInt([CtInvocationImpl][CtVariableReadImpl]potential.size()));
            [CtInvocationImpl][CtVariableReadImpl]chosenBay.destroyDoor();
            [CtInvocationImpl][CtVariableReadImpl]chosenBay.resetDoors();
            [CtAssignmentImpl][CtVariableWriteImpl]bayType = [CtInvocationImpl][CtVariableReadImpl]chosenBay.getType();
        }
        [CtReturnImpl]return [CtVariableReadImpl]bayType;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * damage the door of the first bay that can load this unit
     */
    public [CtTypeReferenceImpl]void damageDoorRecovery([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Entity en) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Enumeration<[CtTypeReferenceImpl]megamek.common.Transporter> iter = [CtInvocationImpl][CtFieldReadImpl]transports.elements();
        [CtWhileImpl]while ([CtInvocationImpl][CtVariableReadImpl]iter.hasMoreElements()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next = [CtInvocationImpl][CtVariableReadImpl]iter.nextElement();
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.ASFBay) && [CtInvocationImpl][CtVariableReadImpl]next.canLoad([CtVariableReadImpl]en)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.ASFBay) (next)).destroyDoor();
                [CtBreakImpl]break;
            }
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.SmallCraftBay) && [CtInvocationImpl][CtVariableReadImpl]next.canLoad([CtVariableReadImpl]en)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.SmallCraftBay) (next)).destroyDoor();
                [CtBreakImpl]break;
            }
        } 
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Damages a randomly determined docking collar on the entity, if one exists
     */
    public [CtTypeReferenceImpl]boolean damageDockCollar() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]boolean result = [CtLiteralImpl]false;
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.DockingCollar> potential;
        [CtAssignmentImpl][CtVariableWriteImpl]potential = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.DockingCollar>();
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Enumeration<[CtTypeReferenceImpl]megamek.common.Transporter> iter = [CtInvocationImpl][CtFieldReadImpl]transports.elements();
        [CtWhileImpl]while ([CtInvocationImpl][CtVariableReadImpl]iter.hasMoreElements()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next = [CtInvocationImpl][CtVariableReadImpl]iter.nextElement();
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.DockingCollar) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.DockingCollar nextDC = [CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.DockingCollar) (next));
                [CtIfImpl]if ([CtUnaryOperatorImpl]![CtInvocationImpl][CtVariableReadImpl]nextDC.isDamaged()) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]potential.add([CtVariableReadImpl]nextDC);
                }
            }
        } 
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]potential.size() > [CtLiteralImpl]0) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.DockingCollar chosenDC = [CtInvocationImpl][CtVariableReadImpl]potential.elementAt([CtInvocationImpl][CtTypeAccessImpl]megamek.common.Compute.randomInt([CtInvocationImpl][CtVariableReadImpl]potential.size()));
            [CtInvocationImpl][CtVariableReadImpl]chosenDC.setDamaged([CtLiteralImpl]true);
            [CtAssignmentImpl][CtVariableWriteImpl]result = [CtLiteralImpl]true;
        }
        [CtReturnImpl]return [CtVariableReadImpl]result;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void pickUp([CtParameterImpl][CtTypeReferenceImpl]megamek.common.MechWarrior mw) [CtBlockImpl]{
        [CtInvocationImpl][CtFieldReadImpl]pickedUpMechWarriors.addElement([CtInvocationImpl][CtVariableReadImpl]mw.getId());
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Get a <code>List</code> of the units currently loaded into this payload.
     *
     * @return A <code>List</code> of loaded <code>Entity</code> units. This
    list will never be <code>null</code>, but it may be empty. The
    returned <code>List</code> is independent from the under- lying
    data structure; modifying one does not affect the other.
     */
    [CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]java.util.List<[CtTypeReferenceImpl]megamek.common.Entity> getLoadedUnits() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.List<[CtTypeReferenceImpl]megamek.common.Entity> result = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.Entity>();
        [CtForEachImpl][CtCommentImpl]// Walk through this entity's transport components;
        [CtCommentImpl]// add all of their lists to ours.
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtIfImpl][CtCommentImpl]// Don't look at trailer hitches here, that's separate
            if ([CtBinaryOperatorImpl][CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.TankTrailerHitch) [CtBlockImpl]{
                [CtContinueImpl]continue;
            }
            [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity e : [CtInvocationImpl][CtVariableReadImpl]next.getLoadedUnits()) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]e != [CtLiteralImpl]null) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]result.add([CtVariableReadImpl]e);
                }
            }
        }
        [CtReturnImpl][CtCommentImpl]// Return the list.
        return [CtVariableReadImpl]result;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @return the number of docking collars
     */
    public [CtTypeReferenceImpl]int getDocks() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getDocks([CtLiteralImpl]false);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @param forCost
     * 		Whether this value is being used for cost calculations, in which case
     * 		dropshuttle bays count as two collars.
     * @return The number of docking collars
     */
    public [CtTypeReferenceImpl]int getDocks([CtParameterImpl][CtTypeReferenceImpl]boolean forCost) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int n = [CtLiteralImpl]0;
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.DockingCollar) || [CtBinaryOperatorImpl]([CtVariableReadImpl]forCost && [CtBinaryOperatorImpl]([CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.DropshuttleBay))) [CtBlockImpl]{
                [CtOperatorAssignmentImpl][CtVariableWriteImpl]n += [CtInvocationImpl][CtVariableReadImpl]next.hardpointCost();
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]n;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * only entities in Bays (for cargo damage to Aero units
     *
     * @return  */
    public [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Entity> getBayLoadedUnits() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Entity> result = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Entity>();
        [CtForEachImpl][CtCommentImpl]// Walk through this entity's transport components;
        [CtCommentImpl]// add all of their lists to ours.
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Bay) [CtBlockImpl]{
                [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity e : [CtInvocationImpl][CtVariableReadImpl]next.getLoadedUnits()) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]result.addElement([CtVariableReadImpl]e);
                }
            }
        }
        [CtReturnImpl][CtCommentImpl]// Return the list.
        return [CtVariableReadImpl]result;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Generate a list of the Ids of entities stored in bays.
     * Used by MHQ in cases where we can't get the entities via Game
     *
     * @return  */
    public [CtTypeReferenceImpl]java.util.List<[CtTypeReferenceImpl]java.lang.Integer> getBayLoadedUnitIds() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.List<[CtTypeReferenceImpl]java.lang.Integer> result = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]java.lang.Integer>();
        [CtForEachImpl][CtCommentImpl]// Walk through this entity's transport components;
        [CtCommentImpl]// add all of their lists to ours.
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Bay) [CtBlockImpl]{
                [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i : [CtInvocationImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.Bay) (next)).getLoadedUnitIds()) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]result.add([CtVariableReadImpl]i);
                }
            }
        }
        [CtReturnImpl][CtCommentImpl]// Return the list.
        return [CtVariableReadImpl]result;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * return the bay that the given entity is loaded into
     *
     * @param loaded
     * @return  */
    public [CtTypeReferenceImpl]megamek.common.Bay getBay([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Entity loaded) [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Bay) [CtBlockImpl]{
                [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity e : [CtInvocationImpl][CtVariableReadImpl]next.getLoadedUnits()) [CtBlockImpl]{
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]loaded.getId() == [CtInvocationImpl][CtVariableReadImpl]e.getId()) [CtBlockImpl]{
                        [CtReturnImpl]return [CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.Bay) (next));
                    }
                }
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]null;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]megamek.common.Bay getBayById([CtParameterImpl][CtTypeReferenceImpl]int bayNumber) [CtBlockImpl]{
        [CtForEachImpl][CtCommentImpl]// TODO: Change transports to a map or other indexed data structure to avoid
        [CtCommentImpl]// linear-time algorithm.
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Bay) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.Bay) (next)).getBayNumber() == [CtVariableReadImpl]bayNumber) [CtBlockImpl]{
                    [CtReturnImpl]return [CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.Bay) (next));
                }
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]null;
    }

    [CtMethodImpl][CtAnnotationImpl]@megamek.common.annotations.Nullable
    public [CtTypeReferenceImpl]megamek.common.DockingCollar getCollarById([CtParameterImpl][CtTypeReferenceImpl]int collarNumber) [CtBlockImpl]{
        [CtForEachImpl][CtCommentImpl]// TODO: Change transports to a map or other indexed data structure to avoid
        [CtCommentImpl]// linear-time algorithm.
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.DockingCollar) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.DockingCollar) (next)).getCollarNumber() == [CtVariableReadImpl]collarNumber) [CtBlockImpl]{
                    [CtReturnImpl]return [CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.DockingCollar) (next));
                }
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]null;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @return only entities in ASF Bays
     */
    public [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Entity> getLoadedFighters() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Entity> result = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Entity>();
        [CtForEachImpl][CtCommentImpl]// Walk through this entity's transport components;
        [CtCommentImpl]// add all of their lists to ours.
        [CtCommentImpl]// I should only add entities in bays that are functional
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.ASFBay) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.ASFBay) (next)).getCurrentDoors() > [CtLiteralImpl]0)) [CtBlockImpl]{
                [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity e : [CtInvocationImpl][CtVariableReadImpl]next.getLoadedUnits()) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]result.addElement([CtVariableReadImpl]e);
                }
            }
        }
        [CtReturnImpl][CtCommentImpl]// Return the list.
        return [CtVariableReadImpl]result;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @return only entities in ASF Bays that can be launched (i.e. not in
    recovery)
     */
    public [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Entity> getLaunchableFighters() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Entity> result = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Entity>();
        [CtForEachImpl][CtCommentImpl]// Walk through this entity's transport components;
        [CtCommentImpl]// add all of their lists to ours.
        [CtCommentImpl]// I should only add entities in bays that are functional
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.ASFBay) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.ASFBay) (next)).getCurrentDoors() > [CtLiteralImpl]0)) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Bay nextbay = [CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.Bay) (next));
                [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity e : [CtInvocationImpl][CtVariableReadImpl]nextbay.getLaunchableUnits()) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]result.addElement([CtVariableReadImpl]e);
                }
            }
        }
        [CtReturnImpl][CtCommentImpl]// Return the list.
        return [CtVariableReadImpl]result;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @return only entities in that can be combat dropped
     */
    public [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Entity> getDroppableUnits() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Entity> result = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Entity>();
        [CtForEachImpl][CtCommentImpl]// Walk through this entity's transport components;
        [CtCommentImpl]// add all of their lists to ours.
        [CtCommentImpl]// I should only add entities in bays that are functional
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Bay) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.Bay) (next)).getCurrentDoors() > [CtLiteralImpl]0)) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Bay nextbay = [CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.Bay) (next));
                [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity e : [CtInvocationImpl][CtVariableReadImpl]nextbay.getDroppableUnits()) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]result.addElement([CtVariableReadImpl]e);
                }
            }
        }
        [CtReturnImpl][CtCommentImpl]// Return the list.
        return [CtVariableReadImpl]result;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @return only entities in that can be unloaded on ground
     */
    public [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Entity> getUnitsUnloadableFromBays() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Entity> result = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Entity>();
        [CtForEachImpl][CtCommentImpl]// Walk through this entity's transport components;
        [CtCommentImpl]// add all of their lists to ours.
        [CtCommentImpl]// I should only add entities in bays that are functional
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Bay) && [CtInvocationImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.Bay) (next)).canUnloadUnits()) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Bay nextbay = [CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.Bay) (next));
                [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity e : [CtInvocationImpl][CtVariableReadImpl]nextbay.getUnloadableUnits()) [CtBlockImpl]{
                    [CtIfImpl]if ([CtUnaryOperatorImpl]![CtInvocationImpl][CtVariableReadImpl]e.wasLoadedThisTurn()) [CtBlockImpl]{
                        [CtInvocationImpl][CtVariableReadImpl]result.addElement([CtVariableReadImpl]e);
                    }
                }
            }
        }
        [CtReturnImpl][CtCommentImpl]// Return the list.
        return [CtVariableReadImpl]result;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]megamek.common.Bay getLoadedBay([CtParameterImpl][CtTypeReferenceImpl]int bayID) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Bay> bays = [CtInvocationImpl]getFighterBays();
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int nbay = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]nbay < [CtInvocationImpl][CtVariableReadImpl]bays.size(); [CtUnaryOperatorImpl][CtVariableWriteImpl]nbay++) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Bay currentBay = [CtInvocationImpl][CtVariableReadImpl]bays.elementAt([CtVariableReadImpl]nbay);
            [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Entity> currentFighters = [CtInvocationImpl][CtVariableReadImpl]currentBay.getLoadedUnits();
            [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int nfighter = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]nfighter < [CtInvocationImpl][CtVariableReadImpl]currentFighters.size(); [CtUnaryOperatorImpl][CtVariableWriteImpl]nfighter++) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity fighter = [CtInvocationImpl][CtVariableReadImpl]currentFighters.elementAt([CtVariableReadImpl]nfighter);
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]fighter.getId() == [CtVariableReadImpl]bayID) [CtBlockImpl]{
                    [CtReturnImpl][CtCommentImpl]// then we are in the right bay
                    return [CtVariableReadImpl]currentBay;
                }
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]null;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @return get the bays separately
     */
    public [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Bay> getFighterBays() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Bay> result = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Bay>();
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.ASFBay) || [CtBinaryOperatorImpl]([CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.SmallCraftBay)) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.Bay) (next)).getCurrentDoors() > [CtLiteralImpl]0)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]result.addElement([CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.Bay) (next)));
            }
        }
        [CtReturnImpl][CtCommentImpl]// Return the list.
        return [CtVariableReadImpl]result;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @return get the bays separately
     */
    public [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.DockingCollar> getDockingCollars() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.DockingCollar> result = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.DockingCollar>();
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.DockingCollar) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]result.addElement([CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.DockingCollar) (next)));
            }
        }
        [CtReturnImpl][CtCommentImpl]// Return the list.
        return [CtVariableReadImpl]result;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns vector of Transports for everything a unit transports
     *
     * @return  */
    public [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Transporter> getTransports() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]transports;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isPodMountedTransport([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Transporter t) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]omniPodTransports.contains([CtVariableReadImpl]t);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Bay> getTransportBays() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Bay> result = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Bay>();
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Bay) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]result.addElement([CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.Bay) (next)));
            }
        }
        [CtReturnImpl][CtCommentImpl]// Return the list.
        return [CtVariableReadImpl]result;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * do any damage to bay doors
     */
    public [CtTypeReferenceImpl]void resetBayDoors() [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Bay) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.Bay) (next)).resetDoors();
            }
        }
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void resetBays() [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Bay) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.Bay) (next)).resetCounts();
            }
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @return the launch rate for fighters
     */
    public [CtTypeReferenceImpl]int getFighterLaunchRate() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int result = [CtLiteralImpl]0;
        [CtForEachImpl][CtCommentImpl]// Walk through this entity's transport components;
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.ASFBay) [CtBlockImpl]{
                [CtOperatorAssignmentImpl][CtVariableWriteImpl]result += [CtBinaryOperatorImpl][CtLiteralImpl]2 * [CtInvocationImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.ASFBay) (next)).getCurrentDoors();
            }
        }
        [CtReturnImpl][CtCommentImpl]// Return the number.
        return [CtVariableReadImpl]result;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Entity> getLoadedSmallCraft() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Entity> result = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Entity>();
        [CtForEachImpl][CtCommentImpl]// Walk through this entity's transport components;
        [CtCommentImpl]// add all of their lists to ours.
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.SmallCraftBay) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.SmallCraftBay) (next)).getCurrentDoors() > [CtLiteralImpl]0)) [CtBlockImpl]{
                [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity e : [CtInvocationImpl][CtVariableReadImpl]next.getLoadedUnits()) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]result.addElement([CtVariableReadImpl]e);
                }
            }
        }
        [CtReturnImpl][CtCommentImpl]// Return the list.
        return [CtVariableReadImpl]result;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Entity> getLaunchableSmallCraft() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Entity> result = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Entity>();
        [CtForEachImpl][CtCommentImpl]// Walk through this entity's transport components;
        [CtCommentImpl]// add all of their lists to ours.
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.SmallCraftBay) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.SmallCraftBay) (next)).getCurrentDoors() > [CtLiteralImpl]0)) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Bay nextbay = [CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.Bay) (next));
                [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity e : [CtInvocationImpl][CtVariableReadImpl]nextbay.getLaunchableUnits()) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]result.addElement([CtVariableReadImpl]e);
                }
            }
        }
        [CtReturnImpl][CtCommentImpl]// Return the list.
        return [CtVariableReadImpl]result;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Entity> getLoadedDropships() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Entity> result = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Entity>();
        [CtForEachImpl][CtCommentImpl]// Walk through this entity's transport components;
        [CtCommentImpl]// add all of their lists to ours.
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.DockingCollar) [CtBlockImpl]{
                [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity e : [CtInvocationImpl][CtVariableReadImpl]next.getLoadedUnits()) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]result.addElement([CtVariableReadImpl]e);
                }
            }
        }
        [CtReturnImpl][CtCommentImpl]// Return the list.
        return [CtVariableReadImpl]result;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Entity> getLaunchableDropships() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Entity> result = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Entity>();
        [CtForEachImpl][CtCommentImpl]// Walk through this entity's transport components;
        [CtCommentImpl]// add all of their lists to ours.
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.DockingCollar) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.DockingCollar collar = [CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.DockingCollar) (next));
                [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity e : [CtInvocationImpl][CtVariableReadImpl]collar.getLaunchableUnits()) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]result.addElement([CtVariableReadImpl]e);
                }
            }
        }
        [CtReturnImpl][CtCommentImpl]// Return the list.
        return [CtVariableReadImpl]result;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * get the bays separately
     */
    public [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.SmallCraftBay> getSmallCraftBays() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.SmallCraftBay> result = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.SmallCraftBay>();
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.SmallCraftBay) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.SmallCraftBay) (next)).getCurrentDoors() > [CtLiteralImpl]0)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]result.addElement([CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.SmallCraftBay) (next)));
            }
        }
        [CtReturnImpl][CtCommentImpl]// Return the list.
        return [CtVariableReadImpl]result;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @return launch rate for Small Craft
     */
    public [CtTypeReferenceImpl]int getSmallCraftLaunchRate() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int result = [CtLiteralImpl]0;
        [CtForEachImpl][CtCommentImpl]// Walk through this entity's transport components;
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.SmallCraftBay) [CtBlockImpl]{
                [CtOperatorAssignmentImpl][CtVariableWriteImpl]result += [CtBinaryOperatorImpl][CtLiteralImpl]2 * [CtInvocationImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.SmallCraftBay) (next)).getCurrentDoors();
            }
        }
        [CtReturnImpl][CtCommentImpl]// Return the number.
        return [CtVariableReadImpl]result;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Unload the given unit.
     *
     * @param unit
     * 		- the <code>Entity</code> to be unloaded.
     * @return <code>true</code> if the unit was contained in this space,
    <code>false</code> otherwise.
     */
    [CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]boolean unload([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Entity unit) [CtBlockImpl]{
        [CtLocalVariableImpl][CtCommentImpl]// Walk through this entity's transport components;
        [CtCommentImpl]// try to remove the unit from each in turn.
        [CtCommentImpl]// Stop after the first match.
        [CtTypeReferenceImpl]java.util.Enumeration<[CtTypeReferenceImpl]megamek.common.Transporter> iter = [CtInvocationImpl][CtFieldReadImpl]transports.elements();
        [CtWhileImpl]while ([CtInvocationImpl][CtVariableReadImpl]iter.hasMoreElements()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next = [CtInvocationImpl][CtVariableReadImpl]iter.nextElement();
            [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]next.unload([CtVariableReadImpl]unit)) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        } 
        [CtReturnImpl][CtCommentImpl]// If we got here, none of our transports currently carry the unit.
        return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]void resetTransporter() [CtBlockImpl]{
        [CtLocalVariableImpl][CtCommentImpl]// Walk through this entity's transport components;
        [CtCommentImpl]// and resets them
        [CtTypeReferenceImpl]java.util.Enumeration<[CtTypeReferenceImpl]megamek.common.Transporter> iter = [CtInvocationImpl][CtFieldReadImpl]transports.elements();
        [CtWhileImpl]while ([CtInvocationImpl][CtVariableReadImpl]iter.hasMoreElements()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next = [CtInvocationImpl][CtVariableReadImpl]iter.nextElement();
            [CtInvocationImpl][CtVariableReadImpl]next.resetTransporter();
        } 
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Return a string that identifies the unused capacity of this transporter.
     *
     * @return A <code>String</code> meant for a human.
     */
    [CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]java.lang.String getUnusedString() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getUnusedString([CtLiteralImpl]false);
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]double getUnused() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]double capacity = [CtLiteralImpl]0;
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter transport : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtOperatorAssignmentImpl][CtVariableWriteImpl]capacity += [CtInvocationImpl][CtVariableReadImpl]transport.getUnused();
        }
        [CtReturnImpl]return [CtVariableReadImpl]capacity;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the current amount of cargo space for an entity of the given
     * type.
     *
     * @param e
     * 		An entity that defines the unit class
     * @return The number of units of the given type that can be loaded in this
    Entity
     */
    public [CtTypeReferenceImpl]double getUnused([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Entity e) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]double capacity = [CtLiteralImpl]0;
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter transport : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]transport.canLoad([CtVariableReadImpl]e)) [CtBlockImpl]{
                [CtOperatorAssignmentImpl][CtVariableWriteImpl]capacity += [CtInvocationImpl][CtVariableReadImpl]transport.getUnused();
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]capacity;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Return a string that identifies the unused capacity of this transporter.
     *
     * @return A <code>String</code> meant for a human.
     */
    public [CtTypeReferenceImpl]java.lang.String getUnusedString([CtParameterImpl][CtTypeReferenceImpl]boolean ishtml) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.lang.StringBuffer result = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.lang.StringBuffer();
        [CtLocalVariableImpl][CtCommentImpl]// Walk through this entity's transport components;
        [CtCommentImpl]// add all of their string to ours.
        [CtTypeReferenceImpl]java.util.Enumeration<[CtTypeReferenceImpl]megamek.common.Transporter> iter = [CtInvocationImpl][CtFieldReadImpl]transports.elements();
        [CtWhileImpl]while ([CtInvocationImpl][CtVariableReadImpl]iter.hasMoreElements()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next = [CtInvocationImpl][CtVariableReadImpl]iter.nextElement();
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Bay) && [CtInvocationImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.Bay) (next)).isQuarters()) [CtBlockImpl]{
                [CtContinueImpl]continue;
            }
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.DockingCollar) && [CtInvocationImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.DockingCollar) (next)).isDamaged()) [CtBlockImpl]{
                [CtContinueImpl]continue;
            }
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]ishtml && [CtBinaryOperatorImpl]([CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Bay)) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.Bay) (next)).getBayDamage() > [CtLiteralImpl]0)) [CtBlockImpl]{
                [CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]result.append([CtLiteralImpl]"<font color='red'>").append([CtInvocationImpl][CtVariableReadImpl]next.getUnusedString()).append([CtLiteralImpl]"</font>");
            } else [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]result.append([CtInvocationImpl][CtVariableReadImpl]next.getUnusedString());
            }
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]isOmni() && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.TroopSpace) || [CtBinaryOperatorImpl]([CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Bay))) [CtBlockImpl]{
                [CtIfImpl]if ([CtInvocationImpl][CtFieldReadImpl]omniPodTransports.contains([CtVariableReadImpl]next)) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]result.append([CtLiteralImpl]" (Pod)");
                } else [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]result.append([CtLiteralImpl]" (Fixed)");
                }
            }
            [CtIfImpl][CtCommentImpl]// Add a newline character between strings.
            if ([CtInvocationImpl][CtVariableReadImpl]iter.hasMoreElements()) [CtBlockImpl]{
                [CtIfImpl]if ([CtVariableReadImpl]ishtml) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]result.append([CtLiteralImpl]"<br>");
                } else [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]result.append([CtLiteralImpl]"\n");
                }
            }
        } 
        [CtReturnImpl][CtCommentImpl]// Return the String.
        return [CtInvocationImpl][CtVariableReadImpl]result.toString();
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Determine if transported units prevent a weapon in the given location
     * from firing.
     *
     * @param loc
     * 		- the <code>int</code> location attempting to fire.
     * @param isRear
     * 		- a <code>boolean</code> value stating if the given location
     * 		is rear facing; if <code>false</code>, the location is front
     * 		facing.
     * @return <code>true</code> if a transported unit is in the way,
    <code>false</code> if the weapon can fire.
     */
    [CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]boolean isWeaponBlockedAt([CtParameterImpl][CtTypeReferenceImpl]int loc, [CtParameterImpl][CtTypeReferenceImpl]boolean isRear) [CtBlockImpl]{
        [CtForEachImpl][CtCommentImpl]// Walk through this entity's transport components;
        [CtCommentImpl]// check each for blockage in turn.
        [CtCommentImpl]// Stop after the first match.
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]next.isWeaponBlockedAt([CtVariableReadImpl]loc, [CtVariableReadImpl]isRear)) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl][CtCommentImpl]// If we got here, none of our transports
        [CtCommentImpl]// carry a blocking unit at that location.
        return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * If a unit is being transported on the outside of the transporter, it can
     * suffer damage when the transporter is hit by an attack. Currently, no
     * more than one unit can be at any single location; that same unit can be
     * "spread" over multiple locations.
     *
     * @param loc
     * 		- the <code>int</code> location hit by attack.
     * @param isRear
     * 		- a <code>boolean</code> value stating if the given location
     * 		is rear facing; if <code>false</code>, the location is front
     * 		facing.
     * @return The <code>Entity</code> being transported on the outside at that
    location. This value will be <code>null</code> if no unit is
    transported on the outside at that location.
     */
    [CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]megamek.common.Entity getExteriorUnitAt([CtParameterImpl][CtTypeReferenceImpl]int loc, [CtParameterImpl][CtTypeReferenceImpl]boolean isRear) [CtBlockImpl]{
        [CtForEachImpl][CtCommentImpl]// Walk through this entity's transport components;
        [CtCommentImpl]// check each for an exterior unit in turn.
        [CtCommentImpl]// Stop after the first match.
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity exterior = [CtInvocationImpl][CtVariableReadImpl]next.getExteriorUnitAt([CtVariableReadImpl]loc, [CtVariableReadImpl]isRear);
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtLiteralImpl]null != [CtVariableReadImpl]exterior) [CtBlockImpl]{
                [CtReturnImpl]return [CtVariableReadImpl]exterior;
            }
        }
        [CtReturnImpl][CtCommentImpl]// If we got here, none of our transports
        [CtCommentImpl]// carry an exterior unit at that location.
        return [CtLiteralImpl]null;
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.Entity> getExternalUnits() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.Entity> rv = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.Entity>();
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter t : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]rv.addAll([CtInvocationImpl][CtVariableReadImpl]t.getExternalUnits());
        }
        [CtReturnImpl]return [CtVariableReadImpl]rv;
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]int getCargoMpReduction([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Entity carrier) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int rv = [CtLiteralImpl]0;
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter t : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtOperatorAssignmentImpl][CtVariableWriteImpl]rv += [CtInvocationImpl][CtVariableReadImpl]t.getCargoMpReduction([CtVariableReadImpl]carrier);
        }
        [CtReturnImpl]return [CtVariableReadImpl]rv;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]megamek.common.HitData getTrooperAtLocation([CtParameterImpl][CtTypeReferenceImpl]megamek.common.HitData hit, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.Entity transport) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]rollHitLocation([CtTypeAccessImpl]ToHitData.HIT_NORMAL, [CtTypeAccessImpl]ToHitData.SIDE_FRONT);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Record the ID of the <code>Entity</code> that has loaded this unit. A
     * unit that is unloaded can neither move nor attack for the rest of the
     * turn.
     *
     * @param transportId
     * 		- the <code>int</code> ID of our transport. The ID is
     * 		<b>not</b> validated. This value should be
     * 		<code>Entity.NONE</code> if this unit has been unloaded.
     */
    public [CtTypeReferenceImpl]void setTransportId([CtParameterImpl][CtTypeReferenceImpl]int transportId) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]conveyance = [CtVariableReadImpl]transportId;
        [CtIfImpl][CtCommentImpl]// If we were unloaded, set the appropriate flags.
        if ([CtBinaryOperatorImpl][CtVariableReadImpl]transportId == [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE) [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl]unloadedThisTurn = [CtLiteralImpl]true;
            [CtAssignmentImpl][CtFieldWriteImpl]done = [CtLiteralImpl]true;
        } else [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl]loadedThisTurn = [CtLiteralImpl]true;
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @return The number of additional crew capacity provided by quarters in transport bays.
     */
    public [CtTypeReferenceImpl]int getBayPersonnel() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int count = [CtLiteralImpl]0;
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Bay bay : [CtInvocationImpl][CtThisAccessImpl]this.getTransportBays()) [CtBlockImpl]{
            [CtOperatorAssignmentImpl][CtVariableWriteImpl]count += [CtInvocationImpl][CtVariableReadImpl]bay.getPersonnel([CtInvocationImpl]isClan());
        }
        [CtReturnImpl]return [CtVariableReadImpl]count;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Get the ID <code>Entity</code> that has loaded this one.
     *
     * @return the <code>int</code> ID of our transport. The ID may be invalid.
    This value should be <code>Entity.NONE</code> if this unit has
    not been loaded.
     */
    public [CtTypeReferenceImpl]int getTransportId() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]conveyance;
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]int hardpointCost() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]0;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Determine if this unit has an active and working stealth system.
     * <p/>
     * Sub-classes are encouraged to override this method.
     *
     * @return <code>true</code> if this unit has a stealth system that is
    currently active and it's actually working, <code>false</code> if
    there is no stealth system or if it is inactive.
     */
    public [CtTypeReferenceImpl]boolean isStealthActive() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Determine if this unit has an active and working stealth system.
     * <p/>
     * Sub-classes are encouraged to override this method.
     *
     * @return <code>true</code> if this unit has a stealth system that is
    currently active and it's actually working, <code>false</code> if
    there is no stealth system or if it is inactive.
     */
    public [CtTypeReferenceImpl]boolean isStealthOn() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Determine if this unit has an active null-signature system.
     * <p/>
     * Sub-classes are encouraged to override this method.
     *
     * @return <code>true</code> if this unit has a null signature system that
    is currently active, <code>false</code> if there is no stealth
    system or if it is inactive.
     */
    public [CtTypeReferenceImpl]boolean isNullSigActive() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Determine if this unit has an active null-signature system.
     * <p/>
     * Sub-classes are encouraged to override this method.
     *
     * @return <code>true</code> if this unit has a null signature system that
    is currently active, <code>false</code> if there is no stealth
    system or if it is inactive.
     */
    public [CtTypeReferenceImpl]boolean isNullSigOn() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Determine if this unit has an active void signature system that is
     * providing its benefits.
     * <p/>
     * Sub-classes are encouraged to override this method.
     *
     * @return <code>true</code> if this unit has a void signature system that
    is currently active, <code>false</code> if there is no stealth
    system or if it is inactive.
     */
    public [CtTypeReferenceImpl]boolean isVoidSigActive() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Determine if this unit has an active void signature system.
     * <p/>
     * Sub-classes are encouraged to override this method.
     *
     * @return <code>true</code> if this unit has a void signature system that
    is currently active, <code>false</code> if there is no stealth
    system or if it is turned off.
     */
    public [CtTypeReferenceImpl]boolean isVoidSigOn() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Determine if this unit has an active chameleon light polarization field.
     * <p/>
     * Sub-classes are encouraged to override this method.
     *
     * @return <code>true</code> if this unit has a void signature system that
    is currently active, <code>false</code> if there is no stealth
    system or if it is inactive.
     */
    public [CtTypeReferenceImpl]boolean isChameleonShieldActive() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Determine if this unit has an active chameleon light polarization field.
     * <p/>
     * Sub-classes are encouraged to override this method.
     *
     * @return <code>true</code> if this unit has a void signature system that
    is currently active, <code>false</code> if there is no stealth
    system or if it is inactive.
     */
    public [CtTypeReferenceImpl]boolean isChameleonShieldOn() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Determine the stealth modifier for firing at this unit from the given
     * range. If the value supplied for <code>range</code> is not one of the
     * <code>Entity</code> class range constants, an
     * <code>IllegalArgumentException</code> will be thrown.
     * <p/>
     * Sub-classes are encouraged to override this method.
     *
     * @param range
     * 		- an <code>int</code> value that must match one of the
     * 		<code>Compute</code> class range constants.
     * @param ae
     * 		- the entity making the attack, who maybe immune to certain
     * 		kinds of stealth
     * @return a <code>TargetRoll</code> value that contains the stealth
    modifier for the given range.
     */
    public [CtTypeReferenceImpl]megamek.common.TargetRoll getStealthModifier([CtParameterImpl][CtTypeReferenceImpl]int range, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.Entity ae) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.TargetRoll result = [CtLiteralImpl]null;
        [CtIfImpl][CtCommentImpl]// Stealth must be active.
        if ([CtUnaryOperatorImpl]![CtInvocationImpl]isStealthActive()) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]result = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.TargetRoll([CtLiteralImpl]0, [CtLiteralImpl]"stealth not active");
        }
        [CtSwitchImpl][CtCommentImpl]// Get the range modifier.
        switch ([CtVariableReadImpl]range) {
            [CtCaseImpl]case [CtFieldReadImpl]RangeType.RANGE_MINIMUM :
            [CtCaseImpl]case [CtFieldReadImpl]RangeType.RANGE_SHORT :
            [CtCaseImpl]case [CtFieldReadImpl]RangeType.RANGE_MEDIUM :
            [CtCaseImpl]case [CtFieldReadImpl]RangeType.RANGE_LONG :
            [CtCaseImpl]case [CtFieldReadImpl]RangeType.RANGE_EXTREME :
            [CtCaseImpl]case [CtFieldReadImpl]RangeType.RANGE_LOS :
            [CtCaseImpl]case [CtFieldReadImpl]RangeType.RANGE_OUT :
                [CtAssignmentImpl][CtVariableWriteImpl]result = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.TargetRoll([CtLiteralImpl]0, [CtLiteralImpl]"stealth not installed");
                [CtBreakImpl]break;
            [CtCaseImpl]default :
                [CtThrowImpl]throw [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.lang.IllegalArgumentException([CtBinaryOperatorImpl][CtLiteralImpl]"Unknown range constant: " + [CtVariableReadImpl]range);
        }
        [CtReturnImpl][CtCommentImpl]// Return the result.
        return [CtVariableReadImpl]result;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Record the ID of the <code>Entity</code> that is the current target of a
     * swarm attack by this unit. A unit that stops swarming can neither move
     * nor attack for the rest of the turn.
     *
     * @param id
     * 		- the <code>int</code> ID of the swarm attack's target. The ID
     * 		is <b>not</b> validated. This value should be
     * 		<code>Entity.NONE</code> if this unit has stopped swarming.
     */
    public [CtTypeReferenceImpl]void setSwarmTargetId([CtParameterImpl][CtTypeReferenceImpl]int id) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]swarmTargetId = [CtVariableReadImpl]id;
        [CtIfImpl][CtCommentImpl]// This entity can neither move nor attack for the rest of this turn.
        if ([CtBinaryOperatorImpl][CtVariableReadImpl]id == [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE) [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl]unloadedThisTurn = [CtLiteralImpl]true;
            [CtAssignmentImpl][CtFieldWriteImpl]done = [CtLiteralImpl]true;
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Get the ID of the <code>Entity</code> that is the current target of a
     * swarm attack by this unit.
     *
     * @return the <code>int</code> ID of the swarm attack's target The ID may
    be invalid. This value should be <code>Entity.NONE</code> if this
    unit is not swarming.
     */
    public [CtTypeReferenceImpl]int getSwarmTargetId() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]swarmTargetId;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Record the ID of the <code>Entity</code> that is attacking this unit with
     * a swarm attack.
     *
     * @param id
     * 		- the <code>int</code> ID of the swarm attack's attacker. The
     * 		ID is <b>not</b> validated. This value should be
     * 		<code>Entity.NONE</code> if the swarm attack has ended.
     */
    public [CtTypeReferenceImpl]void setSwarmAttackerId([CtParameterImpl][CtTypeReferenceImpl]int id) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]swarmAttackerId = [CtVariableReadImpl]id;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Get the ID of the <code>Entity</code> that is attacking this unit with a
     * swarm attack.
     *
     * @return the <code>int</code> ID of the swarm attack's attacker The ID may
    be invalid. This value should be <code>Entity.NONE</code> if this
    unit is not being swarmed.
     */
    public [CtTypeReferenceImpl]int getSwarmAttackerId() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]swarmAttackerId;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Scans through the ammo on the unit for any inferno rounds.
     *
     * @return <code>true</code> if the unit is still loaded with Inferno
    rounds. <code>false</code> if no rounds were ever loaded or if
    they have all been fired.
     */
    public [CtTypeReferenceImpl]boolean hasInfernoAmmo() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]boolean found = [CtLiteralImpl]false;
        [CtForEachImpl][CtCommentImpl]// Walk through the unit's ammo, stop when we find a match.
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted amounted : [CtInvocationImpl]getAmmo()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.AmmoType atype = [CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.AmmoType) ([CtVariableReadImpl]amounted.getType()));
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]atype.getAmmoType() == [CtFieldReadImpl]AmmoType.T_SRM) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]atype.getAmmoType() == [CtFieldReadImpl]AmmoType.T_SRM_IMP)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]atype.getAmmoType() == [CtFieldReadImpl]AmmoType.T_MML)) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]atype.getMunitionType() == [CtFieldReadImpl]AmmoType.M_INFERNO)) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]amounted.getHittableShotsLeft() > [CtLiteralImpl]0)) [CtBlockImpl]{
                [CtAssignmentImpl][CtVariableWriteImpl]found = [CtLiteralImpl]true;
            }
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]atype.getAmmoType() == [CtFieldReadImpl]AmmoType.T_IATM) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]atype.getMunitionType() == [CtFieldReadImpl]AmmoType.M_IATM_IIW)) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]amounted.getHittableShotsLeft() > [CtLiteralImpl]0)) [CtBlockImpl]{
                [CtAssignmentImpl][CtVariableWriteImpl]found = [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]found;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Record if the unit is just combat-lossed or if it has been utterly
     * destroyed.
     *
     * @param canSalvage
     * 		- a <code>boolean</code> that is <code>true</code> if the unit
     * 		can be repaired (given time and parts); if this value is
     * 		<code>false</code>, the unit is utterly destroyed.
     */
    public [CtTypeReferenceImpl]void setSalvage([CtParameterImpl][CtTypeReferenceImpl]boolean canSalvage) [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// Unsalvageable entities aren't in retreat or salvageable.
        if ([CtUnaryOperatorImpl]![CtVariableReadImpl]canSalvage) [CtBlockImpl]{
            [CtInvocationImpl]setRemovalCondition([CtTypeAccessImpl]IEntityRemovalConditions.REMOVE_DEVASTATED);
        }
        [CtAssignmentImpl][CtFieldWriteImpl]salvageable = [CtVariableReadImpl]canSalvage;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Determine if the unit is just combat-lossed or if it has been utterly
     * destroyed.
     *
     * @return A <code>boolean</code> that is <code>true</code> if the unit has
    salvageable components; if this value is <code>false</code> the
    unit is utterly destroyed.
     * @see #isRepairable()
     */
    public [CtTypeReferenceImpl]boolean isSalvage() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]salvageable;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Determine if the unit can be repaired, or only harvested for spares.
     *
     * @return A <code>boolean</code> that is <code>true</code> if the unit can
    be repaired (given enough time and parts); if this value is
    <code>false</code>, the unit is only a source of spares.
     * @see #isSalvage()
     */
    public [CtTypeReferenceImpl]boolean isRepairable() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]isSalvage();
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Getter for property removalCondition.
     *
     * @return Value of property removalCondition.
     */
    public [CtTypeReferenceImpl]int getRemovalCondition() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]removalCondition;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Setter for property removalCondition.
     *
     * @param removalCondition
     * 		New value of property removalCondition.
     */
    public [CtTypeReferenceImpl]void setRemovalCondition([CtParameterImpl][CtTypeReferenceImpl]int removalCondition) [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// Don't replace a removal condition with a lesser condition.
        if ([CtBinaryOperatorImpl][CtFieldReadImpl][CtThisAccessImpl]this.removalCondition < [CtVariableReadImpl]removalCondition) [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.removalCondition = [CtVariableReadImpl]removalCondition;
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @return whether this entity is clearing a minefield.
     */
    public [CtTypeReferenceImpl]boolean isClearingMinefield() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]clearingMinefield;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @param clearingMinefield
     */
    public [CtTypeReferenceImpl]void setClearingMinefield([CtParameterImpl][CtTypeReferenceImpl]boolean clearingMinefield) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.clearingMinefield = [CtVariableReadImpl]clearingMinefield;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @return whether this entity is spotting this round.
     */
    public [CtTypeReferenceImpl]boolean isSpotting() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]spotting;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @param spotting
     */
    public [CtTypeReferenceImpl]void setSpotting([CtParameterImpl][CtTypeReferenceImpl]boolean spotting) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.spotting = [CtVariableReadImpl]spotting;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Um, basically everything can spot for LRM indirect fire.
     *
     * @return true, if the entity is active
     */
    public [CtTypeReferenceImpl]boolean canSpot() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVANCED_PILOTS_CANNOT_SPOT) && [CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.MechWarrior)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtInvocationImpl]isActive() && [CtUnaryOperatorImpl](![CtInvocationImpl]isOffBoard());
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]java.lang.String toString() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtLiteralImpl]"Entity [" + [CtInvocationImpl]getDisplayName()) + [CtLiteralImpl]", ") + [CtInvocationImpl]getId()) + [CtLiteralImpl]"]";
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * This returns a textual description of the entity for visualy impaired
     * users.
     */
    public [CtTypeReferenceImpl]java.lang.String statusToString() [CtBlockImpl]{
        [CtLocalVariableImpl][CtCommentImpl]// should include additional information like imobile.
        [CtTypeReferenceImpl]java.lang.String str = [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtLiteralImpl]"Entity [" + [CtInvocationImpl]getDisplayName()) + [CtLiteralImpl]", ") + [CtInvocationImpl]getId()) + [CtLiteralImpl]"]: ";
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]getPosition() != [CtLiteralImpl]null) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]str = [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]str + [CtLiteralImpl]"Location: (") + [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl]getPosition().getX() + [CtLiteralImpl]1)) + [CtLiteralImpl]", ") + [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl]getPosition().getY() + [CtLiteralImpl]1)) + [CtLiteralImpl]") ";
        }
        [CtAssignmentImpl][CtVariableWriteImpl]str = [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]str + [CtLiteralImpl]"Owner: ") + [CtInvocationImpl][CtFieldReadImpl]owner.getName()) + [CtLiteralImpl]" Armor: ") + [CtInvocationImpl]getTotalArmor()) + [CtLiteralImpl]"/") + [CtInvocationImpl]getTotalOArmor()) + [CtLiteralImpl]" Internal Structure: ") + [CtInvocationImpl]getTotalInternal()) + [CtLiteralImpl]"/") + [CtInvocationImpl]getTotalOInternal();
        [CtIfImpl]if ([CtUnaryOperatorImpl]![CtInvocationImpl]isActive()) [CtBlockImpl]{
            [CtOperatorAssignmentImpl][CtVariableWriteImpl]str += [CtLiteralImpl]" Inactive";
        }
        [CtIfImpl]if ([CtInvocationImpl]isImmobile()) [CtBlockImpl]{
            [CtOperatorAssignmentImpl][CtVariableWriteImpl]str += [CtLiteralImpl]" Immobile";
        }
        [CtIfImpl]if ([CtInvocationImpl]isProne()) [CtBlockImpl]{
            [CtOperatorAssignmentImpl][CtVariableWriteImpl]str += [CtLiteralImpl]" Prone";
        }
        [CtIfImpl]if ([CtInvocationImpl]isDone()) [CtBlockImpl]{
            [CtOperatorAssignmentImpl][CtVariableWriteImpl]str += [CtLiteralImpl]" Done";
        }
        [CtReturnImpl]return [CtVariableReadImpl]str;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * This returns a textual description of a specific location of the entity
     * for visualy impaired users.
     *
     * @param loc
     * 		the location
     * @return a string descibing the status of the location.
     */
    public [CtTypeReferenceImpl]java.lang.String statusToString([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]loc == [CtFieldReadImpl]megamek.common.Entity.LOC_NONE) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"No location given.";
        }
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]getLocationName([CtVariableReadImpl]loc) + [CtLiteralImpl]" (") + [CtInvocationImpl]getLocationAbbr([CtVariableReadImpl]loc)) + [CtLiteralImpl]"): Armor: ") + [CtInvocationImpl]getArmorString([CtVariableReadImpl]loc)) + [CtLiteralImpl]"/") + [CtInvocationImpl]getOArmor([CtVariableReadImpl]loc)) + [CtLiteralImpl]" Structure: ") + [CtInvocationImpl]getInternalString([CtVariableReadImpl]loc)) + [CtLiteralImpl]"/") + [CtInvocationImpl]getOInternal([CtVariableReadImpl]loc);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @param str
     * 		a string defining the location
     * @return the status of the given location.
     */
    public [CtTypeReferenceImpl]java.lang.String statusToString([CtParameterImpl][CtTypeReferenceImpl]java.lang.String str) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int loc = [CtFieldReadImpl]megamek.common.Entity.LOC_NONE;
        [CtAssignmentImpl][CtVariableWriteImpl]loc = [CtInvocationImpl]getLocationFromAbbr([CtVariableReadImpl]str);
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]loc == [CtFieldReadImpl]megamek.common.Entity.LOC_NONE) [CtBlockImpl]{
            [CtTryImpl]try [CtBlockImpl]{
                [CtAssignmentImpl][CtVariableWriteImpl]loc = [CtInvocationImpl][CtTypeAccessImpl]java.lang.Integer.parseInt([CtVariableReadImpl]str);
            }[CtCatchImpl] catch ([CtCatchVariableImpl][CtTypeReferenceImpl]java.lang.NumberFormatException nfe) [CtBlockImpl]{
                [CtAssignmentImpl][CtVariableWriteImpl]loc = [CtFieldReadImpl]megamek.common.Entity.LOC_NONE;
            }
        }
        [CtReturnImpl]return [CtInvocationImpl]statusToString([CtVariableReadImpl]loc);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * The round the unit will be deployed. We will deploy at the end of a
     * round. So if depoyRound is set to 5, we will deploy when round 5 is over.
     * Any value of zero or less is automatically set to 1
     *
     * @param deployRound
     * 		an int
     */
    public [CtTypeReferenceImpl]void setDeployRound([CtParameterImpl][CtTypeReferenceImpl]int deployRound) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.deployRound = [CtVariableReadImpl]deployRound;
        [CtForEachImpl][CtCommentImpl]// also set this for any transported units
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter transport : [CtInvocationImpl]getTransports()) [CtBlockImpl]{
            [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity e : [CtInvocationImpl][CtVariableReadImpl]transport.getLoadedUnits()) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]e.setDeployRound([CtVariableReadImpl]deployRound);
            }
        }
        [CtIfImpl][CtCommentImpl]// Entity's that deploy after the start can set their own deploy zone
        [CtCommentImpl]// If the deployRound is being set back to 0, make sure we reset the
        [CtCommentImpl]// starting position (START_NONE implies inheritance from owning player)
        if ([CtBinaryOperatorImpl][CtVariableReadImpl]deployRound == [CtLiteralImpl]0) [CtBlockImpl]{
            [CtInvocationImpl]setStartingPos([CtTypeAccessImpl]Board.START_NONE);
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * The round the unit will be deployed
     *
     * @return an int
     */
    public [CtTypeReferenceImpl]int getDeployRound() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]deployRound;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Toggles if an entity has been deployed
     */
    public [CtTypeReferenceImpl]void setDeployed([CtParameterImpl][CtTypeReferenceImpl]boolean deployed) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.deployed = [CtVariableReadImpl]deployed;
        [CtIfImpl]if ([CtVariableReadImpl]deployed) [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl]neverDeployed = [CtLiteralImpl]false;
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks to see if an entity has been deployed
     */
    public [CtTypeReferenceImpl]boolean isDeployed() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]deployed;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks to see if entity was never deployed
     */
    public [CtTypeReferenceImpl]boolean wasNeverDeployed() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]neverDeployed;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Toggles if an entity has been deployed
     */
    public [CtTypeReferenceImpl]void setNeverDeployed([CtParameterImpl][CtTypeReferenceImpl]boolean neverDeployed) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.neverDeployed = [CtVariableReadImpl]neverDeployed;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns true if the entity should be deployed
     */
    public [CtTypeReferenceImpl]boolean shouldDeploy([CtParameterImpl][CtTypeReferenceImpl]int round) [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtUnaryOperatorImpl](![CtFieldReadImpl]deployed) && [CtBinaryOperatorImpl]([CtInvocationImpl]getDeployRound() <= [CtVariableReadImpl]round)) && [CtUnaryOperatorImpl](![CtInvocationImpl]isOffBoard());
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns true if the offboard entity should be deployed this round.
     *
     * @param round
     * 		The current round number.
     * @return True if and only if the offboard entity should deploy this
    round, otherwise false.
     */
    public [CtTypeReferenceImpl]boolean shouldOffboardDeploy([CtParameterImpl][CtTypeReferenceImpl]int round) [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtInvocationImpl]isOffBoard() && [CtBinaryOperatorImpl]([CtUnaryOperatorImpl](![CtFieldReadImpl]deployed) && [CtBinaryOperatorImpl]([CtInvocationImpl]getDeployRound() <= [CtVariableReadImpl]round));
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Set the unit number for this entity.
     *
     * @param unit
     * 		the number for the low-level unit that this
     * 		entity belongs to. This entity can be removed from its unit by
     * 		passing the value, <code>{@link Entity#NONE}</code>.
     */
    public [CtTypeReferenceImpl]void setUnitNumber([CtParameterImpl]final [CtTypeReferenceImpl]short unit) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]unitNumber = [CtVariableReadImpl]unit;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Get the unit number of this entity.
     *
     * @return The unit number. If the entity does not belong
    to a unit, <code>{@link Entity#NONE}</code> will be returned.
     */
    public [CtTypeReferenceImpl]short getUnitNumber() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]unitNumber;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns whether an entity can flee from its current position. Currently
     * returns true if the entity is on the edge of the board.
     */
    public [CtTypeReferenceImpl]boolean canFlee() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Coords pos = [CtInvocationImpl]getPosition();
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]pos != [CtLiteralImpl]null) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]getWalkMP() > [CtLiteralImpl]0) || [CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Infantry))) && [CtUnaryOperatorImpl](![CtInvocationImpl]isProne())) && [CtUnaryOperatorImpl](![CtInvocationImpl]isStuck())) && [CtUnaryOperatorImpl](![CtInvocationImpl]isShutDown())) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl]getCrew().isUnconscious())) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]pos.getX() == [CtLiteralImpl]0) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]pos.getX() == [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().getWidth() - [CtLiteralImpl]1))) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]pos.getY() == [CtLiteralImpl]0)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]pos.getY() == [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().getHeight() - [CtLiteralImpl]1)));
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setEverSeenByEnemy([CtParameterImpl][CtTypeReferenceImpl]boolean b) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]everSeenByEnemy = [CtVariableReadImpl]b;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isEverSeenByEnemy() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]everSeenByEnemy;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setVisibleToEnemy([CtParameterImpl][CtTypeReferenceImpl]boolean b) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]visibleToEnemy = [CtVariableReadImpl]b;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isVisibleToEnemy() [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// If double blind isn't on, the unit is always visible
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtFieldReadImpl]game != [CtLiteralImpl]null) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVANCED_DOUBLE_BLIND))) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]true;
        }
        [CtReturnImpl]return [CtFieldReadImpl]visibleToEnemy;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setDetectedByEnemy([CtParameterImpl][CtTypeReferenceImpl]boolean b) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]detectedByEnemy = [CtVariableReadImpl]b;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isDetectedByEnemy() [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// If double blind isn't on, the unit is always detected
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtFieldReadImpl]game != [CtLiteralImpl]null) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVANCED_DOUBLE_BLIND))) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]true;
        }
        [CtReturnImpl]return [CtFieldReadImpl]detectedByEnemy;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void addBeenSeenBy([CtParameterImpl][CtTypeReferenceImpl]megamek.common.IPlayer p) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]p != [CtLiteralImpl]null) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtFieldReadImpl]entitySeenBy.contains([CtVariableReadImpl]p))) [CtBlockImpl]{
            [CtInvocationImpl][CtFieldReadImpl]entitySeenBy.add([CtVariableReadImpl]p);
        }
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.IPlayer> getWhoCanSee() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]entitySeenBy;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setWhoCanSee([CtParameterImpl][CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.IPlayer> entitySeenBy) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.entitySeenBy = [CtVariableReadImpl]entitySeenBy;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void clearSeenBy() [CtBlockImpl]{
        [CtInvocationImpl][CtFieldReadImpl]entitySeenBy.clear();
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns true if the the given player can see this Entity, including
     * teammates if team_vision is on.
     */
    public [CtTypeReferenceImpl]boolean hasSeenEntity([CtParameterImpl][CtTypeReferenceImpl]megamek.common.IPlayer p) [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// No double blind - everyone sees everything
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtFieldReadImpl]game == [CtLiteralImpl]null) || [CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVANCED_DOUBLE_BLIND))) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]true;
        }
        [CtIfImpl][CtCommentImpl]// Null players see nothing
        if ([CtBinaryOperatorImpl][CtVariableReadImpl]p == [CtLiteralImpl]null) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl][CtCommentImpl]// A Player can always see their own 'mechs
        if ([CtInvocationImpl][CtInvocationImpl]getOwner().equals([CtVariableReadImpl]p)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]true;
        }
        [CtIfImpl][CtCommentImpl]// If a player can see all, it sees this
        if ([CtInvocationImpl][CtVariableReadImpl]p.canSeeAll()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]true;
        }
        [CtIfImpl][CtCommentImpl]// Observers can see units spotted by an enemy
        if ([CtInvocationImpl][CtVariableReadImpl]p.isObserver()) [CtBlockImpl]{
            [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.IPlayer other : [CtFieldReadImpl]entitySeenBy) [CtBlockImpl]{
                [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]other.isEnemyOf([CtInvocationImpl]getOwner())) [CtBlockImpl]{
                    [CtReturnImpl]return [CtLiteralImpl]true;
                }
            }
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl]if ([CtInvocationImpl][CtFieldReadImpl]entitySeenBy.contains([CtVariableReadImpl]p)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]true;
        }
        [CtIfImpl][CtCommentImpl]// If team vision, see if any players on team can see
        if ([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVANCED_TEAM_VISION)) [CtBlockImpl]{
            [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.IPlayer teammate : [CtInvocationImpl][CtFieldReadImpl]game.getPlayersVector()) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]teammate.getTeam() == [CtInvocationImpl][CtVariableReadImpl]p.getTeam()) && [CtInvocationImpl][CtFieldReadImpl]entitySeenBy.contains([CtVariableReadImpl]teammate)) [CtBlockImpl]{
                    [CtReturnImpl]return [CtLiteralImpl]true;
                }
            }
        }
        [CtReturnImpl][CtCommentImpl]// Can't see
        return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void addBeenDetectedBy([CtParameterImpl][CtTypeReferenceImpl]megamek.common.IPlayer p) [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// This is for saved-game backwards compatibility
        if ([CtBinaryOperatorImpl][CtFieldReadImpl]entityDetectedBy == [CtLiteralImpl]null) [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl]entityDetectedBy = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.IPlayer>();
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]p != [CtLiteralImpl]null) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtFieldReadImpl]entityDetectedBy.contains([CtVariableReadImpl]p))) [CtBlockImpl]{
            [CtInvocationImpl][CtFieldReadImpl]entityDetectedBy.add([CtVariableReadImpl]p);
        }
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.IPlayer> getWhoCanDetect() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]entityDetectedBy;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setWhoCanDetect([CtParameterImpl][CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.IPlayer> entityDetectedBy) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.entityDetectedBy = [CtVariableReadImpl]entityDetectedBy;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void clearDetectedBy() [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// This is for saved-game backwards compatibility
        if ([CtBinaryOperatorImpl][CtFieldReadImpl]entityDetectedBy == [CtLiteralImpl]null) [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl]entityDetectedBy = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.IPlayer>();
        }
        [CtInvocationImpl][CtFieldReadImpl]entityDetectedBy.clear();
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns true if the the given player can see this Entity, including
     * teammates if team_vision is on.
     */
    public [CtTypeReferenceImpl]boolean hasDetectedEntity([CtParameterImpl][CtTypeReferenceImpl]megamek.common.IPlayer p) [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// No sensors - no one detects anything
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtFieldReadImpl]game == [CtLiteralImpl]null) || [CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVANCED_TACOPS_SENSORS))) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl][CtCommentImpl]// Null players detect nothing
        if ([CtBinaryOperatorImpl][CtVariableReadImpl]p == [CtLiteralImpl]null) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl][CtCommentImpl]// This is for saved-game backwards compatibility
        if ([CtBinaryOperatorImpl][CtFieldReadImpl]entityDetectedBy == [CtLiteralImpl]null) [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl]entityDetectedBy = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.IPlayer>();
        }
        [CtIfImpl][CtCommentImpl]// Observers can detect units detected by an enemy
        if ([CtInvocationImpl][CtVariableReadImpl]p.isObserver()) [CtBlockImpl]{
            [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.IPlayer other : [CtFieldReadImpl]entityDetectedBy) [CtBlockImpl]{
                [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]other.isEnemyOf([CtInvocationImpl]getOwner())) [CtBlockImpl]{
                    [CtReturnImpl]return [CtLiteralImpl]true;
                }
            }
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl]if ([CtInvocationImpl][CtFieldReadImpl]entityDetectedBy.contains([CtVariableReadImpl]p)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]true;
        }
        [CtIfImpl][CtCommentImpl]// If team vision, see if any players on team can see
        if ([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVANCED_TEAM_VISION)) [CtBlockImpl]{
            [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.IPlayer teammate : [CtInvocationImpl][CtFieldReadImpl]game.getPlayersVector()) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]teammate.getTeam() == [CtInvocationImpl][CtVariableReadImpl]p.getTeam()) && [CtInvocationImpl][CtFieldReadImpl]entityDetectedBy.contains([CtVariableReadImpl]teammate)) [CtBlockImpl]{
                    [CtReturnImpl]return [CtLiteralImpl]true;
                }
            }
        }
        [CtReturnImpl][CtCommentImpl]// Can't see
        return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns whether this Entity is a sensor return to the given player.
     *
     * @param spotter
     * 		The player trying to view this unit
     * @return True if the given player can only see this Entity as a sensor
    return
     */
    public [CtTypeReferenceImpl]boolean isSensorReturn([CtParameterImpl][CtTypeReferenceImpl]megamek.common.IPlayer spotter) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]boolean alliedUnit = [CtBinaryOperatorImpl][CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl]getOwner().isEnemyOf([CtVariableReadImpl]spotter)) || [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl]getOwner().getTeam() == [CtInvocationImpl][CtVariableReadImpl]spotter.getTeam()) && [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVANCED_TEAM_VISION));
        [CtLocalVariableImpl][CtTypeReferenceImpl]boolean sensors = [CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVANCED_TACOPS_SENSORS) || [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVAERORULES_STRATOPS_ADVANCED_SENSORS);
        [CtLocalVariableImpl][CtTypeReferenceImpl]boolean sensorsDetectAll = [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVANCED_SENSORS_DETECT_ALL);
        [CtLocalVariableImpl][CtTypeReferenceImpl]boolean doubleBlind = [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVANCED_DOUBLE_BLIND);
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]sensors && [CtVariableReadImpl]doubleBlind) && [CtUnaryOperatorImpl](![CtVariableReadImpl]alliedUnit)) && [CtUnaryOperatorImpl](![CtVariableReadImpl]sensorsDetectAll)) && [CtUnaryOperatorImpl](![CtInvocationImpl]hasSeenEntity([CtVariableReadImpl]spotter))) && [CtInvocationImpl]hasDetectedEntity([CtVariableReadImpl]spotter);
    }

    [CtMethodImpl]protected [CtTypeReferenceImpl]int applyGravityEffectsOnMP([CtParameterImpl][CtTypeReferenceImpl]int MP) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int result = [CtVariableReadImpl]MP;
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]game != [CtLiteralImpl]null) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]float fMP = [CtBinaryOperatorImpl][CtVariableReadImpl]MP / [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getPlanetaryConditions().getGravity();
            [CtAssignmentImpl][CtVariableWriteImpl]fMP = [CtConditionalImpl]([CtBinaryOperatorImpl][CtInvocationImpl][CtTypeAccessImpl]java.lang.Math.abs([CtBinaryOperatorImpl][CtInvocationImpl][CtTypeAccessImpl]java.lang.Math.round([CtVariableReadImpl]fMP) - [CtVariableReadImpl]fMP) == [CtLiteralImpl]0.5) ? [CtInvocationImpl](([CtTypeReferenceImpl]float) ([CtTypeAccessImpl]java.lang.Math.floor([CtVariableReadImpl]fMP))) : [CtInvocationImpl][CtTypeAccessImpl]java.lang.Math.round([CtVariableReadImpl]fMP);[CtCommentImpl]// the

            [CtAssignmentImpl][CtCommentImpl]// rule
            [CtCommentImpl]// requires
            [CtCommentImpl]// rounding down on .5
            [CtVariableWriteImpl]result = [CtVariableReadImpl](([CtTypeReferenceImpl]int) (fMP));
        }
        [CtReturnImpl]return [CtVariableReadImpl]result;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Whether this type of unit can perform charges
     */
    public [CtTypeReferenceImpl]boolean canCharge() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtUnaryOperatorImpl](![CtInvocationImpl]isImmobile()) && [CtBinaryOperatorImpl]([CtInvocationImpl]getWalkMP() > [CtLiteralImpl]0)) && [CtUnaryOperatorImpl](![CtInvocationImpl]isStuck())) && [CtUnaryOperatorImpl](![CtInvocationImpl]isProne());
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Whether this type of unit can perform DFA attacks
     */
    public [CtTypeReferenceImpl]boolean canDFA() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtUnaryOperatorImpl](![CtInvocationImpl]isImmobile()) && [CtBinaryOperatorImpl]([CtInvocationImpl]getJumpMP() > [CtLiteralImpl]0)) && [CtUnaryOperatorImpl](![CtInvocationImpl]isStuck())) && [CtUnaryOperatorImpl](![CtInvocationImpl]isProne());
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Whether this type of unit can perform Ramming attacks
     */
    public [CtTypeReferenceImpl]boolean canRam() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isUsingManAce() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.PILOT_MANEUVERING_ACE);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.util.Enumeration<[CtTypeReferenceImpl]megamek.common.Entity> getKills() [CtBlockImpl]{
        [CtLocalVariableImpl]final [CtTypeReferenceImpl]int killer = [CtFieldReadImpl]id;
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]game.getSelectedOutOfGameEntities([CtNewClassImpl]new [CtTypeReferenceImpl]megamek.common.EntitySelector()[CtClassImpl] {
            [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
            public [CtTypeReferenceImpl]boolean accept([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Entity entity) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]killer == [CtFieldReadImpl][CtVariableReadImpl]entity.killerId) [CtBlockImpl]{
                    [CtReturnImpl]return [CtLiteralImpl]true;
                }
                [CtReturnImpl]return [CtLiteralImpl]false;
            }
        });
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getKillNumber() [CtBlockImpl]{
        [CtLocalVariableImpl]final [CtTypeReferenceImpl]int killer = [CtFieldReadImpl]id;
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]game.getSelectedOutOfGameEntityCount([CtNewClassImpl]new [CtTypeReferenceImpl]megamek.common.EntitySelector()[CtClassImpl] {
            [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
            public [CtTypeReferenceImpl]boolean accept([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Entity entity) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]killer == [CtFieldReadImpl][CtVariableReadImpl]entity.killerId) [CtBlockImpl]{
                    [CtReturnImpl]return [CtLiteralImpl]true;
                }
                [CtReturnImpl]return [CtLiteralImpl]false;
            }
        });
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void addKill([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Entity kill) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtVariableReadImpl]kill.killerId = [CtFieldReadImpl]id;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean getGaveKillCredit() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtFieldReadImpl]killerId != [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getKillerId() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]killerId;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Determines if an entity is eligible for a phase.
     */
    public [CtTypeReferenceImpl]boolean isEligibleFor([CtParameterImpl][CtTypeReferenceImpl][CtTypeReferenceImpl]megamek.common.IGame.Phase phase) [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// only deploy in deployment phase
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]phase == [CtFieldReadImpl]megamek.common.IGame.Phase.PHASE_DEPLOYMENT) == [CtInvocationImpl]isDeployed()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl][CtCommentImpl]// carcass can't do anything
        if ([CtInvocationImpl]isCarcass()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl][CtCommentImpl]// Hidden units shouldn't be counted for turn order, unless deploying
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl]isHidden() && [CtBinaryOperatorImpl]([CtVariableReadImpl]phase != [CtFieldReadImpl]megamek.common.IGame.Phase.PHASE_DEPLOYMENT)) && [CtBinaryOperatorImpl]([CtVariableReadImpl]phase != [CtFieldReadImpl]megamek.common.IGame.Phase.PHASE_FIRING)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtSwitchImpl]switch ([CtVariableReadImpl]phase) {
            [CtCaseImpl]case [CtFieldReadImpl]PHASE_MOVEMENT :
                [CtReturnImpl]return [CtInvocationImpl]isEligibleForMovement();
            [CtCaseImpl]case [CtFieldReadImpl]PHASE_FIRING :
                [CtReturnImpl]return [CtInvocationImpl]isEligibleForFiring();
            [CtCaseImpl]case [CtFieldReadImpl]PHASE_PHYSICAL :
                [CtReturnImpl]return [CtInvocationImpl]isEligibleForPhysical();
            [CtCaseImpl]case [CtFieldReadImpl]PHASE_TARGETING :
                [CtReturnImpl]return [CtInvocationImpl]isEligibleForTargetingPhase();
            [CtCaseImpl]case [CtFieldReadImpl]PHASE_OFFBOARD :
                [CtReturnImpl]return [CtInvocationImpl]isEligibleForOffboard();
            [CtCaseImpl]default :
                [CtReturnImpl]return [CtLiteralImpl]true;
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Determines if an entity is eligible for a phase. Called only if at least
     * one entity returned true to isEligibleFor() This is for using
     * searchlights in physical&offboard phase, without forcing the phase to be
     * played when not needed. However it could be used for other things in the
     * future
     */
    public [CtTypeReferenceImpl]boolean canAssist([CtParameterImpl][CtTypeReferenceImpl][CtTypeReferenceImpl]megamek.common.IGame.Phase phase) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]phase != [CtFieldReadImpl]megamek.common.IGame.Phase.PHASE_PHYSICAL) && [CtBinaryOperatorImpl]([CtVariableReadImpl]phase != [CtFieldReadImpl]megamek.common.IGame.Phase.PHASE_FIRING)) && [CtBinaryOperatorImpl]([CtVariableReadImpl]phase != [CtFieldReadImpl]megamek.common.IGame.Phase.PHASE_OFFBOARD)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl][CtCommentImpl]// if you're charging or finding a club, it's already declared
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]isUnjammingRAC() || [CtInvocationImpl]isCharging()) || [CtInvocationImpl]isMakingDfa()) || [CtInvocationImpl]isRamming()) || [CtInvocationImpl]isFindingClub()) || [CtInvocationImpl]isOffBoard()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl][CtCommentImpl]// must be active
        if ([CtUnaryOperatorImpl]![CtInvocationImpl]isActive()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl][CtCommentImpl]// If we have a searchlight, we can use it to assist
        if ([CtInvocationImpl]isUsingSpotlight()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]true;
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * An entity is eligible if its to-hit number is anything but impossible.
     * This is only really an issue if friendly fire is turned off.
     */
    public [CtTypeReferenceImpl]boolean isEligibleForFiring() [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// if you're charging, no shooting
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]isUnjammingRAC() || [CtInvocationImpl]isCharging()) || [CtInvocationImpl]isMakingDfa()) || [CtInvocationImpl]isRamming()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl][CtCommentImpl]// if you're offboard, no shooting
        if ([CtBinaryOperatorImpl][CtInvocationImpl]isOffBoard() || [CtInvocationImpl]isAssaultDropInProgress()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl][CtCommentImpl]// check game options
        if ([CtUnaryOperatorImpl]![CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.BASE_SKIP_INELIGABLE_FIRING)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]true;
        }
        [CtIfImpl][CtCommentImpl]// must be active
        if ([CtUnaryOperatorImpl]![CtInvocationImpl]isActive()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtReturnImpl][CtCommentImpl]// Check for weapons. If we find them, return true. Otherwise... we
        [CtCommentImpl]// return false.
        [CtCommentImpl]// Bug 3648: No, no, no - you cannot skip units with no weapons - what
        [CtCommentImpl]// about spotting, unjamming, etc.?
        [CtCommentImpl]/* for (Mounted mounted : getWeaponList()) { WeaponType wtype =
        (WeaponType) mounted.getType(); if ((wtype != null) &&
        (!wtype.hasFlag(WeaponType.F_AMS) && !wtype.hasFlag(WeaponType.F_TAG)
        && mounted.isReady() && ((mounted.getLinked() == null) || (mounted
        .getLinked().getUsableShotsLeft() > 0)))) { return true; } }
         */
        return [CtLiteralImpl]true;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Pretty much anybody's eligible for movement. If the game option is
     * toggled on, inactive and immobile entities are not eligible. OffBoard
     * units are always ineligible
     *
     * @return whether or not the entity is allowed to move
     */
    public [CtTypeReferenceImpl]boolean isEligibleForMovement() [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// check if entity is offboard
        if ([CtBinaryOperatorImpl][CtInvocationImpl]isOffBoard() || [CtBinaryOperatorImpl]([CtInvocationImpl]isAssaultDropInProgress() && [CtUnaryOperatorImpl](![CtBinaryOperatorImpl]([CtFieldReadImpl]movementMode == [CtFieldReadImpl]EntityMovementMode.WIGE)))) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl][CtCommentImpl]// Prevent ejected crews from moving when advanced movement rule is off
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtUnaryOperatorImpl](![CtInvocationImpl][CtFieldReadImpl]game.useVectorMove()) && [CtInvocationImpl]isSpaceborne()) && [CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.EjectedCrew)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl][CtCommentImpl]// check game options
        if ([CtUnaryOperatorImpl]![CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.BASE_SKIP_INELIGABLE_MOVEMENT)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]true;
        }
        [CtLocalVariableImpl][CtCommentImpl]// Must be active: this is slightly different  from isActive();
        [CtCommentImpl]// we don't want to skip manually shutdown units (so they can restart)
        [CtTypeReferenceImpl]boolean isActive = [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtUnaryOperatorImpl](![CtFieldReadImpl]shutDown) || [CtInvocationImpl]isManualShutdown()) && [CtUnaryOperatorImpl](![CtFieldReadImpl]destroyed)) && [CtInvocationImpl][CtInvocationImpl]getCrew().isActive()) && [CtUnaryOperatorImpl](![CtFieldReadImpl]unloadedThisTurn)) && [CtFieldReadImpl]deployed;
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtUnaryOperatorImpl](![CtVariableReadImpl]isActive) || [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]isImmobile() && [CtUnaryOperatorImpl](![CtInvocationImpl]isManualShutdown())) && [CtUnaryOperatorImpl](![CtInvocationImpl]canUnjamRAC())) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVGRNDMOV_VEHICLES_CAN_EJECT)))) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtReturnImpl]return [CtLiteralImpl]true;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isEligibleForOffboard() [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// if you're charging, no shooting
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl]isUnjammingRAC() || [CtInvocationImpl]isCharging()) || [CtInvocationImpl]isMakingDfa()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl][CtCommentImpl]// if you're offboard, no shooting
        if ([CtBinaryOperatorImpl][CtInvocationImpl]isOffBoard() || [CtInvocationImpl]isAssaultDropInProgress()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted : [CtInvocationImpl]getWeaponList()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.WeaponType wtype = [CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.WeaponType) ([CtVariableReadImpl]mounted.getType()));
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]wtype != [CtLiteralImpl]null) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]wtype.hasFlag([CtTypeAccessImpl]WeaponType.F_TAG) && [CtInvocationImpl][CtVariableReadImpl]mounted.isReady())) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;[CtCommentImpl]// only things w/ tag are

    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isAttackingThisTurn() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.List<[CtTypeReferenceImpl]megamek.common.actions.EntityAction> actions = [CtInvocationImpl][CtFieldReadImpl]game.getActionsVector();
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.actions.EntityAction ea : [CtVariableReadImpl]actions) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]ea.getEntityId() == [CtInvocationImpl]getId()) && [CtBinaryOperatorImpl]([CtVariableReadImpl]ea instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.actions.AbstractAttackAction)) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Check if the entity has any valid targets for physical attacks.
     */
    public [CtTypeReferenceImpl]boolean isEligibleForPhysical() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]boolean canHit = [CtLiteralImpl]false;
        [CtLocalVariableImpl][CtTypeReferenceImpl]boolean friendlyFire = [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.BASE_FRIENDLY_FIRE);
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Infantry) && [CtInvocationImpl]hasWorkingMisc([CtTypeAccessImpl]MiscType.F_TOOLS, [CtTypeAccessImpl]MiscType.S_DEMOLITION_CHARGE)) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.IHex hex = [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().getHex([CtInvocationImpl]getPosition());
            [CtReturnImpl]return [CtInvocationImpl][CtVariableReadImpl]hex.containsTerrain([CtTypeAccessImpl]Terrains.BUILDING);
        }
        [CtIfImpl][CtCommentImpl]// only mechs and protos have physical attacks (except tank charges)
        if ([CtUnaryOperatorImpl]![CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Mech) || [CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Protomech)) || [CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Infantry))) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl][CtCommentImpl]// if you're charging or finding a club, it's already declared
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]isUnjammingRAC() || [CtInvocationImpl]isCharging()) || [CtInvocationImpl]isMakingDfa()) || [CtInvocationImpl]isRamming()) || [CtInvocationImpl]isFindingClub()) || [CtInvocationImpl]isOffBoard()) || [CtInvocationImpl]isAssaultDropInProgress()) || [CtInvocationImpl]isDropping()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl][CtCommentImpl]// check game options
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ALLOWED_NO_CLAN_PHYSICAL) && [CtInvocationImpl]isClan()) && [CtUnaryOperatorImpl](![CtInvocationImpl]hasINarcPodsAttached())) && [CtBinaryOperatorImpl]([CtInvocationImpl]getSwarmAttackerId() == [CtFieldReadImpl]megamek.common.Entity.NONE)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl][CtCommentImpl]// Issue with Vibroblades only being turned on/off during Physical phase
        [CtCommentImpl]// -- Torren
        if ([CtInvocationImpl]hasVibroblades()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]true;
        }
        [CtIfImpl]if ([CtUnaryOperatorImpl]![CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.BASE_SKIP_INELIGABLE_PHYSICAL)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]true;
        }
        [CtIfImpl][CtCommentImpl]// dead mek walking
        if ([CtUnaryOperatorImpl]![CtInvocationImpl]isActive()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl][CtCommentImpl]// sprinted?
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtFieldReadImpl]moved == [CtFieldReadImpl]EntityMovementType.MOVE_SPRINT) || [CtBinaryOperatorImpl]([CtFieldReadImpl]moved == [CtFieldReadImpl]EntityMovementType.MOVE_VTOL_SPRINT)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]getPosition() == [CtLiteralImpl]null) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;[CtCommentImpl]// not on board?

        }
        [CtIfImpl][CtCommentImpl]// check if we have iNarc pods attached that can be brushed off
        if ([CtBinaryOperatorImpl][CtInvocationImpl]hasINarcPodsAttached() && [CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Mech)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]true;
        }
        [CtLocalVariableImpl][CtCommentImpl]// Try to find a valid entity target.
        [CtTypeReferenceImpl]java.util.Iterator<[CtTypeReferenceImpl]megamek.common.Entity> e = [CtInvocationImpl][CtFieldReadImpl]game.getEntities();
        [CtWhileImpl]while ([CtBinaryOperatorImpl][CtUnaryOperatorImpl](![CtVariableReadImpl]canHit) && [CtInvocationImpl][CtVariableReadImpl]e.hasNext()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity target = [CtInvocationImpl][CtVariableReadImpl]e.next();
            [CtIfImpl][CtCommentImpl]// don't shoot at friendlies unless you are into that sort of thing
            [CtCommentImpl]// and do not shoot yourself even then
            if ([CtUnaryOperatorImpl]![CtBinaryOperatorImpl]([CtInvocationImpl]isEnemyOf([CtVariableReadImpl]target) || [CtBinaryOperatorImpl]([CtVariableReadImpl]friendlyFire && [CtBinaryOperatorImpl]([CtInvocationImpl]getId() != [CtInvocationImpl][CtVariableReadImpl]target.getId())))) [CtBlockImpl]{
                [CtContinueImpl]continue;
            }
            [CtIfImpl]if ([CtUnaryOperatorImpl]![CtInvocationImpl][CtVariableReadImpl]target.isDeployed()) [CtBlockImpl]{
                [CtContinueImpl]continue;
            }
            [CtIfImpl][CtCommentImpl]// No physical attack works at distances > 1.
            if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]target.getPosition() != [CtLiteralImpl]null) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtTypeAccessImpl]megamek.common.Compute.effectiveDistance([CtFieldReadImpl]game, [CtThisAccessImpl]this, [CtVariableReadImpl]target) > [CtLiteralImpl]1)) [CtBlockImpl]{
                [CtContinueImpl]continue;
            }
            [CtOperatorAssignmentImpl][CtVariableWriteImpl]canHit |= [CtInvocationImpl][CtTypeAccessImpl]megamek.common.Compute.canPhysicalTarget([CtFieldReadImpl]game, [CtInvocationImpl]getId(), [CtVariableReadImpl]target);
            [CtOperatorAssignmentImpl][CtCommentImpl]// check if we can dodge and target can attack us,
            [CtCommentImpl]// then we are eligible.
            [CtVariableWriteImpl]canHit |= [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Mech) && [CtUnaryOperatorImpl](![CtInvocationImpl]isProne())) && [CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.PILOT_DODGE_MANEUVER)) && [CtInvocationImpl][CtTypeAccessImpl]megamek.common.Compute.canPhysicalTarget([CtFieldReadImpl]game, [CtInvocationImpl][CtVariableReadImpl]target.getId(), [CtThisAccessImpl]this);
        } 
        [CtLocalVariableImpl][CtCommentImpl]// If there are no valid Entity targets, check for add valid buildings.
        [CtTypeReferenceImpl]java.util.Enumeration<[CtTypeReferenceImpl]megamek.common.Building> bldgs = [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().getBuildings();
        [CtWhileImpl]while ([CtBinaryOperatorImpl][CtUnaryOperatorImpl](![CtVariableReadImpl]canHit) && [CtInvocationImpl][CtVariableReadImpl]bldgs.hasMoreElements()) [CtBlockImpl]{
            [CtLocalVariableImpl]final [CtTypeReferenceImpl]megamek.common.Building bldg = [CtInvocationImpl][CtVariableReadImpl]bldgs.nextElement();
            [CtLocalVariableImpl][CtCommentImpl]// Walk through the hexes of the building.
            [CtTypeReferenceImpl]java.util.Enumeration<[CtTypeReferenceImpl]megamek.common.Coords> hexes = [CtInvocationImpl][CtVariableReadImpl]bldg.getCoords();
            [CtWhileImpl]while ([CtBinaryOperatorImpl][CtUnaryOperatorImpl](![CtVariableReadImpl]canHit) && [CtInvocationImpl][CtVariableReadImpl]hexes.hasMoreElements()) [CtBlockImpl]{
                [CtLocalVariableImpl]final [CtTypeReferenceImpl]megamek.common.Coords coords = [CtInvocationImpl][CtVariableReadImpl]hexes.nextElement();
                [CtIfImpl][CtCommentImpl]// No physical attack works at distances > 1.
                if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl]getPosition().distance([CtVariableReadImpl]coords) > [CtLiteralImpl]1) [CtBlockImpl]{
                    [CtContinueImpl]continue;
                }
                [CtLocalVariableImpl][CtCommentImpl]// Can the entity target *this* hex of the building?
                final [CtTypeReferenceImpl]megamek.common.BuildingTarget target = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.BuildingTarget([CtVariableReadImpl]coords, [CtInvocationImpl][CtFieldReadImpl]game.getBoard(), [CtLiteralImpl]false);
                [CtOperatorAssignmentImpl][CtVariableWriteImpl]canHit |= [CtInvocationImpl][CtTypeAccessImpl]megamek.common.Compute.canPhysicalTarget([CtFieldReadImpl]game, [CtInvocationImpl]getId(), [CtVariableReadImpl]target);
            } [CtCommentImpl]// Check the next hex of the building

        } [CtCommentImpl]// Check the next building

        [CtReturnImpl]return [CtVariableReadImpl]canHit;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Determines if this Entity is eligible to pre-designate hexes as
     * auto-hits. Per TacOps pg 180, if a player has offboard artillery they get
     * 5 pre- designated hexes per mapsheet.
     *
     * @return  */
    public [CtTypeReferenceImpl]boolean isEligibleForArtyAutoHitHexes() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtInvocationImpl]isEligibleForTargetingPhase() && [CtBinaryOperatorImpl]([CtInvocationImpl]isOffBoard() || [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVCOMBAT_ON_MAP_PREDESIGNATE));
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isEligibleForTargetingPhase() [CtBlockImpl]{
        [CtIfImpl]if ([CtInvocationImpl]isAssaultDropInProgress()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted : [CtInvocationImpl]getWeaponList()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.WeaponType wtype = [CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.WeaponType) ([CtVariableReadImpl]mounted.getType()));
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]wtype != [CtLiteralImpl]null) && [CtInvocationImpl][CtVariableReadImpl]wtype.hasFlag([CtTypeAccessImpl]WeaponType.F_ARTILLERY)) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
            [CtIfImpl][CtCommentImpl]// Bearings-only capital missiles fire during the targeting phase
            if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]wtype instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.bayweapons.TeleOperatedMissileBayWeapon) || [CtBinaryOperatorImpl]([CtVariableReadImpl]wtype instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.bayweapons.CapitalMissileBayWeapon)) || [CtBinaryOperatorImpl]([CtVariableReadImpl]wtype instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.bayweapons.AR10BayWeapon)) [CtBlockImpl]{
                [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]mounted.isInBearingsOnlyMode()) [CtBlockImpl]{
                    [CtReturnImpl]return [CtLiteralImpl]true;
                }
            }
            [CtIfImpl][CtCommentImpl]// Surface to surface capital missiles count as artillery
            if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtThisAccessImpl]this.getAltitude() == [CtLiteralImpl]0) && [CtBinaryOperatorImpl]([CtVariableReadImpl]wtype instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.capitalweapons.CapitalMissileWeapon)) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]double getTroopCarryingSpace() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]double space = [CtLiteralImpl]0;
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter t : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]t instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.TroopSpace) [CtBlockImpl]{
                [CtOperatorAssignmentImpl][CtVariableWriteImpl]space += [CtFieldReadImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.TroopSpace) (t)).totalSpace;
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]space;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]double getPodMountedTroopCarryingSpace() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]double space = [CtLiteralImpl]0;
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter t : [CtFieldReadImpl]omniPodTransports) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]t instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.TroopSpace) [CtBlockImpl]{
                [CtOperatorAssignmentImpl][CtVariableWriteImpl]space += [CtFieldReadImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.TroopSpace) (t)).totalSpace;
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]space;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean hasBattleArmorHandles() [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter t : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]t instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.BattleArmorHandles) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns true if this unit has a ClampMountMech or ClampMountTank that
     * is currently unloaded.
     *
     * @return  */
    public [CtTypeReferenceImpl]boolean hasUnloadedClampMount() [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter t : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]t instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.ClampMountTank) || [CtBinaryOperatorImpl]([CtVariableReadImpl]t instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.ClampMountMech)) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]t.getUnused() > [CtLiteralImpl]0)) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtCommentImpl]/* (non-Javadoc)

    @see megamek.common.Targetable#isOffBoard()
     */
    [CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]boolean isOffBoard() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtFieldReadImpl]offBoardDistance > [CtLiteralImpl]0;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Set the unit as an offboard deployment. If a non-zero distance is chosen,
     * the direction must <b>not</b> be <code>Entity.NONE</code>. If a direction
     * other than <code>Entity.NONE</code> is chosen, the distance must
     * <b>not</b> be zero (0).
     *
     * @param distance
     * 		the <code>int</code> distance in hexes that the unit will be
     * 		deployed from the board; this value must not be negative.
     * @param direction
     * 		the <code>int</code> direction from the board that the unit
     * 		will be deployed; a valid value must be selected from: NONE,
     * 		NORTH, SOUTH, EAST, or WEST.
     * @throws IllegalArgumentException
     * 		if a negative distance, an invalid direction is selected, or
     * 		the distance does not match the direction.
     */
    public [CtTypeReferenceImpl]void setOffBoard([CtParameterImpl][CtTypeReferenceImpl]int distance, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.OffBoardDirection direction) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]distance < [CtLiteralImpl]0) [CtBlockImpl]{
            [CtThrowImpl]throw [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.lang.IllegalArgumentException([CtLiteralImpl]"negative number given for distance offboard");
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtLiteralImpl]0 == [CtVariableReadImpl]distance) && [CtBinaryOperatorImpl]([CtFieldReadImpl]OffBoardDirection.NONE != [CtVariableReadImpl]direction)) [CtBlockImpl]{
            [CtThrowImpl]throw [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.lang.IllegalArgumentException([CtLiteralImpl]"onboard unit was given an offboard direction");
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtLiteralImpl]0 != [CtVariableReadImpl]distance) && [CtBinaryOperatorImpl]([CtFieldReadImpl]OffBoardDirection.NONE == [CtVariableReadImpl]direction)) [CtBlockImpl]{
            [CtThrowImpl]throw [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.lang.IllegalArgumentException([CtLiteralImpl]"offboard unit was not given an offboard direction");
        }
        [CtSwitchImpl]switch ([CtVariableReadImpl]direction) {
            [CtCaseImpl]case [CtFieldReadImpl]NORTH :
                [CtInvocationImpl]setFacing([CtLiteralImpl]3);
                [CtBreakImpl]break;
            [CtCaseImpl]case [CtFieldReadImpl]SOUTH :
                [CtInvocationImpl]setFacing([CtLiteralImpl]0);
                [CtBreakImpl]break;
            [CtCaseImpl]case [CtFieldReadImpl]WEST :
                [CtInvocationImpl]setFacing([CtLiteralImpl]2);
                [CtBreakImpl]break;
            [CtCaseImpl]case [CtFieldReadImpl]EAST :
                [CtInvocationImpl]setFacing([CtLiteralImpl]4);
                [CtBreakImpl]break;
            [CtCaseImpl]default :
                [CtBreakImpl]break;
        }
        [CtAssignmentImpl][CtFieldWriteImpl]offBoardDistance = [CtVariableReadImpl]distance;
        [CtAssignmentImpl][CtFieldWriteImpl]offBoardDirection = [CtVariableReadImpl]direction;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Get the distance in hexes from the board that the unit will be deployed.
     * If the unit is to be deployed onboard, the distance will be zero (0).
     *
     * @return the <code>int</code> distance from the board the unit will be
    deployed (in hexes); this value will never be negative.
     */
    public [CtTypeReferenceImpl]int getOffBoardDistance() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]offBoardDistance;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Get the direction the board that the unit will be deployed. If the unit
     * is to be deployed onboard, the distance will be
     * <code>IOffBoardDirections.NONE</code>, otherwise it will be one of the
     * values:
     * <ul>
     * <li><code>IOffBoardDirections.NORTH</code></li>
     * <li><code>IOffBoardDirections.SOUTH</code></li>
     * <li><code>IOffBoardDirections.EAST</code></li>
     * <li><code>IOffBoardDirections.WEST</code></li>
     * </ul>
     *
     * @return the <code>int</code> direction from the board the unit will be
    deployed. Only valid values will be returned.
     */
    public [CtTypeReferenceImpl]megamek.common.OffBoardDirection getOffBoardDirection() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]offBoardDirection;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Deploy this offboard entity at the previously specified distance and
     * direction. This should only be invoked by the <code>Server</code> after
     * the board has been selected and all the players are ready to start. The
     * side effects of this methods set the unit's position and facing as
     * appropriate (as well as deploying the unit).
     * <p/>
     * Onboard units (units with an offboard distance of zero and a direction of
     * <code>Entity.NONE</code>) will be unaffected by this method.
     *
     * @param round
     * 		The current round number.
     */
    public [CtTypeReferenceImpl]void deployOffBoard([CtParameterImpl][CtTypeReferenceImpl]int round) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtLiteralImpl]null == [CtFieldReadImpl]game) [CtBlockImpl]{
            [CtThrowImpl]throw [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.lang.IllegalStateException([CtLiteralImpl]"game not set; possible serialization error");
        }
        [CtSwitchImpl][CtCommentImpl]// N.B. 17 / 2 = 8, but the middle of 1..17 is 9, so we
        [CtCommentImpl]// add a bit (because 17 % 2 == 1 and 16 % 2 == 0).
        switch ([CtFieldReadImpl]offBoardDirection) {
            [CtCaseImpl]case [CtFieldReadImpl]megamek.common.Entity.NONE :
                [CtReturnImpl]return;
            [CtCaseImpl]case [CtFieldReadImpl]NORTH :
                [CtInvocationImpl]setPosition([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.Coords([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().getWidth() / [CtLiteralImpl]2) + [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().getWidth() % [CtLiteralImpl]2), [CtUnaryOperatorImpl]-[CtInvocationImpl]getOffBoardDistance()));
                [CtInvocationImpl]setFacing([CtLiteralImpl]3);
                [CtBreakImpl]break;
            [CtCaseImpl]case [CtFieldReadImpl]SOUTH :
                [CtInvocationImpl]setPosition([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.Coords([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().getWidth() / [CtLiteralImpl]2) + [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().getWidth() % [CtLiteralImpl]2), [CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().getHeight() + [CtInvocationImpl]getOffBoardDistance()));
                [CtInvocationImpl]setFacing([CtLiteralImpl]0);
                [CtBreakImpl]break;
            [CtCaseImpl]case [CtFieldReadImpl]EAST :
                [CtInvocationImpl]setPosition([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.Coords([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().getWidth() + [CtInvocationImpl]getOffBoardDistance(), [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().getHeight() / [CtLiteralImpl]2) + [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().getHeight() % [CtLiteralImpl]2)));
                [CtInvocationImpl]setFacing([CtLiteralImpl]5);
                [CtBreakImpl]break;
            [CtCaseImpl]case [CtFieldReadImpl]WEST :
                [CtInvocationImpl]setPosition([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.Coords([CtUnaryOperatorImpl]-[CtInvocationImpl]getOffBoardDistance(), [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().getHeight() / [CtLiteralImpl]2) + [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().getHeight() % [CtLiteralImpl]2)));
                [CtInvocationImpl]setFacing([CtLiteralImpl]1);
                [CtBreakImpl]break;
        }
        [CtInvocationImpl][CtCommentImpl]// deploy the unit, but only if it should be deployed this round
        setDeployed([CtInvocationImpl]shouldOffboardDeploy([CtVariableReadImpl]round));
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]java.lang.Integer> getPickedUpMechWarriors() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]pickedUpMechWarriors;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Has this entity been captured?
     *
     * @return <code>true</code> if it has.
     */
    public [CtTypeReferenceImpl]boolean isCaptured() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtFieldReadImpl]captured && [CtUnaryOperatorImpl](![CtInvocationImpl]isDestroyed());
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Specify that this entity has been captured.
     *
     * @param arg
     * 		the <code>boolean</code> value to assign.
     */
    public [CtTypeReferenceImpl]void setCaptured([CtParameterImpl][CtTypeReferenceImpl]boolean arg) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]captured = [CtVariableReadImpl]arg;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setExternalSpotlight([CtParameterImpl][CtTypeReferenceImpl]boolean arg) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]hasExternalSpotlight = [CtVariableReadImpl]arg;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns state of hasExternalSpotlight, does not consider mounted
     * spotlights.
     *
     * @return  */
    public [CtTypeReferenceImpl]boolean hasExternaSpotlight() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]hasExternalSpotlight;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns true if the unit has a usable spotlight. It considers both
     * externally mounted spotlights as well as internally mounted ones.
     *
     * @return  */
    public [CtTypeReferenceImpl]boolean hasSpotlight() [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getMisc()) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_SEARCHLIGHT) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]m.isInoperable())) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtFieldReadImpl]hasExternalSpotlight;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Method to destroy a single spotlight on an entity. Spotlights can be
     * destroyed on a roll of 7+ on a torso hit on a mek or on a front/side hit
     * on a combat vehicle.
     */
    public [CtTypeReferenceImpl]void destroyOneSpotlight() [CtBlockImpl]{
        [CtIfImpl]if ([CtUnaryOperatorImpl]![CtInvocationImpl]hasSpotlight()) [CtBlockImpl]{
            [CtReturnImpl]return;
        }
        [CtIfImpl][CtCommentImpl]// A random spotlight should be destroyed, but this is easier...
        if ([CtFieldReadImpl]hasExternalSpotlight) [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl]hasExternalSpotlight = [CtLiteralImpl]false;
        }
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getMisc()) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_SEARCHLIGHT) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]m.isInoperable())) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]m.setDestroyed([CtLiteralImpl]true);
                [CtBreakImpl]break;
            }
        }
        [CtIfImpl][CtCommentImpl]// Turn off the light all spot lights were destroyed
        if ([CtUnaryOperatorImpl]![CtInvocationImpl]hasSpotlight()) [CtBlockImpl]{
            [CtInvocationImpl]setSpotlightState([CtLiteralImpl]false);
        }
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setSpotlightState([CtParameterImpl][CtTypeReferenceImpl]boolean arg) [CtBlockImpl]{
        [CtIfImpl]if ([CtInvocationImpl]hasSpotlight()) [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl]spotlightIsActive = [CtVariableReadImpl]arg;
            [CtIfImpl]if ([CtVariableReadImpl]arg) [CtBlockImpl]{
                [CtAssignmentImpl][CtFieldWriteImpl]illuminated = [CtLiteralImpl]true;
            }
        } else [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl]spotlightIsActive = [CtLiteralImpl]false;
        }
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isIlluminated() [CtBlockImpl]{
        [CtReturnImpl][CtCommentImpl]// Regardless of illuminated state, if we have a spotlight active we
        [CtCommentImpl]// are illuminated
        return [CtBinaryOperatorImpl][CtFieldReadImpl]illuminated || [CtFieldReadImpl]spotlightIsActive;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setIlluminated([CtParameterImpl][CtTypeReferenceImpl]boolean arg) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]illuminated = [CtBinaryOperatorImpl][CtFieldReadImpl]spotlightIsActive || [CtVariableReadImpl]arg;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isUsingSpotlight() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtInvocationImpl]hasSpotlight() && [CtFieldReadImpl]spotlightIsActive;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setUsedSearchlight([CtParameterImpl][CtTypeReferenceImpl]boolean arg) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]usedSearchlight = [CtVariableReadImpl]arg;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean usedSearchlight() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]usedSearchlight;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Is the Entity stuck in a swamp?
     */
    public [CtTypeReferenceImpl]boolean isStuck() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]stuckInSwamp;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Set weather this Entity is stuck in a swamp or not
     *
     * @param arg
     * 		the <code>boolean</code> value to assign
     */
    public [CtTypeReferenceImpl]void setStuck([CtParameterImpl][CtTypeReferenceImpl]boolean arg) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]stuckInSwamp = [CtVariableReadImpl]arg;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Is the Entity stuck in a swamp?
     */
    public [CtTypeReferenceImpl]boolean canUnstickByJumping() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]canUnstickByJumping;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Set wether this Enity is stuck in a swamp or not
     *
     * @param arg
     * 		the <code>boolean</code> value to assign
     */
    public [CtTypeReferenceImpl]void setCanUnstickByJumping([CtParameterImpl][CtTypeReferenceImpl]boolean arg) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]canUnstickByJumping = [CtVariableReadImpl]arg;
    }

    [CtMethodImpl][CtCommentImpl]/* The following methods support the eventual refactoring into the Entity
    class of a lot of the Server logic surrounding entity damage and death.
    They are not currently called in Server anywhere, and so may as well not
    exist.
     */
    public [CtTypeReferenceImpl]java.lang.String destroy([CtParameterImpl][CtTypeReferenceImpl]java.lang.String reason, [CtParameterImpl][CtTypeReferenceImpl]boolean survivable, [CtParameterImpl][CtTypeReferenceImpl]boolean canSalvage) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.lang.StringBuffer sb = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.lang.StringBuffer();
        [CtLocalVariableImpl][CtTypeReferenceImpl]int condition = [CtFieldReadImpl]IEntityRemovalConditions.REMOVE_SALVAGEABLE;
        [CtIfImpl]if ([CtUnaryOperatorImpl]![CtVariableReadImpl]canSalvage) [CtBlockImpl]{
            [CtInvocationImpl]setSalvage([CtVariableReadImpl]canSalvage);
            [CtAssignmentImpl][CtVariableWriteImpl]condition = [CtFieldReadImpl]IEntityRemovalConditions.REMOVE_DEVASTATED;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]isDoomed() || [CtInvocationImpl]isDestroyed()) [CtBlockImpl]{
            [CtReturnImpl]return [CtInvocationImpl][CtVariableReadImpl]sb.toString();
        }
        [CtInvocationImpl][CtCommentImpl]// working under the assumption that entity was neither doomed or
        [CtCommentImpl]// destroyed before from here on out
        setDoomed([CtLiteralImpl]true);
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Enumeration<[CtTypeReferenceImpl]java.lang.Integer> iter = [CtInvocationImpl][CtInvocationImpl]getPickedUpMechWarriors().elements();
        [CtWhileImpl]while ([CtInvocationImpl][CtVariableReadImpl]iter.hasMoreElements()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]java.lang.Integer mechWarriorId = [CtInvocationImpl][CtVariableReadImpl]iter.nextElement();
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity mw = [CtInvocationImpl][CtFieldReadImpl]game.getEntity([CtInvocationImpl][CtVariableReadImpl]mechWarriorId.intValue());
            [CtInvocationImpl][CtVariableReadImpl]mw.setDestroyed([CtLiteralImpl]true);
            [CtInvocationImpl][CtFieldReadImpl]game.removeEntity([CtInvocationImpl][CtVariableReadImpl]mw.getId(), [CtVariableReadImpl]condition);
            [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]sb.append([CtLiteralImpl]"\n*** ").append([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]mw.getDisplayName() + [CtLiteralImpl]" died in the wreckage. ***\n");
        } 
        [CtReturnImpl]return [CtInvocationImpl][CtVariableReadImpl]sb.toString();
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Add a targeting by a swarm volley from a specified entity
     *
     * @param entityId
     * 		The <code>int</code> id of the shooting entity
     * @param weaponId
     * 		The <code>int</code> id of the shooting lrm launcher
     */
    public [CtTypeReferenceImpl]void addTargetedBySwarm([CtParameterImpl][CtTypeReferenceImpl]int entityId, [CtParameterImpl][CtTypeReferenceImpl]int weaponId) [CtBlockImpl]{
        [CtInvocationImpl][CtFieldReadImpl]hitBySwarmsEntity.addElement([CtVariableReadImpl]entityId);
        [CtInvocationImpl][CtFieldReadImpl]hitBySwarmsWeapon.addElement([CtVariableReadImpl]weaponId);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Were we targeted by a certain swarm/swarm-i volley this turn?
     *
     * @param entityId
     * 		The <code>int</code> id of the shooting entity we are checking
     * @param weaponId
     * 		The <code>int</code> id of the launcher to check
     * @return a fitting <code>boolean</code> value
     */
    public [CtTypeReferenceImpl]boolean getTargetedBySwarm([CtParameterImpl][CtTypeReferenceImpl]int entityId, [CtParameterImpl][CtTypeReferenceImpl]int weaponId) [CtBlockImpl]{
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtInvocationImpl][CtFieldReadImpl]hitBySwarmsEntity.size(); [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]java.lang.Integer entityIdToTest = [CtInvocationImpl][CtFieldReadImpl]hitBySwarmsEntity.elementAt([CtVariableReadImpl]i);
            [CtLocalVariableImpl][CtTypeReferenceImpl]java.lang.Integer weaponIdToTest = [CtInvocationImpl][CtFieldReadImpl]hitBySwarmsWeapon.elementAt([CtVariableReadImpl]i);
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]entityId == [CtInvocationImpl][CtVariableReadImpl]entityIdToTest.intValue()) && [CtBinaryOperatorImpl]([CtVariableReadImpl]weaponId == [CtInvocationImpl][CtVariableReadImpl]weaponIdToTest.intValue())) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getShortRangeModifier() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int mod = [CtLiteralImpl]0;
        [CtIfImpl]if ([CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.GUNNERY_RANGE_MASTER, [CtTypeAccessImpl]Crew.RANGEMASTER_MEDIUM)) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]mod = [CtLiteralImpl]2;
        }
        [CtIfImpl]if ([CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.GUNNERY_RANGE_MASTER, [CtTypeAccessImpl]Crew.RANGEMASTER_LONG)) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]mod = [CtLiteralImpl]4;
        }
        [CtIfImpl]if ([CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.GUNNERY_RANGE_MASTER, [CtTypeAccessImpl]Crew.RANGEMASTER_EXTREME)) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]mod = [CtLiteralImpl]6;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.GUNNERY_SNIPER) && [CtBinaryOperatorImpl]([CtVariableReadImpl]mod > [CtLiteralImpl]0)) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]mod = [CtBinaryOperatorImpl][CtVariableReadImpl]mod / [CtLiteralImpl]2;
        }
        [CtIfImpl]if ([CtInvocationImpl]hasQuirk([CtTypeAccessImpl]OptionsConstants.QUIRK_POS_IMP_TARG_S)) [CtBlockImpl]{
            [CtUnaryOperatorImpl][CtVariableWriteImpl]mod--;
        }
        [CtIfImpl]if ([CtInvocationImpl]hasQuirk([CtTypeAccessImpl]OptionsConstants.QUIRK_NEG_POOR_TARG_S)) [CtBlockImpl]{
            [CtUnaryOperatorImpl][CtVariableWriteImpl]mod++;
        }
        [CtIfImpl]if ([CtInvocationImpl]hasQuirk([CtTypeAccessImpl]OptionsConstants.QUIRK_POS_VAR_RNG_TARG_L)) [CtBlockImpl]{
            [CtUnaryOperatorImpl][CtVariableWriteImpl]mod++;
        }
        [CtIfImpl]if ([CtInvocationImpl]hasQuirk([CtTypeAccessImpl]OptionsConstants.QUIRK_POS_VAR_RNG_TARG_S)) [CtBlockImpl]{
            [CtUnaryOperatorImpl][CtVariableWriteImpl]mod--;
        }
        [CtReturnImpl]return [CtVariableReadImpl]mod;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getMediumRangeModifier() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int mod = [CtLiteralImpl]2;
        [CtIfImpl]if ([CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.GUNNERY_RANGE_MASTER, [CtTypeAccessImpl]Crew.RANGEMASTER_MEDIUM)) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]mod = [CtLiteralImpl]0;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.GUNNERY_SNIPER) && [CtBinaryOperatorImpl]([CtVariableReadImpl]mod > [CtLiteralImpl]0)) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]mod = [CtBinaryOperatorImpl][CtVariableReadImpl]mod / [CtLiteralImpl]2;
        }
        [CtIfImpl]if ([CtInvocationImpl]hasQuirk([CtTypeAccessImpl]OptionsConstants.QUIRK_POS_IMP_TARG_M)) [CtBlockImpl]{
            [CtUnaryOperatorImpl][CtVariableWriteImpl]mod--;
        }
        [CtIfImpl]if ([CtInvocationImpl]hasQuirk([CtTypeAccessImpl]OptionsConstants.QUIRK_NEG_POOR_TARG_M)) [CtBlockImpl]{
            [CtUnaryOperatorImpl][CtVariableWriteImpl]mod++;
        }
        [CtReturnImpl]return [CtVariableReadImpl]mod;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getLongRangeModifier() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int mod = [CtLiteralImpl]4;
        [CtIfImpl]if ([CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.GUNNERY_RANGE_MASTER, [CtTypeAccessImpl]Crew.RANGEMASTER_LONG)) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]mod = [CtLiteralImpl]0;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.GUNNERY_SNIPER) && [CtBinaryOperatorImpl]([CtVariableReadImpl]mod > [CtLiteralImpl]0)) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]mod = [CtBinaryOperatorImpl][CtVariableReadImpl]mod / [CtLiteralImpl]2;
        }
        [CtIfImpl]if ([CtInvocationImpl]hasQuirk([CtTypeAccessImpl]OptionsConstants.QUIRK_POS_IMP_TARG_L)) [CtBlockImpl]{
            [CtUnaryOperatorImpl][CtVariableWriteImpl]mod--;
        }
        [CtIfImpl]if ([CtInvocationImpl]hasQuirk([CtTypeAccessImpl]OptionsConstants.QUIRK_NEG_POOR_TARG_L)) [CtBlockImpl]{
            [CtUnaryOperatorImpl][CtVariableWriteImpl]mod++;
        }
        [CtIfImpl]if ([CtInvocationImpl]hasQuirk([CtTypeAccessImpl]OptionsConstants.QUIRK_POS_VAR_RNG_TARG_L)) [CtBlockImpl]{
            [CtUnaryOperatorImpl][CtVariableWriteImpl]mod--;
        }
        [CtIfImpl]if ([CtInvocationImpl]hasQuirk([CtTypeAccessImpl]OptionsConstants.QUIRK_POS_VAR_RNG_TARG_S)) [CtBlockImpl]{
            [CtUnaryOperatorImpl][CtVariableWriteImpl]mod++;
        }
        [CtReturnImpl]return [CtVariableReadImpl]mod;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getExtremeRangeModifier() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int mod = [CtLiteralImpl]6;
        [CtIfImpl]if ([CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.GUNNERY_RANGE_MASTER, [CtTypeAccessImpl]Crew.RANGEMASTER_EXTREME)) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]mod = [CtLiteralImpl]0;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.GUNNERY_SNIPER) && [CtBinaryOperatorImpl]([CtVariableReadImpl]mod > [CtLiteralImpl]0)) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]mod = [CtBinaryOperatorImpl][CtVariableReadImpl]mod / [CtLiteralImpl]2;
        }
        [CtReturnImpl]return [CtVariableReadImpl]mod;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getLOSRangeModifier() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int mod = [CtLiteralImpl]8;
        [CtReturnImpl]return [CtVariableReadImpl]mod;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setArmorType([CtParameterImpl][CtTypeReferenceImpl]int armType) [CtBlockImpl]{
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtInvocationImpl]locations(); [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtAssignmentImpl][CtArrayWriteImpl][CtFieldReadImpl]armorType[[CtVariableReadImpl]i] = [CtVariableReadImpl]armType;
        }
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setArmorType([CtParameterImpl][CtTypeReferenceImpl]int armType, [CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtAssignmentImpl][CtArrayWriteImpl][CtFieldReadImpl]armorType[[CtVariableReadImpl]loc] = [CtVariableReadImpl]armType;
        [CtInvocationImpl]recalculateTechAdvancement();
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setStructureType([CtParameterImpl][CtTypeReferenceImpl]int strucType) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]structureType = [CtVariableReadImpl]strucType;
        [CtAssignmentImpl][CtFieldWriteImpl]structureTechLevel = [CtInvocationImpl]getTechLevel();
        [CtInvocationImpl]recalculateTechAdvancement();
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setStructureTechLevel([CtParameterImpl][CtTypeReferenceImpl]int level) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]structureTechLevel = [CtVariableReadImpl]level;
        [CtInvocationImpl]recalculateTechAdvancement();
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setArmorType([CtParameterImpl][CtTypeReferenceImpl]java.lang.String armType) [CtBlockImpl]{
        [CtIfImpl]if ([CtUnaryOperatorImpl]![CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]armType.startsWith([CtLiteralImpl]"Clan ") || [CtInvocationImpl][CtVariableReadImpl]armType.startsWith([CtLiteralImpl]"IS "))) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]armType = [CtConditionalImpl]([CtInvocationImpl][CtTypeAccessImpl]megamek.common.TechConstants.isClan([CtInvocationImpl]getArmorTechLevel([CtLiteralImpl]0))) ? [CtBinaryOperatorImpl][CtLiteralImpl]"Clan " + [CtVariableReadImpl]armType : [CtBinaryOperatorImpl][CtLiteralImpl]"IS " + [CtVariableReadImpl]armType;
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.EquipmentType et = [CtInvocationImpl][CtTypeAccessImpl]megamek.common.EquipmentType.get([CtVariableReadImpl]armType);
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]et == [CtLiteralImpl]null) [CtBlockImpl]{
            [CtInvocationImpl]setArmorType([CtTypeAccessImpl]EquipmentType.T_ARMOR_UNKNOWN);
        } else [CtBlockImpl]{
            [CtInvocationImpl]setArmorType([CtInvocationImpl][CtTypeAccessImpl]megamek.common.EquipmentType.getArmorType([CtVariableReadImpl]et));
            [CtIfImpl][CtCommentImpl]// TODO: Is this needed? WTF is the point of it?
            if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]et.getCriticals([CtThisAccessImpl]this) == [CtLiteralImpl]0) [CtBlockImpl]{
                [CtTryImpl]try [CtBlockImpl]{
                    [CtInvocationImpl][CtThisAccessImpl]this.addEquipment([CtVariableReadImpl]et, [CtFieldReadImpl]megamek.common.Entity.LOC_NONE);
                }[CtCatchImpl] catch ([CtCatchVariableImpl][CtTypeReferenceImpl]megamek.common.LocationFullException e) [CtBlockImpl]{
                    [CtInvocationImpl][CtCommentImpl]// can't happen
                    [CtVariableReadImpl]e.printStackTrace();
                }
            }
        }
        [CtInvocationImpl]recalculateTechAdvancement();
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setArmorType([CtParameterImpl][CtTypeReferenceImpl]java.lang.String armType, [CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtIfImpl]if ([CtUnaryOperatorImpl]![CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]armType.startsWith([CtLiteralImpl]"Clan ") || [CtInvocationImpl][CtVariableReadImpl]armType.startsWith([CtLiteralImpl]"IS "))) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]armType = [CtConditionalImpl]([CtInvocationImpl][CtTypeAccessImpl]megamek.common.TechConstants.isClan([CtInvocationImpl]getArmorTechLevel([CtLiteralImpl]0))) ? [CtBinaryOperatorImpl][CtLiteralImpl]"Clan " + [CtVariableReadImpl]armType : [CtBinaryOperatorImpl][CtLiteralImpl]"IS " + [CtVariableReadImpl]armType;
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.EquipmentType et = [CtInvocationImpl][CtTypeAccessImpl]megamek.common.EquipmentType.get([CtVariableReadImpl]armType);
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]et == [CtLiteralImpl]null) [CtBlockImpl]{
            [CtInvocationImpl]setArmorType([CtTypeAccessImpl]EquipmentType.T_ARMOR_UNKNOWN, [CtVariableReadImpl]loc);
        } else [CtBlockImpl]{
            [CtInvocationImpl]setArmorType([CtInvocationImpl][CtTypeAccessImpl]megamek.common.EquipmentType.getArmorType([CtVariableReadImpl]et), [CtVariableReadImpl]loc);
            [CtIfImpl][CtCommentImpl]// TODO: Is this needed? WTF is the point of it?
            if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]et.getCriticals([CtThisAccessImpl]this) == [CtLiteralImpl]0) [CtBlockImpl]{
                [CtTryImpl]try [CtBlockImpl]{
                    [CtInvocationImpl][CtThisAccessImpl]this.addEquipment([CtVariableReadImpl]et, [CtFieldReadImpl]megamek.common.Entity.LOC_NONE);
                }[CtCatchImpl] catch ([CtCatchVariableImpl][CtTypeReferenceImpl]megamek.common.LocationFullException e) [CtBlockImpl]{
                    [CtInvocationImpl][CtCommentImpl]// can't happen
                    [CtVariableReadImpl]e.printStackTrace();
                }
            }
        }
        [CtInvocationImpl]recalculateTechAdvancement();
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setStructureType([CtParameterImpl][CtTypeReferenceImpl]java.lang.String strucType) [CtBlockImpl]{
        [CtIfImpl]if ([CtUnaryOperatorImpl]![CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]strucType.startsWith([CtLiteralImpl]"Clan ") || [CtInvocationImpl][CtVariableReadImpl]strucType.startsWith([CtLiteralImpl]"IS "))) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]strucType = [CtConditionalImpl]([CtInvocationImpl]isClan()) ? [CtBinaryOperatorImpl][CtLiteralImpl]"Clan " + [CtVariableReadImpl]strucType : [CtBinaryOperatorImpl][CtLiteralImpl]"IS " + [CtVariableReadImpl]strucType;
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.EquipmentType et = [CtInvocationImpl][CtTypeAccessImpl]megamek.common.EquipmentType.get([CtVariableReadImpl]strucType);
        [CtInvocationImpl]setStructureType([CtInvocationImpl][CtTypeAccessImpl]megamek.common.EquipmentType.getStructureType([CtVariableReadImpl]et));
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]et == [CtLiteralImpl]null) [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl]structureTechLevel = [CtFieldReadImpl]TechConstants.T_TECH_UNKNOWN;
        } else [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl]structureTechLevel = [CtInvocationImpl][CtVariableReadImpl]et.getTechLevel([CtFieldReadImpl]year);
            [CtIfImpl][CtCommentImpl]// TODO: Is this needed? WTF is the point of it?
            if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]et.getCriticals([CtThisAccessImpl]this) == [CtLiteralImpl]0) [CtBlockImpl]{
                [CtTryImpl]try [CtBlockImpl]{
                    [CtInvocationImpl][CtThisAccessImpl]this.addEquipment([CtVariableReadImpl]et, [CtFieldReadImpl]megamek.common.Entity.LOC_NONE);
                }[CtCatchImpl] catch ([CtCatchVariableImpl][CtTypeReferenceImpl]megamek.common.LocationFullException e) [CtBlockImpl]{
                    [CtInvocationImpl][CtCommentImpl]// can't happen
                    [CtVariableReadImpl]e.printStackTrace();
                }
            }
        }
        [CtInvocationImpl]recalculateTechAdvancement();
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getArmorType([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtReturnImpl]return [CtArrayReadImpl][CtFieldReadImpl]armorType[[CtVariableReadImpl]loc];
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setArmorTechLevel([CtParameterImpl][CtTypeReferenceImpl]int newTL) [CtBlockImpl]{
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtInvocationImpl]locations(); [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtAssignmentImpl][CtArrayWriteImpl][CtFieldReadImpl]armorTechLevel[[CtVariableReadImpl]i] = [CtVariableReadImpl]newTL;
        }
        [CtInvocationImpl]recalculateTechAdvancement();
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setArmorTechLevel([CtParameterImpl][CtTypeReferenceImpl]int newTL, [CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtAssignmentImpl][CtArrayWriteImpl][CtFieldReadImpl]armorTechLevel[[CtVariableReadImpl]loc] = [CtVariableReadImpl]newTL;
        [CtInvocationImpl]recalculateTechAdvancement();
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getArmorTechLevel([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtReturnImpl]return [CtArrayReadImpl][CtFieldReadImpl]armorTechLevel[[CtVariableReadImpl]loc];
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getStructureType() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]structureType;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getStructureTechLevel() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]structureTechLevel;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setWeaponHit([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Mounted which) [CtBlockImpl]{
        [CtIfImpl]if ([CtInvocationImpl][CtFieldReadImpl]weaponList.contains([CtVariableReadImpl]which)) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]which.setHit([CtLiteralImpl]true);
        }
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setTaggedBy([CtParameterImpl][CtTypeReferenceImpl]int tagger) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]taggedBy = [CtVariableReadImpl]tagger;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getTaggedBy() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]taggedBy;
    }

    [CtMethodImpl]public abstract [CtTypeReferenceImpl]double getCost([CtParameterImpl][CtTypeReferenceImpl]boolean ignoreAmmo);

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns a multiplier that combines multiplicative construction cost modifiers for this Entity.
     *
     * This includes only modifiers that apply to an Entity's final, total cost (e.g. - the 1.25x modifier for being
     * an omni-unit, or the 32.0x for being an aerodyne dropship). It does NOT include multipliers that only apply to
     * a sub-part of the unit (e.g. the weight based multiplier that applies to a vehicle's internal structure cost).
     *
     * This allows MekHQ to scale the price of a Unit's Parts in a more appropriate manner.
     *
     * Defaults to 1.0
     */
    public [CtTypeReferenceImpl]double getPriceMultiplier() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]1.0;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]long getWeaponsAndEquipmentCost([CtParameterImpl][CtTypeReferenceImpl]boolean ignoreAmmo) [CtBlockImpl]{
        [CtLocalVariableImpl][CtCommentImpl]// bvText = new StringBuffer();
        [CtTypeReferenceImpl]long cost = [CtLiteralImpl]0;
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.text.NumberFormat commafy = [CtInvocationImpl][CtTypeAccessImpl]java.text.NumberFormat.getInstance();
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted : [CtInvocationImpl]getEquipment()) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]ignoreAmmo && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]mounted.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.AmmoType)) && [CtUnaryOperatorImpl](![CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.AmmoType) ([CtVariableReadImpl]mounted.getType())).getAmmoType() == [CtFieldReadImpl]AmmoType.T_COOLANT_POD))) [CtBlockImpl]{
                [CtContinueImpl]continue;
            }
            [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]mounted.isWeaponGroup()) [CtBlockImpl]{
                [CtContinueImpl]continue;
            }
            [CtLocalVariableImpl][CtTypeReferenceImpl]long itemCost = [CtInvocationImpl](([CtTypeReferenceImpl]long) ([CtVariableReadImpl]mounted.getCost()));
            [CtOperatorAssignmentImpl][CtVariableWriteImpl]cost += [CtVariableReadImpl]itemCost;
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtFieldReadImpl]bvText != [CtLiteralImpl]null) && [CtBinaryOperatorImpl]([CtVariableReadImpl]itemCost > [CtLiteralImpl]0)) [CtBlockImpl]{
                [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtFieldReadImpl]startRow);
                [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtFieldReadImpl]startColumn);
                [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtInvocationImpl][CtVariableReadImpl]mounted.getName());
                [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtFieldReadImpl]endColumn);
                [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtFieldReadImpl]startColumn);
                [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtInvocationImpl][CtVariableReadImpl]commafy.format([CtVariableReadImpl]itemCost));
                [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtFieldReadImpl]endColumn);
                [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtFieldReadImpl]endRow);
            }
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]int count = [CtInvocationImpl]implicitClanCASE();
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]count > [CtLiteralImpl]0) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]long itemCost = [CtLiteralImpl]50000;
            [CtOperatorAssignmentImpl][CtVariableWriteImpl]cost += [CtBinaryOperatorImpl][CtVariableReadImpl]count * [CtVariableReadImpl]itemCost;
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtLiteralImpl]null != [CtFieldReadImpl]bvText) [CtBlockImpl]{
                [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtVariableReadImpl]count; [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
                    [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtFieldReadImpl]startColumn);
                    [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtLiteralImpl]"CASE");
                    [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtFieldReadImpl]endColumn);
                    [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtFieldReadImpl]startColumn);
                    [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtInvocationImpl][CtVariableReadImpl]commafy.format([CtVariableReadImpl]itemCost));
                    [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtFieldReadImpl]endColumn);
                    [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtFieldReadImpl]endRow);
                }
            }
        }
        [CtIfImpl]if ([CtInvocationImpl]isSupportVehicle()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]long seatCost = [CtLiteralImpl]0;
            [CtLocalVariableImpl][CtTypeReferenceImpl]long quartersCost = [CtLiteralImpl]0;
            [CtLocalVariableImpl][CtTypeReferenceImpl]long bayCost = [CtLiteralImpl]0;
            [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Bay bay : [CtInvocationImpl]getTransportBays()) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]bay instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.StandardSeatCargoBay) [CtBlockImpl]{
                    [CtOperatorAssignmentImpl][CtVariableWriteImpl]seatCost += [CtInvocationImpl][CtVariableReadImpl]bay.getCost();
                } else [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]bay.isQuarters()) [CtBlockImpl]{
                    [CtOperatorAssignmentImpl][CtVariableWriteImpl]quartersCost += [CtInvocationImpl][CtVariableReadImpl]bay.getCost();
                } else [CtBlockImpl]{
                    [CtOperatorAssignmentImpl][CtVariableWriteImpl]bayCost += [CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]bay.getCost() + [CtBinaryOperatorImpl]([CtLiteralImpl]1000L * [CtInvocationImpl][CtVariableReadImpl]bay.getDoors());
                }
            }
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtLiteralImpl]null != [CtFieldReadImpl]bvText) && [CtBinaryOperatorImpl]([CtVariableReadImpl]seatCost > [CtLiteralImpl]0)) [CtBlockImpl]{
                [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtFieldReadImpl]startColumn);
                [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtLiteralImpl]"Seating");
                [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtFieldReadImpl]endColumn);
                [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtFieldReadImpl]startColumn);
                [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtInvocationImpl][CtVariableReadImpl]commafy.format([CtVariableReadImpl]seatCost));
                [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtFieldReadImpl]endColumn);
                [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtFieldReadImpl]endRow);
                [CtOperatorAssignmentImpl][CtVariableWriteImpl]cost += [CtVariableReadImpl]seatCost;
            }
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtLiteralImpl]null != [CtFieldReadImpl]bvText) && [CtBinaryOperatorImpl]([CtVariableReadImpl]quartersCost > [CtLiteralImpl]0)) [CtBlockImpl]{
                [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtFieldReadImpl]startColumn);
                [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtLiteralImpl]"Quarters");
                [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtFieldReadImpl]endColumn);
                [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtFieldReadImpl]startColumn);
                [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtInvocationImpl][CtVariableReadImpl]commafy.format([CtVariableReadImpl]quartersCost));
                [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtFieldReadImpl]endColumn);
                [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtFieldReadImpl]endRow);
                [CtOperatorAssignmentImpl][CtVariableWriteImpl]cost += [CtVariableReadImpl]quartersCost;
            }
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtLiteralImpl]null != [CtFieldReadImpl]bvText) && [CtBinaryOperatorImpl]([CtVariableReadImpl]bayCost > [CtLiteralImpl]0)) [CtBlockImpl]{
                [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtFieldReadImpl]startColumn);
                [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtLiteralImpl]"Bays");
                [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtFieldReadImpl]endColumn);
                [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtFieldReadImpl]startColumn);
                [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtInvocationImpl][CtVariableReadImpl]commafy.format([CtVariableReadImpl]bayCost));
                [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtFieldReadImpl]endColumn);
                [CtInvocationImpl][CtFieldReadImpl]bvText.append([CtFieldReadImpl]endRow);
                [CtOperatorAssignmentImpl][CtVariableWriteImpl]cost += [CtVariableReadImpl]bayCost;
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]cost;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Used to for cost calculations. Though the TM rules allow a Clan unit to be designed without CASE,
     * MM assumes that CASE is present in any location that has explosive equipment.
     *
     * @return The number of locations protected by Clan CASE beyond what is explicitly mounted.
     */
    protected [CtTypeReferenceImpl]int implicitClanCASE() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]0;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean removePartialCoverHits([CtParameterImpl][CtTypeReferenceImpl]int location, [CtParameterImpl][CtTypeReferenceImpl]int cover, [CtParameterImpl][CtTypeReferenceImpl]int side) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]cover > [CtFieldReadImpl]LosEffects.COVER_NONE) [CtBlockImpl]{
            [CtSwitchImpl]switch ([CtVariableReadImpl]cover) {
                [CtCaseImpl]case [CtFieldReadImpl]LosEffects.COVER_LOWLEFT :
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]location == [CtFieldReadImpl]Mech.LOC_LLEG) [CtBlockImpl]{
                        [CtReturnImpl]return [CtLiteralImpl]true;
                    }
                    [CtBreakImpl]break;
                [CtCaseImpl]case [CtFieldReadImpl]LosEffects.COVER_LOWRIGHT :
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]location == [CtFieldReadImpl]Mech.LOC_RLEG) [CtBlockImpl]{
                        [CtReturnImpl]return [CtLiteralImpl]true;
                    }
                    [CtBreakImpl]break;
                [CtCaseImpl]case [CtFieldReadImpl]LosEffects.COVER_LEFT :
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]location == [CtFieldReadImpl]Mech.LOC_LLEG) || [CtBinaryOperatorImpl]([CtVariableReadImpl]location == [CtFieldReadImpl]Mech.LOC_LARM)) || [CtBinaryOperatorImpl]([CtVariableReadImpl]location == [CtFieldReadImpl]Mech.LOC_LT)) [CtBlockImpl]{
                        [CtReturnImpl]return [CtLiteralImpl]true;
                    }
                    [CtBreakImpl]break;
                [CtCaseImpl]case [CtFieldReadImpl]LosEffects.COVER_RIGHT :
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]location == [CtFieldReadImpl]Mech.LOC_RLEG) || [CtBinaryOperatorImpl]([CtVariableReadImpl]location == [CtFieldReadImpl]Mech.LOC_RARM)) || [CtBinaryOperatorImpl]([CtVariableReadImpl]location == [CtFieldReadImpl]Mech.LOC_RT)) [CtBlockImpl]{
                        [CtReturnImpl]return [CtLiteralImpl]true;
                    }
                    [CtBreakImpl]break;
                [CtCaseImpl]case [CtFieldReadImpl]LosEffects.COVER_HORIZONTAL :
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]location == [CtFieldReadImpl]Mech.LOC_LLEG) || [CtBinaryOperatorImpl]([CtVariableReadImpl]location == [CtFieldReadImpl]Mech.LOC_RLEG)) [CtBlockImpl]{
                        [CtReturnImpl]return [CtLiteralImpl]true;
                    }
                    [CtBreakImpl]break;
                [CtCaseImpl]case [CtFieldReadImpl]LosEffects.COVER_UPPER :
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]location == [CtFieldReadImpl]Mech.LOC_LLEG) || [CtBinaryOperatorImpl]([CtVariableReadImpl]location == [CtFieldReadImpl]Mech.LOC_RLEG)) [CtBlockImpl]{
                        [CtReturnImpl]return [CtLiteralImpl]false;
                    }
                    [CtReturnImpl]return [CtLiteralImpl]true;
                [CtCaseImpl]case [CtFieldReadImpl]LosEffects.COVER_FULL :
                    [CtReturnImpl]return [CtLiteralImpl]true;
                [CtCaseImpl]case [CtFieldReadImpl]LosEffects.COVER_75LEFT :
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]location == [CtFieldReadImpl]Mech.LOC_RARM) || [CtBinaryOperatorImpl]([CtVariableReadImpl]location == [CtFieldReadImpl]Mech.LOC_RLEG)) [CtBlockImpl]{
                        [CtReturnImpl]return [CtLiteralImpl]false;
                    }
                    [CtReturnImpl]return [CtLiteralImpl]true;
                [CtCaseImpl]case [CtFieldReadImpl]LosEffects.COVER_75RIGHT :
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]location == [CtFieldReadImpl]Mech.LOC_LLEG) || [CtBinaryOperatorImpl]([CtVariableReadImpl]location == [CtFieldReadImpl]Mech.LOC_LARM)) [CtBlockImpl]{
                        [CtReturnImpl]return [CtLiteralImpl]false;
                    }
                    [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public abstract [CtTypeReferenceImpl]boolean doomedInExtremeTemp();

    [CtMethodImpl]public abstract [CtTypeReferenceImpl]boolean doomedInVacuum();

    [CtMethodImpl]public abstract [CtTypeReferenceImpl]boolean doomedOnGround();

    [CtMethodImpl]public abstract [CtTypeReferenceImpl]boolean doomedInAtmosphere();

    [CtMethodImpl]public abstract [CtTypeReferenceImpl]boolean doomedInSpace();

    [CtMethodImpl][CtJavaDocImpl]/**
     * Prior to TacOps errata 3.3, armor was rounded up to the nearest half ton
     * As of TacOps errata 3.3, patchwork armor is not rounded by location. Previous editions
     * of the rules required it to be rounded up to the nearest half ton by location.
     * Note:
     * Unless overridden, this should <em>only</em> be called on units with
     * patchwork armor, as rounding behavior is not guaranteed to be correct or
     * even the same for others and units with a single overall armor type have
     * no real reason to specifically care about weight per location anyway.
     *
     * @param loc
     * 		The code value for the location in question (unit
     * 		type-specific).
     * @return The weight of the armor in the location in tons.
     */
    public [CtTypeReferenceImpl]double getArmorWeight([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]double armorPerTon = [CtBinaryOperatorImpl][CtLiteralImpl]16.0 * [CtInvocationImpl][CtTypeAccessImpl]megamek.common.EquipmentType.getArmorPointMultiplier([CtArrayReadImpl][CtFieldReadImpl]armorType[[CtVariableReadImpl]loc], [CtArrayReadImpl][CtFieldReadImpl]armorTechLevel[[CtVariableReadImpl]loc]);
        [CtLocalVariableImpl][CtTypeReferenceImpl]double points = [CtBinaryOperatorImpl][CtInvocationImpl]getOArmor([CtVariableReadImpl]loc) + [CtConditionalImpl]([CtInvocationImpl]hasRearArmor([CtVariableReadImpl]loc) ? [CtInvocationImpl]getOArmor([CtVariableReadImpl]loc, [CtLiteralImpl]true) : [CtLiteralImpl]0);
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtVariableReadImpl]points / [CtVariableReadImpl]armorPerTon;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * The total weight of the armor on this unit. This is guaranteed to be
     * rounded properly for both single-type and patchwork armor.
     *
     * @return The armor weight in tons.
     */
    public [CtTypeReferenceImpl]double getArmorWeight() [CtBlockImpl]{
        [CtIfImpl]if ([CtInvocationImpl]hasPatchworkArmor()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]double total = [CtLiteralImpl]0;
            [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int loc = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]loc < [CtInvocationImpl]locations(); [CtUnaryOperatorImpl][CtVariableWriteImpl]loc++) [CtBlockImpl]{
                [CtOperatorAssignmentImpl][CtVariableWriteImpl]total += [CtInvocationImpl]getArmorWeight([CtVariableReadImpl]loc);
            }
            [CtReturnImpl]return [CtInvocationImpl][CtTypeAccessImpl]megamek.common.RoundWeight.standard([CtVariableReadImpl]total, [CtThisAccessImpl]this);
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]isSupportVehicle() && [CtBinaryOperatorImpl]([CtInvocationImpl]getArmorType([CtInvocationImpl]firstArmorIndex()) == [CtFieldReadImpl]EquipmentType.T_ARMOR_STANDARD)) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]double total = [CtBinaryOperatorImpl][CtInvocationImpl]getTotalOArmor() * [CtInvocationImpl][CtTypeAccessImpl]megamek.common.EquipmentType.getSupportVehicleArmorWeightPerPoint([CtInvocationImpl]getBARRating([CtInvocationImpl]firstArmorIndex()), [CtInvocationImpl]getArmorTechRating());
            [CtReturnImpl]return [CtInvocationImpl][CtTypeAccessImpl]megamek.common.RoundWeight.standard([CtVariableReadImpl]total, [CtThisAccessImpl]this);
        } else [CtBlockImpl]{
            [CtLocalVariableImpl][CtCommentImpl]// this roundabout method is actually necessary to avoid rounding
            [CtCommentImpl]// weirdness. Yeah, it's dumb.
            [CtTypeReferenceImpl]double armorPerTon = [CtBinaryOperatorImpl][CtLiteralImpl]16.0 * [CtInvocationImpl][CtTypeAccessImpl]megamek.common.EquipmentType.getArmorPointMultiplier([CtArrayReadImpl][CtFieldReadImpl]armorType[[CtLiteralImpl]0], [CtArrayReadImpl][CtFieldReadImpl]armorTechLevel[[CtLiteralImpl]0]);
            [CtReturnImpl]return [CtInvocationImpl][CtTypeAccessImpl]megamek.common.RoundWeight.standard([CtBinaryOperatorImpl][CtInvocationImpl]getTotalOArmor() / [CtVariableReadImpl]armorPerTon, [CtThisAccessImpl]this);
        }
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean hasTAG() [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getWeaponList()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.WeaponType equip = [CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.WeaponType) ([CtVariableReadImpl]m.getType()));
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]equip != [CtLiteralImpl]null) && [CtInvocationImpl][CtVariableReadImpl]equip.hasFlag([CtTypeAccessImpl]WeaponType.F_TAG)) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isCanon() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]canon;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setCanon([CtParameterImpl][CtTypeReferenceImpl]boolean canon) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.canon = [CtVariableReadImpl]canon;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Get the entity's "climbing mode"
     *
     * @return True or false, where true = climb up and false = go through
     */
    public [CtTypeReferenceImpl]boolean climbMode() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]climbMode;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setClimbMode([CtParameterImpl][CtTypeReferenceImpl]boolean state) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]climbMode = [CtVariableReadImpl]state;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean usedTag() [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted weapon : [CtInvocationImpl]getWeaponList()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.WeaponType wtype = [CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.WeaponType) ([CtVariableReadImpl]weapon.getType()));
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]weapon.isUsedThisRound() && [CtInvocationImpl][CtVariableReadImpl]wtype.hasFlag([CtTypeAccessImpl]WeaponType.F_TAG)) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean hasEiCockpit() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtFieldReadImpl]game != [CtLiteralImpl]null) && [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVANCED_ALL_HAVE_EI_COCKPIT);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean hasActiveEiCockpit() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtInvocationImpl]hasEiCockpit() && [CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.UNOFF_EI_IMPLANT);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isLayingMines() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]layingMines;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setLayingMines([CtParameterImpl][CtTypeReferenceImpl]boolean laying) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]layingMines = [CtVariableReadImpl]laying;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean canLayMine() [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]java.lang.Object oMount : [CtFieldReadImpl]miscList) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted mount = [CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.Mounted) (oMount));
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.EquipmentType type = [CtInvocationImpl][CtVariableReadImpl]mount.getType();
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]mount.isMissing()) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]type.hasFlag([CtTypeAccessImpl]MiscType.F_MINE) || [CtInvocationImpl][CtVariableReadImpl]type.hasFlag([CtTypeAccessImpl]MiscType.F_VEHICLE_MINE_DISPENSER))) && [CtUnaryOperatorImpl](![CtInvocationImpl]isLayingMines())) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]int sideTable([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords src) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]sideTable([CtVariableReadImpl]src, [CtLiteralImpl]false);
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]int sideTable([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords src, [CtParameterImpl][CtTypeReferenceImpl]boolean usePrior) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]sideTable([CtVariableReadImpl]src, [CtVariableReadImpl]usePrior, [CtFieldReadImpl]facing);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int sideTable([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords src, [CtParameterImpl][CtTypeReferenceImpl]boolean usePrior, [CtParameterImpl][CtTypeReferenceImpl]int face) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]sideTable([CtVariableReadImpl]src, [CtVariableReadImpl]usePrior, [CtVariableReadImpl]face, [CtInvocationImpl]getPosition());
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int sideTable([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords src, [CtParameterImpl][CtTypeReferenceImpl]boolean usePrior, [CtParameterImpl][CtTypeReferenceImpl]int face, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords effectivePos) [CtBlockImpl]{
        [CtIfImpl]if ([CtVariableReadImpl]usePrior) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]effectivePos = [CtInvocationImpl]getPriorPosition();
        }
        [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]src.equals([CtVariableReadImpl]effectivePos)) [CtBlockImpl]{
            [CtReturnImpl][CtCommentImpl]// most places handle 0 range explicitly,
            [CtCommentImpl]// this is a safe default (calculation gives SIDE_RIGHT)
            return [CtFieldReadImpl]ToHitData.SIDE_FRONT;
        }
        [CtLocalVariableImpl][CtCommentImpl]// calculate firing angle
        [CtTypeReferenceImpl]int fa = [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]effectivePos.degree([CtVariableReadImpl]src) + [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtLiteralImpl]6 - [CtVariableReadImpl]face) * [CtLiteralImpl]60)) % [CtLiteralImpl]360;
        [CtLocalVariableImpl][CtTypeReferenceImpl]int leftBetter = [CtLiteralImpl]2;
        [CtIfImpl][CtCommentImpl]// if we're right on the line, we need to special case this
        [CtCommentImpl]// defender would choose along which hex the LOS gets drawn, and that
        [CtCommentImpl]// side also determines the side we hit in
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]fa % [CtLiteralImpl]30) == [CtLiteralImpl]0) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.IHex srcHex = [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().getHex([CtVariableReadImpl]src);
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.IHex curHex = [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().getHex([CtInvocationImpl]getPosition());
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]srcHex != [CtLiteralImpl]null) && [CtBinaryOperatorImpl]([CtVariableReadImpl]curHex != [CtLiteralImpl]null)) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl][CtTypeReferenceImpl]megamek.common.LosEffects.AttackInfo ai = [CtInvocationImpl][CtTypeAccessImpl]megamek.common.LosEffects.buildAttackInfo([CtVariableReadImpl]src, [CtInvocationImpl]getPosition(), [CtLiteralImpl]1, [CtInvocationImpl]getElevation(), [CtInvocationImpl][CtVariableReadImpl]srcHex.floor(), [CtInvocationImpl][CtVariableReadImpl]curHex.floor());
                [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.Coords> in = [CtInvocationImpl][CtTypeAccessImpl]megamek.common.Coords.intervening([CtFieldReadImpl][CtVariableReadImpl]ai.attackPos, [CtFieldReadImpl][CtVariableReadImpl]ai.targetPos, [CtLiteralImpl]true);
                [CtAssignmentImpl][CtVariableWriteImpl]leftBetter = [CtInvocationImpl][CtTypeAccessImpl]megamek.common.LosEffects.dividedLeftBetter([CtVariableReadImpl]in, [CtFieldReadImpl]game, [CtVariableReadImpl]ai, [CtInvocationImpl][CtTypeAccessImpl]megamek.common.Compute.isInBuilding([CtFieldReadImpl]game, [CtThisAccessImpl]this), [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.LosEffects());
            }
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]boolean targetIsTank = [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Tank) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVCOMBAT_TACOPS_ADVANCED_MECH_HIT_LOCATIONS) && [CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.QuadMech));
        [CtIfImpl]if ([CtVariableReadImpl]targetIsTank) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]leftBetter == [CtLiteralImpl]1) && [CtBinaryOperatorImpl]([CtVariableReadImpl]fa == [CtLiteralImpl]150)) [CtBlockImpl]{
                [CtReturnImpl]return [CtFieldReadImpl]ToHitData.SIDE_REAR;
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]leftBetter == [CtLiteralImpl]1) && [CtBinaryOperatorImpl]([CtVariableReadImpl]fa == [CtLiteralImpl]30)) [CtBlockImpl]{
                [CtReturnImpl]return [CtFieldReadImpl]ToHitData.SIDE_RIGHT;
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]leftBetter == [CtLiteralImpl]0) && [CtBinaryOperatorImpl]([CtVariableReadImpl]fa == [CtLiteralImpl]330)) [CtBlockImpl]{
                [CtReturnImpl]return [CtFieldReadImpl]ToHitData.SIDE_LEFT;
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]leftBetter == [CtLiteralImpl]0) && [CtBinaryOperatorImpl]([CtVariableReadImpl]fa == [CtLiteralImpl]210)) [CtBlockImpl]{
                [CtReturnImpl]return [CtFieldReadImpl]ToHitData.SIDE_REAR;
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]fa > [CtLiteralImpl]30) && [CtBinaryOperatorImpl]([CtVariableReadImpl]fa <= [CtLiteralImpl]150)) [CtBlockImpl]{
                [CtReturnImpl]return [CtFieldReadImpl]ToHitData.SIDE_RIGHT;
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]fa > [CtLiteralImpl]150) && [CtBinaryOperatorImpl]([CtVariableReadImpl]fa < [CtLiteralImpl]210)) [CtBlockImpl]{
                [CtReturnImpl]return [CtFieldReadImpl]ToHitData.SIDE_REAR;
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]fa >= [CtLiteralImpl]210) && [CtBinaryOperatorImpl]([CtVariableReadImpl]fa < [CtLiteralImpl]330)) [CtBlockImpl]{
                [CtReturnImpl]return [CtFieldReadImpl]ToHitData.SIDE_LEFT;
            } else [CtBlockImpl]{
                [CtReturnImpl]return [CtFieldReadImpl]ToHitData.SIDE_FRONT;
            }
        }
        [CtIfImpl]if ([CtInvocationImpl]isAero()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.IAero a = [CtThisAccessImpl](([CtTypeReferenceImpl]megamek.common.IAero) (this));
            [CtIfImpl][CtCommentImpl]// Handle spheroids in atmosphere or on the ground differently
            if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]a.isSpheroid() && [CtBinaryOperatorImpl]([CtFieldReadImpl]game != [CtLiteralImpl]null)) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().inSpace())) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]fa >= [CtLiteralImpl]0) && [CtBinaryOperatorImpl]([CtVariableReadImpl]fa < [CtLiteralImpl]180)) [CtBlockImpl]{
                    [CtReturnImpl]return [CtFieldReadImpl]ToHitData.SIDE_RIGHT;
                }
                [CtReturnImpl]return [CtFieldReadImpl]ToHitData.SIDE_LEFT;
            }
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]leftBetter == [CtLiteralImpl]1) && [CtBinaryOperatorImpl]([CtVariableReadImpl]fa == [CtLiteralImpl]150)) [CtBlockImpl]{
                [CtReturnImpl]return [CtFieldReadImpl]ToHitData.SIDE_REAR;
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]leftBetter == [CtLiteralImpl]1) && [CtBinaryOperatorImpl]([CtVariableReadImpl]fa == [CtLiteralImpl]30)) [CtBlockImpl]{
                [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]a.isRolled()) [CtBlockImpl]{
                    [CtReturnImpl]return [CtFieldReadImpl]ToHitData.SIDE_LEFT;
                }
                [CtReturnImpl]return [CtFieldReadImpl]ToHitData.SIDE_RIGHT;
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]leftBetter == [CtLiteralImpl]0) && [CtBinaryOperatorImpl]([CtVariableReadImpl]fa == [CtLiteralImpl]330)) [CtBlockImpl]{
                [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]a.isRolled()) [CtBlockImpl]{
                    [CtReturnImpl]return [CtFieldReadImpl]ToHitData.SIDE_RIGHT;
                }
                [CtReturnImpl]return [CtFieldReadImpl]ToHitData.SIDE_LEFT;
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]leftBetter == [CtLiteralImpl]0) && [CtBinaryOperatorImpl]([CtVariableReadImpl]fa == [CtLiteralImpl]210)) [CtBlockImpl]{
                [CtReturnImpl]return [CtFieldReadImpl]ToHitData.SIDE_REAR;
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]fa > [CtLiteralImpl]30) && [CtBinaryOperatorImpl]([CtVariableReadImpl]fa <= [CtLiteralImpl]150)) [CtBlockImpl]{
                [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]a.isRolled()) [CtBlockImpl]{
                    [CtReturnImpl]return [CtFieldReadImpl]ToHitData.SIDE_LEFT;
                }
                [CtReturnImpl]return [CtFieldReadImpl]ToHitData.SIDE_RIGHT;
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]fa > [CtLiteralImpl]150) && [CtBinaryOperatorImpl]([CtVariableReadImpl]fa < [CtLiteralImpl]210)) [CtBlockImpl]{
                [CtReturnImpl]return [CtFieldReadImpl]ToHitData.SIDE_REAR;
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]fa >= [CtLiteralImpl]210) && [CtBinaryOperatorImpl]([CtVariableReadImpl]fa < [CtLiteralImpl]330)) [CtBlockImpl]{
                [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]a.isRolled()) [CtBlockImpl]{
                    [CtReturnImpl]return [CtFieldReadImpl]ToHitData.SIDE_RIGHT;
                }
                [CtReturnImpl]return [CtFieldReadImpl]ToHitData.SIDE_LEFT;
            } else [CtBlockImpl]{
                [CtReturnImpl]return [CtFieldReadImpl]ToHitData.SIDE_FRONT;
            }
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]fa == [CtLiteralImpl]90) && [CtBinaryOperatorImpl]([CtVariableReadImpl]leftBetter == [CtLiteralImpl]1)) [CtBlockImpl]{
            [CtReturnImpl]return [CtFieldReadImpl]ToHitData.SIDE_RIGHT;
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]fa == [CtLiteralImpl]150) && [CtBinaryOperatorImpl]([CtVariableReadImpl]leftBetter == [CtLiteralImpl]1)) || [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]leftBetter == [CtLiteralImpl]0) && [CtBinaryOperatorImpl]([CtVariableReadImpl]fa == [CtLiteralImpl]210))) [CtBlockImpl]{
            [CtReturnImpl]return [CtFieldReadImpl]ToHitData.SIDE_REAR;
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]leftBetter == [CtLiteralImpl]0) && [CtBinaryOperatorImpl]([CtVariableReadImpl]fa == [CtLiteralImpl]270)) [CtBlockImpl]{
            [CtReturnImpl]return [CtFieldReadImpl]ToHitData.SIDE_LEFT;
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]fa > [CtLiteralImpl]90) && [CtBinaryOperatorImpl]([CtVariableReadImpl]fa <= [CtLiteralImpl]150)) [CtBlockImpl]{
            [CtReturnImpl]return [CtFieldReadImpl]ToHitData.SIDE_RIGHT;
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]fa > [CtLiteralImpl]150) && [CtBinaryOperatorImpl]([CtVariableReadImpl]fa < [CtLiteralImpl]210)) [CtBlockImpl]{
            [CtReturnImpl]return [CtFieldReadImpl]ToHitData.SIDE_REAR;
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]fa >= [CtLiteralImpl]210) && [CtBinaryOperatorImpl]([CtVariableReadImpl]fa < [CtLiteralImpl]270)) [CtBlockImpl]{
            [CtReturnImpl]return [CtFieldReadImpl]ToHitData.SIDE_LEFT;
        } else [CtBlockImpl]{
            [CtReturnImpl]return [CtFieldReadImpl]ToHitData.SIDE_FRONT;
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Method to determine if an entity is currently capable of going hull-down.
     * Note, this is *not* whether the entity can ever go hull-down.
     *
     * @return True if the entity is able to go hull-down, else false.
     */
    public [CtTypeReferenceImpl]boolean canGoHullDown() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean canAssaultDrop() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setAssaultDropInProgress([CtParameterImpl][CtTypeReferenceImpl]boolean flag) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]assaultDropInProgress = [CtConditionalImpl]([CtVariableReadImpl]flag) ? [CtLiteralImpl]1 : [CtLiteralImpl]0;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setLandedAssaultDrop() [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]assaultDropInProgress = [CtLiteralImpl]2;
        [CtAssignmentImpl][CtFieldWriteImpl]moved = [CtFieldReadImpl]EntityMovementType.MOVE_JUMP;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isAssaultDropInProgress() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtFieldReadImpl]assaultDropInProgress != [CtLiteralImpl]0;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Apply PSR modifier for difficult terrain at the specified coordinates
     *
     * @param roll
     * 		the PSR to modify
     * @param c
     * 		the coordinates where the PSR happens
     */
    public [CtTypeReferenceImpl]void addPilotingModifierForTerrain([CtParameterImpl][CtTypeReferenceImpl]megamek.common.PilotingRollData roll, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords c) [CtBlockImpl]{
        [CtInvocationImpl]addPilotingModifierForTerrain([CtVariableReadImpl]roll, [CtVariableReadImpl]c, [CtLiteralImpl]false);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Apply PSR modifier for difficult terrain at the specified coordinates
     *
     * @param roll
     * 		the PSR to modify
     * @param c
     * 		the coordinates where the PSR happens
     * @param enteringRubble
     * 		True if entering rubble, else false
     */
    public [CtTypeReferenceImpl]void addPilotingModifierForTerrain([CtParameterImpl][CtTypeReferenceImpl]megamek.common.PilotingRollData roll, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords c, [CtParameterImpl][CtTypeReferenceImpl]boolean enteringRubble) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]c == [CtLiteralImpl]null) || [CtBinaryOperatorImpl]([CtVariableReadImpl]roll == [CtLiteralImpl]null)) [CtBlockImpl]{
            [CtReturnImpl]return;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]isOffBoard() || [CtUnaryOperatorImpl](![CtInvocationImpl]isDeployed())) [CtBlockImpl]{
            [CtReturnImpl]return;
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.IHex hex = [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().getHex([CtVariableReadImpl]c);
        [CtInvocationImpl][CtVariableReadImpl]hex.terrainPilotingModifier([CtInvocationImpl]getMovementMode(), [CtVariableReadImpl]roll, [CtVariableReadImpl]enteringRubble);
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]hex.containsTerrain([CtTypeAccessImpl]Terrains.JUNGLE) && [CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.PILOT_TM_FOREST_RANGER)) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtUnaryOperatorImpl]-[CtLiteralImpl]1, [CtLiteralImpl]"Forest Ranger");
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Apply PSR modifier for difficult terrain at the move step position
     *
     * @param roll
     * 		the PSR to modify
     * @param step
     * 		the move step the PSR occurs at
     */
    public [CtTypeReferenceImpl]void addPilotingModifierForTerrain([CtParameterImpl][CtTypeReferenceImpl]megamek.common.PilotingRollData roll, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.MoveStep step) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]step.getElevation() > [CtLiteralImpl]0) [CtBlockImpl]{
            [CtReturnImpl]return;
        }
        [CtInvocationImpl]addPilotingModifierForTerrain([CtVariableReadImpl]roll, [CtInvocationImpl][CtVariableReadImpl]step.getPosition());
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Apply PSR modifier for difficult terrain in the current position
     *
     * @param roll
     * 		the PSR to modify
     */
    public [CtTypeReferenceImpl]void addPilotingModifierForTerrain([CtParameterImpl][CtTypeReferenceImpl]megamek.common.PilotingRollData roll) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]getElevation() > [CtLiteralImpl]0) [CtBlockImpl]{
            [CtReturnImpl]return;
        }
        [CtInvocationImpl]addPilotingModifierForTerrain([CtVariableReadImpl]roll, [CtInvocationImpl]getPosition());
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * defensively check and correct elevation
     */
    public [CtTypeReferenceImpl]boolean fixElevation() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtUnaryOperatorImpl](![CtInvocationImpl]isDeployed()) || [CtInvocationImpl]isOffBoard()) || [CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().contains([CtInvocationImpl]getPosition()))) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl]if ([CtUnaryOperatorImpl]![CtInvocationImpl]isElevationValid([CtInvocationImpl]getElevation(), [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().getHex([CtInvocationImpl]getPosition()))) [CtBlockImpl]{
            [CtInvocationImpl][CtFieldReadImpl][CtTypeAccessImpl]java.lang.System.[CtFieldReferenceImpl]err.println([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]getDisplayName() + [CtLiteralImpl]" in hex ") + [CtInvocationImpl][CtTypeAccessImpl]megamek.common.HexTarget.coordsToId([CtInvocationImpl]getPosition())) + [CtLiteralImpl]" is at invalid elevation: ") + [CtInvocationImpl]getElevation());
            [CtInvocationImpl]setElevation([CtBinaryOperatorImpl][CtLiteralImpl]0 - [CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().getHex([CtInvocationImpl]getPosition()).depth());
            [CtInvocationImpl][CtFieldReadImpl][CtTypeAccessImpl]java.lang.System.[CtFieldReferenceImpl]err.println([CtBinaryOperatorImpl][CtLiteralImpl]"   moved to elevation " + [CtInvocationImpl]getElevation());
            [CtReturnImpl]return [CtLiteralImpl]true;
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]megamek.common.Engine getEngine() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]engine;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean hasEngine() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtLiteralImpl]null != [CtFieldReadImpl]engine;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setEngine([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Engine e) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]engine = [CtVariableReadImpl]e;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean itemOppositeTech([CtParameterImpl][CtTypeReferenceImpl]java.lang.String s) [CtBlockImpl]{
        [CtIfImpl]if ([CtInvocationImpl]isClan()) [CtBlockImpl]{
            [CtIfImpl][CtCommentImpl]// Clan base
            if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]s.toLowerCase().indexOf([CtLiteralImpl]"(is)") != [CtUnaryOperatorImpl](-[CtLiteralImpl]1)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]s.toLowerCase().indexOf([CtLiteralImpl]"inner sphere") != [CtUnaryOperatorImpl](-[CtLiteralImpl]1))) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]s.toLowerCase().indexOf([CtLiteralImpl]"(c)") != [CtUnaryOperatorImpl](-[CtLiteralImpl]1)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]s.toLowerCase().indexOf([CtLiteralImpl]"clan") != [CtUnaryOperatorImpl](-[CtLiteralImpl]1))) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]true;
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @return Returns the retreatedDirection.
     */
    public [CtTypeReferenceImpl]megamek.common.OffBoardDirection getRetreatedDirection() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]retreatedDirection;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @param retreatedDirection
     * 		The retreatedDirection to set.
     */
    public [CtTypeReferenceImpl]void setRetreatedDirection([CtParameterImpl][CtTypeReferenceImpl]megamek.common.OffBoardDirection retreatedDirection) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.retreatedDirection = [CtVariableReadImpl]retreatedDirection;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setLastTarget([CtParameterImpl][CtTypeReferenceImpl]int id) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]lastTarget = [CtVariableReadImpl]id;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getLastTarget() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]lastTarget;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setLastTargetDisplayName([CtParameterImpl][CtTypeReferenceImpl]java.lang.String name) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]lastTargetDisplayName = [CtVariableReadImpl]name;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.lang.String getLastTargetDisplayName() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]lastTargetDisplayName;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @returns whether or not the unit is suffering from Electromagnetic
    Interference
     */
    public [CtTypeReferenceImpl]boolean isSufferingEMI() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]_isEMId;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setEMI([CtParameterImpl][CtTypeReferenceImpl]boolean inVal) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]_isEMId = [CtVariableReadImpl]inVal;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * The attack direction modifier for rolls on the motive system hits table
     * for the given side (as defined in {@link ToHitData}). This will return 0
     * if Tactical Operations vehicle effectiveness rules are in effect or if
     * the side parameter falls outside ToHitData's range of "fixed" side
     * values; in particular, it will return 0 if handed
     * {@link ToHitData#SIDE_RANDOM}.
     *
     * @param side
     * 		The attack direction as specified above.
     * @return The appropriate directional roll modifier.
     */
    public [CtTypeReferenceImpl]int getMotiveSideMod([CtParameterImpl][CtTypeReferenceImpl]int side) [CtBlockImpl]{
        [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVCOMBAT_TACOPS_VEHICLE_EFFECTIVE)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]0;
        }
        [CtSwitchImpl]switch ([CtVariableReadImpl]side) {
            [CtCaseImpl]case [CtFieldReadImpl]ToHitData.SIDE_LEFT :
            [CtCaseImpl]case [CtFieldReadImpl]ToHitData.SIDE_RIGHT :
            [CtCaseImpl]case [CtFieldReadImpl]ToHitData.SIDE_FRONTLEFT :
            [CtCaseImpl]case [CtFieldReadImpl]ToHitData.SIDE_FRONTRIGHT :
            [CtCaseImpl]case [CtFieldReadImpl]ToHitData.SIDE_REARLEFT :
            [CtCaseImpl]case [CtFieldReadImpl]ToHitData.SIDE_REARRIGHT :
                [CtReturnImpl]return [CtLiteralImpl]2;
            [CtCaseImpl]case [CtFieldReadImpl]ToHitData.SIDE_REAR :
                [CtReturnImpl]return [CtLiteralImpl]1;
            [CtCaseImpl]default :
                [CtReturnImpl]return [CtLiteralImpl]0;
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks if the unit is hardened agaist nuclear strikes.
     *
     * @return true if this is a hardened unit.
     */
    public abstract [CtTypeReferenceImpl]boolean isNuclearHardened();

    [CtMethodImpl][CtJavaDocImpl]/**
     * Set the isHidden state of this entity (used for hidden units rules, TW
     * pg 259).
     *
     * @param inVal
     */
    public [CtTypeReferenceImpl]void setHidden([CtParameterImpl][CtTypeReferenceImpl]boolean inVal) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]isHidden = [CtVariableReadImpl]inVal;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setMadePointblankShot([CtParameterImpl][CtTypeReferenceImpl]boolean inVal) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]madePointblankShot = [CtVariableReadImpl]inVal;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Set a phase for this hidden unit to become active in.
     *
     * @param phase
     */
    public [CtTypeReferenceImpl]void setHiddeActivationPhase([CtParameterImpl][CtTypeReferenceImpl][CtTypeReferenceImpl]megamek.common.IGame.Phase phase) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]hiddenActivationPhase = [CtVariableReadImpl]phase;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns true if this unit is currently hidden (hidden units, TW pg 259).
     *
     * @return  */
    public [CtTypeReferenceImpl]boolean isHidden() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]isHidden;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns true if this unit has already made a pointblank shot this round.
     *
     * @return  */
    public [CtTypeReferenceImpl]boolean madePointblankShot() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]madePointblankShot;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns true if this unit should be considering a hidden unit that is
     * activating.
     *
     * @return  */
    public [CtTypeReferenceImpl]boolean isHiddenActivating() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtInvocationImpl]getHiddenActivationPhase() != [CtLiteralImpl]null;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Get the phase that this hidden unit will activate in (generally this
     * will be null, indicating that the unit isn't activating).
     *
     * @return  */
    [CtAnnotationImpl]@megamek.common.annotations.Nullable
    public [CtTypeReferenceImpl]megamek.common.IGame.Phase getHiddenActivationPhase() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]hiddenActivationPhase;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Is this unit a carcass, a carcass can take no action
     */
    public [CtTypeReferenceImpl]boolean isCarcass() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]carcass;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Sets if this unit is a carcass.
     *
     * @param carcass
     * 		true if this unit should be a carcass, false otherwise.
     * @see megamek.common.Entity#isCarcass
     */
    public [CtTypeReferenceImpl]void setCarcass([CtParameterImpl][CtTypeReferenceImpl]boolean carcass) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.carcass = [CtVariableReadImpl]carcass;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Marks all equipment in a location on this entity as destroyed.
     *
     * @param loc
     * 		The location that is destroyed.
     */
    public [CtTypeReferenceImpl]void destroyLocation([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtInvocationImpl]destroyLocation([CtVariableReadImpl]loc, [CtLiteralImpl]false);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Marks all equipment in a location on this entity as destroyed.
     *
     * @param loc
     * 		The location that is destroyed.
     * @param blownOff
     * 		true if the location was blown off
     */
    public [CtTypeReferenceImpl]void destroyLocation([CtParameterImpl][CtTypeReferenceImpl]int loc, [CtParameterImpl][CtTypeReferenceImpl]boolean blownOff) [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// if it's already marked as destroyed, don't bother
        if ([CtBinaryOperatorImpl][CtInvocationImpl]getInternal([CtVariableReadImpl]loc) < [CtLiteralImpl]0) [CtBlockImpl]{
            [CtReturnImpl]return;
        }
        [CtIfImpl]if ([CtVariableReadImpl]blownOff) [CtBlockImpl]{
            [CtInvocationImpl]setLocationBlownOff([CtVariableReadImpl]loc, [CtLiteralImpl]true);
            [CtInvocationImpl]setLocationBlownOffThisPhase([CtVariableReadImpl]loc, [CtLiteralImpl]true);
        } else [CtBlockImpl]{
            [CtInvocationImpl][CtCommentImpl]// mark armor, internal as doomed
            setArmor([CtTypeAccessImpl]IArmorState.ARMOR_DOOMED, [CtVariableReadImpl]loc, [CtLiteralImpl]false);
            [CtInvocationImpl]setInternal([CtTypeAccessImpl]IArmorState.ARMOR_DOOMED, [CtVariableReadImpl]loc);
            [CtIfImpl]if ([CtInvocationImpl]hasRearArmor([CtVariableReadImpl]loc)) [CtBlockImpl]{
                [CtInvocationImpl]setArmor([CtTypeAccessImpl]IArmorState.ARMOR_DOOMED, [CtVariableReadImpl]loc, [CtLiteralImpl]true);
            }
        }
        [CtForEachImpl][CtCommentImpl]// equipment marked missing
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted : [CtInvocationImpl]getEquipment()) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]mounted.getLocation() == [CtVariableReadImpl]loc) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getType().isHittable()) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]mounted.isSplit() && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]mounted.getSecondLocation() == [CtVariableReadImpl]loc))) [CtBlockImpl]{
                [CtIfImpl]if ([CtVariableReadImpl]blownOff) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]mounted.setMissing([CtLiteralImpl]true);
                } else [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]mounted.setHit([CtLiteralImpl]true);
                }
            }
        }
        [CtForImpl][CtCommentImpl]// all critical slots set as missing
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtInvocationImpl]getNumberOfCriticals([CtVariableReadImpl]loc); [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtLocalVariableImpl]final [CtTypeReferenceImpl]megamek.common.CriticalSlot cs = [CtInvocationImpl]getCritical([CtVariableReadImpl]loc, [CtVariableReadImpl]i);
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]cs != [CtLiteralImpl]null) [CtBlockImpl]{
                [CtIfImpl][CtCommentImpl]// count engine hits for maxtech engine explosions
                if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]cs.getType() == [CtFieldReadImpl]CriticalSlot.TYPE_SYSTEM) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]cs.getIndex() == [CtFieldReadImpl]Mech.SYSTEM_ENGINE)) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]cs.isDamaged())) [CtBlockImpl]{
                    [CtUnaryOperatorImpl][CtFieldWriteImpl]engineHitsThisPhase++;
                }
                [CtIfImpl]if ([CtVariableReadImpl]blownOff) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]cs.setMissing([CtLiteralImpl]true);
                } else [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]cs.setHit([CtLiteralImpl]true);
                }
            }
        }
        [CtIfImpl][CtCommentImpl]// dependent locations destroyed, unless they are already destroyed
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl]getDependentLocation([CtVariableReadImpl]loc) != [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]LOC_NONE) && [CtUnaryOperatorImpl](![CtBinaryOperatorImpl]([CtInvocationImpl]getInternal([CtInvocationImpl]getDependentLocation([CtVariableReadImpl]loc)) < [CtLiteralImpl]0))) [CtBlockImpl]{
            [CtInvocationImpl]destroyLocation([CtInvocationImpl]getDependentLocation([CtVariableReadImpl]loc), [CtLiteralImpl]true);
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Iterates over all Narc and iNarc pods attached to this entity and removes
     * those still 'stuck' to destroyed or missing locations.
     */
    public [CtTypeReferenceImpl]void clearDestroyedNarcPods() [CtBlockImpl]{
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Iterator<[CtTypeReferenceImpl]megamek.common.NarcPod> i = [CtInvocationImpl][CtFieldReadImpl]pendingNarcPods.iterator(); [CtInvocationImpl][CtVariableReadImpl]i.hasNext();) [CtBlockImpl]{
            [CtIfImpl]if ([CtUnaryOperatorImpl]![CtInvocationImpl]locationCanHoldNarcPod([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]i.next().getLocation())) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]i.remove();
            }
        }
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Iterator<[CtTypeReferenceImpl]megamek.common.NarcPod> i = [CtInvocationImpl][CtFieldReadImpl]narcPods.iterator(); [CtInvocationImpl][CtVariableReadImpl]i.hasNext();) [CtBlockImpl]{
            [CtIfImpl]if ([CtUnaryOperatorImpl]![CtInvocationImpl]locationCanHoldNarcPod([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]i.next().getLocation())) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]i.remove();
            }
        }
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Iterator<[CtTypeReferenceImpl]megamek.common.INarcPod> i = [CtInvocationImpl][CtFieldReadImpl]pendingINarcPods.iterator(); [CtInvocationImpl][CtVariableReadImpl]i.hasNext();) [CtBlockImpl]{
            [CtIfImpl]if ([CtUnaryOperatorImpl]![CtInvocationImpl]locationCanHoldNarcPod([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]i.next().getLocation())) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]i.remove();
            }
        }
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Iterator<[CtTypeReferenceImpl]megamek.common.INarcPod> i = [CtInvocationImpl][CtFieldReadImpl]iNarcPods.iterator(); [CtInvocationImpl][CtVariableReadImpl]i.hasNext();) [CtBlockImpl]{
            [CtIfImpl]if ([CtUnaryOperatorImpl]![CtInvocationImpl]locationCanHoldNarcPod([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]i.next().getLocation())) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]i.remove();
            }
        }
    }

    [CtMethodImpl]private [CtTypeReferenceImpl]boolean locationCanHoldNarcPod([CtParameterImpl][CtTypeReferenceImpl]int location) [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]getInternal([CtVariableReadImpl]location) > [CtLiteralImpl]0) && [CtUnaryOperatorImpl](![CtInvocationImpl]isLocationBlownOff([CtVariableReadImpl]location))) && [CtUnaryOperatorImpl](![CtInvocationImpl]isLocationBlownOffThisPhase([CtVariableReadImpl]location));
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]megamek.common.PilotingRollData checkSideSlip([CtParameterImpl][CtTypeReferenceImpl]megamek.common.EntityMovementType moveType, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.IHex prevHex, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.EntityMovementType overallMoveType, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.MoveStep prevStep, [CtParameterImpl][CtTypeReferenceImpl]int prevFacing, [CtParameterImpl][CtTypeReferenceImpl]int curFacing, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords lastPos, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords curPos, [CtParameterImpl][CtTypeReferenceImpl]int distance) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.PilotingRollData roll = [CtInvocationImpl]getBasePilotingRoll([CtVariableReadImpl]overallMoveType);
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]moveType != [CtFieldReadImpl]EntityMovementType.MOVE_JUMP) && [CtBinaryOperatorImpl]([CtVariableReadImpl]prevHex != [CtLiteralImpl]null)) && [CtBinaryOperatorImpl]([CtVariableReadImpl]distance > [CtLiteralImpl]1)) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]overallMoveType == [CtFieldReadImpl]EntityMovementType.MOVE_RUN) || [CtBinaryOperatorImpl]([CtVariableReadImpl]overallMoveType == [CtFieldReadImpl]EntityMovementType.MOVE_VTOL_RUN)) || [CtBinaryOperatorImpl]([CtVariableReadImpl]overallMoveType == [CtFieldReadImpl]EntityMovementType.MOVE_SPRINT)) || [CtBinaryOperatorImpl]([CtVariableReadImpl]overallMoveType == [CtFieldReadImpl]EntityMovementType.MOVE_VTOL_SPRINT))) && [CtBinaryOperatorImpl]([CtVariableReadImpl]prevFacing != [CtVariableReadImpl]curFacing)) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]lastPos.equals([CtVariableReadImpl]curPos))) && [CtUnaryOperatorImpl](![CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Infantry))) && [CtUnaryOperatorImpl](![CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Protomech))) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.append([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtInvocationImpl]getId(), [CtLiteralImpl]0, [CtLiteralImpl]"flanking and turning"));
            [CtIfImpl]if ([CtInvocationImpl]isUsingManAce()) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtUnaryOperatorImpl]-[CtLiteralImpl]1, [CtLiteralImpl]"Maneuvering Ace");
            }
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() == [CtFieldReadImpl]EntityMovementMode.VTOL) && [CtInvocationImpl]isMASCUsed()) && [CtInvocationImpl]hasWorkingMisc([CtTypeAccessImpl]MiscType.F_JET_BOOSTER)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtLiteralImpl]3, [CtLiteralImpl]"used VTOL Jet Booster");
            }
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]moveType != [CtFieldReadImpl]EntityMovementType.MOVE_JUMP) && [CtBinaryOperatorImpl]([CtVariableReadImpl]prevFacing == [CtVariableReadImpl]curFacing)) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]lastPos.equals([CtVariableReadImpl]curPos))) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]lastPos.direction([CtVariableReadImpl]curPos) % [CtLiteralImpl]3) != [CtBinaryOperatorImpl]([CtVariableReadImpl]curFacing % [CtLiteralImpl]3))) && [CtUnaryOperatorImpl](![CtBinaryOperatorImpl]([CtInvocationImpl]isUsingManAce() && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]overallMoveType == [CtFieldReadImpl]EntityMovementType.MOVE_WALK) || [CtBinaryOperatorImpl]([CtVariableReadImpl]overallMoveType == [CtFieldReadImpl]EntityMovementType.MOVE_VTOL_WALK))))) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.append([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.PilotingRollData([CtInvocationImpl]getId(), [CtLiteralImpl]0, [CtLiteralImpl]"controlled sideslip"));
        } else [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]roll.addModifier([CtTypeAccessImpl]TargetRoll.CHECK_FALSE, [CtLiteralImpl]"Check false: not apparently sideslipping");
        }
        [CtReturnImpl]return [CtVariableReadImpl]roll;
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]boolean isAirborneVTOLorWIGE() [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// stuff that moves like a VTOL is flying unless at elevation 0 or on
        [CtCommentImpl]// top of/in a building,
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() == [CtFieldReadImpl]EntityMovementMode.VTOL) || [CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() == [CtFieldReadImpl]EntityMovementMode.WIGE)) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtFieldReadImpl]game != [CtLiteralImpl]null) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtFieldReadImpl]game.getBoard() != [CtLiteralImpl]null)) && [CtBinaryOperatorImpl]([CtInvocationImpl]getPosition() != [CtLiteralImpl]null)) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().getHex([CtInvocationImpl]getPosition()) != [CtLiteralImpl]null)) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().getHex([CtInvocationImpl]getPosition()).terrainLevel([CtTypeAccessImpl]Terrains.BLDG_ELEV) >= [CtInvocationImpl]getElevation()) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().getHex([CtInvocationImpl]getPosition()).terrainLevel([CtTypeAccessImpl]Terrains.BRIDGE_ELEV) >= [CtInvocationImpl]getElevation()))) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]false;
            }
            [CtReturnImpl]return [CtBinaryOperatorImpl][CtInvocationImpl]getElevation() > [CtLiteralImpl]0;
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setSpotTargetId([CtParameterImpl][CtTypeReferenceImpl]int targetId) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]spotTargetId = [CtVariableReadImpl]targetId;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getSpotTargetId() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]spotTargetId;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setCommander([CtParameterImpl][CtTypeReferenceImpl]boolean arg) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]isCommander = [CtVariableReadImpl]arg;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isCommander() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]isCommander;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean hasLinkedMGA([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted) [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getWeaponList()) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getLocation() == [CtInvocationImpl][CtVariableReadImpl]mounted.getLocation()) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]WeaponType.F_MGA)) && [CtUnaryOperatorImpl](![CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.isDestroyed() || [CtInvocationImpl][CtVariableReadImpl]m.isBreached()))) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getBayWeapons().contains([CtInvocationImpl]getEquipmentNum([CtVariableReadImpl]mounted))) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasModes()) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"Linked")) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setReckless([CtParameterImpl][CtTypeReferenceImpl]boolean b) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]reckless = [CtVariableReadImpl]b;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isReckless() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]reckless;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Helper function to test whether an entity should be treated as an Aero unit (includes
     * LAMs in fighter mode)
     */
    public [CtTypeReferenceImpl]boolean isAero() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Helper function to determine whether an entity is an aero unit but not Small Craft/
     * DropShip/JumpShip/WarShip.
     */
    public [CtTypeReferenceImpl]boolean isFighter() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]isAero();
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isCapitalFighter() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]isCapitalFighter([CtLiteralImpl]false);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isCapitalFighter([CtParameterImpl][CtTypeReferenceImpl]boolean lounge) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtLiteralImpl]null == [CtFieldReadImpl]game) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl][CtCommentImpl]// If we're using the unofficial option for single fighters staying
        [CtCommentImpl]// standard scale & we're not a member of a squadron... then false.
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtUnaryOperatorImpl](![CtVariableReadImpl]lounge) && [CtInvocationImpl]isFighter()) && [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVAERORULES_SINGLE_NO_CAP)) && [CtUnaryOperatorImpl](![CtInvocationImpl]isPartOfFighterSquadron())) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVAERORULES_STRATOPS_CAPITAL_FIGHTER) && [CtInvocationImpl]isFighter();
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * a function that let's us know if this entity has capital-scale armor
     *
     * @return  */
    public [CtTypeReferenceImpl]boolean isCapitalScale() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Jumpship) || [CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.FighterSquadron)) || [CtInvocationImpl]isCapitalFighter()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]true;
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * a function that let's us know if this entity is using weapons bays
     *
     * @return  */
    public [CtTypeReferenceImpl]boolean usesWeaponBays() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * return the bay of the current weapon
     *
     * @param bayID
     * @return  */
    public [CtTypeReferenceImpl]megamek.common.Mounted whichBay([CtParameterImpl][CtTypeReferenceImpl]int bayID) [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getWeaponBayList()) [CtBlockImpl]{
            [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int wId : [CtInvocationImpl][CtVariableReadImpl]m.getBayWeapons()) [CtBlockImpl]{
                [CtIfImpl][CtCommentImpl]// find the weapon and determine if it is there
                if ([CtBinaryOperatorImpl][CtVariableReadImpl]wId == [CtVariableReadImpl]bayID) [CtBlockImpl]{
                    [CtReturnImpl]return [CtVariableReadImpl]m;
                }
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]null;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * return the first bay of the right type in the right location with enough
     * damage to spare
     *
     * @param wtype
     * @param loc
     * @param rearMount
     * @return  */
    public [CtTypeReferenceImpl]megamek.common.Mounted getFirstBay([CtParameterImpl][CtTypeReferenceImpl]megamek.common.WeaponType wtype, [CtParameterImpl][CtTypeReferenceImpl]int loc, [CtParameterImpl][CtTypeReferenceImpl]boolean rearMount) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int weapDamage = [CtInvocationImpl][CtVariableReadImpl]wtype.getRoundShortAV();
        [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]wtype.isCapital()) [CtBlockImpl]{
            [CtOperatorAssignmentImpl][CtVariableWriteImpl]weapDamage *= [CtLiteralImpl]10;
        }
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getWeaponBayList()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.weapons.bayweapons.BayWeapon bay = [CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.weapons.bayweapons.BayWeapon) ([CtVariableReadImpl]m.getType()));
            [CtLocalVariableImpl][CtTypeReferenceImpl]int damage = [CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]bay.getRoundShortAV() + [CtVariableReadImpl]weapDamage;
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]bay.getAtClass() == [CtInvocationImpl][CtVariableReadImpl]wtype.getAtClass()) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getLocation() == [CtVariableReadImpl]loc)) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.isRearMounted() == [CtVariableReadImpl]rearMount)) && [CtBinaryOperatorImpl]([CtVariableReadImpl]damage <= [CtLiteralImpl]700)) [CtBlockImpl]{
                [CtReturnImpl]return [CtVariableReadImpl]m;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]null;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getHeatInArc([CtParameterImpl][CtTypeReferenceImpl]int location, [CtParameterImpl][CtTypeReferenceImpl]boolean rearMount) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int arcHeat = [CtLiteralImpl]0;
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted : [CtInvocationImpl]getTotalWeaponList()) [CtBlockImpl]{
            [CtIfImpl][CtCommentImpl]// is the weapon usable?
            if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]mounted.isDestroyed() || [CtInvocationImpl][CtVariableReadImpl]mounted.isJammed()) [CtBlockImpl]{
                [CtContinueImpl]continue;
            }
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]mounted.getLocation() == [CtVariableReadImpl]location) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]mounted.isRearMounted() == [CtVariableReadImpl]rearMount)) [CtBlockImpl]{
                [CtOperatorAssignmentImpl][CtVariableWriteImpl]arcHeat += [CtInvocationImpl][CtVariableReadImpl]mounted.getCurrentHeat();
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]arcHeat;
    }

    [CtMethodImpl]public [CtArrayTypeReferenceImpl]int[] getVectors() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]vectors;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setVectors([CtParameterImpl][CtArrayTypeReferenceImpl]int[] v) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]v == [CtLiteralImpl]null) || [CtBinaryOperatorImpl]([CtFieldReadImpl][CtVariableReadImpl]v.length != [CtLiteralImpl]6)) [CtBlockImpl]{
            [CtReturnImpl]return;
        }
        [CtAssignmentImpl][CtFieldWriteImpl]vectors = [CtVariableReadImpl]v;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getVector([CtParameterImpl][CtTypeReferenceImpl]int vectorFacing) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]vectorFacing < [CtLiteralImpl]6) [CtBlockImpl]{
            [CtReturnImpl]return [CtArrayReadImpl][CtFieldReadImpl]vectors[[CtVariableReadImpl]vectorFacing];
        }
        [CtReturnImpl]return [CtLiteralImpl]0;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getVelocity() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int total = [CtLiteralImpl]0;
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int dir = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]dir < [CtLiteralImpl]6; [CtUnaryOperatorImpl][CtVariableWriteImpl]dir++) [CtBlockImpl]{
            [CtOperatorAssignmentImpl][CtVariableWriteImpl]total += [CtInvocationImpl]getVector([CtVariableReadImpl]dir);
        }
        [CtReturnImpl]return [CtVariableReadImpl]total;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int chooseSide([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords attackPos, [CtParameterImpl][CtTypeReferenceImpl]boolean usePrior) [CtBlockImpl]{
        [CtLocalVariableImpl][CtCommentImpl]// loop through directions and if we have a non-zero vector, then
        [CtCommentImpl]// compute
        [CtCommentImpl]// the targetsidetable. If we come to a higher vector, then replace. If
        [CtCommentImpl]// we come to an equal vector then take it if it is better
        [CtTypeReferenceImpl]int thrust = [CtLiteralImpl]0;
        [CtLocalVariableImpl][CtTypeReferenceImpl]int high = [CtUnaryOperatorImpl]-[CtLiteralImpl]1;
        [CtLocalVariableImpl][CtTypeReferenceImpl]int side = [CtUnaryOperatorImpl]-[CtLiteralImpl]1;
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int dir = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]dir < [CtLiteralImpl]6; [CtUnaryOperatorImpl][CtVariableWriteImpl]dir++) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]thrust = [CtInvocationImpl]getVector([CtVariableReadImpl]dir);
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]thrust == [CtLiteralImpl]0) [CtBlockImpl]{
                [CtContinueImpl]continue;
            }
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]thrust > [CtVariableReadImpl]high) [CtBlockImpl]{
                [CtAssignmentImpl][CtVariableWriteImpl]high = [CtVariableReadImpl]thrust;
                [CtAssignmentImpl][CtVariableWriteImpl]side = [CtInvocationImpl]sideTable([CtVariableReadImpl]attackPos, [CtVariableReadImpl]usePrior, [CtVariableReadImpl]dir);
            }
            [CtIfImpl][CtCommentImpl]// what if they tie
            if ([CtBinaryOperatorImpl][CtVariableReadImpl]thrust == [CtVariableReadImpl]high) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]int newside = [CtInvocationImpl]sideTable([CtVariableReadImpl]attackPos, [CtVariableReadImpl]usePrior, [CtVariableReadImpl]dir);
                [CtIfImpl][CtCommentImpl]// choose the best
                if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]newside == [CtFieldReadImpl]ToHitData.SIDE_LEFT) || [CtBinaryOperatorImpl]([CtVariableReadImpl]newside == [CtFieldReadImpl]ToHitData.SIDE_RIGHT)) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]newside = [CtVariableReadImpl]side;
                }
                [CtCommentImpl]// that should be the only case, because it can't shift you from
                [CtCommentImpl]// front
                [CtCommentImpl]// to aft or vice-versa
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]side;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * return the heading of the unit based on its active vectors if vectors are
     * tied then return two headings
     */
    public [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]java.lang.Integer> getHeading() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]java.lang.Integer> heading = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]java.lang.Integer>();
        [CtLocalVariableImpl][CtTypeReferenceImpl]int high = [CtLiteralImpl]0;
        [CtLocalVariableImpl][CtTypeReferenceImpl]int curDir = [CtInvocationImpl]getFacing();
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int dir = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]dir < [CtLiteralImpl]6; [CtUnaryOperatorImpl][CtVariableWriteImpl]dir++) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]int thrust = [CtInvocationImpl]getVector([CtVariableReadImpl]dir);
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]thrust >= [CtVariableReadImpl]high) && [CtBinaryOperatorImpl]([CtVariableReadImpl]thrust > [CtLiteralImpl]0)) [CtBlockImpl]{
                [CtIfImpl][CtCommentImpl]// if they were equal then add the last direction to the
                [CtCommentImpl]// vector before moving on
                if ([CtBinaryOperatorImpl][CtVariableReadImpl]thrust == [CtVariableReadImpl]high) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]heading.addElement([CtVariableReadImpl]curDir);
                }
                [CtAssignmentImpl][CtVariableWriteImpl]high = [CtInvocationImpl]getVector([CtVariableReadImpl]dir);
                [CtAssignmentImpl][CtVariableWriteImpl]curDir = [CtVariableReadImpl]dir;
            }
        }
        [CtInvocationImpl][CtVariableReadImpl]heading.addElement([CtVariableReadImpl]curDir);
        [CtReturnImpl]return [CtVariableReadImpl]heading;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setPlayerPickedPassThrough([CtParameterImpl][CtTypeReferenceImpl]int attackerId, [CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords c) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]playerPickedPassThrough == [CtLiteralImpl]null) [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl]playerPickedPassThrough = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.HashMap<>();
        }
        [CtInvocationImpl][CtFieldReadImpl]playerPickedPassThrough.put([CtVariableReadImpl]attackerId, [CtVariableReadImpl]c);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]megamek.common.Coords getPlayerPickedPassThrough([CtParameterImpl][CtTypeReferenceImpl]int attackerId) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]playerPickedPassThrough == [CtLiteralImpl]null) [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl]playerPickedPassThrough = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.HashMap<>();
        }
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]playerPickedPassThrough.get([CtVariableReadImpl]attackerId);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setPassedThrough([CtParameterImpl][CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Coords> pass) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]passedThrough = [CtVariableReadImpl]pass;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Coords> getPassedThrough() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]passedThrough;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setPassedThroughFacing([CtParameterImpl][CtTypeReferenceImpl]java.util.List<[CtTypeReferenceImpl]java.lang.Integer> passFacing) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]passedThroughFacing = [CtVariableReadImpl]passFacing;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.util.List<[CtTypeReferenceImpl]java.lang.Integer> getPassedThroughFacing() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]passedThroughFacing;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void addPassedThrough([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords c) [CtBlockImpl]{
        [CtInvocationImpl][CtFieldReadImpl]passedThrough.add([CtVariableReadImpl]c);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Method that determines if this Entity passed over another entity during
     * its current path
     *
     * @param t
     * @return  */
    public [CtTypeReferenceImpl]boolean passedOver([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Targetable t) [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Coords crd : [CtFieldReadImpl]passedThrough) [CtBlockImpl]{
            [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]crd.equals([CtInvocationImpl][CtVariableReadImpl]t.getPosition())) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
            [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Coords secondary : [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]t.getSecondaryPositions().values()) [CtBlockImpl]{
                [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]crd.equals([CtVariableReadImpl]secondary)) [CtBlockImpl]{
                    [CtReturnImpl]return [CtLiteralImpl]true;
                }
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean passedThrough([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords c) [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Coords crd : [CtFieldReadImpl]passedThrough) [CtBlockImpl]{
            [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]crd.equals([CtVariableReadImpl]c)) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Did the entity pass within a certain number of hexes of these coords?
     */
    public [CtTypeReferenceImpl]boolean passedWithin([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords c, [CtParameterImpl][CtTypeReferenceImpl]int dist) [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Coords crd : [CtFieldReadImpl]passedThrough) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]crd.distance([CtVariableReadImpl]c) <= [CtVariableReadImpl]dist) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * What coords were passed through previous to the given one
     */
    public [CtTypeReferenceImpl]megamek.common.Coords passedThroughPrevious([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords c) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtFieldReadImpl]passedThrough.size() == [CtLiteralImpl]0) [CtBlockImpl]{
            [CtReturnImpl]return [CtInvocationImpl]getPosition();
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Coords prevCrd = [CtInvocationImpl][CtFieldReadImpl]passedThrough.get([CtLiteralImpl]0);
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Coords crd : [CtFieldReadImpl]passedThrough) [CtBlockImpl]{
            [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]crd.equals([CtVariableReadImpl]c)) [CtBlockImpl]{
                [CtBreakImpl]break;
            }
            [CtAssignmentImpl][CtVariableWriteImpl]prevCrd = [CtVariableReadImpl]crd;
        }
        [CtReturnImpl]return [CtVariableReadImpl]prevCrd;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setRamming([CtParameterImpl][CtTypeReferenceImpl]boolean b) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]ramming = [CtVariableReadImpl]b;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isRamming() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]ramming;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void resetFiringArcs() [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]frontArcFired = [CtNewArrayImpl]new [CtTypeReferenceImpl]boolean[[CtInvocationImpl]locations()];
        [CtAssignmentImpl][CtFieldWriteImpl]rearArcFired = [CtNewArrayImpl]new [CtTypeReferenceImpl]boolean[[CtInvocationImpl]locations()];
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtInvocationImpl]locations(); [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtAssignmentImpl][CtArrayWriteImpl][CtFieldReadImpl]frontArcFired[[CtVariableReadImpl]i] = [CtLiteralImpl]false;
            [CtAssignmentImpl][CtArrayWriteImpl][CtFieldReadImpl]rearArcFired[[CtVariableReadImpl]i] = [CtLiteralImpl]false;
        }
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean hasArcFired([CtParameterImpl][CtTypeReferenceImpl]int location, [CtParameterImpl][CtTypeReferenceImpl]boolean rearMount) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtLiteralImpl]null == [CtFieldReadImpl]frontArcFired) || [CtBinaryOperatorImpl]([CtLiteralImpl]null == [CtFieldReadImpl]rearArcFired)) [CtBlockImpl]{
            [CtInvocationImpl]resetFiringArcs();
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]location > [CtInvocationImpl]locations()) || [CtBinaryOperatorImpl]([CtVariableReadImpl]location < [CtLiteralImpl]0)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl]if ([CtVariableReadImpl]rearMount) [CtBlockImpl]{
            [CtReturnImpl]return [CtArrayReadImpl][CtFieldReadImpl]rearArcFired[[CtVariableReadImpl]location];
        }
        [CtReturnImpl]return [CtArrayReadImpl][CtFieldReadImpl]frontArcFired[[CtVariableReadImpl]location];
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setArcFired([CtParameterImpl][CtTypeReferenceImpl]int location, [CtParameterImpl][CtTypeReferenceImpl]boolean rearMount) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtLiteralImpl]null == [CtFieldReadImpl]frontArcFired) || [CtBinaryOperatorImpl]([CtLiteralImpl]null == [CtFieldReadImpl]rearArcFired)) [CtBlockImpl]{
            [CtInvocationImpl]resetFiringArcs();
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]location > [CtInvocationImpl]locations()) || [CtBinaryOperatorImpl]([CtVariableReadImpl]location < [CtLiteralImpl]0)) [CtBlockImpl]{
            [CtReturnImpl]return;
        }
        [CtIfImpl]if ([CtVariableReadImpl]rearMount) [CtBlockImpl]{
            [CtAssignmentImpl][CtArrayWriteImpl][CtFieldReadImpl]rearArcFired[[CtVariableReadImpl]location] = [CtLiteralImpl]true;
        } else [CtBlockImpl]{
            [CtAssignmentImpl][CtArrayWriteImpl][CtFieldReadImpl]frontArcFired[[CtVariableReadImpl]location] = [CtLiteralImpl]true;
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Force rapid fire mode to the highest level on RAC and UAC - this is for
     * aeros
     */
    public [CtTypeReferenceImpl]void setRapidFire() [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getTotalWeaponList()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.WeaponType wtype = [CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.WeaponType) ([CtVariableReadImpl]m.getType()));
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]wtype.getAmmoType() == [CtFieldReadImpl]AmmoType.T_AC_ROTARY) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]m.setMode([CtLiteralImpl]"6-shot");
                [CtInvocationImpl][CtVariableReadImpl]m.setModeSwitchable([CtLiteralImpl]false);
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]wtype.getAmmoType() == [CtFieldReadImpl]AmmoType.T_AC_ULTRA) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]m.setMode([CtLiteralImpl]"Ultra");
                [CtInvocationImpl][CtVariableReadImpl]m.setModeSwitchable([CtLiteralImpl]false);
            }
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Set the retractable blade in the given location as extended Takes the
     * first piece of appropriate equipment
     */
    public [CtTypeReferenceImpl]void extendBlade([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getEquipment()) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getLocation() == [CtVariableReadImpl]loc) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]m.isDestroyed())) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]m.isBreached())) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.MiscType)) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_CLUB)) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasSubType([CtTypeAccessImpl]MiscType.S_RETRACTABLE_BLADE)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]m.setMode([CtLiteralImpl]"extended");
                [CtReturnImpl]return;
            }
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * destroys the first retractable blade critical slot found
     */
    public [CtTypeReferenceImpl]void destroyRetractableBlade([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtForImpl][CtCommentImpl]// check critical slots
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtInvocationImpl][CtThisAccessImpl]this.getNumberOfCriticals([CtVariableReadImpl]loc); [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.CriticalSlot slot = [CtInvocationImpl]getCritical([CtVariableReadImpl]loc, [CtVariableReadImpl]i);
            [CtIfImpl][CtCommentImpl]// ignore empty & system slots
            if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]slot == [CtLiteralImpl]null) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]slot.getType() != [CtFieldReadImpl]CriticalSlot.TYPE_EQUIPMENT)) [CtBlockImpl]{
                [CtContinueImpl]continue;
            }
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m = [CtInvocationImpl][CtVariableReadImpl]slot.getMount();
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getLocation() == [CtVariableReadImpl]loc) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]m.isHit())) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]m.isBreached())) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.MiscType)) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_CLUB)) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasSubType([CtTypeAccessImpl]MiscType.S_RETRACTABLE_BLADE)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]slot.setHit([CtLiteralImpl]true);
                [CtInvocationImpl][CtVariableReadImpl]m.setHit([CtLiteralImpl]true);
                [CtReturnImpl]return;
            }
        }
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]megamek.common.TeleMissileTracker getTMTracker() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]tmTracker;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setGrappled([CtParameterImpl][CtTypeReferenceImpl]int id, [CtParameterImpl][CtTypeReferenceImpl]boolean attacker) [CtBlockImpl]{
        [CtCommentImpl]// This is implemented in subclasses.  Do nothing in general.
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isGrappleAttacker() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getGrappled() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isChainWhipGrappled() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtInvocationImpl]getGrappleSide() != [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]GRAPPLE_BOTH;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isGrappledThisRound() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setGrappledThisRound([CtParameterImpl][CtTypeReferenceImpl]boolean grappled) [CtBlockImpl]{
        [CtCommentImpl]// Do nothing here, set in base classes
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setGameOptions() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]game == [CtLiteralImpl]null) [CtBlockImpl]{
            [CtReturnImpl]return;
        }
        [CtLocalVariableImpl]final [CtTypeReferenceImpl]megamek.common.options.GameOptions gameOpts = [CtInvocationImpl][CtFieldReadImpl]game.getOptions();
        [CtIfImpl][CtCommentImpl]// if the small craft does not already have ECM, then give them a single
        [CtCommentImpl]// hex ECM so they can change the mode
        [CtCommentImpl]// FIXME: This is a really hacky way to to do it that results in small
        [CtCommentImpl]// craft having
        [CtCommentImpl]// ECM when the rule is not in effect and in non-space maps
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.SmallCraft) && [CtUnaryOperatorImpl](![CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Dropship))) && [CtUnaryOperatorImpl](![CtInvocationImpl]hasActiveECM())) && [CtInvocationImpl]isMilitary()) [CtBlockImpl]{
            [CtTryImpl]try [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]java.lang.String prefix = [CtConditionalImpl]([CtInvocationImpl]isClan()) ? [CtLiteralImpl]"CL" : [CtLiteralImpl]"IS";
                [CtInvocationImpl][CtThisAccessImpl]this.addEquipment([CtInvocationImpl][CtTypeAccessImpl]megamek.common.EquipmentType.get([CtBinaryOperatorImpl][CtVariableReadImpl]prefix + [CtFieldReadImpl]BattleArmor.SINGLE_HEX_ECM), [CtTypeAccessImpl]Aero.LOC_NOSE, [CtLiteralImpl]false);
            }[CtCatchImpl] catch ([CtCatchVariableImpl][CtTypeReferenceImpl]megamek.common.LocationFullException ex) [CtBlockImpl]{
                [CtCommentImpl]// ignore
            }
        }
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted : [CtInvocationImpl]getWeaponList()) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.weapons.Weapon)[CtBlockImpl]
                [CtInvocationImpl][CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.weapons.Weapon) ([CtVariableReadImpl]mounted.getType())).adaptToGameOptions([CtInvocationImpl][CtFieldReadImpl]game.getOptions());

            [CtInvocationImpl][CtVariableReadImpl]mounted.setModesForMapType();
        }
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted misc : [CtInvocationImpl]getMisc()) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]misc.getType().hasFlag([CtTypeAccessImpl]MiscType.F_BAP) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Aero) || [CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.LandAirMech))) && [CtInvocationImpl][CtVariableReadImpl]gameOpts.booleanOption([CtTypeAccessImpl]OptionsConstants.ADVAERORULES_STRATOPS_ECM)) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]java.lang.String> modes = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]java.lang.String>();
                [CtLocalVariableImpl][CtArrayTypeReferenceImpl]java.lang.String[] stringArray = [CtNewArrayImpl]new java.lang.String[]{  };
                [CtInvocationImpl][CtVariableReadImpl]modes.add([CtLiteralImpl]"Short");
                [CtInvocationImpl][CtVariableReadImpl]modes.add([CtLiteralImpl]"Medium");
                [CtInvocationImpl][CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.MiscType) ([CtVariableReadImpl]misc.getType())).setModes([CtInvocationImpl][CtVariableReadImpl]modes.toArray([CtVariableReadImpl]stringArray));
                [CtInvocationImpl][CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.MiscType) ([CtVariableReadImpl]misc.getType())).setInstantModeSwitch([CtLiteralImpl]false);
            }
            [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]misc.getType().hasFlag([CtTypeAccessImpl]MiscType.F_ECM)) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]java.lang.String> modes = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]java.lang.String>();
                [CtInvocationImpl][CtVariableReadImpl]modes.add([CtLiteralImpl]"ECM");
                [CtLocalVariableImpl][CtArrayTypeReferenceImpl]java.lang.String[] stringArray = [CtNewArrayImpl]new java.lang.String[]{  };
                [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]gameOpts.booleanOption([CtTypeAccessImpl]OptionsConstants.ADVANCED_TACOPS_ECCM)) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]modes.add([CtLiteralImpl]"ECCM");
                    [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]misc.getType().hasFlag([CtTypeAccessImpl]MiscType.F_ANGEL_ECM)) [CtBlockImpl]{
                        [CtInvocationImpl][CtVariableReadImpl]modes.add([CtLiteralImpl]"ECM & ECCM");
                    }
                } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]gameOpts.booleanOption([CtTypeAccessImpl]OptionsConstants.ADVAERORULES_STRATOPS_ECM) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Aero) || [CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.LandAirMech))) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]modes.add([CtLiteralImpl]"ECCM");
                    [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]misc.getType().hasFlag([CtTypeAccessImpl]MiscType.F_ANGEL_ECM)) [CtBlockImpl]{
                        [CtInvocationImpl][CtVariableReadImpl]modes.add([CtLiteralImpl]"ECM & ECCM");
                    }
                }
                [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]gameOpts.booleanOption([CtTypeAccessImpl]OptionsConstants.ADVANCED_TACOPS_GHOST_TARGET)) [CtBlockImpl]{
                    [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]misc.getType().hasFlag([CtTypeAccessImpl]MiscType.F_ANGEL_ECM)) [CtBlockImpl]{
                        [CtInvocationImpl][CtVariableReadImpl]modes.add([CtLiteralImpl]"ECM & Ghost Targets");
                        [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]gameOpts.booleanOption([CtTypeAccessImpl]OptionsConstants.ADVANCED_TACOPS_ECCM)) [CtBlockImpl]{
                            [CtInvocationImpl][CtVariableReadImpl]modes.add([CtLiteralImpl]"ECCM & Ghost Targets");
                        }
                    } else [CtBlockImpl]{
                        [CtInvocationImpl][CtVariableReadImpl]modes.add([CtLiteralImpl]"Ghost Targets");
                    }
                }
                [CtInvocationImpl][CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.MiscType) ([CtVariableReadImpl]misc.getType())).setModes([CtInvocationImpl][CtVariableReadImpl]modes.toArray([CtVariableReadImpl]stringArray));
            }
        }
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setGrappleSide([CtParameterImpl][CtTypeReferenceImpl]int side) [CtBlockImpl]{
        [CtCommentImpl]// This is implemented in subclasses, do nothing in general
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getGrappleSide() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean hasFunctionalArmAES([CtParameterImpl][CtTypeReferenceImpl]int location) [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean hasFunctionalLegAES() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isEvading() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]evading;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setEvading([CtParameterImpl][CtTypeReferenceImpl]boolean evasion) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]evading = [CtVariableReadImpl]evasion;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getEvasionBonus() [CtBlockImpl]{
        [CtIfImpl]if ([CtInvocationImpl]isProne()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]0;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.SmallCraft) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]2;
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Jumpship) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]1;
        } else [CtIfImpl]if ([CtInvocationImpl]isAero()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]3;
        } else [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVGRNDMOV_TACOPS_SKILLED_EVASION)) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]int piloting = [CtInvocationImpl][CtFieldReadImpl]crew.getPiloting();
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]piloting < [CtLiteralImpl]2) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]3;
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]piloting < [CtLiteralImpl]4) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]2;
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]piloting < [CtLiteralImpl]6) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]1;
            }
        } else [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]1;
        }
        [CtReturnImpl]return [CtLiteralImpl]0;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setCarefulStand([CtParameterImpl][CtTypeReferenceImpl]boolean stand) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]isCarefulStanding = [CtVariableReadImpl]stand;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isCarefulStand() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Sensor> getSensors() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]sensors;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]megamek.common.Sensor getActiveSensor() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]activeSensor;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]megamek.common.Sensor getNextSensor() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]nextSensor;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setNextSensor([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Sensor s) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]nextSensor = [CtVariableReadImpl]s;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getSensorCheck() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]sensorCheck;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * A method to determine if an aero has suffered 3 sensor hits.
     * When double-blind is on, this affects both standard visibility and sensor rolls
     */
    public [CtTypeReferenceImpl]boolean isAeroSensorDestroyed() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean hasModularArmor() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]hasModularArmor([CtUnaryOperatorImpl]-[CtLiteralImpl]1);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean hasModularArmor([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted mount : [CtInvocationImpl][CtThisAccessImpl]this.getEquipment()) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]loc == [CtUnaryOperatorImpl](-[CtLiteralImpl]1)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]mount.getLocation() == [CtVariableReadImpl]loc)) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]mount.isDestroyed()) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]mount.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.MiscType)) && [CtInvocationImpl][CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.MiscType) ([CtVariableReadImpl]mount.getType())).hasFlag([CtTypeAccessImpl]MiscType.F_MODULAR_ARMOR)) [CtBlockImpl]{
                    [CtReturnImpl]return [CtLiteralImpl]true;
                }
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getDamageReductionFromModularArmor([CtParameterImpl][CtTypeReferenceImpl]megamek.common.HitData hit, [CtParameterImpl][CtTypeReferenceImpl]int damage, [CtParameterImpl][CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Report> vDesc) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int loc = [CtInvocationImpl][CtVariableReadImpl]hit.getLocation();
        [CtIfImpl]if ([CtUnaryOperatorImpl]![CtInvocationImpl]hasModularArmor([CtVariableReadImpl]loc)) [CtBlockImpl]{
            [CtReturnImpl]return [CtVariableReadImpl]damage;
        }
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted mount : [CtInvocationImpl][CtThisAccessImpl]this.getEquipment()) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]mount.getLocation() == [CtVariableReadImpl]loc) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]mount.isDestroyed())) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]mount.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.MiscType)) && [CtInvocationImpl][CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.MiscType) ([CtVariableReadImpl]mount.getType())).hasFlag([CtTypeAccessImpl]MiscType.F_MODULAR_ARMOR)) && [CtBinaryOperatorImpl][CtCommentImpl]// On 'Mech torsos only, modular armor covers either front
            [CtCommentImpl]// or rear, as mounted.
            ([CtBinaryOperatorImpl]([CtUnaryOperatorImpl](![CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Mech)) || [CtUnaryOperatorImpl](![CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]loc == [CtFieldReadImpl]Mech.LOC_CT) || [CtBinaryOperatorImpl]([CtVariableReadImpl]loc == [CtFieldReadImpl]Mech.LOC_LT)) || [CtBinaryOperatorImpl]([CtVariableReadImpl]loc == [CtFieldReadImpl]Mech.LOC_RT)))) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]hit.isRear() == [CtInvocationImpl][CtVariableReadImpl]mount.isRearMounted()))) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]int damageAbsorption = [CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]mount.getBaseDamageCapacity() - [CtInvocationImpl][CtVariableReadImpl]mount.getDamageTaken();
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]damageAbsorption > [CtVariableReadImpl]damage) [CtBlockImpl]{
                    [CtOperatorAssignmentImpl][CtFieldWriteImpl][CtVariableWriteImpl]mount.damageTaken += [CtVariableReadImpl]damage;
                    [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Report r = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.Report([CtLiteralImpl]3535);
                    [CtAssignmentImpl][CtFieldWriteImpl][CtVariableWriteImpl]r.subject = [CtInvocationImpl]getId();
                    [CtInvocationImpl][CtVariableReadImpl]r.add([CtVariableReadImpl]damage);
                    [CtInvocationImpl][CtVariableReadImpl]r.indent([CtLiteralImpl]1);
                    [CtAssignmentImpl][CtFieldWriteImpl][CtVariableWriteImpl]r.newlines = [CtLiteralImpl]0;
                    [CtInvocationImpl][CtVariableReadImpl]vDesc.addElement([CtVariableReadImpl]r);
                    [CtInvocationImpl][CtTypeAccessImpl]megamek.common.Report.addNewline([CtVariableReadImpl]vDesc);
                    [CtReturnImpl]return [CtLiteralImpl]0;
                }
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]damageAbsorption == [CtVariableReadImpl]damage) [CtBlockImpl]{
                    [CtInvocationImpl][CtTypeAccessImpl]megamek.common.Report.addNewline([CtVariableReadImpl]vDesc);
                    [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Report r = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.Report([CtLiteralImpl]3535);
                    [CtAssignmentImpl][CtFieldWriteImpl][CtVariableWriteImpl]r.subject = [CtInvocationImpl]getId();
                    [CtInvocationImpl][CtVariableReadImpl]r.add([CtVariableReadImpl]damage);
                    [CtInvocationImpl][CtVariableReadImpl]r.indent([CtLiteralImpl]1);
                    [CtAssignmentImpl][CtFieldWriteImpl][CtVariableWriteImpl]r.newlines = [CtLiteralImpl]0;
                    [CtInvocationImpl][CtVariableReadImpl]vDesc.addElement([CtVariableReadImpl]r);
                    [CtAssignmentImpl][CtVariableWriteImpl]r = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.Report([CtLiteralImpl]3536);
                    [CtAssignmentImpl][CtFieldWriteImpl][CtVariableWriteImpl]r.subject = [CtInvocationImpl]getId();
                    [CtInvocationImpl][CtVariableReadImpl]r.indent();
                    [CtInvocationImpl][CtVariableReadImpl]vDesc.addElement([CtVariableReadImpl]r);
                    [CtOperatorAssignmentImpl][CtFieldWriteImpl][CtVariableWriteImpl]mount.damageTaken += [CtVariableReadImpl]damage;
                    [CtInvocationImpl][CtVariableReadImpl]mount.setHit([CtLiteralImpl]true);
                    [CtReturnImpl]return [CtLiteralImpl]0;
                }
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]damageAbsorption < [CtVariableReadImpl]damage) [CtBlockImpl]{
                    [CtInvocationImpl][CtTypeAccessImpl]megamek.common.Report.addNewline([CtVariableReadImpl]vDesc);
                    [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Report r = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.Report([CtLiteralImpl]3535);
                    [CtAssignmentImpl][CtFieldWriteImpl][CtVariableWriteImpl]r.subject = [CtInvocationImpl]getId();
                    [CtInvocationImpl][CtVariableReadImpl]r.add([CtVariableReadImpl]damageAbsorption);
                    [CtInvocationImpl][CtVariableReadImpl]r.indent([CtLiteralImpl]1);
                    [CtAssignmentImpl][CtFieldWriteImpl][CtVariableWriteImpl]r.newlines = [CtLiteralImpl]0;
                    [CtInvocationImpl][CtVariableReadImpl]vDesc.addElement([CtVariableReadImpl]r);
                    [CtAssignmentImpl][CtVariableWriteImpl]r = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.Report([CtLiteralImpl]3536);
                    [CtAssignmentImpl][CtFieldWriteImpl][CtVariableWriteImpl]r.subject = [CtInvocationImpl]getId();
                    [CtInvocationImpl][CtVariableReadImpl]r.indent([CtLiteralImpl]1);
                    [CtInvocationImpl][CtVariableReadImpl]vDesc.addElement([CtVariableReadImpl]r);
                    [CtOperatorAssignmentImpl][CtVariableWriteImpl]damage -= [CtBinaryOperatorImpl][CtFieldReadImpl][CtVariableReadImpl]mount.baseDamageAbsorptionRate - [CtFieldReadImpl][CtVariableReadImpl]mount.damageTaken;
                    [CtAssignmentImpl][CtFieldWriteImpl][CtVariableWriteImpl]mount.damageTaken = [CtFieldReadImpl][CtVariableReadImpl]mount.baseDamageAbsorptionRate;
                    [CtInvocationImpl][CtVariableReadImpl]mount.setDestroyed([CtLiteralImpl]true);
                    [CtInvocationImpl][CtVariableReadImpl]mount.setHit([CtLiteralImpl]true);
                }
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]damage;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getGhostTargetRoll() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]ghostTargetRoll;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getGhostTargetRollMoS() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtFieldReadImpl]ghostTargetRoll - [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl]getCrew().getSensorOps() + [CtLiteralImpl]2);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getGhostTargetOverride() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]ghostTargetOverride;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getCoolantFailureAmount() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]0;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void addCoolantFailureAmount([CtParameterImpl][CtTypeReferenceImpl]int amount) [CtBlockImpl]{
        [CtCommentImpl]// This is implemented in subclasses, do nothing in general
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void resetCoolantFailureAmount() [CtBlockImpl]{
        [CtCommentImpl]// This is implemented in subclasses, do nothing in general
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @return the tonnage of additional mounted communications equipment
     */
    public [CtTypeReferenceImpl]int getExtraCommGearTons() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0;
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted : [CtFieldReadImpl]miscList) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]mounted.getType().hasFlag([CtTypeAccessImpl]MiscType.F_COMMUNICATIONS) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]mounted.isInoperable())) [CtBlockImpl]{
                [CtOperatorAssignmentImpl][CtVariableWriteImpl]i += [CtInvocationImpl][CtVariableReadImpl]mounted.getTonnage();
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]i;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns information (range, location, strength) about ECM if the unit
     * has active ECM or null if it doesn't.  In the case of multiple ECCM
     * system, the best one takes precendence, as a unit can only have one
     * active ECCM at a time.
     *
     * @return  */
    public [CtTypeReferenceImpl]megamek.common.ECMInfo getECMInfo() [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// If we don't have a position, ECM doesn't have an effect
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]getPosition() == [CtLiteralImpl]null) || [CtInvocationImpl]isShutDown()) || [CtInvocationImpl]isStealthOn()) || [CtBinaryOperatorImpl]([CtInvocationImpl]getTransportId() != [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]null;
        }
        [CtIfImpl][CtCommentImpl]// E(C)CM operates differently in space (SO pg 110)
        if ([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().inSpace()) [CtBlockImpl]{
            [CtIfImpl][CtCommentImpl]// No ECM in space unless SO rule is on
            if ([CtUnaryOperatorImpl]![CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVAERORULES_STRATOPS_ECM)) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]null;
            }
            [CtLocalVariableImpl][CtTypeReferenceImpl]int range = [CtInvocationImpl]getECMRange();
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]range >= [CtLiteralImpl]0) && [CtInvocationImpl]hasActiveECM()) [CtBlockImpl]{
                [CtReturnImpl]return [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.ECMInfo([CtVariableReadImpl]range, [CtLiteralImpl]1, [CtThisAccessImpl]this);
            } else [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]null;
            }
        }
        [CtIfImpl][CtCommentImpl]// ASF ECM only has an effect if the unit is NOE
        if ([CtBinaryOperatorImpl][CtInvocationImpl]isAirborne() && [CtUnaryOperatorImpl](![CtInvocationImpl]isNOE())) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]null;
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.ECMInfo bestInfo = [CtLiteralImpl]null;
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Comparator<[CtTypeReferenceImpl]megamek.common.ECMInfo> ecmComparator;
        [CtAssignmentImpl][CtVariableWriteImpl]ecmComparator = [CtConstructorCallImpl]new [CtTypeReferenceImpl][CtTypeReferenceImpl]megamek.common.ECMInfo.ECCMComparator();
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getMisc()) [CtBlockImpl]{
            [CtIfImpl][CtCommentImpl]// Ignore if inoperable
            if ([CtInvocationImpl][CtVariableReadImpl]m.isInoperable()) [CtBlockImpl]{
                [CtContinueImpl]continue;
            }
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.ECMInfo newInfo = [CtLiteralImpl]null;
            [CtIfImpl][CtCommentImpl]// Angel ECM
            if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_ANGEL_ECM)) [CtBlockImpl]{
                [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"ECM")) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]newInfo = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.ECMInfo([CtLiteralImpl]6, [CtLiteralImpl]0, [CtThisAccessImpl]this);
                    [CtInvocationImpl][CtVariableReadImpl]newInfo.setAngelECMStrength([CtLiteralImpl]1);
                } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"ECM & ECCM") || [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"ECM & Ghost Targets")) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]newInfo = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.ECMInfo([CtLiteralImpl]6, [CtLiteralImpl]1, [CtThisAccessImpl]this);
                    [CtCommentImpl]// Doesn't count as Angel ECM
                }
                [CtIfImpl][CtCommentImpl]// BA Angel ECM has a shorter range
                if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]newInfo != [CtLiteralImpl]null) && [CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.BattleArmor)) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]newInfo.setRange([CtLiteralImpl]2);
                }
                [CtCommentImpl]// Anything that's not Angel ECM
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_ECM) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"ECM")) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]int range = [CtLiteralImpl]6;
                [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_SINGLE_HEX_ECM)) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]range = [CtLiteralImpl]0;
                } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_EW_EQUIPMENT) || [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_NOVA)) || [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_WATCHDOG)) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]range = [CtLiteralImpl]3;
                }
                [CtAssignmentImpl][CtVariableWriteImpl]newInfo = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.ECMInfo([CtVariableReadImpl]range, [CtLiteralImpl]1, [CtThisAccessImpl]this);
                [CtInvocationImpl][CtVariableReadImpl]newInfo.setECMNova([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_NOVA));
            }
            [CtIfImpl][CtCommentImpl]// In some type of ECM mode...
            if ([CtBinaryOperatorImpl][CtVariableReadImpl]newInfo != [CtLiteralImpl]null) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]bestInfo == [CtLiteralImpl]null) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]ecmComparator.compare([CtVariableReadImpl]newInfo, [CtVariableReadImpl]bestInfo) > [CtLiteralImpl]0)) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]bestInfo = [CtVariableReadImpl]newInfo;
                }
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]bestInfo;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns information (range, location, strength) about ECCM if the unit
     * has active ECCM or null if it doesn't.  In the case of multiple ECCM
     * system, the best one takes precendence, as a unit can only have one
     * active ECCM at a time.
     *
     * @return  */
    public [CtTypeReferenceImpl]megamek.common.ECMInfo getECCMInfo() [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// If we don't have a position, ECM doesn't have an effect
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]getPosition() == [CtLiteralImpl]null) || [CtInvocationImpl]isShutDown()) || [CtInvocationImpl]isStealthOn()) || [CtBinaryOperatorImpl]([CtInvocationImpl]getTransportId() != [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]null;
        }
        [CtIfImpl][CtCommentImpl]// E(C)CM operates differently in space (SO pg 110)
        if ([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().inSpace()) [CtBlockImpl]{
            [CtIfImpl][CtCommentImpl]// No ECCM in space unless SO rule is on
            if ([CtUnaryOperatorImpl]![CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVAERORULES_STRATOPS_ECM)) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]null;
            }
            [CtLocalVariableImpl][CtTypeReferenceImpl]int bapRange = [CtInvocationImpl]getBAPRange();
            [CtLocalVariableImpl][CtTypeReferenceImpl]int range = [CtInvocationImpl]getECMRange();
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.ECMInfo eccmInfo = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.ECMInfo([CtLiteralImpl]0, [CtLiteralImpl]0, [CtThisAccessImpl]this);
            [CtInvocationImpl][CtVariableReadImpl]eccmInfo.setECCMStrength([CtLiteralImpl]1);
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]bapRange > [CtLiteralImpl]0) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]eccmInfo.setRange([CtVariableReadImpl]bapRange);
                [CtIfImpl][CtCommentImpl]// Medium range band only effects the nose, so set direction
                if ([CtBinaryOperatorImpl][CtVariableReadImpl]bapRange > [CtLiteralImpl]6) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]eccmInfo.setDirection([CtInvocationImpl]getFacing());
                }
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]range >= [CtLiteralImpl]0) && [CtInvocationImpl]hasActiveECCM()) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]eccmInfo.setRange([CtVariableReadImpl]range);
            } else [CtBlockImpl]{
                [CtAssignmentImpl][CtVariableWriteImpl]eccmInfo = [CtLiteralImpl]null;
            }
            [CtReturnImpl]return [CtVariableReadImpl]eccmInfo;
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.ECMInfo bestInfo = [CtLiteralImpl]null;
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Comparator<[CtTypeReferenceImpl]megamek.common.ECMInfo> ecmComparator;
        [CtAssignmentImpl][CtVariableWriteImpl]ecmComparator = [CtConstructorCallImpl]new [CtTypeReferenceImpl][CtTypeReferenceImpl]megamek.common.ECMInfo.ECCMComparator();
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getMisc()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.ECMInfo newInfo = [CtLiteralImpl]null;
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_COMMUNICATIONS) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"ECCM")) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]getTotalCommGearTons() > [CtLiteralImpl]3) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]newInfo = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.ECMInfo([CtLiteralImpl]6, [CtLiteralImpl]0.5, [CtThisAccessImpl]this);
                }
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]getTotalCommGearTons() > [CtLiteralImpl]6) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]newInfo = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.ECMInfo([CtLiteralImpl]6, [CtLiteralImpl]1, [CtThisAccessImpl]this);
                }
            }
            [CtIfImpl][CtCommentImpl]// Angel ECM
            if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_ANGEL_ECM)) [CtBlockImpl]{
                [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"ECCM")) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]newInfo = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.ECMInfo([CtLiteralImpl]6, [CtLiteralImpl]0, [CtThisAccessImpl]this);
                    [CtInvocationImpl][CtVariableReadImpl]newInfo.setAngelECCMStrength([CtLiteralImpl]1);
                } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"ECM & ECCM") || [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"ECCM & Ghost Targets")) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]newInfo = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.ECMInfo([CtLiteralImpl]6, [CtLiteralImpl]1, [CtThisAccessImpl]this);
                    [CtCommentImpl]// Doesn't count as Angel
                }
                [CtIfImpl][CtCommentImpl]// BA Angel ECM has a shorter range
                if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]newInfo != [CtLiteralImpl]null) && [CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.BattleArmor)) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]newInfo.setRange([CtLiteralImpl]2);
                }
                [CtCommentImpl]// Anything that's not Angel ECM
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_ECM) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"ECCM")) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]int range = [CtLiteralImpl]6;
                [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_SINGLE_HEX_ECM)) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]range = [CtLiteralImpl]0;
                } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_EW_EQUIPMENT) || [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_NOVA)) || [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_WATCHDOG)) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]range = [CtLiteralImpl]3;
                }
                [CtAssignmentImpl][CtVariableWriteImpl]newInfo = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.ECMInfo([CtVariableReadImpl]range, [CtLiteralImpl]0, [CtThisAccessImpl]this);
                [CtInvocationImpl][CtVariableReadImpl]newInfo.setECCMStrength([CtLiteralImpl]1);
            }
            [CtIfImpl][CtCommentImpl]// In some type of ECCM mode...
            if ([CtBinaryOperatorImpl][CtVariableReadImpl]newInfo != [CtLiteralImpl]null) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]bestInfo == [CtLiteralImpl]null) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]ecmComparator.compare([CtVariableReadImpl]newInfo, [CtVariableReadImpl]bestInfo) > [CtLiteralImpl]0)) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]bestInfo = [CtVariableReadImpl]newInfo;
                }
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]bestInfo;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @return the strength of the ECM field this unit emits
     */
    public [CtTypeReferenceImpl]double getECMStrength() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int strength = [CtLiteralImpl]0;
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getMisc()) [CtBlockImpl]{
            [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_ANGEL_ECM)) [CtBlockImpl]{
                [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"ECM")) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]strength = [CtLiteralImpl]2;
                } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]strength < [CtLiteralImpl]1) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"ECM & ECCM") || [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"ECM & Ghost Targets"))) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]strength = [CtLiteralImpl]1;
                }
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_ECM) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"ECM")) && [CtBinaryOperatorImpl]([CtVariableReadImpl]strength < [CtLiteralImpl]1)) [CtBlockImpl]{
                [CtAssignmentImpl][CtVariableWriteImpl]strength = [CtLiteralImpl]1;
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]strength;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @return the strength of the ECCM field this unit emits
     */
    public [CtTypeReferenceImpl]double getECCMStrength() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]double strength = [CtLiteralImpl]0;
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getMisc()) [CtBlockImpl]{
            [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_COMMUNICATIONS)) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl]getTotalCommGearTons() > [CtLiteralImpl]3) && [CtBinaryOperatorImpl]([CtVariableReadImpl]strength < [CtLiteralImpl]0.5)) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]strength = [CtLiteralImpl]0.5;
                }
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl]getTotalCommGearTons() > [CtLiteralImpl]6) && [CtBinaryOperatorImpl]([CtVariableReadImpl]strength < [CtLiteralImpl]1)) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]strength = [CtLiteralImpl]1;
                }
            }
            [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_ANGEL_ECM)) [CtBlockImpl]{
                [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"ECM")) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]strength = [CtLiteralImpl]2;
                } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]strength < [CtLiteralImpl]1) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"ECM & ECCM") || [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"ECCM & Ghost Targets"))) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]strength = [CtLiteralImpl]1;
                }
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_ECM) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"ECCM")) && [CtBinaryOperatorImpl]([CtVariableReadImpl]strength < [CtLiteralImpl]1)) [CtBlockImpl]{
                [CtAssignmentImpl][CtVariableWriteImpl]strength = [CtLiteralImpl]1;
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]strength;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @return the total tonnage of communications gear in this entity
     */
    public abstract [CtTypeReferenceImpl]int getTotalCommGearTons();

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @return the initiative bonus this Entity grants for HQ
     */
    public [CtTypeReferenceImpl]int getHQIniBonus() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int bonus = [CtLiteralImpl]0;
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted misc : [CtInvocationImpl]getMisc()) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]misc.getType().hasFlag([CtTypeAccessImpl]MiscType.F_COMMUNICATIONS) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]misc.curMode().equals([CtLiteralImpl]"Default")) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]misc.isInoperable())) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]getTotalCommGearTons() >= [CtLiteralImpl]3) [CtBlockImpl]{
                    [CtOperatorAssignmentImpl][CtVariableWriteImpl]bonus += [CtLiteralImpl]1;
                }
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]getTotalCommGearTons() >= [CtLiteralImpl]7) [CtBlockImpl]{
                    [CtOperatorAssignmentImpl][CtVariableWriteImpl]bonus += [CtLiteralImpl]1;
                }
                [CtBreakImpl]break;
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]bonus;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @return the initiative bonus this Entity grants for MD implants
     */
    [CtCommentImpl]/* This has been removed in IO see pg 78

    public int getMDIniBonus() { if
    (crew.getOptions().booleanOption(OptionsConstants.MD_COMM_IMPLANT) ||
    crew.getOptions().booleanOption(OptionsConstants.MD_BOOST_COMM_IMPLANT))
    { return 1; } return 0; }
     */
    [CtJavaDocImpl]/**
     *
     * @return the initiative bonus this Entity grants for quirks
     */
    public [CtTypeReferenceImpl]int getQuirkIniBonus() [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// command battlemech and and battle computer are not cumulative
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl]hasQuirk([CtTypeAccessImpl]OptionsConstants.QUIRK_POS_BATTLE_COMP) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl]getCrew().isDead())) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl]getCrew().isUnconscious())) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]2;
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl]hasQuirk([CtTypeAccessImpl]OptionsConstants.QUIRK_POS_COMMAND_MECH) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl]getCrew().isDead())) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl]getCrew().isUnconscious())) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]1;
        }
        [CtReturnImpl]return [CtLiteralImpl]0;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * get the bay that ammo is associated with
     *
     * @param mammo
     * @return  */
    public [CtTypeReferenceImpl]megamek.common.Mounted getBayByAmmo([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Mounted mammo) [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getWeaponBayList()) [CtBlockImpl]{
            [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int bayAmmoId : [CtInvocationImpl][CtVariableReadImpl]m.getBayAmmo()) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted bayammo = [CtInvocationImpl]getEquipment([CtVariableReadImpl]bayAmmoId);
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]bayammo == [CtVariableReadImpl]mammo) [CtBlockImpl]{
                    [CtReturnImpl]return [CtVariableReadImpl]m;
                }
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]null;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Return how many BA vibroclaws this <code>Entity</code> is equipped with
     */
    public [CtTypeReferenceImpl]int getVibroClaws() [CtBlockImpl]{
        [CtReturnImpl][CtCommentImpl]// generic entities can't carry vibroclaws
        return [CtLiteralImpl]0;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * shut this unit down due to a Taser attack
     *
     * @param turns
     * 		- the amount of rounds for which this Entity should be
     * 		shutdown
     * @param baTaser
     * 		- was this due to a BA taser?
     */
    public [CtTypeReferenceImpl]void taserShutdown([CtParameterImpl][CtTypeReferenceImpl]int turns, [CtParameterImpl][CtTypeReferenceImpl]boolean baTaser) [CtBlockImpl]{
        [CtInvocationImpl]setShutDown([CtLiteralImpl]true);
        [CtAssignmentImpl][CtFieldWriteImpl]taserShutdownRounds = [CtVariableReadImpl]turns;
        [CtAssignmentImpl][CtFieldWriteImpl]shutdownByBATaser = [CtVariableReadImpl]baTaser;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * get the number of rounds for which this unit should be shutdown by taser
     *
     * @return  */
    public [CtTypeReferenceImpl]int getTaserShutdownRounds() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]taserShutdownRounds;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setTaserShutdownRounds([CtParameterImpl][CtTypeReferenceImpl]int rounds) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]taserShutdownRounds = [CtVariableReadImpl]rounds;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isBATaserShutdown() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]shutdownByBATaser;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setBATaserShutdown([CtParameterImpl][CtTypeReferenceImpl]boolean value) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]shutdownByBATaser = [CtVariableReadImpl]value;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean getTaserInterferenceHeat() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]taserInterferenceHeat;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * set this entity to suffer from taser feedback
     *
     * @param rounds
     * 		- the number of rounds to suffer from taserfeedback
     */
    public [CtTypeReferenceImpl]void setTaserFeedback([CtParameterImpl][CtTypeReferenceImpl]int rounds) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]taserFeedBackRounds = [CtVariableReadImpl]rounds;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * get the rounds for which this entity suffers from taser feedback
     *
     * @return  */
    public [CtTypeReferenceImpl]int getTaserFeedBackRounds() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]taserFeedBackRounds;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setTaserInterference([CtParameterImpl][CtTypeReferenceImpl]int value, [CtParameterImpl][CtTypeReferenceImpl]int rounds, [CtParameterImpl][CtTypeReferenceImpl]boolean heat) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]taserInterference = [CtVariableReadImpl]value;
        [CtAssignmentImpl][CtFieldWriteImpl]taserInterferenceRounds = [CtVariableReadImpl]rounds;
        [CtAssignmentImpl][CtFieldWriteImpl]taserInterferenceHeat = [CtVariableReadImpl]heat;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getTaserInterference() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]taserInterference;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getTaserInterferenceRounds() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]taserInterferenceRounds;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void addIMPHits([CtParameterImpl][CtTypeReferenceImpl]int missiles) [CtBlockImpl]{
        [CtOperatorAssignmentImpl][CtCommentImpl]// effects last for only one turn.
        [CtFieldWriteImpl]impThisTurn += [CtVariableReadImpl]missiles;
        [CtLocalVariableImpl][CtTypeReferenceImpl]int heatAdd = [CtBinaryOperatorImpl][CtVariableReadImpl]missiles + [CtFieldReadImpl]impThisTurnHeatHelp;
        [CtAssignmentImpl][CtFieldWriteImpl]impThisTurnHeatHelp = [CtBinaryOperatorImpl][CtVariableReadImpl]heatAdd % [CtLiteralImpl]3;
        [CtAssignmentImpl][CtVariableWriteImpl]heatAdd = [CtBinaryOperatorImpl][CtVariableReadImpl]heatAdd - [CtFieldReadImpl]impThisTurnHeatHelp;
        [CtAssignmentImpl][CtVariableWriteImpl]heatAdd = [CtBinaryOperatorImpl][CtVariableReadImpl]heatAdd / [CtLiteralImpl]3;
        [CtOperatorAssignmentImpl][CtFieldWriteImpl]heatFromExternal += [CtVariableReadImpl]heatAdd;
    }

    [CtMethodImpl]private [CtTypeReferenceImpl]void doNewRoundIMP() [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]impLastTurn = [CtFieldReadImpl]impThisTurn;
        [CtAssignmentImpl][CtFieldWriteImpl]impThisTurn = [CtLiteralImpl]0;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getIMPMoveMod() [CtBlockImpl]{
        [CtLocalVariableImpl][CtCommentImpl]// this function needs to be added to the MP
        [CtCommentImpl]// calculating functions
        [CtCommentImpl]// however, since no function calls super, it seems unneccesary complicated
        [CtCommentImpl]// really.
        [CtTypeReferenceImpl]int max = [CtLiteralImpl]2;
        [CtLocalVariableImpl][CtTypeReferenceImpl]int modifier = [CtBinaryOperatorImpl][CtFieldReadImpl]impThisTurn + [CtFieldReadImpl]impLastTurn;
        [CtAssignmentImpl][CtVariableWriteImpl]modifier = [CtBinaryOperatorImpl][CtVariableReadImpl]modifier - [CtBinaryOperatorImpl]([CtVariableReadImpl]modifier % [CtLiteralImpl]3);
        [CtAssignmentImpl][CtVariableWriteImpl]modifier = [CtBinaryOperatorImpl][CtVariableReadImpl]modifier / [CtLiteralImpl]3;
        [CtReturnImpl]return [CtConditionalImpl][CtBinaryOperatorImpl][CtVariableReadImpl]modifier > [CtVariableReadImpl]max ? [CtUnaryOperatorImpl]-[CtVariableReadImpl]max : [CtUnaryOperatorImpl]-[CtVariableReadImpl]modifier;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getIMPTHMod() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int max = [CtLiteralImpl]2;
        [CtLocalVariableImpl][CtTypeReferenceImpl]int modifier = [CtBinaryOperatorImpl][CtFieldReadImpl]impThisTurn + [CtFieldReadImpl]impLastTurn;
        [CtAssignmentImpl][CtVariableWriteImpl]modifier = [CtBinaryOperatorImpl][CtVariableReadImpl]modifier - [CtBinaryOperatorImpl]([CtVariableReadImpl]modifier % [CtLiteralImpl]3);
        [CtAssignmentImpl][CtVariableWriteImpl]modifier = [CtBinaryOperatorImpl][CtVariableReadImpl]modifier / [CtLiteralImpl]3;
        [CtReturnImpl]return [CtConditionalImpl][CtBinaryOperatorImpl][CtVariableReadImpl]modifier > [CtVariableReadImpl]max ? [CtVariableReadImpl]max : [CtVariableReadImpl]modifier;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * returns whether the unit is a military unit (as opposed to a civilian
     * unit).
     */
    public [CtTypeReferenceImpl]boolean isMilitary() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]military;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * is this entity a large craft? (dropship, jumpship, warship, or space
     * station)
     */
    public [CtTypeReferenceImpl]boolean isLargeCraft() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Dropship) || [CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Jumpship);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Do units loaded onto this entity still have active ECM/ECCM/etc.?
     */
    public [CtTypeReferenceImpl]boolean loadedUnitsHaveActiveECM() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * is this entity loaded into a fighter squadron?
     */
    public [CtTypeReferenceImpl]boolean isPartOfFighterSquadron() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]game == [CtLiteralImpl]null) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]conveyance == [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtInvocationImpl][CtFieldReadImpl]game.getEntity([CtFieldReadImpl]conveyance) instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.FighterSquadron;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Return a HTML string that describes the BV calculations
     *
     * @return a <code>String</code> explaining the BV calculation
     */
    public [CtTypeReferenceImpl]java.lang.String getBVText() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]bvText == [CtLiteralImpl]null) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"";
        }
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]bvText.toString();
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Return the BAR-rating of this Entity's armor
     *
     * @return the BAR rating
     */
    public [CtTypeReferenceImpl]int getBARRating([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtReturnImpl][CtCommentImpl]// normal armor has a BAR rating of 10
        return [CtLiteralImpl]10;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * does this Entity have BAR armor?
     *
     * @return  */
    public [CtTypeReferenceImpl]boolean hasBARArmor([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtInvocationImpl]getBARRating([CtVariableReadImpl]loc) < [CtLiteralImpl]10;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Sets the barrier armor rating for support vehicles. Has no effect on other unit types.
     *
     * @param rating
     */
    public [CtTypeReferenceImpl]void setBARRating([CtParameterImpl][CtTypeReferenceImpl]int rating) [CtBlockImpl]{
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * does this entity have an armored chassis?
     *
     * @return  */
    public [CtTypeReferenceImpl]boolean hasArmoredChassis() [CtBlockImpl]{
        [CtReturnImpl][CtCommentImpl]// normal entities don't, subclasses should
        [CtCommentImpl]// override
        return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * does this <code>Entity</code> have Environmental sealing? (only Support
     * Vehicles or IndustrialMechs should mount this)
     *
     * @return  */
    public [CtTypeReferenceImpl]boolean hasEnvironmentalSealing() [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted misc : [CtFieldReadImpl]miscList) [CtBlockImpl]{
            [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]misc.getType().hasFlag([CtTypeAccessImpl]MiscType.F_ENVIRONMENTAL_SEALING)) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Possibly do a ICE-Engine stall PSR (only intended for Mechs, both
     * Industrial and Battle).
     *
     * @param vPhaseReport
     * 		the <code>Vector<Report></code> containing the phase reports
     * @return a Vector<Report> containing the passed in reports, and any
    additional ones
     */
    public [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Report> doCheckEngineStallRoll([CtParameterImpl][CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Report> vPhaseReport) [CtBlockImpl]{
        [CtReturnImpl]return [CtVariableReadImpl]vPhaseReport;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Check for unstalling of this Entity's engine (only used for ICE-powered
     * 'Mechs).
     *
     * @param vPhaseReport
     * 		the <code>Vector<Report></code> containing the phase reports
     */
    public [CtTypeReferenceImpl]void checkUnstall([CtParameterImpl][CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Report> vPhaseReport) [CtBlockImpl]{
        [CtReturnImpl]return;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean hasArmoredEngine() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Is this Entity's ICE Engine stalled?
     *
     * @return if this Entity's ICE engine is stalled
     */
    public [CtTypeReferenceImpl]boolean isStalled() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * is this a naval vessel on the surface of the water?
     */
    public [CtTypeReferenceImpl]boolean isSurfaceNaval() [CtBlockImpl]{
        [CtReturnImpl][CtCommentImpl]// TODO: assuming submarines on the surface act like surface naval
        [CtCommentImpl]// vessels until rules clarified
        [CtCommentImpl]// http://www.classicbattletech.com/forums/index.php/topic,48987.0.html
        return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl]getElevation() == [CtLiteralImpl]0) && [CtInvocationImpl]isNaval();
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Is this a naval vessel?
     *
     * @return Whether it is or not.
     */
    public [CtTypeReferenceImpl]boolean isNaval() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() == [CtFieldReadImpl]EntityMovementMode.NAVAL) || [CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() == [CtFieldReadImpl]EntityMovementMode.HYDROFOIL)) || [CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() == [CtFieldReadImpl]EntityMovementMode.SUBMARINE);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * used to set the source of the creation of this entity, i.e RS PPU Custom
     * what not Fluff for MMLab
     *
     * @param source
     */
    public [CtTypeReferenceImpl]void setSource([CtParameterImpl][CtTypeReferenceImpl]java.lang.String source) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]source != [CtLiteralImpl]null) [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.source = [CtVariableReadImpl]source;
        }
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.lang.String getSource() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]source == [CtLiteralImpl]null) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"";
        }
        [CtReturnImpl]return [CtFieldReadImpl]source;
    }

    [CtMethodImpl]public synchronized [CtTypeReferenceImpl]void setQuirks([CtParameterImpl][CtTypeReferenceImpl]megamek.common.options.Quirks quirks) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.quirks = [CtVariableReadImpl]quirks;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Retrieves the quirks object for entity. DO NOT USE this to check boolean
     * options, as it will not check game options for quirks. Use
     * entity#hasQuirk instead
     *
     * @return  */
    public synchronized [CtTypeReferenceImpl]megamek.common.options.Quirks getQuirks() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]quirks;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean hasQuirk([CtParameterImpl][CtTypeReferenceImpl]java.lang.String name) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtLiteralImpl]null == [CtFieldReadImpl]game) || [CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVANCED_STRATOPS_QUIRKS))) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]quirks.booleanOption([CtVariableReadImpl]name);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]megamek.common.options.PartialRepairs getPartialRepairs() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]partReps;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void clearPartialRepairs() [CtBlockImpl]{
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Enumeration<[CtTypeReferenceImpl]megamek.common.options.IOptionGroup> i = [CtInvocationImpl][CtFieldReadImpl]partReps.getGroups(); [CtInvocationImpl][CtVariableReadImpl]i.hasMoreElements();) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.options.IOptionGroup group = [CtInvocationImpl][CtVariableReadImpl]i.nextElement();
            [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Enumeration<[CtTypeReferenceImpl]megamek.common.options.IOption> j = [CtInvocationImpl][CtVariableReadImpl]group.getOptions(); [CtInvocationImpl][CtVariableReadImpl]j.hasMoreElements();) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.options.IOption option = [CtInvocationImpl][CtVariableReadImpl]j.nextElement();
                [CtInvocationImpl][CtVariableReadImpl]option.clearValue();
            }
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * count all the quirks for this unit, positive and negative
     */
    public [CtTypeReferenceImpl]int countQuirks() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtLiteralImpl]null == [CtFieldReadImpl]game) || [CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVANCED_STRATOPS_QUIRKS))) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]0;
        }
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]quirks.count();
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int countWeaponQuirks() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int count = [CtLiteralImpl]0;
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtLiteralImpl]null == [CtFieldReadImpl]game) || [CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVANCED_STRATOPS_QUIRKS))) [CtBlockImpl]{
            [CtReturnImpl]return [CtVariableReadImpl]count;
        }
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getEquipment()) [CtBlockImpl]{
            [CtOperatorAssignmentImpl][CtVariableWriteImpl]count += [CtInvocationImpl][CtVariableReadImpl]m.countQuirks();
        }
        [CtReturnImpl]return [CtVariableReadImpl]count;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int countPartialRepairs() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtLiteralImpl]null == [CtFieldReadImpl]game) || [CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVANCED_STRATOPS_PARTIALREPAIRS))) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]0;
        }
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]partReps.count();
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * count the quirks for this unit, for a given group name
     */
    public [CtTypeReferenceImpl]int countQuirks([CtParameterImpl][CtTypeReferenceImpl]java.lang.String grpKey) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtLiteralImpl]null == [CtFieldReadImpl]game) || [CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVANCED_STRATOPS_QUIRKS))) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]0;
        }
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]quirks.count([CtVariableReadImpl]grpKey);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns a string of all the quirk "codes" for this entity, using sep as
     * the separator
     */
    public [CtTypeReferenceImpl]java.lang.String getQuirkList([CtParameterImpl][CtTypeReferenceImpl]java.lang.String sep) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtLiteralImpl]null == [CtFieldReadImpl]game) || [CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVANCED_STRATOPS_QUIRKS))) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"";
        }
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]quirks.getOptionList([CtVariableReadImpl]sep);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the forward firing arc for this entity - overrided by some units
     */
    public [CtTypeReferenceImpl]int getForwardArc() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]Compute.ARC_FORWARD;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the rear firing arc for this entity - overrided by some units
     */
    public [CtTypeReferenceImpl]int getRearArc() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]Compute.ARC_REAR;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * returns a description to the current sensing range of the active sensor
     */
    public [CtTypeReferenceImpl]java.lang.String getSensorDesc() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtLiteralImpl]null == [CtInvocationImpl]getActiveSensor()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"none";
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]int bracket = [CtInvocationImpl][CtTypeAccessImpl]megamek.common.Compute.getSensorBracket([CtInvocationImpl]getSensorCheck());
        [CtIfImpl]if ([CtInvocationImpl]isSpaceborne()) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]bracket = [CtInvocationImpl][CtTypeAccessImpl]megamek.common.Compute.getSensorBracket([CtLiteralImpl]7);
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]int range = [CtInvocationImpl][CtInvocationImpl]getActiveSensor().getRangeByBracket();
        [CtLocalVariableImpl][CtTypeReferenceImpl]int groundRange = [CtLiteralImpl]0;
        [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl]getActiveSensor().isBAP()) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]groundRange = [CtLiteralImpl]2;
        } else [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]groundRange = [CtLiteralImpl]1;
        }
        [CtIfImpl][CtCommentImpl]// ASF sensors change range when in space, so we do that here
        if ([CtInvocationImpl]isSpaceborne()) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl]getActiveSensor().getType() == [CtFieldReadImpl]Sensor.TYPE_AERO_SENSOR) [CtBlockImpl]{
                [CtAssignmentImpl][CtVariableWriteImpl]range = [CtFieldReadImpl]Sensor.ASF_RADAR_MAX_RANGE;
            }
            [CtIfImpl][CtCommentImpl]// If Aero/Spacecraft sensors are destroyed while in space, the range is 0.
            if ([CtInvocationImpl]isAeroSensorDestroyed()) [CtBlockImpl]{
                [CtAssignmentImpl][CtVariableWriteImpl]range = [CtLiteralImpl]0;
            }
        }
        [CtIfImpl][CtCommentImpl]// Dropships using radar in an atmosphere need a range that's a bit more sensible
        if ([CtBinaryOperatorImpl][CtInvocationImpl]hasETypeFlag([CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]ETYPE_DROPSHIP) && [CtUnaryOperatorImpl](![CtInvocationImpl]isSpaceborne())) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl]getActiveSensor().getType() == [CtFieldReadImpl]Sensor.TYPE_SPACECRAFT_RADAR) [CtBlockImpl]{
                [CtAssignmentImpl][CtVariableWriteImpl]range = [CtFieldReadImpl]Sensor.LC_RADAR_GROUND_RANGE;
            }
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]int maxSensorRange = [CtBinaryOperatorImpl][CtVariableReadImpl]bracket * [CtVariableReadImpl]range;
        [CtLocalVariableImpl][CtTypeReferenceImpl]int minSensorRange = [CtInvocationImpl][CtTypeAccessImpl]java.lang.Math.max([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]bracket - [CtLiteralImpl]1) * [CtVariableReadImpl]range, [CtLiteralImpl]0);
        [CtLocalVariableImpl][CtTypeReferenceImpl]int maxGroundSensorRange = [CtBinaryOperatorImpl][CtVariableReadImpl]bracket * [CtVariableReadImpl]groundRange;
        [CtLocalVariableImpl][CtTypeReferenceImpl]int minGroundSensorRange = [CtInvocationImpl][CtTypeAccessImpl]java.lang.Math.max([CtBinaryOperatorImpl][CtVariableReadImpl]maxGroundSensorRange - [CtLiteralImpl]1, [CtLiteralImpl]0);
        [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVANCED_INCLUSIVE_SENSOR_RANGE)) [CtBlockImpl]{
            [CtAssignmentImpl][CtVariableWriteImpl]minSensorRange = [CtLiteralImpl]0;
            [CtAssignmentImpl][CtVariableWriteImpl]minGroundSensorRange = [CtLiteralImpl]0;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]isAirborne() && [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().onGround()) [CtBlockImpl]{
            [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl]getActiveSensor().getDisplayName() + [CtLiteralImpl]" (") + [CtVariableReadImpl]minSensorRange) + [CtLiteralImpl]"-") + [CtVariableReadImpl]maxSensorRange) + [CtLiteralImpl]")") + [CtLiteralImpl]" {") + [CtFieldReadImpl]megamek.common.Entity.ENTITY_AIR_TO_GROUND_SENSOR_RANGE) + [CtLiteralImpl]" (") + [CtVariableReadImpl]minGroundSensorRange) + [CtLiteralImpl]"-") + [CtVariableReadImpl]maxGroundSensorRange) + [CtLiteralImpl]")}";
        }
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl]getActiveSensor().getDisplayName() + [CtLiteralImpl]" (") + [CtVariableReadImpl]minSensorRange) + [CtLiteralImpl]"-") + [CtVariableReadImpl]maxSensorRange) + [CtLiteralImpl]")";
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]boolean isAirborne() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]getAltitude() > [CtLiteralImpl]0) || [CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() == [CtFieldReadImpl]EntityMovementMode.AERODYNE)) || [CtBinaryOperatorImpl]([CtInvocationImpl]getMovementMode() == [CtFieldReadImpl]EntityMovementMode.SPHEROID);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isSpaceborne() [CtBlockImpl]{
        [CtReturnImpl][CtCommentImpl]// for now if you are in space, you are spaceborne, but this will become
        [CtCommentImpl]// more complicated when
        [CtCommentImpl]// we start adding multiple maps to the same game and so I should try to
        [CtCommentImpl]// replace most calls to
        [CtCommentImpl]// game.getBoard().inSpace() with this one
        return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtFieldReadImpl]game != [CtLiteralImpl]null) && [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().inSpace();
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * is the unit flying Nape of the Earth? (i.e. one elevation above ground)
     */
    public [CtTypeReferenceImpl]boolean isNOE() [CtBlockImpl]{
        [CtIfImpl]if ([CtUnaryOperatorImpl]![CtInvocationImpl]isAirborne()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().inAtmosphere()) [CtBlockImpl]{
            [CtReturnImpl]return [CtBinaryOperatorImpl][CtLiteralImpl]1 == [CtBinaryOperatorImpl]([CtInvocationImpl]getAltitude() - [CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().getHex([CtInvocationImpl]getPosition()).ceiling([CtLiteralImpl]true));
        }
        [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().onGround()) [CtBlockImpl]{
            [CtReturnImpl]return [CtBinaryOperatorImpl][CtLiteralImpl]1 == [CtInvocationImpl]getAltitude();
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getStartingPos() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getStartingPos([CtLiteralImpl]true);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getStartingPos([CtParameterImpl][CtTypeReferenceImpl]boolean inheritFromOwner) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]inheritFromOwner && [CtBinaryOperatorImpl]([CtFieldReadImpl]startingPos == [CtFieldReadImpl]Board.START_NONE)) [CtBlockImpl]{
            [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]owner.getStartingPos();
        }
        [CtReturnImpl]return [CtFieldReadImpl]startingPos;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setStartingPos([CtParameterImpl][CtTypeReferenceImpl]int i) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]startingPos = [CtVariableReadImpl]i;
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]int getAltitude() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]altitude;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setAltitude([CtParameterImpl][CtTypeReferenceImpl]int a) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]altitude = [CtVariableReadImpl]a;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean getUseManualBV() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]useManualBV;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setUseManualBV([CtParameterImpl][CtTypeReferenceImpl]boolean bv) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]useManualBV = [CtVariableReadImpl]bv;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getManualBV() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]manualBV;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setManualBV([CtParameterImpl][CtTypeReferenceImpl]int bv) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]manualBV = [CtVariableReadImpl]bv;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Gets the initial BV of a unit.
     *
     * Useful for comparisons with the current BV.
     *
     * @return The initial BV of a unit.
     */
    public [CtTypeReferenceImpl]int getInitialBV() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]initialBV;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Sets the initial BV for a unit.
     *
     * Called when the game is initialized.
     *
     * @param bv
     * 		The initial BV of a unit.
     */
    public [CtTypeReferenceImpl]void setInitialBV([CtParameterImpl][CtTypeReferenceImpl]int bv) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]initialBV = [CtVariableReadImpl]bv;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * produce an int array of the number of bombs of each type based on the
     * current bomblist
     *
     * @return  */
    public [CtArrayTypeReferenceImpl]int[] getBombLoadout() [CtBlockImpl]{
        [CtLocalVariableImpl][CtArrayTypeReferenceImpl]int[] loadout = [CtNewArrayImpl]new [CtTypeReferenceImpl]int[[CtFieldReadImpl]BombType.B_NUM];
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted bomb : [CtInvocationImpl]getBombs()) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]bomb.getUsableShotsLeft() > [CtLiteralImpl]0) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]bomb.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.BombType)) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]int type = [CtInvocationImpl][CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.BombType) ([CtVariableReadImpl]bomb.getType())).getBombType();
                [CtAssignmentImpl][CtArrayWriteImpl][CtVariableReadImpl]loadout[[CtVariableReadImpl]type] = [CtBinaryOperatorImpl][CtArrayReadImpl][CtVariableReadImpl]loadout[[CtVariableReadImpl]type] + [CtLiteralImpl]1;
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]loadout;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Start of Battle Force Conversion Methods
     */
    public [CtTypeReferenceImpl]int getBattleForcePoints() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]double bv = [CtInvocationImpl]calculateBattleValue([CtLiteralImpl]true, [CtLiteralImpl]true);
        [CtLocalVariableImpl][CtTypeReferenceImpl]int points = [CtInvocationImpl](([CtTypeReferenceImpl]int) ([CtTypeAccessImpl]java.lang.Math.round([CtBinaryOperatorImpl][CtVariableReadImpl]bv / [CtLiteralImpl]100)));
        [CtReturnImpl]return [CtInvocationImpl][CtTypeAccessImpl]java.lang.Math.max([CtLiteralImpl]1, [CtVariableReadImpl]points);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Get the movement mode of the entity and return it as a battle force
     * string.
     */
    public [CtTypeReferenceImpl]java.lang.String getMovementModeAsBattleForceString() [CtBlockImpl]{
        [CtSwitchImpl]switch ([CtInvocationImpl]getMovementMode()) {
            [CtCaseImpl]case [CtFieldReadImpl]megamek.common.Entity.NONE :
            [CtCaseImpl]case [CtFieldReadImpl]BIPED :
            [CtCaseImpl]case [CtFieldReadImpl]BIPED_SWIM :
            [CtCaseImpl]case [CtFieldReadImpl]QUAD :
            [CtCaseImpl]case [CtFieldReadImpl]QUAD_SWIM :
                [CtReturnImpl]return [CtLiteralImpl]"";
            [CtCaseImpl]case [CtFieldReadImpl]TRACKED :
                [CtReturnImpl]return [CtLiteralImpl]"t";
            [CtCaseImpl]case [CtFieldReadImpl]WHEELED :
                [CtReturnImpl]return [CtLiteralImpl]"w";
            [CtCaseImpl]case [CtFieldReadImpl]HOVER :
                [CtReturnImpl]return [CtLiteralImpl]"h";
            [CtCaseImpl]case [CtFieldReadImpl]VTOL :
                [CtReturnImpl]return [CtLiteralImpl]"v";
            [CtCaseImpl]case [CtFieldReadImpl]NAVAL :
            [CtCaseImpl]case [CtFieldReadImpl]HYDROFOIL :
                [CtReturnImpl]return [CtLiteralImpl]"n";
            [CtCaseImpl]case [CtFieldReadImpl]SUBMARINE :
            [CtCaseImpl]case [CtFieldReadImpl]INF_UMU :
                [CtReturnImpl]return [CtLiteralImpl]"s";
            [CtCaseImpl]case [CtFieldReadImpl]INF_LEG :
                [CtReturnImpl]return [CtLiteralImpl]"f";
            [CtCaseImpl]case [CtFieldReadImpl]INF_MOTORIZED :
                [CtReturnImpl]return [CtLiteralImpl]"m";
            [CtCaseImpl]case [CtFieldReadImpl]INF_JUMP :
                [CtReturnImpl]return [CtLiteralImpl]"j";
            [CtCaseImpl]case [CtFieldReadImpl]WIGE :
                [CtReturnImpl]return [CtLiteralImpl]"g";
            [CtCaseImpl]case [CtFieldReadImpl]AERODYNE :
                [CtReturnImpl]return [CtLiteralImpl]"a";
            [CtCaseImpl]case [CtFieldReadImpl]SPHEROID :
                [CtReturnImpl]return [CtLiteralImpl]"p";
            [CtCaseImpl]default :
                [CtReturnImpl]return [CtLiteralImpl]"ERROR";
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Certain unit types can increase this with MASC, supercharger, or jet booster.
     * AlphaStrike needs the fraction retained because it doubles the movement for ground units,
     * while BattleForce rounds this to the nearest integer.
     */
    public [CtTypeReferenceImpl]double getBaseBattleForceMovement() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getOriginalWalkMP();
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Handles base, jump, and underwater movement.
     *
     * @return  */
    public [CtTypeReferenceImpl]void setBattleForceMovement([CtParameterImpl][CtTypeReferenceImpl]java.util.Map<[CtTypeReferenceImpl]java.lang.String, [CtTypeReferenceImpl]java.lang.Integer> movement) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int baseMove = [CtInvocationImpl](([CtTypeReferenceImpl]int) ([CtTypeAccessImpl]java.lang.Math.round([CtInvocationImpl]getBaseBattleForceMovement())));
        [CtLocalVariableImpl][CtTypeReferenceImpl]int jumpMove = [CtInvocationImpl]getOriginalJumpMP();
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]jumpMove == [CtVariableReadImpl]baseMove) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl]getMovementModeAsBattleForceString().length() == [CtLiteralImpl]0)) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]movement.put([CtLiteralImpl]"j", [CtVariableReadImpl]baseMove);
        } else [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]movement.put([CtInvocationImpl]getMovementModeAsBattleForceString(), [CtVariableReadImpl]baseMove);
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]jumpMove >= [CtVariableReadImpl]baseMove) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]movement.put([CtLiteralImpl]"j", [CtVariableReadImpl]jumpMove);
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]jumpMove > [CtLiteralImpl]0) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]movement.put([CtLiteralImpl]"j", [CtInvocationImpl](([CtTypeReferenceImpl]int) ([CtTypeAccessImpl]java.lang.Math.round([CtBinaryOperatorImpl][CtVariableReadImpl]jumpMove * [CtLiteralImpl]0.66))));
            }
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]int umu = [CtInvocationImpl]getAllUMUCount();
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]umu > [CtLiteralImpl]0) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]movement.put([CtLiteralImpl]"s", [CtVariableReadImpl]umu);
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Doubles base movement. Aero overrides this.
     */
    public [CtTypeReferenceImpl]void setAlphaStrikeMovement([CtParameterImpl][CtTypeReferenceImpl]java.util.Map<[CtTypeReferenceImpl]java.lang.String, [CtTypeReferenceImpl]java.lang.Integer> movement) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int baseMove = [CtInvocationImpl](([CtTypeReferenceImpl]int) ([CtTypeAccessImpl]java.lang.Math.round([CtBinaryOperatorImpl][CtInvocationImpl]getBaseBattleForceMovement() * [CtLiteralImpl]2)));
        [CtLocalVariableImpl][CtTypeReferenceImpl]int jumpMove = [CtInvocationImpl]getOriginalJumpMP();
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]jumpMove == [CtVariableReadImpl]baseMove) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]movement.put([CtLiteralImpl]"j", [CtVariableReadImpl]baseMove);
        } else [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]movement.put([CtInvocationImpl]getMovementModeAsBattleForceString(), [CtVariableReadImpl]baseMove);
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]jumpMove > [CtLiteralImpl]0) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]movement.put([CtLiteralImpl]"j", [CtBinaryOperatorImpl][CtVariableReadImpl]jumpMove * [CtLiteralImpl]2);
            }
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]int umu = [CtInvocationImpl]getAllUMUCount();
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]umu > [CtLiteralImpl]0) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]movement.put([CtLiteralImpl]"s", [CtBinaryOperatorImpl][CtVariableReadImpl]umu * [CtLiteralImpl]2);
        }
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getBattleForceArmorPoints() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl](([CtTypeReferenceImpl]int) ([CtTypeAccessImpl]java.lang.Math.round([CtInvocationImpl]getBattleForceArmorPointsRaw())));
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Calculates the intermediate value for armor points (retaining fractional amounts)
     * and adds any special abilities conferred by armor.
     *
     * @return The armor value of this entity
     */
    public [CtTypeReferenceImpl]double getBattleForceArmorPointsRaw() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]double armorPoints = [CtLiteralImpl]0;
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int loc = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]loc < [CtInvocationImpl]locations(); [CtUnaryOperatorImpl][CtVariableWriteImpl]loc++) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]double armorMod = [CtLiteralImpl]1;
            [CtSwitchImpl]switch ([CtInvocationImpl]getArmorType([CtVariableReadImpl]loc)) {
                [CtCaseImpl]case [CtFieldReadImpl]EquipmentType.T_ARMOR_COMMERCIAL :
                    [CtAssignmentImpl][CtVariableWriteImpl]armorMod = [CtLiteralImpl]0.5;
                    [CtBreakImpl]break;
                [CtCaseImpl]case [CtFieldReadImpl]EquipmentType.T_ARMOR_INDUSTRIAL :
                [CtCaseImpl]case [CtFieldReadImpl]EquipmentType.T_ARMOR_HEAVY_INDUSTRIAL :
                    [CtAssignmentImpl][CtVariableWriteImpl]armorMod = [CtBinaryOperatorImpl][CtInvocationImpl]getBARRating([CtLiteralImpl]0) / [CtLiteralImpl]10;
                    [CtBreakImpl]break;
                [CtCaseImpl]case [CtFieldReadImpl]EquipmentType.T_ARMOR_FERRO_LAMELLOR :
                    [CtAssignmentImpl][CtVariableWriteImpl]armorMod = [CtLiteralImpl]1.2;
                    [CtBreakImpl]break;
                [CtCaseImpl]case [CtFieldReadImpl]EquipmentType.T_ARMOR_HARDENED :
                    [CtAssignmentImpl][CtVariableWriteImpl]armorMod = [CtLiteralImpl]1.5;
                    [CtBreakImpl]break;
                [CtCaseImpl]case [CtFieldReadImpl]EquipmentType.T_ARMOR_REFLECTIVE :
                [CtCaseImpl]case [CtFieldReadImpl]EquipmentType.T_ARMOR_REACTIVE :
                    [CtAssignmentImpl][CtVariableWriteImpl]armorMod = [CtLiteralImpl]0.75;
                    [CtBreakImpl]break;
            }
            [CtOperatorAssignmentImpl][CtVariableWriteImpl]armorPoints += [CtInvocationImpl][CtTypeAccessImpl]java.lang.Math.ceil([CtBinaryOperatorImpl][CtInvocationImpl]getArmor([CtVariableReadImpl]loc) * [CtVariableReadImpl]armorMod);
        }
        [CtIfImpl]if ([CtInvocationImpl][CtThisAccessImpl]this.hasModularArmor()) [CtBlockImpl]{
            [CtForEachImpl][CtCommentImpl]// Modular armor is always "regular" armor
            for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted mount : [CtInvocationImpl][CtThisAccessImpl]this.getEquipment()) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]mount.isDestroyed()) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]mount.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.MiscType)) && [CtInvocationImpl][CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.MiscType) ([CtVariableReadImpl]mount.getType())).hasFlag([CtTypeAccessImpl]MiscType.F_MODULAR_ARMOR)) [CtBlockImpl]{
                    [CtOperatorAssignmentImpl][CtVariableWriteImpl]armorPoints += [CtLiteralImpl]10;
                }
            }
        }
        [CtIfImpl]if ([CtInvocationImpl]isCapitalScale()) [CtBlockImpl]{
            [CtReturnImpl]return [CtInvocationImpl](([CtTypeReferenceImpl]int) ([CtTypeAccessImpl]java.lang.Math.round([CtBinaryOperatorImpl][CtVariableReadImpl]armorPoints * [CtLiteralImpl]0.33)));
        }
        [CtReturnImpl]return [CtInvocationImpl](([CtTypeReferenceImpl]int) ([CtTypeAccessImpl]java.lang.Math.round([CtBinaryOperatorImpl][CtVariableReadImpl]armorPoints / [CtLiteralImpl]30)));
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * only used for Aerospace and Dropships
     *
     * @return  */
    public [CtTypeReferenceImpl]java.lang.String getBattleForceDamageThresholdString() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]"";
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * this will be unit specific
     *
     * @return  */
    public [CtTypeReferenceImpl]int getBattleForceStructurePoints() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]0;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Some units have separate damage values for various locations (turrets, large craft firing arcs)
     *
     * @return  */
    public [CtTypeReferenceImpl]int getNumBattleForceWeaponsLocations() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]1;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getNumAlphaStrikeWeaponsLocations() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getNumBattleForceWeaponsLocations();
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @param index
     * 		- indicates which set of damage values is being calculated
     * @param location
     * 		- one of the entity's LOC_* constants
     * @return - the damage multiplier for this location; 0 for exclusion
     */
    public [CtTypeReferenceImpl]double getBattleForceLocationMultiplier([CtParameterImpl][CtTypeReferenceImpl]int index, [CtParameterImpl][CtTypeReferenceImpl]int location, [CtParameterImpl][CtTypeReferenceImpl]boolean rearMounted) [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]1.0;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Weapon calculations are the same for BF and AS except for turrets, which are not separated
     * in AS, and warships, which have only four arcs in AS.
     */
    public [CtTypeReferenceImpl]double getAlphaStrikeLocationMultiplier([CtParameterImpl][CtTypeReferenceImpl]int index, [CtParameterImpl][CtTypeReferenceImpl]int location, [CtParameterImpl][CtTypeReferenceImpl]boolean rearMounted) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getBattleForceLocationMultiplier([CtVariableReadImpl]index, [CtVariableReadImpl]location, [CtVariableReadImpl]rearMounted);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isBattleForceTurretLocation([CtParameterImpl][CtTypeReferenceImpl]int index) [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isBattleForceRearLocation([CtParameterImpl][CtTypeReferenceImpl]int index) [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Units with separate weapon locations (turrets or firing arcs) return the name of the location
     *
     * @param index
     * @return  */
    public [CtTypeReferenceImpl]java.lang.String getBattleForceLocationName([CtParameterImpl][CtTypeReferenceImpl]int index) [CtBlockImpl]{
        [CtIfImpl]if ([CtInvocationImpl]isBattleForceTurretLocation([CtVariableReadImpl]index)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"TUR";
        }
        [CtReturnImpl]return [CtLiteralImpl]"";
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.lang.String getAlphaStrikeLocationName([CtParameterImpl][CtTypeReferenceImpl]int index) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getBattleForceLocationName([CtVariableReadImpl]index);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean useForAlphaStrikePointCalc([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]loc == [CtLiteralImpl]0) || [CtInvocationImpl]isBattleForceTurretLocation([CtVariableReadImpl]loc);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Only used by Mechs and ASFs, which require different approaches to determining rear mountings
     *
     * @param allowRear
     * 		- Use rear-mounted weapons instead of forward
     * @return - total heat generated by firing all weapons
     */
    public [CtTypeReferenceImpl]int getBattleForceTotalHeatGeneration([CtParameterImpl][CtTypeReferenceImpl]boolean allowRear) [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]0;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Used by small craft, dropships, jumpships, and warships to compute heat for a specific firing arc
     *
     * @param location
     * @return  */
    public [CtTypeReferenceImpl]int getBattleForceTotalHeatGeneration([CtParameterImpl][CtTypeReferenceImpl]int location) [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]0;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void addBattleForceSpecialAbilities([CtParameterImpl][CtTypeReferenceImpl]java.util.Map<[CtTypeReferenceImpl]megamek.common.BattleForceSPA, [CtTypeReferenceImpl]java.lang.Integer> specialAbilities) [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getEquipment()) [CtBlockImpl]{
            [CtIfImpl]if ([CtUnaryOperatorImpl]![CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.MiscType)) [CtBlockImpl]{
                [CtContinueImpl]continue;
            }
            [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_BAP)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.RCN, [CtLiteralImpl]null);
                [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_BLOODHOUND)) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.BH, [CtLiteralImpl]null);
                } else [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_BA_EQUIPMENT)) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.LPRB, [CtLiteralImpl]null);
                } else [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_WATCHDOG)) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.WAT, [CtLiteralImpl]null);
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.LPRB, [CtLiteralImpl]null);
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.ECM, [CtLiteralImpl]null);
                } else [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.PRB, [CtLiteralImpl]null);
                }
                [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_NOVA)) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.NOVA, [CtLiteralImpl]null);
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.ECM, [CtLiteralImpl]null);
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.MHQ, [CtLiteralImpl]3);[CtCommentImpl]// count half-tons

                }
            } else [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_ECM)) [CtBlockImpl]{
                [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_ANGEL_ECM)) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.AECM, [CtLiteralImpl]null);
                } else [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_SINGLE_HEX_ECM)) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.LECM, [CtLiteralImpl]null);
                } else [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.ECM, [CtLiteralImpl]null);
                }
            } else [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_BOOBY_TRAP)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.BT, [CtLiteralImpl]null);
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_LIGHT_BRIDGE_LAYER) || [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_MEDIUM_BRIDGE_LAYER)) || [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_HEAVY_BRIDGE_LAYER)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.BRID, [CtLiteralImpl]null);
            } else [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_C3S)) [CtBlockImpl]{
                [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_C3SBS)) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.C3BSS, [CtLiteralImpl]null);
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.merge([CtTypeAccessImpl]BattleForceSPA.MHQ, [CtLiteralImpl]4, [CtExecutableReferenceExpressionImpl][CtTypeAccessImpl]java.lang.Integer::sum);
                } else [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_C3EM)) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.merge([CtTypeAccessImpl]BattleForceSPA.C3EM, [CtLiteralImpl]1, [CtExecutableReferenceExpressionImpl][CtTypeAccessImpl]java.lang.Integer::sum);
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.merge([CtTypeAccessImpl]BattleForceSPA.MHQ, [CtLiteralImpl]4, [CtExecutableReferenceExpressionImpl][CtTypeAccessImpl]java.lang.Integer::sum);
                } else [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.C3S, [CtLiteralImpl]null);
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.merge([CtTypeAccessImpl]BattleForceSPA.MHQ, [CtLiteralImpl]2, [CtExecutableReferenceExpressionImpl][CtTypeAccessImpl]java.lang.Integer::sum);
                }
            } else [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_C3I)) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl]getEntityType() & [CtFieldReadImpl]megamek.common.Entity.ETYPE_AERO) == [CtFieldReadImpl]megamek.common.Entity.ETYPE_AERO) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.NC3, [CtLiteralImpl]null);
                } else [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.C3I, [CtLiteralImpl]null);
                    [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_BA_EQUIPMENT)) [CtBlockImpl]{
                        [CtInvocationImpl][CtVariableReadImpl]specialAbilities.merge([CtTypeAccessImpl]BattleForceSPA.MHQ, [CtLiteralImpl]4, [CtExecutableReferenceExpressionImpl][CtTypeAccessImpl]java.lang.Integer::sum);
                    } else [CtBlockImpl]{
                        [CtInvocationImpl][CtVariableReadImpl]specialAbilities.merge([CtTypeAccessImpl]BattleForceSPA.MHQ, [CtLiteralImpl]5, [CtExecutableReferenceExpressionImpl][CtTypeAccessImpl]java.lang.Integer::sum);
                    }
                }
            } else [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_CASE)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.CASE, [CtLiteralImpl]null);
            } else [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_CASEP)) [CtBlockImpl]{
                [CtInvocationImpl][CtCommentImpl]// in BF seems to work the same as CASE
                [CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.CASE, [CtLiteralImpl]null);
            } else [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_CASEII)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.CASEII, [CtLiteralImpl]null);
            } else [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_DRONE_OPERATING_SYSTEM)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.DRO, [CtLiteralImpl]null);
            } else [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_DRONE_CARRIER_CONTROL)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.merge([CtTypeAccessImpl]BattleForceSPA.DCC, [CtInvocationImpl](([CtTypeReferenceImpl]int) ([CtVariableReadImpl]m.getSize())), [CtExecutableReferenceExpressionImpl][CtTypeAccessImpl]java.lang.Integer::sum);
            } else [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_EJECTION_SEAT)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.ES, [CtLiteralImpl]null);
            } else [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_ECM)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.ECM, [CtLiteralImpl]null);
            } else [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_BULLDOZER)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.ENG, [CtLiteralImpl]null);
            } else [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_CLUB)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.MEL, [CtLiteralImpl]null);
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().getSubType() & [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtFieldReadImpl]MiscType.S_BACKHOE | [CtFieldReadImpl]MiscType.S_PILE_DRIVER) | [CtFieldReadImpl]MiscType.S_MINING_DRILL) | [CtFieldReadImpl]MiscType.S_ROCK_CUTTER) | [CtFieldReadImpl]MiscType.S_WRECKING_BALL)) != [CtLiteralImpl]0) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.ENG, [CtLiteralImpl]null);
                } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().getSubType() & [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtFieldReadImpl]MiscType.S_DUAL_SAW | [CtFieldReadImpl]MiscType.S_CHAINSAW) | [CtFieldReadImpl]MiscType.S_BUZZSAW)) != [CtLiteralImpl]0) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.SAW, [CtLiteralImpl]null);
                }
            } else [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_FIRE_RESISTANT)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.FR, [CtLiteralImpl]null);
            } else [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_MOBILE_HPG)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.HPG, [CtLiteralImpl]null);
            } else [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_COMMUNICATIONS)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.merge([CtTypeAccessImpl]BattleForceSPA.MHQ, [CtBinaryOperatorImpl][CtInvocationImpl](([CtTypeReferenceImpl]int) ([CtVariableReadImpl]m.getTonnage())) * [CtLiteralImpl]2, [CtExecutableReferenceExpressionImpl][CtTypeAccessImpl]java.lang.Integer::sum);
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]m.getTonnage() >= [CtBinaryOperatorImpl]([CtInvocationImpl]getWeight() / [CtLiteralImpl]20.0)) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.RCN, [CtLiteralImpl]null);
                }
            } else [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_SENSOR_DISPENSER)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.merge([CtTypeAccessImpl]BattleForceSPA.RSD, [CtLiteralImpl]1, [CtExecutableReferenceExpressionImpl][CtTypeAccessImpl]java.lang.Integer::sum);
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.RCN, [CtLiteralImpl]null);
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_LOOKDOWN_RADAR) || [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_RECON_CAMERA)) || [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_HIRES_IMAGER)) || [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_HYPERSPECTRAL_IMAGER)) || [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_INFRARED_IMAGER)) [CtBlockImpl]{
            } else [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_SEARCHLIGHT)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.SRCH, [CtLiteralImpl]null);
            } else [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_RADICAL_HEATSINK)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.RHS, [CtLiteralImpl]null);
            } else [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_EMERGENCY_COOLANT_SYSTEM)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.ECS, [CtLiteralImpl]null);
            } else [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_VIRAL_JAMMER_DECOY)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.DJ, [CtLiteralImpl]null);
            } else [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_VIRAL_JAMMER_HOMING)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.HJ, [CtLiteralImpl]null);
            }
        }
        [CtIfImpl]if ([CtInvocationImpl]isOmni()) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.OMNI, [CtLiteralImpl]null);
        }
        [CtIfImpl][CtCommentImpl]// TODO: Variable Range targeting is not implemented
        if ([CtUnaryOperatorImpl]![CtInvocationImpl]hasPatchworkArmor()) [CtBlockImpl]{
            [CtSwitchImpl]switch ([CtInvocationImpl]getArmorType([CtLiteralImpl]0)) {
                [CtCaseImpl]case [CtFieldReadImpl]EquipmentType.T_ARMOR_COMMERCIAL :
                [CtCaseImpl]case [CtFieldReadImpl]EquipmentType.T_ARMOR_INDUSTRIAL :
                [CtCaseImpl]case [CtFieldReadImpl]EquipmentType.T_ARMOR_HEAVY_INDUSTRIAL :
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.BAR, [CtLiteralImpl]null);
                    [CtBreakImpl]break;
                [CtCaseImpl]case [CtFieldReadImpl]EquipmentType.T_ARMOR_FERRO_LAMELLOR :
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.CR, [CtLiteralImpl]null);
                    [CtBreakImpl]break;
                [CtCaseImpl]case [CtFieldReadImpl]EquipmentType.T_ARMOR_STEALTH :
                [CtCaseImpl]case [CtFieldReadImpl]EquipmentType.T_ARMOR_STEALTH_VEHICLE :
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.STL, [CtLiteralImpl]null);
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.ECM, [CtLiteralImpl]null);
                    [CtBreakImpl]break;
                [CtCaseImpl]case [CtFieldReadImpl]EquipmentType.T_ARMOR_BA_STEALTH :
                [CtCaseImpl]case [CtFieldReadImpl]EquipmentType.T_ARMOR_BA_STEALTH_BASIC :
                [CtCaseImpl]case [CtFieldReadImpl]EquipmentType.T_ARMOR_BA_STEALTH_IMP :
                [CtCaseImpl]case [CtFieldReadImpl]EquipmentType.T_ARMOR_BA_STEALTH_PROTOTYPE :
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.STL, [CtLiteralImpl]null);
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.LECM, [CtLiteralImpl]null);
                    [CtBreakImpl]break;
                [CtCaseImpl]case [CtFieldReadImpl]EquipmentType.T_ARMOR_ANTI_PENETRATIVE_ABLATION :
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.ABA, [CtLiteralImpl]null);
                    [CtBreakImpl]break;
                [CtCaseImpl]case [CtFieldReadImpl]EquipmentType.T_ARMOR_BALLISTIC_REINFORCED :
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.BRA, [CtLiteralImpl]null);
                    [CtBreakImpl]break;
                [CtCaseImpl]case [CtFieldReadImpl]EquipmentType.T_ARMOR_BA_FIRE_RESIST :
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.FR, [CtLiteralImpl]null);
                    [CtBreakImpl]break;
                [CtCaseImpl]case [CtFieldReadImpl]EquipmentType.T_ARMOR_IMPACT_RESISTANT :
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.IRA, [CtLiteralImpl]null);
                    [CtBreakImpl]break;
                [CtCaseImpl]case [CtFieldReadImpl]EquipmentType.T_ARMOR_REACTIVE :
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.RCA, [CtLiteralImpl]null);
                    [CtBreakImpl]break;
                [CtCaseImpl]case [CtFieldReadImpl]EquipmentType.T_ARMOR_REFLECTIVE :
                    [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.RFA, [CtLiteralImpl]null);
                    [CtBreakImpl]break;
            }
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl]getAmmo().size() > [CtLiteralImpl]0) [CtBlockImpl]{
            [CtIfImpl]if ([CtInvocationImpl]isClan()) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.CASE, [CtLiteralImpl]null);
            }
        } else [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.ENE, [CtLiteralImpl]null);
        }
        [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtInvocationImpl]getAmmo().stream().map([CtLambdaImpl]([CtParameterImpl] m) -> [CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.AmmoType) ([CtVariableReadImpl]m.getType()))).anyMatch([CtLambdaImpl]([CtParameterImpl] at) -> [CtInvocationImpl][CtVariableReadImpl]at.hasFlag([CtVariableReadImpl]AmmoType.F_TELE_MISSILE))) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.TELE, [CtLiteralImpl]null);
        }
        [CtIfImpl]if ([CtInvocationImpl]hasEngine()) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl]getEngine().getEngineType() == [CtFieldReadImpl]Engine.STEAM) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl]getEngine().getEngineType() == [CtFieldReadImpl]Engine.FUEL_CELL)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.EE, [CtLiteralImpl]null);
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl]getEngine().getEngineType() == [CtFieldReadImpl]Engine.STEAM) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.FC, [CtLiteralImpl]null);
            } else [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.EEE, [CtLiteralImpl]null);
            }
        }
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter t : [CtInvocationImpl]getTransports()) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]t instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.ASFBay) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.merge([CtTypeAccessImpl]BattleForceSPA.AT, [CtInvocationImpl](([CtTypeReferenceImpl]int) ([CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.ASFBay) (t)).getCapacity())), [CtExecutableReferenceExpressionImpl][CtTypeAccessImpl]java.lang.Integer::sum);
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.merge([CtTypeAccessImpl]BattleForceSPA.ATxD, [CtInvocationImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.ASFBay) (t)).getDoors(), [CtExecutableReferenceExpressionImpl][CtTypeAccessImpl]java.lang.Integer::sum);
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.MFB, [CtLiteralImpl]null);
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]t instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.CargoBay) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.merge([CtTypeAccessImpl]BattleForceSPA.CT, [CtInvocationImpl](([CtTypeReferenceImpl]int) ([CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.CargoBay) (t)).getCapacity())), [CtExecutableReferenceExpressionImpl][CtTypeAccessImpl]java.lang.Integer::sum);
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.merge([CtTypeAccessImpl]BattleForceSPA.CTxD, [CtInvocationImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.CargoBay) (t)).getDoors(), [CtExecutableReferenceExpressionImpl][CtTypeAccessImpl]java.lang.Integer::sum);
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]t instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.DockingCollar) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.merge([CtTypeAccessImpl]BattleForceSPA.DT, [CtLiteralImpl]1, [CtExecutableReferenceExpressionImpl][CtTypeAccessImpl]java.lang.Integer::sum);
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]t instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.InfantryBay) [CtBlockImpl]{
                [CtInvocationImpl][CtCommentImpl]// We do not record number of doors for infantry
                [CtVariableReadImpl]specialAbilities.merge([CtTypeAccessImpl]BattleForceSPA.IT, [CtInvocationImpl](([CtTypeReferenceImpl]int) ([CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.InfantryBay) (t)).getCapacity())), [CtExecutableReferenceExpressionImpl][CtTypeAccessImpl]java.lang.Integer::sum);
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]t instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.MechBay) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.merge([CtTypeAccessImpl]BattleForceSPA.MT, [CtInvocationImpl](([CtTypeReferenceImpl]int) ([CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.MechBay) (t)).getCapacity())), [CtExecutableReferenceExpressionImpl][CtTypeAccessImpl]java.lang.Integer::sum);
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.merge([CtTypeAccessImpl]BattleForceSPA.MTxD, [CtInvocationImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.MechBay) (t)).getDoors(), [CtExecutableReferenceExpressionImpl][CtTypeAccessImpl]java.lang.Integer::sum);
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.MFB, [CtLiteralImpl]null);
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]t instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.ProtomechBay) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.merge([CtTypeAccessImpl]BattleForceSPA.PT, [CtInvocationImpl](([CtTypeReferenceImpl]int) ([CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.ProtomechBay) (t)).getCapacity())), [CtExecutableReferenceExpressionImpl][CtTypeAccessImpl]java.lang.Integer::sum);
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.merge([CtTypeAccessImpl]BattleForceSPA.PTxD, [CtInvocationImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.ProtomechBay) (t)).getDoors(), [CtExecutableReferenceExpressionImpl][CtTypeAccessImpl]java.lang.Integer::sum);
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.MFB, [CtLiteralImpl]null);
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]t instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.SmallCraftBay) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.merge([CtTypeAccessImpl]BattleForceSPA.ST, [CtInvocationImpl](([CtTypeReferenceImpl]int) ([CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.SmallCraftBay) (t)).getCapacity())), [CtExecutableReferenceExpressionImpl][CtTypeAccessImpl]java.lang.Integer::sum);
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.merge([CtTypeAccessImpl]BattleForceSPA.STxD, [CtInvocationImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.SmallCraftBay) (t)).getDoors(), [CtExecutableReferenceExpressionImpl][CtTypeAccessImpl]java.lang.Integer::sum);
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.MFB, [CtLiteralImpl]null);
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]t instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.LightVehicleBay) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.merge([CtTypeAccessImpl]BattleForceSPA.VTM, [CtInvocationImpl](([CtTypeReferenceImpl]int) ([CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.LightVehicleBay) (t)).getCapacity())), [CtExecutableReferenceExpressionImpl][CtTypeAccessImpl]java.lang.Integer::sum);
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.merge([CtTypeAccessImpl]BattleForceSPA.VTMxD, [CtInvocationImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.LightVehicleBay) (t)).getDoors(), [CtExecutableReferenceExpressionImpl][CtTypeAccessImpl]java.lang.Integer::sum);
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.MFB, [CtLiteralImpl]null);
            } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]t instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.HeavyVehicleBay) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.merge([CtTypeAccessImpl]BattleForceSPA.VTH, [CtInvocationImpl](([CtTypeReferenceImpl]int) ([CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.HeavyVehicleBay) (t)).getCapacity())), [CtExecutableReferenceExpressionImpl][CtTypeAccessImpl]java.lang.Integer::sum);
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.merge([CtTypeAccessImpl]BattleForceSPA.VTHxD, [CtInvocationImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.HeavyVehicleBay) (t)).getDoors(), [CtExecutableReferenceExpressionImpl][CtTypeAccessImpl]java.lang.Integer::sum);
                [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.MFB, [CtLiteralImpl]null);
            }
        }
        [CtForImpl]topLoop : for ([CtLocalVariableImpl][CtTypeReferenceImpl]int location = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]location < [CtInvocationImpl]locations(); [CtUnaryOperatorImpl][CtVariableWriteImpl]location++) [CtBlockImpl]{
            [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int slot = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]slot < [CtInvocationImpl]getNumberOfCriticals([CtVariableReadImpl]location); [CtUnaryOperatorImpl][CtVariableWriteImpl]slot++) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.CriticalSlot crit = [CtInvocationImpl]getCritical([CtVariableReadImpl]location, [CtVariableReadImpl]slot);
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtLiteralImpl]null != [CtVariableReadImpl]crit) [CtBlockImpl]{
                    [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]crit.isArmored()) [CtBlockImpl]{
                        [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.ARM, [CtLiteralImpl]null);
                        [CtBreakImpl]break topLoop;
                    } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]crit.getType() == [CtFieldReadImpl]CriticalSlot.TYPE_EQUIPMENT) [CtBlockImpl]{
                        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted mount = [CtInvocationImpl][CtVariableReadImpl]crit.getMount();
                        [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]mount.isArmored()) [CtBlockImpl]{
                            [CtInvocationImpl][CtVariableReadImpl]specialAbilities.put([CtTypeAccessImpl]BattleForceSPA.ARM, [CtLiteralImpl]null);
                            [CtBreakImpl]break topLoop;
                        }
                    }
                }
            }
        }
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getBattleForceSize() [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// the default BF Size is for ground Combat elements. Other types will
        [CtCommentImpl]// need to override this
        [CtCommentImpl]// The tables are on page 356 of StartOps
        if ([CtBinaryOperatorImpl][CtInvocationImpl]getWeight() < [CtLiteralImpl]40) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]1;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]getWeight() < [CtLiteralImpl]60) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]2;
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]getWeight() < [CtLiteralImpl]80) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]3;
        }
        [CtReturnImpl]return [CtLiteralImpl]4;
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]java.util.Map<[CtTypeReferenceImpl]java.lang.Integer, [CtTypeReferenceImpl]megamek.common.Coords> getSecondaryPositions() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]secondaryPositions;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks to see if this unit has a functional Blue Shield Particle Field
     * Damper that is turned on
     *
     * @return <code>true</code> if the entity has a working, switched on blue
    field <code>false</code> otherwise
     */
    public [CtTypeReferenceImpl]boolean hasActiveBlueShield() [CtBlockImpl]{
        [CtIfImpl]if ([CtUnaryOperatorImpl]![CtInvocationImpl]isShutDown()) [CtBlockImpl]{
            [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getMisc()) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.EquipmentType type = [CtInvocationImpl][CtVariableReadImpl]m.getType();
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]type instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.MiscType) && [CtInvocationImpl][CtVariableReadImpl]type.hasFlag([CtTypeAccessImpl]MiscType.F_BLUE_SHIELD)) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"On")) [CtBlockImpl]{
                    [CtReturnImpl]return [CtUnaryOperatorImpl]![CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.isDestroyed() || [CtInvocationImpl][CtVariableReadImpl]m.isMissing()) || [CtInvocationImpl][CtVariableReadImpl]m.isBreached()) || [CtInvocationImpl]isShutDown());
                }
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getBlueShieldRounds() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]blueShieldRounds;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isDropping() [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtInvocationImpl]isAirborne() && [CtUnaryOperatorImpl](![CtInvocationImpl]isAero());
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * does this unit have stealth armor?
     *
     * @return  */
    public [CtTypeReferenceImpl]boolean hasStealth() [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// only non-patchwork stealth actually works as stealth
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]getArmorType([CtLiteralImpl]1) == [CtFieldReadImpl]EquipmentType.T_ARMOR_STEALTH) || [CtBinaryOperatorImpl]([CtInvocationImpl]getArmorType([CtLiteralImpl]1) == [CtFieldReadImpl]EquipmentType.T_ARMOR_STEALTH_VEHICLE)) && [CtUnaryOperatorImpl](![CtInvocationImpl]hasPatchworkArmor())) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]true;
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Computes and returns the power amplifier weight for this entity, if any.
     * Returns 0.0 if the entity needs no amplifiers due to engine type or not
     * carrying any weapons requiring them.
     *
     * @return the power amplifier weight in tons.
     */
    public [CtTypeReferenceImpl]double getPowerAmplifierWeight() [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// If we're fusion- or fission-powered, we need no amplifiers to begin
        [CtCommentImpl]// with.
        if ([CtBinaryOperatorImpl][CtInvocationImpl]hasEngine() && [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl]getEngine().isFusion() || [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl]getEngine().getEngineType() == [CtFieldReadImpl]Engine.FISSION))) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]0.0;
        }
        [CtLocalVariableImpl][CtCommentImpl]// Otherwise we need to iterate over our weapons, find out which of them
        [CtCommentImpl]// require amplification, and keep a running weight total of those.
        [CtTypeReferenceImpl]double total = [CtLiteralImpl]0.0;
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getWeaponList()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.WeaponType wt = [CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.WeaponType) ([CtVariableReadImpl]m.getType()));
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]wt.hasFlag([CtTypeAccessImpl]WeaponType.F_LASER) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]wt.getAmmoType() == [CtFieldReadImpl]AmmoType.T_NA)) || [CtInvocationImpl][CtVariableReadImpl]wt.hasFlag([CtTypeAccessImpl]WeaponType.F_PPC)) || [CtInvocationImpl][CtVariableReadImpl]wt.hasFlag([CtTypeAccessImpl]WeaponType.F_PLASMA)) || [CtInvocationImpl][CtVariableReadImpl]wt.hasFlag([CtTypeAccessImpl]WeaponType.F_PLASMA_MFUK)) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]wt.hasFlag([CtTypeAccessImpl]WeaponType.F_FLAMER) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]wt.getAmmoType() == [CtFieldReadImpl]AmmoType.T_NA))) [CtBlockImpl]{
                [CtOperatorAssignmentImpl][CtVariableWriteImpl]total += [CtInvocationImpl][CtVariableReadImpl]m.getTonnage();
            }
        }
        [CtReturnImpl][CtCommentImpl]// Finally use that total to compute and return the actual power
        [CtCommentImpl]// amplifier weight.
        return [CtBinaryOperatorImpl][CtInvocationImpl][CtTypeAccessImpl]java.lang.Math.ceil([CtBinaryOperatorImpl][CtVariableReadImpl]total / [CtLiteralImpl]5) / [CtLiteralImpl]2;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]java.lang.Integer> getLoadedKeepers() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]loadedKeepers;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setLoadedKeepers([CtParameterImpl][CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]java.lang.Integer> v) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]loadedKeepers = [CtVariableReadImpl]v;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getExtraC3BV([CtParameterImpl][CtTypeReferenceImpl]int baseBV) [CtBlockImpl]{
        [CtLocalVariableImpl][CtCommentImpl]// extra from c3 networks. a valid network requires at least 2 members
        [CtCommentImpl]// some hackery and magic numbers here. could be better
        [CtCommentImpl]// also, each 'has' loops through all equipment. inefficient to do it 3
        [CtCommentImpl]// times
        [CtTypeReferenceImpl]int xbv = [CtLiteralImpl]0;
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtFieldReadImpl]game != [CtLiteralImpl]null) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]hasC3MM() && [CtBinaryOperatorImpl]([CtInvocationImpl]calculateFreeC3MNodes() < [CtLiteralImpl]2)) || [CtBinaryOperatorImpl]([CtInvocationImpl]hasC3M() && [CtBinaryOperatorImpl]([CtInvocationImpl]calculateFreeC3Nodes() < [CtLiteralImpl]3))) || [CtBinaryOperatorImpl]([CtInvocationImpl]hasC3S() && [CtBinaryOperatorImpl]([CtFieldReadImpl]c3Master > [CtFieldReadImpl]megamek.common.Entity.NONE))) || [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]hasC3i() || [CtInvocationImpl]hasNavalC3()) && [CtBinaryOperatorImpl]([CtInvocationImpl]calculateFreeC3Nodes() < [CtLiteralImpl]5)))) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]int totalForceBV = [CtLiteralImpl]0;
            [CtOperatorAssignmentImpl][CtVariableWriteImpl]totalForceBV += [CtVariableReadImpl]baseBV;
            [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity e : [CtInvocationImpl][CtFieldReadImpl]game.getC3NetworkMembers([CtThisAccessImpl]this)) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtUnaryOperatorImpl](![CtInvocationImpl]equals([CtVariableReadImpl]e)) && [CtInvocationImpl]onSameC3NetworkAs([CtVariableReadImpl]e)) [CtBlockImpl]{
                    [CtOperatorAssignmentImpl][CtVariableWriteImpl]totalForceBV += [CtInvocationImpl][CtVariableReadImpl]e.calculateBattleValue([CtLiteralImpl]true, [CtLiteralImpl]true);
                }
            }
            [CtLocalVariableImpl][CtTypeReferenceImpl]double multiplier = [CtLiteralImpl]0.05;
            [CtIfImpl]if ([CtInvocationImpl]hasBoostedC3()) [CtBlockImpl]{
                [CtAssignmentImpl][CtVariableWriteImpl]multiplier = [CtLiteralImpl]0.07;
            }
            [CtOperatorAssignmentImpl][CtVariableWriteImpl]xbv += [CtBinaryOperatorImpl][CtVariableReadImpl]totalForceBV * [CtVariableReadImpl]multiplier;
        }
        [CtReturnImpl]return [CtVariableReadImpl]xbv;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean hasUnloadedUnitsFromBays() [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Bay) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.Bay) (next)).getNumberUnloadedThisTurn() > [CtLiteralImpl]0)) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean getMovedBackwards() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]movedBackwards;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setMovedBackwards([CtParameterImpl][CtTypeReferenceImpl]boolean back) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]movedBackwards = [CtVariableReadImpl]back;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isPowerReverse() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]isPowerReverse;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setPowerReverse([CtParameterImpl][CtTypeReferenceImpl]boolean isPowerReverse) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.isPowerReverse = [CtVariableReadImpl]isPowerReverse;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Tracks whether a WiGE lifted off this turn (or a LAM hovered). Needed to track state
     * in case movement is continued from an interruption, so that the unit does not have a minimum
     * movement for the turn.
     *
     * @return whether a WiGE lifted off during this turn's movement
     */
    public [CtTypeReferenceImpl]boolean wigeLiftoffHover() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]wigeLiftoffHover;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setWigeLiftoffHover([CtParameterImpl][CtTypeReferenceImpl]boolean lifted) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]wigeLiftoffHover = [CtVariableReadImpl]lifted;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setHardenedArmorDamaged([CtParameterImpl][CtTypeReferenceImpl]megamek.common.HitData hit, [CtParameterImpl][CtTypeReferenceImpl]boolean damaged) [CtBlockImpl]{
        [CtAssignmentImpl][CtArrayWriteImpl][CtFieldReadImpl]hardenedArmorDamaged[[CtInvocationImpl][CtVariableReadImpl]hit.getLocation()] = [CtVariableReadImpl]damaged;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * do we have a half-hit hardened armor point in the location struck by
     * this?
     *
     * @param hit
     * @return  */
    public [CtTypeReferenceImpl]boolean isHardenedArmorDamaged([CtParameterImpl][CtTypeReferenceImpl]megamek.common.HitData hit) [CtBlockImpl]{
        [CtReturnImpl]return [CtArrayReadImpl][CtFieldReadImpl]hardenedArmorDamaged[[CtInvocationImpl][CtVariableReadImpl]hit.getLocation()];
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setLocationBlownOff([CtParameterImpl][CtTypeReferenceImpl]int loc, [CtParameterImpl][CtTypeReferenceImpl]boolean damaged) [CtBlockImpl]{
        [CtAssignmentImpl][CtArrayWriteImpl][CtFieldReadImpl]locationBlownOff[[CtVariableReadImpl]loc] = [CtVariableReadImpl]damaged;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isLocationBlownOff([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtReturnImpl]return [CtArrayReadImpl][CtFieldReadImpl]locationBlownOff[[CtVariableReadImpl]loc];
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Marks the location as blown off in the current phase. This should be
     * called together with {@link #setLocationBlownOff(int, boolean)} whenever
     * a location gets blown off <em>during play</em>, to allow relevant methods
     * (notably {@link #isLocationBad(int)}) to distinguish between fresh and
     * preexisting damage. A location's "newly blown off" status resets with the
     * next call to {@link #applyDamage()}.
     *
     * @param loc
     * 		Subclass-dependent code for the location.
     * @param damaged
     * 		The location's "recently blown off" status.
     */
    public [CtTypeReferenceImpl]void setLocationBlownOffThisPhase([CtParameterImpl][CtTypeReferenceImpl]int loc, [CtParameterImpl][CtTypeReferenceImpl]boolean damaged) [CtBlockImpl]{
        [CtAssignmentImpl][CtArrayWriteImpl][CtFieldReadImpl]locationBlownOffThisPhase[[CtVariableReadImpl]loc] = [CtVariableReadImpl]damaged;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Has the indicated location been blown off this phase (as opposed to
     * either earlier or not at all)?
     *
     * @param loc
     * 		Subclass-dependent code for the location.
     * @return The locations "recently blown off" status.
     */
    public [CtTypeReferenceImpl]boolean isLocationBlownOffThisPhase([CtParameterImpl][CtTypeReferenceImpl]int loc) [CtBlockImpl]{
        [CtReturnImpl]return [CtArrayReadImpl][CtFieldReadImpl]locationBlownOffThisPhase[[CtVariableReadImpl]loc];
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * does this entity have patchwork armor?
     *
     * @return  */
    public [CtTypeReferenceImpl]boolean hasPatchworkArmor() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int type = [CtArrayReadImpl][CtFieldReadImpl]armorType[[CtLiteralImpl]0];
        [CtLocalVariableImpl][CtTypeReferenceImpl]int level = [CtArrayReadImpl][CtFieldReadImpl]armorTechLevel[[CtLiteralImpl]0];
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]1; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtInvocationImpl]locations(); [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtArrayReadImpl][CtFieldReadImpl]armorType[[CtVariableReadImpl]i] != [CtVariableReadImpl]type) || [CtBinaryOperatorImpl]([CtArrayReadImpl][CtFieldReadImpl]armorTechLevel[[CtVariableReadImpl]i] != [CtVariableReadImpl]level)) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean hasHardenedArmor() [CtBlockImpl]{
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtInvocationImpl]locations(); [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtArrayReadImpl][CtFieldReadImpl]armorType[[CtVariableReadImpl]i] == [CtFieldReadImpl]EquipmentType.T_ARMOR_HARDENED) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Get the number of turns MASC has been used continuously.
     * <p/>
     * This method should <strong>only</strong> be used during serialization.
     *
     * @return the <code>int</code> number of turns MASC has been used.
     */
    public [CtTypeReferenceImpl]int getMASCTurns() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]nMASCLevel;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Set the number of turns MASC has been used continuously.
     * <p/>
     * This method should <strong>only</strong> be used during deserialization.
     *
     * @param turns
     * 		The <code>int</code> number of turns MASC has been used.
     */
    public [CtTypeReferenceImpl]void setMASCTurns([CtParameterImpl][CtTypeReferenceImpl]int turns) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]nMASCLevel = [CtVariableReadImpl]turns;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Determine if MASC has been used this turn.
     *
     * @return <code>true</code> if MASC has been used.
     */
    public [CtTypeReferenceImpl]boolean isMASCUsed() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]usedMASC;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Set whether MASC has been used.
     * <p/>
     * This method should <strong>only</strong> be used during deserialization.
     *
     * @param used
     * 		The <code>boolean</code> whether MASC has been used.
     */
    public [CtTypeReferenceImpl]void setMASCUsed([CtParameterImpl][CtTypeReferenceImpl]boolean used) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]usedMASC = [CtVariableReadImpl]used;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getMASCTarget() [CtBlockImpl]{
        [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVANCED_ALTERNATE_MASC_ENHANCED)) [CtBlockImpl]{
            [CtReturnImpl]return [CtArrayReadImpl][CtFieldReadImpl]megamek.common.Entity.ALTERNATE_MASC_FAILURE_ENHANCED[[CtFieldReadImpl]nMASCLevel];
        } else [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVANCED_ALTERNATE_MASC)) [CtBlockImpl]{
            [CtReturnImpl]return [CtArrayReadImpl][CtFieldReadImpl]megamek.common.Entity.ALTERNATE_MASC_FAILURE[[CtFieldReadImpl]nMASCLevel];
        } else [CtBlockImpl]{
            [CtReturnImpl]return [CtArrayReadImpl][CtFieldReadImpl]megamek.common.Entity.MASC_FAILURE[[CtFieldReadImpl]nMASCLevel];
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * This function cheks for masc failure.
     *
     * @param md
     * 		the movement path.
     * @param vDesc
     * 		the description off the masc failure. used as output.
     * @param vCriticals
     * 		contains tuple of intiger and critical slot. used as output.
     * @return true if there was a masc failure.
     */
    public [CtTypeReferenceImpl]boolean checkForMASCFailure([CtParameterImpl][CtTypeReferenceImpl]megamek.common.MovePath md, [CtParameterImpl][CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Report> vDesc, [CtParameterImpl][CtTypeReferenceImpl]java.util.HashMap<[CtTypeReferenceImpl]java.lang.Integer, [CtTypeReferenceImpl]java.util.List<[CtTypeReferenceImpl]megamek.common.CriticalSlot>> vCriticals) [CtBlockImpl]{
        [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]md.hasActiveMASC()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]boolean bFailure = [CtLiteralImpl]false;
            [CtIfImpl][CtCommentImpl]// If usedMASC is already set, then we've already checked MASC
            [CtCommentImpl]// this turn. If we succeded before, return false.
            [CtCommentImpl]// If we failed before, the MASC was destroyed, and we wouldn't
            [CtCommentImpl]// have gotten here (hasActiveMASC would return false)
            if ([CtUnaryOperatorImpl]![CtFieldReadImpl]usedMASC) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted masc = [CtInvocationImpl]getMASC();
                [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted superCharger = [CtInvocationImpl]getSuperCharger();
                [CtAssignmentImpl][CtVariableWriteImpl]bFailure = [CtInvocationImpl]doMASCCheckFor([CtVariableReadImpl]masc, [CtVariableReadImpl]vDesc, [CtVariableReadImpl]vCriticals);
                [CtLocalVariableImpl][CtTypeReferenceImpl]boolean bSuperChargeFailure = [CtInvocationImpl]doMASCCheckFor([CtVariableReadImpl]superCharger, [CtVariableReadImpl]vDesc, [CtVariableReadImpl]vCriticals);
                [CtAssignmentImpl][CtFieldWriteImpl]usedMASC = [CtLiteralImpl]true;
                [CtReturnImpl]return [CtBinaryOperatorImpl][CtVariableReadImpl]bFailure || [CtVariableReadImpl]bSuperChargeFailure;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * check one masc system for failure
     *
     * @param masc
     * @param vDesc
     * @param vCriticals
     * @return  */
    private [CtTypeReferenceImpl]boolean doMASCCheckFor([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Mounted masc, [CtParameterImpl][CtTypeReferenceImpl]java.util.Vector<[CtTypeReferenceImpl]megamek.common.Report> vDesc, [CtParameterImpl][CtTypeReferenceImpl]java.util.HashMap<[CtTypeReferenceImpl]java.lang.Integer, [CtTypeReferenceImpl]java.util.List<[CtTypeReferenceImpl]megamek.common.CriticalSlot>> vCriticals) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]masc != [CtLiteralImpl]null) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]masc.curMode().equals([CtLiteralImpl]"Armed")) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]boolean bFailure = [CtLiteralImpl]false;
            [CtLocalVariableImpl][CtTypeReferenceImpl]int nRoll = [CtInvocationImpl][CtTypeAccessImpl]megamek.common.Compute.d6([CtLiteralImpl]2);
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]masc.getType().hasSubType([CtTypeAccessImpl]MiscType.S_SUPERCHARGER) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Mech) && [CtInvocationImpl][CtThisAccessImpl](([CtTypeReferenceImpl]megamek.common.Mech) (this)).isIndustrial()) || [CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.SupportTank)) || [CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.SupportVTOL))) [CtBlockImpl]{
                [CtOperatorAssignmentImpl][CtVariableWriteImpl]nRoll -= [CtLiteralImpl]1;
            }
            [CtAssignmentImpl][CtFieldWriteImpl]usedMASC = [CtLiteralImpl]true;
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Report r = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.Report([CtLiteralImpl]2365);
            [CtAssignmentImpl][CtFieldWriteImpl][CtVariableWriteImpl]r.subject = [CtInvocationImpl]getId();
            [CtInvocationImpl][CtVariableReadImpl]r.addDesc([CtThisAccessImpl]this);
            [CtInvocationImpl][CtVariableReadImpl]r.add([CtInvocationImpl][CtVariableReadImpl]masc.getName());
            [CtInvocationImpl][CtVariableReadImpl]vDesc.addElement([CtVariableReadImpl]r);
            [CtAssignmentImpl][CtVariableWriteImpl]r = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.Report([CtLiteralImpl]2370);
            [CtAssignmentImpl][CtFieldWriteImpl][CtVariableWriteImpl]r.subject = [CtInvocationImpl]getId();
            [CtInvocationImpl][CtVariableReadImpl]r.indent();
            [CtInvocationImpl][CtVariableReadImpl]r.add([CtInvocationImpl]getMASCTarget());
            [CtInvocationImpl][CtVariableReadImpl]r.add([CtVariableReadImpl]nRoll);
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]nRoll < [CtInvocationImpl]getMASCTarget()) [CtBlockImpl]{
                [CtAssignmentImpl][CtCommentImpl]// uh oh
                [CtVariableWriteImpl]bFailure = [CtLiteralImpl]true;
                [CtInvocationImpl][CtVariableReadImpl]r.choose([CtLiteralImpl]false);
                [CtInvocationImpl][CtVariableReadImpl]vDesc.addElement([CtVariableReadImpl]r);
                [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.MiscType) ([CtVariableReadImpl]masc.getType())).hasSubType([CtTypeAccessImpl]MiscType.S_SUPERCHARGER)) [CtBlockImpl]{
                    [CtLocalVariableImpl][CtCommentImpl]// do the damage - engine crits
                    [CtTypeReferenceImpl]int hits = [CtLiteralImpl]0;
                    [CtLocalVariableImpl][CtTypeReferenceImpl]int roll = [CtInvocationImpl][CtTypeAccessImpl]megamek.common.Compute.d6([CtLiteralImpl]2);
                    [CtAssignmentImpl][CtVariableWriteImpl]r = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.Report([CtLiteralImpl]6310);
                    [CtAssignmentImpl][CtFieldWriteImpl][CtVariableWriteImpl]r.subject = [CtInvocationImpl]getId();
                    [CtInvocationImpl][CtVariableReadImpl]r.add([CtVariableReadImpl]roll);
                    [CtAssignmentImpl][CtFieldWriteImpl][CtVariableWriteImpl]r.newlines = [CtLiteralImpl]0;
                    [CtInvocationImpl][CtVariableReadImpl]vDesc.addElement([CtVariableReadImpl]r);
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]roll <= [CtLiteralImpl]7) [CtBlockImpl]{
                        [CtAssignmentImpl][CtCommentImpl]// no effect
                        [CtVariableWriteImpl]r = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.Report([CtLiteralImpl]6005);
                        [CtAssignmentImpl][CtFieldWriteImpl][CtVariableWriteImpl]r.subject = [CtInvocationImpl]getId();
                        [CtAssignmentImpl][CtFieldWriteImpl][CtVariableWriteImpl]r.newlines = [CtLiteralImpl]0;
                        [CtInvocationImpl][CtVariableReadImpl]vDesc.addElement([CtVariableReadImpl]r);
                    } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]roll >= [CtLiteralImpl]8) && [CtBinaryOperatorImpl]([CtVariableReadImpl]roll <= [CtLiteralImpl]9)) [CtBlockImpl]{
                        [CtAssignmentImpl][CtVariableWriteImpl]hits = [CtLiteralImpl]1;
                        [CtAssignmentImpl][CtVariableWriteImpl]r = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.Report([CtLiteralImpl]6315);
                        [CtAssignmentImpl][CtFieldWriteImpl][CtVariableWriteImpl]r.subject = [CtInvocationImpl]getId();
                        [CtAssignmentImpl][CtFieldWriteImpl][CtVariableWriteImpl]r.newlines = [CtLiteralImpl]0;
                        [CtInvocationImpl][CtVariableReadImpl]vDesc.addElement([CtVariableReadImpl]r);
                    } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]roll >= [CtLiteralImpl]10) && [CtBinaryOperatorImpl]([CtVariableReadImpl]roll <= [CtLiteralImpl]11)) [CtBlockImpl]{
                        [CtAssignmentImpl][CtVariableWriteImpl]hits = [CtLiteralImpl]2;
                        [CtAssignmentImpl][CtVariableWriteImpl]r = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.Report([CtLiteralImpl]6320);
                        [CtAssignmentImpl][CtFieldWriteImpl][CtVariableWriteImpl]r.subject = [CtInvocationImpl]getId();
                        [CtAssignmentImpl][CtFieldWriteImpl][CtVariableWriteImpl]r.newlines = [CtLiteralImpl]0;
                        [CtInvocationImpl][CtVariableReadImpl]vDesc.addElement([CtVariableReadImpl]r);
                    } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]roll == [CtLiteralImpl]12) [CtBlockImpl]{
                        [CtAssignmentImpl][CtVariableWriteImpl]hits = [CtLiteralImpl]3;
                        [CtAssignmentImpl][CtVariableWriteImpl]r = [CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.Report([CtLiteralImpl]6325);
                        [CtAssignmentImpl][CtFieldWriteImpl][CtVariableWriteImpl]r.subject = [CtInvocationImpl]getId();
                        [CtAssignmentImpl][CtFieldWriteImpl][CtVariableWriteImpl]r.newlines = [CtLiteralImpl]0;
                        [CtInvocationImpl][CtVariableReadImpl]vDesc.addElement([CtVariableReadImpl]r);
                    }
                    [CtIfImpl]if ([CtBinaryOperatorImpl][CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Mech) [CtBlockImpl]{
                        [CtInvocationImpl][CtVariableReadImpl]vCriticals.put([CtTypeAccessImpl]Mech.LOC_CT, [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.LinkedList<[CtTypeReferenceImpl]megamek.common.CriticalSlot>());
                        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]i < [CtLiteralImpl]12) && [CtBinaryOperatorImpl]([CtVariableReadImpl]hits > [CtLiteralImpl]0); [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
                            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.CriticalSlot cs = [CtInvocationImpl]getCritical([CtTypeAccessImpl]Mech.LOC_CT, [CtVariableReadImpl]i);
                            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]cs.getType() == [CtFieldReadImpl]CriticalSlot.TYPE_SYSTEM) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]cs.getIndex() == [CtFieldReadImpl]Mech.SYSTEM_ENGINE)) && [CtInvocationImpl][CtVariableReadImpl]cs.isHittable()) [CtBlockImpl]{
                                [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]vCriticals.get([CtTypeAccessImpl]Mech.LOC_CT).add([CtVariableReadImpl]cs);
                                [CtUnaryOperatorImpl][CtVariableWriteImpl]hits--;
                            }
                        }
                    } else [CtBlockImpl]{
                        [CtLocalVariableImpl][CtCommentImpl]// this must be a Tank
                        [CtTypeReferenceImpl]megamek.common.Tank tank = [CtThisAccessImpl](([CtTypeReferenceImpl]megamek.common.Tank) (this));
                        [CtLocalVariableImpl][CtTypeReferenceImpl]boolean vtolStabilizerHit = [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.VTOL) && [CtInvocationImpl][CtVariableReadImpl]tank.isStabiliserHit([CtTypeAccessImpl]VTOL.LOC_ROTOR);
                        [CtLocalVariableImpl][CtTypeReferenceImpl]boolean minorMovementDamage = [CtInvocationImpl][CtVariableReadImpl]tank.hasMinorMovementDamage();
                        [CtLocalVariableImpl][CtTypeReferenceImpl]boolean moderateMovementDamage = [CtInvocationImpl][CtVariableReadImpl]tank.hasModerateMovementDamage();
                        [CtLocalVariableImpl][CtTypeReferenceImpl]boolean heavyMovementDamage = [CtInvocationImpl][CtVariableReadImpl]tank.hasHeavyMovementDamage();
                        [CtInvocationImpl][CtVariableReadImpl]vCriticals.put([CtTypeAccessImpl]Tank.LOC_BODY, [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.LinkedList<>());
                        [CtInvocationImpl][CtVariableReadImpl]vCriticals.put([CtUnaryOperatorImpl]-[CtLiteralImpl]1, [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.LinkedList<>());
                        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]tank instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.VTOL) [CtBlockImpl]{
                            [CtInvocationImpl][CtVariableReadImpl]vCriticals.put([CtTypeAccessImpl]VTOL.LOC_ROTOR, [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.LinkedList<>());
                        }
                        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtVariableReadImpl]hits; [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
                            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]tank instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.VTOL) [CtBlockImpl]{
                                [CtIfImpl]if ([CtVariableReadImpl]vtolStabilizerHit) [CtBlockImpl]{
                                    [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]vCriticals.get([CtTypeAccessImpl]Tank.LOC_BODY).add([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.CriticalSlot([CtFieldReadImpl]CriticalSlot.TYPE_SYSTEM, [CtFieldReadImpl]Tank.CRIT_ENGINE));
                                } else [CtBlockImpl]{
                                    [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]vCriticals.get([CtTypeAccessImpl]VTOL.LOC_ROTOR).add([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.CriticalSlot([CtFieldReadImpl]CriticalSlot.TYPE_SYSTEM, [CtFieldReadImpl]VTOL.CRIT_FLIGHT_STABILIZER));
                                    [CtAssignmentImpl][CtVariableWriteImpl]vtolStabilizerHit = [CtLiteralImpl]true;
                                }
                            } else [CtIfImpl]if ([CtVariableReadImpl]heavyMovementDamage) [CtBlockImpl]{
                                [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]vCriticals.get([CtTypeAccessImpl]Tank.LOC_BODY).add([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.CriticalSlot([CtFieldReadImpl]CriticalSlot.TYPE_SYSTEM, [CtFieldReadImpl]Tank.CRIT_ENGINE));
                            } else [CtIfImpl]if ([CtVariableReadImpl]moderateMovementDamage) [CtBlockImpl]{
                                [CtInvocationImpl][CtCommentImpl]// HACK: we abuse the criticalslot item to
                                [CtCommentImpl]// signify the calling function to deal
                                [CtCommentImpl]// movement damage
                                [CtInvocationImpl][CtVariableReadImpl]vCriticals.get([CtUnaryOperatorImpl]-[CtLiteralImpl]1).add([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.CriticalSlot([CtFieldReadImpl]CriticalSlot.TYPE_SYSTEM, [CtLiteralImpl]3));
                                [CtAssignmentImpl][CtVariableWriteImpl]heavyMovementDamage = [CtLiteralImpl]true;
                            } else [CtIfImpl]if ([CtVariableReadImpl]minorMovementDamage) [CtBlockImpl]{
                                [CtInvocationImpl][CtCommentImpl]// HACK: we abuse the criticalslot item to
                                [CtCommentImpl]// signify the calling function to deal
                                [CtCommentImpl]// movement damage
                                [CtInvocationImpl][CtVariableReadImpl]vCriticals.get([CtUnaryOperatorImpl]-[CtLiteralImpl]1).add([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.CriticalSlot([CtFieldReadImpl]CriticalSlot.TYPE_SYSTEM, [CtLiteralImpl]2));
                                [CtAssignmentImpl][CtVariableWriteImpl]moderateMovementDamage = [CtLiteralImpl]true;
                            } else [CtBlockImpl]{
                                [CtInvocationImpl][CtCommentImpl]// HACK: we abuse the criticalslot item to
                                [CtCommentImpl]// signify the calling function to deal
                                [CtCommentImpl]// movement damage
                                [CtInvocationImpl][CtVariableReadImpl]vCriticals.get([CtUnaryOperatorImpl]-[CtLiteralImpl]1).add([CtConstructorCallImpl]new [CtTypeReferenceImpl]megamek.common.CriticalSlot([CtFieldReadImpl]CriticalSlot.TYPE_SYSTEM, [CtLiteralImpl]1));
                                [CtAssignmentImpl][CtVariableWriteImpl]minorMovementDamage = [CtLiteralImpl]true;
                            }
                        }
                    }
                } else [CtBlockImpl]{
                    [CtForImpl][CtCommentImpl]// do the damage.
                    [CtCommentImpl]// random crit on each leg, but MASC is not destroyed
                    for ([CtLocalVariableImpl][CtTypeReferenceImpl]int loc = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]loc < [CtInvocationImpl]locations(); [CtUnaryOperatorImpl][CtVariableWriteImpl]loc++) [CtBlockImpl]{
                        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]locationIsLeg([CtVariableReadImpl]loc) && [CtBinaryOperatorImpl]([CtInvocationImpl]getHittableCriticals([CtVariableReadImpl]loc) > [CtLiteralImpl]0)) [CtBlockImpl]{
                            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.CriticalSlot slot = [CtLiteralImpl]null;
                            [CtDoImpl]do [CtBlockImpl]{
                                [CtLocalVariableImpl][CtTypeReferenceImpl]int slotIndex = [CtInvocationImpl][CtTypeAccessImpl]megamek.common.Compute.randomInt([CtInvocationImpl]getNumberOfCriticals([CtVariableReadImpl]loc));
                                [CtAssignmentImpl][CtVariableWriteImpl]slot = [CtInvocationImpl]getCritical([CtVariableReadImpl]loc, [CtVariableReadImpl]slotIndex);
                            } while ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]slot == [CtLiteralImpl]null) || [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]slot.isHittable()) );
                            [CtInvocationImpl][CtVariableReadImpl]vCriticals.put([CtVariableReadImpl]loc, [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.LinkedList<>());
                            [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]vCriticals.get([CtVariableReadImpl]loc).add([CtVariableReadImpl]slot);
                        }
                    }
                }
                [CtInvocationImpl][CtCommentImpl]// failed a PSR, check for stalling
                doCheckEngineStallRoll([CtVariableReadImpl]vDesc);
            } else [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]r.choose([CtLiteralImpl]true);
                [CtInvocationImpl][CtVariableReadImpl]vDesc.addElement([CtVariableReadImpl]r);
            }
            [CtReturnImpl]return [CtVariableReadImpl]bFailure;
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * get non-supercharger MASC mounted on this entity
     *
     * @return  */
    public [CtTypeReferenceImpl]megamek.common.Mounted getMASC() [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getMisc()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.MiscType mtype = [CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.MiscType) ([CtVariableReadImpl]m.getType()));
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]mtype.hasFlag([CtTypeAccessImpl]MiscType.F_MASC) && [CtInvocationImpl][CtVariableReadImpl]m.isReady()) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]mtype.hasSubType([CtTypeAccessImpl]MiscType.S_SUPERCHARGER))) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]mtype.hasSubType([CtTypeAccessImpl]MiscType.S_JETBOOSTER))) [CtBlockImpl]{
                [CtReturnImpl]return [CtVariableReadImpl]m;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]null;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * get a supercharger mounted on this mech
     *
     * @return  */
    public [CtTypeReferenceImpl]megamek.common.Mounted getSuperCharger() [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getMisc()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.MiscType mtype = [CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.MiscType) ([CtVariableReadImpl]m.getType()));
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]mtype.hasFlag([CtTypeAccessImpl]MiscType.F_MASC) && [CtInvocationImpl][CtVariableReadImpl]m.isReady()) && [CtInvocationImpl][CtVariableReadImpl]mtype.hasSubType([CtTypeAccessImpl]MiscType.S_SUPERCHARGER)) [CtBlockImpl]{
                [CtReturnImpl]return [CtVariableReadImpl]m;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]null;
    }

    [CtMethodImpl]public abstract [CtTypeReferenceImpl]int getEngineHits();

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the number of destroyed jump jets.
     */
    public [CtTypeReferenceImpl]int damagedJumpJets() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int jumpJets = [CtLiteralImpl]0;
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted mounted : [CtInvocationImpl]getMisc()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.EquipmentType etype = [CtInvocationImpl][CtVariableReadImpl]mounted.getType();
            [CtIfImpl]if ([CtUnaryOperatorImpl]![CtInvocationImpl][CtVariableReadImpl]mounted.isDestroyed()) [CtBlockImpl]{
                [CtContinueImpl]continue;
            }
            [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]etype.hasFlag([CtTypeAccessImpl]MiscType.F_JUMP_JET)) [CtBlockImpl]{
                [CtUnaryOperatorImpl][CtVariableWriteImpl]jumpJets++;
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]jumpJets;
    }

    [CtMethodImpl]public abstract [CtTypeReferenceImpl]java.lang.String getLocationDamage([CtParameterImpl][CtTypeReferenceImpl]int loc);

    [CtMethodImpl][CtJavaDocImpl]/**
     * This method returns a true if the unit can reasonably escape from the
     * board. It can be used to determine whether some non-destroyed units
     * should be considered possible salvage.
     *
     * @return  */
    public [CtTypeReferenceImpl]boolean canEscape() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtLiteralImpl]null == [CtInvocationImpl]getCrew()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl][CtCommentImpl]// if the crew is unconscious, dead, or ejected, no escape
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl]getCrew().isUnconscious() || [CtInvocationImpl][CtInvocationImpl]getCrew().isDead()) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl]getCrew().isEjected() && [CtUnaryOperatorImpl](![CtBinaryOperatorImpl]([CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.EjectedCrew)))) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtReturnImpl][CtCommentImpl]// what else? If its permaneantly immobilized or shutdown it can't escape
        [CtCommentImpl]// TODO: should stalled and stuck be here?
        return [CtBinaryOperatorImpl][CtUnaryOperatorImpl](![CtInvocationImpl]isPermanentlyImmobilized([CtLiteralImpl]false)) && [CtUnaryOperatorImpl](![CtInvocationImpl]isShutDown());
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns TRUE if the entity meets the requirements for crippling damage as
     * detailed in TW pg 258.
     *
     * @return boolean
     */
    public abstract [CtTypeReferenceImpl]boolean isCrippled();

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns TRUE if the entity meets the requirements for crippling damage as
     * detailed in TW pg 258. Excepting dead or non-existing crew issues
     *
     * @return boolean
     */
    public abstract [CtTypeReferenceImpl]boolean isCrippled([CtParameterImpl][CtTypeReferenceImpl]boolean checkCrew);

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns TRUE if the entity has been heavily damaged.
     *
     * @return boolean
     */
    public abstract [CtTypeReferenceImpl]boolean isDmgHeavy();

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns TRUE if the entity has been moderately damaged.
     *
     * @return boolean
     */
    public abstract [CtTypeReferenceImpl]boolean isDmgModerate();

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns TRUE if the entity has been lightly damaged.
     *
     * @return boolean
     */
    public abstract [CtTypeReferenceImpl]boolean isDmgLight();

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the entity's current damage level.
     *
     * @return DMG_CRIPLED, DMG_HEAVY, DMG_MODERATE, DMG_LIGHT or DMG_NONE.
     */
    public [CtTypeReferenceImpl]int getDamageLevel() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getDamageLevel([CtLiteralImpl]true);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the entity's current damage level.
     *
     * @return DMG_CRIPLED, DMG_HEAVY, DMG_MODERATE, DMG_LIGHT or DMG_NONE.
     */
    public [CtTypeReferenceImpl]int getDamageLevel([CtParameterImpl][CtTypeReferenceImpl]boolean checkCrew) [CtBlockImpl]{
        [CtIfImpl]if ([CtInvocationImpl]isCrippled([CtVariableReadImpl]checkCrew)) [CtBlockImpl]{
            [CtReturnImpl]return [CtFieldReadImpl]megamek.common.Entity.DMG_CRIPPLED;
        }
        [CtIfImpl]if ([CtInvocationImpl]isDmgHeavy()) [CtBlockImpl]{
            [CtReturnImpl]return [CtFieldReadImpl]megamek.common.Entity.DMG_HEAVY;
        }
        [CtIfImpl]if ([CtInvocationImpl]isDmgModerate()) [CtBlockImpl]{
            [CtReturnImpl]return [CtFieldReadImpl]megamek.common.Entity.DMG_MODERATE;
        }
        [CtIfImpl]if ([CtInvocationImpl]isDmgLight()) [CtBlockImpl]{
            [CtReturnImpl]return [CtFieldReadImpl]megamek.common.Entity.DMG_LIGHT;
        }
        [CtReturnImpl]return [CtFieldReadImpl]megamek.common.Entity.DMG_NONE;
    }

    [CtMethodImpl][CtCommentImpl]// Make a UUID for this entity and assign it to entity's String c3UUID
    public [CtTypeReferenceImpl]void setC3UUID() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.UUID id = [CtInvocationImpl][CtTypeAccessImpl]java.util.UUID.randomUUID();
        [CtInvocationImpl]setC3UUIDAsString([CtInvocationImpl][CtVariableReadImpl]id.toString());
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setC3UUIDAsString([CtParameterImpl][CtTypeReferenceImpl]java.lang.String c3id) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]c3UUID = [CtVariableReadImpl]c3id;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.lang.String getC3UUIDAsString() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]c3UUID;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setC3MasterIsUUIDAsString([CtParameterImpl][CtTypeReferenceImpl]java.lang.String c3id) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]c3MasterIsUUID = [CtVariableReadImpl]c3id;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.lang.String getC3MasterIsUUIDAsString() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]c3MasterIsUUID;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setC3iNextUUIDAsString([CtParameterImpl][CtTypeReferenceImpl]int pos, [CtParameterImpl][CtTypeReferenceImpl]java.lang.String c3id) [CtBlockImpl]{
        [CtAssignmentImpl][CtArrayWriteImpl][CtFieldReadImpl]c3iUUIDs[[CtVariableReadImpl]pos] = [CtVariableReadImpl]c3id;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.lang.String getC3iNextUUIDAsString([CtParameterImpl][CtTypeReferenceImpl]int pos) [CtBlockImpl]{
        [CtReturnImpl]return [CtArrayReadImpl][CtFieldReadImpl]c3iUUIDs[[CtVariableReadImpl]pos];
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getFreeC3iUUID() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int pos = [CtLiteralImpl]0;
        [CtWhileImpl]while ([CtBinaryOperatorImpl][CtArrayReadImpl][CtFieldReadImpl]c3iUUIDs[[CtVariableReadImpl]pos] != [CtLiteralImpl]null) [CtBlockImpl]{
            [CtUnaryOperatorImpl][CtVariableWriteImpl]pos++;
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]pos >= [CtFieldReadImpl]megamek.common.Entity.MAX_C3i_NODES) [CtBlockImpl]{
                [CtReturnImpl]return [CtUnaryOperatorImpl]-[CtLiteralImpl]1;
            }
        } 
        [CtReturnImpl]return [CtVariableReadImpl]pos;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setNC3NextUUIDAsString([CtParameterImpl][CtTypeReferenceImpl]int pos, [CtParameterImpl][CtTypeReferenceImpl]java.lang.String c3id) [CtBlockImpl]{
        [CtAssignmentImpl][CtArrayWriteImpl][CtFieldReadImpl]NC3UUIDs[[CtVariableReadImpl]pos] = [CtVariableReadImpl]c3id;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.lang.String getNC3NextUUIDAsString([CtParameterImpl][CtTypeReferenceImpl]int pos) [CtBlockImpl]{
        [CtReturnImpl]return [CtArrayReadImpl][CtFieldReadImpl]NC3UUIDs[[CtVariableReadImpl]pos];
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getFreeNC3UUID() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int pos = [CtLiteralImpl]0;
        [CtWhileImpl]while ([CtBinaryOperatorImpl][CtArrayReadImpl][CtFieldReadImpl]NC3UUIDs[[CtVariableReadImpl]pos] != [CtLiteralImpl]null) [CtBlockImpl]{
            [CtUnaryOperatorImpl][CtVariableWriteImpl]pos++;
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]pos >= [CtFieldReadImpl]megamek.common.Entity.MAX_C3i_NODES) [CtBlockImpl]{
                [CtReturnImpl]return [CtUnaryOperatorImpl]-[CtLiteralImpl]1;
            }
        } 
        [CtReturnImpl]return [CtVariableReadImpl]pos;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Indicates if a unit was physically struck (punch, kick, DFA, etc).
     *
     * @return  */
    public [CtTypeReferenceImpl]boolean wasStruck() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]struck;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Indicates if a unit was physically struck (punch, kick, DFA, etc).
     *
     * @return  */
    public [CtTypeReferenceImpl]void setStruck([CtParameterImpl][CtTypeReferenceImpl]boolean struck) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.struck = [CtVariableReadImpl]struck;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Indicates if a unit has falling in the current phase.
     *
     * @return  */
    public [CtTypeReferenceImpl]boolean hasFallen() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]fell;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Indicates if a unit has falling in the current phase.
     *
     * @return  */
    public [CtTypeReferenceImpl]void setFallen([CtParameterImpl][CtTypeReferenceImpl]boolean fell) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.fell = [CtVariableReadImpl]fell;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * This is used to get an alternative cost that will be added to the
     * MechSummaryCache - at the moment it is primarily used to rework infantry
     * costs for MekHQ, but it could be applied to other unit types as well -
     * defaults to -1, so there is no confusion
     *
     * @return  */
    public [CtTypeReferenceImpl]double getAlternateCost() [CtBlockImpl]{
        [CtReturnImpl]return [CtUnaryOperatorImpl]-[CtLiteralImpl]1;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Are we trapped inside of a destroyed transport? If so we shouldn't count
     * for BV, which is why we have this check.
     */
    public [CtTypeReferenceImpl]boolean isTrapped() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]getTransportId() != [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity transport = [CtInvocationImpl][CtFieldReadImpl]game.getEntity([CtInvocationImpl]getTransportId());
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]transport == [CtLiteralImpl]null) [CtBlockImpl]{
                [CtAssignmentImpl][CtVariableWriteImpl]transport = [CtInvocationImpl][CtFieldReadImpl]game.getOutOfGameEntity([CtInvocationImpl]getTransportId());
            }
            [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]transport.isDestroyed()) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtCommentImpl]// Deal with per entity camo
    public [CtTypeReferenceImpl]void setCamoCategory([CtParameterImpl][CtTypeReferenceImpl]java.lang.String name) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]camoCategory = [CtVariableReadImpl]name;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.lang.String getCamoCategory() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]camoCategory;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setCamoFileName([CtParameterImpl][CtTypeReferenceImpl]java.lang.String name) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]camoFileName = [CtVariableReadImpl]name;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.lang.String getCamoFileName() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]camoFileName;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean getSelfDestructing() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]selfDestructing;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setSelfDestructing([CtParameterImpl][CtTypeReferenceImpl]boolean tf) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]selfDestructing = [CtVariableReadImpl]tf;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean getSelfDestructInitiated() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]selfDestructInitiated;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setSelfDestructInitiated([CtParameterImpl][CtTypeReferenceImpl]boolean tf) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]selfDestructInitiated = [CtVariableReadImpl]tf;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean getSelfDestructedThisTurn() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]selfDestructedThisTurn;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setSelfDestructedThisTurn([CtParameterImpl][CtTypeReferenceImpl]boolean tf) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]selfDestructedThisTurn = [CtVariableReadImpl]tf;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setIsJumpingNow([CtParameterImpl][CtTypeReferenceImpl]boolean jumped) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]isJumpingNow = [CtVariableReadImpl]jumped;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean getIsJumpingNow() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]isJumpingNow;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setConvertingNow([CtParameterImpl][CtTypeReferenceImpl]boolean converting) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]convertingNow = [CtVariableReadImpl]converting;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isConvertingNow() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]convertingNow;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getConversionMode() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]conversionMode;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Units capable of converting mode should override this to perform any other necessary changes.
     *
     * @param mode
     */
    public [CtTypeReferenceImpl]void setConversionMode([CtParameterImpl][CtTypeReferenceImpl]int mode) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]conversionMode = [CtVariableReadImpl]mode;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Entities that can convert movement modes (LAMs, QuadVees) report the next mode to assume
     * when a convert movement command is processed. This provides a set order for cycling through
     * available modes.
     *
     * @param afterMode
     * 		The movement mode to convert from.
     * @return The next movement mode in the sequence.
     */
    public [CtTypeReferenceImpl]megamek.common.EntityMovementMode nextConversionMode([CtParameterImpl][CtTypeReferenceImpl]megamek.common.EntityMovementMode afterMode) [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]movementMode;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Sets the movement mode to the next in the conversion sequence for QuadVees, LAMs, and Mechs
     * with tracks. In most cases this switches between two available modes, but LAMs that start
     * the turn in AirMech mode have three available.
     */
    public [CtTypeReferenceImpl]void toggleConversionMode() [CtBlockImpl]{
        [CtInvocationImpl]setMovementMode([CtInvocationImpl]nextConversionMode([CtFieldReadImpl]movementMode));
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Only applicable to Mechs, but here for convenience. Mechs that are already prone, or
     * QuadVees and LAMs in non-leg mode are not subject to PSRs for falling. Note that PSRs
     * are sometimes required for other reasons.
     *
     * @param gyroLegDamage
     * 		Whether the potential fall is due to damage to gyro or leg actuators,
     * 		in which case Mechs using tracks are not subject to falls.
     * @return Whether the <code>Entity</code> is required to make PSRs to avoid falling.
     */
    public [CtTypeReferenceImpl]boolean canFall([CtParameterImpl][CtTypeReferenceImpl]boolean gyroLegDamage) [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Only applicable to Mechs, but here for convenience. Mechs that are already prone, or
     * QuadVees and LAMs in fighter mode are not subject to PSRs for falling. Note that PSRs
     * are sometimes required for other reasons.
     *
     * @return Whether the <code>Entity</code> is required to make PSRs to avoid falling.
     */
    public [CtTypeReferenceImpl]boolean canFall() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]canFall([CtLiteralImpl]false);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setTraitorId([CtParameterImpl][CtTypeReferenceImpl]int id) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]traitorId = [CtVariableReadImpl]id;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getTraitorId() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]traitorId;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Used to determine net velocity of ramming attack
     */
    public [CtTypeReferenceImpl]int sideTableRam([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords src) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]sideTableRam([CtVariableReadImpl]src, [CtFieldReadImpl]facing);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int sideTableRam([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Coords src, [CtParameterImpl][CtTypeReferenceImpl]int facing) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int fa = [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl][CtInvocationImpl]getPosition().degree([CtVariableReadImpl]src) + [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtLiteralImpl]6 - [CtVariableReadImpl]facing) * [CtLiteralImpl]60)) % [CtLiteralImpl]360;
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]fa > [CtLiteralImpl]30) && [CtBinaryOperatorImpl]([CtVariableReadImpl]fa <= [CtLiteralImpl]90)) || [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]fa < [CtLiteralImpl]330) && [CtBinaryOperatorImpl]([CtVariableReadImpl]fa >= [CtLiteralImpl]270))) [CtBlockImpl]{
            [CtReturnImpl]return [CtFieldReadImpl]Aero.RAM_TOWARD_OBL;
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]fa > [CtLiteralImpl]150) && [CtBinaryOperatorImpl]([CtVariableReadImpl]fa < [CtLiteralImpl]210)) [CtBlockImpl]{
            [CtReturnImpl]return [CtFieldReadImpl]Aero.RAM_AWAY_DIR;
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]fa > [CtLiteralImpl]90) && [CtBinaryOperatorImpl]([CtVariableReadImpl]fa <= [CtLiteralImpl]150)) || [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]fa < [CtLiteralImpl]270) && [CtBinaryOperatorImpl]([CtVariableReadImpl]fa >= [CtLiteralImpl]210))) [CtBlockImpl]{
            [CtReturnImpl]return [CtFieldReadImpl]Aero.RAM_AWAY_OBL;
        } else [CtBlockImpl]{
            [CtReturnImpl]return [CtFieldReadImpl]Aero.RAM_TOWARD_DIR;
        }
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setArmorTonnage([CtParameterImpl][CtTypeReferenceImpl]double ton) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]armorTonnage = [CtVariableReadImpl]ton;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]double getLabArmorTonnage() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]armorTonnage;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getLabTotalArmorPoints() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl]isSupportVehicle() && [CtBinaryOperatorImpl]([CtInvocationImpl]getArmorType([CtInvocationImpl]firstArmorIndex()) == [CtFieldReadImpl]EquipmentType.T_ARMOR_STANDARD)) && [CtUnaryOperatorImpl](![CtInvocationImpl]hasPatchworkArmor())) [CtBlockImpl]{
            [CtReturnImpl]return [CtInvocationImpl](([CtTypeReferenceImpl]int) ([CtTypeAccessImpl]java.lang.Math.floor([CtBinaryOperatorImpl][CtFieldReadImpl]armorTonnage / [CtInvocationImpl][CtTypeAccessImpl]megamek.common.EquipmentType.getSupportVehicleArmorWeightPerPoint([CtInvocationImpl]getBARRating([CtInvocationImpl]firstArmorIndex()), [CtInvocationImpl]getArmorTechRating()))));
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]double armorPerTon = [CtBinaryOperatorImpl][CtLiteralImpl]16.0 * [CtInvocationImpl][CtTypeAccessImpl]megamek.common.EquipmentType.getArmorPointMultiplier([CtArrayReadImpl][CtFieldReadImpl]armorType[[CtLiteralImpl]0], [CtArrayReadImpl][CtFieldReadImpl]armorTechLevel[[CtLiteralImpl]0]);
        [CtReturnImpl]return [CtInvocationImpl](([CtTypeReferenceImpl]int) ([CtTypeAccessImpl]java.lang.Math.floor([CtBinaryOperatorImpl][CtVariableReadImpl]armorPerTon * [CtFieldReadImpl]armorTonnage)));
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void loadDefaultCustomWeaponOrder() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl][CtTypeReferenceImpl]megamek.common.WeaponOrderHandler.WeaponOrder weapOrder = [CtInvocationImpl][CtTypeAccessImpl]megamek.common.WeaponOrderHandler.getWeaponOrder([CtInvocationImpl]getChassis(), [CtInvocationImpl]getModel());
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]weapOrder != [CtLiteralImpl]null) [CtBlockImpl]{
            [CtInvocationImpl]setWeaponSortOrder([CtFieldReadImpl][CtVariableReadImpl]weapOrder.orderType);
            [CtInvocationImpl]setCustomWeaponOrder([CtFieldReadImpl][CtVariableReadImpl]weapOrder.customWeaponOrderMap);
        }
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void loadDefaultQuirks() [CtBlockImpl]{
        [CtLocalVariableImpl][CtCommentImpl]// Get a list of quirks for this entity.
        [CtTypeReferenceImpl]java.util.List<[CtTypeReferenceImpl]megamek.common.QuirkEntry> quirks = [CtInvocationImpl][CtTypeAccessImpl]megamek.common.QuirksHandler.getQuirks([CtThisAccessImpl]this);
        [CtIfImpl][CtCommentImpl]// If this unit has no quirks, we do not need to proceed further.
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]quirks == [CtLiteralImpl]null) || [CtInvocationImpl][CtVariableReadImpl]quirks.isEmpty()) [CtBlockImpl]{
            [CtReturnImpl]return;
        }
        [CtForEachImpl][CtCommentImpl]// System.out.println("Loading quirks for " + getChassis() + " " +
        [CtCommentImpl]// getModel());
        [CtCommentImpl]// Load all the unit's quirks.
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.QuirkEntry q : [CtVariableReadImpl]quirks) [CtBlockImpl]{
            [CtIfImpl][CtCommentImpl]// System.out.print("  " + q.toLog() + "... ");
            [CtCommentImpl]// If the quirk doesn't have a location, then it is a unit quirk,
            [CtCommentImpl]// not a weapon quirk.
            if ([CtInvocationImpl][CtTypeAccessImpl]megamek.common.util.StringUtil.isNullOrEmpty([CtInvocationImpl][CtVariableReadImpl]q.getLocation())) [CtBlockImpl]{
                [CtIfImpl][CtCommentImpl]// Activate the unit quirk.
                if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl]getQuirks().getOption([CtInvocationImpl][CtVariableReadImpl]q.getQuirk()) == [CtLiteralImpl]null) [CtBlockImpl]{
                    [CtInvocationImpl][CtFieldReadImpl][CtTypeAccessImpl]java.lang.System.[CtFieldReferenceImpl]out.println([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]q.toLog() + [CtLiteralImpl]" failed for ") + [CtInvocationImpl]getChassis()) + [CtLiteralImpl]" ") + [CtInvocationImpl]getModel()) + [CtLiteralImpl]" - Invalid quirk!");
                    [CtContinueImpl]continue;
                }
                [CtInvocationImpl][CtInvocationImpl][CtInvocationImpl]getQuirks().getOption([CtInvocationImpl][CtVariableReadImpl]q.getQuirk()).setValue([CtLiteralImpl]true);
                [CtContinueImpl][CtCommentImpl]// System.out.println("Loaded.");
                continue;
            }
            [CtLocalVariableImpl][CtCommentImpl]// Get the weapon in the indicated location and slot.
            [CtCommentImpl]// System.out.print("Getting CriticalSlot... ");
            [CtTypeReferenceImpl]megamek.common.CriticalSlot cs = [CtInvocationImpl]getCritical([CtInvocationImpl]getLocationFromAbbr([CtInvocationImpl][CtVariableReadImpl]q.getLocation()), [CtInvocationImpl][CtVariableReadImpl]q.getSlot());
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]cs == [CtLiteralImpl]null) [CtBlockImpl]{
                [CtInvocationImpl][CtFieldReadImpl][CtTypeAccessImpl]java.lang.System.[CtFieldReferenceImpl]out.println([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]q.toLog() + [CtLiteralImpl]" failed for ") + [CtInvocationImpl]getChassis()) + [CtLiteralImpl]" ") + [CtInvocationImpl]getModel()) + [CtLiteralImpl]" - Critical slot (") + [CtInvocationImpl][CtVariableReadImpl]q.getLocation()) + [CtLiteralImpl]"-") + [CtInvocationImpl][CtVariableReadImpl]q.getSlot()) + [CtLiteralImpl]") did not load!");
                [CtContinueImpl]continue;
            }
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m = [CtInvocationImpl][CtVariableReadImpl]cs.getMount();
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]m == [CtLiteralImpl]null) [CtBlockImpl]{
                [CtInvocationImpl][CtFieldReadImpl][CtTypeAccessImpl]java.lang.System.[CtFieldReferenceImpl]out.println([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]q.toLog() + [CtLiteralImpl]" failed for ") + [CtInvocationImpl]getChassis()) + [CtLiteralImpl]" ") + [CtInvocationImpl]getModel()) + [CtLiteralImpl]" - Critical slot (") + [CtInvocationImpl][CtVariableReadImpl]q.getLocation()) + [CtLiteralImpl]"-") + [CtInvocationImpl][CtVariableReadImpl]q.getSlot()) + [CtLiteralImpl]") is empty!");
                [CtContinueImpl]continue;
            }
            [CtIfImpl][CtCommentImpl]// Make sure this is a weapon.
            [CtCommentImpl]// System.out.print("Getting WeaponType... ");
            if ([CtBinaryOperatorImpl][CtUnaryOperatorImpl](![CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.getType() instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.WeaponType)) && [CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_CLUB))) [CtBlockImpl]{
                [CtInvocationImpl][CtFieldReadImpl][CtTypeAccessImpl]java.lang.System.[CtFieldReferenceImpl]out.println([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]q.toLog() + [CtLiteralImpl]" failed for ") + [CtInvocationImpl]getChassis()) + [CtLiteralImpl]" ") + [CtInvocationImpl]getModel()) + [CtLiteralImpl]" - ") + [CtInvocationImpl][CtVariableReadImpl]m.getName()) + [CtLiteralImpl]" is not a weapon!");
                [CtContinueImpl]continue;
            }
            [CtLocalVariableImpl][CtCommentImpl]// Make sure it is the weapon we expect.
            [CtCommentImpl]// System.out.print("Matching weapon... ");
            [CtTypeReferenceImpl]boolean matchFound = [CtLiteralImpl]false;
            [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Enumeration<[CtTypeReferenceImpl]java.lang.String> typeNames = [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().getNames();
            [CtWhileImpl]while ([CtInvocationImpl][CtVariableReadImpl]typeNames.hasMoreElements()) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]java.lang.String typeName = [CtInvocationImpl][CtVariableReadImpl]typeNames.nextElement();
                [CtIfImpl][CtCommentImpl]// System.out.print(typeName + "... ");
                if ([CtInvocationImpl][CtVariableReadImpl]typeName.equals([CtInvocationImpl][CtVariableReadImpl]q.getWeaponName())) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]matchFound = [CtLiteralImpl]true;
                    [CtBreakImpl]break;
                }
            } 
            [CtIfImpl]if ([CtUnaryOperatorImpl]![CtVariableReadImpl]matchFound) [CtBlockImpl]{
                [CtInvocationImpl][CtFieldReadImpl][CtTypeAccessImpl]java.lang.System.[CtFieldReferenceImpl]out.println([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]q.toLog() + [CtLiteralImpl]" failed for ") + [CtInvocationImpl]getChassis()) + [CtLiteralImpl]" ") + [CtInvocationImpl]getModel()) + [CtLiteralImpl]" - ") + [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().getName()) + [CtLiteralImpl]" != ") + [CtInvocationImpl][CtVariableReadImpl]q.getWeaponName());
                [CtContinueImpl]continue;
            }
            [CtIfImpl][CtCommentImpl]// Activate the weapon quirk.
            [CtCommentImpl]// System.out.print("Activating quirk... ");
            if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getQuirks().getOption([CtInvocationImpl][CtVariableReadImpl]q.getQuirk()) == [CtLiteralImpl]null) [CtBlockImpl]{
                [CtInvocationImpl][CtFieldReadImpl][CtTypeAccessImpl]java.lang.System.[CtFieldReferenceImpl]out.println([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]q.toLog() + [CtLiteralImpl]" failed for ") + [CtInvocationImpl]getChassis()) + [CtLiteralImpl]" ") + [CtInvocationImpl]getModel()) + [CtLiteralImpl]" - Invalid quirk!");
                [CtContinueImpl]continue;
            }
            [CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getQuirks().getOption([CtInvocationImpl][CtVariableReadImpl]q.getQuirk()).setValue([CtLiteralImpl]true);
            [CtCommentImpl]// System.out.println("Loaded.");
        }
    }

    [CtMethodImpl][CtAnnotationImpl]@java.lang.Override
    public [CtTypeReferenceImpl]void newPhase([CtParameterImpl][CtTypeReferenceImpl][CtTypeReferenceImpl]megamek.common.IGame.Phase phase) [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getEquipment()) [CtBlockImpl]{
            [CtInvocationImpl][CtVariableReadImpl]m.newPhase([CtVariableReadImpl]phase);
        }
        [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl]getCrew().isDoomed()) [CtBlockImpl]{
            [CtInvocationImpl][CtInvocationImpl]getCrew().setDoomed([CtLiteralImpl]false);
            [CtInvocationImpl][CtInvocationImpl]getCrew().setDead([CtLiteralImpl]true);
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtThisAccessImpl]this instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.Tank) [CtBlockImpl]{
                [CtInvocationImpl]setCarcass([CtLiteralImpl]true);
                [CtInvocationImpl][CtThisAccessImpl](([CtTypeReferenceImpl]megamek.common.Tank) (this)).immobilize();
            } else [CtBlockImpl]{
                [CtInvocationImpl]setDestroyed([CtLiteralImpl]true);
            }
        }
        [CtInvocationImpl]setIsJumpingNow([CtLiteralImpl]false);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks to see if the entities' elevation is below the surface of a water
     * hex.
     *
     * @return True if the entity is underwater, else false.
     */
    public [CtTypeReferenceImpl]boolean isUnderwater() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.IHex occupiedHex = [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getBoard().getHex([CtInvocationImpl]getPosition());
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]occupiedHex.containsTerrain([CtTypeAccessImpl]Terrains.WATER) && [CtBinaryOperatorImpl]([CtInvocationImpl]relHeight() < [CtInvocationImpl][CtVariableReadImpl]occupiedHex.surface())) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]true;
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getTechLevelYear() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]game != [CtLiteralImpl]null) [CtBlockImpl]{
            [CtReturnImpl]return [CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().intOption([CtTypeAccessImpl]OptionsConstants.ALLOWED_YEAR);
        }
        [CtReturnImpl]return [CtFieldReadImpl]year;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getTargetBay() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]targetBay;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setTargetBay([CtParameterImpl][CtTypeReferenceImpl]int tb) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]targetBay = [CtVariableReadImpl]tb;
    }

    [CtMethodImpl]public abstract [CtTypeReferenceImpl]long getEntityType();

    [CtMethodImpl][CtJavaDocImpl]/**
     * Convenience method that checks whether a bit is set in the entity type field.
     *
     * @param flag
     * 		An ETYPE_* value
     * @return true if getEntityType() has the flag set
     */
    public [CtTypeReferenceImpl]boolean hasETypeFlag([CtParameterImpl][CtTypeReferenceImpl]long flag) [CtBlockImpl]{
        [CtReturnImpl]return [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtInvocationImpl]getEntityType() & [CtVariableReadImpl]flag) == [CtVariableReadImpl]flag;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Given an Entity type, return the name of the major class it belongs to
     * (eg: Mech, Aero, Tank, Infantry).
     *
     * @param typeId
     * 		The type Id to get a major name for
     * @return The major class name for the given type id
     */
    public static [CtTypeReferenceImpl]java.lang.String getEntityMajorTypeName([CtParameterImpl][CtTypeReferenceImpl]long typeId) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]typeId & [CtFieldReadImpl]megamek.common.Entity.ETYPE_MECH) == [CtFieldReadImpl]megamek.common.Entity.ETYPE_MECH) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"Mech";
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]typeId & [CtFieldReadImpl]megamek.common.Entity.ETYPE_AERO) == [CtFieldReadImpl]megamek.common.Entity.ETYPE_AERO) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"Aero";
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]typeId & [CtFieldReadImpl]megamek.common.Entity.ETYPE_VTOL) == [CtFieldReadImpl]megamek.common.Entity.ETYPE_VTOL) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"VTOL";
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]typeId & [CtFieldReadImpl]megamek.common.Entity.ETYPE_TANK) == [CtFieldReadImpl]megamek.common.Entity.ETYPE_TANK) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"Tank";
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]typeId & [CtFieldReadImpl]megamek.common.Entity.ETYPE_INFANTRY) == [CtFieldReadImpl]megamek.common.Entity.ETYPE_INFANTRY) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"Infantry";
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]typeId & [CtFieldReadImpl]megamek.common.Entity.ETYPE_PROTOMECH) == [CtFieldReadImpl]megamek.common.Entity.ETYPE_PROTOMECH) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"Protomech";
        } else [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"Unknown";
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the specific entity type name for the given type id
     * (eg: Biped Mech, Conventional Fighter, VTOL).
     *
     * @param typeId
     * @return  */
    public static [CtTypeReferenceImpl]java.lang.String getEntityTypeName([CtParameterImpl][CtTypeReferenceImpl]long typeId) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]typeId & [CtFieldReadImpl]megamek.common.Entity.ETYPE_BIPED_MECH) == [CtFieldReadImpl]megamek.common.Entity.ETYPE_BIPED_MECH) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"Biped Mech";
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]typeId & [CtFieldReadImpl]megamek.common.Entity.ETYPE_LAND_AIR_MECH) == [CtFieldReadImpl]megamek.common.Entity.ETYPE_LAND_AIR_MECH) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"Landair Mech";
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]typeId & [CtFieldReadImpl]megamek.common.Entity.ETYPE_QUAD_MECH) == [CtFieldReadImpl]megamek.common.Entity.ETYPE_QUAD_MECH) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"Quad Mech";
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]typeId & [CtFieldReadImpl]megamek.common.Entity.ETYPE_TRIPOD_MECH) == [CtFieldReadImpl]megamek.common.Entity.ETYPE_TRIPOD_MECH) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"Tripod Mech";
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]typeId & [CtFieldReadImpl]megamek.common.Entity.ETYPE_ARMLESS_MECH) == [CtFieldReadImpl]megamek.common.Entity.ETYPE_ARMLESS_MECH) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"Armless Mech";
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]typeId & [CtFieldReadImpl]megamek.common.Entity.ETYPE_MECH) == [CtFieldReadImpl]megamek.common.Entity.ETYPE_MECH) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"Mech";
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]typeId & [CtFieldReadImpl]megamek.common.Entity.ETYPE_JUMPSHIP) == [CtFieldReadImpl]megamek.common.Entity.ETYPE_JUMPSHIP) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"JumpShip";
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]typeId & [CtFieldReadImpl]megamek.common.Entity.ETYPE_WARSHIP) == [CtFieldReadImpl]megamek.common.Entity.ETYPE_WARSHIP) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"WarShip";
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]typeId & [CtFieldReadImpl]megamek.common.Entity.ETYPE_SPACE_STATION) == [CtFieldReadImpl]megamek.common.Entity.ETYPE_SPACE_STATION) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"Space Station";
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]typeId & [CtFieldReadImpl]megamek.common.Entity.ETYPE_CONV_FIGHTER) == [CtFieldReadImpl]megamek.common.Entity.ETYPE_CONV_FIGHTER) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"Conventional Fighter";
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]typeId & [CtFieldReadImpl]megamek.common.Entity.ETYPE_FIXED_WING_SUPPORT) == [CtFieldReadImpl]megamek.common.Entity.ETYPE_FIXED_WING_SUPPORT) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"Fixed Wing Support";
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]typeId & [CtFieldReadImpl]megamek.common.Entity.ETYPE_FIGHTER_SQUADRON) == [CtFieldReadImpl]megamek.common.Entity.ETYPE_FIGHTER_SQUADRON) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"Fighter Squadron";
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]typeId & [CtFieldReadImpl]megamek.common.Entity.ETYPE_SMALL_CRAFT) == [CtFieldReadImpl]megamek.common.Entity.ETYPE_SMALL_CRAFT) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"Small Craft";
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]typeId & [CtFieldReadImpl]megamek.common.Entity.ETYPE_DROPSHIP) == [CtFieldReadImpl]megamek.common.Entity.ETYPE_DROPSHIP) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"DropShip";
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]typeId & [CtFieldReadImpl]megamek.common.Entity.ETYPE_TELEMISSILE) == [CtFieldReadImpl]megamek.common.Entity.ETYPE_TELEMISSILE) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"Telemissile";
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]typeId & [CtFieldReadImpl]megamek.common.Entity.ETYPE_AERO) == [CtFieldReadImpl]megamek.common.Entity.ETYPE_AERO) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"Aerospace fighter";
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]typeId & [CtFieldReadImpl]megamek.common.Entity.ETYPE_BATTLEARMOR) == [CtFieldReadImpl]megamek.common.Entity.ETYPE_BATTLEARMOR) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"Battlearmor";
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]typeId & [CtFieldReadImpl]megamek.common.Entity.ETYPE_MECHWARRIOR) == [CtFieldReadImpl]megamek.common.Entity.ETYPE_MECHWARRIOR) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"Mechwarrior";
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]typeId & [CtFieldReadImpl]megamek.common.Entity.ETYPE_PROTOMECH) == [CtFieldReadImpl]megamek.common.Entity.ETYPE_PROTOMECH) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"ProtoMech";
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]typeId & [CtFieldReadImpl]megamek.common.Entity.ETYPE_INFANTRY) == [CtFieldReadImpl]megamek.common.Entity.ETYPE_INFANTRY) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"Infantry";
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]typeId & [CtFieldReadImpl]megamek.common.Entity.ETYPE_GUN_EMPLACEMENT) == [CtFieldReadImpl]megamek.common.Entity.ETYPE_GUN_EMPLACEMENT) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"Gun Emplacement";
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]typeId & [CtFieldReadImpl]megamek.common.Entity.ETYPE_SUPER_HEAVY_TANK) == [CtFieldReadImpl]megamek.common.Entity.ETYPE_SUPER_HEAVY_TANK) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"Superheavy Tank";
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]typeId & [CtFieldReadImpl]megamek.common.Entity.ETYPE_SUPPORT_TANK) == [CtFieldReadImpl]megamek.common.Entity.ETYPE_SUPPORT_TANK) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"Support Tank";
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]typeId & [CtFieldReadImpl]megamek.common.Entity.ETYPE_LARGE_SUPPORT_TANK) == [CtFieldReadImpl]megamek.common.Entity.ETYPE_LARGE_SUPPORT_TANK) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"Large Support Tank";
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]typeId & [CtFieldReadImpl]megamek.common.Entity.ETYPE_VTOL) == [CtFieldReadImpl]megamek.common.Entity.ETYPE_VTOL) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"VTOL";
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]typeId & [CtFieldReadImpl]megamek.common.Entity.ETYPE_SUPPORT_VTOL) == [CtFieldReadImpl]megamek.common.Entity.ETYPE_SUPPORT_VTOL) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"Support VTOL";
        } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]typeId & [CtFieldReadImpl]megamek.common.Entity.ETYPE_TANK) == [CtFieldReadImpl]megamek.common.Entity.ETYPE_TANK) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"Tank";
        } else [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]"Unknown";
        }
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void damageSystem([CtParameterImpl][CtTypeReferenceImpl]int type, [CtParameterImpl][CtTypeReferenceImpl]int slot, [CtParameterImpl][CtTypeReferenceImpl]int hits) [CtBlockImpl]{
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int loc = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]loc < [CtInvocationImpl]locations(); [CtUnaryOperatorImpl][CtVariableWriteImpl]loc++) [CtBlockImpl]{
            [CtInvocationImpl]damageSystem([CtVariableReadImpl]type, [CtVariableReadImpl]slot, [CtVariableReadImpl]loc, [CtVariableReadImpl]hits);
        }
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void damageSystem([CtParameterImpl][CtTypeReferenceImpl]int type, [CtParameterImpl][CtTypeReferenceImpl]int slot, [CtParameterImpl][CtTypeReferenceImpl]int loc, [CtParameterImpl][CtTypeReferenceImpl]int hits) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int nhits = [CtLiteralImpl]0;
        [CtForImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i = [CtLiteralImpl]0; [CtBinaryOperatorImpl][CtVariableReadImpl]i < [CtInvocationImpl]getNumberOfCriticals([CtVariableReadImpl]loc); [CtUnaryOperatorImpl][CtVariableWriteImpl]i++) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.CriticalSlot cs = [CtInvocationImpl]getCritical([CtVariableReadImpl]loc, [CtVariableReadImpl]i);
            [CtIfImpl][CtCommentImpl]// ignore empty & system slots
            if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]cs == [CtLiteralImpl]null) || [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]cs.getType() != [CtVariableReadImpl]type)) [CtBlockImpl]{
                [CtContinueImpl]continue;
            }
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m = [CtLiteralImpl]null;
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]type == [CtFieldReadImpl]CriticalSlot.TYPE_EQUIPMENT) [CtBlockImpl]{
                [CtAssignmentImpl][CtVariableWriteImpl]m = [CtInvocationImpl]getEquipment([CtVariableReadImpl]slot);
            }
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]type == [CtFieldReadImpl]CriticalSlot.TYPE_SYSTEM) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]cs.getIndex() == [CtVariableReadImpl]slot)) || [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]type == [CtFieldReadImpl]CriticalSlot.TYPE_EQUIPMENT) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]m.equals([CtInvocationImpl][CtVariableReadImpl]cs.getMount()) || [CtInvocationImpl][CtVariableReadImpl]m.equals([CtInvocationImpl][CtVariableReadImpl]cs.getMount2())))) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]nhits < [CtVariableReadImpl]hits) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]cs.setHit([CtLiteralImpl]true);
                    [CtInvocationImpl][CtVariableReadImpl]cs.setDestroyed([CtLiteralImpl]true);
                    [CtUnaryOperatorImpl][CtVariableWriteImpl]nhits++;
                } else [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]cs.setHit([CtLiteralImpl]false);
                    [CtInvocationImpl][CtVariableReadImpl]cs.setDestroyed([CtLiteralImpl]false);
                    [CtInvocationImpl][CtVariableReadImpl]cs.setRepairable([CtLiteralImpl]true);
                }
            }
        }
    }

    [CtMethodImpl][CtCommentImpl]// Most units cannot eject.
    [CtCommentImpl]// ToDo Look up ejection rules for ASF.
    public [CtTypeReferenceImpl]boolean isEjectionPossible() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getAllowedPhysicalAttacks() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtLiteralImpl]null != [CtFieldReadImpl]crew) && [CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.PILOT_MELEE_MASTER)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]2;
        }
        [CtReturnImpl]return [CtLiteralImpl]1;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * The max weapons range of this entity, taking into account whether or not
     * we're on an air/space map, using extreme range. Assumes target is not airborne
     * if we are on a ground map.
     *
     * @return  */
    public [CtTypeReferenceImpl]int getMaxWeaponRange() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl]getMaxWeaponRange([CtLiteralImpl]false);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * The max weapons range of this entity, taking into account whether or not
     * we're on an air/space map, using extreme range, and whether or not the target is
     * air borne.
     *
     * @param targetIsAirborne
     * @return  */
    public [CtTypeReferenceImpl]int getMaxWeaponRange([CtParameterImpl][CtTypeReferenceImpl]boolean targetIsAirborne) [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// Aeros on the ground map must shoot along their flight path, giving
        [CtCommentImpl]// them effectively 0 range
        if ([CtBinaryOperatorImpl][CtInvocationImpl]isAirborneAeroOnGroundMap() && [CtUnaryOperatorImpl](![CtVariableReadImpl]targetIsAirborne)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]0;
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]int maxRange = [CtLiteralImpl]0;
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtFieldReadImpl]megamek.common.Entity.ETYPE_MECH == [CtInvocationImpl]getEntityType()) || [CtBinaryOperatorImpl]([CtFieldReadImpl]megamek.common.Entity.ETYPE_INFANTRY == [CtInvocationImpl]getEntityType())) || [CtBinaryOperatorImpl]([CtFieldReadImpl]megamek.common.Entity.ETYPE_PROTOMECH == [CtInvocationImpl]getEntityType())) [CtBlockImpl]{
            [CtAssignmentImpl][CtCommentImpl]// account for physical attacks.
            [CtVariableWriteImpl]maxRange = [CtLiteralImpl]1;
        }
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted weapon : [CtInvocationImpl]getWeaponList()) [CtBlockImpl]{
            [CtIfImpl]if ([CtUnaryOperatorImpl]![CtInvocationImpl][CtVariableReadImpl]weapon.isReady()) [CtBlockImpl]{
                [CtContinueImpl]continue;
            }
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.WeaponType type = [CtInvocationImpl](([CtTypeReferenceImpl]megamek.common.WeaponType) ([CtVariableReadImpl]weapon.getType()));
            [CtLocalVariableImpl][CtTypeReferenceImpl]int range;
            [CtIfImpl]if ([CtInvocationImpl]isAirborne()) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]int rangeMultiplier = [CtConditionalImpl]([CtInvocationImpl][CtVariableReadImpl]type.isCapital()) ? [CtLiteralImpl]2 : [CtLiteralImpl]1;
                [CtOperatorAssignmentImpl][CtVariableWriteImpl]rangeMultiplier *= [CtConditionalImpl]([CtInvocationImpl]isAirborneAeroOnGroundMap()) ? [CtLiteralImpl]8 : [CtLiteralImpl]1;
                [CtAssignmentImpl][CtVariableWriteImpl]range = [CtBinaryOperatorImpl][CtArrayReadImpl][CtFieldReadImpl]WeaponType.AIRBORNE_WEAPON_RANGES[[CtInvocationImpl][CtVariableReadImpl]type.getMaxRange([CtVariableReadImpl]weapon)] * [CtVariableReadImpl]rangeMultiplier;
            } else [CtBlockImpl]{
                [CtAssignmentImpl][CtVariableWriteImpl]range = [CtConditionalImpl]([CtInvocationImpl][CtInvocationImpl][CtFieldReadImpl]game.getOptions().booleanOption([CtTypeAccessImpl]OptionsConstants.ADVCOMBAT_TACOPS_RANGE)) ? [CtInvocationImpl][CtVariableReadImpl]type.getExtremeRange() : [CtInvocationImpl][CtVariableReadImpl]type.getLongRange();
            }
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]range > [CtVariableReadImpl]maxRange) [CtBlockImpl]{
                [CtAssignmentImpl][CtVariableWriteImpl]maxRange = [CtVariableReadImpl]range;
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]maxRange;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getHeat() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]heat;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getTsempHitsThisTurn() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]tsempHitsThisTurn;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void addTsempHitThisTurn() [CtBlockImpl]{
        [CtUnaryOperatorImpl][CtFieldWriteImpl]tsempHitsThisTurn++;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getTsempEffect() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]tsempEffect;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setTsempEffect([CtParameterImpl][CtTypeReferenceImpl]int tsempEffect) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.tsempEffect = [CtVariableReadImpl]tsempEffect;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isFiredTsempThisTurn() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]firedTsempThisTurn;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setFiredTsempThisTurn([CtParameterImpl][CtTypeReferenceImpl]boolean firedTsempThisTurn) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.firedTsempThisTurn = [CtVariableReadImpl]firedTsempThisTurn;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean hasFiredTsemp() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]hasFiredTsemp;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setHasFiredTsemp([CtParameterImpl][CtTypeReferenceImpl]boolean hasFiredTSEMP) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]hasFiredTsemp = [CtVariableReadImpl]hasFiredTSEMP;
    }

    [CtMethodImpl][CtCommentImpl]/* Sets the number of rounds that the entity is affected by an ASEW missile
    @param turns - integer specifying the number of end phases that the effects last through
    Technically, about 1.5 turns elapse per the rules for ASEW missiles in TO
     */
    public [CtTypeReferenceImpl]void setASEWAffected([CtParameterImpl][CtTypeReferenceImpl]int turns) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]asewAffectedTurns = [CtVariableReadImpl]turns;
    }

    [CtMethodImpl][CtCommentImpl]/* Returns the number of rounds that the entity is affected by an ASEW missile */
    public [CtTypeReferenceImpl]int getASEWAffected() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]asewAffectedTurns;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean hasActivatedRadicalHS() [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getMisc()) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_RADICAL_HEATSINK) && [CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.curMode().equals([CtLiteralImpl]"On")) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void deactivateRadicalHS() [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted m : [CtInvocationImpl]getMisc()) [CtBlockImpl]{
            [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]m.getType().hasFlag([CtTypeAccessImpl]MiscType.F_RADICAL_HEATSINK)) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]m.setMode([CtLiteralImpl]"Off");
                [CtBreakImpl][CtCommentImpl]// Can only have one radical heat sink
                break;
            }
        }
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getConsecutiveRHSUses() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]consecutiveRHSUses;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setConsecutiveRHSUses([CtParameterImpl][CtTypeReferenceImpl]int consecutiveRHSUses) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.consecutiveRHSUses = [CtVariableReadImpl]consecutiveRHSUses;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean hasDamagedRHS() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]hasDamagedRHS;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setHasDamagedRHS([CtParameterImpl][CtTypeReferenceImpl]boolean hasDamagedRHS) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.hasDamagedRHS = [CtVariableReadImpl]hasDamagedRHS;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isUseGeometricBV() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]useGeometricBV;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setUseGeometricBV([CtParameterImpl][CtTypeReferenceImpl]boolean useGeometricBV) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.useGeometricBV = [CtVariableReadImpl]useGeometricBV;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isUseReducedOverheatModifierBV() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]useReducedOverheatModifierBV;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setUseReducedOverheatModifierBV([CtParameterImpl][CtTypeReferenceImpl]boolean useReducedOverheatModifierBV) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.useReducedOverheatModifierBV = [CtVariableReadImpl]useReducedOverheatModifierBV;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void addAttackedByThisTurn([CtParameterImpl][CtTypeReferenceImpl]int entityId) [CtBlockImpl]{
        [CtInvocationImpl][CtFieldReadImpl]attackedByThisTurn.add([CtVariableReadImpl]entityId);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void clearAttackedByThisTurn() [CtBlockImpl]{
        [CtInvocationImpl][CtFieldReadImpl]attackedByThisTurn.clear();
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.util.Collection<[CtTypeReferenceImpl]java.lang.Integer> getAttackedByThisTurn() [CtBlockImpl]{
        [CtReturnImpl]return [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.HashSet<>([CtFieldReadImpl]attackedByThisTurn);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]megamek.common.Entity.WeaponSortOrder getWeaponSortOrder() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]weaponSortOrder == [CtLiteralImpl]null) [CtBlockImpl]{
            [CtReturnImpl]return [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.WeaponSortOrder.[CtFieldReferenceImpl]DEFAULT;
        }
        [CtReturnImpl]return [CtFieldReadImpl]weaponSortOrder;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setWeaponSortOrder([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Entity.WeaponSortOrder weaponSortOrder) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]weaponSortOrder != [CtFieldReadImpl][CtThisAccessImpl]this.weaponSortOrder) [CtBlockImpl]{
            [CtInvocationImpl]setWeapOrderChanged([CtLiteralImpl]true);
        }
        [CtIfImpl][CtCommentImpl]// If sort mode is custom, and the custom order is null, create it
        [CtCommentImpl]// and make the order the same as default (based on eqId)
        if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]weaponSortOrder == [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.WeaponSortOrder.[CtFieldReferenceImpl]CUSTOM) && [CtBinaryOperatorImpl]([CtFieldReadImpl]customWeapOrder == [CtLiteralImpl]null)) [CtBlockImpl]{
            [CtAssignmentImpl][CtFieldWriteImpl]customWeapOrder = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.HashMap<[CtTypeReferenceImpl]java.lang.Integer, [CtTypeReferenceImpl]java.lang.Integer>();
            [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Mounted weap : [CtFieldReadImpl]weaponList) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]int eqId = [CtInvocationImpl]getEquipmentNum([CtVariableReadImpl]weap);
                [CtInvocationImpl][CtFieldReadImpl]customWeapOrder.put([CtVariableReadImpl]eqId, [CtVariableReadImpl]eqId);
            }
        }
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.weaponSortOrder = [CtVariableReadImpl]weaponSortOrder;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]java.util.Map<[CtTypeReferenceImpl]java.lang.Integer, [CtTypeReferenceImpl]java.lang.Integer> getCustomWeaponOrder() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]customWeapOrder;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setCustomWeaponOrder([CtParameterImpl][CtTypeReferenceImpl]java.util.Map<[CtTypeReferenceImpl]java.lang.Integer, [CtTypeReferenceImpl]java.lang.Integer> customWeapOrder) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.customWeapOrder = [CtVariableReadImpl]customWeapOrder;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getCustomWeaponOrder([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Mounted weapon) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]int eqId = [CtInvocationImpl]getEquipmentNum([CtVariableReadImpl]weapon);
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]customWeapOrder == [CtLiteralImpl]null) [CtBlockImpl]{
            [CtReturnImpl]return [CtVariableReadImpl]eqId;
        }
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.lang.Integer order = [CtInvocationImpl][CtFieldReadImpl]customWeapOrder.get([CtVariableReadImpl]eqId);
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]order == [CtLiteralImpl]null) [CtBlockImpl]{
            [CtReturnImpl]return [CtUnaryOperatorImpl]-[CtLiteralImpl]1;
        } else [CtBlockImpl]{
            [CtReturnImpl]return [CtVariableReadImpl]order;
        }
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setCustomWeaponOrder([CtParameterImpl][CtTypeReferenceImpl]megamek.common.Mounted weapon, [CtParameterImpl][CtTypeReferenceImpl]int order) [CtBlockImpl]{
        [CtInvocationImpl]setWeapOrderChanged([CtLiteralImpl]true);
        [CtLocalVariableImpl][CtTypeReferenceImpl]int eqId = [CtInvocationImpl]getEquipmentNum([CtVariableReadImpl]weapon);
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]eqId == [CtUnaryOperatorImpl](-[CtLiteralImpl]1)) [CtBlockImpl]{
            [CtReturnImpl]return;
        }
        [CtInvocationImpl][CtFieldReadImpl]customWeapOrder.put([CtVariableReadImpl]eqId, [CtVariableReadImpl]order);
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]boolean isWeapOrderChanged() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]weapOrderChanged;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setWeapOrderChanged([CtParameterImpl][CtTypeReferenceImpl]boolean weapOrderChanged) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.weapOrderChanged = [CtVariableReadImpl]weapOrderChanged;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getMpUsedLastRound() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]mpUsedLastRound;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setMpUsedLastRound([CtParameterImpl][CtTypeReferenceImpl]int mpUsedLastRound) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.mpUsedLastRound = [CtVariableReadImpl]mpUsedLastRound;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Flag that determines if the Entity is a support vehicle.
     *
     * @return  */
    public [CtTypeReferenceImpl]boolean isSupportVehicle() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     *
     * @return Whether the unit uses primitive or retrotech construction rules
     */
    public [CtTypeReferenceImpl]boolean isPrimitive() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getStructuralTechRating() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]structuralTechRating;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setStructuralTechRating([CtParameterImpl][CtTypeReferenceImpl]int structuralTechRating) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.structuralTechRating = [CtVariableReadImpl]structuralTechRating;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the base engine value for support vehicles, see TM pg 120.  Non
     * support vehicle Entities will return 0.
     *
     * @return  */
    public [CtTypeReferenceImpl]double getBaseEngineValue() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]0;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the base chassis value for support vehicles, see TM pg 120.  Non
     * support vehicle Entities will return 0.
     *
     * @return  */
    public [CtTypeReferenceImpl]double getBaseChassisValue() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]0;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getArmorTechRating() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]armorTechRating == [CtFieldReadImpl]megamek.common.Entity.USE_STRUCTURAL_RATING) [CtBlockImpl]{
            [CtReturnImpl]return [CtFieldReadImpl]structuralTechRating;
        }
        [CtReturnImpl]return [CtFieldReadImpl]armorTechRating;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setArmorTechRating([CtParameterImpl][CtTypeReferenceImpl]int armorTechRating) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.armorTechRating = [CtVariableReadImpl]armorTechRating;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int getEngineTechRating() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]engineTechRating == [CtFieldReadImpl]megamek.common.Entity.USE_STRUCTURAL_RATING) [CtBlockImpl]{
            [CtReturnImpl]return [CtFieldReadImpl]structuralTechRating;
        }
        [CtReturnImpl]return [CtFieldReadImpl]engineTechRating;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setEngineTechRating([CtParameterImpl][CtTypeReferenceImpl]int engineTechRating) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl][CtThisAccessImpl]this.engineTechRating = [CtVariableReadImpl]engineTechRating;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Used by omni support vehicles to track the weight of fire control systems.
     * This limits the tonnage that can be devoted to weapons in pods.
     *
     * @return The fixed weight of fire control systems.
     */
    public [CtTypeReferenceImpl]double getBaseChassisFireConWeight() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]baseChassisFireConWeight;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Used by omni support vehicles to set the weight of fixed fire control systems in the base chassis.
     *
     * @param weight
     * 		The weight of fixed fire control systems.
     */
    public [CtTypeReferenceImpl]void setBaseChassisFireConWeight([CtParameterImpl][CtTypeReferenceImpl]double weight) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]baseChassisFireConWeight = [CtVariableReadImpl]weight;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Units with construction data that varies by year (such as engine and control system weight
     * for some primitive aerospace units) require tracking the original build year separately
     * from the intro year for the model to account for refits that don't affect the core components.
     *
     * @return The year to use for core component construction data.
     */
    public [CtTypeReferenceImpl]int getOriginalBuildYear() [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtFieldReadImpl]originalBuildYear < [CtLiteralImpl]0) [CtBlockImpl]{
            [CtReturnImpl]return [CtFieldReadImpl]year;
        }
        [CtReturnImpl]return [CtFieldReadImpl]originalBuildYear;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]void setOriginalBuildYear([CtParameterImpl][CtTypeReferenceImpl]int year) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]originalBuildYear = [CtVariableReadImpl]year;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * This method (and getActiveSubEntities()) is meant for groups of entities handled as a
     * singular one. Examples include fighter squadrons on space maps or lances in BattleForce
     * game modes.
     * <p>
     * To check if a given entity consists of multiple sub-entities, use
     * <pre>
     * if(entity.getSubEntities().isPresent()) {
     *     ...
     * }
     * </pre>
     * To iterate over entities (if present), use:
     * <pre>
     * entity.getSubEntities().ifPresent(entities -> entities.forEach(
     *     subEntity -> {
     *         ...
     *     });
     * </pre>
     *
     * @return an optional collection of sub-entities, if this entity is considered a grouping of them.
     */
    public [CtTypeReferenceImpl]java.util.Optional<[CtTypeReferenceImpl]java.util.List<[CtTypeReferenceImpl]megamek.common.Entity>> getSubEntities() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtTypeAccessImpl]java.util.Optional.empty();
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * The default implementation calls getSubEntities(), then filters them. This might not be
     * the optimal code for many applications, so feel free to override both if needed.
     *
     * @return an optional collection of sub-entities, if this entity is considered a grouping of them,
    pre-filtered to only contain active (non-destroyed and non-doomed) entities.
     */
    public [CtTypeReferenceImpl]java.util.Optional<[CtTypeReferenceImpl]java.util.List<[CtTypeReferenceImpl]megamek.common.Entity>> getActiveSubEntities() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtInvocationImpl]getSubEntities().map([CtLambdaImpl]([CtParameterImpl]java.util.List<megamek.common.Entity> ents) -> [CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]ents.stream().filter([CtLambdaImpl]([CtParameterImpl]megamek.common.Entity ent) -> [CtUnaryOperatorImpl]![CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]ent.isDestroyed() || [CtInvocationImpl][CtVariableReadImpl]ent.isDoomed())).collect([CtInvocationImpl][CtTypeAccessImpl]java.util.stream.Collectors.toList()));
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Used to determine the draw priority of different Entity subclasses.
     * This allows different unit types to always be draw above/below other
     * types.
     *
     * @return  */
    public [CtTypeReferenceImpl]int getSpriteDrawPriority() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]0;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Entities that use different sprites for different modes should override this
     *
     * @return a code identifying the mode, or an empty string for the default sprite
     */
    public [CtTypeReferenceImpl]java.lang.String getTilesetModeString() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]"";
    }

    [CtMethodImpl][CtCommentImpl]// Tractors and trailers, tugs, etc
    [CtJavaDocImpl]/**
     * Used to determine if this vehicle can be towed by a tractor
     *
     * @return  */
    public [CtTypeReferenceImpl]boolean isTrailer() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Used to determine if this vehicle can be the engine/tractor
     * for a bunch of trailers
     *
     * @return  */
    public [CtTypeReferenceImpl]boolean isTractor() [CtBlockImpl]{
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns a list of Coords that need to be checked for entities that can be towed
     * This accounts for the hexes occupied by each entity in the 'train', plus hexes
     * in front of or behind each trailer hitch
     *
     * @return  */
    public [CtTypeReferenceImpl]java.util.Set<[CtTypeReferenceImpl]megamek.common.Coords> getHitchLocations() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.Set<[CtTypeReferenceImpl]megamek.common.Coords> trailerPos = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.HashSet<[CtTypeReferenceImpl]megamek.common.Coords>();
        [CtLocalVariableImpl][CtCommentImpl]// First, set up a list of all the entities in this train
        [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.Entity> thisTrain = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.ArrayList<>();
        [CtInvocationImpl][CtVariableReadImpl]thisTrain.add([CtThisAccessImpl]this);
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int id : [CtInvocationImpl]getAllTowedUnits()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity trailer = [CtInvocationImpl][CtFieldReadImpl]game.getEntity([CtVariableReadImpl]id);
            [CtInvocationImpl][CtVariableReadImpl]thisTrain.add([CtVariableReadImpl]trailer);
        }
        [CtForEachImpl][CtCommentImpl]// Check each Entity in the train for working hitches. When found, add the hex
        [CtCommentImpl]// that Entity is in and the hex the hitch faces.
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity e : [CtVariableReadImpl]thisTrain) [CtBlockImpl]{
            [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter t : [CtInvocationImpl][CtVariableReadImpl]e.getTransports()) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]t instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.TankTrailerHitch) && [CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]t.getUnused() > [CtLiteralImpl]0)) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]trailerPos.add([CtInvocationImpl][CtVariableReadImpl]e.getPosition());
                    [CtLocalVariableImpl][CtTypeReferenceImpl]int dir = [CtInvocationImpl][CtVariableReadImpl]e.getFacing();
                    [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.TankTrailerHitch) (t)).getRearMounted()) [CtBlockImpl]{
                        [CtAssignmentImpl][CtVariableWriteImpl]dir = [CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]dir + [CtLiteralImpl]3) % [CtLiteralImpl]6;
                    }
                    [CtInvocationImpl][CtVariableReadImpl]trailerPos.add([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]e.getPosition().translated([CtVariableReadImpl]dir));
                }
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]trailerPos;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Matches up a trailer hitch transporter with its Id #
     *
     * @param bayNumber
     * 		- the index of the transporter we're trying to find.
     * @returns the trailerhitch corresponding to the passed-in value
     */
    public [CtTypeReferenceImpl]megamek.common.TankTrailerHitch getHitchById([CtParameterImpl][CtTypeReferenceImpl]int bayNumber) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter transporter = [CtInvocationImpl][CtFieldReadImpl]transports.get([CtVariableReadImpl]bayNumber);
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]transporter instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.TankTrailerHitch) [CtBlockImpl]{
            [CtReturnImpl]return [CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.TankTrailerHitch) (transporter));
        }
        [CtReturnImpl]return [CtLiteralImpl]null;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Finds the trailer hitch transporter that is carrying a given entityId
     * Hitches move around in Transports on loading a saved game
     *
     * @param id
     * 		- the id of the loaded Entity we're trying to find
     * @returns the trailerhitch corresponding to the passed-in value
     */
    public [CtTypeReferenceImpl]megamek.common.TankTrailerHitch getHitchCarrying([CtParameterImpl][CtTypeReferenceImpl]int id) [CtBlockImpl]{
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]next instanceof [CtTypeAccessImpl][CtTypeReferenceImpl]megamek.common.TankTrailerHitch) [CtBlockImpl]{
                [CtIfImpl]if ([CtInvocationImpl][CtInvocationImpl][CtVariableReadImpl]next.getLoadedUnits().contains([CtInvocationImpl][CtFieldReadImpl]game.getEntity([CtVariableReadImpl]id))) [CtBlockImpl]{
                    [CtReturnImpl]return [CtVariableReadImpl](([CtTypeReferenceImpl]megamek.common.TankTrailerHitch) (next));
                }
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]null;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Adds a trailer hitch to any tracked or wheeled military vehicle, or SupportVee with
     * Tractor chassis mod that doesn't already have one
     */
    public [CtTypeReferenceImpl]void addTrailerHitchEquipment() [CtBlockImpl]{
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Determines if this vehicle is currently able to tow designated trailer.
     *
     * @param trailerId
     * 		- the ID of the <code>Entity</code> to be towed.
     * @return <code>true</code> if the trailer can be towed, <code>false</code>
    otherwise.
     */
    public [CtTypeReferenceImpl]boolean canTow([CtParameterImpl][CtTypeReferenceImpl]int trailerId) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity trailer = [CtInvocationImpl][CtFieldReadImpl]game.getEntity([CtVariableReadImpl]trailerId);
        [CtIfImpl][CtCommentImpl]// Null check
        if ([CtBinaryOperatorImpl][CtVariableReadImpl]trailer == [CtLiteralImpl]null) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl][CtCommentImpl]// Shouldn't be using this method if Trailer isn't a trailer
        if ([CtUnaryOperatorImpl]![CtInvocationImpl][CtVariableReadImpl]trailer.isTrailer()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl][CtCommentImpl]// Can't tow if we aren't a tractor
        if ([CtUnaryOperatorImpl]![CtInvocationImpl]isTractor()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl][CtCommentImpl]// If this entity is in a transport bay, it can't tow another
        if ([CtBinaryOperatorImpl][CtInvocationImpl]getTransportId() != [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl][CtCommentImpl]// If Trailer moved or is already being towed, discard it
        if ([CtUnaryOperatorImpl]![CtInvocationImpl][CtVariableReadImpl]trailer.isLoadableThisTurn()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl][CtCommentImpl]// Can't tow yourself, either.
        if ([CtInvocationImpl][CtVariableReadImpl]trailer.equals([CtThisAccessImpl]this)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl][CtCommentImpl]// one can only tow friendly units!
        if ([CtInvocationImpl][CtVariableReadImpl]trailer.isEnemyOf([CtThisAccessImpl]this)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtIfImpl][CtCommentImpl]// Can't tow if hitch and trailer aren't at the same elevation
        if ([CtBinaryOperatorImpl][CtInvocationImpl][CtVariableReadImpl]trailer.getElevation() != [CtInvocationImpl]getElevation()) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtLocalVariableImpl][CtCommentImpl]// If none of the above happen, assume that we can't tow the trailer...
        [CtTypeReferenceImpl]boolean result = [CtLiteralImpl]false;
        [CtLocalVariableImpl][CtCommentImpl]// First, set up a list of all the entities in this train
        [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.Entity> thisTrain = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.Entity>();
        [CtInvocationImpl][CtVariableReadImpl]thisTrain.add([CtThisAccessImpl]this);
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]int id : [CtInvocationImpl]getAllTowedUnits()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity tr = [CtInvocationImpl][CtFieldReadImpl]game.getEntity([CtVariableReadImpl]id);
            [CtInvocationImpl][CtVariableReadImpl]thisTrain.add([CtVariableReadImpl]tr);
        }
        [CtLocalVariableImpl][CtCommentImpl]// Add up the weight of all carried trailers. A tractor can tow a total tonnage equal to its own.
        [CtTypeReferenceImpl]double tractorWeight = [CtInvocationImpl]getWeight();
        [CtLocalVariableImpl][CtTypeReferenceImpl]double trailerWeight = [CtLiteralImpl]0;
        [CtForEachImpl][CtCommentImpl]// Add up what the tractor's already towing
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]int id : [CtInvocationImpl]getAllTowedUnits()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity tr = [CtInvocationImpl][CtFieldReadImpl]game.getEntity([CtVariableReadImpl]id);
            [CtOperatorAssignmentImpl][CtVariableWriteImpl]trailerWeight += [CtInvocationImpl][CtVariableReadImpl]tr.getWeight();
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]trailerWeight + [CtInvocationImpl][CtVariableReadImpl]trailer.getWeight()) > [CtVariableReadImpl]tractorWeight) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]false;
        }
        [CtLocalVariableImpl][CtCommentImpl]// Next, look for an empty hitch somewhere in the train
        [CtTypeReferenceImpl]boolean hitchFound = [CtLiteralImpl]false;
        [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity e : [CtVariableReadImpl]thisTrain) [CtBlockImpl]{
            [CtIfImpl][CtCommentImpl]// Quit looking if we've already found a valid hitch
            if ([CtVariableReadImpl]hitchFound) [CtBlockImpl]{
                [CtBreakImpl]break;
            }
            [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter t : [CtInvocationImpl][CtVariableReadImpl]e.getTransports()) [CtBlockImpl]{
                [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]t.canTow([CtVariableReadImpl]trailer)) [CtBlockImpl]{
                    [CtAssignmentImpl][CtVariableWriteImpl]result = [CtLiteralImpl]true;
                    [CtAssignmentImpl][CtVariableWriteImpl]hitchFound = [CtLiteralImpl]true;
                    [CtBreakImpl][CtCommentImpl]// stop looking
                    break;
                }
            }
        }
        [CtReturnImpl]return [CtVariableReadImpl]result;
    }

    [CtFieldImpl][CtJavaDocImpl]/**
     * Used with MoveStep.TOW to find and update the correct entity when adding it to a train
     */
    private [CtTypeReferenceImpl]int isTowing = [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE;

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the entity to be towed
     *
     * @return  */
    public [CtTypeReferenceImpl]int getTowing() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]isTowing;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Change the towed status of this entity
     *
     * @param id
     * 		- the ID of the entity being towed
     */
    public [CtTypeReferenceImpl]void setTowing([CtParameterImpl][CtTypeReferenceImpl]int id) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]isTowing = [CtVariableReadImpl]id;
    }

    [CtFieldImpl][CtJavaDocImpl]/**
     * The id of the powered tractor towing the whole train
     * this entity is part of. This will often be the same
     * entity as towedBy
     */
    private [CtTypeReferenceImpl]int tractor = [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE;

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the tractor towing the train this entity is part of
     *
     * @return  */
    public [CtTypeReferenceImpl]int getTractor() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]tractor;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Sets the tractor towing the train this entity is part of
     *
     * @param id
     * 		- id of the tractor towing this train
     */
    public [CtTypeReferenceImpl]void setTractor([CtParameterImpl][CtTypeReferenceImpl]int id) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]tractor = [CtVariableReadImpl]id;
    }

    [CtFieldImpl][CtJavaDocImpl]/**
     * The ID of the entity directly towing this one
     * Used to find and set the correct Transporter
     */
    private [CtTypeReferenceImpl]int towedBy = [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE;

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the Entity that is directly towing this one
     *
     * @return  */
    public [CtTypeReferenceImpl]int getTowedBy() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]towedBy;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Sets the Entity that is directly towing this one
     *
     * @param id
     * 		- the id of the Entity towing this trailer
     */
    public [CtTypeReferenceImpl]void setTowedBy([CtParameterImpl][CtTypeReferenceImpl]int id) [CtBlockImpl]{
        [CtAssignmentImpl][CtFieldWriteImpl]towedBy = [CtVariableReadImpl]id;
    }

    [CtFieldImpl][CtJavaDocImpl]/**
     * A list of entity IDs being towed behind this entity, if present
     *
     * Used to ensure all following trailers are disconnected if the train
     * is broken at this entity.
     */
    private [CtTypeReferenceImpl]java.util.List<[CtTypeReferenceImpl]java.lang.Integer> connectedUnits = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]java.lang.Integer>();

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns the entities towed behind this entity
     *
     * @return  */
    public [CtTypeReferenceImpl]java.util.List<[CtTypeReferenceImpl]java.lang.Integer> getConnectedUnits() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtTypeAccessImpl]java.util.Collections.unmodifiableList([CtFieldReadImpl]connectedUnits);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Attaches a trailer to this train
     *
     * @param id
     * 		- if of the entity to be added to this train
     */
    public [CtTypeReferenceImpl]void towUnit([CtParameterImpl][CtTypeReferenceImpl]int id) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity towed = [CtInvocationImpl][CtFieldReadImpl]game.getEntity([CtVariableReadImpl]id);
        [CtForEachImpl][CtCommentImpl]// Add this trailer to the connected list for all trailers already in this train
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]int tr : [CtInvocationImpl]getAllTowedUnits()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity trailer = [CtInvocationImpl][CtFieldReadImpl]game.getEntity([CtVariableReadImpl]tr);
            [CtInvocationImpl][CtFieldReadImpl][CtVariableReadImpl]trailer.connectedUnits.add([CtVariableReadImpl]id);
        }
        [CtInvocationImpl]addTowedUnit([CtVariableReadImpl]id);
        [CtInvocationImpl][CtVariableReadImpl]towed.setTractor([CtInvocationImpl][CtThisAccessImpl]this.getId());
        [CtLocalVariableImpl][CtCommentImpl]// Now, find the transporter and the actual towing entity (trailer or tractor)
        [CtTypeReferenceImpl]megamek.common.Entity towingEnt = [CtInvocationImpl][CtFieldReadImpl]game.getEntity([CtFieldReadImpl][CtVariableReadImpl]towed.towedBy);
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]towingEnt != [CtLiteralImpl]null) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter hitch = [CtInvocationImpl][CtVariableReadImpl]towingEnt.getHitchById([CtInvocationImpl][CtVariableReadImpl]towed.getTargetBay());
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]hitch != [CtLiteralImpl]null) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]hitch.load([CtVariableReadImpl]towed);
            }
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Detaches an entity from this entity's towing mechanism
     * also detaches all trailers behind this one from the whole
     * train
     *
     * @param id
     * 		- the id of entity to be detached
     */
    public [CtTypeReferenceImpl]void disconnectUnit([CtParameterImpl][CtTypeReferenceImpl]int id) [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity towed = [CtInvocationImpl][CtFieldReadImpl]game.getEntity([CtVariableReadImpl]id);
        [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity tractor = [CtInvocationImpl][CtFieldReadImpl]game.getEntity([CtInvocationImpl][CtVariableReadImpl]towed.getTractor());
        [CtInvocationImpl][CtCommentImpl]// Remove the designated trailer from the tractor's carried units
        removeTowedUnit([CtVariableReadImpl]id);
        [CtLocalVariableImpl][CtCommentImpl]// Now, find and empty the transporter on the actual towing entity (trailer or tractor)
        [CtTypeReferenceImpl]megamek.common.Entity towingEnt = [CtInvocationImpl][CtFieldReadImpl]game.getEntity([CtInvocationImpl][CtVariableReadImpl]towed.getTowedBy());
        [CtInvocationImpl][CtFieldReadImpl][CtVariableReadImpl]towingEnt.connectedUnits.clear();
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]towingEnt != [CtLiteralImpl]null) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter hitch = [CtInvocationImpl][CtVariableReadImpl]towingEnt.getHitchCarrying([CtVariableReadImpl]id);
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]hitch != [CtLiteralImpl]null) [CtBlockImpl]{
                [CtInvocationImpl][CtVariableReadImpl]hitch.unload([CtVariableReadImpl]towed);
            }
        }
        [CtForEachImpl][CtCommentImpl]// If there are other trailers behind the one being dropped, disconnect all of them
        [CtCommentImpl]// from the tractor and from each other, so they can be picked up again later
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]int i : [CtInvocationImpl][CtVariableReadImpl]towed.getConnectedUnits()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity trailer = [CtInvocationImpl][CtFieldReadImpl]game.getEntity([CtVariableReadImpl]i);
            [CtInvocationImpl][CtVariableReadImpl]trailer.setTractor([CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE);
            [CtInvocationImpl][CtVariableReadImpl]tractor.removeTowedUnit([CtVariableReadImpl]i);
            [CtAssignmentImpl][CtVariableWriteImpl]towingEnt = [CtInvocationImpl][CtFieldReadImpl]game.getEntity([CtInvocationImpl][CtVariableReadImpl]trailer.getTowedBy());
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]towingEnt != [CtLiteralImpl]null) [CtBlockImpl]{
                [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter hitch = [CtInvocationImpl][CtVariableReadImpl]towingEnt.getHitchCarrying([CtVariableReadImpl]i);
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]hitch != [CtLiteralImpl]null) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]hitch.unload([CtVariableReadImpl]trailer);
                }
            }
            [CtInvocationImpl][CtVariableReadImpl]trailer.setTowedBy([CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE);
            [CtInvocationImpl][CtFieldReadImpl][CtVariableReadImpl]trailer.connectedUnits.clear();
        }
        [CtInvocationImpl][CtCommentImpl]// Update these last, or we get concurrency issues
        [CtVariableReadImpl]towed.setTractor([CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE);
        [CtInvocationImpl][CtVariableReadImpl]towed.setTowedBy([CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE);
        [CtInvocationImpl][CtVariableReadImpl]towed.setTowing([CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE);
        [CtInvocationImpl][CtFieldReadImpl][CtVariableReadImpl]towed.connectedUnits.clear();
    }

    [CtFieldImpl][CtJavaDocImpl]/**
     * A list of all the entity IDs towed by this entity,
     * including those connected to other towed trailers
     *
     * Use this for the tractor/engine/tug
     */
    private [CtTypeReferenceImpl]java.util.List<[CtTypeReferenceImpl]java.lang.Integer> isTractorFor = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]java.lang.Integer>();

    [CtMethodImpl][CtJavaDocImpl]/**
     * Returns a list of all entities towed behind this tractor.
     *
     * @return  */
    public [CtTypeReferenceImpl]java.util.List<[CtTypeReferenceImpl]java.lang.Integer> getAllTowedUnits() [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtTypeAccessImpl]java.util.Collections.unmodifiableList([CtFieldReadImpl]isTractorFor);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Adds an entity to this tractor's train
     */
    public [CtTypeReferenceImpl]void addTowedUnit([CtParameterImpl][CtTypeReferenceImpl]int id) [CtBlockImpl]{
        [CtInvocationImpl][CtFieldReadImpl]isTractorFor.add([CtVariableReadImpl]id);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Removes an entity from this tractor's train
     */
    public [CtTypeReferenceImpl]void removeTowedUnit([CtParameterImpl][CtTypeReferenceImpl]int id) [CtBlockImpl]{
        [CtInvocationImpl][CtFieldReadImpl]isTractorFor.remove([CtInvocationImpl][CtFieldReadImpl]isTractorFor.indexOf([CtVariableReadImpl]id));
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtInvocationImpl]getTowing() == [CtVariableReadImpl]id) [CtBlockImpl]{
            [CtInvocationImpl]setTowing([CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE);
        }
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Get a <code>List</code> of the trailers currently loaded into this payload.
     *
     * @return A <code>List</code> of loaded <code>Entity</code> units. This
    list will never be <code>null</code>, but it may be empty. The
    returned <code>List</code> is independant from the under- lying
    data structure; modifying one does not affect the other.

    This will only return loaded trailers
     */
    public [CtTypeReferenceImpl]java.util.List<[CtTypeReferenceImpl]megamek.common.Entity> getLoadedTrailers() [CtBlockImpl]{
        [CtLocalVariableImpl][CtTypeReferenceImpl]java.util.List<[CtTypeReferenceImpl]megamek.common.Entity> result = [CtConstructorCallImpl]new [CtTypeReferenceImpl]java.util.ArrayList<[CtTypeReferenceImpl]megamek.common.Entity>();
        [CtForEachImpl][CtCommentImpl]// Walk through this entity's transport components;
        [CtCommentImpl]// add any trailers we find there
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next : [CtFieldReadImpl]transports) [CtBlockImpl]{
            [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity e : [CtInvocationImpl][CtVariableReadImpl]next.getLoadedUnits()) [CtBlockImpl]{
                [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]e.isTrailer()) [CtBlockImpl]{
                    [CtInvocationImpl][CtVariableReadImpl]result.add([CtVariableReadImpl]e);
                }
            }
        }
        [CtForEachImpl][CtCommentImpl]// Now do the same for any additional trailers being carried by those trailers
        for ([CtLocalVariableImpl][CtTypeReferenceImpl]int id : [CtInvocationImpl]getAllTowedUnits()) [CtBlockImpl]{
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity trailer = [CtInvocationImpl][CtFieldReadImpl]game.getEntity([CtVariableReadImpl]id);
            [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Transporter next : [CtFieldReadImpl][CtVariableReadImpl]trailer.transports) [CtBlockImpl]{
                [CtForEachImpl]for ([CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.Entity e : [CtInvocationImpl][CtVariableReadImpl]next.getLoadedUnits()) [CtBlockImpl]{
                    [CtIfImpl]if ([CtInvocationImpl][CtVariableReadImpl]e.isTrailer()) [CtBlockImpl]{
                        [CtInvocationImpl][CtVariableReadImpl]result.add([CtVariableReadImpl]e);
                    }
                }
            }
        }
        [CtReturnImpl][CtCommentImpl]// Return the list.
        return [CtVariableReadImpl]result;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Determine if a connected tractor/trailer prevents a weapon in the given location
     * from firing.
     *
     * @param loc
     * 		- the <code>int</code> location attempting to fire.
     * @param secondaryFacing
     * 		- the <code>int</code> direction the turret is facing if the weapon is mounted there.
     * @param isRear
     * 		- a <code>boolean</code> value stating if the given location
     * 		is rear facing; if <code>false</code>, the location is front
     * 		facing.
     * @return <code>true</code> if a tractor/trailer unit is in the way,
    <code>false</code> if the weapon can fire.
     */
    public [CtTypeReferenceImpl]boolean isWeaponBlockedByTowing([CtParameterImpl][CtTypeReferenceImpl]int loc, [CtParameterImpl][CtTypeReferenceImpl]int secondaryFacing, [CtParameterImpl][CtTypeReferenceImpl]boolean isRear) [CtBlockImpl]{
        [CtIfImpl][CtCommentImpl]// Per TW p205, assume our trailer is being towed from the front.
        if ([CtBinaryOperatorImpl][CtInvocationImpl]getTowedBy() != [CtFieldReadImpl][CtTypeAccessImpl]megamek.common.Entity.[CtFieldReferenceImpl]NONE) [CtBlockImpl]{
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtVariableReadImpl]loc == [CtFieldReadImpl]Tank.LOC_FRONT) || [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]loc == [CtFieldReadImpl]Tank.LOC_TURRET) || [CtBinaryOperatorImpl]([CtVariableReadImpl]loc == [CtFieldReadImpl]Tank.LOC_TURRET_2)) || [CtBinaryOperatorImpl]([CtVariableReadImpl]loc == [CtFieldReadImpl]SuperHeavyTank.LOC_TURRET)) || [CtBinaryOperatorImpl]([CtVariableReadImpl]loc == [CtFieldReadImpl]SuperHeavyTank.LOC_TURRET_2)) && [CtBinaryOperatorImpl]([CtVariableReadImpl]secondaryFacing == [CtInvocationImpl]getFacing()))) [CtBlockImpl]{
                [CtReturnImpl]return [CtLiteralImpl]true;
            }
        }
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl]getAllTowedUnits().isEmpty()) || [CtUnaryOperatorImpl](![CtInvocationImpl][CtInvocationImpl]getConnectedUnits().isEmpty())) [CtBlockImpl]{
            [CtLocalVariableImpl][CtCommentImpl]// If we're towing something, check for a front or rear hitch
            [CtTypeReferenceImpl]megamek.common.Entity towed = [CtLiteralImpl]null;
            [CtIfImpl]if ([CtUnaryOperatorImpl]![CtInvocationImpl][CtInvocationImpl]getAllTowedUnits().isEmpty()) [CtBlockImpl]{
                [CtAssignmentImpl][CtVariableWriteImpl]towed = [CtInvocationImpl][CtFieldReadImpl]game.getEntity([CtInvocationImpl][CtInvocationImpl]getAllTowedUnits().get([CtLiteralImpl]0));
            } else [CtBlockImpl]{
                [CtAssignmentImpl][CtVariableWriteImpl]towed = [CtInvocationImpl][CtFieldReadImpl]game.getEntity([CtInvocationImpl][CtInvocationImpl]getConnectedUnits().get([CtLiteralImpl]0));
            }
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]towed == [CtLiteralImpl]null) [CtBlockImpl]{
                [CtReturnImpl][CtCommentImpl]// shouldn't happen, but just in case
                return [CtLiteralImpl]false;
            }
            [CtLocalVariableImpl][CtTypeReferenceImpl]megamek.common.TankTrailerHitch hitch = [CtInvocationImpl]getHitchCarrying([CtInvocationImpl][CtVariableReadImpl]towed.getId());
            [CtIfImpl]if ([CtBinaryOperatorImpl][CtVariableReadImpl]hitch != [CtLiteralImpl]null) [CtBlockImpl]{
                [CtIfImpl]if ([CtBinaryOperatorImpl][CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl][CtVariableReadImpl]hitch.getRearMounted() && [CtBinaryOperatorImpl]([CtVariableReadImpl]loc == [CtFieldReadImpl]Tank.LOC_REAR)) || [CtVariableReadImpl]isRear) || [CtBinaryOperatorImpl]([CtVariableReadImpl]loc == [CtFieldReadImpl]SuperHeavyTank.LOC_REAR)) || [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]loc == [CtFieldReadImpl]Tank.LOC_TURRET) || [CtBinaryOperatorImpl]([CtVariableReadImpl]loc == [CtFieldReadImpl]Tank.LOC_TURRET_2)) || [CtBinaryOperatorImpl]([CtVariableReadImpl]loc == [CtFieldReadImpl]SuperHeavyTank.LOC_TURRET)) || [CtBinaryOperatorImpl]([CtVariableReadImpl]loc == [CtFieldReadImpl]SuperHeavyTank.LOC_TURRET_2)) && [CtBinaryOperatorImpl]([CtVariableReadImpl]secondaryFacing == [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtInvocationImpl]getFacing() + [CtLiteralImpl]3) % [CtLiteralImpl]6)))) [CtBlockImpl]{
                    [CtReturnImpl]return [CtLiteralImpl]true;
                } else [CtIfImpl]if ([CtBinaryOperatorImpl][CtUnaryOperatorImpl](![CtInvocationImpl][CtVariableReadImpl]hitch.getRearMounted()) && [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]loc == [CtFieldReadImpl]Tank.LOC_FRONT) || [CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtBinaryOperatorImpl]([CtVariableReadImpl]loc == [CtFieldReadImpl]Tank.LOC_TURRET) || [CtBinaryOperatorImpl]([CtVariableReadImpl]loc == [CtFieldReadImpl]Tank.LOC_TURRET_2)) || [CtBinaryOperatorImpl]([CtVariableReadImpl]loc == [CtFieldReadImpl]SuperHeavyTank.LOC_TURRET)) || [CtBinaryOperatorImpl]([CtVariableReadImpl]loc == [CtFieldReadImpl]SuperHeavyTank.LOC_TURRET_2)) && [CtBinaryOperatorImpl]([CtVariableReadImpl]secondaryFacing == [CtInvocationImpl]getFacing())))) [CtBlockImpl]{
                    [CtReturnImpl]return [CtLiteralImpl]true;
                }
            }
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * determine if an entity has an ability that is identified by its presence or absence only.
     * The entity may gain this ability from different places, not exclusively the crew.
     *
     * @param name
     * 		- name of the ability as recorded in the options
     * @return true if the entity has this ability from some source
     */
    public [CtTypeReferenceImpl]boolean hasAbility([CtParameterImpl][CtTypeReferenceImpl]java.lang.String name) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtLiteralImpl]null != [CtInvocationImpl]getCrew()) [CtBlockImpl]{
            [CtReturnImpl]return [CtInvocationImpl][CtInvocationImpl][CtInvocationImpl]getCrew().getOptions().booleanOption([CtVariableReadImpl]name);
        }
        [CtReturnImpl][CtCommentImpl]// TODO: look for the ability at the player level
        return [CtLiteralImpl]false;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * determine if an entity has an ability at a given level.
     * The entity may gain this ability from different places, not exclusively the crew.
     *
     * @param name
     * 		- name of the ability as recorded in the optionsme
     * @param choice
     * 		- A string indicating the given level being asked about
     * @return true if the entity has this ability at the given choice from some source
     */
    public [CtTypeReferenceImpl]boolean hasAbility([CtParameterImpl][CtTypeReferenceImpl]java.lang.String name, [CtParameterImpl][CtTypeReferenceImpl]java.lang.String choice) [CtBlockImpl]{
        [CtIfImpl]if ([CtBinaryOperatorImpl][CtLiteralImpl]null != [CtInvocationImpl]getCrew()) [CtBlockImpl]{
            [CtReturnImpl]return [CtInvocationImpl][CtInvocationImpl][CtInvocationImpl][CtInvocationImpl]getCrew().getOptions().stringOption([CtVariableReadImpl]name).equals([CtVariableReadImpl]choice);
        }
        [CtReturnImpl]return [CtLiteralImpl]false;
    }

    [CtMethodImpl]public [CtTypeReferenceImpl]int modifyPhysicalDamageForMeleeSpecialist() [CtBlockImpl]{
        [CtIfImpl]if ([CtUnaryOperatorImpl]![CtInvocationImpl]hasAbility([CtTypeAccessImpl]OptionsConstants.PILOT_MELEE_SPECIALIST)) [CtBlockImpl]{
            [CtReturnImpl]return [CtLiteralImpl]0;
        }
        [CtReturnImpl]return [CtLiteralImpl]1;
    }

    [CtMethodImpl][CtCommentImpl]// Getters and setters for sensor contacts and firing solutions. Currently only used in space combat
    [CtJavaDocImpl]/**
     * Retrieves the IDs of all entities that this entity has detected with sensors
     *
     * @return the contents of this entity's sensorContacts set
     */
    public [CtTypeReferenceImpl]java.util.Set<[CtTypeReferenceImpl]java.lang.Integer> getSensorContacts() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]sensorContacts;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks the sensorContacts set for a specific target's ID number
     *
     * @param targetId
     * 		the ID number of the target entity to check for
     * @return true if the entity's sensorContacts set contains the passed-in target ID
     */
    public [CtTypeReferenceImpl]boolean hasSensorContactFor([CtParameterImpl][CtTypeReferenceImpl]int targetId) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]sensorContacts.contains([CtVariableReadImpl]targetId);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Adds the specified target entity's ID to this entity's sensorContacts
     *
     * @param targetId
     * 		the ID number of the target entity to add
     */
    public [CtTypeReferenceImpl]void addSensorContact([CtParameterImpl][CtTypeReferenceImpl]int targetId) [CtBlockImpl]{
        [CtInvocationImpl][CtFieldReadImpl]sensorContacts.add([CtVariableReadImpl]targetId);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Removes the specified target entity's ID from this entity's sensorContacts
     *
     * @param targetIds
     * 		the ID number of the target entity to remove
     */
    public [CtTypeReferenceImpl]void removeSensorContact([CtParameterImpl][CtTypeReferenceImpl]java.util.Collection<[CtTypeReferenceImpl]java.lang.Integer> targetIds) [CtBlockImpl]{
        [CtInvocationImpl][CtFieldReadImpl]sensorContacts.removeAll([CtVariableReadImpl]targetIds);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Empties this entity's sensorContacts
     * Used when it dies or moves offboard
     */
    public [CtTypeReferenceImpl]void clearSensorContacts() [CtBlockImpl]{
        [CtInvocationImpl][CtFieldReadImpl]sensorContacts.clear();
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Retrieves the IDs of all entities that this entity has established firing solutions on
     *
     * @return the contents of this entity's firingSolutions set
     */
    public [CtTypeReferenceImpl]java.util.Set<[CtTypeReferenceImpl]java.lang.Integer> getFiringSolutions() [CtBlockImpl]{
        [CtReturnImpl]return [CtFieldReadImpl]firingSolutions;
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Checks the firingSolutions set for a specific target's ID number
     *
     * @param targetId
     * 		the ID number of the target entity to check for
     * @return true if the entity's firingSolutions set contains the passed-in target ID
     */
    public [CtTypeReferenceImpl]boolean hasFiringSolutionFor([CtParameterImpl][CtTypeReferenceImpl]int targetId) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]firingSolutions.contains([CtVariableReadImpl]targetId);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Adds the specified target entity's ID to this entity's firingSolutions
     *
     * @param targetId
     * 		the ID number of the target entity to add
     */
    public [CtTypeReferenceImpl]void addFiringSolution([CtParameterImpl][CtTypeReferenceImpl]int targetId) [CtBlockImpl]{
        [CtInvocationImpl][CtFieldReadImpl]firingSolutions.add([CtVariableReadImpl]targetId);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Removes the specified target entity's ID from this entity's firingSolutions
     *
     * @param targetIds
     * 		the ID number of the target entity to remove
     */
    public [CtTypeReferenceImpl]void removeFiringSolution([CtParameterImpl][CtTypeReferenceImpl]java.util.Collection<[CtTypeReferenceImpl]java.lang.Integer> targetIds) [CtBlockImpl]{
        [CtInvocationImpl][CtFieldReadImpl]firingSolutions.removeAll([CtVariableReadImpl]targetIds);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Empties this entity's firingSolutions
     * Used when it dies or moves offboard
     */
    public [CtTypeReferenceImpl]void clearFiringSolutions() [CtBlockImpl]{
        [CtInvocationImpl][CtFieldReadImpl]firingSolutions.clear();
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Indicate that an off-board artillery attack by this entity has been observed by a particular team
     */
    public [CtTypeReferenceImpl]void addOffBoardObserver([CtParameterImpl][CtTypeReferenceImpl]int teamID) [CtBlockImpl]{
        [CtInvocationImpl][CtFieldReadImpl]offBoardShotObservers.add([CtVariableReadImpl]teamID);
    }

    [CtMethodImpl][CtJavaDocImpl]/**
     * Has the given team observed an off-board artillery attack by this entity?
     */
    public [CtTypeReferenceImpl]boolean isOffBoardObserved([CtParameterImpl][CtTypeReferenceImpl]int teamID) [CtBlockImpl]{
        [CtReturnImpl]return [CtInvocationImpl][CtFieldReadImpl]offBoardShotObservers.contains([CtVariableReadImpl]teamID);
    }
}