{"pr_number": 16698, "pr_title": "Initial commit to add MultiMap bulk put feature request (#9079)", "pr_author": "abdulazizali77", "pr_createdAt": "2020-02-27T11:21:42Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/16698", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA2NzIwMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r385067201", "body": "In the public interface javadoc:\r\n- describe what the method's contract is. For example, this is the place to mention that there is no atomicity guarantee (some puts may have already been executed while puts in other partitions may still be ongoing, so clients may observe partial effects of this method).\r\n- do not commit to internal implementation details; the fact that the implementation will batch KVs by partition is an optimization that might be true for the current implementation however we want to be free to change implementation as needed.", "bodyText": "In the public interface javadoc:\n\ndescribe what the method's contract is. For example, this is the place to mention that there is no atomicity guarantee (some puts may have already been executed while puts in other partitions may still be ongoing, so clients may observe partial effects of this method).\ndo not commit to internal implementation details; the fact that the implementation will batch KVs by partition is an optimization that might be true for the current implementation however we want to be free to change implementation as needed.", "bodyHTML": "<p dir=\"auto\">In the public interface javadoc:</p>\n<ul dir=\"auto\">\n<li>describe what the method's contract is. For example, this is the place to mention that there is no atomicity guarantee (some puts may have already been executed while puts in other partitions may still be ongoing, so clients may observe partial effects of this method).</li>\n<li>do not commit to internal implementation details; the fact that the implementation will batch KVs by partition is an optimization that might be true for the current implementation however we want to be free to change implementation as needed.</li>\n</ul>", "author": "vbekiaris", "createdAt": "2020-02-27T11:24:46Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/MultiMap.java", "diffHunk": "@@ -57,6 +58,33 @@\n  */\n @SuppressWarnings(\"checkstyle:methodcount\")\n public interface MultiMap<K, V> extends BaseMultiMap<K, V> {\n+\n+    /**\n+     * Stores a Map in the multimap synchronously.\n+     * <p>\n+     * This method performs a bulk put into a MultiMap\n+     * by partitions similar to Map.putAllAsync", "originalCommit": "2b2dfd27152e08ea00364879267a44f5927999a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA2Nzc2OA==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r385067768", "body": "We expose `CompletionStage` as public return type for our async interface methods.\r\n\r\n```suggestion\r\n    CompletionStage<Void> putAllAsync(@Nonnull Map<? extends K, Collection<? extends V>> m);\r\n```", "bodyText": "We expose CompletionStage as public return type for our async interface methods.\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                InternalCompletableFuture<Void> putAllAsync(@Nonnull Map<? extends Object, Collection> m);\n          \n          \n            \n                CompletionStage<Void> putAllAsync(@Nonnull Map<? extends K, Collection<? extends V>> m);", "bodyHTML": "<p dir=\"auto\">We expose <code>CompletionStage</code> as public return type for our async interface methods.</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-k\"><span class=\"x x-first x-last\">InternalCompletableFuture</span>&lt;<span class=\"pl-smi\">Void</span>&gt;</span> putAllAsync(<span class=\"pl-k\">@Nonnull</span> <span class=\"pl-k\">Map&lt;? extends <span class=\"pl-smi x x-first x-last\">Object</span>, <span class=\"pl-smi\">Collection</span>&gt;</span> m);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\"><span class=\"x x-first x-last\">CompletionStage</span>&lt;<span class=\"pl-smi\">Void</span>&gt;</span> putAllAsync(<span class=\"pl-k\">@Nonnull</span> <span class=\"pl-k\">Map&lt;? extends <span class=\"pl-smi x x-first x-last\">K</span>, <span class=\"pl-k\">Collection<span class=\"x x-first\">&lt;? extends </span><span class=\"pl-smi x\">V</span><span class=\"x x-last\">&gt;</span></span>&gt;</span> m);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "vbekiaris", "createdAt": "2020-02-27T11:26:06Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/MultiMap.java", "diffHunk": "@@ -57,6 +58,33 @@\n  */\n @SuppressWarnings(\"checkstyle:methodcount\")\n public interface MultiMap<K, V> extends BaseMultiMap<K, V> {\n+\n+    /**\n+     * Stores a Map in the multimap synchronously.\n+     * <p>\n+     * This method performs a bulk put into a MultiMap\n+     * by partitions similar to Map.putAllAsync\n+     *\n+     * @param m the map to be stored\n+     */\n+    void putAll(@Nonnull Map<?, Collection> m);\n+\n+    /**\n+     * Stores a Map in the multimap aynchronously.\n+     * <p>\n+     * This method performs a bulk put into a MultiMap\n+     * by partitions similar to Map.putAllAsync.\n+     * <p>\n+     * <b>Warning:</b> The Map and result of the put cannot be fetched\n+     * from the Future.\n+     *\n+     * @param m the map to be stored\n+     * @return a void Future\n+     */\n+    //FIXME:should be narrowly generic, but as it were, MultiMapProxySupport is not genericized.\n+    //Another alternative is to pass in MultiMapValue\n+    InternalCompletableFuture<Void> putAllAsync(@Nonnull Map<? extends Object, Collection> m);", "originalCommit": "2b2dfd27152e08ea00364879267a44f5927999a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTEyNjg0Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r385126846", "body": "When adding new methods in minor versions, due to rolling-upgrade restrictions we need first to check if we are allowed to run the method. In this case, one is only allowed to run the new method in version 4.1. So first instruction should be something like this:\r\n```\r\n    if (isClusterVersionLessThan(Versions.V4_1)) {\r\n        throw new UnsupportedOperationException(\"MultiMap#putAll is only available with cluster version 4.1 or greater\");\r\n    }\r\n```\r\n\r\n(same for `putAll` above)", "bodyText": "When adding new methods in minor versions, due to rolling-upgrade restrictions we need first to check if we are allowed to run the method. In this case, one is only allowed to run the new method in version 4.1. So first instruction should be something like this:\n    if (isClusterVersionLessThan(Versions.V4_1)) {\n        throw new UnsupportedOperationException(\"MultiMap#putAll is only available with cluster version 4.1 or greater\");\n    }\n\n(same for putAll above)", "bodyHTML": "<p dir=\"auto\">When adding new methods in minor versions, due to rolling-upgrade restrictions we need first to check if we are allowed to run the method. In this case, one is only allowed to run the new method in version 4.1. So first instruction should be something like this:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"    if (isClusterVersionLessThan(Versions.V4_1)) {\n        throw new UnsupportedOperationException(&quot;MultiMap#putAll is only available with cluster version 4.1 or greater&quot;);\n    }\n\"><pre><code>    if (isClusterVersionLessThan(Versions.V4_1)) {\n        throw new UnsupportedOperationException(\"MultiMap#putAll is only available with cluster version 4.1 or greater\");\n    }\n</code></pre></div>\n<p dir=\"auto\">(same for <code>putAll</code> above)</p>", "author": "vbekiaris", "createdAt": "2020-02-27T13:32:16Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/MultiMapProxyImpl.java", "diffHunk": "@@ -92,6 +93,20 @@ public void initialize() {\n         }\n     }\n \n+    @Override\n+    public void putAll(@Nonnull Map<? extends Object, Collection> m) {\n+        //TODO: add contains check\n+        putAllInternal(m, null);\n+    }\n+\n+    @Override\n+    public InternalCompletableFuture<Void> putAllAsync(@Nonnull Map<? extends Object, Collection> m) {\n+        //TODO: add contains check\n+        InternalCompletableFuture<Void> future = new InternalCompletableFuture<>();", "originalCommit": "2b2dfd27152e08ea00364879267a44f5927999a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE0MzU3NA==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r385143574", "body": "`MultiMapSupport` is not aware of `K, V` type parameters; instead it only operates with `Data`, the serialized binary form of keys and values. So here I would expect a `Map<Data, Collection<Data>>` as argument. Serialization occurs in `MultiMapProxyImpl`, as an example see how `MultiMap#put(@Nonnull K key, @Nonnull V value)` is implemented.", "bodyText": "MultiMapSupport is not aware of K, V type parameters; instead it only operates with Data, the serialized binary form of keys and values. So here I would expect a Map<Data, Collection<Data>> as argument. Serialization occurs in MultiMapProxyImpl, as an example see how MultiMap#put(@Nonnull K key, @Nonnull V value) is implemented.", "bodyHTML": "<p dir=\"auto\"><code>MultiMapSupport</code> is not aware of <code>K, V</code> type parameters; instead it only operates with <code>Data</code>, the serialized binary form of keys and values. So here I would expect a <code>Map&lt;Data, Collection&lt;Data&gt;&gt;</code> as argument. Serialization occurs in <code>MultiMapProxyImpl</code>, as an example see how <code>MultiMap#put(@Nonnull K key, @Nonnull V value)</code> is implemented.</p>", "author": "vbekiaris", "createdAt": "2020-02-27T14:01:44Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/MultiMapProxySupport.java", "diffHunk": "@@ -16,54 +16,267 @@\n \n package com.hazelcast.multimap.impl;\n \n-import com.hazelcast.internal.locksupport.LockProxySupport;\n-import com.hazelcast.internal.locksupport.LockSupportServiceImpl;\n+import com.hazelcast.cluster.Address;\n import com.hazelcast.config.MultiMapConfig;\n import com.hazelcast.core.EntryEventType;\n+import com.hazelcast.internal.locksupport.LockProxySupport;\n+import com.hazelcast.internal.locksupport.LockSupportServiceImpl;\n+import com.hazelcast.internal.partition.IPartitionService;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.SerializationService;\n+import com.hazelcast.internal.services.DistributedObjectNamespace;\n+import com.hazelcast.internal.util.ExceptionUtil;\n+import com.hazelcast.internal.util.ThreadUtil;\n+import com.hazelcast.map.impl.MapEntries;\n import com.hazelcast.multimap.impl.operations.CountOperation;\n import com.hazelcast.multimap.impl.operations.DeleteOperation;\n import com.hazelcast.multimap.impl.operations.GetAllOperation;\n import com.hazelcast.multimap.impl.operations.MultiMapOperationFactory;\n import com.hazelcast.multimap.impl.operations.MultiMapOperationFactory.OperationFactoryType;\n+import com.hazelcast.multimap.impl.operations.MultiMapPutAllOperationFactory;\n import com.hazelcast.multimap.impl.operations.MultiMapResponse;\n import com.hazelcast.multimap.impl.operations.PutOperation;\n import com.hazelcast.multimap.impl.operations.RemoveAllOperation;\n import com.hazelcast.multimap.impl.operations.RemoveOperation;\n-import com.hazelcast.internal.serialization.Data;\n import com.hazelcast.spi.impl.AbstractDistributedObject;\n-import com.hazelcast.internal.services.DistributedObjectNamespace;\n+import com.hazelcast.spi.impl.InternalCompletableFuture;\n import com.hazelcast.spi.impl.NodeEngine;\n import com.hazelcast.spi.impl.operationservice.Operation;\n-import com.hazelcast.internal.util.ExceptionUtil;\n-import com.hazelcast.internal.util.ThreadUtil;\n+import com.hazelcast.spi.impl.operationservice.OperationFactory;\n+import com.hazelcast.spi.impl.operationservice.OperationService;\n \n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+import java.util.Collection;\n import java.util.HashSet;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.BiConsumer;\n \n+import static com.hazelcast.internal.util.CollectionUtil.asIntegerList;\n+import static com.hazelcast.internal.util.ConcurrencyUtil.CALLER_RUNS;\n+import static com.hazelcast.internal.util.ExceptionUtil.rethrow;\n+import static com.hazelcast.internal.util.Preconditions.checkNotNull;\n import static com.hazelcast.internal.util.MapUtil.toIntSize;\n+import static com.hazelcast.multimap.impl.MultiMapProxyImpl.NULL_KEY_IS_NOT_ALLOWED;\n+import static com.hazelcast.multimap.impl.MultiMapProxyImpl.NULL_VALUE_IS_NOT_ALLOWED;\n+import static com.hazelcast.spi.impl.InternalCompletableFuture.newCompletedFuture;\n+import static java.lang.Math.ceil;\n+import static java.lang.Math.log10;\n+import static java.util.Collections.singletonMap;\n \n public abstract class MultiMapProxySupport extends AbstractDistributedObject<MultiMapService> {\n \n     protected final MultiMapConfig config;\n     protected final String name;\n     protected final LockProxySupport lockSupport;\n+    protected final SerializationService serializationService;\n+    protected final OperationService operationService;\n+    protected final IPartitionService partitionService;\n+    private final float putAllInitialSizeFactor;\n \n     protected MultiMapProxySupport(MultiMapConfig config, MultiMapService service, NodeEngine nodeEngine, String name) {\n         super(nodeEngine, service);\n         this.config = config;\n         this.name = name;\n \n+        this.partitionService = nodeEngine.getPartitionService();\n+        this.serializationService = nodeEngine.getSerializationService();\n+        this.operationService = nodeEngine.getOperationService();\n+\n         lockSupport = new LockProxySupport(new DistributedObjectNamespace(MultiMapService.SERVICE_NAME, name),\n                 LockSupportServiceImpl.getMaxLeaseTimeInMillis(nodeEngine.getProperties()));\n+\n+        //TODO: implement properties and properties.getFloat(MAP_PUT_ALL_INITIAL_SIZE_FACTOR);\n+        this.putAllInitialSizeFactor = 1;\n     }\n \n     @Override\n     public String getName() {\n         return name;\n     }\n \n+    //NB: this method is copied from MapProxySupport#getPutAllInitialSize\n+    @SuppressWarnings(\"checkstyle:magicnumber\")\n+    private int getPutAllInitialSize(boolean useBatching, int mapSize, int partitionCount) {\n+        if (mapSize == 1) {\n+            return 1;\n+        }\n+        //TODO: implement batching\n+        /*\n+        if (useBatching) {\n+            return putAllBatchSize;\n+        }*/\n+        if (putAllInitialSizeFactor < 1) {\n+            // this is an educated guess for the initial size of the entries per partition, depending on the map size\n+            return (int) ceil(20f * mapSize / partitionCount / log10(mapSize));\n+        }\n+        return (int) ceil(putAllInitialSizeFactor * mapSize / partitionCount);\n+    }\n+\n+    //NB: this method is generally copied from MapProxySupport#putAllInternal\n+    @SuppressWarnings({\"checkstyle:npathcomplexity\", \"checkstyle:methodlength\"})\n+    protected void putAllInternal(Map<? extends Object, Collection> map,", "originalCommit": "2b2dfd27152e08ea00364879267a44f5927999a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "941f97d717eb624059761c4884b9fa7381bc6c33", "url": "https://github.com/hazelcast/hazelcast/commit/941f97d717eb624059761c4884b9fa7381bc6c33", "message": " Modify new MultiMap bulk store interfaces to take in Map, MultiMap and Key and Collection (#9079)\n Implement ClientMultiMapProxy, corresponding PutAllMessageTask, unit tests and copy in generated codec.\n Address comments and fix MultiMap javadoc.\n\n Add new Precondition to throw given Exception.", "committedDate": "2020-03-22T19:07:37Z", "type": "forcePushed"}, {"oid": "d98853fc1667c392bc94f445adcb517df86ddf3b", "url": "https://github.com/hazelcast/hazelcast/commit/d98853fc1667c392bc94f445adcb517df86ddf3b", "message": "Modify new MultiMap bulk store interfaces to take in Map, MultiMap and Key and Collection (#9079)\n Implement ClientMultiMapProxy, corresponding PutAllMessageTask, unit tests and copy in generated codec.\n Address comments and fix MultiMap javadoc.\n\n Add new Precondition to throw given Exception.", "committedDate": "2020-03-22T22:31:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQwOTIzNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r396409235", "body": "While I appreciate the clean coding style with `checkTrue(boolean, RuntimeException)`, this version of code will produce a lot of litter even in the happy path, when cluster version is >= 4.1. I would rather have the exception construction & message formatting code be only executed when the cluster version condition is `false`.", "bodyText": "While I appreciate the clean coding style with checkTrue(boolean, RuntimeException), this version of code will produce a lot of litter even in the happy path, when cluster version is >= 4.1. I would rather have the exception construction & message formatting code be only executed when the cluster version condition is false.", "bodyHTML": "<p dir=\"auto\">While I appreciate the clean coding style with <code>checkTrue(boolean, RuntimeException)</code>, this version of code will produce a lot of litter even in the happy path, when cluster version is &gt;= 4.1. I would rather have the exception construction &amp; message formatting code be only executed when the cluster version condition is <code>false</code>.</p>", "author": "vbekiaris", "createdAt": "2020-03-23T12:20:02Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/MultiMapProxyImpl.java", "diffHunk": "@@ -92,6 +100,120 @@ public void initialize() {\n         }\n     }\n \n+    @Override\n+    public void putAll(@Nonnull Map<? extends K, Collection<? extends V>> m) {\n+        checkTrue(isClusterVersionGreaterOrEqual(Versions.V4_1),", "originalCommit": "d98853fc1667c392bc94f445adcb517df86ddf3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUyMDQyMg==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r396520422", "body": "I would rather not have this (and the async variant) API method with `MultiMap` as argument implemented at all. The reason is that it makes it extremely easy for users to shoot themselves in the foot, abstracting away the fact that each invocation to get an item from the `MultiMap` argument will be a remote invocation.", "bodyText": "I would rather not have this (and the async variant) API method with MultiMap as argument implemented at all. The reason is that it makes it extremely easy for users to shoot themselves in the foot, abstracting away the fact that each invocation to get an item from the MultiMap argument will be a remote invocation.", "bodyHTML": "<p dir=\"auto\">I would rather not have this (and the async variant) API method with <code>MultiMap</code> as argument implemented at all. The reason is that it makes it extremely easy for users to shoot themselves in the foot, abstracting away the fact that each invocation to get an item from the <code>MultiMap</code> argument will be a remote invocation.</p>", "author": "vbekiaris", "createdAt": "2020-03-23T15:05:50Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/MultiMap.java", "diffHunk": "@@ -57,6 +58,117 @@\n  */\n @SuppressWarnings(\"checkstyle:methodcount\")\n public interface MultiMap<K, V> extends BaseMultiMap<K, V> {\n+\n+    /**\n+     * Stores the given Map in the MultiMap synchronously.\n+     * <p>\n+     * This version doesn't support batching. Don't mutate the given map until the future completes.\n+     * <p>\n+     * No atomicity guarantees are given. It could be that in case of failure\n+     * some of the key/value-pairs get written, while others are not.\n+     * <p>\n+     * <b>Warning:</b> There is no warning if the input Map collection items are discarded due to uniqueness\n+     * eg. passing in List into a Set type MultiMap\n+     *\n+     * @param m the Map to be stored\n+     * @since 4.1\n+     */\n+    void putAll(@Nonnull Map<? extends K, Collection<? extends V>> m);\n+\n+    /**\n+     * Stores the given MultiMap in the MultiMap synchronously.\n+     * <p>\n+     * This version doesn't support batching. Don't mutate the given multimap until the future completes.\n+     * <p>\n+     * No atomicity guarantees are given. It could be that in case of failure\n+     * some of the key/value-pairs get written, while others are not.\n+     * <p>\n+     * <b>Warning:</b> There is no warning if the input MultiMap items are discarded due to uniqueness\n+     * eg. passing in List type MultiMap into a Set type MultiMap\n+     *\n+     * @param m the MultiMap to be stored\n+     * @since 4.1\n+     */\n+    void putAll(@Nonnull MultiMap<K, V> m);", "originalCommit": "d98853fc1667c392bc94f445adcb517df86ddf3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU0MDQ0Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r396540447", "body": "\"This version doesn't support batching.\" -> This seems superfluous for an API description, don't bother with mentioning implementation details in the contract description. If you feel like it is important to mention this so users can take it into account when planning their usage of the API, then probably it could be rephrased. From my point of view reading \"This version doesn't support batching\" indicates that there exists a version that supports batching.\r\n\r\n\"Don't mutate the given map until the future completes.\" -> what do you think about rephrasing as \"The results of concurrently mutating the given map are undefined\"?", "bodyText": "\"This version doesn't support batching.\" -> This seems superfluous for an API description, don't bother with mentioning implementation details in the contract description. If you feel like it is important to mention this so users can take it into account when planning their usage of the API, then probably it could be rephrased. From my point of view reading \"This version doesn't support batching\" indicates that there exists a version that supports batching.\n\"Don't mutate the given map until the future completes.\" -> what do you think about rephrasing as \"The results of concurrently mutating the given map are undefined\"?", "bodyHTML": "<p dir=\"auto\">\"This version doesn't support batching.\" -&gt; This seems superfluous for an API description, don't bother with mentioning implementation details in the contract description. If you feel like it is important to mention this so users can take it into account when planning their usage of the API, then probably it could be rephrased. From my point of view reading \"This version doesn't support batching\" indicates that there exists a version that supports batching.</p>\n<p dir=\"auto\">\"Don't mutate the given map until the future completes.\" -&gt; what do you think about rephrasing as \"The results of concurrently mutating the given map are undefined\"?</p>", "author": "vbekiaris", "createdAt": "2020-03-23T15:31:55Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/MultiMap.java", "diffHunk": "@@ -57,6 +58,117 @@\n  */\n @SuppressWarnings(\"checkstyle:methodcount\")\n public interface MultiMap<K, V> extends BaseMultiMap<K, V> {\n+\n+    /**\n+     * Stores the given Map in the MultiMap synchronously.\n+     * <p>\n+     * This version doesn't support batching. Don't mutate the given map until the future completes.", "originalCommit": "d98853fc1667c392bc94f445adcb517df86ddf3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU5Nzg4OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r396597889", "body": "Are we sure that it is worth the `parallelStream` setup here, also taking into account that the per-element function (in line 114 below) also contends for the same CPU cores? I think this question can have varying answers depending on the number of keys and the average number of values per key, however using `parallelStream` to process both the entry stream and the values collection is certain to have a detrimental effect. I would probably opt for simple sequential execution in both places (here and line 114).\r\n\r\nRelated reading: http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html", "bodyText": "Are we sure that it is worth the parallelStream setup here, also taking into account that the per-element function (in line 114 below) also contends for the same CPU cores? I think this question can have varying answers depending on the number of keys and the average number of values per key, however using parallelStream to process both the entry stream and the values collection is certain to have a detrimental effect. I would probably opt for simple sequential execution in both places (here and line 114).\nRelated reading: http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html", "bodyHTML": "<p dir=\"auto\">Are we sure that it is worth the <code>parallelStream</code> setup here, also taking into account that the per-element function (in line 114 below) also contends for the same CPU cores? I think this question can have varying answers depending on the number of keys and the average number of values per key, however using <code>parallelStream</code> to process both the entry stream and the values collection is certain to have a detrimental effect. I would probably opt for simple sequential execution in both places (here and line 114).</p>\n<p dir=\"auto\">Related reading: <a href=\"http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html\" rel=\"nofollow\">http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html</a></p>", "author": "vbekiaris", "createdAt": "2020-03-23T16:47:07Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/MultiMapProxyImpl.java", "diffHunk": "@@ -92,6 +100,120 @@ public void initialize() {\n         }\n     }\n \n+    @Override\n+    public void putAll(@Nonnull Map<? extends K, Collection<? extends V>> m) {\n+        checkTrue(isClusterVersionGreaterOrEqual(Versions.V4_1),\n+                new UnsupportedOperationException(MessageFormat.format(MINIMUM_VERSION_ERROR_FORMAT,\n+                        \"MultiMap#putAll\", \"4.1\")));\n+        Map<Data, Collection<Data>> dataMap = new HashMap<Data, Collection<Data>>();\n+\n+        m.entrySet().parallelStream().forEach(", "originalCommit": "d98853fc1667c392bc94f445adcb517df86ddf3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA0NTQ1NA==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r397045454", "body": "`new PutAllPartitionAwareOperationFactory`?", "bodyText": "new PutAllPartitionAwareOperationFactory?", "bodyHTML": "<p dir=\"auto\"><code>new PutAllPartitionAwareOperationFactory</code>?</p>", "author": "vbekiaris", "createdAt": "2020-03-24T10:24:37Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/MultiMapDataSerializerHook.java", "diffHunk": "@@ -172,6 +175,8 @@ public DataSerializableFactory createFactory() {\n         constructors[MERGE_BACKUP_OPERATION] = arg -> new MergeBackupOperation();\n         constructors[DELETE] = arg -> new DeleteOperation();\n         constructors[DELETE_BACKUP] = arg -> new DeleteBackupOperation();\n+        constructors[PUT_ALL] = arg -> new PutAllOperation();\n+        constructors[PUT_ALL_PARTITION_AWARE_FACTORY] = arg -> new MultiMapOperationFactory();", "originalCommit": "d98853fc1667c392bc94f445adcb517df86ddf3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA4MDM4Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r397080387", "body": "This is unnecessary", "bodyText": "This is unnecessary", "bodyHTML": "<p dir=\"auto\">This is unnecessary</p>", "author": "vbekiaris", "createdAt": "2020-03-24T11:25:31Z", "path": "hazelcast/src/test/java/com/hazelcast/multimap/MultiMapTest.java", "diffHunk": "@@ -104,6 +116,245 @@ public void testMultiMapPutGetRemove() {\n         assertEquals(0, multiMap.size());\n     }\n \n+    protected <K, V> EntryListener<K, V> putAllEntryListenerBuilder(Consumer<EntryEvent<K, V>> f) {\n+        return new EntryAdapter<K, V>() {\n+            public void entryAdded(EntryEvent<K, V> event) {\n+                f.accept(event);\n+            }\n+\n+            public void entryRemoved(EntryEvent<K, V> event) {\n+                System.out.println(\"entryRemoved \" + event);\n+            }\n+\n+            public void entryEvicted(EntryEvent<K, V> event) {\n+                entryRemoved(event);\n+            }\n+\n+            @Override\n+            public void mapEvicted(MapEvent event) {\n+            }\n+\n+            @Override\n+            public void mapCleared(MapEvent event) {\n+                System.out.println(\"mapCleared \" + event);\n+            }\n+        };\n+    }\n+\n+    protected HazelcastInstance testMultiMapPutAllSetup() {\n+        MultiMapConfig multiMapConfig1 = new MultiMapConfig()\n+                .setName(\"testMultiMapPutAllMapList\")\n+                .setValueCollectionType(\"LIST\")\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig2 = new MultiMapConfig()\n+                .setName(\"testMultiMapPutAllMapSet\")\n+                .setValueCollectionType(\"SET\")\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig3 = new MultiMapConfig()\n+                .setName(\"expectedMultiMap1\")\n+                .setValueCollectionType(\"LIST\")\n+                .setBinary(false);\n+        Config cfg = smallInstanceConfig()\n+                .addMultiMapConfig(multiMapConfig1)\n+                .addMultiMapConfig(multiMapConfig2)\n+                .addMultiMapConfig(multiMapConfig3);\n+        HazelcastInstance hz = createHazelcastInstanceFactory(1)\n+                .newInstances(cfg)[0];\n+\n+        Accessors.getNode(hz).getClusterService().changeClusterVersion(Version.of(4, 1));", "originalCommit": "d98853fc1667c392bc94f445adcb517df86ddf3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEzODc3MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r397138771", "body": "The `Set` and `List` implementations used internally in the multimap container are not thread-safe. Additionally, using `parallelStream` here breaks the principle of a single thread accessing a partition's data. Instead, do a plain `for` loop (and avoid the cost of stream & consumer allocations as a bonus). This is the reason of spurious test failures you observed. One more thing, event should be only triggered when a value is actually added (so adding an already existing value to a `Set`-backed multimap should not trigger an event).", "bodyText": "The Set and List implementations used internally in the multimap container are not thread-safe. Additionally, using parallelStream here breaks the principle of a single thread accessing a partition's data. Instead, do a plain for loop (and avoid the cost of stream & consumer allocations as a bonus). This is the reason of spurious test failures you observed. One more thing, event should be only triggered when a value is actually added (so adding an already existing value to a Set-backed multimap should not trigger an event).", "bodyHTML": "<p dir=\"auto\">The <code>Set</code> and <code>List</code> implementations used internally in the multimap container are not thread-safe. Additionally, using <code>parallelStream</code> here breaks the principle of a single thread accessing a partition's data. Instead, do a plain <code>for</code> loop (and avoid the cost of stream &amp; consumer allocations as a bonus). This is the reason of spurious test failures you observed. One more thing, event should be only triggered when a value is actually added (so adding an already existing value to a <code>Set</code>-backed multimap should not trigger an event).</p>", "author": "vbekiaris", "createdAt": "2020-03-24T13:10:10Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/operations/PutAllOperation.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.multimap.impl.operations;\n+\n+import com.hazelcast.core.EntryEventType;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.map.impl.MapEntries;\n+import com.hazelcast.memory.NativeOutOfMemoryError;\n+import com.hazelcast.multimap.impl.MultiMapContainer;\n+import com.hazelcast.multimap.impl.MultiMapDataSerializerHook;\n+import com.hazelcast.multimap.impl.MultiMapRecord;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.spi.impl.operationservice.MutatingOperation;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+public class PutAllOperation extends AbstractMultiMapOperation implements MutatingOperation {\n+    private transient int currentIndex;\n+    private MapEntries mapEntries;\n+    private long recordId;\n+\n+    public PutAllOperation() {\n+        super();\n+    }\n+\n+    public PutAllOperation(String name, MapEntries mapEntries) {\n+        super(name);\n+        this.mapEntries = mapEntries;\n+        //NB: general structure copied from c.hz.map.impl.operation.PutAllOperation\n+        //May benefit from refactoring or default interfaces\n+    }\n+\n+    @Override\n+    public final void run() {\n+        try {\n+            runInternal();\n+        } catch (NativeOutOfMemoryError e) {\n+            //TODO: implement rerun?\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    protected void runInternal() {\n+        //FIXME: potentially bad idiom?\n+        int size = mapEntries != null ? mapEntries.size() : 0;\n+        while (currentIndex < size) {\n+            Data dataKey = mapEntries.getKey(currentIndex);\n+            Data value = mapEntries.getValue(currentIndex);\n+            put(dataKey, value);\n+            currentIndex++;\n+        }\n+        //FIXME: is this the best place to set response?\n+        response = true;\n+    }\n+\n+    protected void put(Data dataKey, Data dataValue) {\n+        MultiMapContainer container = getOrCreateContainer();\n+        Collection c = (Collection) toObject(dataValue);\n+        Collection<MultiMapRecord> coll = container.getOrCreateMultiMapValue(dataKey).getCollection(false);\n+        Consumer addObjToCollection = o -> {\n+            recordId = container.nextId();\n+            MultiMapRecord record = new MultiMapRecord(recordId, o);\n+            coll.add(record);\n+            getOrCreateContainer().update();\n+            publishEvent(EntryEventType.ADDED, dataKey, o, null);\n+        };\n+\n+        if (coll instanceof Set) {\n+            c.parallelStream().distinct().forEach(addObjToCollection);", "originalCommit": "d98853fc1667c392bc94f445adcb517df86ddf3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzE1MDM1MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r397150351", "body": "Need to respect the configured in-memory format here. Do something like `MultiMapRecord record = new MultiMapRecord(recordId, isBinary() ? o : toObject(o));`\r\n\r\nwhere \r\n```\r\npublic final boolean isBinary() {\r\n    return getOrCreateContainer().getConfig().isBinary();\r\n}\r\n```", "bodyText": "Need to respect the configured in-memory format here. Do something like MultiMapRecord record = new MultiMapRecord(recordId, isBinary() ? o : toObject(o));\nwhere\npublic final boolean isBinary() {\n    return getOrCreateContainer().getConfig().isBinary();\n}", "bodyHTML": "<p dir=\"auto\">Need to respect the configured in-memory format here. Do something like <code>MultiMapRecord record = new MultiMapRecord(recordId, isBinary() ? o : toObject(o));</code></p>\n<p dir=\"auto\">where</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"public final boolean isBinary() {\n    return getOrCreateContainer().getConfig().isBinary();\n}\n\"><pre><code>public final boolean isBinary() {\n    return getOrCreateContainer().getConfig().isBinary();\n}\n</code></pre></div>", "author": "vbekiaris", "createdAt": "2020-03-24T13:27:49Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/operations/PutAllOperation.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.multimap.impl.operations;\n+\n+import com.hazelcast.core.EntryEventType;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.map.impl.MapEntries;\n+import com.hazelcast.memory.NativeOutOfMemoryError;\n+import com.hazelcast.multimap.impl.MultiMapContainer;\n+import com.hazelcast.multimap.impl.MultiMapDataSerializerHook;\n+import com.hazelcast.multimap.impl.MultiMapRecord;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.spi.impl.operationservice.MutatingOperation;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+public class PutAllOperation extends AbstractMultiMapOperation implements MutatingOperation {\n+    private transient int currentIndex;\n+    private MapEntries mapEntries;\n+    private long recordId;\n+\n+    public PutAllOperation() {\n+        super();\n+    }\n+\n+    public PutAllOperation(String name, MapEntries mapEntries) {\n+        super(name);\n+        this.mapEntries = mapEntries;\n+        //NB: general structure copied from c.hz.map.impl.operation.PutAllOperation\n+        //May benefit from refactoring or default interfaces\n+    }\n+\n+    @Override\n+    public final void run() {\n+        try {\n+            runInternal();\n+        } catch (NativeOutOfMemoryError e) {\n+            //TODO: implement rerun?\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    protected void runInternal() {\n+        //FIXME: potentially bad idiom?\n+        int size = mapEntries != null ? mapEntries.size() : 0;\n+        while (currentIndex < size) {\n+            Data dataKey = mapEntries.getKey(currentIndex);\n+            Data value = mapEntries.getValue(currentIndex);\n+            put(dataKey, value);\n+            currentIndex++;\n+        }\n+        //FIXME: is this the best place to set response?\n+        response = true;\n+    }\n+\n+    protected void put(Data dataKey, Data dataValue) {\n+        MultiMapContainer container = getOrCreateContainer();\n+        Collection c = (Collection) toObject(dataValue);\n+        Collection<MultiMapRecord> coll = container.getOrCreateMultiMapValue(dataKey).getCollection(false);\n+        Consumer addObjToCollection = o -> {\n+            recordId = container.nextId();\n+            MultiMapRecord record = new MultiMapRecord(recordId, o);", "originalCommit": "d98853fc1667c392bc94f445adcb517df86ddf3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3e59db4b82436572d3935ebe5d12f14fdfb1ca7c", "url": "https://github.com/hazelcast/hazelcast/commit/3e59db4b82436572d3935ebe5d12f14fdfb1ca7c", "message": "Modify interface and implementations of MultiMap.putAllAsync and related classes (#9079)\n\nRemove non async putAll interfaces. Modify MultiMap.putAllInternal interface to take in Data, Data. Amend MultiMap.putAllAsync javadoc. Remove streams implementation\n\nFix PutAllOperation record saving implementation. Fix incorrect MultimapDataSerializerHook reference.\n\nImplement Preconditions.checkTrue to take in class type.", "committedDate": "2020-03-31T03:16:06Z", "type": "forcePushed"}, {"oid": "d5eab935497c3e80d0e4201d684cae3adce677c7", "url": "https://github.com/hazelcast/hazelcast/commit/d5eab935497c3e80d0e4201d684cae3adce677c7", "message": "Modify interface and implementations of MultiMap.putAllAsync and related classes (#9079)\n\nRemove non async putAll interfaces. Modify MultiMap.putAllInternal interface to take in Data, Data. Amend MultiMap.putAllAsync javadoc. Remove streams implementation\n\nFix PutAllOperation record saving implementation. Fix incorrect MultimapDataSerializerHook reference.\n\nImplement Preconditions.checkTrue to take in class type.", "committedDate": "2020-04-01T09:33:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYzNDE1Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r401634156", "body": "this is `IMap`'s put all operation factory, please revert", "bodyText": "this is IMap's put all operation factory, please revert", "bodyHTML": "<p dir=\"auto\">this is <code>IMap</code>'s put all operation factory, please revert</p>", "author": "vbekiaris", "createdAt": "2020-04-01T13:55:11Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/operation/PutAllPartitionAwareOperationFactory.java", "diffHunk": "@@ -27,12 +26,11 @@\n \n import java.io.IOException;\n import java.util.Arrays;\n-import java.util.Map;\n \n /**\n  * Inserts the {@link MapEntries} for all partitions of a member via locally invoked {@link PutAllOperation}.\n  * <p>\n- * Used to reduce the number of remote invocations of an {@link IMap#putAll(Map)} call.\n+ * Used to reduce the number of remote invocations of an {@link MultiMap#putAllAsync(Map) } call.", "originalCommit": "d5eab935497c3e80d0e4201d684cae3adce677c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ2NjA2OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r403466069", "bodyText": "oops. i need to schedule that appointment with a brain surgeon now ...  :O", "author": "abdulazizali77", "createdAt": "2020-04-04T12:43:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYzNDE1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYzNDU5Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r401634593", "body": "please remove also this variant of `putAllAsync` with `MultiMap` as argument", "bodyText": "please remove also this variant of putAllAsync with MultiMap as argument", "bodyHTML": "<p dir=\"auto\">please remove also this variant of <code>putAllAsync</code> with <code>MultiMap</code> as argument</p>", "author": "vbekiaris", "createdAt": "2020-04-01T13:55:45Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/MultiMap.java", "diffHunk": "@@ -57,6 +58,69 @@\n  */\n @SuppressWarnings(\"checkstyle:methodcount\")\n public interface MultiMap<K, V> extends BaseMultiMap<K, V> {\n+\n+\n+    /**\n+     * Stores the given Map in the MultiMap asynchronously.\n+     * <p>\n+     * The results of concurrently mutating the given map are undefined.\n+     * <p>\n+     * No atomicity guarantees are given. It could be that in case of failure\n+     * some of the key/value-pairs get written, while others are not.\n+     * <p>\n+     * <b>Warning:</b> There is no warning if the input Map collection items are discarded due to uniqueness\n+     * eg. passing in List into a Set type MultiMap\n+     * <p>\n+     * <b>Warning:</b> The Map and result of the put cannot be fetched\n+     * from the Future.\n+     *\n+     * @param m the map to be stored\n+     * @return a void CompletionStage\n+     * @since 4.1\n+     */\n+    CompletionStage<Void> putAllAsync(@Nonnull Map<? extends K, Collection<? extends V>> m);\n+\n+    /**\n+     * Stores a specified MultiMap in the MultiMap synchronously.\n+     * <p>\n+     * The results of concurrently mutating the given MultiMap are undefined\n+     * <p>\n+     * No atomicity guarantees are given. It could be that in case of failure\n+     * some of the key/value-pairs get written, while others are not.\n+     * <p>\n+     * <b>Warning:</b> There is no warning if the input MultiMap items are discarded due to uniqueness\n+     * eg. passing in List type MultiMap into a Set type MultiMap\n+     * <p>\n+     * <b>Warning:</b> The Map and result of the put cannot be fetched\n+     * from the Future.\n+     *\n+     * @param m the map to be stored\n+     * @return a void CompletionStage\n+     * @since 4.1\n+     */\n+    CompletionStage<Void> putAllAsync(@Nonnull MultiMap<K, V> m);", "originalCommit": "d5eab935497c3e80d0e4201d684cae3adce677c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY1NDI1Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r401654257", "body": "I think reflection is too heavy weight as an alternative to something like `if (!properVersion) { throw new UnsupportedOperationException(...);}`. Taking also into account the Java 9+ reflection restrictions I would rather not use reflection in this case.", "bodyText": "I think reflection is too heavy weight as an alternative to something like if (!properVersion) { throw new UnsupportedOperationException(...);}. Taking also into account the Java 9+ reflection restrictions I would rather not use reflection in this case.", "bodyHTML": "<p dir=\"auto\">I think reflection is too heavy weight as an alternative to something like <code>if (!properVersion) { throw new UnsupportedOperationException(...);}</code>. Taking also into account the Java 9+ reflection restrictions I would rather not use reflection in this case.</p>", "author": "vbekiaris", "createdAt": "2020-04-01T14:22:25Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/Preconditions.java", "diffHunk": "@@ -328,6 +329,28 @@ public static void checkTrue(boolean expression, String errorMessage) {\n         }\n     }\n \n+    /**\n+     * Tests whether the supplied expression is {@code true}.\n+     *\n+     * @param expression the expression tested to see if it is {@code true}.\n+     * @param clazz      the exception class to construct.\n+     * @param message    the exception message.\n+     * @throws java.lang.RuntimeException if the supplied expression is {@code false}.\n+     */\n+    public static void checkTrue(boolean expression, Class<? extends RuntimeException> clazz, String message)\n+            throws RuntimeException {\n+        try {\n+            if (!expression) {\n+                Constructor<? extends RuntimeException> con = clazz.getConstructor(String.class);", "originalCommit": "d5eab935497c3e80d0e4201d684cae3adce677c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY2MDc4Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r401660787", "body": "also implement `BackupAwareOperation` here and:\r\n- `shouldBackup` should return `true` if the put all resulted in modification of the multimap (similarly to `PutOperation`)\r\n- `getSync/AsyncBackupCount` are already implemented in `AbstractMultiMapOperation` so no need to bother with those\r\n- `getBackupOperation` must return a new `PutAllBackupOperation` as discussed.", "bodyText": "also implement BackupAwareOperation here and:\n\nshouldBackup should return true if the put all resulted in modification of the multimap (similarly to PutOperation)\ngetSync/AsyncBackupCount are already implemented in AbstractMultiMapOperation so no need to bother with those\ngetBackupOperation must return a new PutAllBackupOperation as discussed.", "bodyHTML": "<p dir=\"auto\">also implement <code>BackupAwareOperation</code> here and:</p>\n<ul dir=\"auto\">\n<li><code>shouldBackup</code> should return <code>true</code> if the put all resulted in modification of the multimap (similarly to <code>PutOperation</code>)</li>\n<li><code>getSync/AsyncBackupCount</code> are already implemented in <code>AbstractMultiMapOperation</code> so no need to bother with those</li>\n<li><code>getBackupOperation</code> must return a new <code>PutAllBackupOperation</code> as discussed.</li>\n</ul>", "author": "vbekiaris", "createdAt": "2020-04-01T14:30:41Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/operations/PutAllOperation.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.multimap.impl.operations;\n+\n+import com.hazelcast.core.EntryEventType;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.map.impl.MapEntries;\n+import com.hazelcast.memory.NativeOutOfMemoryError;\n+import com.hazelcast.multimap.impl.MultiMapContainer;\n+import com.hazelcast.multimap.impl.MultiMapDataSerializerHook;\n+import com.hazelcast.multimap.impl.MultiMapRecord;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.spi.impl.operationservice.MutatingOperation;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+public class PutAllOperation extends AbstractMultiMapOperation implements MutatingOperation {", "originalCommit": "d5eab935497c3e80d0e4201d684cae3adce677c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY2MjM2OA==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r401662368", "body": "remove this try-catch block and pull `runInternal` code here. `MultiMap` does not support `NATIVE` in memory format so it's not possible for `NativeOutOfMemoryError` to be thrown.", "bodyText": "remove this try-catch block and pull runInternal code here. MultiMap does not support NATIVE in memory format so it's not possible for NativeOutOfMemoryError to be thrown.", "bodyHTML": "<p dir=\"auto\">remove this try-catch block and pull <code>runInternal</code> code here. <code>MultiMap</code> does not support <code>NATIVE</code> in memory format so it's not possible for <code>NativeOutOfMemoryError</code> to be thrown.</p>", "author": "vbekiaris", "createdAt": "2020-04-01T14:32:44Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/operations/PutAllOperation.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.multimap.impl.operations;\n+\n+import com.hazelcast.core.EntryEventType;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.map.impl.MapEntries;\n+import com.hazelcast.memory.NativeOutOfMemoryError;\n+import com.hazelcast.multimap.impl.MultiMapContainer;\n+import com.hazelcast.multimap.impl.MultiMapDataSerializerHook;\n+import com.hazelcast.multimap.impl.MultiMapRecord;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.spi.impl.operationservice.MutatingOperation;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+public class PutAllOperation extends AbstractMultiMapOperation implements MutatingOperation {\n+    private transient int currentIndex;\n+    private MapEntries mapEntries;\n+    private long recordId;\n+\n+    public PutAllOperation() {\n+        super();\n+    }\n+\n+    public PutAllOperation(String name, MapEntries mapEntries) {\n+        super(name);\n+        this.mapEntries = mapEntries;\n+        //NB: general structure copied from c.hz.map.impl.operation.PutAllOperation\n+        //May benefit from refactoring or default interfaces\n+    }\n+\n+    @Override\n+    public final void run() {\n+        try {\n+            runInternal();\n+        } catch (NativeOutOfMemoryError e) {", "originalCommit": "d5eab935497c3e80d0e4201d684cae3adce677c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcwNDg5Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r401704892", "body": "to be removed (see relevant comment in `MultiMap` interface)", "bodyText": "to be removed (see relevant comment in MultiMap interface)", "bodyHTML": "<p dir=\"auto\">to be removed (see relevant comment in <code>MultiMap</code> interface)</p>", "author": "vbekiaris", "createdAt": "2020-04-01T15:28:40Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/MultiMapProxyImpl.java", "diffHunk": "@@ -92,6 +101,47 @@ public void initialize() {\n         }\n     }\n \n+    @Override\n+    public CompletionStage<Void> putAllAsync(@Nonnull Map<? extends K, Collection<? extends V>> m) {\n+        checkTrue(isClusterVersionGreaterOrEqual(Versions.V4_1),\n+                UnsupportedOperationException.class, MINIMUM_VERSION_ERROR_4_1);\n+        InternalCompletableFuture<Void> future = new InternalCompletableFuture<>();\n+        Map<Data, Data> dataMap = new HashMap<>();\n+\n+        for (Map.Entry e : m.entrySet()) {\n+            dataMap.put(toData(e.getKey()), toData(e.getValue()));\n+        }\n+        putAllInternal(dataMap, future);\n+        return future;\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> putAllAsync(@Nonnull MultiMap<K, V> m) {", "originalCommit": "d5eab935497c3e80d0e4201d684cae3adce677c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcxNDEwMg==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r401714102", "body": "I would only set `response` to `true` if a value was actually added to the multimap (so if at least one of `coll.add(record)` in line 84 below returned `true`). This way, you can check `response` in your `shouldBackup` implementation to avoid sending a backup operation when no actual changes were performed. This is similar to how the existing `MultiMap` `PutOperation` works.", "bodyText": "I would only set response to true if a value was actually added to the multimap (so if at least one of coll.add(record) in line 84 below returned true). This way, you can check response in your shouldBackup implementation to avoid sending a backup operation when no actual changes were performed. This is similar to how the existing MultiMap PutOperation works.", "bodyHTML": "<p dir=\"auto\">I would only set <code>response</code> to <code>true</code> if a value was actually added to the multimap (so if at least one of <code>coll.add(record)</code> in line 84 below returned <code>true</code>). This way, you can check <code>response</code> in your <code>shouldBackup</code> implementation to avoid sending a backup operation when no actual changes were performed. This is similar to how the existing <code>MultiMap</code> <code>PutOperation</code> works.</p>", "author": "vbekiaris", "createdAt": "2020-04-01T15:41:01Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/operations/PutAllOperation.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.multimap.impl.operations;\n+\n+import com.hazelcast.core.EntryEventType;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.map.impl.MapEntries;\n+import com.hazelcast.memory.NativeOutOfMemoryError;\n+import com.hazelcast.multimap.impl.MultiMapContainer;\n+import com.hazelcast.multimap.impl.MultiMapDataSerializerHook;\n+import com.hazelcast.multimap.impl.MultiMapRecord;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.spi.impl.operationservice.MutatingOperation;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+public class PutAllOperation extends AbstractMultiMapOperation implements MutatingOperation {\n+    private transient int currentIndex;\n+    private MapEntries mapEntries;\n+    private long recordId;\n+\n+    public PutAllOperation() {\n+        super();\n+    }\n+\n+    public PutAllOperation(String name, MapEntries mapEntries) {\n+        super(name);\n+        this.mapEntries = mapEntries;\n+        //NB: general structure copied from c.hz.map.impl.operation.PutAllOperation\n+        //May benefit from refactoring or default interfaces\n+    }\n+\n+    @Override\n+    public final void run() {\n+        try {\n+            runInternal();\n+        } catch (NativeOutOfMemoryError e) {\n+            //TODO: implement rerun?\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    protected void runInternal() {\n+        //FIXME: potentially bad idiom?\n+        int size = mapEntries != null ? mapEntries.size() : 0;\n+        while (currentIndex < size) {\n+            Data dataKey = mapEntries.getKey(currentIndex);\n+            Data value = mapEntries.getValue(currentIndex);\n+            put(dataKey, value);\n+            currentIndex++;\n+        }\n+        //FIXME: is this the best place to set response?\n+        response = true;", "originalCommit": "d5eab935497c3e80d0e4201d684cae3adce677c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcxNTQ1NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r401715455", "body": "as soon as you no longer need these `System.out`s (probably inserted for debugging?), please remove them.", "bodyText": "as soon as you no longer need these System.outs (probably inserted for debugging?), please remove them.", "bodyHTML": "<p dir=\"auto\">as soon as you no longer need these <code>System.out</code>s (probably inserted for debugging?), please remove them.</p>", "author": "vbekiaris", "createdAt": "2020-04-01T15:42:52Z", "path": "hazelcast/src/test/java/com/hazelcast/multimap/MultiMapTest.java", "diffHunk": "@@ -104,6 +114,184 @@ public void testMultiMapPutGetRemove() {\n         assertEquals(0, multiMap.size());\n     }\n \n+    protected <K, V> EntryListener<K, V> putAllEntryListenerBuilder(Consumer<EntryEvent<K, V>> f) {\n+        return new EntryAdapter<K, V>() {\n+            public void entryAdded(EntryEvent<K, V> event) {\n+                f.accept(event);\n+            }\n+\n+            public void entryRemoved(EntryEvent<K, V> event) {\n+                System.out.println(\"entryRemoved \" + event);", "originalCommit": "d5eab935497c3e80d0e4201d684cae3adce677c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyMDQzMg==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r401720432", "body": "you can use the compile-time safe variant `setValueCollectionType(ValueCollectionType valueCollectionType)` (here + 3 more instances below).", "bodyText": "you can use the compile-time safe variant setValueCollectionType(ValueCollectionType valueCollectionType) (here + 3 more instances below).", "bodyHTML": "<p dir=\"auto\">you can use the compile-time safe variant <code>setValueCollectionType(ValueCollectionType valueCollectionType)</code> (here + 3 more instances below).</p>", "author": "vbekiaris", "createdAt": "2020-04-01T15:49:27Z", "path": "hazelcast/src/test/java/com/hazelcast/multimap/MultiMapTest.java", "diffHunk": "@@ -104,6 +114,184 @@ public void testMultiMapPutGetRemove() {\n         assertEquals(0, multiMap.size());\n     }\n \n+    protected <K, V> EntryListener<K, V> putAllEntryListenerBuilder(Consumer<EntryEvent<K, V>> f) {\n+        return new EntryAdapter<K, V>() {\n+            public void entryAdded(EntryEvent<K, V> event) {\n+                f.accept(event);\n+            }\n+\n+            public void entryRemoved(EntryEvent<K, V> event) {\n+                System.out.println(\"entryRemoved \" + event);\n+            }\n+\n+            public void entryEvicted(EntryEvent<K, V> event) {\n+                entryRemoved(event);\n+            }\n+\n+            @Override\n+            public void mapEvicted(MapEvent event) {\n+            }\n+\n+            @Override\n+            public void mapCleared(MapEvent event) {\n+                System.out.println(\"mapCleared \" + event);\n+            }\n+        };\n+    }\n+\n+    protected HazelcastInstance testMultiMapPutAllSetup() {\n+        MultiMapConfig multiMapConfig1 = new MultiMapConfig()\n+                .setName(\"testMultiMapPutAllMapList\")\n+                .setValueCollectionType(\"LIST\")", "originalCommit": "d5eab935497c3e80d0e4201d684cae3adce677c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyMjIyMA==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r401722220", "body": "don't catch exceptions here, you want them to be thrown and fail the test", "bodyText": "don't catch exceptions here, you want them to be thrown and fail the test", "bodyHTML": "<p dir=\"auto\">don't catch exceptions here, you want them to be thrown and fail the test</p>", "author": "vbekiaris", "createdAt": "2020-04-01T15:52:00Z", "path": "hazelcast/src/test/java/com/hazelcast/multimap/MultiMapTest.java", "diffHunk": "@@ -104,6 +114,184 @@ public void testMultiMapPutGetRemove() {\n         assertEquals(0, multiMap.size());\n     }\n \n+    protected <K, V> EntryListener<K, V> putAllEntryListenerBuilder(Consumer<EntryEvent<K, V>> f) {\n+        return new EntryAdapter<K, V>() {\n+            public void entryAdded(EntryEvent<K, V> event) {\n+                f.accept(event);\n+            }\n+\n+            public void entryRemoved(EntryEvent<K, V> event) {\n+                System.out.println(\"entryRemoved \" + event);\n+            }\n+\n+            public void entryEvicted(EntryEvent<K, V> event) {\n+                entryRemoved(event);\n+            }\n+\n+            @Override\n+            public void mapEvicted(MapEvent event) {\n+            }\n+\n+            @Override\n+            public void mapCleared(MapEvent event) {\n+                System.out.println(\"mapCleared \" + event);\n+            }\n+        };\n+    }\n+\n+    protected HazelcastInstance testMultiMapPutAllSetup() {\n+        MultiMapConfig multiMapConfig1 = new MultiMapConfig()\n+                .setName(\"testMultiMapPutAllMapList\")\n+                .setValueCollectionType(\"LIST\")\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig2 = new MultiMapConfig()\n+                .setName(\"testMultiMapPutAllMapSet\")\n+                .setValueCollectionType(\"SET\")\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig3 = new MultiMapConfig()\n+                .setName(\"expectedMultiMap1\")\n+                .setValueCollectionType(\"LIST\")\n+                .setBinary(false);\n+        Config cfg = smallInstanceConfig()\n+                .addMultiMapConfig(multiMapConfig1)\n+                .addMultiMapConfig(multiMapConfig2)\n+                .addMultiMapConfig(multiMapConfig3);\n+        HazelcastInstance hz = createHazelcastInstanceFactory(1)\n+                .newInstances(cfg)[0];\n+\n+        return hz;\n+    }\n+\n+    public void testMultiMapPutAllTemplate(HazelcastInstance instance1,\n+                                           Map<String, Collection<? extends Integer>> expectedMultiMap1,\n+                                           MultiMap<String, Integer> expectedMultiMap2,\n+                                           Consumer<MultiMap<String, Integer>> putAllOperation1) {\n+\n+        MultiMap<String, Integer> mmap1 = instance1.getMultiMap(\"testMultiMapPutAllMapList\");\n+        MultiMap<String, Integer> mmap2 = instance1.getMultiMap(\"testMultiMapPutAllMapSet\");\n+        Map<String, Collection<Integer>> resultMap1 = new HashMap<>();\n+        Map<String, Collection<Integer>> resultMap2 = new HashMap<>();\n+\n+        int totalItems = 0;\n+        Set<String> ks = expectedMultiMap1 != null\n+                ? expectedMultiMap1.keySet() : expectedMultiMap2.keySet();\n+        for (String s : ks) {\n+            Collection expectedCollection = expectedMultiMap1 != null\n+                    ? expectedMultiMap1.get(s) : expectedMultiMap2.get(s);\n+            totalItems += expectedCollection.size()\n+                    + ((Long) expectedCollection.stream().distinct().count()).intValue();\n+        }\n+\n+        final CountDownLatch latchAdded = new CountDownLatch(totalItems);\n+        mmap1.addEntryListener(putAllEntryListenerBuilder((event) -> {\n+                    String key = (String) event.getKey();\n+                    Integer value = (Integer) event.getValue();\n+                    Collection<Integer> c;\n+                    if (!resultMap1.containsKey(key)) {\n+                        c = new ArrayList<>();\n+                    } else {\n+                        c = resultMap1.get(key);\n+                    }\n+                    c.add(value);\n+                    resultMap1.put(key, c);\n+                    latchAdded.countDown();\n+                }\n+        ), true);\n+        mmap2.addEntryListener(putAllEntryListenerBuilder((event) -> {\n+                    String key = (String) event.getKey();\n+                    Integer value = (Integer) event.getValue();\n+                    Collection<Integer> c;\n+                    if (!resultMap2.containsKey(key)) {\n+                        c = new ArrayList<>();\n+                    } else {\n+                        c = resultMap2.get(key);\n+                    }\n+                    c.add(value);\n+\n+                    resultMap2.put(key, c);\n+                    latchAdded.countDown();\n+                }\n+        ), true);\n+        try {\n+            putAllOperation1.accept(mmap1);\n+            putAllOperation1.accept(mmap2);\n+            latchAdded.await(5, TimeUnit.MINUTES);\n+\n+            for (String s : ks) {\n+                Collection c1 = resultMap1.get(s);\n+                Collection c2 = resultMap2.get(s);\n+                Collection expectedCollection = expectedMultiMap1 != null\n+                        ? expectedMultiMap1.get(s) : expectedMultiMap2.get(s);\n+                assertEquals(expectedCollection.size(), c1.size());\n+                assertEquals(expectedCollection.stream().distinct().count(), c2.size());\n+            }\n+\n+        } catch (Exception e) {", "originalCommit": "d5eab935497c3e80d0e4201d684cae3adce677c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyNDUyNA==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r401724524", "body": "this class needs some clean up to get rid of too many TODOs, eg anything related to a potential future implementation of batching can be completely removed", "bodyText": "this class needs some clean up to get rid of too many TODOs, eg anything related to a potential future implementation of batching can be completely removed", "bodyHTML": "<p dir=\"auto\">this class needs some clean up to get rid of too many TODOs, eg anything related to a potential future implementation of batching can be completely removed</p>", "author": "vbekiaris", "createdAt": "2020-04-01T15:55:08Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/MultiMapProxySupport.java", "diffHunk": "@@ -16,54 +16,268 @@\n \n package com.hazelcast.multimap.impl;\n \n-import com.hazelcast.internal.locksupport.LockProxySupport;\n-import com.hazelcast.internal.locksupport.LockSupportServiceImpl;\n+import com.hazelcast.cluster.Address;\n import com.hazelcast.config.MultiMapConfig;\n import com.hazelcast.core.EntryEventType;\n+import com.hazelcast.internal.locksupport.LockProxySupport;\n+import com.hazelcast.internal.locksupport.LockSupportServiceImpl;\n+import com.hazelcast.internal.partition.IPartitionService;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.SerializationService;\n+import com.hazelcast.internal.services.DistributedObjectNamespace;\n+import com.hazelcast.internal.util.ExceptionUtil;\n+import com.hazelcast.internal.util.ThreadUtil;\n+import com.hazelcast.map.impl.MapEntries;\n import com.hazelcast.multimap.impl.operations.CountOperation;\n import com.hazelcast.multimap.impl.operations.DeleteOperation;\n import com.hazelcast.multimap.impl.operations.GetAllOperation;\n import com.hazelcast.multimap.impl.operations.MultiMapOperationFactory;\n import com.hazelcast.multimap.impl.operations.MultiMapOperationFactory.OperationFactoryType;\n+import com.hazelcast.multimap.impl.operations.MultiMapPutAllOperationFactory;\n import com.hazelcast.multimap.impl.operations.MultiMapResponse;\n import com.hazelcast.multimap.impl.operations.PutOperation;\n import com.hazelcast.multimap.impl.operations.RemoveAllOperation;\n import com.hazelcast.multimap.impl.operations.RemoveOperation;\n-import com.hazelcast.internal.serialization.Data;\n import com.hazelcast.spi.impl.AbstractDistributedObject;\n-import com.hazelcast.internal.services.DistributedObjectNamespace;\n+import com.hazelcast.spi.impl.InternalCompletableFuture;\n import com.hazelcast.spi.impl.NodeEngine;\n import com.hazelcast.spi.impl.operationservice.Operation;\n-import com.hazelcast.internal.util.ExceptionUtil;\n-import com.hazelcast.internal.util.ThreadUtil;\n+import com.hazelcast.spi.impl.operationservice.OperationFactory;\n+import com.hazelcast.spi.impl.operationservice.OperationService;\n \n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n import java.util.HashSet;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.BiConsumer;\n \n+import static com.hazelcast.internal.util.CollectionUtil.asIntegerList;\n+import static com.hazelcast.internal.util.ConcurrencyUtil.CALLER_RUNS;\n+import static com.hazelcast.internal.util.ExceptionUtil.rethrow;\n import static com.hazelcast.internal.util.MapUtil.toIntSize;\n+import static com.hazelcast.internal.util.Preconditions.checkNotNull;\n+import static com.hazelcast.multimap.impl.MultiMapProxyImpl.NULL_KEY_IS_NOT_ALLOWED;\n+import static com.hazelcast.multimap.impl.MultiMapProxyImpl.NULL_VALUE_IS_NOT_ALLOWED;\n+import static com.hazelcast.spi.impl.InternalCompletableFuture.newCompletedFuture;\n+import static java.lang.Math.ceil;\n+import static java.lang.Math.log10;\n+import static java.util.Collections.singletonMap;\n \n public abstract class MultiMapProxySupport extends AbstractDistributedObject<MultiMapService> {\n \n     protected final MultiMapConfig config;\n     protected final String name;\n     protected final LockProxySupport lockSupport;\n+    protected final SerializationService serializationService;\n+    protected final OperationService operationService;\n+    protected final IPartitionService partitionService;\n+    private final float putAllInitialSizeFactor;\n \n     protected MultiMapProxySupport(MultiMapConfig config, MultiMapService service, NodeEngine nodeEngine, String name) {\n         super(nodeEngine, service);\n         this.config = config;\n         this.name = name;\n \n+        this.partitionService = nodeEngine.getPartitionService();\n+        this.serializationService = nodeEngine.getSerializationService();\n+        this.operationService = nodeEngine.getOperationService();\n+\n         lockSupport = new LockProxySupport(new DistributedObjectNamespace(MultiMapService.SERVICE_NAME, name),\n                 LockSupportServiceImpl.getMaxLeaseTimeInMillis(nodeEngine.getProperties()));\n+\n+        //TODO: implement properties and properties.getFloat(MAP_PUT_ALL_INITIAL_SIZE_FACTOR);\n+        this.putAllInitialSizeFactor = 1;\n     }\n \n     @Override\n     public String getName() {\n         return name;\n     }\n \n+    //NB: this method is copied from MapProxySupport#getPutAllInitialSize\n+    @SuppressWarnings(\"checkstyle:magicnumber\")\n+    private int getPutAllInitialSize(boolean useBatching, int mapSize, int partitionCount) {", "originalCommit": "d5eab935497c3e80d0e4201d684cae3adce677c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyNTg1MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r401725851", "body": "`entry.getValue()` is already `Data` here, no need to wrap it in `toData()`", "bodyText": "entry.getValue() is already Data here, no need to wrap it in toData()", "bodyHTML": "<p dir=\"auto\"><code>entry.getValue()</code> is already <code>Data</code> here, no need to wrap it in <code>toData()</code></p>", "author": "vbekiaris", "createdAt": "2020-04-01T15:56:58Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/MultiMapProxySupport.java", "diffHunk": "@@ -16,54 +16,268 @@\n \n package com.hazelcast.multimap.impl;\n \n-import com.hazelcast.internal.locksupport.LockProxySupport;\n-import com.hazelcast.internal.locksupport.LockSupportServiceImpl;\n+import com.hazelcast.cluster.Address;\n import com.hazelcast.config.MultiMapConfig;\n import com.hazelcast.core.EntryEventType;\n+import com.hazelcast.internal.locksupport.LockProxySupport;\n+import com.hazelcast.internal.locksupport.LockSupportServiceImpl;\n+import com.hazelcast.internal.partition.IPartitionService;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.SerializationService;\n+import com.hazelcast.internal.services.DistributedObjectNamespace;\n+import com.hazelcast.internal.util.ExceptionUtil;\n+import com.hazelcast.internal.util.ThreadUtil;\n+import com.hazelcast.map.impl.MapEntries;\n import com.hazelcast.multimap.impl.operations.CountOperation;\n import com.hazelcast.multimap.impl.operations.DeleteOperation;\n import com.hazelcast.multimap.impl.operations.GetAllOperation;\n import com.hazelcast.multimap.impl.operations.MultiMapOperationFactory;\n import com.hazelcast.multimap.impl.operations.MultiMapOperationFactory.OperationFactoryType;\n+import com.hazelcast.multimap.impl.operations.MultiMapPutAllOperationFactory;\n import com.hazelcast.multimap.impl.operations.MultiMapResponse;\n import com.hazelcast.multimap.impl.operations.PutOperation;\n import com.hazelcast.multimap.impl.operations.RemoveAllOperation;\n import com.hazelcast.multimap.impl.operations.RemoveOperation;\n-import com.hazelcast.internal.serialization.Data;\n import com.hazelcast.spi.impl.AbstractDistributedObject;\n-import com.hazelcast.internal.services.DistributedObjectNamespace;\n+import com.hazelcast.spi.impl.InternalCompletableFuture;\n import com.hazelcast.spi.impl.NodeEngine;\n import com.hazelcast.spi.impl.operationservice.Operation;\n-import com.hazelcast.internal.util.ExceptionUtil;\n-import com.hazelcast.internal.util.ThreadUtil;\n+import com.hazelcast.spi.impl.operationservice.OperationFactory;\n+import com.hazelcast.spi.impl.operationservice.OperationService;\n \n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n import java.util.HashSet;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.BiConsumer;\n \n+import static com.hazelcast.internal.util.CollectionUtil.asIntegerList;\n+import static com.hazelcast.internal.util.ConcurrencyUtil.CALLER_RUNS;\n+import static com.hazelcast.internal.util.ExceptionUtil.rethrow;\n import static com.hazelcast.internal.util.MapUtil.toIntSize;\n+import static com.hazelcast.internal.util.Preconditions.checkNotNull;\n+import static com.hazelcast.multimap.impl.MultiMapProxyImpl.NULL_KEY_IS_NOT_ALLOWED;\n+import static com.hazelcast.multimap.impl.MultiMapProxyImpl.NULL_VALUE_IS_NOT_ALLOWED;\n+import static com.hazelcast.spi.impl.InternalCompletableFuture.newCompletedFuture;\n+import static java.lang.Math.ceil;\n+import static java.lang.Math.log10;\n+import static java.util.Collections.singletonMap;\n \n public abstract class MultiMapProxySupport extends AbstractDistributedObject<MultiMapService> {\n \n     protected final MultiMapConfig config;\n     protected final String name;\n     protected final LockProxySupport lockSupport;\n+    protected final SerializationService serializationService;\n+    protected final OperationService operationService;\n+    protected final IPartitionService partitionService;\n+    private final float putAllInitialSizeFactor;\n \n     protected MultiMapProxySupport(MultiMapConfig config, MultiMapService service, NodeEngine nodeEngine, String name) {\n         super(nodeEngine, service);\n         this.config = config;\n         this.name = name;\n \n+        this.partitionService = nodeEngine.getPartitionService();\n+        this.serializationService = nodeEngine.getSerializationService();\n+        this.operationService = nodeEngine.getOperationService();\n+\n         lockSupport = new LockProxySupport(new DistributedObjectNamespace(MultiMapService.SERVICE_NAME, name),\n                 LockSupportServiceImpl.getMaxLeaseTimeInMillis(nodeEngine.getProperties()));\n+\n+        //TODO: implement properties and properties.getFloat(MAP_PUT_ALL_INITIAL_SIZE_FACTOR);\n+        this.putAllInitialSizeFactor = 1;\n     }\n \n     @Override\n     public String getName() {\n         return name;\n     }\n \n+    //NB: this method is copied from MapProxySupport#getPutAllInitialSize\n+    @SuppressWarnings(\"checkstyle:magicnumber\")\n+    private int getPutAllInitialSize(boolean useBatching, int mapSize, int partitionCount) {\n+        if (mapSize == 1) {\n+            return 1;\n+        }\n+        //TODO: implement batching\n+        /*\n+        if (useBatching) {\n+            return putAllBatchSize;\n+        }*/\n+        if (putAllInitialSizeFactor < 1) {\n+            // this is an educated guess for the initial size of the entries per partition, depending on the map size\n+            return (int) ceil(20f * mapSize / partitionCount / log10(mapSize));\n+        }\n+        return (int) ceil(putAllInitialSizeFactor * mapSize / partitionCount);\n+    }\n+\n+    //NB: this method is generally copied from MapProxySupport#putAllInternal\n+    @SuppressWarnings({\"checkstyle:npathcomplexity\", \"checkstyle:methodlength\"})\n+    protected void putAllInternal(Map<Data, Data> map,\n+                                  @Nullable InternalCompletableFuture<Void> future) {\n+\n+        //get partition to entries mapping\n+        try {\n+            int mapSize = map.size();\n+            if (mapSize == 0) {\n+                if (future != null) {\n+                    future.complete(null);\n+                }\n+                return;\n+            }\n+\n+            //TODO: implement batching\n+            //boolean useBatching = future == null && isPutAllUseBatching(mapSize);\n+            int partitionCount = partitionService.getPartitionCount();\n+            int initialSize = getPutAllInitialSize(false, mapSize, partitionCount);\n+\n+            //get node to partition mapping\n+            Map<Address, List<Integer>> memberPartitionsMap = partitionService.getMemberPartitionsMap();\n+\n+            //TODO: implement batching\n+            /*\n+            MutableLong[] counterPerMember = null;\n+            Address[] addresses = null;\n+            if (useBatching) {\n+                counterPerMember = new MutableLong[partitionCount];\n+                addresses = new Address[partitionCount];\n+                for (Map.Entry<Address, List<Integer>> addressListEntry : memberPartitionsMap.entrySet()) {\n+                    MutableLong counter = new MutableLong();\n+                    Address address = addressListEntry.getKey();\n+                    for (int partitionId : addressListEntry.getValue()) {\n+                        counterPerMember[partitionId] = counter;\n+                        addresses[partitionId] = address;\n+                    }\n+                }\n+            }\n+            */\n+\n+            // fill entriesPerPartition\n+            MapEntries[] entriesPerPartition = new MapEntries[partitionCount];\n+\n+            for (Map.Entry<Data, Data> entry : map.entrySet()) {\n+                checkNotNull(entry.getKey(), NULL_KEY_IS_NOT_ALLOWED);\n+                checkNotNull(entry.getValue(), NULL_VALUE_IS_NOT_ALLOWED);\n+\n+                //TODO: add and use PartitioningStrategy?\n+                Data keyData = entry.getKey();\n+\n+                int partitionId = partitionService.getPartitionId(keyData);\n+                MapEntries entries = entriesPerPartition[partitionId];\n+                if (entries == null) {\n+                    entries = new MapEntries(initialSize);\n+                    entriesPerPartition[partitionId] = entries;\n+                }\n+                entries.add(keyData, toData(entry.getValue()));", "originalCommit": "d5eab935497c3e80d0e4201d684cae3adce677c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyNzMyNw==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r401727327", "body": "consider adding test for stats of `putAllAsync` in `MultiMapContainerStatisticsTest`", "bodyText": "consider adding test for stats of putAllAsync in MultiMapContainerStatisticsTest", "bodyHTML": "<p dir=\"auto\">consider adding test for stats of <code>putAllAsync</code> in <code>MultiMapContainerStatisticsTest</code></p>", "author": "vbekiaris", "createdAt": "2020-04-01T15:58:55Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/MultiMapProxySupport.java", "diffHunk": "@@ -16,54 +16,268 @@\n \n package com.hazelcast.multimap.impl;\n \n-import com.hazelcast.internal.locksupport.LockProxySupport;\n-import com.hazelcast.internal.locksupport.LockSupportServiceImpl;\n+import com.hazelcast.cluster.Address;\n import com.hazelcast.config.MultiMapConfig;\n import com.hazelcast.core.EntryEventType;\n+import com.hazelcast.internal.locksupport.LockProxySupport;\n+import com.hazelcast.internal.locksupport.LockSupportServiceImpl;\n+import com.hazelcast.internal.partition.IPartitionService;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.SerializationService;\n+import com.hazelcast.internal.services.DistributedObjectNamespace;\n+import com.hazelcast.internal.util.ExceptionUtil;\n+import com.hazelcast.internal.util.ThreadUtil;\n+import com.hazelcast.map.impl.MapEntries;\n import com.hazelcast.multimap.impl.operations.CountOperation;\n import com.hazelcast.multimap.impl.operations.DeleteOperation;\n import com.hazelcast.multimap.impl.operations.GetAllOperation;\n import com.hazelcast.multimap.impl.operations.MultiMapOperationFactory;\n import com.hazelcast.multimap.impl.operations.MultiMapOperationFactory.OperationFactoryType;\n+import com.hazelcast.multimap.impl.operations.MultiMapPutAllOperationFactory;\n import com.hazelcast.multimap.impl.operations.MultiMapResponse;\n import com.hazelcast.multimap.impl.operations.PutOperation;\n import com.hazelcast.multimap.impl.operations.RemoveAllOperation;\n import com.hazelcast.multimap.impl.operations.RemoveOperation;\n-import com.hazelcast.internal.serialization.Data;\n import com.hazelcast.spi.impl.AbstractDistributedObject;\n-import com.hazelcast.internal.services.DistributedObjectNamespace;\n+import com.hazelcast.spi.impl.InternalCompletableFuture;\n import com.hazelcast.spi.impl.NodeEngine;\n import com.hazelcast.spi.impl.operationservice.Operation;\n-import com.hazelcast.internal.util.ExceptionUtil;\n-import com.hazelcast.internal.util.ThreadUtil;\n+import com.hazelcast.spi.impl.operationservice.OperationFactory;\n+import com.hazelcast.spi.impl.operationservice.OperationService;\n \n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n import java.util.HashSet;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.BiConsumer;\n \n+import static com.hazelcast.internal.util.CollectionUtil.asIntegerList;\n+import static com.hazelcast.internal.util.ConcurrencyUtil.CALLER_RUNS;\n+import static com.hazelcast.internal.util.ExceptionUtil.rethrow;\n import static com.hazelcast.internal.util.MapUtil.toIntSize;\n+import static com.hazelcast.internal.util.Preconditions.checkNotNull;\n+import static com.hazelcast.multimap.impl.MultiMapProxyImpl.NULL_KEY_IS_NOT_ALLOWED;\n+import static com.hazelcast.multimap.impl.MultiMapProxyImpl.NULL_VALUE_IS_NOT_ALLOWED;\n+import static com.hazelcast.spi.impl.InternalCompletableFuture.newCompletedFuture;\n+import static java.lang.Math.ceil;\n+import static java.lang.Math.log10;\n+import static java.util.Collections.singletonMap;\n \n public abstract class MultiMapProxySupport extends AbstractDistributedObject<MultiMapService> {\n \n     protected final MultiMapConfig config;\n     protected final String name;\n     protected final LockProxySupport lockSupport;\n+    protected final SerializationService serializationService;\n+    protected final OperationService operationService;\n+    protected final IPartitionService partitionService;\n+    private final float putAllInitialSizeFactor;\n \n     protected MultiMapProxySupport(MultiMapConfig config, MultiMapService service, NodeEngine nodeEngine, String name) {\n         super(nodeEngine, service);\n         this.config = config;\n         this.name = name;\n \n+        this.partitionService = nodeEngine.getPartitionService();\n+        this.serializationService = nodeEngine.getSerializationService();\n+        this.operationService = nodeEngine.getOperationService();\n+\n         lockSupport = new LockProxySupport(new DistributedObjectNamespace(MultiMapService.SERVICE_NAME, name),\n                 LockSupportServiceImpl.getMaxLeaseTimeInMillis(nodeEngine.getProperties()));\n+\n+        //TODO: implement properties and properties.getFloat(MAP_PUT_ALL_INITIAL_SIZE_FACTOR);\n+        this.putAllInitialSizeFactor = 1;\n     }\n \n     @Override\n     public String getName() {\n         return name;\n     }\n \n+    //NB: this method is copied from MapProxySupport#getPutAllInitialSize\n+    @SuppressWarnings(\"checkstyle:magicnumber\")\n+    private int getPutAllInitialSize(boolean useBatching, int mapSize, int partitionCount) {\n+        if (mapSize == 1) {\n+            return 1;\n+        }\n+        //TODO: implement batching\n+        /*\n+        if (useBatching) {\n+            return putAllBatchSize;\n+        }*/\n+        if (putAllInitialSizeFactor < 1) {\n+            // this is an educated guess for the initial size of the entries per partition, depending on the map size\n+            return (int) ceil(20f * mapSize / partitionCount / log10(mapSize));\n+        }\n+        return (int) ceil(putAllInitialSizeFactor * mapSize / partitionCount);\n+    }\n+\n+    //NB: this method is generally copied from MapProxySupport#putAllInternal\n+    @SuppressWarnings({\"checkstyle:npathcomplexity\", \"checkstyle:methodlength\"})\n+    protected void putAllInternal(Map<Data, Data> map,\n+                                  @Nullable InternalCompletableFuture<Void> future) {\n+\n+        //get partition to entries mapping\n+        try {\n+            int mapSize = map.size();\n+            if (mapSize == 0) {\n+                if (future != null) {\n+                    future.complete(null);\n+                }\n+                return;\n+            }\n+\n+            //TODO: implement batching\n+            //boolean useBatching = future == null && isPutAllUseBatching(mapSize);\n+            int partitionCount = partitionService.getPartitionCount();\n+            int initialSize = getPutAllInitialSize(false, mapSize, partitionCount);\n+\n+            //get node to partition mapping\n+            Map<Address, List<Integer>> memberPartitionsMap = partitionService.getMemberPartitionsMap();\n+\n+            //TODO: implement batching\n+            /*\n+            MutableLong[] counterPerMember = null;\n+            Address[] addresses = null;\n+            if (useBatching) {\n+                counterPerMember = new MutableLong[partitionCount];\n+                addresses = new Address[partitionCount];\n+                for (Map.Entry<Address, List<Integer>> addressListEntry : memberPartitionsMap.entrySet()) {\n+                    MutableLong counter = new MutableLong();\n+                    Address address = addressListEntry.getKey();\n+                    for (int partitionId : addressListEntry.getValue()) {\n+                        counterPerMember[partitionId] = counter;\n+                        addresses[partitionId] = address;\n+                    }\n+                }\n+            }\n+            */\n+\n+            // fill entriesPerPartition\n+            MapEntries[] entriesPerPartition = new MapEntries[partitionCount];\n+\n+            for (Map.Entry<Data, Data> entry : map.entrySet()) {\n+                checkNotNull(entry.getKey(), NULL_KEY_IS_NOT_ALLOWED);\n+                checkNotNull(entry.getValue(), NULL_VALUE_IS_NOT_ALLOWED);\n+\n+                //TODO: add and use PartitioningStrategy?\n+                Data keyData = entry.getKey();\n+\n+                int partitionId = partitionService.getPartitionId(keyData);\n+                MapEntries entries = entriesPerPartition[partitionId];\n+                if (entries == null) {\n+                    entries = new MapEntries(initialSize);\n+                    entriesPerPartition[partitionId] = entries;\n+                }\n+                entries.add(keyData, toData(entry.getValue()));\n+\n+                //TODO:implement batching\n+                /*\n+                if (useBatching) {\n+                    long currentSize = ++counterPerMember[partitionId].value;\n+                    if (currentSize % putAllBatchSize == 0) {\n+                        List<Integer> partitions = memberPartitionsMap.get(addresses[partitionId]);\n+                        invokePutAllOperation(addresses[partitionId], partitions, entriesPerPartition)\n+                                .get();\n+                    }\n+                }\n+                */\n+            }\n+            // invoke operations for entriesPerPartition\n+            AtomicInteger counter = new AtomicInteger(memberPartitionsMap.size());\n+            InternalCompletableFuture<Void> resultFuture =\n+                    future != null ? future : new InternalCompletableFuture<>();\n+            BiConsumer<Void, Throwable> callback = (response, t) -> {\n+                if (t != null) {\n+                    resultFuture.completeExceptionally(t);\n+                }\n+\n+                if (counter.decrementAndGet() == 0) {\n+                    //FIXME: implement finalizePutAll(map);\n+                    if (!resultFuture.isDone()) {\n+                        resultFuture.complete(null);\n+                    }\n+                }\n+            };\n+            for (Map.Entry<Address, List<Integer>> entry : memberPartitionsMap.entrySet()) {\n+                invokePutAllOperation(entry.getKey(), entry.getValue(), entriesPerPartition).whenCompleteAsync(callback);\n+            }\n+            // if executing in sync mode, block for the responses\n+            if (future == null) {\n+                resultFuture.get();\n+            }\n+        } catch (Throwable e) {\n+            throw rethrow(e);\n+        }\n+    }\n+\n+    //NB: this method is generally copied from MapProxySupport#invokePutAllOperation\n+    private InternalCompletableFuture<Void> invokePutAllOperation(\n+            Address address,\n+            List<Integer> memberPartitions,\n+            MapEntries[] entriesPerPartition\n+    ) {\n+        int size = memberPartitions.size();\n+        int[] partitions = new int[size];\n+        int index = 0;\n+        for (Integer partitionId : memberPartitions) {\n+            if (entriesPerPartition[partitionId] != null) {\n+                partitions[index++] = partitionId;\n+            }\n+        }\n+        if (index == 0) {\n+            return newCompletedFuture(null);\n+        }\n+        // trim partition array to real size\n+        if (index < size) {\n+            partitions = Arrays.copyOf(partitions, index);\n+            size = index;\n+        }\n+\n+        index = 0;\n+        MapEntries[] entries = new MapEntries[size];\n+        long totalSize = 0;\n+        for (int partitionId : partitions) {\n+            int batchSize = entriesPerPartition[partitionId].size();\n+            //FIXME: implement batching\n+            //assert (putAllBatchSize == 0 || batchSize <= putAllBatchSize);\n+            entries[index++] = entriesPerPartition[partitionId];\n+            totalSize += batchSize;\n+            entriesPerPartition[partitionId] = null;\n+        }\n+        if (totalSize == 0) {\n+            return newCompletedFuture(null);\n+        }\n+\n+        OperationFactory factory = new MultiMapPutAllOperationFactory(name, partitions, entries);\n+        long startTimeNanos = System.nanoTime();\n+        CompletableFuture<Map<Integer, Object>> future =\n+                operationService.invokeOnPartitionsAsync(MultiMapService.SERVICE_NAME, factory,\n+                        singletonMap(address, asIntegerList(partitions)));\n+        InternalCompletableFuture<Void> resultFuture = new InternalCompletableFuture<>();\n+        long finalTotalSize = totalSize;\n+        future.whenCompleteAsync((response, t) -> {\n+            //TODO: implement putAllVisitSerializedKeys\n+            //putAllVisitSerializedKeys(entries);\n+\n+            if (t == null) {\n+                //TODO: verify stats\n+                getService().getLocalMultiMapStatsImpl(name).incrementPutLatencyNanos(finalTotalSize,", "originalCommit": "d5eab935497c3e80d0e4201d684cae3adce677c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyODY0MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r401728641", "body": "I think `serializationService` can be removed as it is not used", "bodyText": "I think serializationService can be removed as it is not used", "bodyHTML": "<p dir=\"auto\">I think <code>serializationService</code> can be removed as it is not used</p>", "author": "vbekiaris", "createdAt": "2020-04-01T16:00:46Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/MultiMapProxySupport.java", "diffHunk": "@@ -16,54 +16,268 @@\n \n package com.hazelcast.multimap.impl;\n \n-import com.hazelcast.internal.locksupport.LockProxySupport;\n-import com.hazelcast.internal.locksupport.LockSupportServiceImpl;\n+import com.hazelcast.cluster.Address;\n import com.hazelcast.config.MultiMapConfig;\n import com.hazelcast.core.EntryEventType;\n+import com.hazelcast.internal.locksupport.LockProxySupport;\n+import com.hazelcast.internal.locksupport.LockSupportServiceImpl;\n+import com.hazelcast.internal.partition.IPartitionService;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.SerializationService;\n+import com.hazelcast.internal.services.DistributedObjectNamespace;\n+import com.hazelcast.internal.util.ExceptionUtil;\n+import com.hazelcast.internal.util.ThreadUtil;\n+import com.hazelcast.map.impl.MapEntries;\n import com.hazelcast.multimap.impl.operations.CountOperation;\n import com.hazelcast.multimap.impl.operations.DeleteOperation;\n import com.hazelcast.multimap.impl.operations.GetAllOperation;\n import com.hazelcast.multimap.impl.operations.MultiMapOperationFactory;\n import com.hazelcast.multimap.impl.operations.MultiMapOperationFactory.OperationFactoryType;\n+import com.hazelcast.multimap.impl.operations.MultiMapPutAllOperationFactory;\n import com.hazelcast.multimap.impl.operations.MultiMapResponse;\n import com.hazelcast.multimap.impl.operations.PutOperation;\n import com.hazelcast.multimap.impl.operations.RemoveAllOperation;\n import com.hazelcast.multimap.impl.operations.RemoveOperation;\n-import com.hazelcast.internal.serialization.Data;\n import com.hazelcast.spi.impl.AbstractDistributedObject;\n-import com.hazelcast.internal.services.DistributedObjectNamespace;\n+import com.hazelcast.spi.impl.InternalCompletableFuture;\n import com.hazelcast.spi.impl.NodeEngine;\n import com.hazelcast.spi.impl.operationservice.Operation;\n-import com.hazelcast.internal.util.ExceptionUtil;\n-import com.hazelcast.internal.util.ThreadUtil;\n+import com.hazelcast.spi.impl.operationservice.OperationFactory;\n+import com.hazelcast.spi.impl.operationservice.OperationService;\n \n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n import java.util.HashSet;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.BiConsumer;\n \n+import static com.hazelcast.internal.util.CollectionUtil.asIntegerList;\n+import static com.hazelcast.internal.util.ConcurrencyUtil.CALLER_RUNS;\n+import static com.hazelcast.internal.util.ExceptionUtil.rethrow;\n import static com.hazelcast.internal.util.MapUtil.toIntSize;\n+import static com.hazelcast.internal.util.Preconditions.checkNotNull;\n+import static com.hazelcast.multimap.impl.MultiMapProxyImpl.NULL_KEY_IS_NOT_ALLOWED;\n+import static com.hazelcast.multimap.impl.MultiMapProxyImpl.NULL_VALUE_IS_NOT_ALLOWED;\n+import static com.hazelcast.spi.impl.InternalCompletableFuture.newCompletedFuture;\n+import static java.lang.Math.ceil;\n+import static java.lang.Math.log10;\n+import static java.util.Collections.singletonMap;\n \n public abstract class MultiMapProxySupport extends AbstractDistributedObject<MultiMapService> {\n \n     protected final MultiMapConfig config;\n     protected final String name;\n     protected final LockProxySupport lockSupport;\n+    protected final SerializationService serializationService;", "originalCommit": "d5eab935497c3e80d0e4201d684cae3adce677c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1a6d23ce0fcc6cef2b790248a92f599f0d23e33c", "url": "https://github.com/hazelcast/hazelcast/commit/1a6d23ce0fcc6cef2b790248a92f599f0d23e33c", "message": "Modify interface and implementations of MultiMap.putAllAsync and related classes (#9079)\n\nRemove putAll(MultiMap) interfaces and related tests. Many other small code quality changes.\n\nAdd statistics tests for putAll. Preliminary PutBackupOperation implementation.", "committedDate": "2020-04-02T08:47:28Z", "type": "forcePushed"}, {"oid": "7068f3bc7fd60a5373689601cf7cadcb1feaf9a6", "url": "https://github.com/hazelcast/hazelcast/commit/7068f3bc7fd60a5373689601cf7cadcb1feaf9a6", "message": "    Modify interface and implementations of MultiMap.putAllAsync and related classes (#9079)\n    Remove non async and MultiMap putAll interfaces. Modify MultiMap.putAllInternal interface to take in Data, Data. Amend MultiMap.putAllAsync javadoc. Remove streams implementation. Many other small code quality changes.\n\n    Fix PutAllOperation record saving implementation. Fix incorrect MultimapDataSerializerHook reference. Implement PutAllBackupOperation, parametrize MultiMapBackupTest and clean up MultiMapProxySupport.\n\n    Add statistics tests for putAll. Preliminary PutBackupOperation implementation.\n\n    Define UnsupportedException specific Preconditions checkTrue.", "committedDate": "2020-04-04T11:53:16Z", "type": "forcePushed"}, {"oid": "3badfce8976c15696c1c12128b9eafee2fbfcda1", "url": "https://github.com/hazelcast/hazelcast/commit/3badfce8976c15696c1c12128b9eafee2fbfcda1", "message": "fix checkstyle (#9079)", "committedDate": "2020-04-07T02:05:20Z", "type": "forcePushed"}, {"oid": "13dc280e79f849bce8d255ac5660ae6c323cf568", "url": "https://github.com/hazelcast/hazelcast/commit/13dc280e79f849bce8d255ac5660ae6c323cf568", "message": "    Modify interface and implementations of MultiMap.putAllAsync and related classes (#9079)\n    Remove non async and MultiMap putAll interfaces. Modify MultiMap.putAllInternal interface to take in Data, Data. Amend MultiMap.putAllAsync javadoc. Remove streams implementation. Many other small code quality changes.\n\n    Fix PutAllOperation record saving implementation. Fix incorrect MultimapDataSerializerHook reference. Implement PutAllBackupOperation, parametrize MultiMapBackupTest and clean up MultiMapProxySupport.\n\n    Add statistics tests for putAll. Preliminary PutBackupOperation implementation.\n\n    Define UnsupportedException specific Preconditions checkTrue.", "committedDate": "2020-04-07T07:43:40Z", "type": "forcePushed"}, {"oid": "d37e0291cfa5dd30d362a20b327ae1068e3a30e3", "url": "https://github.com/hazelcast/hazelcast/commit/d37e0291cfa5dd30d362a20b327ae1068e3a30e3", "message": "Fix PutAllBackup serializer constant (#9079)", "committedDate": "2020-04-08T03:59:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQwNjI5OA==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r405406298", "body": "Two things might go wrong here:\r\n1. this is an async call; it is possible that the operation has not yet been completed by the time `assertNewLastAccessTime` below is executed.\r\n2. you miss a `sleepMillis()` statement before this one (similarly to previous code blocks in the same test) to ensure that `putAllAsync` is not executed in the same millisecond as the previous operation.\r\n\r\n\r\n```suggestion\r\n        sleepMillis(10);\r\n        multiMap.putAllAsync(key, expectedMultiMap1.get(key)).toCompletableFuture().join();\r\n```", "bodyText": "Two things might go wrong here:\n\nthis is an async call; it is possible that the operation has not yet been completed by the time assertNewLastAccessTime below is executed.\nyou miss a sleepMillis() statement before this one (similarly to previous code blocks in the same test) to ensure that putAllAsync is not executed in the same millisecond as the previous operation.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    multiMap.putAllAsync(key, expectedMultiMap1.get(key));\n          \n          \n            \n                    sleepMillis(10);\n          \n          \n            \n                    multiMap.putAllAsync(key, expectedMultiMap1.get(key)).toCompletableFuture().join();", "bodyHTML": "<p dir=\"auto\">Two things might go wrong here:</p>\n<ol dir=\"auto\">\n<li>this is an async call; it is possible that the operation has not yet been completed by the time <code>assertNewLastAccessTime</code> below is executed.</li>\n<li>you miss a <code>sleepMillis()</code> statement before this one (similarly to previous code blocks in the same test) to ensure that <code>putAllAsync</code> is not executed in the same millisecond as the previous operation.</li>\n</ol>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"x x-first\">multiMap</span><span class=\"pl-k x\">.</span><span class=\"x\">putAllAsync(key, expectedMultiMap1</span><span class=\"pl-k x\">.</span><span class=\"x x-last\">get(key)</span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"x x-first\">sleepMillis(</span><span class=\"pl-c1 x x-last\">10</span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        multiMap<span class=\"pl-k\">.</span>putAllAsync(key, expectedMultiMap1<span class=\"pl-k\">.</span>get(key))<span class=\"pl-k\">.</span>toCompletableFuture()<span class=\"pl-k\">.</span>join();</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "vbekiaris", "createdAt": "2020-04-08T10:00:23Z", "path": "hazelcast/src/test/java/com/hazelcast/multimap/MultiMapContainerStatisticsTest.java", "diffHunk": "@@ -143,6 +157,33 @@ public void testMultiMapContainerStats() {\n         assertNewLastAccessTime();\n         assertNewLastUpdateTime();\n \n+        Map<String, Collection<? extends String>> expectedMultiMap1 = new HashMap<>();\n+        // a successful putAll(Map) operation on a Hash backed mmap updates the lastAccessTime and lastUpdateTime\n+        expectedMultiMap1.put(key, new ArrayList<>(Arrays.asList(\"value\", \"value\", \"value\")));\n+        multiMap.putAllAsync(expectedMultiMap1);\n+        assertNewLastAccessTime();\n+        assertNewLastUpdateTime();\n+        // a successful clear operation updates the lastAccessTime and the lastUpdateTime\n+        sleepMillis(10);\n+        multiMap.clear();\n+        assertNewLastAccessTime();\n+        assertNewLastUpdateTime();\n+\n+        // a successful putAll(K,V) operation on a Hash backed mmap updates the lastAccessTime and lastUpdateTime\n+        multiMap.putAllAsync(key, expectedMultiMap1.get(key));", "originalCommit": "d37e0291cfa5dd30d362a20b327ae1068e3a30e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYyMjExOA==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r405622118", "body": "minor: `currentIndex` can be a local variable in `run` method", "bodyText": "minor: currentIndex can be a local variable in run method", "bodyHTML": "<p dir=\"auto\">minor: <code>currentIndex</code> can be a local variable in <code>run</code> method</p>", "author": "vbekiaris", "createdAt": "2020-04-08T15:41:24Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/operations/PutAllOperation.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.multimap.impl.operations;\n+\n+import com.hazelcast.core.EntryEventType;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.map.impl.MapEntries;\n+import com.hazelcast.multimap.impl.MultiMapContainer;\n+import com.hazelcast.multimap.impl.MultiMapDataSerializerHook;\n+import com.hazelcast.multimap.impl.MultiMapRecord;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.spi.impl.operationservice.BackupAwareOperation;\n+import com.hazelcast.spi.impl.operationservice.MutatingOperation;\n+import com.hazelcast.spi.impl.operationservice.Operation;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+public class PutAllOperation extends AbstractMultiMapOperation implements MutatingOperation, BackupAwareOperation {\n+    private transient int currentIndex;", "originalCommit": "9f1a3464f2c64eea95c9944bf66fb530977a8fd2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYyNDE4NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r405624185", "body": "no need to track each new value. We only care if something changed so the backup operation can be created and executed or avoid the backup in case nothing changed.", "bodyText": "no need to track each new value. We only care if something changed so the backup operation can be created and executed or avoid the backup in case nothing changed.", "bodyHTML": "<p dir=\"auto\">no need to track each new value. We only care if something changed so the backup operation can be created and executed or avoid the backup in case nothing changed.</p>", "author": "vbekiaris", "createdAt": "2020-04-08T15:44:14Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/operations/PutAllOperation.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.multimap.impl.operations;\n+\n+import com.hazelcast.core.EntryEventType;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.map.impl.MapEntries;\n+import com.hazelcast.multimap.impl.MultiMapContainer;\n+import com.hazelcast.multimap.impl.MultiMapDataSerializerHook;\n+import com.hazelcast.multimap.impl.MultiMapRecord;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.spi.impl.operationservice.BackupAwareOperation;\n+import com.hazelcast.spi.impl.operationservice.MutatingOperation;\n+import com.hazelcast.spi.impl.operationservice.Operation;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+public class PutAllOperation extends AbstractMultiMapOperation implements MutatingOperation, BackupAwareOperation {\n+    private transient int currentIndex;\n+    private MapEntries mapEntries;\n+\n+    public PutAllOperation() {\n+        super();\n+    }\n+\n+    public PutAllOperation(String name, MapEntries mapEntries) {\n+        super(name);\n+        this.mapEntries = mapEntries;\n+        //NB: general structure copied from c.hz.map.impl.operation.PutAllOperation\n+    }\n+\n+    @Override\n+    public final void run() {\n+        int size = mapEntries != null ? mapEntries.size() : 0;\n+        while (currentIndex < size) {\n+            Data dataKey = mapEntries.getKey(currentIndex);\n+            Data value = mapEntries.getValue(currentIndex);\n+            put(dataKey, value);\n+            currentIndex++;\n+        }\n+    }\n+\n+    protected void put(Data dataKey, Data dataValue) {\n+        MultiMapContainer container = getOrCreateContainer();\n+        Collection c = (Collection) toObject(dataValue);\n+        Collection<MultiMapRecord> coll = container.getOrCreateMultiMapValue(dataKey).getCollection(false);\n+        Iterator it = c.iterator();\n+\n+        while (it.hasNext()) {\n+            Object o = it.next();\n+            //NB: the collection values are always passed in as unencoded objects\n+            MultiMapRecord record = new MultiMapRecord(container.nextId(), isBinary() ? toData(o) : o);\n+            if (coll.add(record)) {\n+                //NB: cant put htis in afterRun because we want to notify on each new value\n+                getOrCreateContainer().update();\n+                publishEvent(EntryEventType.ADDED, dataKey, o, null);\n+                //would it be worthwhile to track all the additions and have a response array?", "originalCommit": "9f1a3464f2c64eea95c9944bf66fb530977a8fd2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYyNjQwOA==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r405626408", "body": "Sleeping for 10 seconds is a bit of a stretch for a `QuickTest`. Is this necessary?", "bodyText": "Sleeping for 10 seconds is a bit of a stretch for a QuickTest. Is this necessary?", "bodyHTML": "<p dir=\"auto\">Sleeping for 10 seconds is a bit of a stretch for a <code>QuickTest</code>. Is this necessary?</p>", "author": "vbekiaris", "createdAt": "2020-04-08T15:47:30Z", "path": "hazelcast/src/test/java/com/hazelcast/multimap/LocalMultiMapStatsTest.java", "diffHunk": "@@ -74,10 +99,65 @@ public void testPutAndHitsGenerated() {\n             map.get(i);\n         }\n         LocalMapStats localMapStats = getMultiMapStats();\n+\n         assertEquals(100, localMapStats.getPutOperationCount());\n         assertEquals(100, localMapStats.getHits());\n     }\n \n+    public void testPutAllAndHitsGeneratedTemplate(Map<Integer, Collection<? extends Integer>> expectedMultiMap1,\n+                                                   Consumer<MultiMap<Integer, Integer>> putAllOperation1) {\n+        MultiMap<Integer, Integer> mmap1 = getMultiMap();\n+        MultiMap<Integer, Integer> mmap2 = getMultiMap(mapNameSet);\n+        for (int i = 0; i < 100; i++) {\n+            expectedMultiMap1.put(i, new ArrayList<>(Arrays.asList(1, 1, 1)));\n+        }\n+\n+        putAllOperation1.accept(mmap1);\n+        putAllOperation1.accept(mmap2);\n+\n+        sleepMillis(10000);", "originalCommit": "9f1a3464f2c64eea95c9944bf66fb530977a8fd2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYyOTUyOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r405629529", "body": "minor: could use diamond operator instead of `<Integer>` (here and a few more places below)", "bodyText": "minor: could use diamond operator instead of <Integer> (here and a few more places below)", "bodyHTML": "<p dir=\"auto\">minor: could use diamond operator instead of <code>&lt;Integer&gt;</code> (here and a few more places below)</p>", "author": "vbekiaris", "createdAt": "2020-04-08T15:51:47Z", "path": "hazelcast/src/test/java/com/hazelcast/multimap/MultiMapTest.java", "diffHunk": "@@ -104,6 +114,147 @@ public void testMultiMapPutGetRemove() {\n         assertEquals(0, multiMap.size());\n     }\n \n+    protected <K, V> EntryListener<K, V> putAllEntryListenerBuilder(Consumer<EntryEvent<K, V>> f) {\n+        return new EntryAdapter<K, V>() {\n+            public void entryAdded(EntryEvent<K, V> event) {\n+                f.accept(event);\n+            }\n+\n+            public void entryRemoved(EntryEvent<K, V> event) {\n+            }\n+\n+            public void entryEvicted(EntryEvent<K, V> event) {\n+                entryRemoved(event);\n+            }\n+\n+            @Override\n+            public void mapEvicted(MapEvent event) {\n+            }\n+\n+            @Override\n+            public void mapCleared(MapEvent event) {\n+            }\n+        };\n+    }\n+\n+    protected HazelcastInstance testMultiMapPutAllSetup() {\n+        MultiMapConfig multiMapConfig1 = new MultiMapConfig()\n+                .setName(\"testMultiMapPutAllMapList\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.LIST)\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig2 = new MultiMapConfig()\n+                .setName(\"testMultiMapPutAllMapSet\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.SET)\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig3 = new MultiMapConfig()\n+                .setName(\"expectedMultiMap1\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.LIST)\n+                .setBinary(false);\n+        Config cfg = smallInstanceConfig()\n+                .addMultiMapConfig(multiMapConfig1)\n+                .addMultiMapConfig(multiMapConfig2)\n+                .addMultiMapConfig(multiMapConfig3);\n+        HazelcastInstance hz = createHazelcastInstanceFactory(1)\n+                .newInstances(cfg)[0];\n+\n+        return hz;\n+    }\n+\n+    public void testMultiMapPutAllTemplate(HazelcastInstance instance1,\n+                                           Map<String, Collection<? extends Integer>> expectedMultiMap1,\n+                                           Consumer<MultiMap<String, Integer>> putAllOperation1)\n+            throws InterruptedException {\n+\n+        MultiMap<String, Integer> mmap1 = instance1.getMultiMap(\"testMultiMapPutAllMapList\");\n+        MultiMap<String, Integer> mmap2 = instance1.getMultiMap(\"testMultiMapPutAllMapSet\");\n+        Map<String, Collection<Integer>> resultMap1 = new HashMap<>();\n+        Map<String, Collection<Integer>> resultMap2 = new HashMap<>();\n+\n+        int totalItems = 0;\n+        Set<String> ks = expectedMultiMap1.keySet();\n+        for (String s : ks) {\n+            Collection expectedCollection = expectedMultiMap1.get(s);\n+            totalItems += expectedCollection.size()\n+                    + ((Long) expectedCollection.stream().distinct().count()).intValue();\n+        }\n+\n+        final CountDownLatch latchAdded = new CountDownLatch(totalItems);\n+        mmap1.addEntryListener(putAllEntryListenerBuilder((event) -> {\n+                    String key = (String) event.getKey();\n+                    Integer value = (Integer) event.getValue();\n+                    Collection<Integer> c;\n+                    if (!resultMap1.containsKey(key)) {\n+                        c = new ArrayList<>();\n+                    } else {\n+                        c = resultMap1.get(key);\n+                    }\n+                    c.add(value);\n+                    resultMap1.put(key, c);\n+                    latchAdded.countDown();\n+                }\n+        ), true);\n+        mmap2.addEntryListener(putAllEntryListenerBuilder((event) -> {\n+                    String key = (String) event.getKey();\n+                    Integer value = (Integer) event.getValue();\n+                    Collection<Integer> c;\n+                    if (!resultMap2.containsKey(key)) {\n+                        c = new ArrayList<>();\n+                    } else {\n+                        c = resultMap2.get(key);\n+                    }\n+                    c.add(value);\n+\n+                    resultMap2.put(key, c);\n+                    latchAdded.countDown();\n+                }\n+        ), true);\n+\n+        putAllOperation1.accept(mmap1);\n+        putAllOperation1.accept(mmap2);\n+        latchAdded.await(5, TimeUnit.MINUTES);\n+        sleepMillis(10000);\n+\n+        for (String s : ks) {\n+            Collection c1 = resultMap1.get(s);\n+            Collection c2 = resultMap2.get(s);\n+            Collection expectedCollection = expectedMultiMap1.get(s);\n+            assertEquals(expectedCollection.size(), c1.size());\n+            assertEquals(expectedCollection.stream().distinct().count(), c2.size());\n+        }\n+    }\n+\n+    @Test\n+    public void testMultiMapPutAllAsyncMap() throws InterruptedException {\n+        Map<String, Collection<? extends Integer>> expectedMultiMap1 = new HashMap<>();\n+        expectedMultiMap1.put(\"A\", new ArrayList<Integer>(Arrays.asList(1, 1, 1, 1, 2)));", "originalCommit": "9f1a3464f2c64eea95c9944bf66fb530977a8fd2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc1OTY4Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r405759687", "body": "I just realized there is an issue with the serialization of the `Collection<? extends V> value` here:\r\n- `Collection<? extends V>` is serialized to `Data`\r\n- It will then be passed on as value to `MapEntries` field of `PutAllOperation`\r\n- In [`PutAllOperation`](https://github.com/hazelcast/hazelcast/pull/16698/files#diff-a4c616539a59466e148996ae5c3b77e2R62) it is deserialized. The `Data` will be deserialized to `Collection<? extends V>`. The problem with this is that it requires that the collection's element class `Class<? extends V>` must be present on the server, even when the `MultiMap` stores items in `binary` format.\r\n\r\nThe solution is to first serialize each element, so the `Collection<? extends V>` is turned to a `Collection<Data>`, then perform the serialization of `Collection<Data>` to a single `Data` to be put in your `dataMap`:\r\n```\r\nfor (Map.Entry e : m.entrySet()) {\r\n  Collection<Data> dataCollection = asDataCollection(e.getValue());\r\n  dataMap.put(toData(e.getKey()), toData(dataCollection));\r\n}\r\n...\r\nCollection<Data> asDataCollection(Collection<? extends V> values) {\r\n  // iterate values and serialize each\r\n}\r\n```", "bodyText": "I just realized there is an issue with the serialization of the Collection<? extends V> value here:\n\nCollection<? extends V> is serialized to Data\nIt will then be passed on as value to MapEntries field of PutAllOperation\nIn PutAllOperation it is deserialized. The Data will be deserialized to Collection<? extends V>. The problem with this is that it requires that the collection's element class Class<? extends V> must be present on the server, even when the MultiMap stores items in binary format.\n\nThe solution is to first serialize each element, so the Collection<? extends V> is turned to a Collection<Data>, then perform the serialization of Collection<Data> to a single Data to be put in your dataMap:\nfor (Map.Entry e : m.entrySet()) {\n  Collection<Data> dataCollection = asDataCollection(e.getValue());\n  dataMap.put(toData(e.getKey()), toData(dataCollection));\n}\n...\nCollection<Data> asDataCollection(Collection<? extends V> values) {\n  // iterate values and serialize each\n}", "bodyHTML": "<p dir=\"auto\">I just realized there is an issue with the serialization of the <code>Collection&lt;? extends V&gt; value</code> here:</p>\n<ul dir=\"auto\">\n<li><code>Collection&lt;? extends V&gt;</code> is serialized to <code>Data</code></li>\n<li>It will then be passed on as value to <code>MapEntries</code> field of <code>PutAllOperation</code></li>\n<li>In <a href=\"https://github.com/hazelcast/hazelcast/pull/16698/files#diff-a4c616539a59466e148996ae5c3b77e2R62\"><code>PutAllOperation</code></a> it is deserialized. The <code>Data</code> will be deserialized to <code>Collection&lt;? extends V&gt;</code>. The problem with this is that it requires that the collection's element class <code>Class&lt;? extends V&gt;</code> must be present on the server, even when the <code>MultiMap</code> stores items in <code>binary</code> format.</li>\n</ul>\n<p dir=\"auto\">The solution is to first serialize each element, so the <code>Collection&lt;? extends V&gt;</code> is turned to a <code>Collection&lt;Data&gt;</code>, then perform the serialization of <code>Collection&lt;Data&gt;</code> to a single <code>Data</code> to be put in your <code>dataMap</code>:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"for (Map.Entry e : m.entrySet()) {\n  Collection&lt;Data&gt; dataCollection = asDataCollection(e.getValue());\n  dataMap.put(toData(e.getKey()), toData(dataCollection));\n}\n...\nCollection&lt;Data&gt; asDataCollection(Collection&lt;? extends V&gt; values) {\n  // iterate values and serialize each\n}\"><pre><code>for (Map.Entry e : m.entrySet()) {\n  Collection&lt;Data&gt; dataCollection = asDataCollection(e.getValue());\n  dataMap.put(toData(e.getKey()), toData(dataCollection));\n}\n...\nCollection&lt;Data&gt; asDataCollection(Collection&lt;? extends V&gt; values) {\n  // iterate values and serialize each\n}\n</code></pre></div>", "author": "vbekiaris", "createdAt": "2020-04-08T19:24:12Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/MultiMapProxyImpl.java", "diffHunk": "@@ -92,6 +101,31 @@ public void initialize() {\n         }\n     }\n \n+    @Override\n+    public CompletionStage<Void> putAllAsync(@Nonnull Map<? extends K, Collection<? extends V>> m) {\n+        checkTrueUnsupportedOperation(isClusterVersionGreaterOrEqual(Versions.V4_1), MINIMUM_VERSION_ERROR_4_1);\n+        InternalCompletableFuture<Void> future = new InternalCompletableFuture<>();\n+        Map<Data, Data> dataMap = new HashMap<>();\n+\n+        for (Map.Entry e : m.entrySet()) {\n+            dataMap.put(toData(e.getKey()), toData(e.getValue()));", "originalCommit": "9f1a3464f2c64eea95c9944bf66fb530977a8fd2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc2MDYzMA==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r405760630", "body": "This will be a `Collection<Data> c` (once you implement serialization as described in the comment in `MultiMapProxyImpl`)", "bodyText": "This will be a Collection<Data> c (once you implement serialization as described in the comment in MultiMapProxyImpl)", "bodyHTML": "<p dir=\"auto\">This will be a <code>Collection&lt;Data&gt; c</code> (once you implement serialization as described in the comment in <code>MultiMapProxyImpl</code>)</p>", "author": "vbekiaris", "createdAt": "2020-04-08T19:26:08Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/operations/PutAllOperation.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.multimap.impl.operations;\n+\n+import com.hazelcast.core.EntryEventType;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.map.impl.MapEntries;\n+import com.hazelcast.multimap.impl.MultiMapContainer;\n+import com.hazelcast.multimap.impl.MultiMapDataSerializerHook;\n+import com.hazelcast.multimap.impl.MultiMapRecord;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.spi.impl.operationservice.BackupAwareOperation;\n+import com.hazelcast.spi.impl.operationservice.MutatingOperation;\n+import com.hazelcast.spi.impl.operationservice.Operation;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+public class PutAllOperation extends AbstractMultiMapOperation implements MutatingOperation, BackupAwareOperation {\n+    private transient int currentIndex;\n+    private MapEntries mapEntries;\n+\n+    public PutAllOperation() {\n+        super();\n+    }\n+\n+    public PutAllOperation(String name, MapEntries mapEntries) {\n+        super(name);\n+        this.mapEntries = mapEntries;\n+        //NB: general structure copied from c.hz.map.impl.operation.PutAllOperation\n+    }\n+\n+    @Override\n+    public final void run() {\n+        int size = mapEntries != null ? mapEntries.size() : 0;\n+        while (currentIndex < size) {\n+            Data dataKey = mapEntries.getKey(currentIndex);\n+            Data value = mapEntries.getValue(currentIndex);\n+            put(dataKey, value);\n+            currentIndex++;\n+        }\n+    }\n+\n+    protected void put(Data dataKey, Data dataValue) {\n+        MultiMapContainer container = getOrCreateContainer();\n+        Collection c = (Collection) toObject(dataValue);", "originalCommit": "9f1a3464f2c64eea95c9944bf66fb530977a8fd2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc2MTY1MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r405761651", "body": "`o` will be already `Data`, so instead of `isBinary() ? toData(o) : o`, change this to `isBinary() ? o : toObject(o)`\r\n(once you implement serialization as described in the comment in MultiMapProxyImpl).", "bodyText": "o will be already Data, so instead of isBinary() ? toData(o) : o, change this to isBinary() ? o : toObject(o)\n(once you implement serialization as described in the comment in MultiMapProxyImpl).", "bodyHTML": "<p dir=\"auto\"><code>o</code> will be already <code>Data</code>, so instead of <code>isBinary() ? toData(o) : o</code>, change this to <code>isBinary() ? o : toObject(o)</code><br>\n(once you implement serialization as described in the comment in MultiMapProxyImpl).</p>", "author": "vbekiaris", "createdAt": "2020-04-08T19:28:05Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/operations/PutAllOperation.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.multimap.impl.operations;\n+\n+import com.hazelcast.core.EntryEventType;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.map.impl.MapEntries;\n+import com.hazelcast.multimap.impl.MultiMapContainer;\n+import com.hazelcast.multimap.impl.MultiMapDataSerializerHook;\n+import com.hazelcast.multimap.impl.MultiMapRecord;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.spi.impl.operationservice.BackupAwareOperation;\n+import com.hazelcast.spi.impl.operationservice.MutatingOperation;\n+import com.hazelcast.spi.impl.operationservice.Operation;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+public class PutAllOperation extends AbstractMultiMapOperation implements MutatingOperation, BackupAwareOperation {\n+    private transient int currentIndex;\n+    private MapEntries mapEntries;\n+\n+    public PutAllOperation() {\n+        super();\n+    }\n+\n+    public PutAllOperation(String name, MapEntries mapEntries) {\n+        super(name);\n+        this.mapEntries = mapEntries;\n+        //NB: general structure copied from c.hz.map.impl.operation.PutAllOperation\n+    }\n+\n+    @Override\n+    public final void run() {\n+        int size = mapEntries != null ? mapEntries.size() : 0;\n+        while (currentIndex < size) {\n+            Data dataKey = mapEntries.getKey(currentIndex);\n+            Data value = mapEntries.getValue(currentIndex);\n+            put(dataKey, value);\n+            currentIndex++;\n+        }\n+    }\n+\n+    protected void put(Data dataKey, Data dataValue) {\n+        MultiMapContainer container = getOrCreateContainer();\n+        Collection c = (Collection) toObject(dataValue);\n+        Collection<MultiMapRecord> coll = container.getOrCreateMultiMapValue(dataKey).getCollection(false);\n+        Iterator it = c.iterator();\n+\n+        while (it.hasNext()) {\n+            Object o = it.next();\n+            //NB: the collection values are always passed in as unencoded objects\n+            MultiMapRecord record = new MultiMapRecord(container.nextId(), isBinary() ? toData(o) : o);", "originalCommit": "9f1a3464f2c64eea95c9944bf66fb530977a8fd2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "22d4bca64919908655498a18f8ac25e227ed4cbe", "url": "https://github.com/hazelcast/hazelcast/commit/22d4bca64919908655498a18f8ac25e227ed4cbe", "message": "Pass in Collection<Data> to putAllOperation. (#9079)\nAllow for serializing and deserializing Data to Collections Serializer. Strip type info from Array and HashSet Serializer initially. Save and read isData flag during de/serialization.", "committedDate": "2020-04-09T11:17:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM5OTUzNg==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r407399536", "body": "```suggestion\r\n            dataMap.put(toData(e.getKey()), toData(new DataCollection(dataCollection)));\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        dataMap.put(toData(e.getKey()), toData(dataCollection));\n          \n          \n            \n                        dataMap.put(toData(e.getKey()), toData(new DataCollection(dataCollection)));", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            dataMap<span class=\"pl-k\">.</span>put(toData(e<span class=\"pl-k\">.</span>getKey()), toData(dataCollection));</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            dataMap<span class=\"pl-k\">.</span>put(toData(e<span class=\"pl-k\">.</span>getKey()), toData(<span class=\"pl-k x x-first\">new</span><span class=\"x\"> </span><span class=\"pl-smi x\">DataCollection</span><span class=\"x x-last\">(</span>dataCollection<span class=\"x x-first x-last\">)</span>));</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "vbekiaris", "createdAt": "2020-04-13T09:32:47Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/MultiMapProxyImpl.java", "diffHunk": "@@ -92,6 +102,37 @@ public void initialize() {\n         }\n     }\n \n+    @Override\n+    public CompletionStage<Void> putAllAsync(@Nonnull Map<? extends K, Collection<? extends V>> m) {\n+        checkTrueUnsupportedOperation(isClusterVersionGreaterOrEqual(Versions.V4_1), MINIMUM_VERSION_ERROR_4_1);\n+        InternalCompletableFuture<Void> future = new InternalCompletableFuture<>();\n+        Map<Data, Data> dataMap = new HashMap<>();\n+\n+        for (Map.Entry e : m.entrySet()) {\n+            Collection<Data> dataCollection = CollectionUtil\n+                    .objectToDataCollection(((Collection<? extends V>) e.getValue()),\n+                            getNodeEngine().getSerializationService());\n+\n+            dataMap.put(toData(e.getKey()), toData(dataCollection));", "originalCommit": "22d4bca64919908655498a18f8ac25e227ed4cbe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM5OTY2Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r407399667", "body": "```suggestion\r\n        dataMap.put(toData(key), toData(new DataCollection(dataCollection)));\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    dataMap.put(toData(key), toData(dataCollection));\n          \n          \n            \n                    dataMap.put(toData(key), toData(new DataCollection(dataCollection)));", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        dataMap<span class=\"pl-k\">.</span>put(toData(key), toData(dataCollection));</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        dataMap<span class=\"pl-k\">.</span>put(toData(key), toData(<span class=\"pl-k x x-first\">new</span><span class=\"x\"> </span><span class=\"pl-smi x\">DataCollection</span><span class=\"x x-last\">(</span>dataCollection<span class=\"x x-first x-last\">)</span>));</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "vbekiaris", "createdAt": "2020-04-13T09:33:08Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/MultiMapProxyImpl.java", "diffHunk": "@@ -92,6 +102,37 @@ public void initialize() {\n         }\n     }\n \n+    @Override\n+    public CompletionStage<Void> putAllAsync(@Nonnull Map<? extends K, Collection<? extends V>> m) {\n+        checkTrueUnsupportedOperation(isClusterVersionGreaterOrEqual(Versions.V4_1), MINIMUM_VERSION_ERROR_4_1);\n+        InternalCompletableFuture<Void> future = new InternalCompletableFuture<>();\n+        Map<Data, Data> dataMap = new HashMap<>();\n+\n+        for (Map.Entry e : m.entrySet()) {\n+            Collection<Data> dataCollection = CollectionUtil\n+                    .objectToDataCollection(((Collection<? extends V>) e.getValue()),\n+                            getNodeEngine().getSerializationService());\n+\n+            dataMap.put(toData(e.getKey()), toData(dataCollection));\n+        }\n+        putAllInternal(dataMap, future);\n+        return future;\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> putAllAsync(@Nonnull K key, @Nonnull Collection<? extends V> value) {\n+        checkTrueUnsupportedOperation(isClusterVersionGreaterOrEqual(Versions.V4_1), MINIMUM_VERSION_ERROR_4_1);\n+        InternalCompletableFuture<Void> future = new InternalCompletableFuture<>();\n+        Map<Data, Data> dataMap = new HashMap<>();\n+\n+        Collection<Data> dataCollection = CollectionUtil\n+                .objectToDataCollection(value, getNodeEngine().getSerializationService());\n+        dataMap.put(toData(key), toData(dataCollection));", "originalCommit": "22d4bca64919908655498a18f8ac25e227ed4cbe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQwMDAwNg==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r407400006", "body": "```suggestion\r\n        DataCollection c = (DataCollection) toObject(dataValue);\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Collection<Data> c = (Collection<Data>) toObject(dataValue);\n          \n          \n            \n                    DataCollection c = (DataCollection) toObject(dataValue);", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\"><span class=\"x x-first\">Collection&lt;</span><span class=\"pl-smi x\">Data</span><span class=\"x x-last\">&gt;</span></span> c <span class=\"pl-k\">=</span> (<span class=\"pl-k\"><span class=\"x x-first\">Collection&lt;</span><span class=\"pl-smi x\">Data</span><span class=\"x x-last\">&gt;</span></span>) toObject(dataValue);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-smi x x-first x-last\">DataCollection</span> c <span class=\"pl-k\">=</span> (<span class=\"pl-smi x x-first x-last\">DataCollection</span>) toObject(dataValue);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "vbekiaris", "createdAt": "2020-04-13T09:34:07Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/operations/PutAllOperation.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.multimap.impl.operations;\n+\n+import com.hazelcast.core.EntryEventType;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.map.impl.MapEntries;\n+import com.hazelcast.multimap.impl.MultiMapContainer;\n+import com.hazelcast.multimap.impl.MultiMapDataSerializerHook;\n+import com.hazelcast.multimap.impl.MultiMapRecord;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.spi.impl.operationservice.BackupAwareOperation;\n+import com.hazelcast.spi.impl.operationservice.MutatingOperation;\n+import com.hazelcast.spi.impl.operationservice.Operation;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+public class PutAllOperation extends AbstractMultiMapOperation implements MutatingOperation, BackupAwareOperation {\n+    private MapEntries mapEntries;\n+\n+    public PutAllOperation() {\n+        super();\n+    }\n+\n+    public PutAllOperation(String name, MapEntries mapEntries) {\n+        super(name);\n+        this.mapEntries = mapEntries;\n+        //NB: general structure copied from c.hz.map.impl.operation.PutAllOperation\n+    }\n+\n+    @Override\n+    public final void run() {\n+        int size = mapEntries != null ? mapEntries.size() : 0;\n+        int currentIndex = 0;\n+        while (currentIndex < size) {\n+            Data dataKey = mapEntries.getKey(currentIndex);\n+            Data value = mapEntries.getValue(currentIndex);\n+            put(dataKey, value);\n+            currentIndex++;\n+        }\n+    }\n+\n+    protected void put(Data dataKey, Data dataValue) {\n+        MultiMapContainer container = getOrCreateContainer();\n+        Collection<Data> c = (Collection<Data>) toObject(dataValue);", "originalCommit": "22d4bca64919908655498a18f8ac25e227ed4cbe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQwMDExMg==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r407400112", "body": "```suggestion\r\n        Iterator<Data> it = c.getCollection().iterator();\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Iterator it = c.iterator();\n          \n          \n            \n                    Iterator<Data> it = c.getCollection().iterator();", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-smi\">Iterator</span> it <span class=\"pl-k\">=</span> c<span class=\"pl-k\">.</span>iterator();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">Iterator<span class=\"x x-first\">&lt;</span><span class=\"pl-smi x\">Data</span><span class=\"x x-last\">&gt;</span></span> it <span class=\"pl-k\">=</span> c<span class=\"pl-k x x-first\">.</span><span class=\"x x-last\">getCollection()</span><span class=\"pl-k\">.</span>iterator();</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "vbekiaris", "createdAt": "2020-04-13T09:34:23Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/operations/PutAllOperation.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.multimap.impl.operations;\n+\n+import com.hazelcast.core.EntryEventType;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.map.impl.MapEntries;\n+import com.hazelcast.multimap.impl.MultiMapContainer;\n+import com.hazelcast.multimap.impl.MultiMapDataSerializerHook;\n+import com.hazelcast.multimap.impl.MultiMapRecord;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.spi.impl.operationservice.BackupAwareOperation;\n+import com.hazelcast.spi.impl.operationservice.MutatingOperation;\n+import com.hazelcast.spi.impl.operationservice.Operation;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+public class PutAllOperation extends AbstractMultiMapOperation implements MutatingOperation, BackupAwareOperation {\n+    private MapEntries mapEntries;\n+\n+    public PutAllOperation() {\n+        super();\n+    }\n+\n+    public PutAllOperation(String name, MapEntries mapEntries) {\n+        super(name);\n+        this.mapEntries = mapEntries;\n+        //NB: general structure copied from c.hz.map.impl.operation.PutAllOperation\n+    }\n+\n+    @Override\n+    public final void run() {\n+        int size = mapEntries != null ? mapEntries.size() : 0;\n+        int currentIndex = 0;\n+        while (currentIndex < size) {\n+            Data dataKey = mapEntries.getKey(currentIndex);\n+            Data value = mapEntries.getValue(currentIndex);\n+            put(dataKey, value);\n+            currentIndex++;\n+        }\n+    }\n+\n+    protected void put(Data dataKey, Data dataValue) {\n+        MultiMapContainer container = getOrCreateContainer();\n+        Collection<Data> c = (Collection<Data>) toObject(dataValue);\n+        Collection<MultiMapRecord> coll = container.getOrCreateMultiMapValue(dataKey).getCollection(false);\n+        Iterator it = c.iterator();", "originalCommit": "22d4bca64919908655498a18f8ac25e227ed4cbe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQwMDkyMg==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r407400922", "body": "this method needs to be updated similarly to `PutAllOperation` to take into account serialization and also handle properly binary data.", "bodyText": "this method needs to be updated similarly to PutAllOperation to take into account serialization and also handle properly binary data.", "bodyHTML": "<p dir=\"auto\">this method needs to be updated similarly to <code>PutAllOperation</code> to take into account serialization and also handle properly binary data.</p>", "author": "vbekiaris", "createdAt": "2020-04-13T09:36:46Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/operations/PutAllBackupOperation.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.multimap.impl.operations;\n+\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.map.impl.MapEntries;\n+import com.hazelcast.multimap.impl.MultiMapContainer;\n+import com.hazelcast.multimap.impl.MultiMapDataSerializerHook;\n+import com.hazelcast.multimap.impl.MultiMapRecord;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.spi.impl.operationservice.BackupOperation;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+public class PutAllBackupOperation extends AbstractMultiMapOperation implements BackupOperation {\n+    private transient int currentIndex;\n+    private MapEntries mapEntries;\n+\n+    public PutAllBackupOperation() {\n+    }\n+\n+    public PutAllBackupOperation(String name, MapEntries mapEntries) {\n+        super(name);\n+        this.mapEntries = mapEntries;\n+    }\n+\n+    @Override\n+    public void run() throws Exception {\n+        int size = mapEntries != null ? mapEntries.size() : 0;\n+        while (currentIndex < size) {\n+            Data dataKey = mapEntries.getKey(currentIndex);\n+            Data value = mapEntries.getValue(currentIndex);\n+            put(dataKey, value);\n+            currentIndex++;\n+        }\n+    }\n+\n+    protected void put(Data dataKey, Data dataValue) {", "originalCommit": "22d4bca64919908655498a18f8ac25e227ed4cbe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bef680b72c90e574c2c9e125159b513e8a658bd9", "url": "https://github.com/hazelcast/hazelcast/commit/bef680b72c90e574c2c9e125159b513e8a658bd9", "message": "Reduce sleep time in ClientMultiMapTests (#9079)", "committedDate": "2020-04-13T11:50:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQ5NzUzOA==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r407497538", "body": "I could not find a usage of this future with a null value. \r\n\r\n@vbekiaris Are we planning to implement sync versions of these methods ? \r\nIf there is no plan, can we make this `@nonnull` , and remove the null checks inside the method? Same goes for the MultiMapProxyImpl as well. ", "bodyText": "I could not find a usage of this future with a null value.\n@vbekiaris Are we planning to implement sync versions of these methods ?\nIf there is no plan, can we make this @nonnull , and remove the null checks inside the method? Same goes for the MultiMapProxyImpl as well.", "bodyHTML": "<p dir=\"auto\">I could not find a usage of this future with a null value.</p>\n<p dir=\"auto\"><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/vbekiaris/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/vbekiaris\">@vbekiaris</a> Are we planning to implement sync versions of these methods ?<br>\nIf there is no plan, can we make this <code>@nonnull</code> , and remove the null checks inside the method? Same goes for the MultiMapProxyImpl as well.</p>", "author": "sancar", "createdAt": "2020-04-13T14:10:35Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientMultiMapProxy.java", "diffHunk": "@@ -91,6 +105,98 @@ public ClientMultiMapProxy(String serviceName, String name, ClientContext contex\n         super(serviceName, name, context);\n     }\n \n+    @Override\n+    public CompletionStage<Void> putAllAsync(@Nonnull Map<? extends K, Collection<? extends V>> m) {\n+        InternalCompletableFuture<Void> future = new InternalCompletableFuture<>();\n+        Map<Data, Data> dataMap = new HashMap<>();\n+\n+        for (Map.Entry e : m.entrySet()) {\n+            Collection<Data> dataCollection = CollectionUtil\n+                    .objectToDataCollection(((Collection<? extends V>) e.getValue()),\n+                            getSerializationService());\n+\n+            dataMap.put(toData(e.getKey()), toData(new DataCollection(dataCollection)));\n+        }\n+        putAllInternal(dataMap, future);\n+        return future;\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> putAllAsync(@Nonnull K key, Collection<? extends V> value) {\n+        InternalCompletableFuture<Void> future = new InternalCompletableFuture<>();\n+        Map<Data, Data> dataMap = new HashMap<>();\n+\n+        Collection<Data> dataCollection = CollectionUtil\n+                .objectToDataCollection(value, getSerializationService());\n+        dataMap.put(toData(key), toData(new DataCollection(dataCollection)));\n+        putAllInternal(dataMap, future);\n+        return future;\n+    }\n+\n+\n+    @SuppressWarnings({\"checkstyle:cyclomaticcomplexity\", \"checkstyle:npathcomplexity\", \"checkstyle:methodlength\"})\n+    private void putAllInternal(@Nonnull Map<Data, Data> map,\n+                                @Nullable InternalCompletableFuture<Void> future) {", "originalCommit": "0e306d8be0f2b1df2b5e1090802257629920ce1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkwMTg1Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r407901856", "bodyText": "Quoting from #9079 (comment) :\n\n... So, instead of getAll and putAll, you can add getAllAsync and putAllAsync.\n\nThere is no concrete plan for implementing the synchronous version of these methods, unless there is interest / a PR from the community. So I would agree to have the future == null paths removed from this PR.", "author": "vbekiaris", "createdAt": "2020-04-14T06:45:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQ5NzUzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUyNjA3Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r407526076", "body": "A collection of objects should not be converted to Data. For details see my comment on protocol pr.\r\nhttps://github.com/hazelcast/hazelcast-client-protocol/pull/313#issuecomment-612937041\r\n\r\nNote that this is the case for Client only. For the member side, I believe it is ok the use DataCollection. \r\nFor the client, we have a protocol and it needs to be self descriptive. Details are on the protocol pr comment", "bodyText": "A collection of objects should not be converted to Data. For details see my comment on protocol pr.\nhazelcast/hazelcast-client-protocol#313 (comment)\nNote that this is the case for Client only. For the member side, I believe it is ok the use DataCollection.\nFor the client, we have a protocol and it needs to be self descriptive. Details are on the protocol pr comment", "bodyHTML": "<p dir=\"auto\">A collection of objects should not be converted to Data. For details see my comment on protocol pr.<br>\n<a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"585839138\" data-permission-text=\"Title is private\" data-url=\"https://github.com/hazelcast/hazelcast-client-protocol/issues/313\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/hazelcast/hazelcast-client-protocol/pull/313/hovercard?comment_id=612937041&amp;comment_type=issue_comment\" href=\"https://github.com/hazelcast/hazelcast-client-protocol/pull/313#issuecomment-612937041\">hazelcast/hazelcast-client-protocol#313 (comment)</a></p>\n<p dir=\"auto\">Note that this is the case for Client only. For the member side, I believe it is ok the use DataCollection.<br>\nFor the client, we have a protocol and it needs to be self descriptive. Details are on the protocol pr comment</p>", "author": "sancar", "createdAt": "2020-04-13T15:05:16Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientMultiMapProxy.java", "diffHunk": "@@ -91,6 +105,98 @@ public ClientMultiMapProxy(String serviceName, String name, ClientContext contex\n         super(serviceName, name, context);\n     }\n \n+    @Override\n+    public CompletionStage<Void> putAllAsync(@Nonnull Map<? extends K, Collection<? extends V>> m) {\n+        InternalCompletableFuture<Void> future = new InternalCompletableFuture<>();\n+        Map<Data, Data> dataMap = new HashMap<>();\n+\n+        for (Map.Entry e : m.entrySet()) {\n+            Collection<Data> dataCollection = CollectionUtil\n+                    .objectToDataCollection(((Collection<? extends V>) e.getValue()),\n+                            getSerializationService());\n+\n+            dataMap.put(toData(e.getKey()), toData(new DataCollection(dataCollection)));\n+        }\n+        putAllInternal(dataMap, future);\n+        return future;\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> putAllAsync(@Nonnull K key, Collection<? extends V> value) {\n+        InternalCompletableFuture<Void> future = new InternalCompletableFuture<>();\n+        Map<Data, Data> dataMap = new HashMap<>();\n+\n+        Collection<Data> dataCollection = CollectionUtil\n+                .objectToDataCollection(value, getSerializationService());\n+        dataMap.put(toData(key), toData(new DataCollection(dataCollection)));", "originalCommit": "0e306d8be0f2b1df2b5e1090802257629920ce1a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a7bf45a34a69a1f5c824f2f16ebb8ee5289cf5c7", "url": "https://github.com/hazelcast/hazelcast/commit/a7bf45a34a69a1f5c824f2f16ebb8ee5289cf5c7", "message": "Change ClientMultiMap PutAll entries param from Map<Data, Data> to Map<Data, Collection<Data>> (#9079)\nUpdate generated codecs and tests.", "committedDate": "2020-04-17T12:21:21Z", "type": "forcePushed"}, {"oid": "e6d09aae355ed6c67efd01b94c5d80d07cca42b7", "url": "https://github.com/hazelcast/hazelcast/commit/e6d09aae355ed6c67efd01b94c5d80d07cca42b7", "message": "Make ClientMultiMapProxy.putAllInternal future @Nonnull and remove check (#9079)", "committedDate": "2020-04-17T12:44:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMzMDM2Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r411330363", "body": "What is this configuration is used for ? Can you remove if it is redundant ?", "bodyText": "What is this configuration is used for ? Can you remove if it is redundant ?", "bodyHTML": "<p dir=\"auto\">What is this configuration is used for ? Can you remove if it is redundant ?</p>", "author": "sancar", "createdAt": "2020-04-20T12:18:07Z", "path": "hazelcast/src/test/java/com/hazelcast/client/multimap/ClientMultiMapTest.java", "diffHunk": "@@ -65,6 +78,137 @@ public void testPut() {\n         assertTrue(mm.put(key, 1));\n     }\n \n+    protected <K, V> EntryListener<K, V> putAllEntryListenerBuilder(Consumer<EntryEvent<K, V>> f) {\n+        return new EntryAdapter<K, V>() {\n+            public void entryAdded(EntryEvent<K, V> event) {\n+                f.accept(event);\n+            }\n+\n+            public void entryRemoved(EntryEvent<K, V> event) {\n+            }\n+\n+            public void entryEvicted(EntryEvent<K, V> event) {\n+                entryRemoved(event);\n+            }\n+\n+            @Override\n+            public void mapEvicted(MapEvent event) {\n+            }\n+\n+            @Override\n+            public void mapCleared(MapEvent event) {\n+            }\n+        };\n+    }\n+\n+    protected void testMultiMapPutAllSetup() {\n+        MultiMapConfig multiMapConfig1 = new MultiMapConfig()\n+                .setName(\"testMultiMapList\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.LIST)\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig2 = new MultiMapConfig()\n+                .setName(\"testMultiMapSet\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.SET)\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig3 = new MultiMapConfig()\n+                .setName(\"expectedMultiMap1\")", "originalCommit": "dd153bc2dd11f13d4f9835ba5eb31efa332d4884", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM0MTE5MA==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r411341190", "body": "This access is not thread safe. You should use ConcurrentHashMap .", "bodyText": "This access is not thread safe. You should use ConcurrentHashMap .", "bodyHTML": "<p dir=\"auto\">This access is not thread safe. You should use ConcurrentHashMap .</p>", "author": "sancar", "createdAt": "2020-04-20T12:35:49Z", "path": "hazelcast/src/test/java/com/hazelcast/client/multimap/ClientMultiMapTest.java", "diffHunk": "@@ -65,6 +78,137 @@ public void testPut() {\n         assertTrue(mm.put(key, 1));\n     }\n \n+    protected <K, V> EntryListener<K, V> putAllEntryListenerBuilder(Consumer<EntryEvent<K, V>> f) {\n+        return new EntryAdapter<K, V>() {\n+            public void entryAdded(EntryEvent<K, V> event) {\n+                f.accept(event);\n+            }\n+\n+            public void entryRemoved(EntryEvent<K, V> event) {\n+            }\n+\n+            public void entryEvicted(EntryEvent<K, V> event) {\n+                entryRemoved(event);\n+            }\n+\n+            @Override\n+            public void mapEvicted(MapEvent event) {\n+            }\n+\n+            @Override\n+            public void mapCleared(MapEvent event) {\n+            }\n+        };\n+    }\n+\n+    protected void testMultiMapPutAllSetup() {\n+        MultiMapConfig multiMapConfig1 = new MultiMapConfig()\n+                .setName(\"testMultiMapList\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.LIST)\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig2 = new MultiMapConfig()\n+                .setName(\"testMultiMapSet\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.SET)\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig3 = new MultiMapConfig()\n+                .setName(\"expectedMultiMap1\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.LIST)\n+                .setBinary(false);\n+        client.getConfig()\n+                .addMultiMapConfig(multiMapConfig1)\n+                .addMultiMapConfig(multiMapConfig2)\n+                .addMultiMapConfig(multiMapConfig3);\n+    }\n+\n+    public void testMultiMapPutAllTemplate(Map<String, Collection<? extends Integer>> expectedMultiMap,\n+                                           Consumer<MultiMap<String, Integer>> putAllOperation1) throws InterruptedException {\n+        MultiMap<String, Integer> mmap1 = client.getMultiMap(\"testMultiMapList\");\n+        MultiMap<String, Integer> mmap2 = client.getMultiMap(\"testMultiMapSet\");\n+        Map<String, Collection<Integer>> resultMap1 = new HashMap<>();\n+        Map<String, Collection<Integer>> resultMap2 = new HashMap<>();\n+\n+        int totalItems = 0;\n+        Set<String> ks = expectedMultiMap.keySet();\n+        for (String s : ks) {\n+            Collection expectedCollection = expectedMultiMap.get(s);\n+            totalItems += expectedCollection.size()\n+                    + ((Long) expectedCollection.stream().distinct().count()).intValue();\n+        }\n+\n+        final CountDownLatch latchAdded = new CountDownLatch(totalItems);\n+        mmap1.addEntryListener(putAllEntryListenerBuilder((event) -> {\n+                    String key = (String) event.getKey();\n+                    Integer value = (Integer) event.getValue();\n+                    Collection<Integer> c;\n+                    if (!resultMap1.containsKey(key)) {", "originalCommit": "dd153bc2dd11f13d4f9835ba5eb31efa332d4884", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM0MjMxNw==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r411342317", "body": "Some naming suggestions to make the code a little bit more easy to understand \r\nPlease remove the numbers from the names where it is not necessary . (When there is a number, I automatically search for the second one. )\r\nlike `putAllOperation1` -> `putAllOperation` \r\n`expectedMultiMap1` -> `expectedMultiMap` ", "bodyText": "Some naming suggestions to make the code a little bit more easy to understand\nPlease remove the numbers from the names where it is not necessary . (When there is a number, I automatically search for the second one. )\nlike putAllOperation1 -> putAllOperation\nexpectedMultiMap1 -> expectedMultiMap", "bodyHTML": "<p dir=\"auto\">Some naming suggestions to make the code a little bit more easy to understand<br>\nPlease remove the numbers from the names where it is not necessary . (When there is a number, I automatically search for the second one. )<br>\nlike <code>putAllOperation1</code> -&gt; <code>putAllOperation</code><br>\n<code>expectedMultiMap1</code> -&gt; <code>expectedMultiMap</code></p>", "author": "sancar", "createdAt": "2020-04-20T12:37:48Z", "path": "hazelcast/src/test/java/com/hazelcast/client/multimap/ClientMultiMapTest.java", "diffHunk": "@@ -65,6 +78,137 @@ public void testPut() {\n         assertTrue(mm.put(key, 1));\n     }\n \n+    protected <K, V> EntryListener<K, V> putAllEntryListenerBuilder(Consumer<EntryEvent<K, V>> f) {\n+        return new EntryAdapter<K, V>() {\n+            public void entryAdded(EntryEvent<K, V> event) {\n+                f.accept(event);\n+            }\n+\n+            public void entryRemoved(EntryEvent<K, V> event) {\n+            }\n+\n+            public void entryEvicted(EntryEvent<K, V> event) {\n+                entryRemoved(event);\n+            }\n+\n+            @Override\n+            public void mapEvicted(MapEvent event) {\n+            }\n+\n+            @Override\n+            public void mapCleared(MapEvent event) {\n+            }\n+        };\n+    }\n+\n+    protected void testMultiMapPutAllSetup() {\n+        MultiMapConfig multiMapConfig1 = new MultiMapConfig()\n+                .setName(\"testMultiMapList\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.LIST)\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig2 = new MultiMapConfig()\n+                .setName(\"testMultiMapSet\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.SET)\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig3 = new MultiMapConfig()\n+                .setName(\"expectedMultiMap1\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.LIST)\n+                .setBinary(false);\n+        client.getConfig()\n+                .addMultiMapConfig(multiMapConfig1)\n+                .addMultiMapConfig(multiMapConfig2)\n+                .addMultiMapConfig(multiMapConfig3);\n+    }\n+\n+    public void testMultiMapPutAllTemplate(Map<String, Collection<? extends Integer>> expectedMultiMap,\n+                                           Consumer<MultiMap<String, Integer>> putAllOperation1) throws InterruptedException {", "originalCommit": "dd153bc2dd11f13d4f9835ba5eb31efa332d4884", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM0MzE5MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r411343191", "body": "Please use the standard one as follows:\r\n```suggestion\r\n        assertOpenEventually(latchAdded);\r\n```\r\n", "bodyText": "Please use the standard one as follows:\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    latchAdded.await(5, TimeUnit.MINUTES);\n          \n          \n            \n                    assertOpenEventually(latchAdded);", "bodyHTML": "<p dir=\"auto\">Please use the standard one as follows:</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"x x-first\">latchAdded</span><span class=\"pl-k x\">.</span><span class=\"x\">await(</span><span class=\"pl-c1 x\">5</span><span class=\"x\">, </span><span class=\"pl-smi x\">TimeUnit</span><span class=\"pl-c1\"><span class=\"pl-k x\">.</span><span class=\"x x-last\">MINUTES</span></span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"x x-first x-last\">assertOpenEventually(latchAdded</span>);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "sancar", "createdAt": "2020-04-20T12:39:09Z", "path": "hazelcast/src/test/java/com/hazelcast/client/multimap/ClientMultiMapTest.java", "diffHunk": "@@ -65,6 +78,137 @@ public void testPut() {\n         assertTrue(mm.put(key, 1));\n     }\n \n+    protected <K, V> EntryListener<K, V> putAllEntryListenerBuilder(Consumer<EntryEvent<K, V>> f) {\n+        return new EntryAdapter<K, V>() {\n+            public void entryAdded(EntryEvent<K, V> event) {\n+                f.accept(event);\n+            }\n+\n+            public void entryRemoved(EntryEvent<K, V> event) {\n+            }\n+\n+            public void entryEvicted(EntryEvent<K, V> event) {\n+                entryRemoved(event);\n+            }\n+\n+            @Override\n+            public void mapEvicted(MapEvent event) {\n+            }\n+\n+            @Override\n+            public void mapCleared(MapEvent event) {\n+            }\n+        };\n+    }\n+\n+    protected void testMultiMapPutAllSetup() {\n+        MultiMapConfig multiMapConfig1 = new MultiMapConfig()\n+                .setName(\"testMultiMapList\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.LIST)\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig2 = new MultiMapConfig()\n+                .setName(\"testMultiMapSet\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.SET)\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig3 = new MultiMapConfig()\n+                .setName(\"expectedMultiMap1\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.LIST)\n+                .setBinary(false);\n+        client.getConfig()\n+                .addMultiMapConfig(multiMapConfig1)\n+                .addMultiMapConfig(multiMapConfig2)\n+                .addMultiMapConfig(multiMapConfig3);\n+    }\n+\n+    public void testMultiMapPutAllTemplate(Map<String, Collection<? extends Integer>> expectedMultiMap,\n+                                           Consumer<MultiMap<String, Integer>> putAllOperation1) throws InterruptedException {\n+        MultiMap<String, Integer> mmap1 = client.getMultiMap(\"testMultiMapList\");\n+        MultiMap<String, Integer> mmap2 = client.getMultiMap(\"testMultiMapSet\");\n+        Map<String, Collection<Integer>> resultMap1 = new HashMap<>();\n+        Map<String, Collection<Integer>> resultMap2 = new HashMap<>();\n+\n+        int totalItems = 0;\n+        Set<String> ks = expectedMultiMap.keySet();\n+        for (String s : ks) {\n+            Collection expectedCollection = expectedMultiMap.get(s);\n+            totalItems += expectedCollection.size()\n+                    + ((Long) expectedCollection.stream().distinct().count()).intValue();\n+        }\n+\n+        final CountDownLatch latchAdded = new CountDownLatch(totalItems);\n+        mmap1.addEntryListener(putAllEntryListenerBuilder((event) -> {\n+                    String key = (String) event.getKey();\n+                    Integer value = (Integer) event.getValue();\n+                    Collection<Integer> c;\n+                    if (!resultMap1.containsKey(key)) {\n+                        c = new ArrayList<>();\n+                    } else {\n+                        c = resultMap1.get(key);\n+                    }\n+                    c.add(value);\n+                    resultMap1.put(key, c);\n+                    latchAdded.countDown();\n+                }\n+        ), true);\n+        mmap2.addEntryListener(putAllEntryListenerBuilder((event) -> {\n+                    String key = (String) event.getKey();\n+                    Integer value = (Integer) event.getValue();\n+                    Collection<Integer> c;\n+                    if (!resultMap2.containsKey(key)) {\n+                        c = new ArrayList<>();\n+                    } else {\n+                        c = resultMap2.get(key);\n+                    }\n+                    c.add(value);\n+                    resultMap2.put(key, c);\n+                    latchAdded.countDown();\n+                }\n+        ), true);\n+\n+        putAllOperation1.accept(mmap1);\n+        putAllOperation1.accept(mmap2);\n+        latchAdded.await(5, TimeUnit.MINUTES);", "originalCommit": "dd153bc2dd11f13d4f9835ba5eb31efa332d4884", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM0MzY0Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r411343643", "body": "A test should not rely on sleep. I believe this should not be necessary. ", "bodyText": "A test should not rely on sleep. I believe this should not be necessary.", "bodyHTML": "<p dir=\"auto\">A test should not rely on sleep. I believe this should not be necessary.</p>", "author": "sancar", "createdAt": "2020-04-20T12:39:50Z", "path": "hazelcast/src/test/java/com/hazelcast/client/multimap/ClientMultiMapTest.java", "diffHunk": "@@ -65,6 +78,137 @@ public void testPut() {\n         assertTrue(mm.put(key, 1));\n     }\n \n+    protected <K, V> EntryListener<K, V> putAllEntryListenerBuilder(Consumer<EntryEvent<K, V>> f) {\n+        return new EntryAdapter<K, V>() {\n+            public void entryAdded(EntryEvent<K, V> event) {\n+                f.accept(event);\n+            }\n+\n+            public void entryRemoved(EntryEvent<K, V> event) {\n+            }\n+\n+            public void entryEvicted(EntryEvent<K, V> event) {\n+                entryRemoved(event);\n+            }\n+\n+            @Override\n+            public void mapEvicted(MapEvent event) {\n+            }\n+\n+            @Override\n+            public void mapCleared(MapEvent event) {\n+            }\n+        };\n+    }\n+\n+    protected void testMultiMapPutAllSetup() {\n+        MultiMapConfig multiMapConfig1 = new MultiMapConfig()\n+                .setName(\"testMultiMapList\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.LIST)\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig2 = new MultiMapConfig()\n+                .setName(\"testMultiMapSet\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.SET)\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig3 = new MultiMapConfig()\n+                .setName(\"expectedMultiMap1\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.LIST)\n+                .setBinary(false);\n+        client.getConfig()\n+                .addMultiMapConfig(multiMapConfig1)\n+                .addMultiMapConfig(multiMapConfig2)\n+                .addMultiMapConfig(multiMapConfig3);\n+    }\n+\n+    public void testMultiMapPutAllTemplate(Map<String, Collection<? extends Integer>> expectedMultiMap,\n+                                           Consumer<MultiMap<String, Integer>> putAllOperation1) throws InterruptedException {\n+        MultiMap<String, Integer> mmap1 = client.getMultiMap(\"testMultiMapList\");\n+        MultiMap<String, Integer> mmap2 = client.getMultiMap(\"testMultiMapSet\");\n+        Map<String, Collection<Integer>> resultMap1 = new HashMap<>();\n+        Map<String, Collection<Integer>> resultMap2 = new HashMap<>();\n+\n+        int totalItems = 0;\n+        Set<String> ks = expectedMultiMap.keySet();\n+        for (String s : ks) {\n+            Collection expectedCollection = expectedMultiMap.get(s);\n+            totalItems += expectedCollection.size()\n+                    + ((Long) expectedCollection.stream().distinct().count()).intValue();\n+        }\n+\n+        final CountDownLatch latchAdded = new CountDownLatch(totalItems);\n+        mmap1.addEntryListener(putAllEntryListenerBuilder((event) -> {\n+                    String key = (String) event.getKey();\n+                    Integer value = (Integer) event.getValue();\n+                    Collection<Integer> c;\n+                    if (!resultMap1.containsKey(key)) {\n+                        c = new ArrayList<>();\n+                    } else {\n+                        c = resultMap1.get(key);\n+                    }\n+                    c.add(value);\n+                    resultMap1.put(key, c);\n+                    latchAdded.countDown();\n+                }\n+        ), true);\n+        mmap2.addEntryListener(putAllEntryListenerBuilder((event) -> {\n+                    String key = (String) event.getKey();\n+                    Integer value = (Integer) event.getValue();\n+                    Collection<Integer> c;\n+                    if (!resultMap2.containsKey(key)) {\n+                        c = new ArrayList<>();\n+                    } else {\n+                        c = resultMap2.get(key);\n+                    }\n+                    c.add(value);\n+                    resultMap2.put(key, c);\n+                    latchAdded.countDown();\n+                }\n+        ), true);\n+\n+        putAllOperation1.accept(mmap1);\n+        putAllOperation1.accept(mmap2);\n+        latchAdded.await(5, TimeUnit.MINUTES);\n+        sleepMillis(500);", "originalCommit": "dd153bc2dd11f13d4f9835ba5eb31efa332d4884", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM0NDUyMA==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r411344520", "body": "Is this also unused ? ", "bodyText": "Is this also unused ?", "bodyHTML": "<p dir=\"auto\">Is this also unused ?</p>", "author": "sancar", "createdAt": "2020-04-20T12:41:05Z", "path": "hazelcast/src/test/java/com/hazelcast/multimap/MultiMapTest.java", "diffHunk": "@@ -104,6 +114,147 @@ public void testMultiMapPutGetRemove() {\n         assertEquals(0, multiMap.size());\n     }\n \n+    protected <K, V> EntryListener<K, V> putAllEntryListenerBuilder(Consumer<EntryEvent<K, V>> f) {\n+        return new EntryAdapter<K, V>() {\n+            public void entryAdded(EntryEvent<K, V> event) {\n+                f.accept(event);\n+            }\n+\n+            public void entryRemoved(EntryEvent<K, V> event) {\n+            }\n+\n+            public void entryEvicted(EntryEvent<K, V> event) {\n+                entryRemoved(event);\n+            }\n+\n+            @Override\n+            public void mapEvicted(MapEvent event) {\n+            }\n+\n+            @Override\n+            public void mapCleared(MapEvent event) {\n+            }\n+        };\n+    }\n+\n+    protected HazelcastInstance testMultiMapPutAllSetup() {\n+        MultiMapConfig multiMapConfig1 = new MultiMapConfig()\n+                .setName(\"testMultiMapPutAllMapList\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.LIST)\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig2 = new MultiMapConfig()\n+                .setName(\"testMultiMapPutAllMapSet\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.SET)\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig3 = new MultiMapConfig()", "originalCommit": "dd153bc2dd11f13d4f9835ba5eb31efa332d4884", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "83119aa4e73b0830a79c51992e7373d195046fb2", "url": "https://github.com/hazelcast/hazelcast/commit/83119aa4e73b0830a79c51992e7373d195046fb2", "message": "New MultiMap bulk put feature request (#9079)\nAdd two new interfaces for MultiMap.putAllAsync and implement for MultiMapProxyImpl and ClientMultiMapProxy.\nAdd new operation classes, MultiMapPutAllOperationFactory, PutAllOperation and PutAllBackupOperation.\nAdd corresponding tests for bulk put, statistics and backup.\n\nAdd new client protocol codecs MultiMapPutAllCodec and ListDataCodec and new message handler MultiMapPutAllMessageTask. Update generated client protocol tests and resources.\nAdd new Preconditions.checkTrueUnsupportedOperation.", "committedDate": "2020-04-21T15:50:43Z", "type": "commit"}, {"oid": "83119aa4e73b0830a79c51992e7373d195046fb2", "url": "https://github.com/hazelcast/hazelcast/commit/83119aa4e73b0830a79c51992e7373d195046fb2", "message": "New MultiMap bulk put feature request (#9079)\nAdd two new interfaces for MultiMap.putAllAsync and implement for MultiMapProxyImpl and ClientMultiMapProxy.\nAdd new operation classes, MultiMapPutAllOperationFactory, PutAllOperation and PutAllBackupOperation.\nAdd corresponding tests for bulk put, statistics and backup.\n\nAdd new client protocol codecs MultiMapPutAllCodec and ListDataCodec and new message handler MultiMapPutAllMessageTask. Update generated client protocol tests and resources.\nAdd new Preconditions.checkTrueUnsupportedOperation.", "committedDate": "2020-04-21T15:50:43Z", "type": "forcePushed"}]}