{"pr_number": 17084, "pr_title": "Fix fragmented message handling", "pr_author": "mdumandag", "pr_createdAt": "2020-06-15T12:53:54Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17084", "timeline": [{"oid": "8d15d42b9c9727e76327d43d977bc184abec02e3", "url": "https://github.com/hazelcast/hazelcast/commit/8d15d42b9c9727e76327d43d977bc184abec02e3", "message": "Fix fragmented message handling\n\nBy definition, fragmented messages may have arbitrary number of frames.\nHowever, ClientMessageDecoder was using ClientMessage#createForDecode\nwhich expects a single frame that has no next frame. As the added test\nshows, that assumption generally does not hold. Start frame of the\nfragmented message may have next frames. The fix correctly creates\na client message using the start and end frames of the fragmented\nmessage.", "committedDate": "2020-06-15T12:44:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1MTM5Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17084#discussion_r440651397", "body": "Good finding. I think we can make further cleanups. Instead of creating a new message, we put the message directly to `builderBySessionIdMap` . We just need to `dropFragmentationFrame` . \r\n\r\n```\r\n                   ClientMessage message = activeReader.getClientMessage();\r\n                    message.dropFragmentationFrame();\r\n                    long fragmentationId = Bits.readLongL(firstFrame.content, FRAGMENTATION_ID_OFFSET);\r\n                    if (ClientMessage.isFlagSet(flags, BEGIN_FRAGMENT_FLAG)) {\r\n                        builderBySessionIdMap.put(fragmentationId, message);\r\n```\r\nWe have a new method on ClientMessage:\r\n\r\n```\r\n  public void dropFragmentationFrame() {\r\n        startFrame = startFrame.next;\r\n    }\r\n```\r\n\r\nand merge method should change accordingly. Dropping the fragmentation logic was there, and feeling wrong to begin with. \r\n\r\n```\r\n public void merge(ClientMessage fragment) {\r\n        endFrame.next = fragment.startFrame;\r\n        endFrame = fragment.endFrame;\r\n    }\r\n```\r\n\r\n@mdumandag How does that look ? ", "bodyText": "Good finding. I think we can make further cleanups. Instead of creating a new message, we put the message directly to builderBySessionIdMap . We just need to dropFragmentationFrame .\n                   ClientMessage message = activeReader.getClientMessage();\n                    message.dropFragmentationFrame();\n                    long fragmentationId = Bits.readLongL(firstFrame.content, FRAGMENTATION_ID_OFFSET);\n                    if (ClientMessage.isFlagSet(flags, BEGIN_FRAGMENT_FLAG)) {\n                        builderBySessionIdMap.put(fragmentationId, message);\n\nWe have a new method on ClientMessage:\n  public void dropFragmentationFrame() {\n        startFrame = startFrame.next;\n    }\n\nand merge method should change accordingly. Dropping the fragmentation logic was there, and feeling wrong to begin with.\n public void merge(ClientMessage fragment) {\n        endFrame.next = fragment.startFrame;\n        endFrame = fragment.endFrame;\n    }\n\n@mdumandag How does that look ?", "bodyHTML": "<p dir=\"auto\">Good finding. I think we can make further cleanups. Instead of creating a new message, we put the message directly to <code>builderBySessionIdMap</code> . We just need to <code>dropFragmentationFrame</code> .</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"                   ClientMessage message = activeReader.getClientMessage();\n                    message.dropFragmentationFrame();\n                    long fragmentationId = Bits.readLongL(firstFrame.content, FRAGMENTATION_ID_OFFSET);\n                    if (ClientMessage.isFlagSet(flags, BEGIN_FRAGMENT_FLAG)) {\n                        builderBySessionIdMap.put(fragmentationId, message);\"><pre><code>                   ClientMessage message = activeReader.getClientMessage();\n                    message.dropFragmentationFrame();\n                    long fragmentationId = Bits.readLongL(firstFrame.content, FRAGMENTATION_ID_OFFSET);\n                    if (ClientMessage.isFlagSet(flags, BEGIN_FRAGMENT_FLAG)) {\n                        builderBySessionIdMap.put(fragmentationId, message);\n</code></pre></div>\n<p dir=\"auto\">We have a new method on ClientMessage:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"  public void dropFragmentationFrame() {\n        startFrame = startFrame.next;\n    }\"><pre><code>  public void dropFragmentationFrame() {\n        startFrame = startFrame.next;\n    }\n</code></pre></div>\n<p dir=\"auto\">and merge method should change accordingly. Dropping the fragmentation logic was there, and feeling wrong to begin with.</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\" public void merge(ClientMessage fragment) {\n        endFrame.next = fragment.startFrame;\n        endFrame = fragment.endFrame;\n    }\"><pre><code> public void merge(ClientMessage fragment) {\n        endFrame.next = fragment.startFrame;\n        endFrame = fragment.endFrame;\n    }\n</code></pre></div>\n<p dir=\"auto\"><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/mdumandag/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/mdumandag\">@mdumandag</a> How does that look ?</p>", "author": "sancar", "createdAt": "2020-06-16T07:46:15Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/util/ClientMessageDecoder.java", "diffHunk": "@@ -90,13 +90,14 @@ public HandlerStatus onRead() {\n                     throw new IllegalStateException(\n                             \"Fragmented client messages are not allowed before the client is authenticated.\");\n                 } else {\n-                    ClientMessage.ForwardFrameIterator frameIterator = activeReader.getClientMessage().frameIterator();\n+                    ClientMessage message = activeReader.getClientMessage();\n+                    ClientMessage.ForwardFrameIterator frameIterator = message.frameIterator();\n                     //ignore the fragmentationFrame\n                     frameIterator.next();\n                     ClientMessage.Frame startFrame = frameIterator.next();\n                     long fragmentationId = Bits.readLongL(firstFrame.content, FRAGMENTATION_ID_OFFSET);\n                     if (ClientMessage.isFlagSet(flags, BEGIN_FRAGMENT_FLAG)) {\n-                        builderBySessionIdMap.put(fragmentationId, ClientMessage.createForDecode(startFrame));\n+                        builderBySessionIdMap.put(fragmentationId, new ClientMessage(startFrame, message.getEndFrame()));", "originalCommit": "8d15d42b9c9727e76327d43d977bc184abec02e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDgzMzk5Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17084#discussion_r440833992", "bodyText": "Thanks for the suggestion. That version looks better.", "author": "mdumandag", "createdAt": "2020-06-16T13:06:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1MTM5Nw=="}], "type": "inlineReview"}, {"oid": "8f006ae421022068180639b80489d19bc13c771d", "url": "https://github.com/hazelcast/hazelcast/commit/8f006ae421022068180639b80489d19bc13c771d", "message": "do not create an extra message while putting it into", "committedDate": "2020-06-16T13:06:09Z", "type": "commit"}]}