{"pr_number": 17671, "pr_title": "Fix race in NodeId innitialization in FlakeId proxy", "pr_author": "jerrinot", "pr_createdAt": "2020-10-02T14:15:04Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17671", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg1NDk1Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17671#discussion_r498854956", "body": "enforcing the contract as described in JavaDoc", "bodyText": "enforcing the contract as described in JavaDoc", "bodyHTML": "<p dir=\"auto\">enforcing the contract as described in JavaDoc</p>", "author": "jerrinot", "createdAt": "2020-10-02T14:25:34Z", "path": "hazelcast/src/main/java/com/hazelcast/flakeidgen/impl/FlakeIdGeneratorProxy.java", "diffHunk": "@@ -199,7 +199,9 @@ IdBatchAndWaitTime newIdBaseLocal(long now, int nodeId, int batchSize) {\n      * </ul>\n      */\n     private int getNodeId() {\n-        return getNodeId(System.nanoTime());\n+        int nodeId = getNodeId(System.nanoTime());\n+        assert nodeId > 0 || nodeId == NODE_ID_OUT_OF_RANGE : \"getNodeId() returned invalid value\";", "originalCommit": "17dee7c8bbbf26274a3df62f0fce0ae917ece86e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU1MzMzNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17671#discussion_r499553336", "body": "Your code is OK, so I'm approving. This also works, I find it easier. If you like it you can replace it:\r\n```java\r\n        long nextNodeIdUpdate = this.nextNodeIdUpdate;\r\n        int nodeId = this.nodeId;\r\n        if (nextNodeIdUpdate <= nanoTime) {\r\n            if (nodeId == NODE_ID_OUT_OF_RANGE) {\r\n                return nodeId;\r\n            }\r\n            int newNodeId = getNodeEngine().getClusterService().getMemberListJoinVersion();\r\n            assert newNodeId >= 0 : \"newNodeId=\" + newNodeId;\r\n            newNodeId += nodeIdOffset;\r\n            if (newNodeId != nodeId) {\r\n                nodeId = newNodeId;\r\n\r\n                // If our node ID is out of range, assign NODE_ID_OUT_OF_RANGE to nodeId\r\n                if ((nodeId & -1 << bitsNodeId) != 0) {\r\n                    outOfRangeMembers.add(getNodeEngine().getClusterService().getLocalMember().getUuid());\r\n                    logger.severe(\"Node ID is out of range (\" + nodeId + \"), this member won't be able to generate IDs. \"\r\n                            + \"Cluster restart is recommended.\");\r\n                    nodeId = NODE_ID_OUT_OF_RANGE;\r\n                }\r\n\r\n                // we ignore possible double initialization\r\n                this.nodeId = nodeId;\r\n                this.nextNodeIdUpdate = nanoTime + NODE_ID_UPDATE_INTERVAL_NS;\r\n                if (logger.isFineEnabled()) {\r\n                    logger.fine(\"Node ID assigned to '\" + name + \"': \" + nodeId);\r\n                }\r\n            }\r\n        }\r\n```\r\nIt ensures that it's impossible to see no need to update before `nodeId` was assigned to some valid value.", "bodyText": "Your code is OK, so I'm approving. This also works, I find it easier. If you like it you can replace it:\n        long nextNodeIdUpdate = this.nextNodeIdUpdate;\n        int nodeId = this.nodeId;\n        if (nextNodeIdUpdate <= nanoTime) {\n            if (nodeId == NODE_ID_OUT_OF_RANGE) {\n                return nodeId;\n            }\n            int newNodeId = getNodeEngine().getClusterService().getMemberListJoinVersion();\n            assert newNodeId >= 0 : \"newNodeId=\" + newNodeId;\n            newNodeId += nodeIdOffset;\n            if (newNodeId != nodeId) {\n                nodeId = newNodeId;\n\n                // If our node ID is out of range, assign NODE_ID_OUT_OF_RANGE to nodeId\n                if ((nodeId & -1 << bitsNodeId) != 0) {\n                    outOfRangeMembers.add(getNodeEngine().getClusterService().getLocalMember().getUuid());\n                    logger.severe(\"Node ID is out of range (\" + nodeId + \"), this member won't be able to generate IDs. \"\n                            + \"Cluster restart is recommended.\");\n                    nodeId = NODE_ID_OUT_OF_RANGE;\n                }\n\n                // we ignore possible double initialization\n                this.nodeId = nodeId;\n                this.nextNodeIdUpdate = nanoTime + NODE_ID_UPDATE_INTERVAL_NS;\n                if (logger.isFineEnabled()) {\n                    logger.fine(\"Node ID assigned to '\" + name + \"': \" + nodeId);\n                }\n            }\n        }\nIt ensures that it's impossible to see no need to update before nodeId was assigned to some valid value.", "bodyHTML": "<p dir=\"auto\">Your code is OK, so I'm approving. This also works, I find it easier. If you like it you can replace it:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"        long nextNodeIdUpdate = this.nextNodeIdUpdate;\n        int nodeId = this.nodeId;\n        if (nextNodeIdUpdate &lt;= nanoTime) {\n            if (nodeId == NODE_ID_OUT_OF_RANGE) {\n                return nodeId;\n            }\n            int newNodeId = getNodeEngine().getClusterService().getMemberListJoinVersion();\n            assert newNodeId &gt;= 0 : &quot;newNodeId=&quot; + newNodeId;\n            newNodeId += nodeIdOffset;\n            if (newNodeId != nodeId) {\n                nodeId = newNodeId;\n\n                // If our node ID is out of range, assign NODE_ID_OUT_OF_RANGE to nodeId\n                if ((nodeId &amp; -1 &lt;&lt; bitsNodeId) != 0) {\n                    outOfRangeMembers.add(getNodeEngine().getClusterService().getLocalMember().getUuid());\n                    logger.severe(&quot;Node ID is out of range (&quot; + nodeId + &quot;), this member won't be able to generate IDs. &quot;\n                            + &quot;Cluster restart is recommended.&quot;);\n                    nodeId = NODE_ID_OUT_OF_RANGE;\n                }\n\n                // we ignore possible double initialization\n                this.nodeId = nodeId;\n                this.nextNodeIdUpdate = nanoTime + NODE_ID_UPDATE_INTERVAL_NS;\n                if (logger.isFineEnabled()) {\n                    logger.fine(&quot;Node ID assigned to '&quot; + name + &quot;': &quot; + nodeId);\n                }\n            }\n        }\"><pre>        <span class=\"pl-k\">long</span> nextNodeIdUpdate <span class=\"pl-k\">=</span> <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>nextNodeIdUpdate;\n        <span class=\"pl-k\">int</span> nodeId <span class=\"pl-k\">=</span> <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>nodeId;\n        <span class=\"pl-k\">if</span> (nextNodeIdUpdate <span class=\"pl-k\">&lt;=</span> nanoTime) {\n            <span class=\"pl-k\">if</span> (nodeId <span class=\"pl-k\">==</span> <span class=\"pl-c1\">NODE_ID_OUT_OF_RANGE</span>) {\n                <span class=\"pl-k\">return</span> nodeId;\n            }\n            <span class=\"pl-k\">int</span> newNodeId <span class=\"pl-k\">=</span> getNodeEngine()<span class=\"pl-k\">.</span>getClusterService()<span class=\"pl-k\">.</span>getMemberListJoinVersion();\n            <span class=\"pl-k\">assert</span> newNodeId <span class=\"pl-k\">&gt;=</span> <span class=\"pl-c1\">0</span> <span class=\"pl-k\">:</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>newNodeId=<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">+</span> newNodeId;\n            newNodeId <span class=\"pl-k\">+=</span> nodeIdOffset;\n            <span class=\"pl-k\">if</span> (newNodeId <span class=\"pl-k\">!=</span> nodeId) {\n                nodeId <span class=\"pl-k\">=</span> newNodeId;\n\n                <span class=\"pl-c\"><span class=\"pl-c\">//</span> If our node ID is out of range, assign NODE_ID_OUT_OF_RANGE to nodeId</span>\n                <span class=\"pl-k\">if</span> ((nodeId <span class=\"pl-k\">&amp;</span> <span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span> <span class=\"pl-k\">&lt;&lt;</span> bitsNodeId) <span class=\"pl-k\">!=</span> <span class=\"pl-c1\">0</span>) {\n                    outOfRangeMembers<span class=\"pl-k\">.</span>add(getNodeEngine()<span class=\"pl-k\">.</span>getClusterService()<span class=\"pl-k\">.</span>getLocalMember()<span class=\"pl-k\">.</span>getUuid());\n                    logger<span class=\"pl-k\">.</span>severe(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Node ID is out of range (<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">+</span> nodeId <span class=\"pl-k\">+</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>), this member won't be able to generate IDs. <span class=\"pl-pds\">\"</span></span>\n                            <span class=\"pl-k\">+</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Cluster restart is recommended.<span class=\"pl-pds\">\"</span></span>);\n                    nodeId <span class=\"pl-k\">=</span> <span class=\"pl-c1\">NODE_ID_OUT_OF_RANGE</span>;\n                }\n\n                <span class=\"pl-c\"><span class=\"pl-c\">//</span> we ignore possible double initialization</span>\n                <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>nodeId <span class=\"pl-k\">=</span> nodeId;\n                <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>nextNodeIdUpdate <span class=\"pl-k\">=</span> nanoTime <span class=\"pl-k\">+</span> <span class=\"pl-c1\">NODE_ID_UPDATE_INTERVAL_NS</span>;\n                <span class=\"pl-k\">if</span> (logger<span class=\"pl-k\">.</span>isFineEnabled()) {\n                    logger<span class=\"pl-k\">.</span>fine(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Node ID assigned to '<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">+</span> name <span class=\"pl-k\">+</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>': <span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">+</span> nodeId);\n                }\n            }\n        }</pre></div>\n<p dir=\"auto\">It ensures that it's impossible to see no need to update before <code>nodeId</code> was assigned to some valid value.</p>", "author": "viliam-durina", "createdAt": "2020-10-05T12:15:15Z", "path": "hazelcast/src/main/java/com/hazelcast/flakeidgen/impl/FlakeIdGeneratorProxy.java", "diffHunk": "@@ -226,10 +227,18 @@ int getNodeId(long nanoTime) {\n \n                 // we ignore possible double initialization\n                 this.nodeId = nodeId;\n+                nextNodeIdUpdate = nanoTime + NODE_ID_UPDATE_INTERVAL_NS;", "originalCommit": "f9d0d7753b302f3ada62984d287dc37b4f63f8f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY1NzYyOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17671#discussion_r499657628", "bodyText": "indeed your version is easier to read. I applied it. It also addresses the  @mmedenjak finding - the hard to understand comment is simply not needed!\nI only made the local variables copies explicit: so localNodeId instead of just nodeId. I believe it's more readable.", "author": "jerrinot", "createdAt": "2020-10-05T14:50:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU1MzMzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU1NTU4NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17671#discussion_r499555584", "body": "Minor: did you want to say \"It could be that we did take the branch, yet the local nodeId variable is set to NODE_ID_NOT_YET_SET\"? I must admit, I know what you did with the else branch but I don't understand the comment :)", "bodyText": "Minor: did you want to say \"It could be that we did take the branch, yet the local nodeId variable is set to NODE_ID_NOT_YET_SET\"? I must admit, I know what you did with the else branch but I don't understand the comment :)", "bodyHTML": "<p dir=\"auto\">Minor: did you want to say \"It could be that we did take the branch, yet the local nodeId variable is set to NODE_ID_NOT_YET_SET\"? I must admit, I know what you did with the else branch but I don't understand the comment :)</p>", "author": "mmedenjak", "createdAt": "2020-10-05T12:19:33Z", "path": "hazelcast/src/main/java/com/hazelcast/flakeidgen/impl/FlakeIdGeneratorProxy.java", "diffHunk": "@@ -226,10 +227,18 @@ int getNodeId(long nanoTime) {\n \n                 // we ignore possible double initialization\n                 this.nodeId = nodeId;\n+                nextNodeIdUpdate = nanoTime + NODE_ID_UPDATE_INTERVAL_NS;\n                 if (logger.isFineEnabled()) {\n                     logger.fine(\"Node ID assigned to '\" + name + \"': \" + nodeId);\n                 }\n             }\n+        } else if (nodeId == NODE_ID_NOT_YET_SET) {\n+            // There is a race between the IF branch above and the local nodeId assignment just above the branch.\n+            // It could be we didn't take the branch yet the local nodeId variable still contains the", "originalCommit": "f9d0d7753b302f3ada62984d287dc37b4f63f8f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "48086359e34e72c396d9e320f83fd04e81906384", "url": "https://github.com/hazelcast/hazelcast/commit/48086359e34e72c396d9e320f83fd04e81906384", "message": "Fix race in NodeId innitialization in FlakeId proxy\n\nFixes #16609\n\nReasoning:\nThe `nextNodeIdUpdate` timestamp was updated BEFORE the `nodeId` field.\nThis means when 2 threads were initializing the proxy concurrently\nthen the 2nd thread could see the timestamp already updated then skip the\nIF branch and return a stale version of nodeId - which was not updated yet.\n\nThis problem is fixed by updating the timestamp after the nodeId field.", "committedDate": "2020-10-05T14:46:18Z", "type": "commit"}, {"oid": "48086359e34e72c396d9e320f83fd04e81906384", "url": "https://github.com/hazelcast/hazelcast/commit/48086359e34e72c396d9e320f83fd04e81906384", "message": "Fix race in NodeId innitialization in FlakeId proxy\n\nFixes #16609\n\nReasoning:\nThe `nextNodeIdUpdate` timestamp was updated BEFORE the `nodeId` field.\nThis means when 2 threads were initializing the proxy concurrently\nthen the 2nd thread could see the timestamp already updated then skip the\nIF branch and return a stale version of nodeId - which was not updated yet.\n\nThis problem is fixed by updating the timestamp after the nodeId field.", "committedDate": "2020-10-05T14:46:18Z", "type": "forcePushed"}]}