{"pr_number": 2099, "pr_title": "GraphCentricQueryBuilder: Optimize index selection algorithm [continuation]", "pr_createdAt": "2020-04-27T10:48:10Z", "pr_url": "https://github.com/JanusGraph/janusgraph/pull/2099", "merge_commit": "7ad753a5fecf6e4155866c7ae62a0a3da585d1e6", "timeline": [{"oid": "df8eb753a4e44ca74e79cc00c07c5d78186e94db", "url": "https://github.com/JanusGraph/janusgraph/commit/df8eb753a4e44ca74e79cc00c07c5d78186e94db", "message": "Move score logic towards IndexCandidate(Group)\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-04-27T10:52:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk5MTk2MQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r417991961", "body": "Can we maybe follow guava's powerSet contract? They look reasonable to me and nice to have IMHO.\r\n```\r\nIllegalArgumentException: If set has more than 30 unique elements, because this causes the power set size to exceed the int range.\r\nNullPointerException: If set is or contains null.\r\n```", "bodyText": "Can we maybe follow guava's powerSet contract? They look reasonable to me and nice to have IMHO.\nIllegalArgumentException: If set has more than 30 unique elements, because this causes the power set size to exceed the int range.\nNullPointerException: If set is or contains null.", "bodyHTML": "<p dir=\"auto\">Can we maybe follow guava's powerSet contract? They look reasonable to me and nice to have IMHO.</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"IllegalArgumentException: If set has more than 30 unique elements, because this causes the power set size to exceed the int range.\nNullPointerException: If set is or contains null.\"><pre><code>IllegalArgumentException: If set has more than 30 unique elements, because this causes the power set size to exceed the int range.\nNullPointerException: If set is or contains null.\n</code></pre></div>", "author": "li-boxuan", "createdAt": "2020-04-30T13:02:18Z", "path": "janusgraph-core/src/main/java/org/janusgraph/util/datastructures/SetUtil.java", "diffHunk": "@@ -0,0 +1,51 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.util.datastructures;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class SetUtil {\n+    \n+    public static <T> Set<Set<T>> powerSet(final Set<T> originalSet) {", "originalCommit": "0131c6bde27a13ed5af79fcb7644780c470dd7bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b8b801a9d163cc0766118e981f16c76830fe6bea", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/util/datastructures/SetUtil.java b/janusgraph-core/src/main/java/org/janusgraph/util/datastructures/SetUtil.java\ndeleted file mode 100644\nindex b4682652f..000000000\n--- a/janusgraph-core/src/main/java/org/janusgraph/util/datastructures/SetUtil.java\n+++ /dev/null\n", "chunk": "@@ -1,51 +0,0 @@\n-// Copyright 2020 JanusGraph Authors\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package org.janusgraph.util.datastructures;\n-\n-import java.util.HashSet;\n-import java.util.Set;\n-\n-/**\n- * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n- */\n-public class SetUtil {\n-    \n-    public static <T> Set<Set<T>> powerSet(final Set<T> originalSet) {\n-        int resultSize = (int) Math.pow(2, originalSet.size());\n-        Set<Set<T>> resultSets = new HashSet<Set<T>>(resultSize);\n-\n-        resultSets.add(new HashSet<T>(0));\n-\n-        if (originalSet.isEmpty()) {\n-            return resultSets;\n-        }\n-\n-        Set<T> remaining = new HashSet<T>(originalSet);\n-        T first = remaining.iterator().next();\n-        remaining.remove(first);\n-\n-        for (Set<T> intermediateSet : powerSet(remaining)) {\n-            // add intermediateSet without \"First\"\n-            resultSets.add(intermediateSet);\n-\n-            // add intermediateSet with \"First\"\n-            Set<T> intermediateSetWithFirst = new HashSet<T>(intermediateSet);\n-            intermediateSetWithFirst.add(first);\n-            resultSets.add(intermediateSetWithFirst);\n-        }\n-\n-        return resultSets;\n-    }\n-}\n\\ No newline at end of file\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODAxNzk4MQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r418017981", "body": "Did you explore Guava's PowerSet implementation? Their implementation seems to be more efficient: https://www.baeldung.com/java-power-set-of-a-set#optimization, and more importantly, it only uses O(n) space by utilizing the Iterator interface.", "bodyText": "Did you explore Guava's PowerSet implementation? Their implementation seems to be more efficient: https://www.baeldung.com/java-power-set-of-a-set#optimization, and more importantly, it only uses O(n) space by utilizing the Iterator interface.", "bodyHTML": "<p dir=\"auto\">Did you explore Guava's PowerSet implementation? Their implementation seems to be more efficient: <a href=\"https://www.baeldung.com/java-power-set-of-a-set#optimization\" rel=\"nofollow\">https://www.baeldung.com/java-power-set-of-a-set#optimization</a>, and more importantly, it only uses O(n) space by utilizing the Iterator interface.</p>", "author": "li-boxuan", "createdAt": "2020-04-30T13:41:05Z", "path": "janusgraph-core/src/main/java/org/janusgraph/util/datastructures/SetUtil.java", "diffHunk": "@@ -0,0 +1,51 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.util.datastructures;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class SetUtil {\n+    \n+    public static <T> Set<Set<T>> powerSet(final Set<T> originalSet) {\n+        int resultSize = (int) Math.pow(2, originalSet.size());\n+        Set<Set<T>> resultSets = new HashSet<Set<T>>(resultSize);\n+\n+        resultSets.add(new HashSet<T>(0));\n+\n+        if (originalSet.isEmpty()) {\n+            return resultSets;\n+        }\n+\n+        Set<T> remaining = new HashSet<T>(originalSet);\n+        T first = remaining.iterator().next();\n+        remaining.remove(first);\n+\n+        for (Set<T> intermediateSet : powerSet(remaining)) {", "originalCommit": "0131c6bde27a13ed5af79fcb7644780c470dd7bc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODAyMjg5MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r418022890", "bodyText": "Very interesting, I'll have a look at it!", "author": "rngcntr", "createdAt": "2020-04-30T13:47:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODAxNzk4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTIyMDA0NA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r419220044", "bodyText": "I refactored the code, it should not exceed the O(n) space bound now", "author": "rngcntr", "createdAt": "2020-05-04T05:33:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODAxNzk4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "b8b801a9d163cc0766118e981f16c76830fe6bea", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/util/datastructures/SetUtil.java b/janusgraph-core/src/main/java/org/janusgraph/util/datastructures/SetUtil.java\ndeleted file mode 100644\nindex b4682652f..000000000\n--- a/janusgraph-core/src/main/java/org/janusgraph/util/datastructures/SetUtil.java\n+++ /dev/null\n", "chunk": "@@ -1,51 +0,0 @@\n-// Copyright 2020 JanusGraph Authors\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package org.janusgraph.util.datastructures;\n-\n-import java.util.HashSet;\n-import java.util.Set;\n-\n-/**\n- * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n- */\n-public class SetUtil {\n-    \n-    public static <T> Set<Set<T>> powerSet(final Set<T> originalSet) {\n-        int resultSize = (int) Math.pow(2, originalSet.size());\n-        Set<Set<T>> resultSets = new HashSet<Set<T>>(resultSize);\n-\n-        resultSets.add(new HashSet<T>(0));\n-\n-        if (originalSet.isEmpty()) {\n-            return resultSets;\n-        }\n-\n-        Set<T> remaining = new HashSet<T>(originalSet);\n-        T first = remaining.iterator().next();\n-        remaining.remove(first);\n-\n-        for (Set<T> intermediateSet : powerSet(remaining)) {\n-            // add intermediateSet without \"First\"\n-            resultSets.add(intermediateSet);\n-\n-            // add intermediateSet with \"First\"\n-            Set<T> intermediateSetWithFirst = new HashSet<T>(intermediateSet);\n-            intermediateSetWithFirst.add(first);\n-            resultSets.add(intermediateSetWithFirst);\n-        }\n-\n-        return resultSets;\n-    }\n-}\n\\ No newline at end of file\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE1MzE0NQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r419153145", "body": "I didn't check the code yet, but have general questions about this optimization.\r\n1) Do I understand it correctly that if we use `index-select-threshold = 0` it means that current logic (which is currently in `master` branch) will be used? I.e., as I understand, if we use `0` it means that the behaviour will be the same as in current `master` branch and complexity of the current algorithm to select indexes will not be increased.\r\n\r\n2) If `1)` is `yes` than I see that this value is set by default to `10`. It means that it is a breaking change. If so, we should describe this breaking change here https://github.com/JanusGraph/janusgraph/blob/master/docs/changelog.md#upgrade-instructions\r\n\r\n3) Is it suggested to use `10` here or should user somehow decide what value to use here? Just interested, if there is 10 or less candidates, is it faster to use `brute force` algorithm or is it just sufficiently fast so that it is OK to sacrifice candidate selection performance if favour to choosing a good candidate?", "bodyText": "I didn't check the code yet, but have general questions about this optimization.\n\n\nDo I understand it correctly that if we use index-select-threshold = 0 it means that current logic (which is currently in master branch) will be used? I.e., as I understand, if we use 0 it means that the behaviour will be the same as in current master branch and complexity of the current algorithm to select indexes will not be increased.\n\n\nIf 1) is yes than I see that this value is set by default to 10. It means that it is a breaking change. If so, we should describe this breaking change here https://github.com/JanusGraph/janusgraph/blob/master/docs/changelog.md#upgrade-instructions\n\n\nIs it suggested to use 10 here or should user somehow decide what value to use here? Just interested, if there is 10 or less candidates, is it faster to use brute force algorithm or is it just sufficiently fast so that it is OK to sacrifice candidate selection performance if favour to choosing a good candidate?", "bodyHTML": "<p dir=\"auto\">I didn't check the code yet, but have general questions about this optimization.</p>\n<ol dir=\"auto\">\n<li>\n<p dir=\"auto\">Do I understand it correctly that if we use <code>index-select-threshold = 0</code> it means that current logic (which is currently in <code>master</code> branch) will be used? I.e., as I understand, if we use <code>0</code> it means that the behaviour will be the same as in current <code>master</code> branch and complexity of the current algorithm to select indexes will not be increased.</p>\n</li>\n<li>\n<p dir=\"auto\">If <code>1)</code> is <code>yes</code> than I see that this value is set by default to <code>10</code>. It means that it is a breaking change. If so, we should describe this breaking change here <a href=\"https://github.com/JanusGraph/janusgraph/blob/master/docs/changelog.md#upgrade-instructions\">https://github.com/JanusGraph/janusgraph/blob/master/docs/changelog.md#upgrade-instructions</a></p>\n</li>\n<li>\n<p dir=\"auto\">Is it suggested to use <code>10</code> here or should user somehow decide what value to use here? Just interested, if there is 10 or less candidates, is it faster to use <code>brute force</code> algorithm or is it just sufficiently fast so that it is OK to sacrifice candidate selection performance if favour to choosing a good candidate?</p>\n</li>\n</ol>", "author": "porunov", "createdAt": "2020-05-03T20:07:58Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/configuration/GraphDatabaseConfiguration.java", "diffHunk": "@@ -265,6 +265,13 @@\n                     \"performance improvement if there is a non-trivial latency to the backend.\",\n             ConfigOption.Type.MASKABLE, false);\n \n+    public static final ConfigOption<Integer> INDEX_SELECT_BRUTE_FORCE_THRESHOLD = new ConfigOption<>(QUERY_NS, \"index-select-threshold\",\n+            \"Threshold of deciding whether to use brute force enumeration algorithm or fast approximation algorithm \" +\n+                    \"for selecting suitable indexes. Selecting optimal indexes for a query is a NP-complete set cover problem. \" +\n+                    \"When number of suitable index candidates is no larger than threshold, JanusGraph uses brute force search \" +\n+                    \"with exponential time complexity to ensure the best combination of indexes is selected.\",\n+            ConfigOption.Type.MASKABLE, 10);\n+", "originalCommit": "0131c6bde27a13ed5af79fcb7644780c470dd7bc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE4MzkxNw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r419183917", "bodyText": "Yes, if set to 0, then the existing logic in current master branch will be used.\n10 is an arbitrary number picked by me originally. My primary purpose was to pick up a threshold that is \"just sufficiently fast so that it is OK to sacrifice candidate selection performance if favour to choosing a good candidate\". We could make it even smaller just to be safe it will make as least impact as possible.\nIn practice, I think the chance is small that people have many index candidates (e.g. >= 5) for one index query.", "author": "li-boxuan", "createdAt": "2020-05-04T01:08:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE1MzE0NQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "b8b801a9d163cc0766118e981f16c76830fe6bea", "url": "https://github.com/JanusGraph/janusgraph/commit/b8b801a9d163cc0766118e981f16c76830fe6bea", "message": "Refactor PowerSet implementation\n\n(requested by @li-boxuan)\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-05-04T05:45:22Z", "type": "forcePushed"}, {"oid": "3ce8c931b0ddf729d34e438512b4451ce0f0adc7", "url": "https://github.com/JanusGraph/janusgraph/commit/3ce8c931b0ddf729d34e438512b4451ce0f0adc7", "message": "Resolve conflicts\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-05-04T05:54:35Z", "type": "forcePushed"}, {"oid": "6e41aed050852e2792e24ba6f74604fa1c1a5122", "url": "https://github.com/JanusGraph/janusgraph/commit/6e41aed050852e2792e24ba6f74604fa1c1a5122", "message": "GraphCentricQueryBuilder: Optimize index selection algorithm\n\nThis intends to optimize index selection algorithm by introducing\na brute force enumeration way to select appropriate indexes in\nGraphCentricQueryBuilder.\n\nCloses #2048\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2020-05-04T06:11:27Z", "type": "commit"}, {"oid": "3edcc358bc3a802c4907ef0df3ecf291dbb89b12", "url": "https://github.com/JanusGraph/janusgraph/commit/3edcc358bc3a802c4907ef0df3ecf291dbb89b12", "message": "Resolve conflicts\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-05-04T06:11:39Z", "type": "forcePushed"}, {"oid": "751d4c40944bcd90c15c8346b526734fdfa62db5", "url": "https://github.com/JanusGraph/janusgraph/commit/751d4c40944bcd90c15c8346b526734fdfa62db5", "message": "Move score logic towards IndexCandidate(Group)\n\nAdditionally: Use custom implementation of powerSet instead of Guava\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-05-05T07:13:40Z", "type": "forcePushed"}, {"oid": "805898c704878418a853b44cbd4a651972267581", "url": "https://github.com/JanusGraph/janusgraph/commit/805898c704878418a853b44cbd4a651972267581", "message": "Move score logic towards IndexCandidate(Group)\n\nAdditionally: Use custom implementation of powerSet instead of Guava\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-05-06T08:50:48Z", "type": "commit"}, {"oid": "805898c704878418a853b44cbd4a651972267581", "url": "https://github.com/JanusGraph/janusgraph/commit/805898c704878418a853b44cbd4a651972267581", "message": "Move score logic towards IndexCandidate(Group)\n\nAdditionally: Use custom implementation of powerSet instead of Guava\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-05-06T08:50:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4Mjc1OQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r424182759", "body": "Add `final`", "bodyText": "Add final", "bodyHTML": "<p dir=\"auto\">Add <code>final</code></p>", "author": "porunov", "createdAt": "2020-05-13T05:35:46Z", "path": "janusgraph-core/src/main/java/org/janusgraph/util/datastructures/PowerSet.java", "diffHunk": "@@ -0,0 +1,78 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.util.datastructures;\n+\n+import java.util.*;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class PowerSet<T> extends AbstractSet<Set<T>> {\n+    \n+    private Set<T> originalSet;", "originalCommit": "805898c704878418a853b44cbd4a651972267581", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "434d25fa5ea74b53aea347f150b2df373983a859", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/util/datastructures/PowerSet.java b/janusgraph-core/src/main/java/org/janusgraph/util/datastructures/PowerSet.java\nindex 0339b6cc3..504a62327 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/util/datastructures/PowerSet.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/util/datastructures/PowerSet.java\n", "chunk": "@@ -21,7 +21,7 @@ import java.util.*;\n  */\n public class PowerSet<T> extends AbstractSet<Set<T>> {\n     \n-    private Set<T> originalSet;\n+    private final Set<T> originalSet;\n \n     public PowerSet(final Set<T> originalSet) {\n         this.originalSet = originalSet;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4OTYyOQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r424189629", "body": "Add `static`", "bodyText": "Add static", "bodyHTML": "<p dir=\"auto\">Add <code>static</code></p>", "author": "porunov", "createdAt": "2020-05-13T05:58:57Z", "path": "janusgraph-core/src/main/java/org/janusgraph/util/datastructures/PowerSet.java", "diffHunk": "@@ -0,0 +1,78 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.util.datastructures;\n+\n+import java.util.*;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class PowerSet<T> extends AbstractSet<Set<T>> {\n+    \n+    private Set<T> originalSet;\n+\n+    public PowerSet(final Set<T> originalSet) {\n+        this.originalSet = originalSet;\n+    }\n+\n+    @Override\n+    public Iterator<Set<T>> iterator() {\n+        return new PowerSetIterator<T>(originalSet);\n+    }\n+\n+    @Override\n+    public int size() {\n+        return 1 << originalSet.size();\n+    }\n+\n+    private class PowerSetIterator<T> implements Iterator<Set<T>> {", "originalCommit": "805898c704878418a853b44cbd4a651972267581", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "434d25fa5ea74b53aea347f150b2df373983a859", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/util/datastructures/PowerSet.java b/janusgraph-core/src/main/java/org/janusgraph/util/datastructures/PowerSet.java\nindex 0339b6cc3..504a62327 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/util/datastructures/PowerSet.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/util/datastructures/PowerSet.java\n", "chunk": "@@ -37,9 +37,9 @@ public class PowerSet<T> extends AbstractSet<Set<T>> {\n         return 1 << originalSet.size();\n     }\n \n-    private class PowerSetIterator<T> implements Iterator<Set<T>> {\n+    private static class PowerSetIterator<T> implements Iterator<Set<T>> {\n \n-        private List<T> originalElements;\n+        private final List<T> originalElements;\n         private int position;\n         private final int resultSize;\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4OTczNQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r424189735", "body": "add `final`", "bodyText": "add final", "bodyHTML": "<p dir=\"auto\">add <code>final</code></p>", "author": "porunov", "createdAt": "2020-05-13T05:59:18Z", "path": "janusgraph-core/src/main/java/org/janusgraph/util/datastructures/PowerSet.java", "diffHunk": "@@ -0,0 +1,78 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.util.datastructures;\n+\n+import java.util.*;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class PowerSet<T> extends AbstractSet<Set<T>> {\n+    \n+    private Set<T> originalSet;\n+\n+    public PowerSet(final Set<T> originalSet) {\n+        this.originalSet = originalSet;\n+    }\n+\n+    @Override\n+    public Iterator<Set<T>> iterator() {\n+        return new PowerSetIterator<T>(originalSet);\n+    }\n+\n+    @Override\n+    public int size() {\n+        return 1 << originalSet.size();\n+    }\n+\n+    private class PowerSetIterator<T> implements Iterator<Set<T>> {\n+\n+        private List<T> originalElements;", "originalCommit": "805898c704878418a853b44cbd4a651972267581", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "434d25fa5ea74b53aea347f150b2df373983a859", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/util/datastructures/PowerSet.java b/janusgraph-core/src/main/java/org/janusgraph/util/datastructures/PowerSet.java\nindex 0339b6cc3..504a62327 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/util/datastructures/PowerSet.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/util/datastructures/PowerSet.java\n", "chunk": "@@ -37,9 +37,9 @@ public class PowerSet<T> extends AbstractSet<Set<T>> {\n         return 1 << originalSet.size();\n     }\n \n-    private class PowerSetIterator<T> implements Iterator<Set<T>> {\n+    private static class PowerSetIterator<T> implements Iterator<Set<T>> {\n \n-        private List<T> originalElements;\n+        private final List<T> originalElements;\n         private int position;\n         private final int resultSize;\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY0NDA3Ng==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r424644076", "body": "`this.coveredClauses = new HashSet<>(indexCandidates.size());`", "bodyText": "this.coveredClauses = new HashSet<>(indexCandidates.size());", "bodyHTML": "<p dir=\"auto\"><code>this.coveredClauses = new HashSet&lt;&gt;(indexCandidates.size());</code></p>", "author": "porunov", "createdAt": "2020-05-13T18:25:59Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidateGroup.java", "diffHunk": "@@ -0,0 +1,71 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.util;\n+\n+import org.janusgraph.graphdb.query.condition.Condition;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class IndexCandidateGroup implements Comparable<IndexCandidateGroup> {\n+\n+    private Set<IndexCandidate> indexCandidates;\n+    private Set<Condition> coveredClauses;\n+\n+    // initialize with the worst possible score\n+    private double score = Double.NEGATIVE_INFINITY;\n+\n+    public IndexCandidateGroup(Set<IndexCandidate> indexCandidates) {\n+        this.indexCandidates = indexCandidates;\n+        this.coveredClauses = new HashSet<>();", "originalCommit": "805898c704878418a853b44cbd4a651972267581", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "434d25fa5ea74b53aea347f150b2df373983a859", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidateGroup.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidateGroup.java\nsimilarity index 95%\nrename from janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidateGroup.java\nrename to janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidateGroup.java\nindex b936c5fe4..67efa422d 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidateGroup.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidateGroup.java\n", "chunk": "@@ -32,7 +32,7 @@ public class IndexCandidateGroup implements Comparable<IndexCandidateGroup> {\n \n     public IndexCandidateGroup(Set<IndexCandidate> indexCandidates) {\n         this.indexCandidates = indexCandidates;\n-        this.coveredClauses = new HashSet<>();\n+        this.coveredClauses = new HashSet<>(indexCandidates.size());\n \n         indexCandidates.forEach(c -> coveredClauses.addAll(c.getSubCover()));\n     }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5MDI0NA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r424690244", "body": "Redundant `null` initialization", "bodyText": "Redundant null initialization", "bodyHTML": "<p dir=\"auto\">Redundant <code>null</code> initialization</p>", "author": "porunov", "createdAt": "2020-05-13T19:48:22Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidate.java", "diffHunk": "@@ -0,0 +1,170 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.util;\n+\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.core.schema.JanusGraphSchemaType;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.condition.PredicateCondition;\n+import org.janusgraph.graphdb.query.graph.GraphCentricQueryBuilder;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.janusgraph.graphdb.types.MixedIndexType;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class IndexCandidate {\n+    private static final double EQUAL_CONDITION_SCORE = 4;\n+    private static final double OTHER_CONDITION_SCORE = 1;\n+    private static final double CARDINALITY_SINGE_SCORE = 1000;\n+    private static final double CARDINALITY_OTHER_SCORE = 1000;\n+\n+    private static final double ORDER_MATCH = 1;\n+    private static final double ALREADY_MATCHED_ADJUSTOR = -1.1;\n+\n+    private final IndexType index;\n+    private final Set<Condition> subCover;\n+    private final Object subCondition;\n+\n+    // initialize with the worst possible score\n+    private double score = Double.NEGATIVE_INFINITY;\n+\n+    public IndexCandidate(final IndexType index,\n+                          final MultiCondition<JanusGraphElement> conditions,\n+                          final IndexSerializer serializer) {\n+        this.index = index;\n+\n+        final Set<Condition> subCover = new HashSet<>(1);\n+        Object subCondition = null;", "originalCommit": "805898c704878418a853b44cbd4a651972267581", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "434d25fa5ea74b53aea347f150b2df373983a859", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidate.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\nsimilarity index 62%\nrename from janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidate.java\nrename to janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\nindex 74091ea56..f821ea00a 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidate.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\n", "chunk": "@@ -53,44 +43,9 @@ public class IndexCandidate {\n     private double score = Double.NEGATIVE_INFINITY;\n \n     public IndexCandidate(final IndexType index,\n-                          final MultiCondition<JanusGraphElement> conditions,\n-                          final IndexSerializer serializer) {\n+                          final Set<Condition> subCover,\n+                          final Object subCondition) {\n         this.index = index;\n-\n-        final Set<Condition> subCover = new HashSet<>(1);\n-        Object subCondition = null;\n-\n-        // Check that this index actually applies in case of a schema constraint\n-        if (index.hasSchemaTypeConstraint()) {\n-            final JanusGraphSchemaType type = index.getSchemaTypeConstraint();\n-            final Map.Entry<Condition, Collection<Object>> equalCon =\n-                GraphCentricQueryBuilder.getEqualityConditionValues(conditions, ImplicitKey.LABEL);\n-\n-            if (equalCon == null) {\n-                throw new IllegalArgumentException(\"Only equality conditions are supported\");\n-            }\n-\n-            final Collection<Object> labels = equalCon.getValue();\n-            assert labels.size() >= 1;\n-\n-            if (labels.size() > 1) {\n-                throw new IllegalArgumentException(\"The query optimizer currently does not support multiple label constraints\");\n-            }\n-            if (!type.name().equals(labels.iterator().next())) {\n-                throw new IllegalArgumentException(\"Given IndexType does not match given condition label\");\n-            }\n-            subCover.add(equalCon.getKey());\n-        }\n-\n-        if (index.isCompositeIndex()) {\n-            subCondition = GraphCentricQueryBuilder.indexCover((CompositeIndexType) index, conditions, subCover);\n-        } else {\n-            subCondition = GraphCentricQueryBuilder.indexCover((MixedIndexType) index, conditions, serializer, subCover);\n-        }\n-        if (subCondition == null || subCover.isEmpty()) {\n-            throw new IllegalArgumentException(\"Unable to initialize IndexCandidate from given parameters\");\n-        }\n-        \n         this.subCover = subCover;\n         this.subCondition = subCondition;\n     }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5NTcyMA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r424695720", "body": "I see that this logic was in the old code but `CARDINALITY_SINGE_SCORE` and `CARDINALITY_OTHER_SCORE` are both always equal to `1000`, so maybe it should be combined into a single constant like `CARDINALITY_SCORE`?\r\nIf so, the code can be simplified to:\r\n```\r\nif(index.isCompositeIndex()){\r\n    return CARDINALITY_SINGE_SCORE;\r\n}\r\nreturn 0.0;\r\n```", "bodyText": "I see that this logic was in the old code but CARDINALITY_SINGE_SCORE and CARDINALITY_OTHER_SCORE are both always equal to 1000, so maybe it should be combined into a single constant like CARDINALITY_SCORE?\nIf so, the code can be simplified to:\nif(index.isCompositeIndex()){\n    return CARDINALITY_SINGE_SCORE;\n}\nreturn 0.0;", "bodyHTML": "<p dir=\"auto\">I see that this logic was in the old code but <code>CARDINALITY_SINGE_SCORE</code> and <code>CARDINALITY_OTHER_SCORE</code> are both always equal to <code>1000</code>, so maybe it should be combined into a single constant like <code>CARDINALITY_SCORE</code>?<br>\nIf so, the code can be simplified to:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"if(index.isCompositeIndex()){\n    return CARDINALITY_SINGE_SCORE;\n}\nreturn 0.0;\"><pre><code>if(index.isCompositeIndex()){\n    return CARDINALITY_SINGE_SCORE;\n}\nreturn 0.0;\n</code></pre></div>", "author": "porunov", "createdAt": "2020-05-13T19:58:23Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidate.java", "diffHunk": "@@ -0,0 +1,170 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.util;\n+\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.core.schema.JanusGraphSchemaType;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.condition.PredicateCondition;\n+import org.janusgraph.graphdb.query.graph.GraphCentricQueryBuilder;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.janusgraph.graphdb.types.MixedIndexType;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class IndexCandidate {\n+    private static final double EQUAL_CONDITION_SCORE = 4;\n+    private static final double OTHER_CONDITION_SCORE = 1;\n+    private static final double CARDINALITY_SINGE_SCORE = 1000;\n+    private static final double CARDINALITY_OTHER_SCORE = 1000;\n+\n+    private static final double ORDER_MATCH = 1;\n+    private static final double ALREADY_MATCHED_ADJUSTOR = -1.1;\n+\n+    private final IndexType index;\n+    private final Set<Condition> subCover;\n+    private final Object subCondition;\n+\n+    // initialize with the worst possible score\n+    private double score = Double.NEGATIVE_INFINITY;\n+\n+    public IndexCandidate(final IndexType index,\n+                          final MultiCondition<JanusGraphElement> conditions,\n+                          final IndexSerializer serializer) {\n+        this.index = index;\n+\n+        final Set<Condition> subCover = new HashSet<>(1);\n+        Object subCondition = null;\n+\n+        // Check that this index actually applies in case of a schema constraint\n+        if (index.hasSchemaTypeConstraint()) {\n+            final JanusGraphSchemaType type = index.getSchemaTypeConstraint();\n+            final Map.Entry<Condition, Collection<Object>> equalCon =\n+                GraphCentricQueryBuilder.getEqualityConditionValues(conditions, ImplicitKey.LABEL);\n+\n+            if (equalCon == null) {\n+                throw new IllegalArgumentException(\"Only equality conditions are supported\");\n+            }\n+\n+            final Collection<Object> labels = equalCon.getValue();\n+            assert labels.size() >= 1;\n+\n+            if (labels.size() > 1) {\n+                throw new IllegalArgumentException(\"The query optimizer currently does not support multiple label constraints\");\n+            }\n+            if (!type.name().equals(labels.iterator().next())) {\n+                throw new IllegalArgumentException(\"Given IndexType does not match given condition label\");\n+            }\n+            subCover.add(equalCon.getKey());\n+        }\n+\n+        if (index.isCompositeIndex()) {\n+            subCondition = GraphCentricQueryBuilder.indexCover((CompositeIndexType) index, conditions, subCover);\n+        } else {\n+            subCondition = GraphCentricQueryBuilder.indexCover((MixedIndexType) index, conditions, serializer, subCover);\n+        }\n+        if (subCondition == null || subCover.isEmpty()) {\n+            throw new IllegalArgumentException(\"Unable to initialize IndexCandidate from given parameters\");\n+        }\n+        \n+        this.subCover = subCover;\n+        this.subCondition = subCondition;\n+    }\n+\n+    public IndexType getIndex() {\n+        return index;\n+    }\n+\n+    public Set<Condition> getSubCover() {\n+        return subCover;\n+    }\n+\n+    public Object getSubCondition() {\n+        return subCondition;\n+    }\n+\n+    public void calculateScoreBruteForce() {\n+        score = 0.0;\n+        for (final Condition c : subCover) {\n+            score += getConditionBasicScore(c) + getIndexTypeScore(index);\n+        }\n+    }\n+\n+    public void calculateScoreApproximation(final Set<Condition> coveredClauses, boolean supportsSort) {\n+        score = 0.0;\n+\n+        for (final Condition c : subCover) {\n+            double subScore = getConditionBasicScore(c);\n+            if (coveredClauses.contains(c)) {\n+                subScore = subScore * ALREADY_MATCHED_ADJUSTOR;\n+            }\n+            score += subScore + getIndexTypeScore(index);\n+        }\n+\n+        if (supportsSort) {\n+            score += ORDER_MATCH;\n+        }\n+    }\n+\n+    public double getScore() {\n+        return score;\n+    }\n+\n+    /**\n+     * Determines if this IndexCandidate only covers clauses, which are already covered by a given set.\n+     * @param coveringClauses\n+     * @return true if the IndexCandidate is fully covered by the given set. false if not.\n+     */\n+    public boolean isCoveredBy(final Set<Condition> coveringClauses) {\n+        for (final Condition c : subCover) {\n+            if (!coveringClauses.contains(c)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private double getConditionBasicScore(final Condition c) {\n+        if (c instanceof PredicateCondition && ((PredicateCondition) c).getPredicate() == Cmp.EQUAL) {\n+            return EQUAL_CONDITION_SCORE;\n+        } else {\n+            return OTHER_CONDITION_SCORE;\n+        }\n+    }\n+\n+    private double getIndexTypeScore(final IndexType index) {\n+        double score = 0.0;\n+        if (index.isCompositeIndex()) {\n+            if (((CompositeIndexType)index).getCardinality() == Cardinality.SINGLE) {\n+                score = CARDINALITY_SINGE_SCORE;\n+            } else {\n+                score = CARDINALITY_OTHER_SCORE;\n+            }\n+        }\n+        return score;\n+    }", "originalCommit": "805898c704878418a853b44cbd4a651972267581", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU3MjQ4MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r425572480", "bodyText": "To me it looks like these constants were introduced with thought in mind that there should be a distinction in scores between cardinalities. It just looks like the original author prepared this distinction but did evaluate the performance impact of different scores right away.\nTherefore in my opinion, we should keep this code as an entry point for further optimizations as it already hints to a tweak which can increase performance.", "author": "rngcntr", "createdAt": "2020-05-15T05:23:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5NTcyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU5NjE3MQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r425596171", "bodyText": "Good points! Agree!", "author": "porunov", "createdAt": "2020-05-15T06:39:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5NTcyMA=="}], "type": "inlineReview", "revised_code": {"commit": "e343e5d474cc583abb6811b6a1b218780c387935", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidate.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidate.java\ndeleted file mode 100644\nindex 74091ea56..000000000\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidate.java\n+++ /dev/null\n", "chunk": "@@ -1,170 +0,0 @@\n-// Copyright 2020 JanusGraph Authors\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package org.janusgraph.graphdb.util;\n-\n-import org.janusgraph.core.Cardinality;\n-import org.janusgraph.core.JanusGraphElement;\n-import org.janusgraph.core.attribute.Cmp;\n-import org.janusgraph.core.schema.JanusGraphSchemaType;\n-import org.janusgraph.graphdb.database.IndexSerializer;\n-import org.janusgraph.graphdb.query.condition.Condition;\n-import org.janusgraph.graphdb.query.condition.MultiCondition;\n-import org.janusgraph.graphdb.query.condition.PredicateCondition;\n-import org.janusgraph.graphdb.query.graph.GraphCentricQueryBuilder;\n-import org.janusgraph.graphdb.types.CompositeIndexType;\n-import org.janusgraph.graphdb.types.IndexType;\n-import org.janusgraph.graphdb.types.MixedIndexType;\n-import org.janusgraph.graphdb.types.system.ImplicitKey;\n-\n-import java.util.Collection;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-\n-/**\n- * @author Boxuan Li (liboxuan@connect.hku.hk)\n- */\n-public class IndexCandidate {\n-    private static final double EQUAL_CONDITION_SCORE = 4;\n-    private static final double OTHER_CONDITION_SCORE = 1;\n-    private static final double CARDINALITY_SINGE_SCORE = 1000;\n-    private static final double CARDINALITY_OTHER_SCORE = 1000;\n-\n-    private static final double ORDER_MATCH = 1;\n-    private static final double ALREADY_MATCHED_ADJUSTOR = -1.1;\n-\n-    private final IndexType index;\n-    private final Set<Condition> subCover;\n-    private final Object subCondition;\n-\n-    // initialize with the worst possible score\n-    private double score = Double.NEGATIVE_INFINITY;\n-\n-    public IndexCandidate(final IndexType index,\n-                          final MultiCondition<JanusGraphElement> conditions,\n-                          final IndexSerializer serializer) {\n-        this.index = index;\n-\n-        final Set<Condition> subCover = new HashSet<>(1);\n-        Object subCondition = null;\n-\n-        // Check that this index actually applies in case of a schema constraint\n-        if (index.hasSchemaTypeConstraint()) {\n-            final JanusGraphSchemaType type = index.getSchemaTypeConstraint();\n-            final Map.Entry<Condition, Collection<Object>> equalCon =\n-                GraphCentricQueryBuilder.getEqualityConditionValues(conditions, ImplicitKey.LABEL);\n-\n-            if (equalCon == null) {\n-                throw new IllegalArgumentException(\"Only equality conditions are supported\");\n-            }\n-\n-            final Collection<Object> labels = equalCon.getValue();\n-            assert labels.size() >= 1;\n-\n-            if (labels.size() > 1) {\n-                throw new IllegalArgumentException(\"The query optimizer currently does not support multiple label constraints\");\n-            }\n-            if (!type.name().equals(labels.iterator().next())) {\n-                throw new IllegalArgumentException(\"Given IndexType does not match given condition label\");\n-            }\n-            subCover.add(equalCon.getKey());\n-        }\n-\n-        if (index.isCompositeIndex()) {\n-            subCondition = GraphCentricQueryBuilder.indexCover((CompositeIndexType) index, conditions, subCover);\n-        } else {\n-            subCondition = GraphCentricQueryBuilder.indexCover((MixedIndexType) index, conditions, serializer, subCover);\n-        }\n-        if (subCondition == null || subCover.isEmpty()) {\n-            throw new IllegalArgumentException(\"Unable to initialize IndexCandidate from given parameters\");\n-        }\n-        \n-        this.subCover = subCover;\n-        this.subCondition = subCondition;\n-    }\n-\n-    public IndexType getIndex() {\n-        return index;\n-    }\n-\n-    public Set<Condition> getSubCover() {\n-        return subCover;\n-    }\n-\n-    public Object getSubCondition() {\n-        return subCondition;\n-    }\n-\n-    public void calculateScoreBruteForce() {\n-        score = 0.0;\n-        for (final Condition c : subCover) {\n-            score += getConditionBasicScore(c) + getIndexTypeScore(index);\n-        }\n-    }\n-\n-    public void calculateScoreApproximation(final Set<Condition> coveredClauses, boolean supportsSort) {\n-        score = 0.0;\n-\n-        for (final Condition c : subCover) {\n-            double subScore = getConditionBasicScore(c);\n-            if (coveredClauses.contains(c)) {\n-                subScore = subScore * ALREADY_MATCHED_ADJUSTOR;\n-            }\n-            score += subScore + getIndexTypeScore(index);\n-        }\n-\n-        if (supportsSort) {\n-            score += ORDER_MATCH;\n-        }\n-    }\n-\n-    public double getScore() {\n-        return score;\n-    }\n-\n-    /**\n-     * Determines if this IndexCandidate only covers clauses, which are already covered by a given set.\n-     * @param coveringClauses\n-     * @return true if the IndexCandidate is fully covered by the given set. false if not.\n-     */\n-    public boolean isCoveredBy(final Set<Condition> coveringClauses) {\n-        for (final Condition c : subCover) {\n-            if (!coveringClauses.contains(c)) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    private double getConditionBasicScore(final Condition c) {\n-        if (c instanceof PredicateCondition && ((PredicateCondition) c).getPredicate() == Cmp.EQUAL) {\n-            return EQUAL_CONDITION_SCORE;\n-        } else {\n-            return OTHER_CONDITION_SCORE;\n-        }\n-    }\n-\n-    private double getIndexTypeScore(final IndexType index) {\n-        double score = 0.0;\n-        if (index.isCompositeIndex()) {\n-            if (((CompositeIndexType)index).getCardinality() == Cardinality.SINGLE) {\n-                score = CARDINALITY_SINGE_SCORE;\n-            } else {\n-                score = CARDINALITY_OTHER_SCORE;\n-            }\n-        }\n-        return score;\n-    }\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcwMjczMA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r424702730", "body": "Previous logic didn't throw an exception. I guess the logic is expected to be used by users thus we should not throw an exception here.\r\nNot only we decrease performance for these expected scenarios but also we are hiding all exceptions later in the caller call which makes not much sense from an exception (just stopping to create a class). \r\nThis problem happened due to business logic in the constructor which is considered a bad practice because it becomes harder to provide mocks into the constructor and thus harder to test it in the future. It is better to follow `DI` here and rewrite this constructor to:\r\n```\r\npublic IndexCandidate(IndexType index, Set<Condition> subCover, Object subCondition){\r\n    this.index = index;\r\n    this.subCover = subCover;\r\n    this.subCondition = subCondition;\r\n}\r\n```", "bodyText": "Previous logic didn't throw an exception. I guess the logic is expected to be used by users thus we should not throw an exception here.\nNot only we decrease performance for these expected scenarios but also we are hiding all exceptions later in the caller call which makes not much sense from an exception (just stopping to create a class).\nThis problem happened due to business logic in the constructor which is considered a bad practice because it becomes harder to provide mocks into the constructor and thus harder to test it in the future. It is better to follow DI here and rewrite this constructor to:\npublic IndexCandidate(IndexType index, Set<Condition> subCover, Object subCondition){\n    this.index = index;\n    this.subCover = subCover;\n    this.subCondition = subCondition;\n}", "bodyHTML": "<p dir=\"auto\">Previous logic didn't throw an exception. I guess the logic is expected to be used by users thus we should not throw an exception here.<br>\nNot only we decrease performance for these expected scenarios but also we are hiding all exceptions later in the caller call which makes not much sense from an exception (just stopping to create a class).<br>\nThis problem happened due to business logic in the constructor which is considered a bad practice because it becomes harder to provide mocks into the constructor and thus harder to test it in the future. It is better to follow <code>DI</code> here and rewrite this constructor to:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"public IndexCandidate(IndexType index, Set&lt;Condition&gt; subCover, Object subCondition){\n    this.index = index;\n    this.subCover = subCover;\n    this.subCondition = subCondition;\n}\"><pre><code>public IndexCandidate(IndexType index, Set&lt;Condition&gt; subCover, Object subCondition){\n    this.index = index;\n    this.subCover = subCover;\n    this.subCondition = subCondition;\n}\n</code></pre></div>", "author": "porunov", "createdAt": "2020-05-13T20:11:24Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidate.java", "diffHunk": "@@ -0,0 +1,170 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.util;\n+\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.core.schema.JanusGraphSchemaType;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.condition.PredicateCondition;\n+import org.janusgraph.graphdb.query.graph.GraphCentricQueryBuilder;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.janusgraph.graphdb.types.MixedIndexType;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class IndexCandidate {\n+    private static final double EQUAL_CONDITION_SCORE = 4;\n+    private static final double OTHER_CONDITION_SCORE = 1;\n+    private static final double CARDINALITY_SINGE_SCORE = 1000;\n+    private static final double CARDINALITY_OTHER_SCORE = 1000;\n+\n+    private static final double ORDER_MATCH = 1;\n+    private static final double ALREADY_MATCHED_ADJUSTOR = -1.1;\n+\n+    private final IndexType index;\n+    private final Set<Condition> subCover;\n+    private final Object subCondition;\n+\n+    // initialize with the worst possible score\n+    private double score = Double.NEGATIVE_INFINITY;\n+\n+    public IndexCandidate(final IndexType index,\n+                          final MultiCondition<JanusGraphElement> conditions,\n+                          final IndexSerializer serializer) {\n+        this.index = index;\n+\n+        final Set<Condition> subCover = new HashSet<>(1);\n+        Object subCondition = null;\n+\n+        // Check that this index actually applies in case of a schema constraint\n+        if (index.hasSchemaTypeConstraint()) {\n+            final JanusGraphSchemaType type = index.getSchemaTypeConstraint();\n+            final Map.Entry<Condition, Collection<Object>> equalCon =\n+                GraphCentricQueryBuilder.getEqualityConditionValues(conditions, ImplicitKey.LABEL);\n+\n+            if (equalCon == null) {\n+                throw new IllegalArgumentException(\"Only equality conditions are supported\");\n+            }", "originalCommit": "805898c704878418a853b44cbd4a651972267581", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "434d25fa5ea74b53aea347f150b2df373983a859", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidate.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\nsimilarity index 62%\nrename from janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidate.java\nrename to janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\nindex 74091ea56..f821ea00a 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidate.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\n", "chunk": "@@ -53,44 +43,9 @@ public class IndexCandidate {\n     private double score = Double.NEGATIVE_INFINITY;\n \n     public IndexCandidate(final IndexType index,\n-                          final MultiCondition<JanusGraphElement> conditions,\n-                          final IndexSerializer serializer) {\n+                          final Set<Condition> subCover,\n+                          final Object subCondition) {\n         this.index = index;\n-\n-        final Set<Condition> subCover = new HashSet<>(1);\n-        Object subCondition = null;\n-\n-        // Check that this index actually applies in case of a schema constraint\n-        if (index.hasSchemaTypeConstraint()) {\n-            final JanusGraphSchemaType type = index.getSchemaTypeConstraint();\n-            final Map.Entry<Condition, Collection<Object>> equalCon =\n-                GraphCentricQueryBuilder.getEqualityConditionValues(conditions, ImplicitKey.LABEL);\n-\n-            if (equalCon == null) {\n-                throw new IllegalArgumentException(\"Only equality conditions are supported\");\n-            }\n-\n-            final Collection<Object> labels = equalCon.getValue();\n-            assert labels.size() >= 1;\n-\n-            if (labels.size() > 1) {\n-                throw new IllegalArgumentException(\"The query optimizer currently does not support multiple label constraints\");\n-            }\n-            if (!type.name().equals(labels.iterator().next())) {\n-                throw new IllegalArgumentException(\"Given IndexType does not match given condition label\");\n-            }\n-            subCover.add(equalCon.getKey());\n-        }\n-\n-        if (index.isCompositeIndex()) {\n-            subCondition = GraphCentricQueryBuilder.indexCover((CompositeIndexType) index, conditions, subCover);\n-        } else {\n-            subCondition = GraphCentricQueryBuilder.indexCover((MixedIndexType) index, conditions, serializer, subCover);\n-        }\n-        if (subCondition == null || subCover.isEmpty()) {\n-            throw new IllegalArgumentException(\"Unable to initialize IndexCandidate from given parameters\");\n-        }\n-        \n         this.subCover = subCover;\n         this.subCondition = subCondition;\n     }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcwNDU4Nw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r424704587", "body": "Don't throw an exception on expected logic. Exception should not be used as `if else` conditions.", "bodyText": "Don't throw an exception on expected logic. Exception should not be used as if else conditions.", "bodyHTML": "<p dir=\"auto\">Don't throw an exception on expected logic. Exception should not be used as <code>if else</code> conditions.</p>", "author": "porunov", "createdAt": "2020-05-13T20:14:48Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidate.java", "diffHunk": "@@ -0,0 +1,170 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.util;\n+\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.core.schema.JanusGraphSchemaType;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.condition.PredicateCondition;\n+import org.janusgraph.graphdb.query.graph.GraphCentricQueryBuilder;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.janusgraph.graphdb.types.MixedIndexType;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class IndexCandidate {\n+    private static final double EQUAL_CONDITION_SCORE = 4;\n+    private static final double OTHER_CONDITION_SCORE = 1;\n+    private static final double CARDINALITY_SINGE_SCORE = 1000;\n+    private static final double CARDINALITY_OTHER_SCORE = 1000;\n+\n+    private static final double ORDER_MATCH = 1;\n+    private static final double ALREADY_MATCHED_ADJUSTOR = -1.1;\n+\n+    private final IndexType index;\n+    private final Set<Condition> subCover;\n+    private final Object subCondition;\n+\n+    // initialize with the worst possible score\n+    private double score = Double.NEGATIVE_INFINITY;\n+\n+    public IndexCandidate(final IndexType index,\n+                          final MultiCondition<JanusGraphElement> conditions,\n+                          final IndexSerializer serializer) {\n+        this.index = index;\n+\n+        final Set<Condition> subCover = new HashSet<>(1);\n+        Object subCondition = null;\n+\n+        // Check that this index actually applies in case of a schema constraint\n+        if (index.hasSchemaTypeConstraint()) {\n+            final JanusGraphSchemaType type = index.getSchemaTypeConstraint();\n+            final Map.Entry<Condition, Collection<Object>> equalCon =\n+                GraphCentricQueryBuilder.getEqualityConditionValues(conditions, ImplicitKey.LABEL);\n+\n+            if (equalCon == null) {\n+                throw new IllegalArgumentException(\"Only equality conditions are supported\");\n+            }\n+\n+            final Collection<Object> labels = equalCon.getValue();\n+            assert labels.size() >= 1;\n+\n+            if (labels.size() > 1) {\n+                throw new IllegalArgumentException(\"The query optimizer currently does not support multiple label constraints\");\n+            }\n+            if (!type.name().equals(labels.iterator().next())) {\n+                throw new IllegalArgumentException(\"Given IndexType does not match given condition label\");\n+            }", "originalCommit": "805898c704878418a853b44cbd4a651972267581", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "434d25fa5ea74b53aea347f150b2df373983a859", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidate.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\nsimilarity index 62%\nrename from janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidate.java\nrename to janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\nindex 74091ea56..f821ea00a 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidate.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\n", "chunk": "@@ -53,44 +43,9 @@ public class IndexCandidate {\n     private double score = Double.NEGATIVE_INFINITY;\n \n     public IndexCandidate(final IndexType index,\n-                          final MultiCondition<JanusGraphElement> conditions,\n-                          final IndexSerializer serializer) {\n+                          final Set<Condition> subCover,\n+                          final Object subCondition) {\n         this.index = index;\n-\n-        final Set<Condition> subCover = new HashSet<>(1);\n-        Object subCondition = null;\n-\n-        // Check that this index actually applies in case of a schema constraint\n-        if (index.hasSchemaTypeConstraint()) {\n-            final JanusGraphSchemaType type = index.getSchemaTypeConstraint();\n-            final Map.Entry<Condition, Collection<Object>> equalCon =\n-                GraphCentricQueryBuilder.getEqualityConditionValues(conditions, ImplicitKey.LABEL);\n-\n-            if (equalCon == null) {\n-                throw new IllegalArgumentException(\"Only equality conditions are supported\");\n-            }\n-\n-            final Collection<Object> labels = equalCon.getValue();\n-            assert labels.size() >= 1;\n-\n-            if (labels.size() > 1) {\n-                throw new IllegalArgumentException(\"The query optimizer currently does not support multiple label constraints\");\n-            }\n-            if (!type.name().equals(labels.iterator().next())) {\n-                throw new IllegalArgumentException(\"Given IndexType does not match given condition label\");\n-            }\n-            subCover.add(equalCon.getKey());\n-        }\n-\n-        if (index.isCompositeIndex()) {\n-            subCondition = GraphCentricQueryBuilder.indexCover((CompositeIndexType) index, conditions, subCover);\n-        } else {\n-            subCondition = GraphCentricQueryBuilder.indexCover((MixedIndexType) index, conditions, serializer, subCover);\n-        }\n-        if (subCondition == null || subCover.isEmpty()) {\n-            throw new IllegalArgumentException(\"Unable to initialize IndexCandidate from given parameters\");\n-        }\n-        \n         this.subCover = subCover;\n         this.subCondition = subCondition;\n     }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcwNDY2Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r424704663", "body": "Don't throw an exception on expected logic. Exception should not be used as `if else` conditions.", "bodyText": "Don't throw an exception on expected logic. Exception should not be used as if else conditions.", "bodyHTML": "<p dir=\"auto\">Don't throw an exception on expected logic. Exception should not be used as <code>if else</code> conditions.</p>", "author": "porunov", "createdAt": "2020-05-13T20:14:56Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidate.java", "diffHunk": "@@ -0,0 +1,170 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.util;\n+\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.core.schema.JanusGraphSchemaType;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.condition.PredicateCondition;\n+import org.janusgraph.graphdb.query.graph.GraphCentricQueryBuilder;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.janusgraph.graphdb.types.MixedIndexType;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class IndexCandidate {\n+    private static final double EQUAL_CONDITION_SCORE = 4;\n+    private static final double OTHER_CONDITION_SCORE = 1;\n+    private static final double CARDINALITY_SINGE_SCORE = 1000;\n+    private static final double CARDINALITY_OTHER_SCORE = 1000;\n+\n+    private static final double ORDER_MATCH = 1;\n+    private static final double ALREADY_MATCHED_ADJUSTOR = -1.1;\n+\n+    private final IndexType index;\n+    private final Set<Condition> subCover;\n+    private final Object subCondition;\n+\n+    // initialize with the worst possible score\n+    private double score = Double.NEGATIVE_INFINITY;\n+\n+    public IndexCandidate(final IndexType index,\n+                          final MultiCondition<JanusGraphElement> conditions,\n+                          final IndexSerializer serializer) {\n+        this.index = index;\n+\n+        final Set<Condition> subCover = new HashSet<>(1);\n+        Object subCondition = null;\n+\n+        // Check that this index actually applies in case of a schema constraint\n+        if (index.hasSchemaTypeConstraint()) {\n+            final JanusGraphSchemaType type = index.getSchemaTypeConstraint();\n+            final Map.Entry<Condition, Collection<Object>> equalCon =\n+                GraphCentricQueryBuilder.getEqualityConditionValues(conditions, ImplicitKey.LABEL);\n+\n+            if (equalCon == null) {\n+                throw new IllegalArgumentException(\"Only equality conditions are supported\");\n+            }\n+\n+            final Collection<Object> labels = equalCon.getValue();\n+            assert labels.size() >= 1;\n+\n+            if (labels.size() > 1) {\n+                throw new IllegalArgumentException(\"The query optimizer currently does not support multiple label constraints\");\n+            }\n+            if (!type.name().equals(labels.iterator().next())) {\n+                throw new IllegalArgumentException(\"Given IndexType does not match given condition label\");\n+            }\n+            subCover.add(equalCon.getKey());\n+        }\n+\n+        if (index.isCompositeIndex()) {\n+            subCondition = GraphCentricQueryBuilder.indexCover((CompositeIndexType) index, conditions, subCover);\n+        } else {\n+            subCondition = GraphCentricQueryBuilder.indexCover((MixedIndexType) index, conditions, serializer, subCover);\n+        }\n+        if (subCondition == null || subCover.isEmpty()) {\n+            throw new IllegalArgumentException(\"Unable to initialize IndexCandidate from given parameters\");\n+        }", "originalCommit": "805898c704878418a853b44cbd4a651972267581", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "434d25fa5ea74b53aea347f150b2df373983a859", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidate.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\nsimilarity index 62%\nrename from janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidate.java\nrename to janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\nindex 74091ea56..f821ea00a 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidate.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\n", "chunk": "@@ -53,44 +43,9 @@ public class IndexCandidate {\n     private double score = Double.NEGATIVE_INFINITY;\n \n     public IndexCandidate(final IndexType index,\n-                          final MultiCondition<JanusGraphElement> conditions,\n-                          final IndexSerializer serializer) {\n+                          final Set<Condition> subCover,\n+                          final Object subCondition) {\n         this.index = index;\n-\n-        final Set<Condition> subCover = new HashSet<>(1);\n-        Object subCondition = null;\n-\n-        // Check that this index actually applies in case of a schema constraint\n-        if (index.hasSchemaTypeConstraint()) {\n-            final JanusGraphSchemaType type = index.getSchemaTypeConstraint();\n-            final Map.Entry<Condition, Collection<Object>> equalCon =\n-                GraphCentricQueryBuilder.getEqualityConditionValues(conditions, ImplicitKey.LABEL);\n-\n-            if (equalCon == null) {\n-                throw new IllegalArgumentException(\"Only equality conditions are supported\");\n-            }\n-\n-            final Collection<Object> labels = equalCon.getValue();\n-            assert labels.size() >= 1;\n-\n-            if (labels.size() > 1) {\n-                throw new IllegalArgumentException(\"The query optimizer currently does not support multiple label constraints\");\n-            }\n-            if (!type.name().equals(labels.iterator().next())) {\n-                throw new IllegalArgumentException(\"Given IndexType does not match given condition label\");\n-            }\n-            subCover.add(equalCon.getKey());\n-        }\n-\n-        if (index.isCompositeIndex()) {\n-            subCondition = GraphCentricQueryBuilder.indexCover((CompositeIndexType) index, conditions, subCover);\n-        } else {\n-            subCondition = GraphCentricQueryBuilder.indexCover((MixedIndexType) index, conditions, serializer, subCover);\n-        }\n-        if (subCondition == null || subCover.isEmpty()) {\n-            throw new IllegalArgumentException(\"Unable to initialize IndexCandidate from given parameters\");\n-        }\n-        \n         this.subCover = subCover;\n         this.subCondition = subCondition;\n     }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxNTI4OQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r424715289", "body": "To be fair, I would try to rewrite this class. I know there are a lot of places in JanusGraph where we should rewrite the code but as more we putting complex code the harder it becomes to maintain and extend it.\r\nIf @rngcntr can rewrite it in this PR, that's great. If cannot, I may later take this PR in made another continuation but I will need to research the logic behind it. I need to understand the purpose behind this logic more.\r\n\r\nBasically, what I can see here on first glance:\r\n1) This is a mix of POJO + some calculation logic. It is better to separate business logic from models.\r\n2) It violates Single-responsibility principle not only because it mix of POJO and business logic but because it combines all possible implementations of `score` calculation inside a single class. In case we have a totally different implementation which might depend on some dependency which neither `BruteForce` nor `Approximation` implementations depend on, then we will need to add an unnecessary dependency to those implementations.\r\n3) It violates Dependency inversion principle because it depends on concrete `subCover` and `subCondition` inside its constructor.", "bodyText": "To be fair, I would try to rewrite this class. I know there are a lot of places in JanusGraph where we should rewrite the code but as more we putting complex code the harder it becomes to maintain and extend it.\nIf @rngcntr can rewrite it in this PR, that's great. If cannot, I may later take this PR in made another continuation but I will need to research the logic behind it. I need to understand the purpose behind this logic more.\nBasically, what I can see here on first glance:\n\nThis is a mix of POJO + some calculation logic. It is better to separate business logic from models.\nIt violates Single-responsibility principle not only because it mix of POJO and business logic but because it combines all possible implementations of score calculation inside a single class. In case we have a totally different implementation which might depend on some dependency which neither BruteForce nor Approximation implementations depend on, then we will need to add an unnecessary dependency to those implementations.\nIt violates Dependency inversion principle because it depends on concrete subCover and subCondition inside its constructor.", "bodyHTML": "<p dir=\"auto\">To be fair, I would try to rewrite this class. I know there are a lot of places in JanusGraph where we should rewrite the code but as more we putting complex code the harder it becomes to maintain and extend it.<br>\nIf <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/rngcntr/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/rngcntr\">@rngcntr</a> can rewrite it in this PR, that's great. If cannot, I may later take this PR in made another continuation but I will need to research the logic behind it. I need to understand the purpose behind this logic more.</p>\n<p dir=\"auto\">Basically, what I can see here on first glance:</p>\n<ol dir=\"auto\">\n<li>This is a mix of POJO + some calculation logic. It is better to separate business logic from models.</li>\n<li>It violates Single-responsibility principle not only because it mix of POJO and business logic but because it combines all possible implementations of <code>score</code> calculation inside a single class. In case we have a totally different implementation which might depend on some dependency which neither <code>BruteForce</code> nor <code>Approximation</code> implementations depend on, then we will need to add an unnecessary dependency to those implementations.</li>\n<li>It violates Dependency inversion principle because it depends on concrete <code>subCover</code> and <code>subCondition</code> inside its constructor.</li>\n</ol>", "author": "porunov", "createdAt": "2020-05-13T20:35:24Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidate.java", "diffHunk": "@@ -0,0 +1,170 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.util;\n+\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.core.schema.JanusGraphSchemaType;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.condition.PredicateCondition;\n+import org.janusgraph.graphdb.query.graph.GraphCentricQueryBuilder;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.janusgraph.graphdb.types.MixedIndexType;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class IndexCandidate {", "originalCommit": "805898c704878418a853b44cbd4a651972267581", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "434d25fa5ea74b53aea347f150b2df373983a859", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidate.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\nsimilarity index 62%\nrename from janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidate.java\nrename to janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\nindex 74091ea56..f821ea00a 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidate.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\n", "chunk": "@@ -12,25 +12,15 @@\n // See the License for the specific language governing permissions and\n // limitations under the License.\n \n-package org.janusgraph.graphdb.util;\n+package org.janusgraph.graphdb.query.index;\n \n import org.janusgraph.core.Cardinality;\n-import org.janusgraph.core.JanusGraphElement;\n import org.janusgraph.core.attribute.Cmp;\n-import org.janusgraph.core.schema.JanusGraphSchemaType;\n-import org.janusgraph.graphdb.database.IndexSerializer;\n import org.janusgraph.graphdb.query.condition.Condition;\n-import org.janusgraph.graphdb.query.condition.MultiCondition;\n import org.janusgraph.graphdb.query.condition.PredicateCondition;\n-import org.janusgraph.graphdb.query.graph.GraphCentricQueryBuilder;\n import org.janusgraph.graphdb.types.CompositeIndexType;\n import org.janusgraph.graphdb.types.IndexType;\n-import org.janusgraph.graphdb.types.MixedIndexType;\n-import org.janusgraph.graphdb.types.system.ImplicitKey;\n \n-import java.util.Collection;\n-import java.util.HashSet;\n-import java.util.Map;\n import java.util.Set;\n \n /**\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxNjkzNw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r424716937", "body": "We should not use exceptions for checks. Also, its better to not swallow an exception. How do you know that `IllegalArgumentException` is a valid exception produces by your check an not by other dependant logic?\r\nCurrently these type of exceptions work to skip loop iteration (i.e. replace for `continue` which was used in the previous logic). Using exceptions just to skip loop is a bad practice. I think we should rewrite `IndexCandidate` code and split it to multiple classes", "bodyText": "We should not use exceptions for checks. Also, its better to not swallow an exception. How do you know that IllegalArgumentException is a valid exception produces by your check an not by other dependant logic?\nCurrently these type of exceptions work to skip loop iteration (i.e. replace for continue which was used in the previous logic). Using exceptions just to skip loop is a bad practice. I think we should rewrite IndexCandidate code and split it to multiple classes", "bodyHTML": "<p dir=\"auto\">We should not use exceptions for checks. Also, its better to not swallow an exception. How do you know that <code>IllegalArgumentException</code> is a valid exception produces by your check an not by other dependant logic?<br>\nCurrently these type of exceptions work to skip loop iteration (i.e. replace for <code>continue</code> which was used in the previous logic). Using exceptions just to skip loop is a bad practice. I think we should rewrite <code>IndexCandidate</code> code and split it to multiple classes</p>", "author": "porunov", "createdAt": "2020-05-13T20:38:47Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java", "diffHunk": "@@ -497,5 +407,122 @@ private static boolean coversAll(final MixedIndexType index, Condition<JanusGrap\n         return match != null && indexInfo.supports(index, match, atom.getPredicate());\n     }\n \n+    private JointIndexQuery selectIndices(final Set<IndexType> indexCandidates, final MultiCondition<JanusGraphElement> conditions,\n+                                          final Set<Condition> coveredClauses, final MutableBoolean isSorted) {\n+        /* TODO: smarter optimization:\n+        - use in-memory histograms to estimate selectivity of PredicateConditions and filter out low-selectivity ones\n+                if they would result in an individual index call (better to filter afterwards in memory)\n+        */\n+        if (indexCandidates.size() <= tx.getGraph().getConfiguration().getIndexSelectThreshold()) {\n+            return selectIndicesByBruteForce(indexCandidates, conditions, coveredClauses, isSorted);\n+        } else {\n+            return selectIndicesByApprox(indexCandidates, conditions, coveredClauses, isSorted);\n+        }\n+    }\n+\n+    /**\n+     * Determine the best jointIndexQuery by enumerating all possibilities with exponential time complexity.\n+     * Similar to Weighted Set Cover problem, to find the best choice is NP-Complete, so we should be careful\n+     * that the problem size MUST be small, otherwise it is more recommended to use an approximation algorithm.\n+     *\n+     * @param rawCandidates\n+     * @param conditions\n+     * @param coveredClauses\n+     * @param isSorted\n+     * @return\n+     */\n+    private JointIndexQuery selectIndicesByBruteForce(final Set<IndexType> rawCandidates, final MultiCondition<JanusGraphElement> conditions,\n+                                                      final Set<Condition> coveredClauses, final MutableBoolean isSorted) {\n+        final JointIndexQuery jointQuery = new JointIndexQuery();\n+        final Set<IndexCandidate> indexCandidates = new HashSet<>();\n+\n+        // validate, enrich index candidates and calculate scores\n+        for (final IndexType index : rawCandidates) {\n+            try {\n+                IndexCandidate ic = new IndexCandidate(index, conditions, serializer);\n+                ic.calculateScoreBruteForce();\n+                indexCandidates.add(ic);\n+            } catch (IllegalArgumentException ignored) {\n+                // ignore invalid index candidates\n+            }\n+        }\n+\n+        IndexCandidateGroup bestGroup = null;\n+        for (Set<IndexCandidate> subset : new PowerSet<IndexCandidate>(indexCandidates)) {\n+            if (subset.isEmpty()) continue;\n+            final IndexCandidateGroup group = new IndexCandidateGroup(subset);\n+            if (group.compareTo(bestGroup) > 0) {\n+                bestGroup = group;\n+            }\n+        }\n+\n+        if (bestGroup != null) {\n+            coveredClauses.addAll(bestGroup.getCoveredClauses());\n+            List<IndexCandidate> bestIndexes = new ArrayList<>(bestGroup.getIndexCandidates());\n+            // sort indexes by score descending order\n+            bestIndexes.sort((a, b) -> Double.compare(b.getScore(), a.getScore()));\n+            // isSorted depends on the first index subquery\n+            isSorted.setValue(orders.isEmpty() || bestIndexes.get(0).getIndex().isMixedIndex()\n+                && indexCoversOrder((MixedIndexType) bestIndexes.get(0).getIndex(), orders));\n+            for (IndexCandidate c : bestIndexes) {\n+                addToJointQuery(c, jointQuery);\n+            }\n+        }\n+\n+        return jointQuery;\n+    }\n+\n+    /**\n+     * Iterate over all potential indexes and compute a score based on how many clauses\n+     * this index covers. The index with the highest score (as long as it covers at least one additional clause)\n+     * is picked and added to the joint query for as long as such exist.\n+     * @param rawCandidates\n+     * @param conditions\n+     * @param coveredClauses\n+     * @param isSorted\n+     * @return\n+     */\n+    private JointIndexQuery selectIndicesByApprox(final Set<IndexType> rawCandidates, final MultiCondition<JanusGraphElement> conditions,\n+                                                  final Set<Condition> coveredClauses, final MutableBoolean isSorted) {\n+        final JointIndexQuery jointQuery = new JointIndexQuery();\n+        while (true) {\n+            IndexCandidate bestCandidate = null;\n+            boolean candidateSupportsSort = false;\n+\n+            for (final IndexType index : rawCandidates) {\n+                try {\n+                    final IndexCandidate indexCandidate = new IndexCandidate(index, conditions, serializer);\n+\n+                    boolean supportsSort = orders.isEmpty() ||\n+                        coveredClauses.isEmpty() && index.isMixedIndex() && indexCoversOrder((MixedIndexType) index, orders);\n+                    indexCandidate.calculateScoreApproximation(coveredClauses, supportsSort);\n \n+                    if (!indexCandidate.isCoveredBy(coveredClauses) && (bestCandidate == null || indexCandidate.getScore() > bestCandidate.getScore())) {\n+                        bestCandidate = indexCandidate;\n+                        candidateSupportsSort = supportsSort;\n+                    }\n+                } catch (IllegalArgumentException ignored) {\n+                    // ignore invalid index candidates\n+                }\n+            }", "originalCommit": "805898c704878418a853b44cbd4a651972267581", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "434d25fa5ea74b53aea347f150b2df373983a859", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java\nindex 4707a068c..61fd43222 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java\n", "chunk": "@@ -276,253 +283,10 @@ public class GraphCentricQueryBuilder implements JanusGraphQuery<GraphCentricQue\n             indexLimit = Math.min(HARD_MAX_LIMIT,\n                 QueryUtil.adjustLimitForTxModifications(tx, coveredClauses.size(), indexLimit));\n             query = new BackendQueryHolder<>(jointQuery.updateLimit(indexLimit),\n-                    coveredClauses.size() == conditions.numChildren(), isSorted.getValue());\n+                    coveredClauses.size() == conditions.numChildren(), isSorted);\n         } else {\n-            query = new BackendQueryHolder<>(new JointIndexQuery(), false, isSorted.getValue());\n+            query = new BackendQueryHolder<>(new JointIndexQuery(), false, isSorted);\n         }\n         return new GraphCentricQuery(resultType, conditions, orders, query, limit);\n     }\n-\n-    public static boolean indexCoversOrder(MixedIndexType index, OrderList orders) {\n-        for (int i = 0; i < orders.size(); i++) {\n-            if (!index.indexesKey(orders.getKey(i))) return false;\n-        }\n-        return true;\n-    }\n-\n-    public static List<Object[]> indexCover(final CompositeIndexType index, Condition<JanusGraphElement> condition,\n-                                            Set<Condition> covered) {\n-        if (!QueryUtil.isQueryNormalForm(condition)) {\n-            return null;\n-        }\n-        assert condition instanceof And;\n-        if (index.getStatus()!= SchemaStatus.ENABLED) return null;\n-        final IndexField[] fields = index.getFieldKeys();\n-        final Object[] indexValues = new Object[fields.length];\n-        final Set<Condition> coveredClauses = new HashSet<>(fields.length);\n-        final List<Object[]> indexCovers = new ArrayList<>(4);\n-\n-        constructIndexCover(indexValues,0,fields,condition,indexCovers,coveredClauses);\n-        if (!indexCovers.isEmpty()) {\n-            covered.addAll(coveredClauses);\n-            return indexCovers;\n-        } else return null;\n-    }\n-\n-    private static void constructIndexCover(Object[] indexValues, int position, IndexField[] fields,\n-                                            Condition<JanusGraphElement> condition,\n-                                            List<Object[]> indexCovers, Set<Condition> coveredClauses) {\n-        if (position>=fields.length) {\n-            indexCovers.add(indexValues);\n-        } else {\n-            final IndexField field = fields[position];\n-            final Map.Entry<Condition,Collection<Object>> equalCon = getEqualityConditionValues(condition,field.getFieldKey());\n-            if (equalCon!=null) {\n-                coveredClauses.add(equalCon.getKey());\n-                assert equalCon.getValue().size()>0;\n-                for (final Object value : equalCon.getValue()) {\n-                    final Object[] newValues = Arrays.copyOf(indexValues,fields.length);\n-                    newValues[position]=value;\n-                    constructIndexCover(newValues,position+1,fields,condition,indexCovers,coveredClauses);\n-                }\n-            }\n-        }\n-    }\n-\n-    public static Map.Entry<Condition,Collection<Object>> getEqualityConditionValues(\n-            Condition<JanusGraphElement> condition, RelationType type) {\n-        for (final Condition c : condition.getChildren()) {\n-            if (c instanceof Or) {\n-                final Map.Entry<RelationType,Collection> orEqual = QueryUtil.extractOrCondition((Or)c);\n-                if (orEqual!=null && orEqual.getKey().equals(type) && !orEqual.getValue().isEmpty()) {\n-                    return new AbstractMap.SimpleImmutableEntry(c,orEqual.getValue());\n-                }\n-            } else if (c instanceof PredicateCondition) {\n-                final PredicateCondition<RelationType, JanusGraphRelation> atom = (PredicateCondition)c;\n-                if (atom.getKey().equals(type) && atom.getPredicate()==Cmp.EQUAL && atom.getValue()!=null) {\n-                    return new AbstractMap.SimpleImmutableEntry(c,Collections.singletonList(atom.getValue()));\n-                }\n-            }\n-\n-        }\n-        return null;\n-    }\n-\n-    public static Condition<JanusGraphElement> indexCover(final MixedIndexType index,\n-                                                          Condition<JanusGraphElement> condition,\n-                                                          final IndexSerializer indexInfo,\n-                                                          final Set<Condition> covered) {\n-        if (!indexInfo.features(index).supportNotQueryNormalForm() && !QueryUtil.isQueryNormalForm(condition)) {\n-            return null;\n-        }\n-        if (condition instanceof Or) {\n-            for (final Condition<JanusGraphElement> subClause : condition.getChildren()) {\n-                if (subClause instanceof And) {\n-                    for (final Condition<JanusGraphElement> subsubClause : condition.getChildren()) {\n-                        if (!coversAll(index, subsubClause,indexInfo)) {\n-                            return null;\n-                        }\n-                    }\n-                } else {\n-                    if (!coversAll(index, subClause, indexInfo)) {\n-                        return null;\n-                    }\n-                }\n-            }\n-            covered.add(condition);\n-            return condition;\n-        }\n-        assert condition instanceof And;\n-        final And<JanusGraphElement> subCondition = new And<>(condition.numChildren());\n-        for (final Condition<JanusGraphElement> subClause : condition.getChildren()) {\n-            if (coversAll(index,subClause,indexInfo)) {\n-                subCondition.add(subClause);\n-                covered.add(subClause);\n-            }\n-        }\n-        return subCondition.isEmpty()?null:subCondition;\n-    }\n-\n-    private static boolean coversAll(final MixedIndexType index, Condition<JanusGraphElement> condition,\n-                                     IndexSerializer indexInfo) {\n-        if (condition.getType()!=Condition.Type.LITERAL) {\n-            return StreamSupport.stream(condition.getChildren().spliterator(), false)\n-                .allMatch(child -> coversAll(index, child, indexInfo));\n-        }\n-        if (!(condition instanceof PredicateCondition)) {\n-            return false;\n-        }\n-        final PredicateCondition<RelationType, JanusGraphElement> atom = (PredicateCondition) condition;\n-        if (atom.getValue() == null) {\n-            return false;\n-        }\n-\n-        Preconditions.checkArgument(atom.getKey().isPropertyKey());\n-        final PropertyKey key = (PropertyKey) atom.getKey();\n-        final ParameterIndexField[] fields = index.getFieldKeys();\n-        final ParameterIndexField match = Arrays.stream(fields)\n-            .filter(field -> field.getStatus() == SchemaStatus.ENABLED)\n-            .filter(field -> field.getFieldKey().equals(key))\n-            .findAny().orElse(null);\n-        return match != null && indexInfo.supports(index, match, atom.getPredicate());\n-    }\n-\n-    private JointIndexQuery selectIndices(final Set<IndexType> indexCandidates, final MultiCondition<JanusGraphElement> conditions,\n-                                          final Set<Condition> coveredClauses, final MutableBoolean isSorted) {\n-        /* TODO: smarter optimization:\n-        - use in-memory histograms to estimate selectivity of PredicateConditions and filter out low-selectivity ones\n-                if they would result in an individual index call (better to filter afterwards in memory)\n-        */\n-        if (indexCandidates.size() <= tx.getGraph().getConfiguration().getIndexSelectThreshold()) {\n-            return selectIndicesByBruteForce(indexCandidates, conditions, coveredClauses, isSorted);\n-        } else {\n-            return selectIndicesByApprox(indexCandidates, conditions, coveredClauses, isSorted);\n-        }\n-    }\n-\n-    /**\n-     * Determine the best jointIndexQuery by enumerating all possibilities with exponential time complexity.\n-     * Similar to Weighted Set Cover problem, to find the best choice is NP-Complete, so we should be careful\n-     * that the problem size MUST be small, otherwise it is more recommended to use an approximation algorithm.\n-     *\n-     * @param rawCandidates\n-     * @param conditions\n-     * @param coveredClauses\n-     * @param isSorted\n-     * @return\n-     */\n-    private JointIndexQuery selectIndicesByBruteForce(final Set<IndexType> rawCandidates, final MultiCondition<JanusGraphElement> conditions,\n-                                                      final Set<Condition> coveredClauses, final MutableBoolean isSorted) {\n-        final JointIndexQuery jointQuery = new JointIndexQuery();\n-        final Set<IndexCandidate> indexCandidates = new HashSet<>();\n-\n-        // validate, enrich index candidates and calculate scores\n-        for (final IndexType index : rawCandidates) {\n-            try {\n-                IndexCandidate ic = new IndexCandidate(index, conditions, serializer);\n-                ic.calculateScoreBruteForce();\n-                indexCandidates.add(ic);\n-            } catch (IllegalArgumentException ignored) {\n-                // ignore invalid index candidates\n-            }\n-        }\n-\n-        IndexCandidateGroup bestGroup = null;\n-        for (Set<IndexCandidate> subset : new PowerSet<IndexCandidate>(indexCandidates)) {\n-            if (subset.isEmpty()) continue;\n-            final IndexCandidateGroup group = new IndexCandidateGroup(subset);\n-            if (group.compareTo(bestGroup) > 0) {\n-                bestGroup = group;\n-            }\n-        }\n-\n-        if (bestGroup != null) {\n-            coveredClauses.addAll(bestGroup.getCoveredClauses());\n-            List<IndexCandidate> bestIndexes = new ArrayList<>(bestGroup.getIndexCandidates());\n-            // sort indexes by score descending order\n-            bestIndexes.sort((a, b) -> Double.compare(b.getScore(), a.getScore()));\n-            // isSorted depends on the first index subquery\n-            isSorted.setValue(orders.isEmpty() || bestIndexes.get(0).getIndex().isMixedIndex()\n-                && indexCoversOrder((MixedIndexType) bestIndexes.get(0).getIndex(), orders));\n-            for (IndexCandidate c : bestIndexes) {\n-                addToJointQuery(c, jointQuery);\n-            }\n-        }\n-\n-        return jointQuery;\n-    }\n-\n-    /**\n-     * Iterate over all potential indexes and compute a score based on how many clauses\n-     * this index covers. The index with the highest score (as long as it covers at least one additional clause)\n-     * is picked and added to the joint query for as long as such exist.\n-     * @param rawCandidates\n-     * @param conditions\n-     * @param coveredClauses\n-     * @param isSorted\n-     * @return\n-     */\n-    private JointIndexQuery selectIndicesByApprox(final Set<IndexType> rawCandidates, final MultiCondition<JanusGraphElement> conditions,\n-                                                  final Set<Condition> coveredClauses, final MutableBoolean isSorted) {\n-        final JointIndexQuery jointQuery = new JointIndexQuery();\n-        while (true) {\n-            IndexCandidate bestCandidate = null;\n-            boolean candidateSupportsSort = false;\n-\n-            for (final IndexType index : rawCandidates) {\n-                try {\n-                    final IndexCandidate indexCandidate = new IndexCandidate(index, conditions, serializer);\n-\n-                    boolean supportsSort = orders.isEmpty() ||\n-                        coveredClauses.isEmpty() && index.isMixedIndex() && indexCoversOrder((MixedIndexType) index, orders);\n-                    indexCandidate.calculateScoreApproximation(coveredClauses, supportsSort);\n-\n-                    if (!indexCandidate.isCoveredBy(coveredClauses) && (bestCandidate == null || indexCandidate.getScore() > bestCandidate.getScore())) {\n-                        bestCandidate = indexCandidate;\n-                        candidateSupportsSort = supportsSort;\n-                    }\n-                } catch (IllegalArgumentException ignored) {\n-                    // ignore invalid index candidates\n-                }\n-            }\n-            if (bestCandidate!=null) {\n-                if (coveredClauses.isEmpty()) isSorted.setValue(candidateSupportsSort);\n-                coveredClauses.addAll(bestCandidate.getSubCover());\n-                addToJointQuery(bestCandidate, jointQuery);\n-            } else {\n-                break;\n-            }\n-        }\n-        return jointQuery;\n-    }\n-\n-    private void addToJointQuery(final IndexCandidate indexCandidate, final JointIndexQuery jointQuery) {\n-        if (indexCandidate.getIndex().isCompositeIndex()) {\n-            jointQuery.add((CompositeIndexType) indexCandidate.getIndex(), serializer.getQuery(\n-                (CompositeIndexType) indexCandidate.getIndex(), (List<Object[]>) indexCandidate.getSubCondition()));\n-        } else {\n-            jointQuery.add((MixedIndexType) indexCandidate.getIndex(), serializer.getQuery(\n-                (MixedIndexType) indexCandidate.getIndex(), (Condition) indexCandidate.getSubCondition(), orders));\n-        }\n-    }\n }\n", "next_change": {"commit": "66304b76615d6af481324508dcefc0844d0ddd65", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java\nindex 61fd43222..a16937904 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java\n", "chunk": "@@ -282,10 +280,10 @@ public class GraphCentricQueryBuilder implements JanusGraphQuery<GraphCentricQue\n             }\n             indexLimit = Math.min(HARD_MAX_LIMIT,\n                 QueryUtil.adjustLimitForTxModifications(tx, coveredClauses.size(), indexLimit));\n-            query = new BackendQueryHolder<>(jointQuery.updateLimit(indexLimit),\n-                    coveredClauses.size() == conditions.numChildren(), isSorted);\n+            query = new BackendQueryHolder<>(selectedIndex.getQuery().updateLimit(indexLimit),\n+                    coveredClauses.size() == conditions.numChildren(), selectedIndex.isSorted());\n         } else {\n-            query = new BackendQueryHolder<>(new JointIndexQuery(), false, isSorted);\n+            query = new BackendQueryHolder<>(new JointIndexQuery(), false, selectedIndex.isSorted());\n         }\n         return new GraphCentricQuery(resultType, conditions, orders, query, limit);\n     }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcyNzE5OQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r424727199", "body": "`isSorted` passed into `selectIndices` just to fill it with some value. It isn't obvious because it is basically used as a return value and not input value.\r\nIt is better to explicitly return result. We can just create another class with `JointIndexQuery jointQuery` and `boolean isSorted` and return that result from `selectIndices` method instead of partially returning result as a return value and partially change input value.", "bodyText": "isSorted passed into selectIndices just to fill it with some value. It isn't obvious because it is basically used as a return value and not input value.\nIt is better to explicitly return result. We can just create another class with JointIndexQuery jointQuery and boolean isSorted and return that result from selectIndices method instead of partially returning result as a return value and partially change input value.", "bodyHTML": "<p dir=\"auto\"><code>isSorted</code> passed into <code>selectIndices</code> just to fill it with some value. It isn't obvious because it is basically used as a return value and not input value.<br>\nIt is better to explicitly return result. We can just create another class with <code>JointIndexQuery jointQuery</code> and <code>boolean isSorted</code> and return that result from <code>selectIndices</code> method instead of partially returning result as a return value and partially change input value.</p>", "author": "porunov", "createdAt": "2020-05-13T20:58:37Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java", "diffHunk": "@@ -270,92 +263,9 @@ public GraphCentricQuery constructQueryWithoutProfile(final ElementCategory resu\n             return true;\n         });\n \n-        /*\n-        Determine the best join index query to answer this query:\n-        Iterate over all potential indexes (as compiled above) and compute a score based on how many clauses\n-        this index covers. The index with the highest score (as long as it covers at least one additional clause)\n-        is picked and added to the joint query for as long as such exist.\n-         */\n-        final JointIndexQuery jointQuery = new JointIndexQuery();\n-        boolean isSorted = orders.isEmpty();\n         final Set<Condition> coveredClauses = new HashSet<>();\n-        while (true) {\n-            IndexType bestCandidate = null;\n-            double candidateScore = 0.0;\n-            Set<Condition> candidateSubcover = null;\n-            boolean candidateSupportsSort = false;\n-            Object candidateSubCondition = null;\n-\n-            for (final IndexType index : indexCandidates) {\n-                final Set<Condition> subcover = new HashSet<>();\n-                Object subCondition;\n-                boolean supportsSort = orders.isEmpty();\n-                //Check that this index actually applies in case of a schema constraint\n-                if (index.hasSchemaTypeConstraint()) {\n-                    final JanusGraphSchemaType type = index.getSchemaTypeConstraint();\n-                    final Map.Entry<Condition,Collection<Object>> equalCon\n-                            = getEqualityConditionValues(conditions,ImplicitKey.LABEL);\n-                    if (equalCon==null) continue;\n-                    final Collection<Object> labels = equalCon.getValue();\n-                    assert labels.size() >= 1;\n-                    if (labels.size()>1) {\n-                        log.warn(\"The query optimizer currently does not support multiple label constraints in query: {}\",this);\n-                        continue;\n-                    }\n-                    if (!type.name().equals(Iterables.getOnlyElement(labels))) {\n-                        continue;\n-                    }\n-                    subcover.add(equalCon.getKey());\n-                }\n-\n-                if (index.isCompositeIndex()) {\n-                    subCondition = indexCover((CompositeIndexType) index,conditions,subcover);\n-                } else {\n-                    subCondition = indexCover((MixedIndexType) index,conditions,serializer,subcover);\n-                    if (coveredClauses.isEmpty() && !supportsSort\n-                            && indexCoversOrder((MixedIndexType)index,orders)) supportsSort=true;\n-                }\n-                if (subCondition==null || subcover.isEmpty()) continue;\n-                double score = 0.0;\n-                boolean coversAdditionalClause = false;\n-                for (final Condition c : subcover) {\n-                    double s = (c instanceof PredicateCondition && ((PredicateCondition)c).getPredicate()==Cmp.EQUAL)?\n-                            EQUAL_CONDITION_SCORE:OTHER_CONDITION_SCORE;\n-                    if (coveredClauses.contains(c)) s=s*ALREADY_MATCHED_ADJUSTOR;\n-                    else coversAdditionalClause = true;\n-                    score+=s;\n-                    if (index.isCompositeIndex())\n-                        score+=((CompositeIndexType)index).getCardinality()==Cardinality.SINGLE?\n-                                CARDINALITY_SINGE_SCORE:CARDINALITY_OTHER_SCORE;\n-                }\n-                if (supportsSort) score+=ORDER_MATCH;\n-                if (coversAdditionalClause && score>candidateScore) {\n-                    candidateScore=score;\n-                    bestCandidate=index;\n-                    candidateSubcover = subcover;\n-                    candidateSubCondition = subCondition;\n-                    candidateSupportsSort = supportsSort;\n-                }\n-            }\n-            if (bestCandidate!=null) {\n-                if (coveredClauses.isEmpty()) isSorted=candidateSupportsSort;\n-                coveredClauses.addAll(candidateSubcover);\n-                if (bestCandidate.isCompositeIndex()) {\n-                    jointQuery.add((CompositeIndexType)bestCandidate,\n-                            serializer.getQuery((CompositeIndexType)bestCandidate,(List<Object[]>)candidateSubCondition));\n-                } else {\n-                    jointQuery.add((MixedIndexType)bestCandidate,\n-                            serializer.getQuery((MixedIndexType)bestCandidate,(Condition)candidateSubCondition,orders));\n-                }\n-            } else {\n-                break;\n-            }\n-            /* TODO: smarter optimization:\n-            - use in-memory histograms to estimate selectivity of PredicateConditions and filter out low-selectivity ones\n-                    if they would result in an individual index call (better to filter afterwards in memory)\n-            - move OR's up and extend GraphCentricQuery to allow multiple JointIndexQuery for proper or'ing of queries\n-            */\n-        }\n+        final MutableBoolean isSorted = new MutableBoolean(orders.isEmpty());\n+        final JointIndexQuery jointQuery = selectIndices(indexCandidates, conditions, coveredClauses, isSorted);", "originalCommit": "805898c704878418a853b44cbd4a651972267581", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "434d25fa5ea74b53aea347f150b2df373983a859", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java\nindex 4707a068c..61fd43222 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java\n", "chunk": "@@ -264,8 +270,9 @@ public class GraphCentricQueryBuilder implements JanusGraphQuery<GraphCentricQue\n         });\n \n         final Set<Condition> coveredClauses = new HashSet<>();\n-        final MutableBoolean isSorted = new MutableBoolean(orders.isEmpty());\n-        final JointIndexQuery jointQuery = selectIndices(indexCandidates, conditions, coveredClauses, isSorted);\n+        final Pair<JointIndexQuery, Boolean> selectedIndex = indexSelector.selectIndices(indexCandidates, conditions, coveredClauses, orders, serializer);\n+        final JointIndexQuery jointQuery = selectedIndex.getValue0();\n+        boolean isSorted = selectedIndex.getValue1().booleanValue();\n \n         BackendQueryHolder<JointIndexQuery> query;\n         if (!coveredClauses.isEmpty()) {\n", "next_change": {"commit": "66304b76615d6af481324508dcefc0844d0ddd65", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java\nindex 61fd43222..a16937904 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java\n", "chunk": "@@ -270,9 +270,7 @@ public class GraphCentricQueryBuilder implements JanusGraphQuery<GraphCentricQue\n         });\n \n         final Set<Condition> coveredClauses = new HashSet<>();\n-        final Pair<JointIndexQuery, Boolean> selectedIndex = indexSelector.selectIndices(indexCandidates, conditions, coveredClauses, orders, serializer);\n-        final JointIndexQuery jointQuery = selectedIndex.getValue0();\n-        boolean isSorted = selectedIndex.getValue1().booleanValue();\n+        final IndexSelectionStrategy.SelectedIndexQuery selectedIndex = indexSelector.selectIndices(indexCandidates, conditions, coveredClauses, orders, serializer);\n \n         BackendQueryHolder<JointIndexQuery> query;\n         if (!coveredClauses.isEmpty()) {\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcyODQ5Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r424728493", "body": "I would suggest to move `selectIndices` method into a separate class. Something like `IndexSelectionService`", "bodyText": "I would suggest to move selectIndices method into a separate class. Something like IndexSelectionService", "bodyHTML": "<p dir=\"auto\">I would suggest to move <code>selectIndices</code> method into a separate class. Something like <code>IndexSelectionService</code></p>", "author": "porunov", "createdAt": "2020-05-13T21:01:15Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java", "diffHunk": "@@ -497,5 +407,122 @@ private static boolean coversAll(final MixedIndexType index, Condition<JanusGrap\n         return match != null && indexInfo.supports(index, match, atom.getPredicate());\n     }\n \n+    private JointIndexQuery selectIndices(final Set<IndexType> indexCandidates, final MultiCondition<JanusGraphElement> conditions,", "originalCommit": "805898c704878418a853b44cbd4a651972267581", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "434d25fa5ea74b53aea347f150b2df373983a859", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java\nindex 4707a068c..61fd43222 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java\n", "chunk": "@@ -276,253 +283,10 @@ public class GraphCentricQueryBuilder implements JanusGraphQuery<GraphCentricQue\n             indexLimit = Math.min(HARD_MAX_LIMIT,\n                 QueryUtil.adjustLimitForTxModifications(tx, coveredClauses.size(), indexLimit));\n             query = new BackendQueryHolder<>(jointQuery.updateLimit(indexLimit),\n-                    coveredClauses.size() == conditions.numChildren(), isSorted.getValue());\n+                    coveredClauses.size() == conditions.numChildren(), isSorted);\n         } else {\n-            query = new BackendQueryHolder<>(new JointIndexQuery(), false, isSorted.getValue());\n+            query = new BackendQueryHolder<>(new JointIndexQuery(), false, isSorted);\n         }\n         return new GraphCentricQuery(resultType, conditions, orders, query, limit);\n     }\n-\n-    public static boolean indexCoversOrder(MixedIndexType index, OrderList orders) {\n-        for (int i = 0; i < orders.size(); i++) {\n-            if (!index.indexesKey(orders.getKey(i))) return false;\n-        }\n-        return true;\n-    }\n-\n-    public static List<Object[]> indexCover(final CompositeIndexType index, Condition<JanusGraphElement> condition,\n-                                            Set<Condition> covered) {\n-        if (!QueryUtil.isQueryNormalForm(condition)) {\n-            return null;\n-        }\n-        assert condition instanceof And;\n-        if (index.getStatus()!= SchemaStatus.ENABLED) return null;\n-        final IndexField[] fields = index.getFieldKeys();\n-        final Object[] indexValues = new Object[fields.length];\n-        final Set<Condition> coveredClauses = new HashSet<>(fields.length);\n-        final List<Object[]> indexCovers = new ArrayList<>(4);\n-\n-        constructIndexCover(indexValues,0,fields,condition,indexCovers,coveredClauses);\n-        if (!indexCovers.isEmpty()) {\n-            covered.addAll(coveredClauses);\n-            return indexCovers;\n-        } else return null;\n-    }\n-\n-    private static void constructIndexCover(Object[] indexValues, int position, IndexField[] fields,\n-                                            Condition<JanusGraphElement> condition,\n-                                            List<Object[]> indexCovers, Set<Condition> coveredClauses) {\n-        if (position>=fields.length) {\n-            indexCovers.add(indexValues);\n-        } else {\n-            final IndexField field = fields[position];\n-            final Map.Entry<Condition,Collection<Object>> equalCon = getEqualityConditionValues(condition,field.getFieldKey());\n-            if (equalCon!=null) {\n-                coveredClauses.add(equalCon.getKey());\n-                assert equalCon.getValue().size()>0;\n-                for (final Object value : equalCon.getValue()) {\n-                    final Object[] newValues = Arrays.copyOf(indexValues,fields.length);\n-                    newValues[position]=value;\n-                    constructIndexCover(newValues,position+1,fields,condition,indexCovers,coveredClauses);\n-                }\n-            }\n-        }\n-    }\n-\n-    public static Map.Entry<Condition,Collection<Object>> getEqualityConditionValues(\n-            Condition<JanusGraphElement> condition, RelationType type) {\n-        for (final Condition c : condition.getChildren()) {\n-            if (c instanceof Or) {\n-                final Map.Entry<RelationType,Collection> orEqual = QueryUtil.extractOrCondition((Or)c);\n-                if (orEqual!=null && orEqual.getKey().equals(type) && !orEqual.getValue().isEmpty()) {\n-                    return new AbstractMap.SimpleImmutableEntry(c,orEqual.getValue());\n-                }\n-            } else if (c instanceof PredicateCondition) {\n-                final PredicateCondition<RelationType, JanusGraphRelation> atom = (PredicateCondition)c;\n-                if (atom.getKey().equals(type) && atom.getPredicate()==Cmp.EQUAL && atom.getValue()!=null) {\n-                    return new AbstractMap.SimpleImmutableEntry(c,Collections.singletonList(atom.getValue()));\n-                }\n-            }\n-\n-        }\n-        return null;\n-    }\n-\n-    public static Condition<JanusGraphElement> indexCover(final MixedIndexType index,\n-                                                          Condition<JanusGraphElement> condition,\n-                                                          final IndexSerializer indexInfo,\n-                                                          final Set<Condition> covered) {\n-        if (!indexInfo.features(index).supportNotQueryNormalForm() && !QueryUtil.isQueryNormalForm(condition)) {\n-            return null;\n-        }\n-        if (condition instanceof Or) {\n-            for (final Condition<JanusGraphElement> subClause : condition.getChildren()) {\n-                if (subClause instanceof And) {\n-                    for (final Condition<JanusGraphElement> subsubClause : condition.getChildren()) {\n-                        if (!coversAll(index, subsubClause,indexInfo)) {\n-                            return null;\n-                        }\n-                    }\n-                } else {\n-                    if (!coversAll(index, subClause, indexInfo)) {\n-                        return null;\n-                    }\n-                }\n-            }\n-            covered.add(condition);\n-            return condition;\n-        }\n-        assert condition instanceof And;\n-        final And<JanusGraphElement> subCondition = new And<>(condition.numChildren());\n-        for (final Condition<JanusGraphElement> subClause : condition.getChildren()) {\n-            if (coversAll(index,subClause,indexInfo)) {\n-                subCondition.add(subClause);\n-                covered.add(subClause);\n-            }\n-        }\n-        return subCondition.isEmpty()?null:subCondition;\n-    }\n-\n-    private static boolean coversAll(final MixedIndexType index, Condition<JanusGraphElement> condition,\n-                                     IndexSerializer indexInfo) {\n-        if (condition.getType()!=Condition.Type.LITERAL) {\n-            return StreamSupport.stream(condition.getChildren().spliterator(), false)\n-                .allMatch(child -> coversAll(index, child, indexInfo));\n-        }\n-        if (!(condition instanceof PredicateCondition)) {\n-            return false;\n-        }\n-        final PredicateCondition<RelationType, JanusGraphElement> atom = (PredicateCondition) condition;\n-        if (atom.getValue() == null) {\n-            return false;\n-        }\n-\n-        Preconditions.checkArgument(atom.getKey().isPropertyKey());\n-        final PropertyKey key = (PropertyKey) atom.getKey();\n-        final ParameterIndexField[] fields = index.getFieldKeys();\n-        final ParameterIndexField match = Arrays.stream(fields)\n-            .filter(field -> field.getStatus() == SchemaStatus.ENABLED)\n-            .filter(field -> field.getFieldKey().equals(key))\n-            .findAny().orElse(null);\n-        return match != null && indexInfo.supports(index, match, atom.getPredicate());\n-    }\n-\n-    private JointIndexQuery selectIndices(final Set<IndexType> indexCandidates, final MultiCondition<JanusGraphElement> conditions,\n-                                          final Set<Condition> coveredClauses, final MutableBoolean isSorted) {\n-        /* TODO: smarter optimization:\n-        - use in-memory histograms to estimate selectivity of PredicateConditions and filter out low-selectivity ones\n-                if they would result in an individual index call (better to filter afterwards in memory)\n-        */\n-        if (indexCandidates.size() <= tx.getGraph().getConfiguration().getIndexSelectThreshold()) {\n-            return selectIndicesByBruteForce(indexCandidates, conditions, coveredClauses, isSorted);\n-        } else {\n-            return selectIndicesByApprox(indexCandidates, conditions, coveredClauses, isSorted);\n-        }\n-    }\n-\n-    /**\n-     * Determine the best jointIndexQuery by enumerating all possibilities with exponential time complexity.\n-     * Similar to Weighted Set Cover problem, to find the best choice is NP-Complete, so we should be careful\n-     * that the problem size MUST be small, otherwise it is more recommended to use an approximation algorithm.\n-     *\n-     * @param rawCandidates\n-     * @param conditions\n-     * @param coveredClauses\n-     * @param isSorted\n-     * @return\n-     */\n-    private JointIndexQuery selectIndicesByBruteForce(final Set<IndexType> rawCandidates, final MultiCondition<JanusGraphElement> conditions,\n-                                                      final Set<Condition> coveredClauses, final MutableBoolean isSorted) {\n-        final JointIndexQuery jointQuery = new JointIndexQuery();\n-        final Set<IndexCandidate> indexCandidates = new HashSet<>();\n-\n-        // validate, enrich index candidates and calculate scores\n-        for (final IndexType index : rawCandidates) {\n-            try {\n-                IndexCandidate ic = new IndexCandidate(index, conditions, serializer);\n-                ic.calculateScoreBruteForce();\n-                indexCandidates.add(ic);\n-            } catch (IllegalArgumentException ignored) {\n-                // ignore invalid index candidates\n-            }\n-        }\n-\n-        IndexCandidateGroup bestGroup = null;\n-        for (Set<IndexCandidate> subset : new PowerSet<IndexCandidate>(indexCandidates)) {\n-            if (subset.isEmpty()) continue;\n-            final IndexCandidateGroup group = new IndexCandidateGroup(subset);\n-            if (group.compareTo(bestGroup) > 0) {\n-                bestGroup = group;\n-            }\n-        }\n-\n-        if (bestGroup != null) {\n-            coveredClauses.addAll(bestGroup.getCoveredClauses());\n-            List<IndexCandidate> bestIndexes = new ArrayList<>(bestGroup.getIndexCandidates());\n-            // sort indexes by score descending order\n-            bestIndexes.sort((a, b) -> Double.compare(b.getScore(), a.getScore()));\n-            // isSorted depends on the first index subquery\n-            isSorted.setValue(orders.isEmpty() || bestIndexes.get(0).getIndex().isMixedIndex()\n-                && indexCoversOrder((MixedIndexType) bestIndexes.get(0).getIndex(), orders));\n-            for (IndexCandidate c : bestIndexes) {\n-                addToJointQuery(c, jointQuery);\n-            }\n-        }\n-\n-        return jointQuery;\n-    }\n-\n-    /**\n-     * Iterate over all potential indexes and compute a score based on how many clauses\n-     * this index covers. The index with the highest score (as long as it covers at least one additional clause)\n-     * is picked and added to the joint query for as long as such exist.\n-     * @param rawCandidates\n-     * @param conditions\n-     * @param coveredClauses\n-     * @param isSorted\n-     * @return\n-     */\n-    private JointIndexQuery selectIndicesByApprox(final Set<IndexType> rawCandidates, final MultiCondition<JanusGraphElement> conditions,\n-                                                  final Set<Condition> coveredClauses, final MutableBoolean isSorted) {\n-        final JointIndexQuery jointQuery = new JointIndexQuery();\n-        while (true) {\n-            IndexCandidate bestCandidate = null;\n-            boolean candidateSupportsSort = false;\n-\n-            for (final IndexType index : rawCandidates) {\n-                try {\n-                    final IndexCandidate indexCandidate = new IndexCandidate(index, conditions, serializer);\n-\n-                    boolean supportsSort = orders.isEmpty() ||\n-                        coveredClauses.isEmpty() && index.isMixedIndex() && indexCoversOrder((MixedIndexType) index, orders);\n-                    indexCandidate.calculateScoreApproximation(coveredClauses, supportsSort);\n-\n-                    if (!indexCandidate.isCoveredBy(coveredClauses) && (bestCandidate == null || indexCandidate.getScore() > bestCandidate.getScore())) {\n-                        bestCandidate = indexCandidate;\n-                        candidateSupportsSort = supportsSort;\n-                    }\n-                } catch (IllegalArgumentException ignored) {\n-                    // ignore invalid index candidates\n-                }\n-            }\n-            if (bestCandidate!=null) {\n-                if (coveredClauses.isEmpty()) isSorted.setValue(candidateSupportsSort);\n-                coveredClauses.addAll(bestCandidate.getSubCover());\n-                addToJointQuery(bestCandidate, jointQuery);\n-            } else {\n-                break;\n-            }\n-        }\n-        return jointQuery;\n-    }\n-\n-    private void addToJointQuery(final IndexCandidate indexCandidate, final JointIndexQuery jointQuery) {\n-        if (indexCandidate.getIndex().isCompositeIndex()) {\n-            jointQuery.add((CompositeIndexType) indexCandidate.getIndex(), serializer.getQuery(\n-                (CompositeIndexType) indexCandidate.getIndex(), (List<Object[]>) indexCandidate.getSubCondition()));\n-        } else {\n-            jointQuery.add((MixedIndexType) indexCandidate.getIndex(), serializer.getQuery(\n-                (MixedIndexType) indexCandidate.getIndex(), (Condition) indexCandidate.getSubCondition(), orders));\n-        }\n-    }\n }\n", "next_change": {"commit": "66304b76615d6af481324508dcefc0844d0ddd65", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java\nindex 61fd43222..a16937904 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java\n", "chunk": "@@ -282,10 +280,10 @@ public class GraphCentricQueryBuilder implements JanusGraphQuery<GraphCentricQue\n             }\n             indexLimit = Math.min(HARD_MAX_LIMIT,\n                 QueryUtil.adjustLimitForTxModifications(tx, coveredClauses.size(), indexLimit));\n-            query = new BackendQueryHolder<>(jointQuery.updateLimit(indexLimit),\n-                    coveredClauses.size() == conditions.numChildren(), isSorted);\n+            query = new BackendQueryHolder<>(selectedIndex.getQuery().updateLimit(indexLimit),\n+                    coveredClauses.size() == conditions.numChildren(), selectedIndex.isSorted());\n         } else {\n-            query = new BackendQueryHolder<>(new JointIndexQuery(), false, isSorted);\n+            query = new BackendQueryHolder<>(new JointIndexQuery(), false, selectedIndex.isSorted());\n         }\n         return new GraphCentricQuery(resultType, conditions, orders, query, limit);\n     }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcyOTg1NQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r424729855", "body": "I would suggest to move `selectIndicesByBruteForce` and `selectIndicesByApprox` to separate classes. As for me they are strategies. So I would move them to `BruteForceIndexSelectionStrategy` and `ApproximationIndexSelectionStrategy`.", "bodyText": "I would suggest to move selectIndicesByBruteForce and selectIndicesByApprox to separate classes. As for me they are strategies. So I would move them to BruteForceIndexSelectionStrategy and ApproximationIndexSelectionStrategy.", "bodyHTML": "<p dir=\"auto\">I would suggest to move <code>selectIndicesByBruteForce</code> and <code>selectIndicesByApprox</code> to separate classes. As for me they are strategies. So I would move them to <code>BruteForceIndexSelectionStrategy</code> and <code>ApproximationIndexSelectionStrategy</code>.</p>", "author": "porunov", "createdAt": "2020-05-13T21:04:00Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java", "diffHunk": "@@ -497,5 +407,122 @@ private static boolean coversAll(final MixedIndexType index, Condition<JanusGrap\n         return match != null && indexInfo.supports(index, match, atom.getPredicate());\n     }\n \n+    private JointIndexQuery selectIndices(final Set<IndexType> indexCandidates, final MultiCondition<JanusGraphElement> conditions,\n+                                          final Set<Condition> coveredClauses, final MutableBoolean isSorted) {\n+        /* TODO: smarter optimization:\n+        - use in-memory histograms to estimate selectivity of PredicateConditions and filter out low-selectivity ones\n+                if they would result in an individual index call (better to filter afterwards in memory)\n+        */\n+        if (indexCandidates.size() <= tx.getGraph().getConfiguration().getIndexSelectThreshold()) {\n+            return selectIndicesByBruteForce(indexCandidates, conditions, coveredClauses, isSorted);\n+        } else {\n+            return selectIndicesByApprox(indexCandidates, conditions, coveredClauses, isSorted);\n+        }", "originalCommit": "805898c704878418a853b44cbd4a651972267581", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYxNDIyMw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r425614223", "bodyText": "I'm currently working on this approach but it looks like this requires moving more code than expected from the GraphCentricQueryBuilder to the strategy classes. I'll push a draft later today so you can at least have a look at what I mean.", "author": "rngcntr", "createdAt": "2020-05-15T07:23:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcyOTg1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "434d25fa5ea74b53aea347f150b2df373983a859", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java\nindex 4707a068c..61fd43222 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java\n", "chunk": "@@ -276,253 +283,10 @@ public class GraphCentricQueryBuilder implements JanusGraphQuery<GraphCentricQue\n             indexLimit = Math.min(HARD_MAX_LIMIT,\n                 QueryUtil.adjustLimitForTxModifications(tx, coveredClauses.size(), indexLimit));\n             query = new BackendQueryHolder<>(jointQuery.updateLimit(indexLimit),\n-                    coveredClauses.size() == conditions.numChildren(), isSorted.getValue());\n+                    coveredClauses.size() == conditions.numChildren(), isSorted);\n         } else {\n-            query = new BackendQueryHolder<>(new JointIndexQuery(), false, isSorted.getValue());\n+            query = new BackendQueryHolder<>(new JointIndexQuery(), false, isSorted);\n         }\n         return new GraphCentricQuery(resultType, conditions, orders, query, limit);\n     }\n-\n-    public static boolean indexCoversOrder(MixedIndexType index, OrderList orders) {\n-        for (int i = 0; i < orders.size(); i++) {\n-            if (!index.indexesKey(orders.getKey(i))) return false;\n-        }\n-        return true;\n-    }\n-\n-    public static List<Object[]> indexCover(final CompositeIndexType index, Condition<JanusGraphElement> condition,\n-                                            Set<Condition> covered) {\n-        if (!QueryUtil.isQueryNormalForm(condition)) {\n-            return null;\n-        }\n-        assert condition instanceof And;\n-        if (index.getStatus()!= SchemaStatus.ENABLED) return null;\n-        final IndexField[] fields = index.getFieldKeys();\n-        final Object[] indexValues = new Object[fields.length];\n-        final Set<Condition> coveredClauses = new HashSet<>(fields.length);\n-        final List<Object[]> indexCovers = new ArrayList<>(4);\n-\n-        constructIndexCover(indexValues,0,fields,condition,indexCovers,coveredClauses);\n-        if (!indexCovers.isEmpty()) {\n-            covered.addAll(coveredClauses);\n-            return indexCovers;\n-        } else return null;\n-    }\n-\n-    private static void constructIndexCover(Object[] indexValues, int position, IndexField[] fields,\n-                                            Condition<JanusGraphElement> condition,\n-                                            List<Object[]> indexCovers, Set<Condition> coveredClauses) {\n-        if (position>=fields.length) {\n-            indexCovers.add(indexValues);\n-        } else {\n-            final IndexField field = fields[position];\n-            final Map.Entry<Condition,Collection<Object>> equalCon = getEqualityConditionValues(condition,field.getFieldKey());\n-            if (equalCon!=null) {\n-                coveredClauses.add(equalCon.getKey());\n-                assert equalCon.getValue().size()>0;\n-                for (final Object value : equalCon.getValue()) {\n-                    final Object[] newValues = Arrays.copyOf(indexValues,fields.length);\n-                    newValues[position]=value;\n-                    constructIndexCover(newValues,position+1,fields,condition,indexCovers,coveredClauses);\n-                }\n-            }\n-        }\n-    }\n-\n-    public static Map.Entry<Condition,Collection<Object>> getEqualityConditionValues(\n-            Condition<JanusGraphElement> condition, RelationType type) {\n-        for (final Condition c : condition.getChildren()) {\n-            if (c instanceof Or) {\n-                final Map.Entry<RelationType,Collection> orEqual = QueryUtil.extractOrCondition((Or)c);\n-                if (orEqual!=null && orEqual.getKey().equals(type) && !orEqual.getValue().isEmpty()) {\n-                    return new AbstractMap.SimpleImmutableEntry(c,orEqual.getValue());\n-                }\n-            } else if (c instanceof PredicateCondition) {\n-                final PredicateCondition<RelationType, JanusGraphRelation> atom = (PredicateCondition)c;\n-                if (atom.getKey().equals(type) && atom.getPredicate()==Cmp.EQUAL && atom.getValue()!=null) {\n-                    return new AbstractMap.SimpleImmutableEntry(c,Collections.singletonList(atom.getValue()));\n-                }\n-            }\n-\n-        }\n-        return null;\n-    }\n-\n-    public static Condition<JanusGraphElement> indexCover(final MixedIndexType index,\n-                                                          Condition<JanusGraphElement> condition,\n-                                                          final IndexSerializer indexInfo,\n-                                                          final Set<Condition> covered) {\n-        if (!indexInfo.features(index).supportNotQueryNormalForm() && !QueryUtil.isQueryNormalForm(condition)) {\n-            return null;\n-        }\n-        if (condition instanceof Or) {\n-            for (final Condition<JanusGraphElement> subClause : condition.getChildren()) {\n-                if (subClause instanceof And) {\n-                    for (final Condition<JanusGraphElement> subsubClause : condition.getChildren()) {\n-                        if (!coversAll(index, subsubClause,indexInfo)) {\n-                            return null;\n-                        }\n-                    }\n-                } else {\n-                    if (!coversAll(index, subClause, indexInfo)) {\n-                        return null;\n-                    }\n-                }\n-            }\n-            covered.add(condition);\n-            return condition;\n-        }\n-        assert condition instanceof And;\n-        final And<JanusGraphElement> subCondition = new And<>(condition.numChildren());\n-        for (final Condition<JanusGraphElement> subClause : condition.getChildren()) {\n-            if (coversAll(index,subClause,indexInfo)) {\n-                subCondition.add(subClause);\n-                covered.add(subClause);\n-            }\n-        }\n-        return subCondition.isEmpty()?null:subCondition;\n-    }\n-\n-    private static boolean coversAll(final MixedIndexType index, Condition<JanusGraphElement> condition,\n-                                     IndexSerializer indexInfo) {\n-        if (condition.getType()!=Condition.Type.LITERAL) {\n-            return StreamSupport.stream(condition.getChildren().spliterator(), false)\n-                .allMatch(child -> coversAll(index, child, indexInfo));\n-        }\n-        if (!(condition instanceof PredicateCondition)) {\n-            return false;\n-        }\n-        final PredicateCondition<RelationType, JanusGraphElement> atom = (PredicateCondition) condition;\n-        if (atom.getValue() == null) {\n-            return false;\n-        }\n-\n-        Preconditions.checkArgument(atom.getKey().isPropertyKey());\n-        final PropertyKey key = (PropertyKey) atom.getKey();\n-        final ParameterIndexField[] fields = index.getFieldKeys();\n-        final ParameterIndexField match = Arrays.stream(fields)\n-            .filter(field -> field.getStatus() == SchemaStatus.ENABLED)\n-            .filter(field -> field.getFieldKey().equals(key))\n-            .findAny().orElse(null);\n-        return match != null && indexInfo.supports(index, match, atom.getPredicate());\n-    }\n-\n-    private JointIndexQuery selectIndices(final Set<IndexType> indexCandidates, final MultiCondition<JanusGraphElement> conditions,\n-                                          final Set<Condition> coveredClauses, final MutableBoolean isSorted) {\n-        /* TODO: smarter optimization:\n-        - use in-memory histograms to estimate selectivity of PredicateConditions and filter out low-selectivity ones\n-                if they would result in an individual index call (better to filter afterwards in memory)\n-        */\n-        if (indexCandidates.size() <= tx.getGraph().getConfiguration().getIndexSelectThreshold()) {\n-            return selectIndicesByBruteForce(indexCandidates, conditions, coveredClauses, isSorted);\n-        } else {\n-            return selectIndicesByApprox(indexCandidates, conditions, coveredClauses, isSorted);\n-        }\n-    }\n-\n-    /**\n-     * Determine the best jointIndexQuery by enumerating all possibilities with exponential time complexity.\n-     * Similar to Weighted Set Cover problem, to find the best choice is NP-Complete, so we should be careful\n-     * that the problem size MUST be small, otherwise it is more recommended to use an approximation algorithm.\n-     *\n-     * @param rawCandidates\n-     * @param conditions\n-     * @param coveredClauses\n-     * @param isSorted\n-     * @return\n-     */\n-    private JointIndexQuery selectIndicesByBruteForce(final Set<IndexType> rawCandidates, final MultiCondition<JanusGraphElement> conditions,\n-                                                      final Set<Condition> coveredClauses, final MutableBoolean isSorted) {\n-        final JointIndexQuery jointQuery = new JointIndexQuery();\n-        final Set<IndexCandidate> indexCandidates = new HashSet<>();\n-\n-        // validate, enrich index candidates and calculate scores\n-        for (final IndexType index : rawCandidates) {\n-            try {\n-                IndexCandidate ic = new IndexCandidate(index, conditions, serializer);\n-                ic.calculateScoreBruteForce();\n-                indexCandidates.add(ic);\n-            } catch (IllegalArgumentException ignored) {\n-                // ignore invalid index candidates\n-            }\n-        }\n-\n-        IndexCandidateGroup bestGroup = null;\n-        for (Set<IndexCandidate> subset : new PowerSet<IndexCandidate>(indexCandidates)) {\n-            if (subset.isEmpty()) continue;\n-            final IndexCandidateGroup group = new IndexCandidateGroup(subset);\n-            if (group.compareTo(bestGroup) > 0) {\n-                bestGroup = group;\n-            }\n-        }\n-\n-        if (bestGroup != null) {\n-            coveredClauses.addAll(bestGroup.getCoveredClauses());\n-            List<IndexCandidate> bestIndexes = new ArrayList<>(bestGroup.getIndexCandidates());\n-            // sort indexes by score descending order\n-            bestIndexes.sort((a, b) -> Double.compare(b.getScore(), a.getScore()));\n-            // isSorted depends on the first index subquery\n-            isSorted.setValue(orders.isEmpty() || bestIndexes.get(0).getIndex().isMixedIndex()\n-                && indexCoversOrder((MixedIndexType) bestIndexes.get(0).getIndex(), orders));\n-            for (IndexCandidate c : bestIndexes) {\n-                addToJointQuery(c, jointQuery);\n-            }\n-        }\n-\n-        return jointQuery;\n-    }\n-\n-    /**\n-     * Iterate over all potential indexes and compute a score based on how many clauses\n-     * this index covers. The index with the highest score (as long as it covers at least one additional clause)\n-     * is picked and added to the joint query for as long as such exist.\n-     * @param rawCandidates\n-     * @param conditions\n-     * @param coveredClauses\n-     * @param isSorted\n-     * @return\n-     */\n-    private JointIndexQuery selectIndicesByApprox(final Set<IndexType> rawCandidates, final MultiCondition<JanusGraphElement> conditions,\n-                                                  final Set<Condition> coveredClauses, final MutableBoolean isSorted) {\n-        final JointIndexQuery jointQuery = new JointIndexQuery();\n-        while (true) {\n-            IndexCandidate bestCandidate = null;\n-            boolean candidateSupportsSort = false;\n-\n-            for (final IndexType index : rawCandidates) {\n-                try {\n-                    final IndexCandidate indexCandidate = new IndexCandidate(index, conditions, serializer);\n-\n-                    boolean supportsSort = orders.isEmpty() ||\n-                        coveredClauses.isEmpty() && index.isMixedIndex() && indexCoversOrder((MixedIndexType) index, orders);\n-                    indexCandidate.calculateScoreApproximation(coveredClauses, supportsSort);\n-\n-                    if (!indexCandidate.isCoveredBy(coveredClauses) && (bestCandidate == null || indexCandidate.getScore() > bestCandidate.getScore())) {\n-                        bestCandidate = indexCandidate;\n-                        candidateSupportsSort = supportsSort;\n-                    }\n-                } catch (IllegalArgumentException ignored) {\n-                    // ignore invalid index candidates\n-                }\n-            }\n-            if (bestCandidate!=null) {\n-                if (coveredClauses.isEmpty()) isSorted.setValue(candidateSupportsSort);\n-                coveredClauses.addAll(bestCandidate.getSubCover());\n-                addToJointQuery(bestCandidate, jointQuery);\n-            } else {\n-                break;\n-            }\n-        }\n-        return jointQuery;\n-    }\n-\n-    private void addToJointQuery(final IndexCandidate indexCandidate, final JointIndexQuery jointQuery) {\n-        if (indexCandidate.getIndex().isCompositeIndex()) {\n-            jointQuery.add((CompositeIndexType) indexCandidate.getIndex(), serializer.getQuery(\n-                (CompositeIndexType) indexCandidate.getIndex(), (List<Object[]>) indexCandidate.getSubCondition()));\n-        } else {\n-            jointQuery.add((MixedIndexType) indexCandidate.getIndex(), serializer.getQuery(\n-                (MixedIndexType) indexCandidate.getIndex(), (Condition) indexCandidate.getSubCondition(), orders));\n-        }\n-    }\n }\n", "next_change": {"commit": "66304b76615d6af481324508dcefc0844d0ddd65", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java\nindex 61fd43222..a16937904 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java\n", "chunk": "@@ -282,10 +280,10 @@ public class GraphCentricQueryBuilder implements JanusGraphQuery<GraphCentricQue\n             }\n             indexLimit = Math.min(HARD_MAX_LIMIT,\n                 QueryUtil.adjustLimitForTxModifications(tx, coveredClauses.size(), indexLimit));\n-            query = new BackendQueryHolder<>(jointQuery.updateLimit(indexLimit),\n-                    coveredClauses.size() == conditions.numChildren(), isSorted);\n+            query = new BackendQueryHolder<>(selectedIndex.getQuery().updateLimit(indexLimit),\n+                    coveredClauses.size() == conditions.numChildren(), selectedIndex.isSorted());\n         } else {\n-            query = new BackendQueryHolder<>(new JointIndexQuery(), false, isSorted);\n+            query = new BackendQueryHolder<>(new JointIndexQuery(), false, selectedIndex.isSorted());\n         }\n         return new GraphCentricQuery(resultType, conditions, orders, query, limit);\n     }\n", "next_change": null}]}}]}}, {"oid": "434d25fa5ea74b53aea347f150b2df373983a859", "url": "https://github.com/JanusGraph/janusgraph/commit/434d25fa5ea74b53aea347f150b2df373983a859", "message": "Cleanup\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-05-15T09:11:20Z", "type": "forcePushed"}, {"oid": "adcde91def8ebb736bd4a884603639ef4da1a943", "url": "https://github.com/JanusGraph/janusgraph/commit/adcde91def8ebb736bd4a884603639ef4da1a943", "message": "Cleanup\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-05-15T09:13:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQzNjUxOA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430436518", "body": "Most of methods of this interface are related to implementation, not abstraction. Thus they should either be private or package protected or protected as they are not intended to be used publicly.\r\nThus, I suggest create an abstract class `public abstract class `AbstractIndexSelectionStrategy` implements IndexSelectionStrategy` and move implementations there (make everything non-static. Methods which should be static can be left here). After that make `BruteForceIndexSelectionStrategy` and `ApproximateIndexSelectionStrategy` to be extended from `AbstractIndexSelectionStrategy`.", "bodyText": "Most of methods of this interface are related to implementation, not abstraction. Thus they should either be private or package protected or protected as they are not intended to be used publicly.\nThus, I suggest create an abstract class public abstract class AbstractIndexSelectionStrategy implements IndexSelectionStrategy and move implementations there (make everything non-static. Methods which should be static can be left here). After that make BruteForceIndexSelectionStrategy and ApproximateIndexSelectionStrategy to be extended from AbstractIndexSelectionStrategy.", "bodyHTML": "<p dir=\"auto\">Most of methods of this interface are related to implementation, not abstraction. Thus they should either be private or package protected or protected as they are not intended to be used publicly.<br>\nThus, I suggest create an abstract class <code>public abstract class </code>AbstractIndexSelectionStrategy<code> implements IndexSelectionStrategy</code> and move implementations there (make everything non-static. Methods which should be static can be left here). After that make <code>BruteForceIndexSelectionStrategy</code> and <code>ApproximateIndexSelectionStrategy</code> to be extended from <code>AbstractIndexSelectionStrategy</code>.</p>", "author": "porunov", "createdAt": "2020-05-26T14:02:54Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexSelectionStrategy.java", "diffHunk": "@@ -0,0 +1,231 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import com.google.common.base.Preconditions;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.JanusGraphRelation;\n+import org.janusgraph.core.PropertyKey;\n+import org.janusgraph.core.RelationType;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.core.schema.JanusGraphSchemaType;\n+import org.janusgraph.core.schema.SchemaStatus;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.QueryUtil;\n+import org.janusgraph.graphdb.query.condition.*;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.types.*;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n+import org.javatuples.Pair;\n+\n+import javax.annotation.Nullable;\n+import java.util.*;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public interface IndexSelectionStrategy {", "originalCommit": "adcde91def8ebb736bd4a884603639ef4da1a943", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "66304b76615d6af481324508dcefc0844d0ddd65", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexSelectionStrategy.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexSelectionStrategy.java\nindex 703cf9eed..88941a27c 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexSelectionStrategy.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexSelectionStrategy.java\n", "chunk": "@@ -14,218 +14,44 @@\n \n package org.janusgraph.graphdb.query.index;\n \n-import com.google.common.base.Preconditions;\n+import java.util.*;\n import org.janusgraph.core.JanusGraphElement;\n-import org.janusgraph.core.JanusGraphRelation;\n-import org.janusgraph.core.PropertyKey;\n-import org.janusgraph.core.RelationType;\n-import org.janusgraph.core.attribute.Cmp;\n-import org.janusgraph.core.schema.JanusGraphSchemaType;\n-import org.janusgraph.core.schema.SchemaStatus;\n import org.janusgraph.graphdb.database.IndexSerializer;\n import org.janusgraph.graphdb.internal.OrderList;\n-import org.janusgraph.graphdb.query.QueryUtil;\n-import org.janusgraph.graphdb.query.condition.*;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n import org.janusgraph.graphdb.types.*;\n-import org.janusgraph.graphdb.types.system.ImplicitKey;\n import org.javatuples.Pair;\n \n-import javax.annotation.Nullable;\n-import java.util.*;\n-import java.util.stream.StreamSupport;\n-\n /**\n  * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n  */\n public interface IndexSelectionStrategy {\n-    Pair<JointIndexQuery, Boolean> selectIndices(final Set<IndexType> indexCandidates, final MultiCondition<JanusGraphElement> conditions,\n-                                                 final Set<Condition> coveredClauses, OrderList orders, IndexSerializer serializer);\n-\n-    /**\n-     * Creates an <code>IndexCandidate</code> from a <code>MultiCondition</code> which it covers.\n-     * @param index\n-     * @param conditions For the condition to be valid, it needs to match these rules:\n-     *                   <ul>\n-     *                   <li>It must be an equality condition</li>\n-     *                   <li>It must not cover multiple labels</li>\n-     *                   <li>The label must match the given <code>index</code></li>\n-     *                   </ul>\n-     * @return An instance of <code>IndexCandidate</code> if the parameter <code>conditions</code> is valid, <code>null</code> else.\n-     */\n-    @Nullable\n-    static IndexCandidate createIndexCandidate(final IndexType index, final MultiCondition<JanusGraphElement> conditions, IndexSerializer serializer) {\n-        final Set<Condition> subCover = new HashSet<>(1);\n-\n-        // Check that this index actually applies in case of a schema constraint\n-        if (index.hasSchemaTypeConstraint()) {\n-            final JanusGraphSchemaType type = index.getSchemaTypeConstraint();\n-            final Map.Entry<Condition, Collection<Object>> equalCon = getEqualityConditionValues(conditions, ImplicitKey.LABEL);\n-\n-            if (equalCon == null) {\n-                // Only equality conditions are supported\n-                return null;\n-            }\n-\n-            final Collection<Object> labels = equalCon.getValue();\n-            assert labels.size() >= 1;\n-\n-            if (labels.size() > 1) {\n-                // The query optimizer currently does not support multiple label constraints\n-                return null;\n-            }\n-            if (!type.name().equals(labels.iterator().next())) {\n-                // Given IndexType does not match given condition label\n-                return null;\n-            }\n-            subCover.add(equalCon.getKey());\n-        }\n-\n-        Object subCondition;\n-        if (index.isCompositeIndex()) {\n-            subCondition = indexCover((CompositeIndexType) index, conditions, subCover);\n-        } else {\n-            subCondition = indexCover((MixedIndexType) index, conditions, serializer, subCover);\n-        }\n-        if (subCondition == null || subCover.isEmpty()) {\n-            // Unable to initialize IndexCandidate from given parameters\n-            return null;\n-        }\n-\n-        return new IndexCandidate(index, subCover, subCondition);\n-    }\n-\n-    static void addToJointQuery(final IndexCandidate indexCandidate, final JointIndexQuery jointQuery, final IndexSerializer serializer, final OrderList orders) {\n-        if (indexCandidate.getIndex().isCompositeIndex()) {\n-            jointQuery.add((CompositeIndexType) indexCandidate.getIndex(), serializer.getQuery(\n-                (CompositeIndexType) indexCandidate.getIndex(), (List<Object[]>) indexCandidate.getSubCondition()));\n-        } else {\n-            jointQuery.add((MixedIndexType) indexCandidate.getIndex(), serializer.getQuery(\n-                (MixedIndexType) indexCandidate.getIndex(), (Condition) indexCandidate.getSubCondition(), orders));\n-        }\n-    }\n+    SelectedIndexQuery selectIndices(final Set<IndexType> indexCandidates,\n+                                     final MultiCondition<JanusGraphElement> conditions,\n+                                     final Set<Condition> coveredClauses, OrderList orders,\n+                                     IndexSerializer serializer);\n \n     static boolean indexCoversOrder(MixedIndexType index, OrderList orders) {\n         for (int i = 0; i < orders.size(); i++) {\n-            if (!index.indexesKey(orders.getKey(i))) return false;\n+            if (!index.indexesKey(orders.getKey(i)))\n+                return false;\n         }\n         return true;\n     }\n \n-    static List<Object[]> indexCover(final CompositeIndexType index, Condition<JanusGraphElement> condition,\n-                                     Set<Condition> covered) {\n-        if (!QueryUtil.isQueryNormalForm(condition)) {\n-            return null;\n-        }\n-        assert condition instanceof And;\n-        if (index.getStatus()!= SchemaStatus.ENABLED) return null;\n-        final IndexField[] fields = index.getFieldKeys();\n-        final Object[] indexValues = new Object[fields.length];\n-        final Set<Condition> coveredClauses = new HashSet<>(fields.length);\n-        final List<Object[]> indexCovers = new ArrayList<>(4);\n-\n-        constructIndexCover(indexValues,0,fields,condition,indexCovers,coveredClauses);\n-        if (!indexCovers.isEmpty()) {\n-            covered.addAll(coveredClauses);\n-            return indexCovers;\n-        } else return null;\n-    }\n-\n-    static void constructIndexCover(Object[] indexValues, int position, IndexField[] fields,\n-                                    Condition<JanusGraphElement> condition,\n-                                    List<Object[]> indexCovers, Set<Condition> coveredClauses) {\n-        if (position>=fields.length) {\n-            indexCovers.add(indexValues);\n-        } else {\n-            final IndexField field = fields[position];\n-            final Map.Entry<Condition,Collection<Object>> equalCon = getEqualityConditionValues(condition,field.getFieldKey());\n-            if (equalCon!=null) {\n-                coveredClauses.add(equalCon.getKey());\n-                assert equalCon.getValue().size()>0;\n-                for (final Object value : equalCon.getValue()) {\n-                    final Object[] newValues = Arrays.copyOf(indexValues,fields.length);\n-                    newValues[position]=value;\n-                    constructIndexCover(newValues,position+1,fields,condition,indexCovers,coveredClauses);\n-                }\n-            }\n-        }\n-    }\n-\n-    static Condition<JanusGraphElement> indexCover(final MixedIndexType index,\n-                                                   Condition<JanusGraphElement> condition,\n-                                                   final IndexSerializer indexInfo,\n-                                                   final Set<Condition> covered) {\n-        if (!indexInfo.features(index).supportNotQueryNormalForm() && !QueryUtil.isQueryNormalForm(condition)) {\n-            return null;\n-        }\n-        if (condition instanceof Or) {\n-            for (final Condition<JanusGraphElement> subClause : condition.getChildren()) {\n-                if (subClause instanceof And) {\n-                    for (final Condition<JanusGraphElement> subsubClause : condition.getChildren()) {\n-                        if (!coversAll(index, subsubClause,indexInfo)) {\n-                            return null;\n-                        }\n-                    }\n-                } else {\n-                    if (!coversAll(index, subClause, indexInfo)) {\n-                        return null;\n-                    }\n-                }\n-            }\n-            covered.add(condition);\n-            return condition;\n-        }\n-        assert condition instanceof And;\n-        final And<JanusGraphElement> subCondition = new And<>(condition.numChildren());\n-        for (final Condition<JanusGraphElement> subClause : condition.getChildren()) {\n-            if (coversAll(index,subClause,indexInfo)) {\n-                subCondition.add(subClause);\n-                covered.add(subClause);\n-            }\n-        }\n-        return subCondition.isEmpty()?null:subCondition;\n-    }\n+    class SelectedIndexQuery {\n+        private JointIndexQuery query;\n+        private boolean isSorted;\n \n-    static boolean coversAll(final MixedIndexType index, Condition<JanusGraphElement> condition,\n-                             IndexSerializer indexInfo) {\n-        if (condition.getType()!=Condition.Type.LITERAL) {\n-            return StreamSupport.stream(condition.getChildren().spliterator(), false)\n-                .allMatch(child -> coversAll(index, child, indexInfo));\n-        }\n-        if (!(condition instanceof PredicateCondition)) {\n-            return false;\n+        public SelectedIndexQuery(JointIndexQuery query, boolean isSorted) {\n+            this.query = query;\n+            this.isSorted = isSorted;\n         }\n-        final PredicateCondition<RelationType, JanusGraphElement> atom = (PredicateCondition) condition;\n-        if (atom.getValue() == null) {\n-            return false;\n-        }\n-\n-        Preconditions.checkArgument(atom.getKey().isPropertyKey());\n-        final PropertyKey key = (PropertyKey) atom.getKey();\n-        final ParameterIndexField[] fields = index.getFieldKeys();\n-        final ParameterIndexField match = Arrays.stream(fields)\n-            .filter(field -> field.getStatus() == SchemaStatus.ENABLED)\n-            .filter(field -> field.getFieldKey().equals(key))\n-            .findAny().orElse(null);\n-        return match != null && indexInfo.supports(index, match, atom.getPredicate());\n-    }\n \n-    static Map.Entry<Condition,Collection<Object>> getEqualityConditionValues(\n-        Condition<JanusGraphElement> condition, RelationType type) {\n-        for (final Condition c : condition.getChildren()) {\n-            if (c instanceof Or) {\n-                final Map.Entry<RelationType,Collection> orEqual = QueryUtil.extractOrCondition((Or)c);\n-                if (orEqual!=null && orEqual.getKey().equals(type) && !orEqual.getValue().isEmpty()) {\n-                    return new AbstractMap.SimpleImmutableEntry(c,orEqual.getValue());\n-                }\n-            } else if (c instanceof PredicateCondition) {\n-                final PredicateCondition<RelationType, JanusGraphRelation> atom = (PredicateCondition)c;\n-                if (atom.getKey().equals(type) && atom.getPredicate()== Cmp.EQUAL && atom.getValue()!=null) {\n-                    return new AbstractMap.SimpleImmutableEntry(c,Collections.singletonList(atom.getValue()));\n-                }\n-            }\n+        public JointIndexQuery getQuery() { return query; }\n \n-        }\n-        return null;\n+        public boolean isSorted() { return isSorted; }\n     }\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ0NTIwMQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430445201", "body": "This looks more like `Service` because it contains a business logic to interact with different strategies. I would suggest to rename it to `IndexSelectorService` and do not implement `IndexSelectionStrategy`.", "bodyText": "This looks more like Service because it contains a business logic to interact with different strategies. I would suggest to rename it to IndexSelectorService and do not implement IndexSelectionStrategy.", "bodyHTML": "<p dir=\"auto\">This looks more like <code>Service</code> because it contains a business logic to interact with different strategies. I would suggest to rename it to <code>IndexSelectorService</code> and do not implement <code>IndexSelectionStrategy</code>.</p>", "author": "porunov", "createdAt": "2020-05-26T14:14:23Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/DefaultIndexSelector.java", "diffHunk": "@@ -0,0 +1,61 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.transaction.StandardJanusGraphTx;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.javatuples.Pair;\n+\n+import java.util.Set;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class DefaultIndexSelector implements IndexSelectionStrategy {", "originalCommit": "adcde91def8ebb736bd4a884603639ef4da1a943", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg1NzcyMQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430857721", "bodyText": "Why not see this as a Strategy, too? Sure it combines and calls other strategies based on the size of the problem. But from my point of view it serves the same purpose as other implementations of IndexSelectionStrategy and acts as a drop-in replacement for other strategies.", "author": "rngcntr", "createdAt": "2020-05-27T05:00:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ0NTIwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg2Mjc3Ng==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430862776", "bodyText": "Good point. I guess it can be seen as a strategy also but from the other hand it just contains logic to choose another strategy based on some logic. I guess if we add another strategy it becomes a dependency of this class also because the logic behind this class is basically to select a strategy.\nI see it more as a service but I don't mind leaving it as a strategy. Just give it some more clear name. Maybe something like 'ThresholdBasedIndexSelectionStrategy'.", "author": "porunov", "createdAt": "2020-05-27T05:20:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ0NTIwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg2NDc1MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430864750", "bodyText": "LGTM\nI'll see if I can find some spare time today or tomorrow to implement your requested changes", "author": "rngcntr", "createdAt": "2020-05-27T05:28:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ0NTIwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "66304b76615d6af481324508dcefc0844d0ddd65", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/DefaultIndexSelector.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/DefaultIndexSelector.java\ndeleted file mode 100644\nindex f41f9d174..000000000\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/DefaultIndexSelector.java\n+++ /dev/null\n", "chunk": "@@ -1,61 +0,0 @@\n-// Copyright 2020 JanusGraph Authors\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package org.janusgraph.graphdb.query.index;\n-\n-import org.janusgraph.core.JanusGraphElement;\n-import org.janusgraph.graphdb.database.IndexSerializer;\n-import org.janusgraph.graphdb.internal.OrderList;\n-import org.janusgraph.graphdb.query.condition.Condition;\n-import org.janusgraph.graphdb.query.condition.MultiCondition;\n-import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n-import org.janusgraph.graphdb.transaction.StandardJanusGraphTx;\n-import org.janusgraph.graphdb.types.IndexType;\n-import org.javatuples.Pair;\n-\n-import java.util.Set;\n-\n-/**\n- * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n- */\n-public class DefaultIndexSelector implements IndexSelectionStrategy {\n-\n-    /**\n-     * Transaction which is used to gather settings of the graph\n-     */\n-    private StandardJanusGraphTx tx;\n-\n-    private IndexSelectionStrategy bruteForce;\n-    private IndexSelectionStrategy approximation;\n-\n-    public DefaultIndexSelector(StandardJanusGraphTx tx) {\n-        this.tx = tx;\n-\n-        this.bruteForce = new BruteForceIndexSelector();\n-        this.approximation = new ApproximateIndexSelector();\n-    }\n-\n-    @Override\n-    public Pair<JointIndexQuery, Boolean> selectIndices(final Set<IndexType> indexCandidates, final MultiCondition<JanusGraphElement> conditions,\n-                                                        final Set<Condition> coveredClauses, OrderList orders, IndexSerializer serializer) {\n-        /* TODO: smarter optimization:\n-        - use in-memory histograms to estimate selectivity of PredicateConditions and filter out low-selectivity ones\n-                if they would result in an individual index call (better to filter afterwards in memory)\n-        */\n-        int bruteForceThreshold = tx.getGraph().getConfiguration().getIndexSelectThreshold();\n-        IndexSelectionStrategy preferredStrategy = indexCandidates.size() <= bruteForceThreshold ? bruteForce : approximation;\n-        return preferredStrategy.selectIndices(indexCandidates, conditions, coveredClauses, orders, serializer);\n-    }\n-\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ0NzI5NQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430447295", "body": "Could you please make it as direct constructor dependency to follow DI principle? It will simplify this class testing in future", "bodyText": "Could you please make it as direct constructor dependency to follow DI principle? It will simplify this class testing in future", "bodyHTML": "<p dir=\"auto\">Could you please make it as direct constructor dependency to follow DI principle? It will simplify this class testing in future</p>", "author": "porunov", "createdAt": "2020-05-26T14:17:15Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/DefaultIndexSelector.java", "diffHunk": "@@ -0,0 +1,61 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.transaction.StandardJanusGraphTx;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.javatuples.Pair;\n+\n+import java.util.Set;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class DefaultIndexSelector implements IndexSelectionStrategy {\n+\n+    /**\n+     * Transaction which is used to gather settings of the graph\n+     */\n+    private StandardJanusGraphTx tx;\n+\n+    private IndexSelectionStrategy bruteForce;\n+    private IndexSelectionStrategy approximation;\n+\n+    public DefaultIndexSelector(StandardJanusGraphTx tx) {\n+        this.tx = tx;\n+\n+        this.bruteForce = new BruteForceIndexSelector();\n+        this.approximation = new ApproximateIndexSelector();", "originalCommit": "adcde91def8ebb736bd4a884603639ef4da1a943", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "66304b76615d6af481324508dcefc0844d0ddd65", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/DefaultIndexSelector.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/DefaultIndexSelector.java\ndeleted file mode 100644\nindex f41f9d174..000000000\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/DefaultIndexSelector.java\n+++ /dev/null\n", "chunk": "@@ -1,61 +0,0 @@\n-// Copyright 2020 JanusGraph Authors\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package org.janusgraph.graphdb.query.index;\n-\n-import org.janusgraph.core.JanusGraphElement;\n-import org.janusgraph.graphdb.database.IndexSerializer;\n-import org.janusgraph.graphdb.internal.OrderList;\n-import org.janusgraph.graphdb.query.condition.Condition;\n-import org.janusgraph.graphdb.query.condition.MultiCondition;\n-import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n-import org.janusgraph.graphdb.transaction.StandardJanusGraphTx;\n-import org.janusgraph.graphdb.types.IndexType;\n-import org.javatuples.Pair;\n-\n-import java.util.Set;\n-\n-/**\n- * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n- */\n-public class DefaultIndexSelector implements IndexSelectionStrategy {\n-\n-    /**\n-     * Transaction which is used to gather settings of the graph\n-     */\n-    private StandardJanusGraphTx tx;\n-\n-    private IndexSelectionStrategy bruteForce;\n-    private IndexSelectionStrategy approximation;\n-\n-    public DefaultIndexSelector(StandardJanusGraphTx tx) {\n-        this.tx = tx;\n-\n-        this.bruteForce = new BruteForceIndexSelector();\n-        this.approximation = new ApproximateIndexSelector();\n-    }\n-\n-    @Override\n-    public Pair<JointIndexQuery, Boolean> selectIndices(final Set<IndexType> indexCandidates, final MultiCondition<JanusGraphElement> conditions,\n-                                                        final Set<Condition> coveredClauses, OrderList orders, IndexSerializer serializer) {\n-        /* TODO: smarter optimization:\n-        - use in-memory histograms to estimate selectivity of PredicateConditions and filter out low-selectivity ones\n-                if they would result in an individual index call (better to filter afterwards in memory)\n-        */\n-        int bruteForceThreshold = tx.getGraph().getConfiguration().getIndexSelectThreshold();\n-        IndexSelectionStrategy preferredStrategy = indexCandidates.size() <= bruteForceThreshold ? bruteForce : approximation;\n-        return preferredStrategy.selectIndices(indexCandidates, conditions, coveredClauses, orders, serializer);\n-    }\n-\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ0OTU1Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430449553", "body": "Can `bruteForceThreshold` be changed during different calls of this method? If no, could you provide `bruteForceThreshold` as a dependency of this class?", "bodyText": "Can bruteForceThreshold be changed during different calls of this method? If no, could you provide bruteForceThreshold as a dependency of this class?", "bodyHTML": "<p dir=\"auto\">Can <code>bruteForceThreshold</code> be changed during different calls of this method? If no, could you provide <code>bruteForceThreshold</code> as a dependency of this class?</p>", "author": "porunov", "createdAt": "2020-05-26T14:20:13Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/DefaultIndexSelector.java", "diffHunk": "@@ -0,0 +1,61 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.transaction.StandardJanusGraphTx;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.javatuples.Pair;\n+\n+import java.util.Set;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class DefaultIndexSelector implements IndexSelectionStrategy {\n+\n+    /**\n+     * Transaction which is used to gather settings of the graph\n+     */\n+    private StandardJanusGraphTx tx;\n+\n+    private IndexSelectionStrategy bruteForce;\n+    private IndexSelectionStrategy approximation;\n+\n+    public DefaultIndexSelector(StandardJanusGraphTx tx) {\n+        this.tx = tx;\n+\n+        this.bruteForce = new BruteForceIndexSelector();\n+        this.approximation = new ApproximateIndexSelector();\n+    }\n+\n+    @Override\n+    public Pair<JointIndexQuery, Boolean> selectIndices(final Set<IndexType> indexCandidates, final MultiCondition<JanusGraphElement> conditions,\n+                                                        final Set<Condition> coveredClauses, OrderList orders, IndexSerializer serializer) {\n+        /* TODO: smarter optimization:\n+        - use in-memory histograms to estimate selectivity of PredicateConditions and filter out low-selectivity ones\n+                if they would result in an individual index call (better to filter afterwards in memory)\n+        */\n+        int bruteForceThreshold = tx.getGraph().getConfiguration().getIndexSelectThreshold();", "originalCommit": "adcde91def8ebb736bd4a884603639ef4da1a943", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg1NjE1NQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430856155", "bodyText": "Good point", "author": "rngcntr", "createdAt": "2020-05-27T04:53:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ0OTU1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "66304b76615d6af481324508dcefc0844d0ddd65", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/DefaultIndexSelector.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/DefaultIndexSelector.java\ndeleted file mode 100644\nindex f41f9d174..000000000\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/DefaultIndexSelector.java\n+++ /dev/null\n", "chunk": "@@ -1,61 +0,0 @@\n-// Copyright 2020 JanusGraph Authors\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package org.janusgraph.graphdb.query.index;\n-\n-import org.janusgraph.core.JanusGraphElement;\n-import org.janusgraph.graphdb.database.IndexSerializer;\n-import org.janusgraph.graphdb.internal.OrderList;\n-import org.janusgraph.graphdb.query.condition.Condition;\n-import org.janusgraph.graphdb.query.condition.MultiCondition;\n-import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n-import org.janusgraph.graphdb.transaction.StandardJanusGraphTx;\n-import org.janusgraph.graphdb.types.IndexType;\n-import org.javatuples.Pair;\n-\n-import java.util.Set;\n-\n-/**\n- * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n- */\n-public class DefaultIndexSelector implements IndexSelectionStrategy {\n-\n-    /**\n-     * Transaction which is used to gather settings of the graph\n-     */\n-    private StandardJanusGraphTx tx;\n-\n-    private IndexSelectionStrategy bruteForce;\n-    private IndexSelectionStrategy approximation;\n-\n-    public DefaultIndexSelector(StandardJanusGraphTx tx) {\n-        this.tx = tx;\n-\n-        this.bruteForce = new BruteForceIndexSelector();\n-        this.approximation = new ApproximateIndexSelector();\n-    }\n-\n-    @Override\n-    public Pair<JointIndexQuery, Boolean> selectIndices(final Set<IndexType> indexCandidates, final MultiCondition<JanusGraphElement> conditions,\n-                                                        final Set<Condition> coveredClauses, OrderList orders, IndexSerializer serializer) {\n-        /* TODO: smarter optimization:\n-        - use in-memory histograms to estimate selectivity of PredicateConditions and filter out low-selectivity ones\n-                if they would result in an individual index call (better to filter afterwards in memory)\n-        */\n-        int bruteForceThreshold = tx.getGraph().getConfiguration().getIndexSelectThreshold();\n-        IndexSelectionStrategy preferredStrategy = indexCandidates.size() <= bruteForceThreshold ? bruteForce : approximation;\n-        return preferredStrategy.selectIndices(indexCandidates, conditions, coveredClauses, orders, serializer);\n-    }\n-\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ1NzE4OQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430457189", "body": "Do not remove `Strategy` of concrete implementations. I.e. call it `ApproximateIndexSelectionStrategy`.", "bodyText": "Do not remove Strategy of concrete implementations. I.e. call it ApproximateIndexSelectionStrategy.", "bodyHTML": "<p dir=\"auto\">Do not remove <code>Strategy</code> of concrete implementations. I.e. call it <code>ApproximateIndexSelectionStrategy</code>.</p>", "author": "porunov", "createdAt": "2020-05-26T14:30:07Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ApproximateIndexSelector.java", "diffHunk": "@@ -0,0 +1,76 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.janusgraph.graphdb.types.MixedIndexType;\n+import org.javatuples.Pair;\n+\n+import java.util.Set;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class ApproximateIndexSelector implements IndexSelectionStrategy {", "originalCommit": "adcde91def8ebb736bd4a884603639ef4da1a943", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "66304b76615d6af481324508dcefc0844d0ddd65", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ApproximateIndexSelector.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ApproximateIndexSelectionStrategy.java\nsimilarity index 65%\nrename from janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ApproximateIndexSelector.java\nrename to janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ApproximateIndexSelectionStrategy.java\nindex 5f35b1ed4..fc7ec21e0 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ApproximateIndexSelector.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ApproximateIndexSelectionStrategy.java\n", "chunk": "@@ -24,21 +25,22 @@ import org.janusgraph.graphdb.types.IndexType;\n import org.janusgraph.graphdb.types.MixedIndexType;\n import org.javatuples.Pair;\n \n-import java.util.Set;\n-\n /**\n  * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n  */\n-public class ApproximateIndexSelector implements IndexSelectionStrategy {\n+public class ApproximateIndexSelectionStrategy\n+    extends AbstractIndexSelectionStrategy implements IndexSelectionStrategy {\n \n     /**\n      * Iterate over all potential indexes and compute a score based on how many clauses\n-     * this index covers. The index with the highest score (as long as it covers at least one additional clause)\n-     * is picked and added to the joint query for as long as such exist.\n+     * this index covers. The index with the highest score (as long as it covers at least one\n+     * additional clause) is picked and added to the joint query for as long as such exist.\n      */\n     @Override\n-    public Pair<JointIndexQuery, Boolean> selectIndices(final Set<IndexType> rawCandidates, final MultiCondition<JanusGraphElement> conditions,\n-                                                        final Set<Condition> coveredClauses, OrderList orders, IndexSerializer serializer) {\n+    public SelectedIndexQuery selectIndices(final Set<IndexType> rawCandidates,\n+                                            final MultiCondition<JanusGraphElement> conditions,\n+                                            final Set<Condition> coveredClauses, OrderList orders,\n+                                            IndexSerializer serializer) {\n         final JointIndexQuery jointQuery = new JointIndexQuery();\n         boolean isSorted = orders.isEmpty();\n         while (true) {\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ1NzQyMQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430457421", "body": "Do not remove `Strategy` of concrete implementations. I.e. call it `BruteForceIndexSelectionStrategy`.", "bodyText": "Do not remove Strategy of concrete implementations. I.e. call it BruteForceIndexSelectionStrategy.", "bodyHTML": "<p dir=\"auto\">Do not remove <code>Strategy</code> of concrete implementations. I.e. call it <code>BruteForceIndexSelectionStrategy</code>.</p>", "author": "porunov", "createdAt": "2020-05-26T14:30:24Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/BruteForceIndexSelector.java", "diffHunk": "@@ -0,0 +1,84 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.janusgraph.graphdb.types.MixedIndexType;\n+import org.janusgraph.util.datastructures.PowerSet;\n+import org.javatuples.Pair;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class BruteForceIndexSelector implements IndexSelectionStrategy {", "originalCommit": "adcde91def8ebb736bd4a884603639ef4da1a943", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "66304b76615d6af481324508dcefc0844d0ddd65", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/BruteForceIndexSelector.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/BruteForceIndexSelectionStrategy.java\nsimilarity index 67%\nrename from janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/BruteForceIndexSelector.java\nrename to janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/BruteForceIndexSelectionStrategy.java\nindex 778f9e8b1..974f476b2 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/BruteForceIndexSelector.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/BruteForceIndexSelectionStrategy.java\n", "chunk": "@@ -25,31 +29,30 @@ import org.janusgraph.graphdb.types.MixedIndexType;\n import org.janusgraph.util.datastructures.PowerSet;\n import org.javatuples.Pair;\n \n-import java.util.ArrayList;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Set;\n-\n /**\n  * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n  */\n-public class BruteForceIndexSelector implements IndexSelectionStrategy {\n+public class BruteForceIndexSelectionStrategy\n+    extends AbstractIndexSelectionStrategy implements IndexSelectionStrategy {\n \n     /**\n-     * Determine the best jointIndexQuery by enumerating all possibilities with exponential time complexity.\n-     * Similar to Weighted Set Cover problem, to find the best choice is NP-Complete, so we should be careful\n-     * that the problem size MUST be small, otherwise it is more recommended to use an approximation algorithm.\n+     * Determine the best jointIndexQuery by enumerating all possibilities with exponential time\n+     * complexity. Similar to Weighted Set Cover problem, to find the best choice is NP-Complete, so\n+     * we should be careful that the problem size MUST be small, otherwise it is more recommended to\n+     * use an approximation algorithm.\n      */\n     @Override\n-    public Pair<JointIndexQuery, Boolean> selectIndices(final Set<IndexType> rawCandidates, final MultiCondition<JanusGraphElement> conditions,\n-                                                        final Set<Condition> coveredClauses, OrderList orders, IndexSerializer serializer) {\n+    public SelectedIndexQuery selectIndices(final Set<IndexType> rawCandidates,\n+                                            final MultiCondition<JanusGraphElement> conditions,\n+                                            final Set<Condition> coveredClauses, OrderList orders,\n+                                            IndexSerializer serializer) {\n         final JointIndexQuery jointQuery = new JointIndexQuery();\n         final Set<IndexCandidate> indexCandidates = new HashSet<>();\n         boolean isSorted = orders.isEmpty();\n \n         // validate, enrich index candidates and calculate scores\n         for (final IndexType index : rawCandidates) {\n-            IndexCandidate ic = IndexSelectionStrategy.createIndexCandidate(index, conditions, serializer);\n+            IndexCandidate ic = createIndexCandidate(index, conditions, serializer);\n             if (ic == null) {\n                 continue;\n             }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ2MjA3Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430462073", "body": "Instead of using `Pair` as a return type, I would create some POJO which contains `JointIndexQuery jointQuery` and `Boolean sorted` because 1) It isn't obvious what does `Boolean` means here. 2) If we decide to extend or shrink our return type, we won't be able to use Pair anymore.", "bodyText": "Instead of using Pair as a return type, I would create some POJO which contains JointIndexQuery jointQuery and Boolean sorted because 1) It isn't obvious what does Boolean means here. 2) If we decide to extend or shrink our return type, we won't be able to use Pair anymore.", "bodyHTML": "<p dir=\"auto\">Instead of using <code>Pair</code> as a return type, I would create some POJO which contains <code>JointIndexQuery jointQuery</code> and <code>Boolean sorted</code> because 1) It isn't obvious what does <code>Boolean</code> means here. 2) If we decide to extend or shrink our return type, we won't be able to use Pair anymore.</p>", "author": "porunov", "createdAt": "2020-05-26T14:36:31Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexSelectionStrategy.java", "diffHunk": "@@ -0,0 +1,231 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import com.google.common.base.Preconditions;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.JanusGraphRelation;\n+import org.janusgraph.core.PropertyKey;\n+import org.janusgraph.core.RelationType;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.core.schema.JanusGraphSchemaType;\n+import org.janusgraph.core.schema.SchemaStatus;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.QueryUtil;\n+import org.janusgraph.graphdb.query.condition.*;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.types.*;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n+import org.javatuples.Pair;\n+\n+import javax.annotation.Nullable;\n+import java.util.*;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public interface IndexSelectionStrategy {\n+    Pair<JointIndexQuery, Boolean> selectIndices(final Set<IndexType> indexCandidates, final MultiCondition<JanusGraphElement> conditions,", "originalCommit": "adcde91def8ebb736bd4a884603639ef4da1a943", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "66304b76615d6af481324508dcefc0844d0ddd65", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexSelectionStrategy.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexSelectionStrategy.java\nindex 703cf9eed..88941a27c 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexSelectionStrategy.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexSelectionStrategy.java\n", "chunk": "@@ -14,218 +14,44 @@\n \n package org.janusgraph.graphdb.query.index;\n \n-import com.google.common.base.Preconditions;\n+import java.util.*;\n import org.janusgraph.core.JanusGraphElement;\n-import org.janusgraph.core.JanusGraphRelation;\n-import org.janusgraph.core.PropertyKey;\n-import org.janusgraph.core.RelationType;\n-import org.janusgraph.core.attribute.Cmp;\n-import org.janusgraph.core.schema.JanusGraphSchemaType;\n-import org.janusgraph.core.schema.SchemaStatus;\n import org.janusgraph.graphdb.database.IndexSerializer;\n import org.janusgraph.graphdb.internal.OrderList;\n-import org.janusgraph.graphdb.query.QueryUtil;\n-import org.janusgraph.graphdb.query.condition.*;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n import org.janusgraph.graphdb.types.*;\n-import org.janusgraph.graphdb.types.system.ImplicitKey;\n import org.javatuples.Pair;\n \n-import javax.annotation.Nullable;\n-import java.util.*;\n-import java.util.stream.StreamSupport;\n-\n /**\n  * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n  */\n public interface IndexSelectionStrategy {\n-    Pair<JointIndexQuery, Boolean> selectIndices(final Set<IndexType> indexCandidates, final MultiCondition<JanusGraphElement> conditions,\n-                                                 final Set<Condition> coveredClauses, OrderList orders, IndexSerializer serializer);\n-\n-    /**\n-     * Creates an <code>IndexCandidate</code> from a <code>MultiCondition</code> which it covers.\n-     * @param index\n-     * @param conditions For the condition to be valid, it needs to match these rules:\n-     *                   <ul>\n-     *                   <li>It must be an equality condition</li>\n-     *                   <li>It must not cover multiple labels</li>\n-     *                   <li>The label must match the given <code>index</code></li>\n-     *                   </ul>\n-     * @return An instance of <code>IndexCandidate</code> if the parameter <code>conditions</code> is valid, <code>null</code> else.\n-     */\n-    @Nullable\n-    static IndexCandidate createIndexCandidate(final IndexType index, final MultiCondition<JanusGraphElement> conditions, IndexSerializer serializer) {\n-        final Set<Condition> subCover = new HashSet<>(1);\n-\n-        // Check that this index actually applies in case of a schema constraint\n-        if (index.hasSchemaTypeConstraint()) {\n-            final JanusGraphSchemaType type = index.getSchemaTypeConstraint();\n-            final Map.Entry<Condition, Collection<Object>> equalCon = getEqualityConditionValues(conditions, ImplicitKey.LABEL);\n-\n-            if (equalCon == null) {\n-                // Only equality conditions are supported\n-                return null;\n-            }\n-\n-            final Collection<Object> labels = equalCon.getValue();\n-            assert labels.size() >= 1;\n-\n-            if (labels.size() > 1) {\n-                // The query optimizer currently does not support multiple label constraints\n-                return null;\n-            }\n-            if (!type.name().equals(labels.iterator().next())) {\n-                // Given IndexType does not match given condition label\n-                return null;\n-            }\n-            subCover.add(equalCon.getKey());\n-        }\n-\n-        Object subCondition;\n-        if (index.isCompositeIndex()) {\n-            subCondition = indexCover((CompositeIndexType) index, conditions, subCover);\n-        } else {\n-            subCondition = indexCover((MixedIndexType) index, conditions, serializer, subCover);\n-        }\n-        if (subCondition == null || subCover.isEmpty()) {\n-            // Unable to initialize IndexCandidate from given parameters\n-            return null;\n-        }\n-\n-        return new IndexCandidate(index, subCover, subCondition);\n-    }\n-\n-    static void addToJointQuery(final IndexCandidate indexCandidate, final JointIndexQuery jointQuery, final IndexSerializer serializer, final OrderList orders) {\n-        if (indexCandidate.getIndex().isCompositeIndex()) {\n-            jointQuery.add((CompositeIndexType) indexCandidate.getIndex(), serializer.getQuery(\n-                (CompositeIndexType) indexCandidate.getIndex(), (List<Object[]>) indexCandidate.getSubCondition()));\n-        } else {\n-            jointQuery.add((MixedIndexType) indexCandidate.getIndex(), serializer.getQuery(\n-                (MixedIndexType) indexCandidate.getIndex(), (Condition) indexCandidate.getSubCondition(), orders));\n-        }\n-    }\n+    SelectedIndexQuery selectIndices(final Set<IndexType> indexCandidates,\n+                                     final MultiCondition<JanusGraphElement> conditions,\n+                                     final Set<Condition> coveredClauses, OrderList orders,\n+                                     IndexSerializer serializer);\n \n     static boolean indexCoversOrder(MixedIndexType index, OrderList orders) {\n         for (int i = 0; i < orders.size(); i++) {\n-            if (!index.indexesKey(orders.getKey(i))) return false;\n+            if (!index.indexesKey(orders.getKey(i)))\n+                return false;\n         }\n         return true;\n     }\n \n-    static List<Object[]> indexCover(final CompositeIndexType index, Condition<JanusGraphElement> condition,\n-                                     Set<Condition> covered) {\n-        if (!QueryUtil.isQueryNormalForm(condition)) {\n-            return null;\n-        }\n-        assert condition instanceof And;\n-        if (index.getStatus()!= SchemaStatus.ENABLED) return null;\n-        final IndexField[] fields = index.getFieldKeys();\n-        final Object[] indexValues = new Object[fields.length];\n-        final Set<Condition> coveredClauses = new HashSet<>(fields.length);\n-        final List<Object[]> indexCovers = new ArrayList<>(4);\n-\n-        constructIndexCover(indexValues,0,fields,condition,indexCovers,coveredClauses);\n-        if (!indexCovers.isEmpty()) {\n-            covered.addAll(coveredClauses);\n-            return indexCovers;\n-        } else return null;\n-    }\n-\n-    static void constructIndexCover(Object[] indexValues, int position, IndexField[] fields,\n-                                    Condition<JanusGraphElement> condition,\n-                                    List<Object[]> indexCovers, Set<Condition> coveredClauses) {\n-        if (position>=fields.length) {\n-            indexCovers.add(indexValues);\n-        } else {\n-            final IndexField field = fields[position];\n-            final Map.Entry<Condition,Collection<Object>> equalCon = getEqualityConditionValues(condition,field.getFieldKey());\n-            if (equalCon!=null) {\n-                coveredClauses.add(equalCon.getKey());\n-                assert equalCon.getValue().size()>0;\n-                for (final Object value : equalCon.getValue()) {\n-                    final Object[] newValues = Arrays.copyOf(indexValues,fields.length);\n-                    newValues[position]=value;\n-                    constructIndexCover(newValues,position+1,fields,condition,indexCovers,coveredClauses);\n-                }\n-            }\n-        }\n-    }\n-\n-    static Condition<JanusGraphElement> indexCover(final MixedIndexType index,\n-                                                   Condition<JanusGraphElement> condition,\n-                                                   final IndexSerializer indexInfo,\n-                                                   final Set<Condition> covered) {\n-        if (!indexInfo.features(index).supportNotQueryNormalForm() && !QueryUtil.isQueryNormalForm(condition)) {\n-            return null;\n-        }\n-        if (condition instanceof Or) {\n-            for (final Condition<JanusGraphElement> subClause : condition.getChildren()) {\n-                if (subClause instanceof And) {\n-                    for (final Condition<JanusGraphElement> subsubClause : condition.getChildren()) {\n-                        if (!coversAll(index, subsubClause,indexInfo)) {\n-                            return null;\n-                        }\n-                    }\n-                } else {\n-                    if (!coversAll(index, subClause, indexInfo)) {\n-                        return null;\n-                    }\n-                }\n-            }\n-            covered.add(condition);\n-            return condition;\n-        }\n-        assert condition instanceof And;\n-        final And<JanusGraphElement> subCondition = new And<>(condition.numChildren());\n-        for (final Condition<JanusGraphElement> subClause : condition.getChildren()) {\n-            if (coversAll(index,subClause,indexInfo)) {\n-                subCondition.add(subClause);\n-                covered.add(subClause);\n-            }\n-        }\n-        return subCondition.isEmpty()?null:subCondition;\n-    }\n+    class SelectedIndexQuery {\n+        private JointIndexQuery query;\n+        private boolean isSorted;\n \n-    static boolean coversAll(final MixedIndexType index, Condition<JanusGraphElement> condition,\n-                             IndexSerializer indexInfo) {\n-        if (condition.getType()!=Condition.Type.LITERAL) {\n-            return StreamSupport.stream(condition.getChildren().spliterator(), false)\n-                .allMatch(child -> coversAll(index, child, indexInfo));\n-        }\n-        if (!(condition instanceof PredicateCondition)) {\n-            return false;\n+        public SelectedIndexQuery(JointIndexQuery query, boolean isSorted) {\n+            this.query = query;\n+            this.isSorted = isSorted;\n         }\n-        final PredicateCondition<RelationType, JanusGraphElement> atom = (PredicateCondition) condition;\n-        if (atom.getValue() == null) {\n-            return false;\n-        }\n-\n-        Preconditions.checkArgument(atom.getKey().isPropertyKey());\n-        final PropertyKey key = (PropertyKey) atom.getKey();\n-        final ParameterIndexField[] fields = index.getFieldKeys();\n-        final ParameterIndexField match = Arrays.stream(fields)\n-            .filter(field -> field.getStatus() == SchemaStatus.ENABLED)\n-            .filter(field -> field.getFieldKey().equals(key))\n-            .findAny().orElse(null);\n-        return match != null && indexInfo.supports(index, match, atom.getPredicate());\n-    }\n \n-    static Map.Entry<Condition,Collection<Object>> getEqualityConditionValues(\n-        Condition<JanusGraphElement> condition, RelationType type) {\n-        for (final Condition c : condition.getChildren()) {\n-            if (c instanceof Or) {\n-                final Map.Entry<RelationType,Collection> orEqual = QueryUtil.extractOrCondition((Or)c);\n-                if (orEqual!=null && orEqual.getKey().equals(type) && !orEqual.getValue().isEmpty()) {\n-                    return new AbstractMap.SimpleImmutableEntry(c,orEqual.getValue());\n-                }\n-            } else if (c instanceof PredicateCondition) {\n-                final PredicateCondition<RelationType, JanusGraphRelation> atom = (PredicateCondition)c;\n-                if (atom.getKey().equals(type) && atom.getPredicate()== Cmp.EQUAL && atom.getValue()!=null) {\n-                    return new AbstractMap.SimpleImmutableEntry(c,Collections.singletonList(atom.getValue()));\n-                }\n-            }\n+        public JointIndexQuery getQuery() { return query; }\n \n-        }\n-        return null;\n+        public boolean isSorted() { return isSorted; }\n     }\n }\n", "next_change": null}]}}, {"oid": "66304b76615d6af481324508dcefc0844d0ddd65", "url": "https://github.com/JanusGraph/janusgraph/commit/66304b76615d6af481324508dcefc0844d0ddd65", "message": "Cleanup\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-05-27T08:10:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MDM4NA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430980384", "body": "I think we can add `indexSelector` as a dependency to this constructor instead of initializing it here to follow DI", "bodyText": "I think we can add indexSelector as a dependency to this constructor instead of initializing it here to follow DI", "bodyHTML": "<p dir=\"auto\">I think we can add <code>indexSelector</code> as a dependency to this constructor instead of initializing it here to follow DI</p>", "author": "porunov", "createdAt": "2020-05-27T09:24:52Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java", "diffHunk": "@@ -81,13 +81,21 @@\n      * Whether smart limit adjustment is enabled\n      */\n     private boolean useSmartLimit;\n+    /**\n+     * Selection service for the best combination of indexes to be queried\n+     */\n+    private IndexSelectionStrategy indexSelector;\n \n     public GraphCentricQueryBuilder(StandardJanusGraphTx tx, IndexSerializer serializer) {\n         Preconditions.checkNotNull(tx);\n         Preconditions.checkNotNull(serializer);\n         useSmartLimit = tx.getGraph().getConfiguration().adjustQueryLimit();\n         this.tx = tx;\n         this.serializer = serializer;\n+        this.indexSelector =\n+            new ThresholdBasedIndexSelectionStrategy(tx.getGraph().getConfiguration().getIndexSelectThreshold(),\n+                new BruteForceIndexSelectionStrategy(),\n+                new ApproximateIndexSelectionStrategy());", "originalCommit": "66304b76615d6af481324508dcefc0844d0ddd65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAwNDgxMw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431004813", "bodyText": "Are you ok with configuring it in StandardJanusGraph?", "author": "rngcntr", "createdAt": "2020-05-27T10:06:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MDM4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAwNjg2Ng==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431006866", "bodyText": "Also, I guess indexSelectThreshold doesn't change from query to query, so we don't need to create a new implementation of a strategy each time. We should create indexSelectionStrategy only once when we establish a connection.", "author": "porunov", "createdAt": "2020-05-27T10:10:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MDM4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxMTU4MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431011580", "bodyText": "I assume this is a \"yes\" \ud83d\ude04", "author": "rngcntr", "createdAt": "2020-05-27T10:19:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MDM4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxNjQzOA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431016438", "bodyText": "Ah, I didn't see you past comment) Yes, configuring it in StandardJanusGraph looks good!", "author": "porunov", "createdAt": "2020-05-27T10:28:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MDM4NA=="}], "type": "inlineReview", "revised_code": {"commit": "ee9cf61ceaaa7f1cb3223e429f2ae820977b8e2f", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java\nindex a16937904..1cd7e7120 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java\n", "chunk": "@@ -86,16 +82,13 @@ public class GraphCentricQueryBuilder implements JanusGraphQuery<GraphCentricQue\n      */\n     private IndexSelectionStrategy indexSelector;\n \n-    public GraphCentricQueryBuilder(StandardJanusGraphTx tx, IndexSerializer serializer) {\n+    public GraphCentricQueryBuilder(StandardJanusGraphTx tx, IndexSerializer serializer, IndexSelectionStrategy indexSelector) {\n         Preconditions.checkNotNull(tx);\n         Preconditions.checkNotNull(serializer);\n         useSmartLimit = tx.getGraph().getConfiguration().adjustQueryLimit();\n         this.tx = tx;\n         this.serializer = serializer;\n-        this.indexSelector =\n-            new ThresholdBasedIndexSelectionStrategy(tx.getGraph().getConfiguration().getIndexSelectThreshold(),\n-                new BruteForceIndexSelectionStrategy(),\n-                new ApproximateIndexSelectionStrategy());\n+        this.indexSelector = indexSelector;\n     }\n \n     public void disableSmartLimit() {\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4Mjc3OQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430982779", "body": "Unused import", "bodyText": "Unused import", "bodyHTML": "<p dir=\"auto\">Unused import</p>", "author": "porunov", "createdAt": "2020-05-27T09:28:53Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java", "diffHunk": "@@ -31,12 +33,11 @@\n import org.janusgraph.graphdb.query.profile.QueryProfiler;\n import org.janusgraph.graphdb.transaction.StandardJanusGraphTx;\n import org.janusgraph.graphdb.types.*;\n-import org.janusgraph.graphdb.types.system.ImplicitKey;\n+import org.javatuples.Pair;", "originalCommit": "66304b76615d6af481324508dcefc0844d0ddd65", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ee9cf61ceaaa7f1cb3223e429f2ae820977b8e2f", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java\nindex a16937904..1cd7e7120 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java\n", "chunk": "@@ -33,7 +30,6 @@ import org.janusgraph.graphdb.query.condition.*;\n import org.janusgraph.graphdb.query.profile.QueryProfiler;\n import org.janusgraph.graphdb.transaction.StandardJanusGraphTx;\n import org.janusgraph.graphdb.types.*;\n-import org.javatuples.Pair;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4NDEzNQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430984135", "body": "`protected` -> `private`", "bodyText": "protected -> private", "bodyHTML": "<p dir=\"auto\"><code>protected</code> -&gt; <code>private</code></p>", "author": "porunov", "createdAt": "2020-05-27T09:31:03Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java", "diffHunk": "@@ -0,0 +1,217 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import javax.annotation.Nullable;\n+import com.google.common.base.Preconditions;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.JanusGraphRelation;\n+import org.janusgraph.core.PropertyKey;\n+import org.janusgraph.core.RelationType;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.core.schema.JanusGraphSchemaType;\n+import org.janusgraph.core.schema.SchemaStatus;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.QueryUtil;\n+import org.janusgraph.graphdb.query.condition.*;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.types.*;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n+\n+import java.util.*;\n+import java.util.stream.StreamSupport;\n+\n+public abstract class AbstractIndexSelectionStrategy {\n+    /**\n+     * Creates an <code>IndexCandidate</code> from a <code>MultiCondition</code> which it covers.\n+     * @param index\n+     * @param conditions For the condition to be valid, it needs to match these rules:\n+     *                   <ul>\n+     *                   <li>It must be an equality condition</li>\n+     *                   <li>It must not cover multiple labels</li>\n+     *                   <li>The label must match the given <code>index</code></li>\n+     *                   </ul>\n+     * @return An instance of <code>IndexCandidate</code> if the parameter <code>conditions</code> is valid, <code>null</code> else.\n+     */\n+    @Nullable\n+    protected IndexCandidate createIndexCandidate(final IndexType index, final MultiCondition<JanusGraphElement> conditions, IndexSerializer serializer) {\n+        final Set<Condition> subCover = new HashSet<>(1);\n+\n+        // Check that this index actually applies in case of a schema constraint\n+        if (index.hasSchemaTypeConstraint()) {\n+            final JanusGraphSchemaType type = index.getSchemaTypeConstraint();\n+            final Map.Entry<Condition, Collection<Object>> equalCon = getEqualityConditionValues(conditions, ImplicitKey.LABEL);\n+\n+            if (equalCon == null) {\n+                // Only equality conditions are supported\n+                return null;\n+            }\n+\n+            final Collection<Object> labels = equalCon.getValue();\n+            assert labels.size() >= 1;\n+\n+            if (labels.size() > 1) {\n+                // The query optimizer currently does not support multiple label constraints\n+                return null;\n+            }\n+            if (!type.name().equals(labels.iterator().next())) {\n+                // Given IndexType does not match given condition label\n+                return null;\n+            }\n+            subCover.add(equalCon.getKey());\n+        }\n+\n+        Object subCondition;\n+        if (index.isCompositeIndex()) {\n+            subCondition = indexCover((CompositeIndexType) index, conditions, subCover);\n+        } else {\n+            subCondition = indexCover((MixedIndexType) index, conditions, serializer, subCover);\n+        }\n+        if (subCondition == null || subCover.isEmpty()) {\n+            // Unable to initialize IndexCandidate from given parameters\n+            return null;\n+        }\n+\n+        return new IndexCandidate(index, subCover, subCondition);\n+    }\n+\n+    protected void addToJointQuery(final IndexCandidate indexCandidate, final JointIndexQuery jointQuery, final IndexSerializer serializer, final OrderList orders) {\n+        if (indexCandidate.getIndex().isCompositeIndex()) {\n+            jointQuery.add((CompositeIndexType) indexCandidate.getIndex(), serializer.getQuery(\n+                (CompositeIndexType) indexCandidate.getIndex(), (List<Object[]>) indexCandidate.getSubCondition()));\n+        } else {\n+            jointQuery.add((MixedIndexType) indexCandidate.getIndex(), serializer.getQuery(\n+                (MixedIndexType) indexCandidate.getIndex(), (Condition) indexCandidate.getSubCondition(), orders));\n+        }\n+    }\n+\n+    protected List<Object[]> indexCover(final CompositeIndexType index, Condition<JanusGraphElement> condition,", "originalCommit": "66304b76615d6af481324508dcefc0844d0ddd65", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ee9cf61ceaaa7f1cb3223e429f2ae820977b8e2f", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java\nindex c800909f8..efd9df8b4 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java\n", "chunk": "@@ -98,7 +98,7 @@ public abstract class AbstractIndexSelectionStrategy {\n         }\n     }\n \n-    protected List<Object[]> indexCover(final CompositeIndexType index, Condition<JanusGraphElement> condition,\n+    private List<Object[]> indexCover(final CompositeIndexType index, Condition<JanusGraphElement> condition,\n                                      Set<Condition> covered) {\n         if (!QueryUtil.isQueryNormalForm(condition)) {\n             return null;\n", "next_change": {"commit": "e343e5d474cc583abb6811b6a1b218780c387935", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java\nindex efd9df8b4..d34a5f9ac 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java\n", "chunk": "@@ -98,6 +103,26 @@ public abstract class AbstractIndexSelectionStrategy implements IndexSelectionSt\n         }\n     }\n \n+    protected double getConditionBasicScore(final Condition c) {\n+        if (c instanceof PredicateCondition && ((PredicateCondition) c).getPredicate() == Cmp.EQUAL) {\n+            return EQUAL_CONDITION_SCORE;\n+        } else {\n+            return OTHER_CONDITION_SCORE;\n+        }\n+    }\n+\n+    protected double getIndexTypeScore(final IndexType index) {\n+        double score = 0.0;\n+        if (index.isCompositeIndex()) {\n+            if (((CompositeIndexType)index).getCardinality() == Cardinality.SINGLE) {\n+                score = CARDINALITY_SINGE_SCORE;\n+            } else {\n+                score = CARDINALITY_OTHER_SCORE;\n+            }\n+        }\n+        return score;\n+    }\n+\n     private List<Object[]> indexCover(final CompositeIndexType index, Condition<JanusGraphElement> condition,\n                                      Set<Condition> covered) {\n         if (!QueryUtil.isQueryNormalForm(condition)) {\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4NDE5OQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430984199", "body": "`protected` -> `private`", "bodyText": "protected -> private", "bodyHTML": "<p dir=\"auto\"><code>protected</code> -&gt; <code>private</code></p>", "author": "porunov", "createdAt": "2020-05-27T09:31:09Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java", "diffHunk": "@@ -0,0 +1,217 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import javax.annotation.Nullable;\n+import com.google.common.base.Preconditions;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.JanusGraphRelation;\n+import org.janusgraph.core.PropertyKey;\n+import org.janusgraph.core.RelationType;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.core.schema.JanusGraphSchemaType;\n+import org.janusgraph.core.schema.SchemaStatus;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.QueryUtil;\n+import org.janusgraph.graphdb.query.condition.*;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.types.*;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n+\n+import java.util.*;\n+import java.util.stream.StreamSupport;\n+\n+public abstract class AbstractIndexSelectionStrategy {\n+    /**\n+     * Creates an <code>IndexCandidate</code> from a <code>MultiCondition</code> which it covers.\n+     * @param index\n+     * @param conditions For the condition to be valid, it needs to match these rules:\n+     *                   <ul>\n+     *                   <li>It must be an equality condition</li>\n+     *                   <li>It must not cover multiple labels</li>\n+     *                   <li>The label must match the given <code>index</code></li>\n+     *                   </ul>\n+     * @return An instance of <code>IndexCandidate</code> if the parameter <code>conditions</code> is valid, <code>null</code> else.\n+     */\n+    @Nullable\n+    protected IndexCandidate createIndexCandidate(final IndexType index, final MultiCondition<JanusGraphElement> conditions, IndexSerializer serializer) {\n+        final Set<Condition> subCover = new HashSet<>(1);\n+\n+        // Check that this index actually applies in case of a schema constraint\n+        if (index.hasSchemaTypeConstraint()) {\n+            final JanusGraphSchemaType type = index.getSchemaTypeConstraint();\n+            final Map.Entry<Condition, Collection<Object>> equalCon = getEqualityConditionValues(conditions, ImplicitKey.LABEL);\n+\n+            if (equalCon == null) {\n+                // Only equality conditions are supported\n+                return null;\n+            }\n+\n+            final Collection<Object> labels = equalCon.getValue();\n+            assert labels.size() >= 1;\n+\n+            if (labels.size() > 1) {\n+                // The query optimizer currently does not support multiple label constraints\n+                return null;\n+            }\n+            if (!type.name().equals(labels.iterator().next())) {\n+                // Given IndexType does not match given condition label\n+                return null;\n+            }\n+            subCover.add(equalCon.getKey());\n+        }\n+\n+        Object subCondition;\n+        if (index.isCompositeIndex()) {\n+            subCondition = indexCover((CompositeIndexType) index, conditions, subCover);\n+        } else {\n+            subCondition = indexCover((MixedIndexType) index, conditions, serializer, subCover);\n+        }\n+        if (subCondition == null || subCover.isEmpty()) {\n+            // Unable to initialize IndexCandidate from given parameters\n+            return null;\n+        }\n+\n+        return new IndexCandidate(index, subCover, subCondition);\n+    }\n+\n+    protected void addToJointQuery(final IndexCandidate indexCandidate, final JointIndexQuery jointQuery, final IndexSerializer serializer, final OrderList orders) {\n+        if (indexCandidate.getIndex().isCompositeIndex()) {\n+            jointQuery.add((CompositeIndexType) indexCandidate.getIndex(), serializer.getQuery(\n+                (CompositeIndexType) indexCandidate.getIndex(), (List<Object[]>) indexCandidate.getSubCondition()));\n+        } else {\n+            jointQuery.add((MixedIndexType) indexCandidate.getIndex(), serializer.getQuery(\n+                (MixedIndexType) indexCandidate.getIndex(), (Condition) indexCandidate.getSubCondition(), orders));\n+        }\n+    }\n+\n+    protected List<Object[]> indexCover(final CompositeIndexType index, Condition<JanusGraphElement> condition,\n+                                     Set<Condition> covered) {\n+        if (!QueryUtil.isQueryNormalForm(condition)) {\n+            return null;\n+        }\n+        assert condition instanceof And;\n+        if (index.getStatus()!= SchemaStatus.ENABLED) return null;\n+        final IndexField[] fields = index.getFieldKeys();\n+        final Object[] indexValues = new Object[fields.length];\n+        final Set<Condition> coveredClauses = new HashSet<>(fields.length);\n+        final List<Object[]> indexCovers = new ArrayList<>(4);\n+\n+        constructIndexCover(indexValues,0,fields,condition,indexCovers,coveredClauses);\n+        if (!indexCovers.isEmpty()) {\n+            covered.addAll(coveredClauses);\n+            return indexCovers;\n+        } else return null;\n+    }\n+\n+    protected void constructIndexCover(Object[] indexValues, int position, IndexField[] fields,", "originalCommit": "66304b76615d6af481324508dcefc0844d0ddd65", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ee9cf61ceaaa7f1cb3223e429f2ae820977b8e2f", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java\nindex c800909f8..efd9df8b4 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java\n", "chunk": "@@ -117,7 +117,7 @@ public abstract class AbstractIndexSelectionStrategy {\n         } else return null;\n     }\n \n-    protected void constructIndexCover(Object[] indexValues, int position, IndexField[] fields,\n+    private void constructIndexCover(Object[] indexValues, int position, IndexField[] fields,\n                                     Condition<JanusGraphElement> condition,\n                                     List<Object[]> indexCovers, Set<Condition> coveredClauses) {\n         if (position>=fields.length) {\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4NDI0OQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430984249", "body": "`protected` -> `private`", "bodyText": "protected -> private", "bodyHTML": "<p dir=\"auto\"><code>protected</code> -&gt; <code>private</code></p>", "author": "porunov", "createdAt": "2020-05-27T09:31:14Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java", "diffHunk": "@@ -0,0 +1,217 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import javax.annotation.Nullable;\n+import com.google.common.base.Preconditions;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.JanusGraphRelation;\n+import org.janusgraph.core.PropertyKey;\n+import org.janusgraph.core.RelationType;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.core.schema.JanusGraphSchemaType;\n+import org.janusgraph.core.schema.SchemaStatus;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.QueryUtil;\n+import org.janusgraph.graphdb.query.condition.*;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.types.*;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n+\n+import java.util.*;\n+import java.util.stream.StreamSupport;\n+\n+public abstract class AbstractIndexSelectionStrategy {\n+    /**\n+     * Creates an <code>IndexCandidate</code> from a <code>MultiCondition</code> which it covers.\n+     * @param index\n+     * @param conditions For the condition to be valid, it needs to match these rules:\n+     *                   <ul>\n+     *                   <li>It must be an equality condition</li>\n+     *                   <li>It must not cover multiple labels</li>\n+     *                   <li>The label must match the given <code>index</code></li>\n+     *                   </ul>\n+     * @return An instance of <code>IndexCandidate</code> if the parameter <code>conditions</code> is valid, <code>null</code> else.\n+     */\n+    @Nullable\n+    protected IndexCandidate createIndexCandidate(final IndexType index, final MultiCondition<JanusGraphElement> conditions, IndexSerializer serializer) {\n+        final Set<Condition> subCover = new HashSet<>(1);\n+\n+        // Check that this index actually applies in case of a schema constraint\n+        if (index.hasSchemaTypeConstraint()) {\n+            final JanusGraphSchemaType type = index.getSchemaTypeConstraint();\n+            final Map.Entry<Condition, Collection<Object>> equalCon = getEqualityConditionValues(conditions, ImplicitKey.LABEL);\n+\n+            if (equalCon == null) {\n+                // Only equality conditions are supported\n+                return null;\n+            }\n+\n+            final Collection<Object> labels = equalCon.getValue();\n+            assert labels.size() >= 1;\n+\n+            if (labels.size() > 1) {\n+                // The query optimizer currently does not support multiple label constraints\n+                return null;\n+            }\n+            if (!type.name().equals(labels.iterator().next())) {\n+                // Given IndexType does not match given condition label\n+                return null;\n+            }\n+            subCover.add(equalCon.getKey());\n+        }\n+\n+        Object subCondition;\n+        if (index.isCompositeIndex()) {\n+            subCondition = indexCover((CompositeIndexType) index, conditions, subCover);\n+        } else {\n+            subCondition = indexCover((MixedIndexType) index, conditions, serializer, subCover);\n+        }\n+        if (subCondition == null || subCover.isEmpty()) {\n+            // Unable to initialize IndexCandidate from given parameters\n+            return null;\n+        }\n+\n+        return new IndexCandidate(index, subCover, subCondition);\n+    }\n+\n+    protected void addToJointQuery(final IndexCandidate indexCandidate, final JointIndexQuery jointQuery, final IndexSerializer serializer, final OrderList orders) {\n+        if (indexCandidate.getIndex().isCompositeIndex()) {\n+            jointQuery.add((CompositeIndexType) indexCandidate.getIndex(), serializer.getQuery(\n+                (CompositeIndexType) indexCandidate.getIndex(), (List<Object[]>) indexCandidate.getSubCondition()));\n+        } else {\n+            jointQuery.add((MixedIndexType) indexCandidate.getIndex(), serializer.getQuery(\n+                (MixedIndexType) indexCandidate.getIndex(), (Condition) indexCandidate.getSubCondition(), orders));\n+        }\n+    }\n+\n+    protected List<Object[]> indexCover(final CompositeIndexType index, Condition<JanusGraphElement> condition,\n+                                     Set<Condition> covered) {\n+        if (!QueryUtil.isQueryNormalForm(condition)) {\n+            return null;\n+        }\n+        assert condition instanceof And;\n+        if (index.getStatus()!= SchemaStatus.ENABLED) return null;\n+        final IndexField[] fields = index.getFieldKeys();\n+        final Object[] indexValues = new Object[fields.length];\n+        final Set<Condition> coveredClauses = new HashSet<>(fields.length);\n+        final List<Object[]> indexCovers = new ArrayList<>(4);\n+\n+        constructIndexCover(indexValues,0,fields,condition,indexCovers,coveredClauses);\n+        if (!indexCovers.isEmpty()) {\n+            covered.addAll(coveredClauses);\n+            return indexCovers;\n+        } else return null;\n+    }\n+\n+    protected void constructIndexCover(Object[] indexValues, int position, IndexField[] fields,\n+                                    Condition<JanusGraphElement> condition,\n+                                    List<Object[]> indexCovers, Set<Condition> coveredClauses) {\n+        if (position>=fields.length) {\n+            indexCovers.add(indexValues);\n+        } else {\n+            final IndexField field = fields[position];\n+            final Map.Entry<Condition,Collection<Object>> equalCon = getEqualityConditionValues(condition,field.getFieldKey());\n+            if (equalCon!=null) {\n+                coveredClauses.add(equalCon.getKey());\n+                assert equalCon.getValue().size()>0;\n+                for (final Object value : equalCon.getValue()) {\n+                    final Object[] newValues = Arrays.copyOf(indexValues,fields.length);\n+                    newValues[position]=value;\n+                    constructIndexCover(newValues,position+1,fields,condition,indexCovers,coveredClauses);\n+                }\n+            }\n+        }\n+    }\n+\n+    protected Condition<JanusGraphElement> indexCover(final MixedIndexType index,", "originalCommit": "66304b76615d6af481324508dcefc0844d0ddd65", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ee9cf61ceaaa7f1cb3223e429f2ae820977b8e2f", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java\nindex c800909f8..efd9df8b4 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java\n", "chunk": "@@ -137,7 +137,7 @@ public abstract class AbstractIndexSelectionStrategy {\n         }\n     }\n \n-    protected Condition<JanusGraphElement> indexCover(final MixedIndexType index,\n+    private Condition<JanusGraphElement> indexCover(final MixedIndexType index,\n                                                    Condition<JanusGraphElement> condition,\n                                                    final IndexSerializer indexInfo,\n                                                    final Set<Condition> covered) {\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4NDM0Nw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430984347", "body": "`protected` -> `private`", "bodyText": "protected -> private", "bodyHTML": "<p dir=\"auto\"><code>protected</code> -&gt; <code>private</code></p>", "author": "porunov", "createdAt": "2020-05-27T09:31:22Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java", "diffHunk": "@@ -0,0 +1,217 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import javax.annotation.Nullable;\n+import com.google.common.base.Preconditions;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.JanusGraphRelation;\n+import org.janusgraph.core.PropertyKey;\n+import org.janusgraph.core.RelationType;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.core.schema.JanusGraphSchemaType;\n+import org.janusgraph.core.schema.SchemaStatus;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.QueryUtil;\n+import org.janusgraph.graphdb.query.condition.*;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.types.*;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n+\n+import java.util.*;\n+import java.util.stream.StreamSupport;\n+\n+public abstract class AbstractIndexSelectionStrategy {\n+    /**\n+     * Creates an <code>IndexCandidate</code> from a <code>MultiCondition</code> which it covers.\n+     * @param index\n+     * @param conditions For the condition to be valid, it needs to match these rules:\n+     *                   <ul>\n+     *                   <li>It must be an equality condition</li>\n+     *                   <li>It must not cover multiple labels</li>\n+     *                   <li>The label must match the given <code>index</code></li>\n+     *                   </ul>\n+     * @return An instance of <code>IndexCandidate</code> if the parameter <code>conditions</code> is valid, <code>null</code> else.\n+     */\n+    @Nullable\n+    protected IndexCandidate createIndexCandidate(final IndexType index, final MultiCondition<JanusGraphElement> conditions, IndexSerializer serializer) {\n+        final Set<Condition> subCover = new HashSet<>(1);\n+\n+        // Check that this index actually applies in case of a schema constraint\n+        if (index.hasSchemaTypeConstraint()) {\n+            final JanusGraphSchemaType type = index.getSchemaTypeConstraint();\n+            final Map.Entry<Condition, Collection<Object>> equalCon = getEqualityConditionValues(conditions, ImplicitKey.LABEL);\n+\n+            if (equalCon == null) {\n+                // Only equality conditions are supported\n+                return null;\n+            }\n+\n+            final Collection<Object> labels = equalCon.getValue();\n+            assert labels.size() >= 1;\n+\n+            if (labels.size() > 1) {\n+                // The query optimizer currently does not support multiple label constraints\n+                return null;\n+            }\n+            if (!type.name().equals(labels.iterator().next())) {\n+                // Given IndexType does not match given condition label\n+                return null;\n+            }\n+            subCover.add(equalCon.getKey());\n+        }\n+\n+        Object subCondition;\n+        if (index.isCompositeIndex()) {\n+            subCondition = indexCover((CompositeIndexType) index, conditions, subCover);\n+        } else {\n+            subCondition = indexCover((MixedIndexType) index, conditions, serializer, subCover);\n+        }\n+        if (subCondition == null || subCover.isEmpty()) {\n+            // Unable to initialize IndexCandidate from given parameters\n+            return null;\n+        }\n+\n+        return new IndexCandidate(index, subCover, subCondition);\n+    }\n+\n+    protected void addToJointQuery(final IndexCandidate indexCandidate, final JointIndexQuery jointQuery, final IndexSerializer serializer, final OrderList orders) {\n+        if (indexCandidate.getIndex().isCompositeIndex()) {\n+            jointQuery.add((CompositeIndexType) indexCandidate.getIndex(), serializer.getQuery(\n+                (CompositeIndexType) indexCandidate.getIndex(), (List<Object[]>) indexCandidate.getSubCondition()));\n+        } else {\n+            jointQuery.add((MixedIndexType) indexCandidate.getIndex(), serializer.getQuery(\n+                (MixedIndexType) indexCandidate.getIndex(), (Condition) indexCandidate.getSubCondition(), orders));\n+        }\n+    }\n+\n+    protected List<Object[]> indexCover(final CompositeIndexType index, Condition<JanusGraphElement> condition,\n+                                     Set<Condition> covered) {\n+        if (!QueryUtil.isQueryNormalForm(condition)) {\n+            return null;\n+        }\n+        assert condition instanceof And;\n+        if (index.getStatus()!= SchemaStatus.ENABLED) return null;\n+        final IndexField[] fields = index.getFieldKeys();\n+        final Object[] indexValues = new Object[fields.length];\n+        final Set<Condition> coveredClauses = new HashSet<>(fields.length);\n+        final List<Object[]> indexCovers = new ArrayList<>(4);\n+\n+        constructIndexCover(indexValues,0,fields,condition,indexCovers,coveredClauses);\n+        if (!indexCovers.isEmpty()) {\n+            covered.addAll(coveredClauses);\n+            return indexCovers;\n+        } else return null;\n+    }\n+\n+    protected void constructIndexCover(Object[] indexValues, int position, IndexField[] fields,\n+                                    Condition<JanusGraphElement> condition,\n+                                    List<Object[]> indexCovers, Set<Condition> coveredClauses) {\n+        if (position>=fields.length) {\n+            indexCovers.add(indexValues);\n+        } else {\n+            final IndexField field = fields[position];\n+            final Map.Entry<Condition,Collection<Object>> equalCon = getEqualityConditionValues(condition,field.getFieldKey());\n+            if (equalCon!=null) {\n+                coveredClauses.add(equalCon.getKey());\n+                assert equalCon.getValue().size()>0;\n+                for (final Object value : equalCon.getValue()) {\n+                    final Object[] newValues = Arrays.copyOf(indexValues,fields.length);\n+                    newValues[position]=value;\n+                    constructIndexCover(newValues,position+1,fields,condition,indexCovers,coveredClauses);\n+                }\n+            }\n+        }\n+    }\n+\n+    protected Condition<JanusGraphElement> indexCover(final MixedIndexType index,\n+                                                   Condition<JanusGraphElement> condition,\n+                                                   final IndexSerializer indexInfo,\n+                                                   final Set<Condition> covered) {\n+        if (!indexInfo.features(index).supportNotQueryNormalForm() && !QueryUtil.isQueryNormalForm(condition)) {\n+            return null;\n+        }\n+        if (condition instanceof Or) {\n+            for (final Condition<JanusGraphElement> subClause : condition.getChildren()) {\n+                if (subClause instanceof And) {\n+                    for (final Condition<JanusGraphElement> subsubClause : condition.getChildren()) {\n+                        if (!coversAll(index, subsubClause,indexInfo)) {\n+                            return null;\n+                        }\n+                    }\n+                } else {\n+                    if (!coversAll(index, subClause, indexInfo)) {\n+                        return null;\n+                    }\n+                }\n+            }\n+            covered.add(condition);\n+            return condition;\n+        }\n+        assert condition instanceof And;\n+        final And<JanusGraphElement> subCondition = new And<>(condition.numChildren());\n+        for (final Condition<JanusGraphElement> subClause : condition.getChildren()) {\n+            if (coversAll(index,subClause,indexInfo)) {\n+                subCondition.add(subClause);\n+                covered.add(subClause);\n+            }\n+        }\n+        return subCondition.isEmpty()?null:subCondition;\n+    }\n+\n+    protected boolean coversAll(final MixedIndexType index, Condition<JanusGraphElement> condition,", "originalCommit": "66304b76615d6af481324508dcefc0844d0ddd65", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ee9cf61ceaaa7f1cb3223e429f2ae820977b8e2f", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java\nindex c800909f8..efd9df8b4 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java\n", "chunk": "@@ -172,7 +172,7 @@ public abstract class AbstractIndexSelectionStrategy {\n         return subCondition.isEmpty()?null:subCondition;\n     }\n \n-    protected boolean coversAll(final MixedIndexType index, Condition<JanusGraphElement> condition,\n+    private boolean coversAll(final MixedIndexType index, Condition<JanusGraphElement> condition,\n                              IndexSerializer indexInfo) {\n         if (condition.getType()!=Condition.Type.LITERAL) {\n             return StreamSupport.stream(condition.getChildren().spliterator(), false)\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4NDQxOA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430984418", "body": "`protected` -> `private`", "bodyText": "protected -> private", "bodyHTML": "<p dir=\"auto\"><code>protected</code> -&gt; <code>private</code></p>", "author": "porunov", "createdAt": "2020-05-27T09:31:27Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java", "diffHunk": "@@ -0,0 +1,217 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import javax.annotation.Nullable;\n+import com.google.common.base.Preconditions;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.JanusGraphRelation;\n+import org.janusgraph.core.PropertyKey;\n+import org.janusgraph.core.RelationType;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.core.schema.JanusGraphSchemaType;\n+import org.janusgraph.core.schema.SchemaStatus;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.QueryUtil;\n+import org.janusgraph.graphdb.query.condition.*;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.types.*;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n+\n+import java.util.*;\n+import java.util.stream.StreamSupport;\n+\n+public abstract class AbstractIndexSelectionStrategy {\n+    /**\n+     * Creates an <code>IndexCandidate</code> from a <code>MultiCondition</code> which it covers.\n+     * @param index\n+     * @param conditions For the condition to be valid, it needs to match these rules:\n+     *                   <ul>\n+     *                   <li>It must be an equality condition</li>\n+     *                   <li>It must not cover multiple labels</li>\n+     *                   <li>The label must match the given <code>index</code></li>\n+     *                   </ul>\n+     * @return An instance of <code>IndexCandidate</code> if the parameter <code>conditions</code> is valid, <code>null</code> else.\n+     */\n+    @Nullable\n+    protected IndexCandidate createIndexCandidate(final IndexType index, final MultiCondition<JanusGraphElement> conditions, IndexSerializer serializer) {\n+        final Set<Condition> subCover = new HashSet<>(1);\n+\n+        // Check that this index actually applies in case of a schema constraint\n+        if (index.hasSchemaTypeConstraint()) {\n+            final JanusGraphSchemaType type = index.getSchemaTypeConstraint();\n+            final Map.Entry<Condition, Collection<Object>> equalCon = getEqualityConditionValues(conditions, ImplicitKey.LABEL);\n+\n+            if (equalCon == null) {\n+                // Only equality conditions are supported\n+                return null;\n+            }\n+\n+            final Collection<Object> labels = equalCon.getValue();\n+            assert labels.size() >= 1;\n+\n+            if (labels.size() > 1) {\n+                // The query optimizer currently does not support multiple label constraints\n+                return null;\n+            }\n+            if (!type.name().equals(labels.iterator().next())) {\n+                // Given IndexType does not match given condition label\n+                return null;\n+            }\n+            subCover.add(equalCon.getKey());\n+        }\n+\n+        Object subCondition;\n+        if (index.isCompositeIndex()) {\n+            subCondition = indexCover((CompositeIndexType) index, conditions, subCover);\n+        } else {\n+            subCondition = indexCover((MixedIndexType) index, conditions, serializer, subCover);\n+        }\n+        if (subCondition == null || subCover.isEmpty()) {\n+            // Unable to initialize IndexCandidate from given parameters\n+            return null;\n+        }\n+\n+        return new IndexCandidate(index, subCover, subCondition);\n+    }\n+\n+    protected void addToJointQuery(final IndexCandidate indexCandidate, final JointIndexQuery jointQuery, final IndexSerializer serializer, final OrderList orders) {\n+        if (indexCandidate.getIndex().isCompositeIndex()) {\n+            jointQuery.add((CompositeIndexType) indexCandidate.getIndex(), serializer.getQuery(\n+                (CompositeIndexType) indexCandidate.getIndex(), (List<Object[]>) indexCandidate.getSubCondition()));\n+        } else {\n+            jointQuery.add((MixedIndexType) indexCandidate.getIndex(), serializer.getQuery(\n+                (MixedIndexType) indexCandidate.getIndex(), (Condition) indexCandidate.getSubCondition(), orders));\n+        }\n+    }\n+\n+    protected List<Object[]> indexCover(final CompositeIndexType index, Condition<JanusGraphElement> condition,\n+                                     Set<Condition> covered) {\n+        if (!QueryUtil.isQueryNormalForm(condition)) {\n+            return null;\n+        }\n+        assert condition instanceof And;\n+        if (index.getStatus()!= SchemaStatus.ENABLED) return null;\n+        final IndexField[] fields = index.getFieldKeys();\n+        final Object[] indexValues = new Object[fields.length];\n+        final Set<Condition> coveredClauses = new HashSet<>(fields.length);\n+        final List<Object[]> indexCovers = new ArrayList<>(4);\n+\n+        constructIndexCover(indexValues,0,fields,condition,indexCovers,coveredClauses);\n+        if (!indexCovers.isEmpty()) {\n+            covered.addAll(coveredClauses);\n+            return indexCovers;\n+        } else return null;\n+    }\n+\n+    protected void constructIndexCover(Object[] indexValues, int position, IndexField[] fields,\n+                                    Condition<JanusGraphElement> condition,\n+                                    List<Object[]> indexCovers, Set<Condition> coveredClauses) {\n+        if (position>=fields.length) {\n+            indexCovers.add(indexValues);\n+        } else {\n+            final IndexField field = fields[position];\n+            final Map.Entry<Condition,Collection<Object>> equalCon = getEqualityConditionValues(condition,field.getFieldKey());\n+            if (equalCon!=null) {\n+                coveredClauses.add(equalCon.getKey());\n+                assert equalCon.getValue().size()>0;\n+                for (final Object value : equalCon.getValue()) {\n+                    final Object[] newValues = Arrays.copyOf(indexValues,fields.length);\n+                    newValues[position]=value;\n+                    constructIndexCover(newValues,position+1,fields,condition,indexCovers,coveredClauses);\n+                }\n+            }\n+        }\n+    }\n+\n+    protected Condition<JanusGraphElement> indexCover(final MixedIndexType index,\n+                                                   Condition<JanusGraphElement> condition,\n+                                                   final IndexSerializer indexInfo,\n+                                                   final Set<Condition> covered) {\n+        if (!indexInfo.features(index).supportNotQueryNormalForm() && !QueryUtil.isQueryNormalForm(condition)) {\n+            return null;\n+        }\n+        if (condition instanceof Or) {\n+            for (final Condition<JanusGraphElement> subClause : condition.getChildren()) {\n+                if (subClause instanceof And) {\n+                    for (final Condition<JanusGraphElement> subsubClause : condition.getChildren()) {\n+                        if (!coversAll(index, subsubClause,indexInfo)) {\n+                            return null;\n+                        }\n+                    }\n+                } else {\n+                    if (!coversAll(index, subClause, indexInfo)) {\n+                        return null;\n+                    }\n+                }\n+            }\n+            covered.add(condition);\n+            return condition;\n+        }\n+        assert condition instanceof And;\n+        final And<JanusGraphElement> subCondition = new And<>(condition.numChildren());\n+        for (final Condition<JanusGraphElement> subClause : condition.getChildren()) {\n+            if (coversAll(index,subClause,indexInfo)) {\n+                subCondition.add(subClause);\n+                covered.add(subClause);\n+            }\n+        }\n+        return subCondition.isEmpty()?null:subCondition;\n+    }\n+\n+    protected boolean coversAll(final MixedIndexType index, Condition<JanusGraphElement> condition,\n+                             IndexSerializer indexInfo) {\n+        if (condition.getType()!=Condition.Type.LITERAL) {\n+            return StreamSupport.stream(condition.getChildren().spliterator(), false)\n+                .allMatch(child -> coversAll(index, child, indexInfo));\n+        }\n+        if (!(condition instanceof PredicateCondition)) {\n+            return false;\n+        }\n+        final PredicateCondition<RelationType, JanusGraphElement> atom = (PredicateCondition) condition;\n+        if (atom.getValue() == null) {\n+            return false;\n+        }\n+\n+        Preconditions.checkArgument(atom.getKey().isPropertyKey());\n+        final PropertyKey key = (PropertyKey) atom.getKey();\n+        final ParameterIndexField[] fields = index.getFieldKeys();\n+        final ParameterIndexField match = Arrays.stream(fields)\n+            .filter(field -> field.getStatus() == SchemaStatus.ENABLED)\n+            .filter(field -> field.getFieldKey().equals(key))\n+            .findAny().orElse(null);\n+        return match != null && indexInfo.supports(index, match, atom.getPredicate());\n+    }\n+\n+    protected Map.Entry<Condition,Collection<Object>> getEqualityConditionValues(", "originalCommit": "66304b76615d6af481324508dcefc0844d0ddd65", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ee9cf61ceaaa7f1cb3223e429f2ae820977b8e2f", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java\nindex c800909f8..efd9df8b4 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java\n", "chunk": "@@ -196,7 +196,7 @@ public abstract class AbstractIndexSelectionStrategy {\n         return match != null && indexInfo.supports(index, match, atom.getPredicate());\n     }\n \n-    protected Map.Entry<Condition,Collection<Object>> getEqualityConditionValues(\n+    private Map.Entry<Condition,Collection<Object>> getEqualityConditionValues(\n         Condition<JanusGraphElement> condition, RelationType type) {\n         for (final Condition c : condition.getChildren()) {\n             if (c instanceof Or) {\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4NzU2MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430987560", "body": "This class looks like self sufficient class. Self sufficient classes should not be `abstract`. Now it looks more like Utility class. \r\nTo make it logically abstract I suggest to add `implements IndexSelectionStrategy` but don't implement it in this class directly. Instead, children of this class will need to implement methods from `IndexSelectionStrategy`.\r\nThus, you don't need to add `implements IndexSelectionStrategy` to any children of this class.", "bodyText": "This class looks like self sufficient class. Self sufficient classes should not be abstract. Now it looks more like Utility class.\nTo make it logically abstract I suggest to add implements IndexSelectionStrategy but don't implement it in this class directly. Instead, children of this class will need to implement methods from IndexSelectionStrategy.\nThus, you don't need to add implements IndexSelectionStrategy to any children of this class.", "bodyHTML": "<p dir=\"auto\">This class looks like self sufficient class. Self sufficient classes should not be <code>abstract</code>. Now it looks more like Utility class.<br>\nTo make it logically abstract I suggest to add <code>implements IndexSelectionStrategy</code> but don't implement it in this class directly. Instead, children of this class will need to implement methods from <code>IndexSelectionStrategy</code>.<br>\nThus, you don't need to add <code>implements IndexSelectionStrategy</code> to any children of this class.</p>", "author": "porunov", "createdAt": "2020-05-27T09:36:41Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java", "diffHunk": "@@ -0,0 +1,217 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import javax.annotation.Nullable;\n+import com.google.common.base.Preconditions;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.JanusGraphRelation;\n+import org.janusgraph.core.PropertyKey;\n+import org.janusgraph.core.RelationType;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.core.schema.JanusGraphSchemaType;\n+import org.janusgraph.core.schema.SchemaStatus;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.QueryUtil;\n+import org.janusgraph.graphdb.query.condition.*;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.types.*;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n+\n+import java.util.*;\n+import java.util.stream.StreamSupport;\n+\n+public abstract class AbstractIndexSelectionStrategy {", "originalCommit": "66304b76615d6af481324508dcefc0844d0ddd65", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ee9cf61ceaaa7f1cb3223e429f2ae820977b8e2f", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java\nindex c800909f8..efd9df8b4 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java\n", "chunk": "@@ -34,7 +34,7 @@ import org.janusgraph.graphdb.types.system.ImplicitKey;\n import java.util.*;\n import java.util.stream.StreamSupport;\n \n-public abstract class AbstractIndexSelectionStrategy {\n+public abstract class AbstractIndexSelectionStrategy implements IndexSelectionStrategy {\n     /**\n      * Creates an <code>IndexCandidate</code> from a <code>MultiCondition</code> which it covers.\n      * @param index\n", "next_change": {"commit": "e343e5d474cc583abb6811b6a1b218780c387935", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java\nindex efd9df8b4..d34a5f9ac 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java\n", "chunk": "@@ -35,6 +32,14 @@ import java.util.*;\n import java.util.stream.StreamSupport;\n \n public abstract class AbstractIndexSelectionStrategy implements IndexSelectionStrategy {\n+    private static final double EQUAL_CONDITION_SCORE = 4;\n+    private static final double OTHER_CONDITION_SCORE = 1;\n+    private static final double CARDINALITY_SINGE_SCORE = 1000;\n+    private static final double CARDINALITY_OTHER_SCORE = 1000;\n+\n+    protected static final double ORDER_MATCH = 1;\n+    protected static final double ALREADY_MATCHED_ADJUSTOR = -1.1;\n+\n     /**\n      * Creates an <code>IndexCandidate</code> from a <code>MultiCondition</code> which it covers.\n      * @param index\n", "next_change": {"commit": "2e049b1f556441cf0ec7c23b48d884afa3dc9eaa", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java\nindex d34a5f9ac..fd88f64ba 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java\n", "chunk": "@@ -37,9 +37,6 @@ public abstract class AbstractIndexSelectionStrategy implements IndexSelectionSt\n     private static final double CARDINALITY_SINGE_SCORE = 1000;\n     private static final double CARDINALITY_OTHER_SCORE = 1000;\n \n-    protected static final double ORDER_MATCH = 1;\n-    protected static final double ALREADY_MATCHED_ADJUSTOR = -1.1;\n-\n     /**\n      * Creates an <code>IndexCandidate</code> from a <code>MultiCondition</code> which it covers.\n      * @param index\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4ODI4Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430988283", "body": "Mark all these fields as `final`", "bodyText": "Mark all these fields as final", "bodyHTML": "<p dir=\"auto\">Mark all these fields as <code>final</code></p>", "author": "porunov", "createdAt": "2020-05-27T09:37:56Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ThresholdBasedIndexSelectionStrategy.java", "diffHunk": "@@ -0,0 +1,64 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import java.util.Set;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.transaction.StandardJanusGraphTx;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.javatuples.Pair;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class ThresholdBasedIndexSelectionStrategy\n+    extends AbstractIndexSelectionStrategy implements IndexSelectionStrategy {\n+\n+    private int threshold;\n+\n+    private IndexSelectionStrategy usedIfLessOrEqualThreshold;\n+    private IndexSelectionStrategy usedIfGreaterThanThreshold;", "originalCommit": "66304b76615d6af481324508dcefc0844d0ddd65", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ee9cf61ceaaa7f1cb3223e429f2ae820977b8e2f", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ThresholdBasedIndexSelectionStrategy.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ThresholdBasedIndexSelectionStrategy.java\nindex 0f95d3b8c..b22fa8e4d 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ThresholdBasedIndexSelectionStrategy.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ThresholdBasedIndexSelectionStrategy.java\n", "chunk": "@@ -20,21 +20,18 @@ import org.janusgraph.graphdb.database.IndexSerializer;\n import org.janusgraph.graphdb.internal.OrderList;\n import org.janusgraph.graphdb.query.condition.Condition;\n import org.janusgraph.graphdb.query.condition.MultiCondition;\n-import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n-import org.janusgraph.graphdb.transaction.StandardJanusGraphTx;\n import org.janusgraph.graphdb.types.IndexType;\n-import org.javatuples.Pair;\n \n /**\n  * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n  */\n public class ThresholdBasedIndexSelectionStrategy\n-    extends AbstractIndexSelectionStrategy implements IndexSelectionStrategy {\n+    extends AbstractIndexSelectionStrategy {\n \n-    private int threshold;\n+    private final int threshold;\n \n-    private IndexSelectionStrategy usedIfLessOrEqualThreshold;\n-    private IndexSelectionStrategy usedIfGreaterThanThreshold;\n+    private final IndexSelectionStrategy usedIfLessOrEqualThreshold;\n+    private final IndexSelectionStrategy usedIfGreaterThanThreshold;\n \n     public ThresholdBasedIndexSelectionStrategy(int threshold,\n                                                 IndexSelectionStrategy usedIfLesOrEqualThreshold,\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4OTMwOQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430989309", "body": "Redundant boxing. I.e. use `isSorted` directly instead of `Boolean.valueOf(isSorted)`", "bodyText": "Redundant boxing. I.e. use isSorted directly instead of Boolean.valueOf(isSorted)", "bodyHTML": "<p dir=\"auto\">Redundant boxing. I.e. use <code>isSorted</code> directly instead of <code>Boolean.valueOf(isSorted)</code></p>", "author": "porunov", "createdAt": "2020-05-27T09:39:46Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ApproximateIndexSelectionStrategy.java", "diffHunk": "@@ -0,0 +1,83 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import java.util.Set;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.janusgraph.graphdb.types.MixedIndexType;\n+import org.javatuples.Pair;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class ApproximateIndexSelectionStrategy\n+    extends AbstractIndexSelectionStrategy implements IndexSelectionStrategy {\n+\n+    /**\n+     * Iterate over all potential indexes and compute a score based on how many clauses\n+     * this index covers. The index with the highest score (as long as it covers at least one\n+     * additional clause) is picked and added to the joint query for as long as such exist.\n+     */\n+    @Override\n+    public SelectedIndexQuery selectIndices(final Set<IndexType> rawCandidates,\n+                                            final MultiCondition<JanusGraphElement> conditions,\n+                                            final Set<Condition> coveredClauses, OrderList orders,\n+                                            IndexSerializer serializer) {\n+        final JointIndexQuery jointQuery = new JointIndexQuery();\n+        boolean isSorted = orders.isEmpty();\n+        while (true) {\n+            IndexCandidate bestCandidate = null;\n+            boolean candidateSupportsSort = false;\n+\n+            for (final IndexType index : rawCandidates) {\n+                final IndexCandidate indexCandidate =\n+                    createIndexCandidate(index, conditions, serializer);\n+                if (indexCandidate == null) {\n+                    continue;\n+                }\n+\n+                boolean supportsSort =\n+                    orders.isEmpty() ||\n+                    coveredClauses.isEmpty() && index.isMixedIndex() &&\n+                        IndexSelectionStrategy.indexCoversOrder((MixedIndexType) index, orders);\n+                indexCandidate.calculateScoreApproximation(coveredClauses, supportsSort);\n+\n+                if (!indexCandidate.isCoveredBy(coveredClauses) &&\n+                    (bestCandidate == null ||\n+                     indexCandidate.getScore() > bestCandidate.getScore())) {\n+                    bestCandidate = indexCandidate;\n+                    candidateSupportsSort = supportsSort;\n+                }\n+            }\n+\n+            if (bestCandidate != null) {\n+                if (coveredClauses.isEmpty()) {\n+                    isSorted = candidateSupportsSort;\n+                }\n+                coveredClauses.addAll(bestCandidate.getSubCover());\n+                addToJointQuery(bestCandidate, jointQuery, serializer, orders);\n+            } else {\n+                break;\n+            }\n+        }\n+        return new SelectedIndexQuery(jointQuery, Boolean.valueOf(isSorted));", "originalCommit": "66304b76615d6af481324508dcefc0844d0ddd65", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ee9cf61ceaaa7f1cb3223e429f2ae820977b8e2f", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ApproximateIndexSelectionStrategy.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ApproximateIndexSelectionStrategy.java\nindex fc7ec21e0..e501cb44b 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ApproximateIndexSelectionStrategy.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ApproximateIndexSelectionStrategy.java\n", "chunk": "@@ -78,6 +77,6 @@ public class ApproximateIndexSelectionStrategy\n                 break;\n             }\n         }\n-        return new SelectedIndexQuery(jointQuery, Boolean.valueOf(isSorted));\n+        return new SelectedIndexQuery(jointQuery, isSorted);\n     }\n }\n", "next_change": {"commit": "e343e5d474cc583abb6811b6a1b218780c387935", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ApproximateIndexSelectionStrategy.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ApproximateIndexSelectionStrategy.java\nindex e501cb44b..b08237ee5 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ApproximateIndexSelectionStrategy.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ApproximateIndexSelectionStrategy.java\n", "chunk": "@@ -79,4 +79,24 @@ public class ApproximateIndexSelectionStrategy\n         }\n         return new SelectedIndexQuery(jointQuery, isSorted);\n     }\n+\n+    private double calculateIndexCandidateScore(final IndexCandidate indexCandidate,\n+                                                final Set<Condition> coveredClauses,\n+                                                boolean supportsSort) {\n+        double score = 0.0;\n+\n+        for (final Condition c : indexCandidate.getSubCover()) {\n+            double subScore = getConditionBasicScore(c);\n+            if (coveredClauses.contains(c)) {\n+                subScore = subScore * ALREADY_MATCHED_ADJUSTOR;\n+            }\n+            score += subScore + getIndexTypeScore(indexCandidate.getIndex());\n+        }\n+\n+        if (supportsSort) {\n+            score += ORDER_MATCH;\n+        }\n+\n+        return score;\n+    }\n }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5MDE4Mg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430990182", "body": "Unused import", "bodyText": "Unused import", "bodyHTML": "<p dir=\"auto\">Unused import</p>", "author": "porunov", "createdAt": "2020-05-27T09:41:19Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/BruteForceIndexSelectionStrategy.java", "diffHunk": "@@ -0,0 +1,90 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.janusgraph.graphdb.types.MixedIndexType;\n+import org.janusgraph.util.datastructures.PowerSet;\n+import org.javatuples.Pair;", "originalCommit": "66304b76615d6af481324508dcefc0844d0ddd65", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ee9cf61ceaaa7f1cb3223e429f2ae820977b8e2f", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/BruteForceIndexSelectionStrategy.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/BruteForceIndexSelectionStrategy.java\nindex 974f476b2..7fa2ff66f 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/BruteForceIndexSelectionStrategy.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/BruteForceIndexSelectionStrategy.java\n", "chunk": "@@ -27,13 +27,12 @@ import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n import org.janusgraph.graphdb.types.IndexType;\n import org.janusgraph.graphdb.types.MixedIndexType;\n import org.janusgraph.util.datastructures.PowerSet;\n-import org.javatuples.Pair;\n \n /**\n  * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n  */\n public class BruteForceIndexSelectionStrategy\n-    extends AbstractIndexSelectionStrategy implements IndexSelectionStrategy {\n+    extends AbstractIndexSelectionStrategy {\n \n     /**\n      * Determine the best jointIndexQuery by enumerating all possibilities with exponential time\n", "next_change": null}]}, "revised_code_in_main": {"commit": "7ad753a5fecf6e4155866c7ae62a0a3da585d1e6", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/BruteForceIndexSelectionStrategy.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/BruteForceIndexSelectionStrategy.java\nindex 974f476b2..eae150a9e 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/BruteForceIndexSelectionStrategy.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/BruteForceIndexSelectionStrategy.java\n", "chunk": "@@ -27,13 +27,12 @@ import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n import org.janusgraph.graphdb.types.IndexType;\n import org.janusgraph.graphdb.types.MixedIndexType;\n import org.janusgraph.util.datastructures.PowerSet;\n-import org.javatuples.Pair;\n \n /**\n  * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n  */\n public class BruteForceIndexSelectionStrategy\n-    extends AbstractIndexSelectionStrategy implements IndexSelectionStrategy {\n+    extends AbstractIndexSelectionStrategy {\n \n     /**\n      * Determine the best jointIndexQuery by enumerating all possibilities with exponential time\n", "next_change": {"commit": "d5ca0b05dfd356824b8e0f507dff99e76755f400", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/BruteForceIndexSelectionStrategy.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/BruteForceIndexSelectionStrategy.java\nindex eae150a9e..b6b997ba3 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/BruteForceIndexSelectionStrategy.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/BruteForceIndexSelectionStrategy.java\n", "chunk": "@@ -34,6 +35,12 @@ import org.janusgraph.util.datastructures.PowerSet;\n public class BruteForceIndexSelectionStrategy\n     extends AbstractIndexSelectionStrategy {\n \n+    public static final String NAME = \"brute-force\";\n+\n+    public BruteForceIndexSelectionStrategy(Configuration config) {\n+       super(config);\n+    }\n+\n     /**\n      * Determine the best jointIndexQuery by enumerating all possibilities with exponential time\n      * complexity. Similar to Weighted Set Cover problem, to find the best choice is NP-Complete, so\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "7ad753a5fecf6e4155866c7ae62a0a3da585d1e6", "message": "Merge commit", "committedDate": null}, {"oid": "d5ca0b05dfd356824b8e0f507dff99e76755f400", "committedDate": "2020-08-28 12:46:31 +0200", "message": "Make index selection strategy configurable"}, {"oid": "0822cce3d7a50cdb530d13a363f076b18f9b14be", "committedDate": "2021-06-01 22:54:19 +0200", "message": "[Checkstyle] Optimize imports"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5MDM2NQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430990365", "body": "Unused import", "bodyText": "Unused import", "bodyHTML": "<p dir=\"auto\">Unused import</p>", "author": "porunov", "createdAt": "2020-05-27T09:41:39Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ApproximateIndexSelectionStrategy.java", "diffHunk": "@@ -0,0 +1,83 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import java.util.Set;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.janusgraph.graphdb.types.MixedIndexType;\n+import org.javatuples.Pair;", "originalCommit": "66304b76615d6af481324508dcefc0844d0ddd65", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ee9cf61ceaaa7f1cb3223e429f2ae820977b8e2f", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ApproximateIndexSelectionStrategy.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ApproximateIndexSelectionStrategy.java\nindex fc7ec21e0..e501cb44b 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ApproximateIndexSelectionStrategy.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ApproximateIndexSelectionStrategy.java\n", "chunk": "@@ -23,13 +23,12 @@ import org.janusgraph.graphdb.query.condition.MultiCondition;\n import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n import org.janusgraph.graphdb.types.IndexType;\n import org.janusgraph.graphdb.types.MixedIndexType;\n-import org.javatuples.Pair;\n \n /**\n  * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n  */\n public class ApproximateIndexSelectionStrategy\n-    extends AbstractIndexSelectionStrategy implements IndexSelectionStrategy {\n+    extends AbstractIndexSelectionStrategy {\n \n     /**\n      * Iterate over all potential indexes and compute a score based on how many clauses\n", "next_change": {"commit": "2e049b1f556441cf0ec7c23b48d884afa3dc9eaa", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ApproximateIndexSelectionStrategy.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ApproximateIndexSelectionStrategy.java\nindex e501cb44b..5f3795729 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ApproximateIndexSelectionStrategy.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ApproximateIndexSelectionStrategy.java\n", "chunk": "@@ -30,6 +30,9 @@ import org.janusgraph.graphdb.types.MixedIndexType;\n public class ApproximateIndexSelectionStrategy\n     extends AbstractIndexSelectionStrategy {\n \n+    private static final double ORDER_MATCH = 1;\n+    private static final double ALREADY_MATCHED_ADJUSTOR = -1.1;\n+\n     /**\n      * Iterate over all potential indexes and compute a score based on how many clauses\n      * this index covers. The index with the highest score (as long as it covers at least one\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5MDkyMA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430990920", "body": "Several unused imports", "bodyText": "Several unused imports", "bodyHTML": "<p dir=\"auto\">Several unused imports</p>", "author": "porunov", "createdAt": "2020-05-27T09:42:37Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ThresholdBasedIndexSelectionStrategy.java", "diffHunk": "@@ -0,0 +1,64 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import java.util.Set;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.transaction.StandardJanusGraphTx;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.javatuples.Pair;\n+", "originalCommit": "66304b76615d6af481324508dcefc0844d0ddd65", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ee9cf61ceaaa7f1cb3223e429f2ae820977b8e2f", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ThresholdBasedIndexSelectionStrategy.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ThresholdBasedIndexSelectionStrategy.java\nindex 0f95d3b8c..b22fa8e4d 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ThresholdBasedIndexSelectionStrategy.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ThresholdBasedIndexSelectionStrategy.java\n", "chunk": "@@ -20,21 +20,18 @@ import org.janusgraph.graphdb.database.IndexSerializer;\n import org.janusgraph.graphdb.internal.OrderList;\n import org.janusgraph.graphdb.query.condition.Condition;\n import org.janusgraph.graphdb.query.condition.MultiCondition;\n-import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n-import org.janusgraph.graphdb.transaction.StandardJanusGraphTx;\n import org.janusgraph.graphdb.types.IndexType;\n-import org.javatuples.Pair;\n \n /**\n  * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n  */\n public class ThresholdBasedIndexSelectionStrategy\n-    extends AbstractIndexSelectionStrategy implements IndexSelectionStrategy {\n+    extends AbstractIndexSelectionStrategy {\n \n-    private int threshold;\n+    private final int threshold;\n \n-    private IndexSelectionStrategy usedIfLessOrEqualThreshold;\n-    private IndexSelectionStrategy usedIfGreaterThanThreshold;\n+    private final IndexSelectionStrategy usedIfLessOrEqualThreshold;\n+    private final IndexSelectionStrategy usedIfGreaterThanThreshold;\n \n     public ThresholdBasedIndexSelectionStrategy(int threshold,\n                                                 IndexSelectionStrategy usedIfLesOrEqualThreshold,\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5NDE4Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430994183", "body": "This is an utility method, so I would recommend to move it to another class. I.e. something like `IndexSelectionUtil`.", "bodyText": "This is an utility method, so I would recommend to move it to another class. I.e. something like IndexSelectionUtil.", "bodyHTML": "<p dir=\"auto\">This is an utility method, so I would recommend to move it to another class. I.e. something like <code>IndexSelectionUtil</code>.</p>", "author": "porunov", "createdAt": "2020-05-27T09:48:16Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexSelectionStrategy.java", "diffHunk": "@@ -0,0 +1,57 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import java.util.*;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.types.*;\n+import org.javatuples.Pair;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public interface IndexSelectionStrategy {\n+    SelectedIndexQuery selectIndices(final Set<IndexType> indexCandidates,\n+                                     final MultiCondition<JanusGraphElement> conditions,\n+                                     final Set<Condition> coveredClauses, OrderList orders,\n+                                     IndexSerializer serializer);\n+\n+    static boolean indexCoversOrder(MixedIndexType index, OrderList orders) {\n+        for (int i = 0; i < orders.size(); i++) {\n+            if (!index.indexesKey(orders.getKey(i)))\n+                return false;\n+        }\n+        return true;\n+    }", "originalCommit": "66304b76615d6af481324508dcefc0844d0ddd65", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ee9cf61ceaaa7f1cb3223e429f2ae820977b8e2f", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexSelectionStrategy.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexSelectionStrategy.java\nindex 88941a27c..17e0bef95 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexSelectionStrategy.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexSelectionStrategy.java\n", "chunk": "@@ -33,14 +32,6 @@ public interface IndexSelectionStrategy {\n                                      final Set<Condition> coveredClauses, OrderList orders,\n                                      IndexSerializer serializer);\n \n-    static boolean indexCoversOrder(MixedIndexType index, OrderList orders) {\n-        for (int i = 0; i < orders.size(); i++) {\n-            if (!index.indexesKey(orders.getKey(i)))\n-                return false;\n-        }\n-        return true;\n-    }\n-\n     class SelectedIndexQuery {\n         private JointIndexQuery query;\n         private boolean isSorted;\n", "next_change": null}]}}, {"oid": "ee9cf61ceaaa7f1cb3223e429f2ae820977b8e2f", "url": "https://github.com/JanusGraph/janusgraph/commit/ee9cf61ceaaa7f1cb3223e429f2ae820977b8e2f", "message": "Refactor construction of index queries\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-05-27T10:19:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA0MDA3Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431040073", "body": "There is a unit test which fails due additional dependency.\r\nTo fix this test `StandardJanusGraphTxTest.testGetOrCreatePropertyKey`, add the next mock into it:\r\n```\r\nIndexSelectionStrategy indexSelectionStrategy = createMock(ThresholdBasedIndexSelectionStrategy.class);\r\nexpect(mockGraph.getIndexSelector()).andReturn(indexSelectionStrategy);\r\n```", "bodyText": "There is a unit test which fails due additional dependency.\nTo fix this test StandardJanusGraphTxTest.testGetOrCreatePropertyKey, add the next mock into it:\nIndexSelectionStrategy indexSelectionStrategy = createMock(ThresholdBasedIndexSelectionStrategy.class);\nexpect(mockGraph.getIndexSelector()).andReturn(indexSelectionStrategy);", "bodyHTML": "<p dir=\"auto\">There is a unit test which fails due additional dependency.<br>\nTo fix this test <code>StandardJanusGraphTxTest.testGetOrCreatePropertyKey</code>, add the next mock into it:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"IndexSelectionStrategy indexSelectionStrategy = createMock(ThresholdBasedIndexSelectionStrategy.class);\nexpect(mockGraph.getIndexSelector()).andReturn(indexSelectionStrategy);\n\"><pre><code>IndexSelectionStrategy indexSelectionStrategy = createMock(ThresholdBasedIndexSelectionStrategy.class);\nexpect(mockGraph.getIndexSelector()).andReturn(indexSelectionStrategy);\n</code></pre></div>", "author": "porunov", "createdAt": "2020-05-27T11:14:53Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/transaction/StandardJanusGraphTx.java", "diffHunk": "@@ -201,6 +204,7 @@ public StandardJanusGraphTx(StandardJanusGraph graph, TransactionConfiguration c\n         this.attributeHandler = graph.getDataSerializer();\n         this.edgeSerializer = graph.getEdgeSerializer();\n         this.indexSerializer = graph.getIndexSerializer();\n+        this.indexSelector = graph.getIndexSelector();", "originalCommit": "ee9cf61ceaaa7f1cb3223e429f2ae820977b8e2f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA1OTEwNw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431059107", "body": "Move to `AbstractIndexSelectionStrategy`", "bodyText": "Move to AbstractIndexSelectionStrategy", "bodyHTML": "<p dir=\"auto\">Move to <code>AbstractIndexSelectionStrategy</code></p>", "author": "porunov", "createdAt": "2020-05-27T11:53:31Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java", "diffHunk": "@@ -0,0 +1,125 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.PredicateCondition;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+\n+import java.util.Set;\n+\n+/**\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class IndexCandidate {\n+    private static final double EQUAL_CONDITION_SCORE = 4;\n+    private static final double OTHER_CONDITION_SCORE = 1;\n+    private static final double CARDINALITY_SINGE_SCORE = 1000;\n+    private static final double CARDINALITY_OTHER_SCORE = 1000;", "originalCommit": "ee9cf61ceaaa7f1cb3223e429f2ae820977b8e2f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e343e5d474cc583abb6811b6a1b218780c387935", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\nindex f821ea00a..917d256f0 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\n", "chunk": "@@ -27,20 +23,11 @@ import java.util.Set;\n  * @author Boxuan Li (liboxuan@connect.hku.hk)\n  */\n public class IndexCandidate {\n-    private static final double EQUAL_CONDITION_SCORE = 4;\n-    private static final double OTHER_CONDITION_SCORE = 1;\n-    private static final double CARDINALITY_SINGE_SCORE = 1000;\n-    private static final double CARDINALITY_OTHER_SCORE = 1000;\n-\n-    private static final double ORDER_MATCH = 1;\n-    private static final double ALREADY_MATCHED_ADJUSTOR = -1.1;\n-\n     private final IndexType index;\n     private final Set<Condition> subCover;\n     private final Object subCondition;\n \n-    // initialize with the worst possible score\n-    private double score = Double.NEGATIVE_INFINITY;\n+    private double score;\n \n     public IndexCandidate(final IndexType index,\n                           final Set<Condition> subCover,\n", "next_change": {"commit": "67cf2b50576b0d7c970f954856abb41e9c829a8d", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\nindex 917d256f0..760e2a665 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\n", "chunk": "@@ -27,7 +27,8 @@ public class IndexCandidate {\n     private final Set<Condition> subCover;\n     private final Object subCondition;\n \n-    private double score;\n+    // initialize with the worst possible score\n+    private double score = Double.NEGATIVE_INFINITY;\n \n     public IndexCandidate(final IndexType index,\n                           final Set<Condition> subCover,\n", "next_change": null}, {"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\nindex 917d256f0..760e2a665 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\n", "chunk": "@@ -35,8 +36,6 @@ public class IndexCandidate {\n         this.index = index;\n         this.subCover = subCover;\n         this.subCondition = subCondition;\n-        // initialize with the worst possible score\n-        this.score = Double.NEGATIVE_INFINITY;\n     }\n \n     public IndexType getIndex() {\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA1OTY5Nw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431059697", "body": "Move to `AbstractIndexSelectionStrategy` as `protected` methods", "bodyText": "Move to AbstractIndexSelectionStrategy as protected methods", "bodyHTML": "<p dir=\"auto\">Move to <code>AbstractIndexSelectionStrategy</code> as <code>protected</code> methods</p>", "author": "porunov", "createdAt": "2020-05-27T11:54:40Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java", "diffHunk": "@@ -0,0 +1,125 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.PredicateCondition;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+\n+import java.util.Set;\n+\n+/**\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class IndexCandidate {\n+    private static final double EQUAL_CONDITION_SCORE = 4;\n+    private static final double OTHER_CONDITION_SCORE = 1;\n+    private static final double CARDINALITY_SINGE_SCORE = 1000;\n+    private static final double CARDINALITY_OTHER_SCORE = 1000;\n+\n+    private static final double ORDER_MATCH = 1;\n+    private static final double ALREADY_MATCHED_ADJUSTOR = -1.1;\n+\n+    private final IndexType index;\n+    private final Set<Condition> subCover;\n+    private final Object subCondition;\n+\n+    // initialize with the worst possible score\n+    private double score = Double.NEGATIVE_INFINITY;\n+\n+    public IndexCandidate(final IndexType index,\n+                          final Set<Condition> subCover,\n+                          final Object subCondition) {\n+        this.index = index;\n+        this.subCover = subCover;\n+        this.subCondition = subCondition;\n+    }\n+\n+    public IndexType getIndex() {\n+        return index;\n+    }\n+\n+    public Set<Condition> getSubCover() {\n+        return subCover;\n+    }\n+\n+    public Object getSubCondition() {\n+        return subCondition;\n+    }\n+\n+    public void calculateScoreBruteForce() {\n+        score = 0.0;\n+        for (final Condition c : subCover) {\n+            score += getConditionBasicScore(c) + getIndexTypeScore(index);\n+        }\n+    }\n+\n+    public void calculateScoreApproximation(final Set<Condition> coveredClauses, boolean supportsSort) {\n+        score = 0.0;\n+\n+        for (final Condition c : subCover) {\n+            double subScore = getConditionBasicScore(c);\n+            if (coveredClauses.contains(c)) {\n+                subScore = subScore * ALREADY_MATCHED_ADJUSTOR;\n+            }\n+            score += subScore + getIndexTypeScore(index);\n+        }\n+\n+        if (supportsSort) {\n+            score += ORDER_MATCH;\n+        }\n+    }\n+\n+    public double getScore() {\n+        return score;\n+    }\n+\n+    /**\n+     * Determines if this IndexCandidate only covers clauses, which are already covered by a given set.\n+     * @param coveringClauses\n+     * @return true if the IndexCandidate is fully covered by the given set. false if not.\n+     */\n+    public boolean isCoveredBy(final Set<Condition> coveringClauses) {\n+        for (final Condition c : subCover) {\n+            if (!coveringClauses.contains(c)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private double getConditionBasicScore(final Condition c) {\n+        if (c instanceof PredicateCondition && ((PredicateCondition) c).getPredicate() == Cmp.EQUAL) {\n+            return EQUAL_CONDITION_SCORE;\n+        } else {\n+            return OTHER_CONDITION_SCORE;\n+        }\n+    }\n+\n+    private double getIndexTypeScore(final IndexType index) {\n+        double score = 0.0;\n+        if (index.isCompositeIndex()) {\n+            if (((CompositeIndexType)index).getCardinality() == Cardinality.SINGLE) {\n+                score = CARDINALITY_SINGE_SCORE;\n+            } else {\n+                score = CARDINALITY_OTHER_SCORE;\n+            }\n+        }\n+        return score;\n+    }", "originalCommit": "ee9cf61ceaaa7f1cb3223e429f2ae820977b8e2f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU4ODA4Nw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431588087", "bodyText": "What's the point in moving everything from the IndexCandidate to AbstractIndexSelectionStrategy? Why would we want to have methods that are only used for IndexCandidates in another class?", "author": "rngcntr", "createdAt": "2020-05-28T05:23:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA1OTY5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5MDg1MQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431590851", "bodyText": "To follow SOLID principles. Currently this class violates Single-responsibility principle.\n\nThe class is responsible for 2 separate algorithms. Brute force and approximation.\nThe class is responsible for both business logic (calculation logic) and data (POJO).", "author": "porunov", "createdAt": "2020-05-28T05:33:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA1OTY5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5MzIzNw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431593237", "bodyText": "Notice, those methods are not used by IndexCandidate as you are telling.\nprivate methods are used by brute force and approximation calculation logic (public methods). That calculation logic is used only in concrete strategies. Brute force calculation logic is used only in brute force strategy. Approximation calculation logic is used only in approximation strategy. Whereas getConditionBasicScore and getIndexTypeScore is general logic which is used by both score calculation logic.", "author": "porunov", "createdAt": "2020-05-28T05:41:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA1OTY5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5OTEyMw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431599123", "bodyText": "Thanks for the explanation! Nice and comprehensive \ud83d\ude04", "author": "rngcntr", "createdAt": "2020-05-28T06:01:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA1OTY5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "e343e5d474cc583abb6811b6a1b218780c387935", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\nindex f821ea00a..917d256f0 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\n", "chunk": "@@ -48,78 +35,21 @@ public class IndexCandidate {\n         this.index = index;\n         this.subCover = subCover;\n         this.subCondition = subCondition;\n+        // initialize with the worst possible score\n+        this.score = Double.NEGATIVE_INFINITY;\n     }\n \n     public IndexType getIndex() {\n         return index;\n     }\n-\n     public Set<Condition> getSubCover() {\n         return subCover;\n     }\n-\n     public Object getSubCondition() {\n         return subCondition;\n     }\n-\n-    public void calculateScoreBruteForce() {\n-        score = 0.0;\n-        for (final Condition c : subCover) {\n-            score += getConditionBasicScore(c) + getIndexTypeScore(index);\n-        }\n-    }\n-\n-    public void calculateScoreApproximation(final Set<Condition> coveredClauses, boolean supportsSort) {\n-        score = 0.0;\n-\n-        for (final Condition c : subCover) {\n-            double subScore = getConditionBasicScore(c);\n-            if (coveredClauses.contains(c)) {\n-                subScore = subScore * ALREADY_MATCHED_ADJUSTOR;\n-            }\n-            score += subScore + getIndexTypeScore(index);\n-        }\n-\n-        if (supportsSort) {\n-            score += ORDER_MATCH;\n-        }\n-    }\n-\n+    public void setScore(double newScore) { this.score = newScore; }\n     public double getScore() {\n         return score;\n     }\n-\n-    /**\n-     * Determines if this IndexCandidate only covers clauses, which are already covered by a given set.\n-     * @param coveringClauses\n-     * @return true if the IndexCandidate is fully covered by the given set. false if not.\n-     */\n-    public boolean isCoveredBy(final Set<Condition> coveringClauses) {\n-        for (final Condition c : subCover) {\n-            if (!coveringClauses.contains(c)) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    private double getConditionBasicScore(final Condition c) {\n-        if (c instanceof PredicateCondition && ((PredicateCondition) c).getPredicate() == Cmp.EQUAL) {\n-            return EQUAL_CONDITION_SCORE;\n-        } else {\n-            return OTHER_CONDITION_SCORE;\n-        }\n-    }\n-\n-    private double getIndexTypeScore(final IndexType index) {\n-        double score = 0.0;\n-        if (index.isCompositeIndex()) {\n-            if (((CompositeIndexType)index).getCardinality() == Cardinality.SINGLE) {\n-                score = CARDINALITY_SINGE_SCORE;\n-            } else {\n-                score = CARDINALITY_OTHER_SCORE;\n-            }\n-        }\n-        return score;\n-    }\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA2MDExOQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431060119", "body": "Move to `ApproximateIndexSelectionStrategy` as a `private` method. Just add another method argument (i.e. `subCover`)", "bodyText": "Move to ApproximateIndexSelectionStrategy as a private method. Just add another method argument (i.e. subCover)", "bodyHTML": "<p dir=\"auto\">Move to <code>ApproximateIndexSelectionStrategy</code> as a <code>private</code> method. Just add another method argument (i.e. <code>subCover</code>)</p>", "author": "porunov", "createdAt": "2020-05-27T11:55:32Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java", "diffHunk": "@@ -0,0 +1,125 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.PredicateCondition;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+\n+import java.util.Set;\n+\n+/**\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class IndexCandidate {\n+    private static final double EQUAL_CONDITION_SCORE = 4;\n+    private static final double OTHER_CONDITION_SCORE = 1;\n+    private static final double CARDINALITY_SINGE_SCORE = 1000;\n+    private static final double CARDINALITY_OTHER_SCORE = 1000;\n+\n+    private static final double ORDER_MATCH = 1;\n+    private static final double ALREADY_MATCHED_ADJUSTOR = -1.1;\n+\n+    private final IndexType index;\n+    private final Set<Condition> subCover;\n+    private final Object subCondition;\n+\n+    // initialize with the worst possible score\n+    private double score = Double.NEGATIVE_INFINITY;\n+\n+    public IndexCandidate(final IndexType index,\n+                          final Set<Condition> subCover,\n+                          final Object subCondition) {\n+        this.index = index;\n+        this.subCover = subCover;\n+        this.subCondition = subCondition;\n+    }\n+\n+    public IndexType getIndex() {\n+        return index;\n+    }\n+\n+    public Set<Condition> getSubCover() {\n+        return subCover;\n+    }\n+\n+    public Object getSubCondition() {\n+        return subCondition;\n+    }\n+\n+    public void calculateScoreBruteForce() {\n+        score = 0.0;\n+        for (final Condition c : subCover) {\n+            score += getConditionBasicScore(c) + getIndexTypeScore(index);\n+        }\n+    }\n+\n+    public void calculateScoreApproximation(final Set<Condition> coveredClauses, boolean supportsSort) {\n+        score = 0.0;\n+\n+        for (final Condition c : subCover) {\n+            double subScore = getConditionBasicScore(c);\n+            if (coveredClauses.contains(c)) {\n+                subScore = subScore * ALREADY_MATCHED_ADJUSTOR;\n+            }\n+            score += subScore + getIndexTypeScore(index);\n+        }\n+\n+        if (supportsSort) {\n+            score += ORDER_MATCH;\n+        }\n+    }\n+\n+    public double getScore() {\n+        return score;\n+    }\n+\n+    /**\n+     * Determines if this IndexCandidate only covers clauses, which are already covered by a given set.\n+     * @param coveringClauses\n+     * @return true if the IndexCandidate is fully covered by the given set. false if not.\n+     */\n+    public boolean isCoveredBy(final Set<Condition> coveringClauses) {\n+        for (final Condition c : subCover) {\n+            if (!coveringClauses.contains(c)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }", "originalCommit": "ee9cf61ceaaa7f1cb3223e429f2ae820977b8e2f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwMDU5MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431600590", "bodyText": "I think we can even replace this method by just calling coveringClauses.containsAll(subCover).", "author": "rngcntr", "createdAt": "2020-05-28T06:05:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA2MDExOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwMjc4Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431602783", "bodyText": "Totally agree", "author": "porunov", "createdAt": "2020-05-28T06:12:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA2MDExOQ=="}], "type": "inlineReview", "revised_code": {"commit": "e343e5d474cc583abb6811b6a1b218780c387935", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\nindex f821ea00a..917d256f0 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\n", "chunk": "@@ -48,78 +35,21 @@ public class IndexCandidate {\n         this.index = index;\n         this.subCover = subCover;\n         this.subCondition = subCondition;\n+        // initialize with the worst possible score\n+        this.score = Double.NEGATIVE_INFINITY;\n     }\n \n     public IndexType getIndex() {\n         return index;\n     }\n-\n     public Set<Condition> getSubCover() {\n         return subCover;\n     }\n-\n     public Object getSubCondition() {\n         return subCondition;\n     }\n-\n-    public void calculateScoreBruteForce() {\n-        score = 0.0;\n-        for (final Condition c : subCover) {\n-            score += getConditionBasicScore(c) + getIndexTypeScore(index);\n-        }\n-    }\n-\n-    public void calculateScoreApproximation(final Set<Condition> coveredClauses, boolean supportsSort) {\n-        score = 0.0;\n-\n-        for (final Condition c : subCover) {\n-            double subScore = getConditionBasicScore(c);\n-            if (coveredClauses.contains(c)) {\n-                subScore = subScore * ALREADY_MATCHED_ADJUSTOR;\n-            }\n-            score += subScore + getIndexTypeScore(index);\n-        }\n-\n-        if (supportsSort) {\n-            score += ORDER_MATCH;\n-        }\n-    }\n-\n+    public void setScore(double newScore) { this.score = newScore; }\n     public double getScore() {\n         return score;\n     }\n-\n-    /**\n-     * Determines if this IndexCandidate only covers clauses, which are already covered by a given set.\n-     * @param coveringClauses\n-     * @return true if the IndexCandidate is fully covered by the given set. false if not.\n-     */\n-    public boolean isCoveredBy(final Set<Condition> coveringClauses) {\n-        for (final Condition c : subCover) {\n-            if (!coveringClauses.contains(c)) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    private double getConditionBasicScore(final Condition c) {\n-        if (c instanceof PredicateCondition && ((PredicateCondition) c).getPredicate() == Cmp.EQUAL) {\n-            return EQUAL_CONDITION_SCORE;\n-        } else {\n-            return OTHER_CONDITION_SCORE;\n-        }\n-    }\n-\n-    private double getIndexTypeScore(final IndexType index) {\n-        double score = 0.0;\n-        if (index.isCompositeIndex()) {\n-            if (((CompositeIndexType)index).getCardinality() == Cardinality.SINGLE) {\n-                score = CARDINALITY_SINGE_SCORE;\n-            } else {\n-                score = CARDINALITY_OTHER_SCORE;\n-            }\n-        }\n-        return score;\n-    }\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA2MTMxMA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431061310", "body": "Move to `AbstractIndexSelectionStrategy`", "bodyText": "Move to AbstractIndexSelectionStrategy", "bodyHTML": "<p dir=\"auto\">Move to <code>AbstractIndexSelectionStrategy</code></p>", "author": "porunov", "createdAt": "2020-05-27T11:57:50Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java", "diffHunk": "@@ -0,0 +1,125 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.PredicateCondition;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+\n+import java.util.Set;\n+\n+/**\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class IndexCandidate {\n+    private static final double EQUAL_CONDITION_SCORE = 4;\n+    private static final double OTHER_CONDITION_SCORE = 1;\n+    private static final double CARDINALITY_SINGE_SCORE = 1000;\n+    private static final double CARDINALITY_OTHER_SCORE = 1000;\n+\n+    private static final double ORDER_MATCH = 1;\n+    private static final double ALREADY_MATCHED_ADJUSTOR = -1.1;", "originalCommit": "ee9cf61ceaaa7f1cb3223e429f2ae820977b8e2f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e343e5d474cc583abb6811b6a1b218780c387935", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\nindex f821ea00a..917d256f0 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\n", "chunk": "@@ -27,20 +23,11 @@ import java.util.Set;\n  * @author Boxuan Li (liboxuan@connect.hku.hk)\n  */\n public class IndexCandidate {\n-    private static final double EQUAL_CONDITION_SCORE = 4;\n-    private static final double OTHER_CONDITION_SCORE = 1;\n-    private static final double CARDINALITY_SINGE_SCORE = 1000;\n-    private static final double CARDINALITY_OTHER_SCORE = 1000;\n-\n-    private static final double ORDER_MATCH = 1;\n-    private static final double ALREADY_MATCHED_ADJUSTOR = -1.1;\n-\n     private final IndexType index;\n     private final Set<Condition> subCover;\n     private final Object subCondition;\n \n-    // initialize with the worst possible score\n-    private double score = Double.NEGATIVE_INFINITY;\n+    private double score;\n \n     public IndexCandidate(final IndexType index,\n                           final Set<Condition> subCover,\n", "next_change": {"commit": "67cf2b50576b0d7c970f954856abb41e9c829a8d", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\nindex 917d256f0..760e2a665 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\n", "chunk": "@@ -27,7 +27,8 @@ public class IndexCandidate {\n     private final Set<Condition> subCover;\n     private final Object subCondition;\n \n-    private double score;\n+    // initialize with the worst possible score\n+    private double score = Double.NEGATIVE_INFINITY;\n \n     public IndexCandidate(final IndexType index,\n                           final Set<Condition> subCover,\n", "next_change": null}, {"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\nindex 917d256f0..760e2a665 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\n", "chunk": "@@ -35,8 +36,6 @@ public class IndexCandidate {\n         this.index = index;\n         this.subCover = subCover;\n         this.subCondition = subCondition;\n-        // initialize with the worst possible score\n-        this.score = Double.NEGATIVE_INFINITY;\n     }\n \n     public IndexType getIndex() {\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA2MzI4OA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431063288", "body": "Move it to `ApproximateIndexSelectionStrategy`. You can just add necessary parameters and return a calculated score. I.e. `private double calculateScore(Set<Condition> subCover, IndexType index, final Set<Condition> coveredClauses, boolean supportsSort)`", "bodyText": "Move it to ApproximateIndexSelectionStrategy. You can just add necessary parameters and return a calculated score. I.e. private double calculateScore(Set<Condition> subCover, IndexType index, final Set<Condition> coveredClauses, boolean supportsSort)", "bodyHTML": "<p dir=\"auto\">Move it to <code>ApproximateIndexSelectionStrategy</code>. You can just add necessary parameters and return a calculated score. I.e. <code>private double calculateScore(Set&lt;Condition&gt; subCover, IndexType index, final Set&lt;Condition&gt; coveredClauses, boolean supportsSort)</code></p>", "author": "porunov", "createdAt": "2020-05-27T12:01:29Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java", "diffHunk": "@@ -0,0 +1,125 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.PredicateCondition;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+\n+import java.util.Set;\n+\n+/**\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class IndexCandidate {\n+    private static final double EQUAL_CONDITION_SCORE = 4;\n+    private static final double OTHER_CONDITION_SCORE = 1;\n+    private static final double CARDINALITY_SINGE_SCORE = 1000;\n+    private static final double CARDINALITY_OTHER_SCORE = 1000;\n+\n+    private static final double ORDER_MATCH = 1;\n+    private static final double ALREADY_MATCHED_ADJUSTOR = -1.1;\n+\n+    private final IndexType index;\n+    private final Set<Condition> subCover;\n+    private final Object subCondition;\n+\n+    // initialize with the worst possible score\n+    private double score = Double.NEGATIVE_INFINITY;\n+\n+    public IndexCandidate(final IndexType index,\n+                          final Set<Condition> subCover,\n+                          final Object subCondition) {\n+        this.index = index;\n+        this.subCover = subCover;\n+        this.subCondition = subCondition;\n+    }\n+\n+    public IndexType getIndex() {\n+        return index;\n+    }\n+\n+    public Set<Condition> getSubCover() {\n+        return subCover;\n+    }\n+\n+    public Object getSubCondition() {\n+        return subCondition;\n+    }\n+\n+    public void calculateScoreBruteForce() {\n+        score = 0.0;\n+        for (final Condition c : subCover) {\n+            score += getConditionBasicScore(c) + getIndexTypeScore(index);\n+        }\n+    }\n+\n+    public void calculateScoreApproximation(final Set<Condition> coveredClauses, boolean supportsSort) {\n+        score = 0.0;\n+\n+        for (final Condition c : subCover) {\n+            double subScore = getConditionBasicScore(c);\n+            if (coveredClauses.contains(c)) {\n+                subScore = subScore * ALREADY_MATCHED_ADJUSTOR;\n+            }\n+            score += subScore + getIndexTypeScore(index);\n+        }\n+\n+        if (supportsSort) {\n+            score += ORDER_MATCH;\n+        }\n+    }", "originalCommit": "ee9cf61ceaaa7f1cb3223e429f2ae820977b8e2f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA3Mjg3Ng==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431072876", "bodyText": "Also, you can just add a method setScore into IndexCandidate and update score after the calculation", "author": "porunov", "createdAt": "2020-05-27T12:19:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA2MzI4OA=="}], "type": "inlineReview", "revised_code": {"commit": "e343e5d474cc583abb6811b6a1b218780c387935", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\nindex f821ea00a..917d256f0 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\n", "chunk": "@@ -48,78 +35,21 @@ public class IndexCandidate {\n         this.index = index;\n         this.subCover = subCover;\n         this.subCondition = subCondition;\n+        // initialize with the worst possible score\n+        this.score = Double.NEGATIVE_INFINITY;\n     }\n \n     public IndexType getIndex() {\n         return index;\n     }\n-\n     public Set<Condition> getSubCover() {\n         return subCover;\n     }\n-\n     public Object getSubCondition() {\n         return subCondition;\n     }\n-\n-    public void calculateScoreBruteForce() {\n-        score = 0.0;\n-        for (final Condition c : subCover) {\n-            score += getConditionBasicScore(c) + getIndexTypeScore(index);\n-        }\n-    }\n-\n-    public void calculateScoreApproximation(final Set<Condition> coveredClauses, boolean supportsSort) {\n-        score = 0.0;\n-\n-        for (final Condition c : subCover) {\n-            double subScore = getConditionBasicScore(c);\n-            if (coveredClauses.contains(c)) {\n-                subScore = subScore * ALREADY_MATCHED_ADJUSTOR;\n-            }\n-            score += subScore + getIndexTypeScore(index);\n-        }\n-\n-        if (supportsSort) {\n-            score += ORDER_MATCH;\n-        }\n-    }\n-\n+    public void setScore(double newScore) { this.score = newScore; }\n     public double getScore() {\n         return score;\n     }\n-\n-    /**\n-     * Determines if this IndexCandidate only covers clauses, which are already covered by a given set.\n-     * @param coveringClauses\n-     * @return true if the IndexCandidate is fully covered by the given set. false if not.\n-     */\n-    public boolean isCoveredBy(final Set<Condition> coveringClauses) {\n-        for (final Condition c : subCover) {\n-            if (!coveringClauses.contains(c)) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    private double getConditionBasicScore(final Condition c) {\n-        if (c instanceof PredicateCondition && ((PredicateCondition) c).getPredicate() == Cmp.EQUAL) {\n-            return EQUAL_CONDITION_SCORE;\n-        } else {\n-            return OTHER_CONDITION_SCORE;\n-        }\n-    }\n-\n-    private double getIndexTypeScore(final IndexType index) {\n-        double score = 0.0;\n-        if (index.isCompositeIndex()) {\n-            if (((CompositeIndexType)index).getCardinality() == Cardinality.SINGLE) {\n-                score = CARDINALITY_SINGE_SCORE;\n-            } else {\n-                score = CARDINALITY_OTHER_SCORE;\n-            }\n-        }\n-        return score;\n-    }\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA2NDU1OA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431064558", "body": "Move it to BruteForceIndexSelectionStrategy. You can just add necessary parameters and return a calculated score. I.e. `private double calculateScore(Set<Condition> subCover, IndexType index)`", "bodyText": "Move it to BruteForceIndexSelectionStrategy. You can just add necessary parameters and return a calculated score. I.e. private double calculateScore(Set<Condition> subCover, IndexType index)", "bodyHTML": "<p dir=\"auto\">Move it to BruteForceIndexSelectionStrategy. You can just add necessary parameters and return a calculated score. I.e. <code>private double calculateScore(Set&lt;Condition&gt; subCover, IndexType index)</code></p>", "author": "porunov", "createdAt": "2020-05-27T12:03:54Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java", "diffHunk": "@@ -0,0 +1,125 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.PredicateCondition;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+\n+import java.util.Set;\n+\n+/**\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class IndexCandidate {\n+    private static final double EQUAL_CONDITION_SCORE = 4;\n+    private static final double OTHER_CONDITION_SCORE = 1;\n+    private static final double CARDINALITY_SINGE_SCORE = 1000;\n+    private static final double CARDINALITY_OTHER_SCORE = 1000;\n+\n+    private static final double ORDER_MATCH = 1;\n+    private static final double ALREADY_MATCHED_ADJUSTOR = -1.1;\n+\n+    private final IndexType index;\n+    private final Set<Condition> subCover;\n+    private final Object subCondition;\n+\n+    // initialize with the worst possible score\n+    private double score = Double.NEGATIVE_INFINITY;\n+\n+    public IndexCandidate(final IndexType index,\n+                          final Set<Condition> subCover,\n+                          final Object subCondition) {\n+        this.index = index;\n+        this.subCover = subCover;\n+        this.subCondition = subCondition;\n+    }\n+\n+    public IndexType getIndex() {\n+        return index;\n+    }\n+\n+    public Set<Condition> getSubCover() {\n+        return subCover;\n+    }\n+\n+    public Object getSubCondition() {\n+        return subCondition;\n+    }\n+\n+    public void calculateScoreBruteForce() {\n+        score = 0.0;\n+        for (final Condition c : subCover) {\n+            score += getConditionBasicScore(c) + getIndexTypeScore(index);\n+        }\n+    }", "originalCommit": "ee9cf61ceaaa7f1cb3223e429f2ae820977b8e2f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e343e5d474cc583abb6811b6a1b218780c387935", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\nindex f821ea00a..917d256f0 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\n", "chunk": "@@ -48,78 +35,21 @@ public class IndexCandidate {\n         this.index = index;\n         this.subCover = subCover;\n         this.subCondition = subCondition;\n+        // initialize with the worst possible score\n+        this.score = Double.NEGATIVE_INFINITY;\n     }\n \n     public IndexType getIndex() {\n         return index;\n     }\n-\n     public Set<Condition> getSubCover() {\n         return subCover;\n     }\n-\n     public Object getSubCondition() {\n         return subCondition;\n     }\n-\n-    public void calculateScoreBruteForce() {\n-        score = 0.0;\n-        for (final Condition c : subCover) {\n-            score += getConditionBasicScore(c) + getIndexTypeScore(index);\n-        }\n-    }\n-\n-    public void calculateScoreApproximation(final Set<Condition> coveredClauses, boolean supportsSort) {\n-        score = 0.0;\n-\n-        for (final Condition c : subCover) {\n-            double subScore = getConditionBasicScore(c);\n-            if (coveredClauses.contains(c)) {\n-                subScore = subScore * ALREADY_MATCHED_ADJUSTOR;\n-            }\n-            score += subScore + getIndexTypeScore(index);\n-        }\n-\n-        if (supportsSort) {\n-            score += ORDER_MATCH;\n-        }\n-    }\n-\n+    public void setScore(double newScore) { this.score = newScore; }\n     public double getScore() {\n         return score;\n     }\n-\n-    /**\n-     * Determines if this IndexCandidate only covers clauses, which are already covered by a given set.\n-     * @param coveringClauses\n-     * @return true if the IndexCandidate is fully covered by the given set. false if not.\n-     */\n-    public boolean isCoveredBy(final Set<Condition> coveringClauses) {\n-        for (final Condition c : subCover) {\n-            if (!coveringClauses.contains(c)) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    private double getConditionBasicScore(final Condition c) {\n-        if (c instanceof PredicateCondition && ((PredicateCondition) c).getPredicate() == Cmp.EQUAL) {\n-            return EQUAL_CONDITION_SCORE;\n-        } else {\n-            return OTHER_CONDITION_SCORE;\n-        }\n-    }\n-\n-    private double getIndexTypeScore(final IndexType index) {\n-        double score = 0.0;\n-        if (index.isCompositeIndex()) {\n-            if (((CompositeIndexType)index).getCardinality() == Cardinality.SINGLE) {\n-                score = CARDINALITY_SINGE_SCORE;\n-            } else {\n-                score = CARDINALITY_OTHER_SCORE;\n-            }\n-        }\n-        return score;\n-    }\n }\n", "next_change": null}]}}, {"oid": "e343e5d474cc583abb6811b6a1b218780c387935", "url": "https://github.com/JanusGraph/janusgraph/commit/e343e5d474cc583abb6811b6a1b218780c387935", "message": "Refactor construction of index queries\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-05-28T06:22:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwOTE0Mg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431609142", "body": "Missed on this. It is used only by `ApproximateIndexSelectionStrategy`, so I think it should be moved there", "bodyText": "Missed on this. It is used only by ApproximateIndexSelectionStrategy, so I think it should be moved there", "bodyHTML": "<p dir=\"auto\">Missed on this. It is used only by <code>ApproximateIndexSelectionStrategy</code>, so I think it should be moved there</p>", "author": "porunov", "createdAt": "2020-05-28T06:30:33Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java", "diffHunk": "@@ -0,0 +1,242 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import javax.annotation.Nullable;\n+import com.google.common.base.Preconditions;\n+import org.janusgraph.core.*;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.core.schema.JanusGraphSchemaType;\n+import org.janusgraph.core.schema.SchemaStatus;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.QueryUtil;\n+import org.janusgraph.graphdb.query.condition.*;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.types.*;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n+\n+import java.util.*;\n+import java.util.stream.StreamSupport;\n+\n+public abstract class AbstractIndexSelectionStrategy implements IndexSelectionStrategy {\n+    private static final double EQUAL_CONDITION_SCORE = 4;\n+    private static final double OTHER_CONDITION_SCORE = 1;\n+    private static final double CARDINALITY_SINGE_SCORE = 1000;\n+    private static final double CARDINALITY_OTHER_SCORE = 1000;\n+\n+    protected static final double ORDER_MATCH = 1;\n+    protected static final double ALREADY_MATCHED_ADJUSTOR = -1.1;", "originalCommit": "e343e5d474cc583abb6811b6a1b218780c387935", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY1ODExMA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431658110", "bodyText": "I briefly thought about that, but I decided (for no reason) to have all constants in one place. I'm also fine with moving them to the strategy that uses them, if it is only a single one.", "author": "rngcntr", "createdAt": "2020-05-28T08:12:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwOTE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY4MTQ0NQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431681445", "bodyText": "I think it is better to move them into a concrete strategy while they are used only by that strategy", "author": "porunov", "createdAt": "2020-05-28T08:51:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwOTE0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "2e049b1f556441cf0ec7c23b48d884afa3dc9eaa", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java\nindex d34a5f9ac..fd88f64ba 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java\n", "chunk": "@@ -37,9 +37,6 @@ public abstract class AbstractIndexSelectionStrategy implements IndexSelectionSt\n     private static final double CARDINALITY_SINGE_SCORE = 1000;\n     private static final double CARDINALITY_OTHER_SCORE = 1000;\n \n-    protected static final double ORDER_MATCH = 1;\n-    protected static final double ALREADY_MATCHED_ADJUSTOR = -1.1;\n-\n     /**\n      * Creates an <code>IndexCandidate</code> from a <code>MultiCondition</code> which it covers.\n      * @param index\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxMTQ2NQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431611465", "body": "It would be better to pass only necessary parameters to the method. Even so, we will need to pass 2 parameters (subCover and index), it is better to pass them instead of indexCandidate because `indexCandidate` has more details (which are not needed by this method, i.e. subCondition)", "bodyText": "It would be better to pass only necessary parameters to the method. Even so, we will need to pass 2 parameters (subCover and index), it is better to pass them instead of indexCandidate because indexCandidate has more details (which are not needed by this method, i.e. subCondition)", "bodyHTML": "<p dir=\"auto\">It would be better to pass only necessary parameters to the method. Even so, we will need to pass 2 parameters (subCover and index), it is better to pass them instead of indexCandidate because <code>indexCandidate</code> has more details (which are not needed by this method, i.e. subCondition)</p>", "author": "porunov", "createdAt": "2020-05-28T06:36:38Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ApproximateIndexSelectionStrategy.java", "diffHunk": "@@ -0,0 +1,102 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import java.util.Set;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.janusgraph.graphdb.types.MixedIndexType;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class ApproximateIndexSelectionStrategy\n+    extends AbstractIndexSelectionStrategy {\n+\n+    /**\n+     * Iterate over all potential indexes and compute a score based on how many clauses\n+     * this index covers. The index with the highest score (as long as it covers at least one\n+     * additional clause) is picked and added to the joint query for as long as such exist.\n+     */\n+    @Override\n+    public SelectedIndexQuery selectIndices(final Set<IndexType> rawCandidates,\n+                                            final MultiCondition<JanusGraphElement> conditions,\n+                                            final Set<Condition> coveredClauses, OrderList orders,\n+                                            IndexSerializer serializer) {\n+        final JointIndexQuery jointQuery = new JointIndexQuery();\n+        boolean isSorted = orders.isEmpty();\n+        while (true) {\n+            IndexCandidate bestCandidate = null;\n+            boolean candidateSupportsSort = false;\n+\n+            for (final IndexType index : rawCandidates) {\n+                final IndexCandidate indexCandidate =\n+                    createIndexCandidate(index, conditions, serializer);\n+                if (indexCandidate == null) {\n+                    continue;\n+                }\n+\n+                boolean supportsSort =\n+                    orders.isEmpty() ||\n+                    coveredClauses.isEmpty() && index.isMixedIndex() &&\n+                        IndexSelectionUtil.indexCoversOrder((MixedIndexType) index, orders);\n+                indexCandidate.setScore(calculateIndexCandidateScore(indexCandidate, coveredClauses, supportsSort));\n+\n+                if (!coveredClauses.containsAll(indexCandidate.getSubCover()) &&\n+                    (bestCandidate == null ||\n+                     indexCandidate.getScore() > bestCandidate.getScore())) {\n+                    bestCandidate = indexCandidate;\n+                    candidateSupportsSort = supportsSort;\n+                }\n+            }\n+\n+            if (bestCandidate != null) {\n+                if (coveredClauses.isEmpty()) {\n+                    isSorted = candidateSupportsSort;\n+                }\n+                coveredClauses.addAll(bestCandidate.getSubCover());\n+                addToJointQuery(bestCandidate, jointQuery, serializer, orders);\n+            } else {\n+                break;\n+            }\n+        }\n+        return new SelectedIndexQuery(jointQuery, isSorted);\n+    }\n+\n+    private double calculateIndexCandidateScore(final IndexCandidate indexCandidate,", "originalCommit": "e343e5d474cc583abb6811b6a1b218780c387935", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY1NTkyMw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431655923", "bodyText": "I think it's convenient to pass the entire IndexCandidate object to the score calculation. Especially as we trimmed down the class IndexCandidate to contain only relevant information and no logic, in my opinion every attribute of an IndexCandidate qualifies as a valid foundation to be considered for the calculation of a score.", "author": "rngcntr", "createdAt": "2020-05-28T08:08:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxMTQ2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY4MDkyNw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431680927", "bodyText": "Good point. Agree", "author": "porunov", "createdAt": "2020-05-28T08:50:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxMTQ2NQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxMTc5MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431611790", "body": "Same here. I would pass 2 separate arguments instead of a single but with redundant information", "bodyText": "Same here. I would pass 2 separate arguments instead of a single but with redundant information", "bodyHTML": "<p dir=\"auto\">Same here. I would pass 2 separate arguments instead of a single but with redundant information</p>", "author": "porunov", "createdAt": "2020-05-28T06:37:25Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/BruteForceIndexSelectionStrategy.java", "diffHunk": "@@ -0,0 +1,97 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.janusgraph.graphdb.types.MixedIndexType;\n+import org.janusgraph.util.datastructures.PowerSet;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class BruteForceIndexSelectionStrategy\n+    extends AbstractIndexSelectionStrategy {\n+\n+    /**\n+     * Determine the best jointIndexQuery by enumerating all possibilities with exponential time\n+     * complexity. Similar to Weighted Set Cover problem, to find the best choice is NP-Complete, so\n+     * we should be careful that the problem size MUST be small, otherwise it is more recommended to\n+     * use an approximation algorithm.\n+     */\n+    @Override\n+    public SelectedIndexQuery selectIndices(final Set<IndexType> rawCandidates,\n+                                            final MultiCondition<JanusGraphElement> conditions,\n+                                            final Set<Condition> coveredClauses, OrderList orders,\n+                                            IndexSerializer serializer) {\n+        final JointIndexQuery jointQuery = new JointIndexQuery();\n+        final Set<IndexCandidate> indexCandidates = new HashSet<>();\n+        boolean isSorted = orders.isEmpty();\n+\n+        // validate, enrich index candidates and calculate scores\n+        for (final IndexType index : rawCandidates) {\n+            IndexCandidate ic = createIndexCandidate(index, conditions, serializer);\n+            if (ic == null) {\n+                continue;\n+            }\n+            ic.setScore(calculateIndexCandidateScore(ic));\n+            indexCandidates.add(ic);\n+        }\n+\n+        IndexCandidateGroup bestGroup = null;\n+        for (Set<IndexCandidate> subset : new PowerSet<>(indexCandidates)) {\n+            if (subset.isEmpty())\n+                continue;\n+            final IndexCandidateGroup group = new IndexCandidateGroup(subset);\n+            if (group.compareTo(bestGroup) > 0) {\n+                bestGroup = group;\n+            }\n+        }\n+\n+        if (bestGroup != null) {\n+            coveredClauses.addAll(bestGroup.getCoveredClauses());\n+            List<IndexCandidate> bestIndexes = new ArrayList<>(bestGroup.getIndexCandidates());\n+            // sort indexes by score descending order\n+            bestIndexes.sort((a, b) -> Double.compare(b.getScore(), a.getScore()));\n+            // isSorted depends on the first index subquery\n+            isSorted =\n+                orders.isEmpty() || bestIndexes.get(0).getIndex().isMixedIndex() &&\n+                                        IndexSelectionUtil.indexCoversOrder(\n+                                            (MixedIndexType) bestIndexes.get(0).getIndex(), orders);\n+            for (IndexCandidate c : bestIndexes) {\n+                addToJointQuery(c, jointQuery, serializer, orders);\n+            }\n+        }\n+\n+        return new SelectedIndexQuery(jointQuery, isSorted);\n+    }\n+\n+    private double calculateIndexCandidateScore(final IndexCandidate ic) {", "originalCommit": "e343e5d474cc583abb6811b6a1b218780c387935", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNjg0Mg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431616842", "body": "I would put it back to inline initialization because:\r\n1) The field isn't final, it means that we may add a bug if we add another constructor later (i.e. forget to initialize it)\r\n2) I'm not sure about non final fields in sense of initialization. If final field is initialized only once, what about non final field? Will it be initialized with `0.0` at class fields initialization phase and them `Double.NEGATIVE_INFINITY` at constructor initialization phase? Again, not sure about it but if we use inline initialization we guarantee that it will be `Double.NEGATIVE_INFINITY` in both class fields initialization phase and constructor initialization phase.", "bodyText": "I would put it back to inline initialization because:\n\nThe field isn't final, it means that we may add a bug if we add another constructor later (i.e. forget to initialize it)\nI'm not sure about non final fields in sense of initialization. If final field is initialized only once, what about non final field? Will it be initialized with 0.0 at class fields initialization phase and them Double.NEGATIVE_INFINITY at constructor initialization phase? Again, not sure about it but if we use inline initialization we guarantee that it will be Double.NEGATIVE_INFINITY in both class fields initialization phase and constructor initialization phase.", "bodyHTML": "<p dir=\"auto\">I would put it back to inline initialization because:</p>\n<ol dir=\"auto\">\n<li>The field isn't final, it means that we may add a bug if we add another constructor later (i.e. forget to initialize it)</li>\n<li>I'm not sure about non final fields in sense of initialization. If final field is initialized only once, what about non final field? Will it be initialized with <code>0.0</code> at class fields initialization phase and them <code>Double.NEGATIVE_INFINITY</code> at constructor initialization phase? Again, not sure about it but if we use inline initialization we guarantee that it will be <code>Double.NEGATIVE_INFINITY</code> in both class fields initialization phase and constructor initialization phase.</li>\n</ol>", "author": "porunov", "createdAt": "2020-05-28T06:50:07Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java", "diffHunk": "@@ -0,0 +1,55 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.types.IndexType;\n+\n+import java.util.Set;\n+\n+/**\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class IndexCandidate {\n+    private final IndexType index;\n+    private final Set<Condition> subCover;\n+    private final Object subCondition;\n+\n+    private double score;\n+\n+    public IndexCandidate(final IndexType index,\n+                          final Set<Condition> subCover,\n+                          final Object subCondition) {\n+        this.index = index;\n+        this.subCover = subCover;\n+        this.subCondition = subCondition;\n+        // initialize with the worst possible score\n+        this.score = Double.NEGATIVE_INFINITY;", "originalCommit": "e343e5d474cc583abb6811b6a1b218780c387935", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY1Njc3Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431656773", "bodyText": "Yes, you're right. Good point.", "author": "rngcntr", "createdAt": "2020-05-28T08:10:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNjg0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "67cf2b50576b0d7c970f954856abb41e9c829a8d", "changed_code": [{"header": "diff --git a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\nindex 917d256f0..760e2a665 100644\n--- a/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\n+++ b/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java\n", "chunk": "@@ -35,8 +36,6 @@ public class IndexCandidate {\n         this.index = index;\n         this.subCover = subCover;\n         this.subCondition = subCondition;\n-        // initialize with the worst possible score\n-        this.score = Double.NEGATIVE_INFINITY;\n     }\n \n     public IndexType getIndex() {\n", "next_change": null}]}}, {"oid": "2e049b1f556441cf0ec7c23b48d884afa3dc9eaa", "url": "https://github.com/JanusGraph/janusgraph/commit/2e049b1f556441cf0ec7c23b48d884afa3dc9eaa", "message": "Refactor construction of index queries\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-05-28T09:01:43Z", "type": "forcePushed"}, {"oid": "67cf2b50576b0d7c970f954856abb41e9c829a8d", "url": "https://github.com/JanusGraph/janusgraph/commit/67cf2b50576b0d7c970f954856abb41e9c829a8d", "message": "Refactor construction of index queries\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-05-28T09:07:31Z", "type": "commit"}, {"oid": "67cf2b50576b0d7c970f954856abb41e9c829a8d", "url": "https://github.com/JanusGraph/janusgraph/commit/67cf2b50576b0d7c970f954856abb41e9c829a8d", "message": "Refactor construction of index queries\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-05-28T09:07:31Z", "type": "forcePushed"}]}