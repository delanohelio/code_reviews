{"pr_number": 1001, "pr_title": "Converting ZipkinPublisher to use a zipkin2.Reporter interface for reporting spans", "pr_author": "colestanfield", "pr_createdAt": "2020-04-03T17:07:07Z", "pr_url": "https://github.com/apple/servicetalk/pull/1001", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5MDA0OQ==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403190049", "body": "We do not use `Optional` anywhere else, can we make `localAddress` `@Nullable` instead?", "bodyText": "We do not use Optional anywhere else, can we make localAddress @Nullable instead?", "bodyHTML": "<p dir=\"auto\">We do not use <code>Optional</code> anywhere else, can we make <code>localAddress</code> <code>@Nullable</code> instead?</p>", "author": "NiteshKant", "createdAt": "2020-04-03T17:48:34Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -164,29 +84,7 @@ public Builder collectorAddress(SocketAddress collectorAddress) {\n          * @return this.\n          */\n         public Builder localAddress(InetSocketAddress localAddress) {\n-            this.localAddress = localAddress;\n-            return this;\n-        }\n-\n-        /**\n-         * Configures the format.\n-         *\n-         * @param encoder the {@link Encoder} to use.\n-         * @return this.\n-         */\n-        public Builder encoder(Encoder encoder) {\n-            this.encoder = requireNonNull(encoder);\n-            return this;\n-        }\n-\n-        /**\n-         * Configures the transport.\n-         *\n-         * @param transport the {@link Transport} to use.\n-         * @return this.\n-         */\n-        public Builder protocol(Transport transport) {\n-            this.transport = requireNonNull(transport);\n+            this.localAddress = Optional.of(requireNonNull(localAddress));", "originalCommit": "c338f88e64d8f0ca9277e32f6951a8cb24187014", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5MjMxNg==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403192316", "body": "Javadocs on this method are outdated as we do not create a `channel` here.", "bodyText": "Javadocs on this method are outdated as we do not create a channel here.", "bodyHTML": "<p dir=\"auto\">Javadocs on this method are outdated as we do not create a <code>channel</code> here.</p>", "author": "NiteshKant", "createdAt": "2020-04-03T17:51:00Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -195,61 +93,32 @@ public Builder protocol(Transport transport) {\n          * @return An interface which can publish tracing data using the zipkin API.", "originalCommit": "c338f88e64d8f0ca9277e32f6951a8cb24187014", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5MzQxMw==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403193413", "body": "As this class requires a `Reporter`, we should make it explicit by taking `Reporter<Span>` as an argument in the `build()` method. Users can pass in a noop/logging reporter if they like.", "bodyText": "As this class requires a Reporter, we should make it explicit by taking Reporter<Span> as an argument in the build() method. Users can pass in a noop/logging reporter if they like.", "bodyHTML": "<p dir=\"auto\">As this class requires a <code>Reporter</code>, we should make it explicit by taking <code>Reporter&lt;Span&gt;</code> as an argument in the <code>build()</code> method. Users can pass in a noop/logging reporter if they like.</p>", "author": "NiteshKant", "createdAt": "2020-04-03T17:52:17Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -195,61 +93,32 @@ public Builder protocol(Transport transport) {\n          * @return An interface which can publish tracing data using the zipkin API.\n          */\n         public ZipkinPublisher build() {\n-            return new ZipkinPublisher(serviceName, collectorAddress, localAddress, encoder, transport);\n-        }\n-    }\n-\n-    private ZipkinPublisher(String serviceName,\n-                            SocketAddress collectorAddress,\n-                            @Nullable InetSocketAddress localAddress,\n-                            Encoder encoder,\n-                            Transport transport) {\n-        requireNonNull(serviceName);\n-        requireNonNull(collectorAddress);\n-        requireNonNull(encoder);\n-        requireNonNull(transport);\n-\n-        endpoint = buildEndpoint(serviceName, localAddress);\n-\n-        group = createEventLoopGroup(1, new DefaultThreadFactory(\"zipkin-publisher\", true));\n-        try {\n-            final Bootstrap bootstrap = transport.buildBootstrap(group, encoder, collectorAddress);\n-            channel = bootstrap.bind(0).sync().channel();\n-        } catch (InterruptedException e) {\n-            currentThread().interrupt(); // Reset the interrupted flag.\n-            throw new IllegalStateException(\"Failed to create \" + transport + \" client\");\n-        } catch (Exception e) {\n-            logger.warn(\"Failed to create {} client\", transport, e);\n-            group.shutdownGracefully(0, 0, SECONDS);\n-            throw e;\n+            if (reporter == null) {", "originalCommit": "c338f88e64d8f0ca9277e32f6951a8cb24187014", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5NTQ5NA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403195494", "body": "Consider moving these `non-null` checks closer to where they are accepted from the user, i.e. in the `Builder`", "bodyText": "Consider moving these non-null checks closer to where they are accepted from the user, i.e. in the Builder", "bodyHTML": "<p dir=\"auto\">Consider moving these <code>non-null</code> checks closer to where they are accepted from the user, i.e. in the <code>Builder</code></p>", "author": "NiteshKant", "createdAt": "2020-04-03T17:54:33Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -19,141 +19,61 @@\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanEventListener;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanLog;\n \n-import io.netty.bootstrap.Bootstrap;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.ChannelOutboundHandlerAdapter;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.channel.EventLoopGroup;\n-import io.netty.channel.FixedRecvByteBufAllocator;\n-import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n-import io.netty.channel.socket.DatagramPacket;\n-import io.netty.util.concurrent.DefaultThreadFactory;\n import io.opentracing.tag.Tags;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import zipkin2.Endpoint;\n import zipkin2.Span;\n-import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n \n import java.io.Closeable;\n-import java.net.InetAddress;\n+import java.io.Flushable;\n+import java.io.IOException;\n import java.net.InetSocketAddress;\n-import java.net.SocketAddress;\n import java.util.Map;\n+import java.util.Optional;\n import javax.annotation.Nullable;\n \n-import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n-import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n-import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n-import static java.lang.Thread.currentThread;\n import static java.util.Objects.requireNonNull;\n-import static java.util.concurrent.TimeUnit.SECONDS;\n \n /**\n  * A publisher of {@link io.opentracing.Span}s to the zipkin transport.\n  */\n public final class ZipkinPublisher implements InMemorySpanEventListener, Closeable {\n-    private static final Logger logger = LoggerFactory.getLogger(ZipkinPublisher.class);\n \n-    /**\n-     * The default maximum {@link DatagramPacket} size.\n-     */\n-    private static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048;\n-    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n-            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+    private static final Logger logger = LoggerFactory.getLogger(ZipkinPublisher.class);\n \n+    private final Reporter<Span> reporter;\n     private final Endpoint endpoint;\n-    private final EventLoopGroup group;\n-    private final Channel channel;\n-\n-    /**\n-     * The serialization format for the zipkin write format data.\n-     */\n-    public enum Encoder {\n-        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n-        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n-\n-        final SpanBytesEncoder encoder;\n-\n-        Encoder(SpanBytesEncoder encoder) {\n-            this.encoder = encoder;\n-        }\n-    }\n \n-    /**\n-     * The networking transport to use.\n-     */\n-    public enum Transport {\n-        UDP {\n-            Bootstrap buildBootstrap(EventLoopGroup group, Encoder encoder, SocketAddress collectorAddress) {\n-                if (!(collectorAddress instanceof InetSocketAddress)) {\n-                    throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n-                            \" is invalid for transport \" + this);\n-                }\n-                return new Bootstrap()\n-                        .group(group)\n-                        .channel(datagramChannel(group))\n-                        .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n-                        .handler(new ChannelOutboundHandlerAdapter() {\n-                            @Override\n-                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n-                                if (msg instanceof Span) {\n-                                    byte[] bytes = encoder.encoder.encode((Span) msg);\n-                                    ctx.write(new DatagramPacket(Unpooled.wrappedBuffer(bytes),\n-                                            (InetSocketAddress) collectorAddress));\n-                                } else {\n-                                    ctx.write(msg, promise);\n-                                }\n-                            }\n-                        });\n-            }\n-        };\n+    private static ZipkinPublisher p = new ZipkinPublisher.Builder(\"\").build();\n \n-        abstract Bootstrap buildBootstrap(EventLoopGroup group, Encoder encoder, SocketAddress collectorAddress);\n+    private ZipkinPublisher(String serviceName,\n+                            Reporter<Span> reporter,\n+                            Optional<InetSocketAddress> localSocketAddress) {\n+        this.reporter = requireNonNull(reporter);", "originalCommit": "c338f88e64d8f0ca9277e32f6951a8cb24187014", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5NTg2OA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403195868", "body": "This can be `final`", "bodyText": "This can be final", "bodyHTML": "<p dir=\"auto\">This can be <code>final</code></p>", "author": "NiteshKant", "createdAt": "2020-04-03T17:54:58Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -19,141 +19,61 @@\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanEventListener;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanLog;\n \n-import io.netty.bootstrap.Bootstrap;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.ChannelOutboundHandlerAdapter;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.channel.EventLoopGroup;\n-import io.netty.channel.FixedRecvByteBufAllocator;\n-import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n-import io.netty.channel.socket.DatagramPacket;\n-import io.netty.util.concurrent.DefaultThreadFactory;\n import io.opentracing.tag.Tags;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import zipkin2.Endpoint;\n import zipkin2.Span;\n-import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n \n import java.io.Closeable;\n-import java.net.InetAddress;\n+import java.io.Flushable;\n+import java.io.IOException;\n import java.net.InetSocketAddress;\n-import java.net.SocketAddress;\n import java.util.Map;\n+import java.util.Optional;\n import javax.annotation.Nullable;\n \n-import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n-import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n-import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n-import static java.lang.Thread.currentThread;\n import static java.util.Objects.requireNonNull;\n-import static java.util.concurrent.TimeUnit.SECONDS;\n \n /**\n  * A publisher of {@link io.opentracing.Span}s to the zipkin transport.\n  */\n public final class ZipkinPublisher implements InMemorySpanEventListener, Closeable {\n-    private static final Logger logger = LoggerFactory.getLogger(ZipkinPublisher.class);\n \n-    /**\n-     * The default maximum {@link DatagramPacket} size.\n-     */\n-    private static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048;\n-    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n-            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+    private static final Logger logger = LoggerFactory.getLogger(ZipkinPublisher.class);\n \n+    private final Reporter<Span> reporter;\n     private final Endpoint endpoint;\n-    private final EventLoopGroup group;\n-    private final Channel channel;\n-\n-    /**\n-     * The serialization format for the zipkin write format data.\n-     */\n-    public enum Encoder {\n-        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n-        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n-\n-        final SpanBytesEncoder encoder;\n-\n-        Encoder(SpanBytesEncoder encoder) {\n-            this.encoder = encoder;\n-        }\n-    }\n \n-    /**\n-     * The networking transport to use.\n-     */\n-    public enum Transport {\n-        UDP {\n-            Bootstrap buildBootstrap(EventLoopGroup group, Encoder encoder, SocketAddress collectorAddress) {\n-                if (!(collectorAddress instanceof InetSocketAddress)) {\n-                    throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n-                            \" is invalid for transport \" + this);\n-                }\n-                return new Bootstrap()\n-                        .group(group)\n-                        .channel(datagramChannel(group))\n-                        .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n-                        .handler(new ChannelOutboundHandlerAdapter() {\n-                            @Override\n-                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n-                                if (msg instanceof Span) {\n-                                    byte[] bytes = encoder.encoder.encode((Span) msg);\n-                                    ctx.write(new DatagramPacket(Unpooled.wrappedBuffer(bytes),\n-                                            (InetSocketAddress) collectorAddress));\n-                                } else {\n-                                    ctx.write(msg, promise);\n-                                }\n-                            }\n-                        });\n-            }\n-        };\n+    private static ZipkinPublisher p = new ZipkinPublisher.Builder(\"\").build();\n \n-        abstract Bootstrap buildBootstrap(EventLoopGroup group, Encoder encoder, SocketAddress collectorAddress);\n+    private ZipkinPublisher(String serviceName,\n+                            Reporter<Span> reporter,\n+                            Optional<InetSocketAddress> localSocketAddress) {\n+        this.reporter = requireNonNull(reporter);\n+        this.endpoint = buildEndpoint(requireNonNull(serviceName), requireNonNull(localSocketAddress));\n     }\n \n     /**\n      * Builder for {@link ZipkinPublisher}.\n      */\n     public static final class Builder {\n         private String serviceName;", "originalCommit": "c338f88e64d8f0ca9277e32f6951a8cb24187014", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5NjUyMA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403196520", "body": "Looks like this is unused.", "bodyText": "Looks like this is unused.", "bodyHTML": "<p dir=\"auto\">Looks like this is unused.</p>", "author": "NiteshKant", "createdAt": "2020-04-03T17:55:39Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -19,141 +19,61 @@\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanEventListener;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanLog;\n \n-import io.netty.bootstrap.Bootstrap;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.ChannelOutboundHandlerAdapter;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.channel.EventLoopGroup;\n-import io.netty.channel.FixedRecvByteBufAllocator;\n-import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n-import io.netty.channel.socket.DatagramPacket;\n-import io.netty.util.concurrent.DefaultThreadFactory;\n import io.opentracing.tag.Tags;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import zipkin2.Endpoint;\n import zipkin2.Span;\n-import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n \n import java.io.Closeable;\n-import java.net.InetAddress;\n+import java.io.Flushable;\n+import java.io.IOException;\n import java.net.InetSocketAddress;\n-import java.net.SocketAddress;\n import java.util.Map;\n+import java.util.Optional;\n import javax.annotation.Nullable;\n \n-import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n-import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n-import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n-import static java.lang.Thread.currentThread;\n import static java.util.Objects.requireNonNull;\n-import static java.util.concurrent.TimeUnit.SECONDS;\n \n /**\n  * A publisher of {@link io.opentracing.Span}s to the zipkin transport.\n  */\n public final class ZipkinPublisher implements InMemorySpanEventListener, Closeable {\n-    private static final Logger logger = LoggerFactory.getLogger(ZipkinPublisher.class);\n \n-    /**\n-     * The default maximum {@link DatagramPacket} size.\n-     */\n-    private static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048;\n-    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n-            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+    private static final Logger logger = LoggerFactory.getLogger(ZipkinPublisher.class);\n \n+    private final Reporter<Span> reporter;\n     private final Endpoint endpoint;\n-    private final EventLoopGroup group;\n-    private final Channel channel;\n-\n-    /**\n-     * The serialization format for the zipkin write format data.\n-     */\n-    public enum Encoder {\n-        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n-        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n-\n-        final SpanBytesEncoder encoder;\n-\n-        Encoder(SpanBytesEncoder encoder) {\n-            this.encoder = encoder;\n-        }\n-    }\n \n-    /**\n-     * The networking transport to use.\n-     */\n-    public enum Transport {\n-        UDP {\n-            Bootstrap buildBootstrap(EventLoopGroup group, Encoder encoder, SocketAddress collectorAddress) {\n-                if (!(collectorAddress instanceof InetSocketAddress)) {\n-                    throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n-                            \" is invalid for transport \" + this);\n-                }\n-                return new Bootstrap()\n-                        .group(group)\n-                        .channel(datagramChannel(group))\n-                        .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n-                        .handler(new ChannelOutboundHandlerAdapter() {\n-                            @Override\n-                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n-                                if (msg instanceof Span) {\n-                                    byte[] bytes = encoder.encoder.encode((Span) msg);\n-                                    ctx.write(new DatagramPacket(Unpooled.wrappedBuffer(bytes),\n-                                            (InetSocketAddress) collectorAddress));\n-                                } else {\n-                                    ctx.write(msg, promise);\n-                                }\n-                            }\n-                        });\n-            }\n-        };\n+    private static ZipkinPublisher p = new ZipkinPublisher.Builder(\"\").build();", "originalCommit": "c338f88e64d8f0ca9277e32f6951a8cb24187014", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5NzE1Mg==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403197152", "body": "```suggestion\r\n    private ZipkinPublisher(final String serviceName,\r\n                            final Reporter<Span> reporter,\r\n                            final Optional<InetSocketAddress> localSocketAddress) {\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private ZipkinPublisher(String serviceName,\n          \n          \n            \n                                        Reporter<Span> reporter,\n          \n          \n            \n                                        Optional<InetSocketAddress> localSocketAddress) {\n          \n          \n            \n                private ZipkinPublisher(final String serviceName,\n          \n          \n            \n                                        final Reporter<Span> reporter,\n          \n          \n            \n                                        final Optional<InetSocketAddress> localSocketAddress) {", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-k\">private</span> ZipkinPublisher(<span class=\"pl-smi\">String</span> serviceName,</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                            <span class=\"pl-k\">Reporter&lt;<span class=\"pl-smi\">Span</span>&gt;</span> reporter,</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                            <span class=\"pl-k\">Optional&lt;<span class=\"pl-smi\">InetSocketAddress</span>&gt;</span> localSocketAddress) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">private</span> ZipkinPublisher(<span class=\"pl-k x x-first\">final</span><span class=\"x x-last\"> </span><span class=\"pl-smi\">String</span> serviceName,</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                            <span class=\"pl-k x x-first\">final</span><span class=\"x x-last\"> </span><span class=\"pl-k\">Reporter&lt;<span class=\"pl-smi\">Span</span>&gt;</span> reporter,</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                            <span class=\"pl-k x x-first\">final</span><span class=\"x x-last\"> </span><span class=\"pl-k\">Optional&lt;<span class=\"pl-smi\">InetSocketAddress</span>&gt;</span> localSocketAddress) {</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "NiteshKant", "createdAt": "2020-04-03T17:56:23Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -19,141 +19,61 @@\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanEventListener;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanLog;\n \n-import io.netty.bootstrap.Bootstrap;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.ChannelOutboundHandlerAdapter;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.channel.EventLoopGroup;\n-import io.netty.channel.FixedRecvByteBufAllocator;\n-import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n-import io.netty.channel.socket.DatagramPacket;\n-import io.netty.util.concurrent.DefaultThreadFactory;\n import io.opentracing.tag.Tags;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import zipkin2.Endpoint;\n import zipkin2.Span;\n-import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n \n import java.io.Closeable;\n-import java.net.InetAddress;\n+import java.io.Flushable;\n+import java.io.IOException;\n import java.net.InetSocketAddress;\n-import java.net.SocketAddress;\n import java.util.Map;\n+import java.util.Optional;\n import javax.annotation.Nullable;\n \n-import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n-import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n-import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n-import static java.lang.Thread.currentThread;\n import static java.util.Objects.requireNonNull;\n-import static java.util.concurrent.TimeUnit.SECONDS;\n \n /**\n  * A publisher of {@link io.opentracing.Span}s to the zipkin transport.\n  */\n public final class ZipkinPublisher implements InMemorySpanEventListener, Closeable {\n-    private static final Logger logger = LoggerFactory.getLogger(ZipkinPublisher.class);\n \n-    /**\n-     * The default maximum {@link DatagramPacket} size.\n-     */\n-    private static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048;\n-    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n-            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+    private static final Logger logger = LoggerFactory.getLogger(ZipkinPublisher.class);\n \n+    private final Reporter<Span> reporter;\n     private final Endpoint endpoint;\n-    private final EventLoopGroup group;\n-    private final Channel channel;\n-\n-    /**\n-     * The serialization format for the zipkin write format data.\n-     */\n-    public enum Encoder {\n-        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n-        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n-\n-        final SpanBytesEncoder encoder;\n-\n-        Encoder(SpanBytesEncoder encoder) {\n-            this.encoder = encoder;\n-        }\n-    }\n \n-    /**\n-     * The networking transport to use.\n-     */\n-    public enum Transport {\n-        UDP {\n-            Bootstrap buildBootstrap(EventLoopGroup group, Encoder encoder, SocketAddress collectorAddress) {\n-                if (!(collectorAddress instanceof InetSocketAddress)) {\n-                    throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n-                            \" is invalid for transport \" + this);\n-                }\n-                return new Bootstrap()\n-                        .group(group)\n-                        .channel(datagramChannel(group))\n-                        .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n-                        .handler(new ChannelOutboundHandlerAdapter() {\n-                            @Override\n-                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n-                                if (msg instanceof Span) {\n-                                    byte[] bytes = encoder.encoder.encode((Span) msg);\n-                                    ctx.write(new DatagramPacket(Unpooled.wrappedBuffer(bytes),\n-                                            (InetSocketAddress) collectorAddress));\n-                                } else {\n-                                    ctx.write(msg, promise);\n-                                }\n-                            }\n-                        });\n-            }\n-        };\n+    private static ZipkinPublisher p = new ZipkinPublisher.Builder(\"\").build();\n \n-        abstract Bootstrap buildBootstrap(EventLoopGroup group, Encoder encoder, SocketAddress collectorAddress);\n+    private ZipkinPublisher(String serviceName,\n+                            Reporter<Span> reporter,\n+                            Optional<InetSocketAddress> localSocketAddress) {", "originalCommit": "c338f88e64d8f0ca9277e32f6951a8cb24187014", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5ODE0NA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403198144", "body": "As this class is not doing any batching, it does not need to worry about flushing. We can move this to the entity(i.e. a `Reporter` implementation) that will do batching in the future.", "bodyText": "As this class is not doing any batching, it does not need to worry about flushing. We can move this to the entity(i.e. a Reporter implementation) that will do batching in the future.", "bodyHTML": "<p dir=\"auto\">As this class is not doing any batching, it does not need to worry about flushing. We can move this to the entity(i.e. a <code>Reporter</code> implementation) that will do batching in the future.</p>", "author": "NiteshKant", "createdAt": "2020-04-03T17:57:34Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -278,6 +147,42 @@ public void onSpanFinished(final InMemorySpan span, long durationMicros) {\n             builder.kind(Span.Kind.CLIENT);\n         }\n \n-        channel.writeAndFlush(builder.build());\n+        Span s = builder.build();\n+        reporter.report(s);\n+    }\n+\n+    @Override\n+    public void close() {\n+        if (reporter instanceof Flushable) {", "originalCommit": "c338f88e64d8f0ca9277e32f6951a8cb24187014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM2NDg3Mw==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404364873", "bodyText": "Reporters may batch and this need to flush them in case they are.", "author": "colestanfield", "createdAt": "2020-04-06T20:23:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5ODE0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5OTIxNw==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403199217", "body": "```suggestion\r\n        private final SocketAddress collectorAddress;\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private SocketAddress collectorAddress;\n          \n          \n            \n                    private final SocketAddress collectorAddress;", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">private</span> <span class=\"pl-smi\">SocketAddress</span> collectorAddress;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">private</span> <span class=\"pl-k x x-first\">final</span><span class=\"x x-last\"> </span><span class=\"pl-smi\">SocketAddress</span> collectorAddress;</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "NiteshKant", "createdAt": "2020-04-03T17:58:45Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.io.Flushable;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, Flushable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final EventLoopGroup group;\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        group = createEventLoopGroup(1, new DefaultThreadFactory(\"udp-span-reporter\", true));\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            group.shutdownGracefully(0, 0, SECONDS);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    public static final class Builder {\n+        private SocketAddress collectorAddress;", "originalCommit": "c338f88e64d8f0ca9277e32f6951a8cb24187014", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIwMDAyMw==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403200023", "body": "Javadocs are required for all `public` classes and methods.", "bodyText": "Javadocs are required for all public classes and methods.", "bodyHTML": "<p dir=\"auto\">Javadocs are required for all <code>public</code> classes and methods.</p>", "author": "NiteshKant", "createdAt": "2020-04-03T17:59:39Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.io.Flushable;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, Flushable {", "originalCommit": "c338f88e64d8f0ca9277e32f6951a8cb24187014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIyNTk4MA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403225980", "bodyText": "Also make this AsyncCloseable", "author": "NiteshKant", "createdAt": "2020-04-03T18:30:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIwMDAyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxNDU2Mw==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403214563", "body": "Few improvements here (feel free to do as a follow up):\r\n\r\n- Add a method on the `Builder` to accept an ST `IoExecutor` which can then be converted to a netty `EventLoopGroup` using [this](https://github.com/apple/servicetalk/blob/master/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/EventLoopAwareNettyIoExecutors.java#L38).\r\n- If the user does not provide an `IoExecutor` use one from the [`GlobalExecutionContext`](https://github.com/apple/servicetalk/blob/master/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/GlobalExecutionContext.java#L39)\r\n- Add a method on the `Builder` to optionally enable wire logging like we do in clients/servers and add a netty `LoggingHandler`. It is useful to debug network activity.\r\n", "bodyText": "Few improvements here (feel free to do as a follow up):\n\nAdd a method on the Builder to accept an ST IoExecutor which can then be converted to a netty EventLoopGroup using this.\nIf the user does not provide an IoExecutor use one from the GlobalExecutionContext\nAdd a method on the Builder to optionally enable wire logging like we do in clients/servers and add a netty LoggingHandler. It is useful to debug network activity.", "bodyHTML": "<p dir=\"auto\">Few improvements here (feel free to do as a follow up):</p>\n<ul dir=\"auto\">\n<li>Add a method on the <code>Builder</code> to accept an ST <code>IoExecutor</code> which can then be converted to a netty <code>EventLoopGroup</code> using <a href=\"https://github.com/apple/servicetalk/blob/master/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/EventLoopAwareNettyIoExecutors.java#L38\">this</a>.</li>\n<li>If the user does not provide an <code>IoExecutor</code> use one from the <a href=\"https://github.com/apple/servicetalk/blob/master/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/GlobalExecutionContext.java#L39\"><code>GlobalExecutionContext</code></a></li>\n<li>Add a method on the <code>Builder</code> to optionally enable wire logging like we do in clients/servers and add a netty <code>LoggingHandler</code>. It is useful to debug network activity.</li>\n</ul>", "author": "NiteshKant", "createdAt": "2020-04-03T18:16:40Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.io.Flushable;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, Flushable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final EventLoopGroup group;\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        group = createEventLoopGroup(1, new DefaultThreadFactory(\"udp-span-reporter\", true));", "originalCommit": "c338f88e64d8f0ca9277e32f6951a8cb24187014", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxNTcwMA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403215700", "body": "Can you also make this an `AsyncCloseable`? If you do `close()` can just delegate to `closeAsync()`", "bodyText": "Can you also make this an AsyncCloseable? If you do close() can just delegate to closeAsync()", "bodyHTML": "<p dir=\"auto\">Can you also make this an <code>AsyncCloseable</code>? If you do <code>close()</code> can just delegate to <code>closeAsync()</code></p>", "author": "NiteshKant", "createdAt": "2020-04-03T18:18:01Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -19,141 +19,61 @@\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanEventListener;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanLog;\n \n-import io.netty.bootstrap.Bootstrap;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.ChannelOutboundHandlerAdapter;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.channel.EventLoopGroup;\n-import io.netty.channel.FixedRecvByteBufAllocator;\n-import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n-import io.netty.channel.socket.DatagramPacket;\n-import io.netty.util.concurrent.DefaultThreadFactory;\n import io.opentracing.tag.Tags;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import zipkin2.Endpoint;\n import zipkin2.Span;\n-import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n \n import java.io.Closeable;\n-import java.net.InetAddress;\n+import java.io.Flushable;\n+import java.io.IOException;\n import java.net.InetSocketAddress;\n-import java.net.SocketAddress;\n import java.util.Map;\n+import java.util.Optional;\n import javax.annotation.Nullable;\n \n-import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n-import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n-import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n-import static java.lang.Thread.currentThread;\n import static java.util.Objects.requireNonNull;\n-import static java.util.concurrent.TimeUnit.SECONDS;\n \n /**\n  * A publisher of {@link io.opentracing.Span}s to the zipkin transport.\n  */\n public final class ZipkinPublisher implements InMemorySpanEventListener, Closeable {", "originalCommit": "c338f88e64d8f0ca9277e32f6951a8cb24187014", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxNjk1Nw==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403216957", "body": "As we are always doing `writeAndFlush()` this isn't really useful?", "bodyText": "As we are always doing writeAndFlush() this isn't really useful?", "bodyHTML": "<p dir=\"auto\">As we are always doing <code>writeAndFlush()</code> this isn't really useful?</p>", "author": "NiteshKant", "createdAt": "2020-04-03T18:19:32Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.io.Flushable;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, Flushable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final EventLoopGroup group;\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        group = createEventLoopGroup(1, new DefaultThreadFactory(\"udp-span-reporter\", true));\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            group.shutdownGracefully(0, 0, SECONDS);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    public static final class Builder {\n+        private SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         * @param collectorAddress the collector SocketAddress\n+         * @return new builder\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        public UdpReporter build() {\n+            return new UdpReporter(this);\n+        }\n+    }\n+\n+    private Bootstrap buildBootstrap(EventLoopGroup group, Codec codec, SocketAddress collectorAddress) {\n+        if (!(collectorAddress instanceof InetSocketAddress)) {\n+            throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n+                    \" is invalid for UDP\");\n+        }\n+        return new Bootstrap()\n+                .group(group)\n+                .channel(datagramChannel(group))\n+                .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n+                .handler(new ChannelOutboundHandlerAdapter() {\n+                    @Override\n+                    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+                        if (msg instanceof Span) {\n+                            byte[] bytes = codec.encoder.encode((Span) msg);\n+                            ctx.write(new DatagramPacket(Unpooled.wrappedBuffer(bytes),\n+                                    (InetSocketAddress) collectorAddress));\n+                        } else {\n+                            ctx.write(msg, promise);\n+                        }\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Non-blocking report method.\n+     * @param span the span to report\n+     */\n+    @Override\n+    public void report(final Span span) {\n+        if (closed) {\n+            throw new IllegalStateException(\"closed\");\n+        }\n+        channel.writeAndFlush(span);\n+    }\n+\n+    @Override\n+    public void flush() {", "originalCommit": "c338f88e64d8f0ca9277e32f6951a8cb24187014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM2MzkxOQ==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404363919", "bodyText": "Removed", "author": "colestanfield", "createdAt": "2020-04-06T20:21:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxNjk1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxNzc5NA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403217794", "body": "Once we do use ST's `IoExecutor` we do not need to manage the lifecycle as either it is global or managed by user.", "bodyText": "Once we do use ST's IoExecutor we do not need to manage the lifecycle as either it is global or managed by user.", "bodyHTML": "<p dir=\"auto\">Once we do use ST's <code>IoExecutor</code> we do not need to manage the lifecycle as either it is global or managed by user.</p>", "author": "NiteshKant", "createdAt": "2020-04-03T18:20:27Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.io.Flushable;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, Flushable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final EventLoopGroup group;\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        group = createEventLoopGroup(1, new DefaultThreadFactory(\"udp-span-reporter\", true));\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            group.shutdownGracefully(0, 0, SECONDS);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    public static final class Builder {\n+        private SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         * @param collectorAddress the collector SocketAddress\n+         * @return new builder\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        public UdpReporter build() {\n+            return new UdpReporter(this);\n+        }\n+    }\n+\n+    private Bootstrap buildBootstrap(EventLoopGroup group, Codec codec, SocketAddress collectorAddress) {\n+        if (!(collectorAddress instanceof InetSocketAddress)) {\n+            throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n+                    \" is invalid for UDP\");\n+        }\n+        return new Bootstrap()\n+                .group(group)\n+                .channel(datagramChannel(group))\n+                .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n+                .handler(new ChannelOutboundHandlerAdapter() {\n+                    @Override\n+                    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+                        if (msg instanceof Span) {\n+                            byte[] bytes = codec.encoder.encode((Span) msg);\n+                            ctx.write(new DatagramPacket(Unpooled.wrappedBuffer(bytes),\n+                                    (InetSocketAddress) collectorAddress));\n+                        } else {\n+                            ctx.write(msg, promise);\n+                        }\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Non-blocking report method.\n+     * @param span the span to report\n+     */\n+    @Override\n+    public void report(final Span span) {\n+        if (closed) {\n+            throw new IllegalStateException(\"closed\");\n+        }\n+        channel.writeAndFlush(span);\n+    }\n+\n+    @Override\n+    public void flush() {\n+        if (closed) {\n+            throw new IllegalStateException(\"closed\");\n+        }\n+        channel.flush();\n+    }\n+\n+    @Override\n+    public void close() {\n+        if (closed) {\n+            return;\n+        }\n+        closed = true;\n+        channel.close();\n+        group.shutdownGracefully(0, 1, SECONDS);", "originalCommit": "c338f88e64d8f0ca9277e32f6951a8cb24187014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM2Mzk3OQ==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404363979", "bodyText": "done", "author": "colestanfield", "createdAt": "2020-04-06T20:21:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxNzc5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxOTQ4OA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403219488", "body": "Use the `ByteBufAllocator` set in the `ctx`?\r\n\r\n```java\r\nctx.alloc().buffer(bytes.length).writeBytes(bytes)\r\n```", "bodyText": "Use the ByteBufAllocator set in the ctx?\nctx.alloc().buffer(bytes.length).writeBytes(bytes)", "bodyHTML": "<p dir=\"auto\">Use the <code>ByteBufAllocator</code> set in the <code>ctx</code>?</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"ctx.alloc().buffer(bytes.length).writeBytes(bytes)\n\"><pre>ctx<span class=\"pl-k\">.</span>alloc()<span class=\"pl-k\">.</span>buffer(bytes<span class=\"pl-k\">.</span>length)<span class=\"pl-k\">.</span>writeBytes(bytes)</pre></div>", "author": "NiteshKant", "createdAt": "2020-04-03T18:22:37Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.io.Flushable;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, Flushable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final EventLoopGroup group;\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        group = createEventLoopGroup(1, new DefaultThreadFactory(\"udp-span-reporter\", true));\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            group.shutdownGracefully(0, 0, SECONDS);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    public static final class Builder {\n+        private SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         * @param collectorAddress the collector SocketAddress\n+         * @return new builder\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        public UdpReporter build() {\n+            return new UdpReporter(this);\n+        }\n+    }\n+\n+    private Bootstrap buildBootstrap(EventLoopGroup group, Codec codec, SocketAddress collectorAddress) {\n+        if (!(collectorAddress instanceof InetSocketAddress)) {\n+            throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n+                    \" is invalid for UDP\");\n+        }\n+        return new Bootstrap()\n+                .group(group)\n+                .channel(datagramChannel(group))\n+                .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n+                .handler(new ChannelOutboundHandlerAdapter() {\n+                    @Override\n+                    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+                        if (msg instanceof Span) {\n+                            byte[] bytes = codec.encoder.encode((Span) msg);\n+                            ctx.write(new DatagramPacket(Unpooled.wrappedBuffer(bytes),", "originalCommit": "c338f88e64d8f0ca9277e32f6951a8cb24187014", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIyMDEyMA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403220120", "body": "Also pass the `promise` to the `write` call", "bodyText": "Also pass the promise to the write call", "bodyHTML": "<p dir=\"auto\">Also pass the <code>promise</code> to the <code>write</code> call</p>", "author": "NiteshKant", "createdAt": "2020-04-03T18:23:22Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.io.Flushable;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, Flushable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final EventLoopGroup group;\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        group = createEventLoopGroup(1, new DefaultThreadFactory(\"udp-span-reporter\", true));\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            group.shutdownGracefully(0, 0, SECONDS);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    public static final class Builder {\n+        private SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         * @param collectorAddress the collector SocketAddress\n+         * @return new builder\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        public UdpReporter build() {\n+            return new UdpReporter(this);\n+        }\n+    }\n+\n+    private Bootstrap buildBootstrap(EventLoopGroup group, Codec codec, SocketAddress collectorAddress) {\n+        if (!(collectorAddress instanceof InetSocketAddress)) {\n+            throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n+                    \" is invalid for UDP\");\n+        }\n+        return new Bootstrap()\n+                .group(group)\n+                .channel(datagramChannel(group))\n+                .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n+                .handler(new ChannelOutboundHandlerAdapter() {\n+                    @Override\n+                    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+                        if (msg instanceof Span) {\n+                            byte[] bytes = codec.encoder.encode((Span) msg);\n+                            ctx.write(new DatagramPacket(Unpooled.wrappedBuffer(bytes),\n+                                    (InetSocketAddress) collectorAddress));", "originalCommit": "c338f88e64d8f0ca9277e32f6951a8cb24187014", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "eb283b726c00a74057d2ac92c52d6afff316ae57", "url": "https://github.com/apple/servicetalk/commit/eb283b726c00a74057d2ac92c52d6afff316ae57", "message": "Converting ZipkinPublisher to use a zipkin2.Reporter interface for reporting spans.\n\nMotivation:\n\nThe existing ZipkinPublisher isn\u2019t readily extensible with different off the shelf reporters\nand adopting that interface will allow users to drop in their own reporters.\n\nModifications:\n\n- Modifying ZipkinPublisher to report spans to a Reporter<Span> interface.\n- Moving the UDP implementation out to a UdpReporter\n- Moving the default log reporter implementation out to a LoggingReporter\n\nResult:\n\nZipkinPublisher can now accept other zipkin2 Reporters as publishing targets.", "committedDate": "2020-04-06T20:20:35Z", "type": "forcePushed"}, {"oid": "04dc92872870995f77ab84bcf855365e92777037", "url": "https://github.com/apple/servicetalk/commit/04dc92872870995f77ab84bcf855365e92777037", "message": "Converting ZipkinPublisher to use a zipkin2.Reporter interface for reporting spans.\n\nMotivation:\n\nThe existing ZipkinPublisher isn\u2019t readily extensible with different off the shelf reporters\nand adopting that interface will allow users to drop in their own reporters.\n\nModifications:\n\n- Modifying ZipkinPublisher to report spans to a Reporter<Span> interface.\n- Moving the UDP implementation out to a UdpReporter\n- Moving the default log reporter implementation out to a LoggingReporter\n\nResult:\n\nZipkinPublisher can now accept other zipkin2 Reporters as publishing targets.", "committedDate": "2020-04-06T20:28:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwODg1MQ==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404408851", "body": "not sure why this has been pkg-private but it can be `private` now.", "bodyText": "not sure why this has been pkg-private but it can be private now.", "bodyHTML": "<p dir=\"auto\">not sure why this has been pkg-private but it can be <code>private</code> now.</p>", "author": "NiteshKant", "createdAt": "2020-04-06T21:47:54Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ExecutionException;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib", "originalCommit": "04dc92872870995f77ab84bcf855365e92777037", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwODkyMA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404408920", "body": "Javadocs please \ud83d\ude04 ", "bodyText": "Javadocs please \ud83d\ude04", "bodyHTML": "<p dir=\"auto\">Javadocs please <g-emoji class=\"g-emoji\" alias=\"smile\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f604.png\">\ud83d\ude04</g-emoji></p>", "author": "NiteshKant", "createdAt": "2020-04-06T21:48:03Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ExecutionException;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {", "originalCommit": "04dc92872870995f77ab84bcf855365e92777037", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxMDA1NA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404410054", "body": "Retain the \"may block comment\" from the original class?\r\n\r\n```\r\nNote that this may block while the underlying channel is bound/connected.\r\n```", "bodyText": "Retain the \"may block comment\" from the original class?\nNote that this may block while the underlying channel is bound/connected.", "bodyHTML": "<p dir=\"auto\">Retain the \"may block comment\" from the original class?</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"Note that this may block while the underlying channel is bound/connected.\n\"><pre><code>Note that this may block while the underlying channel is bound/connected.\n</code></pre></div>", "author": "NiteshKant", "createdAt": "2020-04-06T21:50:29Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ExecutionException;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        EventLoopGroup group;\n+        if (builder.ioExecutor != null) {\n+            group = toEventLoopAwareNettyIoExecutor(builder.ioExecutor).eventLoopGroup();\n+        } else {\n+            group = toEventLoopAwareNettyIoExecutor(globalExecutionContext().ioExecutor()).eventLoopGroup();\n+        }\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress,\n+                    builder.loggerName);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    /**\n+     * A builder to create a new {@link UdpReporter}.\n+     */\n+    public static final class Builder {\n+        private final SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+        @Nullable\n+        private IoExecutor ioExecutor;\n+        @Nullable\n+        private String loggerName;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         *\n+         * @param collectorAddress the collector SocketAddress\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        /**\n+         * Sets the {@link UdpReporter.Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an IoExecutor to use for writing to the datagram channel.\n+         *\n+         * @param ioExecutor IoExecutor to use to write with.\n+         * @return {@code this}\n+         */\n+        public Builder ioExecutor(IoExecutor ioExecutor) {\n+            this.ioExecutor = requireNonNull(ioExecutor);\n+            return this;\n+        }\n+\n+        /**\n+         * Enables wire-logging for udp packets sent.\n+         *\n+         * @param loggerName The name of the logger to log wire events.\n+         * @return {@code this}\n+         */\n+        public Builder enableWireLogging(String loggerName) {\n+            this.loggerName = loggerName;\n+            return this;\n+        }\n+\n+        /**\n+         * Builds a new {@link UdpReporter} instance with this builder's options.", "originalCommit": "04dc92872870995f77ab84bcf855365e92777037", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxMTg2Mw==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404411863", "body": "Mention at what level we will log, reference:\r\nhttps://github.com/apple/servicetalk/blob/master/servicetalk-http-api/src/main/java/io/servicetalk/http/api/BaseHttpBuilder.java#L77", "bodyText": "Mention at what level we will log, reference:\nhttps://github.com/apple/servicetalk/blob/master/servicetalk-http-api/src/main/java/io/servicetalk/http/api/BaseHttpBuilder.java#L77", "bodyHTML": "<p dir=\"auto\">Mention at what level we will log, reference:<br>\n<a href=\"https://github.com/apple/servicetalk/blob/master/servicetalk-http-api/src/main/java/io/servicetalk/http/api/BaseHttpBuilder.java#L77\">https://github.com/apple/servicetalk/blob/master/servicetalk-http-api/src/main/java/io/servicetalk/http/api/BaseHttpBuilder.java#L77</a></p>", "author": "NiteshKant", "createdAt": "2020-04-06T21:54:29Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ExecutionException;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        EventLoopGroup group;\n+        if (builder.ioExecutor != null) {\n+            group = toEventLoopAwareNettyIoExecutor(builder.ioExecutor).eventLoopGroup();\n+        } else {\n+            group = toEventLoopAwareNettyIoExecutor(globalExecutionContext().ioExecutor()).eventLoopGroup();\n+        }\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress,\n+                    builder.loggerName);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    /**\n+     * A builder to create a new {@link UdpReporter}.\n+     */\n+    public static final class Builder {\n+        private final SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+        @Nullable\n+        private IoExecutor ioExecutor;\n+        @Nullable\n+        private String loggerName;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         *\n+         * @param collectorAddress the collector SocketAddress\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        /**\n+         * Sets the {@link UdpReporter.Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an IoExecutor to use for writing to the datagram channel.\n+         *\n+         * @param ioExecutor IoExecutor to use to write with.\n+         * @return {@code this}\n+         */\n+        public Builder ioExecutor(IoExecutor ioExecutor) {\n+            this.ioExecutor = requireNonNull(ioExecutor);\n+            return this;\n+        }\n+\n+        /**\n+         * Enables wire-logging for udp packets sent.\n+         *\n+         * @param loggerName The name of the logger to log wire events.", "originalCommit": "04dc92872870995f77ab84bcf855365e92777037", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxMjEzOQ==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404412139", "body": "We generally log at `Trace` level, you can pass the level to the `LoggingHandler`, default is `DEBUG`", "bodyText": "We generally log at Trace level, you can pass the level to the LoggingHandler, default is DEBUG", "bodyHTML": "<p dir=\"auto\">We generally log at <code>Trace</code> level, you can pass the level to the <code>LoggingHandler</code>, default is <code>DEBUG</code></p>", "author": "NiteshKant", "createdAt": "2020-04-06T21:55:05Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ExecutionException;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        EventLoopGroup group;\n+        if (builder.ioExecutor != null) {\n+            group = toEventLoopAwareNettyIoExecutor(builder.ioExecutor).eventLoopGroup();\n+        } else {\n+            group = toEventLoopAwareNettyIoExecutor(globalExecutionContext().ioExecutor()).eventLoopGroup();\n+        }\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress,\n+                    builder.loggerName);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    /**\n+     * A builder to create a new {@link UdpReporter}.\n+     */\n+    public static final class Builder {\n+        private final SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+        @Nullable\n+        private IoExecutor ioExecutor;\n+        @Nullable\n+        private String loggerName;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         *\n+         * @param collectorAddress the collector SocketAddress\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        /**\n+         * Sets the {@link UdpReporter.Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an IoExecutor to use for writing to the datagram channel.\n+         *\n+         * @param ioExecutor IoExecutor to use to write with.\n+         * @return {@code this}\n+         */\n+        public Builder ioExecutor(IoExecutor ioExecutor) {\n+            this.ioExecutor = requireNonNull(ioExecutor);\n+            return this;\n+        }\n+\n+        /**\n+         * Enables wire-logging for udp packets sent.\n+         *\n+         * @param loggerName The name of the logger to log wire events.\n+         * @return {@code this}\n+         */\n+        public Builder enableWireLogging(String loggerName) {\n+            this.loggerName = loggerName;\n+            return this;\n+        }\n+\n+        /**\n+         * Builds a new {@link UdpReporter} instance with this builder's options.\n+         *\n+         * @return a new {@link UdpReporter}\n+         */\n+        public UdpReporter build() {\n+            return new UdpReporter(this);\n+        }\n+    }\n+\n+    private Bootstrap buildBootstrap(EventLoopGroup group, Codec codec, SocketAddress collectorAddress,\n+                                     @Nullable String loggerName) {\n+        if (!(collectorAddress instanceof InetSocketAddress)) {\n+            throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n+                    \" is invalid for UDP\");\n+        }\n+        return new Bootstrap()\n+                .group(group)\n+                .channel(datagramChannel(group))\n+                .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n+                .handler(new ChannelInitializer<Channel>() {\n+                    @Override\n+                    protected void initChannel(final Channel ch) {\n+                        if (loggerName != null) {\n+                            ch.pipeline().addLast(new LoggingHandler(loggerName));", "originalCommit": "04dc92872870995f77ab84bcf855365e92777037", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxMzEzMA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404413130", "body": "Log instead?", "bodyText": "Log instead?", "bodyHTML": "<p dir=\"auto\">Log instead?</p>", "author": "NiteshKant", "createdAt": "2020-04-06T21:56:56Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ExecutionException;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        EventLoopGroup group;\n+        if (builder.ioExecutor != null) {\n+            group = toEventLoopAwareNettyIoExecutor(builder.ioExecutor).eventLoopGroup();\n+        } else {\n+            group = toEventLoopAwareNettyIoExecutor(globalExecutionContext().ioExecutor()).eventLoopGroup();\n+        }\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress,\n+                    builder.loggerName);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    /**\n+     * A builder to create a new {@link UdpReporter}.\n+     */\n+    public static final class Builder {\n+        private final SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+        @Nullable\n+        private IoExecutor ioExecutor;\n+        @Nullable\n+        private String loggerName;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         *\n+         * @param collectorAddress the collector SocketAddress\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        /**\n+         * Sets the {@link UdpReporter.Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an IoExecutor to use for writing to the datagram channel.\n+         *\n+         * @param ioExecutor IoExecutor to use to write with.\n+         * @return {@code this}\n+         */\n+        public Builder ioExecutor(IoExecutor ioExecutor) {\n+            this.ioExecutor = requireNonNull(ioExecutor);\n+            return this;\n+        }\n+\n+        /**\n+         * Enables wire-logging for udp packets sent.\n+         *\n+         * @param loggerName The name of the logger to log wire events.\n+         * @return {@code this}\n+         */\n+        public Builder enableWireLogging(String loggerName) {\n+            this.loggerName = loggerName;\n+            return this;\n+        }\n+\n+        /**\n+         * Builds a new {@link UdpReporter} instance with this builder's options.\n+         *\n+         * @return a new {@link UdpReporter}\n+         */\n+        public UdpReporter build() {\n+            return new UdpReporter(this);\n+        }\n+    }\n+\n+    private Bootstrap buildBootstrap(EventLoopGroup group, Codec codec, SocketAddress collectorAddress,\n+                                     @Nullable String loggerName) {\n+        if (!(collectorAddress instanceof InetSocketAddress)) {\n+            throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n+                    \" is invalid for UDP\");\n+        }\n+        return new Bootstrap()\n+                .group(group)\n+                .channel(datagramChannel(group))\n+                .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n+                .handler(new ChannelInitializer<Channel>() {\n+                    @Override\n+                    protected void initChannel(final Channel ch) {\n+                        if (loggerName != null) {\n+                            ch.pipeline().addLast(new LoggingHandler(loggerName));\n+                        }\n+                        ch.pipeline().addLast(new ChannelOutboundHandlerAdapter() {\n+                            @Override\n+                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+                                if (msg instanceof Span) {\n+                                    byte[] bytes = codec.encoder.encode((Span) msg);\n+                                    ByteBuf buf = ctx.alloc().buffer(bytes.length).writeBytes(bytes);\n+                                    ctx.write(new DatagramPacket(buf, (InetSocketAddress) collectorAddress), promise);\n+                                } else {\n+                                    ctx.write(msg, promise);\n+                                }\n+                            }\n+                        });\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Non-blocking report method.\n+     *\n+     * @param span the span to report\n+     */\n+    @Override\n+    public void report(final Span span) {\n+        if (closed) {\n+            throw new IllegalStateException(\"closed\");\n+        }\n+        channel.writeAndFlush(span);\n+    }\n+\n+    /**\n+     * Blocking close method delegates to {@link #closeAsync()}).\n+     */\n+    @Override\n+    public void close() {\n+        try {\n+            closeAsync().toFuture().get();\n+        } catch (InterruptedException | ExecutionException e) {\n+            e.printStackTrace();", "originalCommit": "04dc92872870995f77ab84bcf855365e92777037", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxNTMzNg==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404415336", "body": "We still need to close the `channel`. You can make [this class](https://github.com/apple/servicetalk/blob/master/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/NettyFutureCompletable.java#L28) `public` and use it here:\r\n\r\n```java\r\nreturn new NettyFutureCompletable(channel::closeFuture);\r\n```\r\n\r\nBetter to create an keep this `NettyFutureCompletable` instance in the constructor.", "bodyText": "We still need to close the channel. You can make this class public and use it here:\nreturn new NettyFutureCompletable(channel::closeFuture);\nBetter to create an keep this NettyFutureCompletable instance in the constructor.", "bodyHTML": "<p dir=\"auto\">We still need to close the <code>channel</code>. You can make <a href=\"https://github.com/apple/servicetalk/blob/master/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/NettyFutureCompletable.java#L28\">this class</a> <code>public</code> and use it here:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"return new NettyFutureCompletable(channel::closeFuture);\n\"><pre><span class=\"pl-k\">return</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">NettyFutureCompletable</span>(channel<span class=\"pl-k\">::</span>closeFuture);</pre></div>\n<p dir=\"auto\">Better to create an keep this <code>NettyFutureCompletable</code> instance in the constructor.</p>", "author": "NiteshKant", "createdAt": "2020-04-06T22:02:02Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ExecutionException;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        EventLoopGroup group;\n+        if (builder.ioExecutor != null) {\n+            group = toEventLoopAwareNettyIoExecutor(builder.ioExecutor).eventLoopGroup();\n+        } else {\n+            group = toEventLoopAwareNettyIoExecutor(globalExecutionContext().ioExecutor()).eventLoopGroup();\n+        }\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress,\n+                    builder.loggerName);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    /**\n+     * A builder to create a new {@link UdpReporter}.\n+     */\n+    public static final class Builder {\n+        private final SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+        @Nullable\n+        private IoExecutor ioExecutor;\n+        @Nullable\n+        private String loggerName;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         *\n+         * @param collectorAddress the collector SocketAddress\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        /**\n+         * Sets the {@link UdpReporter.Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an IoExecutor to use for writing to the datagram channel.\n+         *\n+         * @param ioExecutor IoExecutor to use to write with.\n+         * @return {@code this}\n+         */\n+        public Builder ioExecutor(IoExecutor ioExecutor) {\n+            this.ioExecutor = requireNonNull(ioExecutor);\n+            return this;\n+        }\n+\n+        /**\n+         * Enables wire-logging for udp packets sent.\n+         *\n+         * @param loggerName The name of the logger to log wire events.\n+         * @return {@code this}\n+         */\n+        public Builder enableWireLogging(String loggerName) {\n+            this.loggerName = loggerName;\n+            return this;\n+        }\n+\n+        /**\n+         * Builds a new {@link UdpReporter} instance with this builder's options.\n+         *\n+         * @return a new {@link UdpReporter}\n+         */\n+        public UdpReporter build() {\n+            return new UdpReporter(this);\n+        }\n+    }\n+\n+    private Bootstrap buildBootstrap(EventLoopGroup group, Codec codec, SocketAddress collectorAddress,\n+                                     @Nullable String loggerName) {\n+        if (!(collectorAddress instanceof InetSocketAddress)) {\n+            throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n+                    \" is invalid for UDP\");\n+        }\n+        return new Bootstrap()\n+                .group(group)\n+                .channel(datagramChannel(group))\n+                .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n+                .handler(new ChannelInitializer<Channel>() {\n+                    @Override\n+                    protected void initChannel(final Channel ch) {\n+                        if (loggerName != null) {\n+                            ch.pipeline().addLast(new LoggingHandler(loggerName));\n+                        }\n+                        ch.pipeline().addLast(new ChannelOutboundHandlerAdapter() {\n+                            @Override\n+                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+                                if (msg instanceof Span) {\n+                                    byte[] bytes = codec.encoder.encode((Span) msg);\n+                                    ByteBuf buf = ctx.alloc().buffer(bytes.length).writeBytes(bytes);\n+                                    ctx.write(new DatagramPacket(buf, (InetSocketAddress) collectorAddress), promise);\n+                                } else {\n+                                    ctx.write(msg, promise);\n+                                }\n+                            }\n+                        });\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Non-blocking report method.\n+     *\n+     * @param span the span to report\n+     */\n+    @Override\n+    public void report(final Span span) {\n+        if (closed) {\n+            throw new IllegalStateException(\"closed\");\n+        }\n+        channel.writeAndFlush(span);\n+    }\n+\n+    /**\n+     * Blocking close method delegates to {@link #closeAsync()}).\n+     */\n+    @Override\n+    public void close() {\n+        try {\n+            closeAsync().toFuture().get();\n+        } catch (InterruptedException | ExecutionException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Marks the {@link UdpReporter} as closed to prevent accepting any more {@link Span}s.\n+     *\n+     * @return a {@link Completable} that is completed when close is done.\n+     */\n+    @Override\n+    public Completable closeAsync() {\n+        closed = true;", "originalCommit": "04dc92872870995f77ab84bcf855365e92777037", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQyOTEzNQ==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404429135", "body": "Once you move to `NettyFutureCompletable` this issue becomes moot but as a general concept; setting state like this before returning an async source means state change is eager as opposed to the expected lazy semantics from the returned async source.", "bodyText": "Once you move to NettyFutureCompletable this issue becomes moot but as a general concept; setting state like this before returning an async source means state change is eager as opposed to the expected lazy semantics from the returned async source.", "bodyHTML": "<p dir=\"auto\">Once you move to <code>NettyFutureCompletable</code> this issue becomes moot but as a general concept; setting state like this before returning an async source means state change is eager as opposed to the expected lazy semantics from the returned async source.</p>", "author": "NiteshKant", "createdAt": "2020-04-06T22:34:53Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ExecutionException;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        EventLoopGroup group;\n+        if (builder.ioExecutor != null) {\n+            group = toEventLoopAwareNettyIoExecutor(builder.ioExecutor).eventLoopGroup();\n+        } else {\n+            group = toEventLoopAwareNettyIoExecutor(globalExecutionContext().ioExecutor()).eventLoopGroup();\n+        }\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress,\n+                    builder.loggerName);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    /**\n+     * A builder to create a new {@link UdpReporter}.\n+     */\n+    public static final class Builder {\n+        private final SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+        @Nullable\n+        private IoExecutor ioExecutor;\n+        @Nullable\n+        private String loggerName;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         *\n+         * @param collectorAddress the collector SocketAddress\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        /**\n+         * Sets the {@link UdpReporter.Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an IoExecutor to use for writing to the datagram channel.\n+         *\n+         * @param ioExecutor IoExecutor to use to write with.\n+         * @return {@code this}\n+         */\n+        public Builder ioExecutor(IoExecutor ioExecutor) {\n+            this.ioExecutor = requireNonNull(ioExecutor);\n+            return this;\n+        }\n+\n+        /**\n+         * Enables wire-logging for udp packets sent.\n+         *\n+         * @param loggerName The name of the logger to log wire events.\n+         * @return {@code this}\n+         */\n+        public Builder enableWireLogging(String loggerName) {\n+            this.loggerName = loggerName;\n+            return this;\n+        }\n+\n+        /**\n+         * Builds a new {@link UdpReporter} instance with this builder's options.\n+         *\n+         * @return a new {@link UdpReporter}\n+         */\n+        public UdpReporter build() {\n+            return new UdpReporter(this);\n+        }\n+    }\n+\n+    private Bootstrap buildBootstrap(EventLoopGroup group, Codec codec, SocketAddress collectorAddress,\n+                                     @Nullable String loggerName) {\n+        if (!(collectorAddress instanceof InetSocketAddress)) {\n+            throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n+                    \" is invalid for UDP\");\n+        }\n+        return new Bootstrap()\n+                .group(group)\n+                .channel(datagramChannel(group))\n+                .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n+                .handler(new ChannelInitializer<Channel>() {\n+                    @Override\n+                    protected void initChannel(final Channel ch) {\n+                        if (loggerName != null) {\n+                            ch.pipeline().addLast(new LoggingHandler(loggerName));\n+                        }\n+                        ch.pipeline().addLast(new ChannelOutboundHandlerAdapter() {\n+                            @Override\n+                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+                                if (msg instanceof Span) {\n+                                    byte[] bytes = codec.encoder.encode((Span) msg);\n+                                    ByteBuf buf = ctx.alloc().buffer(bytes.length).writeBytes(bytes);\n+                                    ctx.write(new DatagramPacket(buf, (InetSocketAddress) collectorAddress), promise);\n+                                } else {\n+                                    ctx.write(msg, promise);\n+                                }\n+                            }\n+                        });\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Non-blocking report method.\n+     *\n+     * @param span the span to report\n+     */\n+    @Override\n+    public void report(final Span span) {\n+        if (closed) {\n+            throw new IllegalStateException(\"closed\");\n+        }\n+        channel.writeAndFlush(span);\n+    }\n+\n+    /**\n+     * Blocking close method delegates to {@link #closeAsync()}).\n+     */\n+    @Override\n+    public void close() {\n+        try {\n+            closeAsync().toFuture().get();\n+        } catch (InterruptedException | ExecutionException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Marks the {@link UdpReporter} as closed to prevent accepting any more {@link Span}s.\n+     *\n+     * @return a {@link Completable} that is completed when close is done.\n+     */\n+    @Override\n+    public Completable closeAsync() {\n+        closed = true;", "originalCommit": "04dc92872870995f77ab84bcf855365e92777037", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ5NTkxNw==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404495917", "bodyText": "Very true. Happened when I copy-pasted from the old blocking close() method.", "author": "colestanfield", "createdAt": "2020-04-07T02:13:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQyOTEzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQzMDQyOA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404430428", "body": "Once you change `closeAsync()` below to close the `channel`, you can just use `channel.isActive()`.", "bodyText": "Once you change closeAsync() below to close the channel, you can just use channel.isActive().", "bodyHTML": "<p dir=\"auto\">Once you change <code>closeAsync()</code> below to close the <code>channel</code>, you can just use <code>channel.isActive()</code>.</p>", "author": "NiteshKant", "createdAt": "2020-04-06T22:38:22Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ExecutionException;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        EventLoopGroup group;\n+        if (builder.ioExecutor != null) {\n+            group = toEventLoopAwareNettyIoExecutor(builder.ioExecutor).eventLoopGroup();\n+        } else {\n+            group = toEventLoopAwareNettyIoExecutor(globalExecutionContext().ioExecutor()).eventLoopGroup();\n+        }\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress,\n+                    builder.loggerName);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    /**\n+     * A builder to create a new {@link UdpReporter}.\n+     */\n+    public static final class Builder {\n+        private final SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+        @Nullable\n+        private IoExecutor ioExecutor;\n+        @Nullable\n+        private String loggerName;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         *\n+         * @param collectorAddress the collector SocketAddress\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        /**\n+         * Sets the {@link UdpReporter.Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an IoExecutor to use for writing to the datagram channel.\n+         *\n+         * @param ioExecutor IoExecutor to use to write with.\n+         * @return {@code this}\n+         */\n+        public Builder ioExecutor(IoExecutor ioExecutor) {\n+            this.ioExecutor = requireNonNull(ioExecutor);\n+            return this;\n+        }\n+\n+        /**\n+         * Enables wire-logging for udp packets sent.\n+         *\n+         * @param loggerName The name of the logger to log wire events.\n+         * @return {@code this}\n+         */\n+        public Builder enableWireLogging(String loggerName) {\n+            this.loggerName = loggerName;\n+            return this;\n+        }\n+\n+        /**\n+         * Builds a new {@link UdpReporter} instance with this builder's options.\n+         *\n+         * @return a new {@link UdpReporter}\n+         */\n+        public UdpReporter build() {\n+            return new UdpReporter(this);\n+        }\n+    }\n+\n+    private Bootstrap buildBootstrap(EventLoopGroup group, Codec codec, SocketAddress collectorAddress,\n+                                     @Nullable String loggerName) {\n+        if (!(collectorAddress instanceof InetSocketAddress)) {\n+            throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n+                    \" is invalid for UDP\");\n+        }\n+        return new Bootstrap()\n+                .group(group)\n+                .channel(datagramChannel(group))\n+                .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n+                .handler(new ChannelInitializer<Channel>() {\n+                    @Override\n+                    protected void initChannel(final Channel ch) {\n+                        if (loggerName != null) {\n+                            ch.pipeline().addLast(new LoggingHandler(loggerName));\n+                        }\n+                        ch.pipeline().addLast(new ChannelOutboundHandlerAdapter() {\n+                            @Override\n+                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+                                if (msg instanceof Span) {\n+                                    byte[] bytes = codec.encoder.encode((Span) msg);\n+                                    ByteBuf buf = ctx.alloc().buffer(bytes.length).writeBytes(bytes);\n+                                    ctx.write(new DatagramPacket(buf, (InetSocketAddress) collectorAddress), promise);\n+                                } else {\n+                                    ctx.write(msg, promise);\n+                                }\n+                            }\n+                        });\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Non-blocking report method.\n+     *\n+     * @param span the span to report\n+     */\n+    @Override\n+    public void report(final Span span) {\n+        if (closed) {", "originalCommit": "04dc92872870995f77ab84bcf855365e92777037", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQzMDY5NA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404430694", "body": "You may want to instead use [`StacklessClosedChannelException`](https://github.com/apple/servicetalk/blob/master/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/StacklessClosedChannelException.java)", "bodyText": "You may want to instead use StacklessClosedChannelException", "bodyHTML": "<p dir=\"auto\">You may want to instead use <a href=\"https://github.com/apple/servicetalk/blob/master/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/StacklessClosedChannelException.java\"><code>StacklessClosedChannelException</code></a></p>", "author": "NiteshKant", "createdAt": "2020-04-06T22:39:04Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ExecutionException;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        EventLoopGroup group;\n+        if (builder.ioExecutor != null) {\n+            group = toEventLoopAwareNettyIoExecutor(builder.ioExecutor).eventLoopGroup();\n+        } else {\n+            group = toEventLoopAwareNettyIoExecutor(globalExecutionContext().ioExecutor()).eventLoopGroup();\n+        }\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress,\n+                    builder.loggerName);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    /**\n+     * A builder to create a new {@link UdpReporter}.\n+     */\n+    public static final class Builder {\n+        private final SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+        @Nullable\n+        private IoExecutor ioExecutor;\n+        @Nullable\n+        private String loggerName;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         *\n+         * @param collectorAddress the collector SocketAddress\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        /**\n+         * Sets the {@link UdpReporter.Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an IoExecutor to use for writing to the datagram channel.\n+         *\n+         * @param ioExecutor IoExecutor to use to write with.\n+         * @return {@code this}\n+         */\n+        public Builder ioExecutor(IoExecutor ioExecutor) {\n+            this.ioExecutor = requireNonNull(ioExecutor);\n+            return this;\n+        }\n+\n+        /**\n+         * Enables wire-logging for udp packets sent.\n+         *\n+         * @param loggerName The name of the logger to log wire events.\n+         * @return {@code this}\n+         */\n+        public Builder enableWireLogging(String loggerName) {\n+            this.loggerName = loggerName;\n+            return this;\n+        }\n+\n+        /**\n+         * Builds a new {@link UdpReporter} instance with this builder's options.\n+         *\n+         * @return a new {@link UdpReporter}\n+         */\n+        public UdpReporter build() {\n+            return new UdpReporter(this);\n+        }\n+    }\n+\n+    private Bootstrap buildBootstrap(EventLoopGroup group, Codec codec, SocketAddress collectorAddress,\n+                                     @Nullable String loggerName) {\n+        if (!(collectorAddress instanceof InetSocketAddress)) {\n+            throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n+                    \" is invalid for UDP\");\n+        }\n+        return new Bootstrap()\n+                .group(group)\n+                .channel(datagramChannel(group))\n+                .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n+                .handler(new ChannelInitializer<Channel>() {\n+                    @Override\n+                    protected void initChannel(final Channel ch) {\n+                        if (loggerName != null) {\n+                            ch.pipeline().addLast(new LoggingHandler(loggerName));\n+                        }\n+                        ch.pipeline().addLast(new ChannelOutboundHandlerAdapter() {\n+                            @Override\n+                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+                                if (msg instanceof Span) {\n+                                    byte[] bytes = codec.encoder.encode((Span) msg);\n+                                    ByteBuf buf = ctx.alloc().buffer(bytes.length).writeBytes(bytes);\n+                                    ctx.write(new DatagramPacket(buf, (InetSocketAddress) collectorAddress), promise);\n+                                } else {\n+                                    ctx.write(msg, promise);\n+                                }\n+                            }\n+                        });\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Non-blocking report method.\n+     *\n+     * @param span the span to report\n+     */\n+    @Override\n+    public void report(final Span span) {\n+        if (closed) {\n+            throw new IllegalStateException(\"closed\");", "originalCommit": "04dc92872870995f77ab84bcf855365e92777037", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQzMzI1MQ==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404433251", "body": "We should also override `closeAsyncGracefully()` to correctly delegate the same to the `Reporter`. Typically we create an `AsyncCloseable` in the constructor and delegate to it from respective methods. In this case the `AsyncCloseable` can be created in the constructor like:\r\n\r\n```java\r\ncloseable = AsyncCloseables.toAsyncCloseable(graceful -> {\r\n    Completable flush = Completable.completed();\r\n    if (reporter instanceof Flushable) {\r\n        flush = globalExecutionContext().executor().submit(() -> {\r\n            try {\r\n                ((Flushable) reporter).flush();\r\n            } catch (IOException e) {\r\n                logger.error(\"Exception while flushing reporter: {}\", e.getMessage(), e);\r\n            }\r\n        });\r\n    }\r\n    // ST Reporters can implement AsyncCloseable so we wouldn't have to call a blocking close in that case\r\n    Completable close = Completable.completed();\r\n    if (reporter instanceof AsyncCloseable) {\r\n        close = graceful ? ((AsyncCloseable) reporter).closeAsyncGracefully() :\r\n                ((AsyncCloseable) reporter).closeAsync();\r\n    } else if (reporter instanceof Closeable) {\r\n        close = globalExecutionContext().executor().submit(() -> {\r\n            try {\r\n                ((Closeable) reporter).close();\r\n            } catch (IOException e) {\r\n                logger.error(\"Exception while closing reporter: {}\", e.getMessage(), e);\r\n            }\r\n        });\r\n    }\r\n    return flush.concat(close);\r\n});\r\n```", "bodyText": "We should also override closeAsyncGracefully() to correctly delegate the same to the Reporter. Typically we create an AsyncCloseable in the constructor and delegate to it from respective methods. In this case the AsyncCloseable can be created in the constructor like:\ncloseable = AsyncCloseables.toAsyncCloseable(graceful -> {\n    Completable flush = Completable.completed();\n    if (reporter instanceof Flushable) {\n        flush = globalExecutionContext().executor().submit(() -> {\n            try {\n                ((Flushable) reporter).flush();\n            } catch (IOException e) {\n                logger.error(\"Exception while flushing reporter: {}\", e.getMessage(), e);\n            }\n        });\n    }\n    // ST Reporters can implement AsyncCloseable so we wouldn't have to call a blocking close in that case\n    Completable close = Completable.completed();\n    if (reporter instanceof AsyncCloseable) {\n        close = graceful ? ((AsyncCloseable) reporter).closeAsyncGracefully() :\n                ((AsyncCloseable) reporter).closeAsync();\n    } else if (reporter instanceof Closeable) {\n        close = globalExecutionContext().executor().submit(() -> {\n            try {\n                ((Closeable) reporter).close();\n            } catch (IOException e) {\n                logger.error(\"Exception while closing reporter: {}\", e.getMessage(), e);\n            }\n        });\n    }\n    return flush.concat(close);\n});", "bodyHTML": "<p dir=\"auto\">We should also override <code>closeAsyncGracefully()</code> to correctly delegate the same to the <code>Reporter</code>. Typically we create an <code>AsyncCloseable</code> in the constructor and delegate to it from respective methods. In this case the <code>AsyncCloseable</code> can be created in the constructor like:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"closeable = AsyncCloseables.toAsyncCloseable(graceful -&gt; {\n    Completable flush = Completable.completed();\n    if (reporter instanceof Flushable) {\n        flush = globalExecutionContext().executor().submit(() -&gt; {\n            try {\n                ((Flushable) reporter).flush();\n            } catch (IOException e) {\n                logger.error(&quot;Exception while flushing reporter: {}&quot;, e.getMessage(), e);\n            }\n        });\n    }\n    // ST Reporters can implement AsyncCloseable so we wouldn't have to call a blocking close in that case\n    Completable close = Completable.completed();\n    if (reporter instanceof AsyncCloseable) {\n        close = graceful ? ((AsyncCloseable) reporter).closeAsyncGracefully() :\n                ((AsyncCloseable) reporter).closeAsync();\n    } else if (reporter instanceof Closeable) {\n        close = globalExecutionContext().executor().submit(() -&gt; {\n            try {\n                ((Closeable) reporter).close();\n            } catch (IOException e) {\n                logger.error(&quot;Exception while closing reporter: {}&quot;, e.getMessage(), e);\n            }\n        });\n    }\n    return flush.concat(close);\n});\n\"><pre>closeable <span class=\"pl-k\">=</span> <span class=\"pl-smi\">AsyncCloseables</span><span class=\"pl-k\">.</span>toAsyncCloseable(graceful <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> {\n    <span class=\"pl-smi\">Completable</span> flush <span class=\"pl-k\">=</span> <span class=\"pl-smi\">Completable</span><span class=\"pl-k\">.</span>completed();\n    <span class=\"pl-k\">if</span> (reporter <span class=\"pl-k\">instanceof</span> <span class=\"pl-smi\">Flushable</span>) {\n        flush <span class=\"pl-k\">=</span> globalExecutionContext()<span class=\"pl-k\">.</span>executor()<span class=\"pl-k\">.</span>submit(() <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> {\n            <span class=\"pl-k\">try</span> {\n                ((<span class=\"pl-smi\">Flushable</span>) reporter)<span class=\"pl-k\">.</span>flush();\n            } <span class=\"pl-k\">catch</span> (<span class=\"pl-smi\">IOException</span> e) {\n                logger<span class=\"pl-k\">.</span>error(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Exception while flushing reporter: {}<span class=\"pl-pds\">\"</span></span>, e<span class=\"pl-k\">.</span>getMessage(), e);\n            }\n        });\n    }\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span> ST Reporters can implement AsyncCloseable so we wouldn't have to call a blocking close in that case</span>\n    <span class=\"pl-smi\">Completable</span> close <span class=\"pl-k\">=</span> <span class=\"pl-smi\">Completable</span><span class=\"pl-k\">.</span>completed();\n    <span class=\"pl-k\">if</span> (reporter <span class=\"pl-k\">instanceof</span> <span class=\"pl-smi\">AsyncCloseable</span>) {\n        close <span class=\"pl-k\">=</span> graceful <span class=\"pl-k\">?</span> ((<span class=\"pl-smi\">AsyncCloseable</span>) reporter)<span class=\"pl-k\">.</span>closeAsyncGracefully() <span class=\"pl-k\">:</span>\n                ((<span class=\"pl-smi\">AsyncCloseable</span>) reporter)<span class=\"pl-k\">.</span>closeAsync();\n    } <span class=\"pl-k\">else</span> <span class=\"pl-k\">if</span> (reporter <span class=\"pl-k\">instanceof</span> <span class=\"pl-smi\">Closeable</span>) {\n        close <span class=\"pl-k\">=</span> globalExecutionContext()<span class=\"pl-k\">.</span>executor()<span class=\"pl-k\">.</span>submit(() <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> {\n            <span class=\"pl-k\">try</span> {\n                ((<span class=\"pl-smi\">Closeable</span>) reporter)<span class=\"pl-k\">.</span>close();\n            } <span class=\"pl-k\">catch</span> (<span class=\"pl-smi\">IOException</span> e) {\n                logger<span class=\"pl-k\">.</span>error(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Exception while closing reporter: {}<span class=\"pl-pds\">\"</span></span>, e<span class=\"pl-k\">.</span>getMessage(), e);\n            }\n        });\n    }\n    <span class=\"pl-k\">return</span> flush<span class=\"pl-k\">.</span>concat(close);\n});</pre></div>", "author": "NiteshKant", "createdAt": "2020-04-06T22:45:43Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -278,6 +149,53 @@ public void onSpanFinished(final InMemorySpan span, long durationMicros) {\n             builder.kind(Span.Kind.CLIENT);\n         }\n \n-        channel.writeAndFlush(builder.build());\n+        Span s = builder.build();\n+        reporter.report(s);\n+    }\n+\n+    /**\n+     * Attempts to flush and close the configured {@link Reporter}.\n+     *\n+     * @return a {@link Completable} that is completed when the flush and close is done\n+     */\n+    @Override\n+    public Completable closeAsync() {", "originalCommit": "04dc92872870995f77ab84bcf855365e92777037", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cedc692217938361cb918f75d62f7c39b3ff4e91", "url": "https://github.com/apple/servicetalk/commit/cedc692217938361cb918f75d62f7c39b3ff4e91", "message": "Converting ZipkinPublisher to use a zipkin2.Reporter interface for reporting spans.\n\nMotivation:\n\nThe existing ZipkinPublisher isn\u2019t readily extensible with different off the shelf reporters\nand adopting that interface will allow users to drop in their own reporters.\n\nModifications:\n\n- Modifying ZipkinPublisher to report spans to a Reporter<Span> interface.\n- Moving the UDP implementation out to a UdpReporter\n- Moving the default log reporter implementation out to a LoggingReporter\n\nResult:\n\nZipkinPublisher can now accept other zipkin2 Reporters as publishing targets.", "committedDate": "2020-04-07T02:02:40Z", "type": "forcePushed"}, {"oid": "a714b13acfa948d4ffcecd980af148a723e4eb67", "url": "https://github.com/apple/servicetalk/commit/a714b13acfa948d4ffcecd980af148a723e4eb67", "message": "Converting ZipkinPublisher to use a zipkin2.Reporter interface for reporting spans.\n\nMotivation:\n\nThe existing ZipkinPublisher isn\u2019t readily extensible with different off the shelf reporters\nand adopting that interface will allow users to drop in their own reporters.\n\nModifications:\n\n- Modifying ZipkinPublisher to report spans to a Reporter<Span> interface.\n- Moving the UDP implementation out to a UdpReporter\n- Moving the default log reporter implementation out to a LoggingReporter\n\nResult:\n\nZipkinPublisher can now accept other zipkin2 Reporters as publishing targets.", "committedDate": "2020-04-07T07:29:37Z", "type": "commit"}, {"oid": "a714b13acfa948d4ffcecd980af148a723e4eb67", "url": "https://github.com/apple/servicetalk/commit/a714b13acfa948d4ffcecd980af148a723e4eb67", "message": "Converting ZipkinPublisher to use a zipkin2.Reporter interface for reporting spans.\n\nMotivation:\n\nThe existing ZipkinPublisher isn\u2019t readily extensible with different off the shelf reporters\nand adopting that interface will allow users to drop in their own reporters.\n\nModifications:\n\n- Modifying ZipkinPublisher to report spans to a Reporter<Span> interface.\n- Moving the UDP implementation out to a UdpReporter\n- Moving the default log reporter implementation out to a LoggingReporter\n\nResult:\n\nZipkinPublisher can now accept other zipkin2 Reporters as publishing targets.", "committedDate": "2020-04-07T07:29:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk0MTQ2OA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404941468", "body": "`onClose()` isn't appropriate here as it does not actually close, also we need to subscribe here as `close()` is synchronous.\r\n```suggestion\r\n    public void close() throws Exception {\r\n        closeable.closeAsync().toFuture().get();\r\n    }\r\n```", "bodyText": "onClose() isn't appropriate here as it does not actually close, also we need to subscribe here as close() is synchronous.\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void close() {\n          \n          \n            \n                    closeable.onClose();\n          \n          \n            \n                }\n          \n          \n            \n                public void close() throws Exception {\n          \n          \n            \n                    closeable.closeAsync().toFuture().get();\n          \n          \n            \n                }", "bodyHTML": "<p dir=\"auto\"><code>onClose()</code> isn't appropriate here as it does not actually close, also we need to subscribe here as <code>close()</code> is synchronous.</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"194\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-k\">public</span> <span class=\"pl-k\">void</span> close() {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"195\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        closeable<span class=\"pl-k\">.</span><span class=\"x x-first x-last\">onClose</span>();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"196\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"194\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">public</span> <span class=\"pl-k\">void</span> close() <span class=\"x x-first\">throws </span><span class=\"pl-smi x\">Exception</span><span class=\"x x-last\"> </span>{</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"195\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        closeable<span class=\"pl-k\">.</span><span class=\"x x-first\">closeAsync()</span><span class=\"pl-k x\">.</span><span class=\"x\">toFuture()</span><span class=\"pl-k x\">.</span><span class=\"x x-last\">get</span>();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"196\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    }</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "NiteshKant", "createdAt": "2020-04-07T16:22:13Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -278,6 +179,35 @@ public void onSpanFinished(final InMemorySpan span, long durationMicros) {\n             builder.kind(Span.Kind.CLIENT);\n         }\n \n-        channel.writeAndFlush(builder.build());\n+        Span s = builder.build();\n+        reporter.report(s);\n+    }\n+\n+    /**\n+     * Blocking close method delegates to {@link #closeAsync()}.\n+     */\n+    @Override\n+    public void close() {\n+        closeable.onClose();\n+    }", "originalCommit": "a714b13acfa948d4ffcecd980af148a723e4eb67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk0MjkxMA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404942910", "bodyText": "@colestanfield I will just commit this suggestion", "author": "NiteshKant", "createdAt": "2020-04-07T16:24:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk0MTQ2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk0NDQyNw==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404944427", "bodyText": "Yikes ... compilation failure, Lemme fix this.", "author": "NiteshKant", "createdAt": "2020-04-07T16:26:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk0MTQ2OA=="}], "type": "inlineReview"}, {"oid": "2aac83d68480ef701171f98fa611d73ee5fd3b81", "url": "https://github.com/apple/servicetalk/commit/2aac83d68480ef701171f98fa611d73ee5fd3b81", "message": "Use `closeAsync()` in `close()`", "committedDate": "2020-04-07T16:23:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk2OTc2Ng==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404969766", "body": "```suggestion\r\nimport static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\r\nimport static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n          \n          \n            \n            import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n          \n          \n            \n            import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"39\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"><span class=\"pl-k\">import static</span> <span class=\"pl-smi\">io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"39\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"><span class=\"pl-k\">import static</span> <span class=\"pl-smi\">io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"40\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"><span class=\"pl-k\">import static</span> <span class=\"pl-smi\">io.servicetalk.concurrent.internal.FutureUtils.awaitTermination</span>;</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "NiteshKant", "createdAt": "2020-04-07T17:03:08Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -15,146 +15,95 @@\n  */\n package io.servicetalk.opentracing.zipkin.publisher;\n \n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.ListenableAsyncCloseable;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpan;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanEventListener;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanLog;\n \n-import io.netty.bootstrap.Bootstrap;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.ChannelOutboundHandlerAdapter;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.channel.EventLoopGroup;\n-import io.netty.channel.FixedRecvByteBufAllocator;\n-import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n-import io.netty.channel.socket.DatagramPacket;\n-import io.netty.util.concurrent.DefaultThreadFactory;\n import io.opentracing.tag.Tags;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import zipkin2.Endpoint;\n import zipkin2.Span;\n-import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n \n import java.io.Closeable;\n-import java.net.InetAddress;\n+import java.io.Flushable;\n+import java.io.IOException;\n import java.net.InetSocketAddress;\n-import java.net.SocketAddress;\n import java.util.Map;\n import javax.annotation.Nullable;\n \n-import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n-import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n-import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n-import static java.lang.Thread.currentThread;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;", "originalCommit": "2aac83d68480ef701171f98fa611d73ee5fd3b81", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk3MDI1Nw==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404970257", "body": "```suggestion\r\n        return awaitTermination(closeable.closeAsync().toFuture());\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return closeable.closeAsync();\n          \n          \n            \n                    return awaitTermination(closeable.closeAsync().toFuture());", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"203\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">return</span> closeable<span class=\"pl-k\">.</span>closeAsync();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"203\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">return</span> <span class=\"x x-first x-last\">awaitTermination(</span>closeable<span class=\"pl-k\">.</span>closeAsync(<span class=\"x x-first\">)</span><span class=\"pl-k x\">.</span><span class=\"x x-last\">toFuture()</span>);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "NiteshKant", "createdAt": "2020-04-07T17:03:43Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -278,6 +179,35 @@ public void onSpanFinished(final InMemorySpan span, long durationMicros) {\n             builder.kind(Span.Kind.CLIENT);\n         }\n \n-        channel.writeAndFlush(builder.build());\n+        Span s = builder.build();\n+        reporter.report(s);\n+    }\n+\n+    /**\n+     * Blocking close method delegates to {@link #closeAsync()}.\n+     */\n+    @Override\n+    public void close() throws Exception {\n+        closeable.closeAsync().toFuture().get();\n+    }\n+\n+    /**\n+     * Attempts to close the configured {@link Reporter}.\n+     *\n+     * @return a {@link Completable} that is completed when the close is done\n+     */\n+    @Override\n+    public Completable closeAsync() {\n+        return closeable.closeAsync();", "originalCommit": "2aac83d68480ef701171f98fa611d73ee5fd3b81", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2dd7864b573e54ee001fac3951bb45cf365bd160", "url": "https://github.com/apple/servicetalk/commit/2dd7864b573e54ee001fac3951bb45cf365bd160", "message": "Correctly implement `close()`", "committedDate": "2020-04-07T17:04:47Z", "type": "commit"}, {"oid": "957d185d4db98fb935624c75e44843a1d6691510", "url": "https://github.com/apple/servicetalk/commit/957d185d4db98fb935624c75e44843a1d6691510", "message": "Properly implementing UdpReporter\u2019s close method", "committedDate": "2020-04-07T19:18:51Z", "type": "forcePushed"}, {"oid": "478bf211dd809661394e56bad48d4a3b919f7a97", "url": "https://github.com/apple/servicetalk/commit/478bf211dd809661394e56bad48d4a3b919f7a97", "message": "Properly implementing UdpReporter\u2019s close method", "committedDate": "2020-04-07T19:39:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEwMDQyNg==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r405100426", "body": "```suggestion\r\n                close = graceful ? ((AsyncCloseable) reporter).closeAsyncGracefully() :\r\n                        ((AsyncCloseable) reporter).closeAsync();\r\n\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            close = ((AsyncCloseable) reporter).closeAsyncGracefully();\n          \n          \n            \n                            close = graceful ? ((AsyncCloseable) reporter).closeAsyncGracefully() :\n          \n          \n            \n                                    ((AsyncCloseable) reporter).closeAsync();", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                close <span class=\"pl-k\">=</span> ((<span class=\"pl-smi\">AsyncCloseable</span>) reporter)<span class=\"pl-k\">.</span>closeAsyncGracefully()<span class=\"x x-first x-last\">;</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                close <span class=\"pl-k\">=</span> <span class=\"x x-first\">graceful </span><span class=\"pl-k x\">?</span><span class=\"x x-last\"> </span>((<span class=\"pl-smi\">AsyncCloseable</span>) reporter)<span class=\"pl-k\">.</span>closeAsyncGracefully()<span class=\"x x-first\"> </span><span class=\"pl-k x x-last\">:</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                        ((<span class=\"pl-smi\">AsyncCloseable</span>) reporter)<span class=\"pl-k\">.</span>closeAsync();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "NiteshKant", "createdAt": "2020-04-07T20:43:46Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -15,146 +15,96 @@\n  */\n package io.servicetalk.opentracing.zipkin.publisher;\n \n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.ListenableAsyncCloseable;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpan;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanEventListener;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanLog;\n \n-import io.netty.bootstrap.Bootstrap;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.ChannelOutboundHandlerAdapter;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.channel.EventLoopGroup;\n-import io.netty.channel.FixedRecvByteBufAllocator;\n-import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n-import io.netty.channel.socket.DatagramPacket;\n-import io.netty.util.concurrent.DefaultThreadFactory;\n import io.opentracing.tag.Tags;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import zipkin2.Endpoint;\n import zipkin2.Span;\n-import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n \n import java.io.Closeable;\n-import java.net.InetAddress;\n+import java.io.Flushable;\n+import java.io.IOException;\n import java.net.InetSocketAddress;\n-import java.net.SocketAddress;\n import java.util.Map;\n import javax.annotation.Nullable;\n \n-import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n-import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n-import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n-import static java.lang.Thread.currentThread;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n import static java.util.Objects.requireNonNull;\n-import static java.util.concurrent.TimeUnit.SECONDS;\n \n /**\n  * A publisher of {@link io.opentracing.Span}s to the zipkin transport.\n  */\n-public final class ZipkinPublisher implements InMemorySpanEventListener, Closeable {\n-    private static final Logger logger = LoggerFactory.getLogger(ZipkinPublisher.class);\n+public final class ZipkinPublisher implements InMemorySpanEventListener, AsyncCloseable, Closeable {\n \n-    /**\n-     * The default maximum {@link DatagramPacket} size.\n-     */\n-    private static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048;\n-    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n-            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+    private static final Logger logger = LoggerFactory.getLogger(ZipkinPublisher.class);\n \n+    private final Reporter<Span> reporter;\n     private final Endpoint endpoint;\n-    private final EventLoopGroup group;\n-    private final Channel channel;\n-\n-    /**\n-     * The serialization format for the zipkin write format data.\n-     */\n-    public enum Encoder {\n-        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n-        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n-\n-        final SpanBytesEncoder encoder;\n-\n-        Encoder(SpanBytesEncoder encoder) {\n-            this.encoder = encoder;\n-        }\n-    }\n-\n-    /**\n-     * The networking transport to use.\n-     */\n-    public enum Transport {\n-        UDP {\n-            Bootstrap buildBootstrap(EventLoopGroup group, Encoder encoder, SocketAddress collectorAddress) {\n-                if (!(collectorAddress instanceof InetSocketAddress)) {\n-                    throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n-                            \" is invalid for transport \" + this);\n-                }\n-                return new Bootstrap()\n-                        .group(group)\n-                        .channel(datagramChannel(group))\n-                        .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n-                        .handler(new ChannelOutboundHandlerAdapter() {\n-                            @Override\n-                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n-                                if (msg instanceof Span) {\n-                                    byte[] bytes = encoder.encoder.encode((Span) msg);\n-                                    ctx.write(new DatagramPacket(Unpooled.wrappedBuffer(bytes),\n-                                            (InetSocketAddress) collectorAddress));\n-                                } else {\n-                                    ctx.write(msg, promise);\n-                                }\n-                            }\n-                        });\n+    private final ListenableAsyncCloseable closeable;\n+\n+    private ZipkinPublisher(final String serviceName,\n+                            final Reporter<Span> reporter,\n+                            @Nullable final InetSocketAddress localSocketAddress) {\n+        this.reporter = reporter;\n+        this.endpoint = buildEndpoint(serviceName, localSocketAddress);\n+        this.closeable = toAsyncCloseable(graceful -> {\n+            // Some Reporter implementations may batch and need an explicit flush before closing (AsyncReporter)\n+            Completable flush = Completable.completed();\n+            if (graceful && reporter instanceof Flushable) {\n+                flush = globalExecutionContext().executor().submit(() -> {\n+                    try {\n+                        ((Flushable) reporter).flush();\n+                    } catch (IOException e) {\n+                        logger.error(\"Exception while flushing reporter: {}\", e.getMessage(), e);\n+                    }\n+                });\n             }\n-        };\n-\n-        abstract Bootstrap buildBootstrap(EventLoopGroup group, Encoder encoder, SocketAddress collectorAddress);\n+            // ST Reporters can implement AsyncCloseable so we wouldn't have to call a blocking close in that case\n+            Completable close = Completable.completed();\n+            if (reporter instanceof AsyncCloseable) {\n+                close = ((AsyncCloseable) reporter).closeAsyncGracefully();", "originalCommit": "478bf211dd809661394e56bad48d4a3b919f7a97", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTExNzQ3MA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r405117470", "body": "```suggestion\r\n         * Sets an {@link Executor} to use when required. \r\n```\r\n\r\nAvoid stating defaults in documentation.", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * Sets an {@link Executor} to use for offloading various tasks. Defaults to the {@link GlobalExecutionContext}\n          \n          \n            \n                     * {@link Executor}.\n          \n          \n            \n                     * Sets an {@link Executor} to use when required. \n          \n      \n    \n    \n  \n\nAvoid stating defaults in documentation.", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">         <span class=\"pl-k\">*</span> <span class=\"pl-smi\">Sets</span> an {<span class=\"pl-k\">@link</span> <span class=\"pl-smi\">Executor</span>} to use <span class=\"pl-k\">for</span> offloading various tasks. <span class=\"pl-smi\">Defaults</span> to the {<span class=\"pl-k\">@link</span> <span class=\"pl-smi\">GlobalExecutionContext</span>}</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">         <span class=\"pl-k\">*</span> {<span class=\"pl-k\">@link</span> <span class=\"pl-smi\">Executor</span>}<span class=\"pl-c1\">.</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">         <span class=\"pl-k\">*</span> <span class=\"pl-smi\">Sets</span> an {<span class=\"pl-k\">@link</span> <span class=\"pl-smi\">Executor</span>} to use when required. </td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n\n<p dir=\"auto\">Avoid stating defaults in documentation.</p>", "author": "NiteshKant", "createdAt": "2020-04-07T21:15:06Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.ListenableAsyncCloseable;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.GlobalExecutionContext;\n+import io.servicetalk.transport.netty.internal.NettyChannelListenableAsyncCloseable;\n+import io.servicetalk.transport.netty.internal.StacklessClosedChannelException;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LogLevel;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.slf4j.event.Level;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to a UDP listener with a configurable encoding {@link Codec}.\n+ */\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    private static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final Channel channel;\n+    private final ListenableAsyncCloseable closeable;\n+\n+    private UdpReporter(final Builder builder) {\n+        EventLoopGroup group = toEventLoopAwareNettyIoExecutor(\n+                builder.ioExecutor != null ? builder.ioExecutor : globalExecutionContext().ioExecutor()\n+        ).eventLoopGroup();\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress,\n+                    builder.loggerName);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            throw e;\n+        }\n+        Executor executor = builder.executor != null ? builder.executor :\n+                globalExecutionContext().executor();\n+        closeable = new NettyChannelListenableAsyncCloseable(channel, executor);\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    /**\n+     * A builder to create a new {@link UdpReporter}.\n+     */\n+    public static final class Builder {\n+        private final SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+        @Nullable\n+        private IoExecutor ioExecutor;\n+        @Nullable\n+        private Executor executor;\n+        @Nullable\n+        private String loggerName;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         *\n+         * @param collectorAddress the collector SocketAddress\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        /**\n+         * Sets the {@link UdpReporter.Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an {@link IoExecutor} to use for writing to the datagram channel. Defaults to the\n+         * {@link GlobalExecutionContext} {@link IoExecutor}.\n+         *\n+         * @param ioExecutor IoExecutor to use to write with.\n+         * @return {@code this}\n+         */\n+        public Builder ioExecutor(IoExecutor ioExecutor) {\n+            this.ioExecutor = requireNonNull(ioExecutor);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an {@link Executor} to use for offloading various tasks. Defaults to the {@link GlobalExecutionContext}\n+         * {@link Executor}.", "originalCommit": "478bf211dd809661394e56bad48d4a3b919f7a97", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEyMDc1MQ==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r405120751", "bodyText": "Why?", "author": "colestanfield", "createdAt": "2020-04-07T21:21:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTExNzQ3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNTAxNQ==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r405135015", "bodyText": "Stating defaults in docs means that we have less flexibility to change them in the future. If a user cares about a default value (more than just knowledge), it is a better option to explicitly use that default value so that if the defaults change they are not surprised.", "author": "NiteshKant", "createdAt": "2020-04-07T21:51:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTExNzQ3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTExNzU3NA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r405117574", "body": "```suggestion\r\n         * @param executor {@link Executor} to use.\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * @param executor {@link Executor} to offload close to\n          \n          \n            \n                     * @param executor {@link Executor} to use.", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">         <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> executor {<span class=\"pl-k\">@link</span> <span class=\"pl-smi\">Executor</span>} to <span class=\"x x-first x-last\">offload close to</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">         <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> executor {<span class=\"pl-k\">@link</span> <span class=\"pl-smi\">Executor</span>} to <span class=\"x x-first x-last\">use.</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "NiteshKant", "createdAt": "2020-04-07T21:15:18Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.ListenableAsyncCloseable;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.GlobalExecutionContext;\n+import io.servicetalk.transport.netty.internal.NettyChannelListenableAsyncCloseable;\n+import io.servicetalk.transport.netty.internal.StacklessClosedChannelException;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LogLevel;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.slf4j.event.Level;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to a UDP listener with a configurable encoding {@link Codec}.\n+ */\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    private static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final Channel channel;\n+    private final ListenableAsyncCloseable closeable;\n+\n+    private UdpReporter(final Builder builder) {\n+        EventLoopGroup group = toEventLoopAwareNettyIoExecutor(\n+                builder.ioExecutor != null ? builder.ioExecutor : globalExecutionContext().ioExecutor()\n+        ).eventLoopGroup();\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress,\n+                    builder.loggerName);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            throw e;\n+        }\n+        Executor executor = builder.executor != null ? builder.executor :\n+                globalExecutionContext().executor();\n+        closeable = new NettyChannelListenableAsyncCloseable(channel, executor);\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    /**\n+     * A builder to create a new {@link UdpReporter}.\n+     */\n+    public static final class Builder {\n+        private final SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+        @Nullable\n+        private IoExecutor ioExecutor;\n+        @Nullable\n+        private Executor executor;\n+        @Nullable\n+        private String loggerName;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         *\n+         * @param collectorAddress the collector SocketAddress\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        /**\n+         * Sets the {@link UdpReporter.Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an {@link IoExecutor} to use for writing to the datagram channel. Defaults to the\n+         * {@link GlobalExecutionContext} {@link IoExecutor}.\n+         *\n+         * @param ioExecutor IoExecutor to use to write with.\n+         * @return {@code this}\n+         */\n+        public Builder ioExecutor(IoExecutor ioExecutor) {\n+            this.ioExecutor = requireNonNull(ioExecutor);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an {@link Executor} to use for offloading various tasks. Defaults to the {@link GlobalExecutionContext}\n+         * {@link Executor}.\n+         *\n+         * @param executor {@link Executor} to offload close to", "originalCommit": "478bf211dd809661394e56bad48d4a3b919f7a97", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTExNzk1MA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r405117950", "body": "Also override `closeAsyncGracefully()`\r\n\r\n```suggestion\r\n    }\r\n\r\n    @Override\r\n    public Completable closeAsyncGracefully() {\r\n        return closeable.closeAsyncGracefully();\r\n    }    \r\n```", "bodyText": "Also override closeAsyncGracefully()\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                @Override\n          \n          \n            \n                public Completable closeAsyncGracefully() {\n          \n          \n            \n                    return closeable.closeAsyncGracefully();\n          \n          \n            \n                }", "bodyHTML": "<p dir=\"auto\">Also override <code>closeAsyncGracefully()</code></p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"250\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"250\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"251\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"252\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">@Override</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"253\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">public</span> <span class=\"pl-smi\">Completable</span> closeAsyncGracefully() {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"254\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">return</span> closeable<span class=\"pl-k\">.</span>closeAsyncGracefully();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"255\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    }    </td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "NiteshKant", "createdAt": "2020-04-07T21:16:09Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.ListenableAsyncCloseable;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.GlobalExecutionContext;\n+import io.servicetalk.transport.netty.internal.NettyChannelListenableAsyncCloseable;\n+import io.servicetalk.transport.netty.internal.StacklessClosedChannelException;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LogLevel;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.slf4j.event.Level;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to a UDP listener with a configurable encoding {@link Codec}.\n+ */\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    private static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final Channel channel;\n+    private final ListenableAsyncCloseable closeable;\n+\n+    private UdpReporter(final Builder builder) {\n+        EventLoopGroup group = toEventLoopAwareNettyIoExecutor(\n+                builder.ioExecutor != null ? builder.ioExecutor : globalExecutionContext().ioExecutor()\n+        ).eventLoopGroup();\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress,\n+                    builder.loggerName);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            throw e;\n+        }\n+        Executor executor = builder.executor != null ? builder.executor :\n+                globalExecutionContext().executor();\n+        closeable = new NettyChannelListenableAsyncCloseable(channel, executor);\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    /**\n+     * A builder to create a new {@link UdpReporter}.\n+     */\n+    public static final class Builder {\n+        private final SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+        @Nullable\n+        private IoExecutor ioExecutor;\n+        @Nullable\n+        private Executor executor;\n+        @Nullable\n+        private String loggerName;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         *\n+         * @param collectorAddress the collector SocketAddress\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        /**\n+         * Sets the {@link UdpReporter.Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an {@link IoExecutor} to use for writing to the datagram channel. Defaults to the\n+         * {@link GlobalExecutionContext} {@link IoExecutor}.\n+         *\n+         * @param ioExecutor IoExecutor to use to write with.\n+         * @return {@code this}\n+         */\n+        public Builder ioExecutor(IoExecutor ioExecutor) {\n+            this.ioExecutor = requireNonNull(ioExecutor);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an {@link Executor} to use for offloading various tasks. Defaults to the {@link GlobalExecutionContext}\n+         * {@link Executor}.\n+         *\n+         * @param executor {@link Executor} to offload close to\n+         * @return {@code this}\n+         */\n+        public Builder executor(Executor executor) {\n+            this.executor = executor;\n+            return this;\n+        }\n+\n+        /**\n+         * Enables wire-logging for udp packets sent.\n+         * <p>\n+         * All wire events will be logged at {@link Level#TRACE TRACE} level.\n+         *\n+         * @param loggerName The name of the logger to log wire events.\n+         * @return {@code this}\n+         */\n+        public Builder enableWireLogging(String loggerName) {\n+            this.loggerName = loggerName;\n+            return this;\n+        }\n+\n+        /**\n+         * Builds a new {@link UdpReporter} instance with this builder's options.\n+         * <p>\n+         * This method may block while the underlying UDP channel is being bound.\n+         *\n+         * @return a new {@link UdpReporter}\n+         */\n+        public UdpReporter build() {\n+            return new UdpReporter(this);\n+        }\n+    }\n+\n+    private Bootstrap buildBootstrap(EventLoopGroup group, Codec codec, SocketAddress collectorAddress,\n+                                     @Nullable String loggerName) {\n+        if (!(collectorAddress instanceof InetSocketAddress)) {\n+            throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n+                    \" is invalid for UDP\");\n+        }\n+        return new Bootstrap()\n+                .group(group)\n+                .channel(datagramChannel(group))\n+                .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n+                .handler(new ChannelInitializer<Channel>() {\n+                    @Override\n+                    protected void initChannel(final Channel ch) {\n+                        if (loggerName != null) {\n+                            ch.pipeline().addLast(new LoggingHandler(loggerName, LogLevel.TRACE));\n+                        }\n+                        ch.pipeline().addLast(new ChannelOutboundHandlerAdapter() {\n+                            @Override\n+                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+                                if (msg instanceof Span) {\n+                                    byte[] bytes = codec.encoder.encode((Span) msg);\n+                                    ByteBuf buf = ctx.alloc().buffer(bytes.length).writeBytes(bytes);\n+                                    ctx.write(new DatagramPacket(buf, (InetSocketAddress) collectorAddress), promise);\n+                                } else {\n+                                    ctx.write(msg, promise);\n+                                }\n+                            }\n+                        });\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Non-blocking report method.\n+     *\n+     * @param span the span to report\n+     */\n+    @Override\n+    public void report(final Span span) {\n+        if (!channel.isActive()) {\n+            throw new RuntimeException(StacklessClosedChannelException.newInstance(this.getClass(), \"report\"));\n+        }\n+        channel.writeAndFlush(span);\n+    }\n+\n+    /**\n+     * Blocking close method delegates to {@link #closeAsync()}).\n+     */\n+    @Override\n+    public void close() {\n+        awaitTermination(closeable.closeAsync().toFuture());\n+    }\n+\n+    /**\n+     * Marks the {@link UdpReporter} as closed to prevent accepting any more {@link Span}s.\n+     *\n+     * @return a {@link Completable} that is completed when close is done.\n+     */\n+    @Override\n+    public Completable closeAsync() {\n+        return closeable.closeAsync();\n+    }", "originalCommit": "478bf211dd809661394e56bad48d4a3b919f7a97", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "910beb0b06b3219b345dbcdffe0953cb8dc51ef3", "url": "https://github.com/apple/servicetalk/commit/910beb0b06b3219b345dbcdffe0953cb8dc51ef3", "message": "Properly implementing UdpReporter\u2019s close method", "committedDate": "2020-04-07T21:36:05Z", "type": "commit"}, {"oid": "910beb0b06b3219b345dbcdffe0953cb8dc51ef3", "url": "https://github.com/apple/servicetalk/commit/910beb0b06b3219b345dbcdffe0953cb8dc51ef3", "message": "Properly implementing UdpReporter\u2019s close method", "committedDate": "2020-04-07T21:36:05Z", "type": "forcePushed"}]}