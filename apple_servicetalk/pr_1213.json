{"pr_number": 1213, "pr_title": "Fix transformed aggregated requests with missing trailers", "pr_author": "tkountis", "pr_createdAt": "2020-11-16T17:04:31Z", "pr_url": "https://github.com/apple/servicetalk/pull/1213", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQzMDgyMA==", "url": "https://github.com/apple/servicetalk/pull/1213#discussion_r524430820", "body": "Append trailers when the result of the reduction is a list of items.\r\n\r\nTrailers should not be here, reasoning:\r\n- When trailers exist according to spec, the transfer encoding should be chunked\r\n- When the payload 'mayHaveTrailers==true' this flow is avoided\r\n- The `calculateContentLength(item)` method already checks instance type and throws exception if not buffer.", "bodyText": "Append trailers when the result of the reduction is a list of items.\nTrailers should not be here, reasoning:\n\nWhen trailers exist according to spec, the transfer encoding should be chunked\nWhen the payload 'mayHaveTrailers==true' this flow is avoided\nThe calculateContentLength(item) method already checks instance type and throws exception if not buffer.", "bodyHTML": "<p dir=\"auto\">Append trailers when the result of the reduction is a list of items.</p>\n<p dir=\"auto\">Trailers should not be here, reasoning:</p>\n<ul dir=\"auto\">\n<li>When trailers exist according to spec, the transfer encoding should be chunked</li>\n<li>When the payload 'mayHaveTrailers==true' this flow is avoided</li>\n<li>The <code>calculateContentLength(item)</code> method already checks instance type and throws exception if not buffer.</li>\n</ul>", "author": "tkountis", "createdAt": "2020-11-16T17:08:48Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HeaderUtils.java", "diffHunk": "@@ -182,10 +183,12 @@ private static void updateResponseContentLength(final int contentLength, final H\n                 flatRequest = from(metadata, EmptyHttpHeaders.INSTANCE);\n             } else if (reduction instanceof List) {\n                 final List<?> items = (List<?>) reduction;\n-                for (int i = 0; i < items.size(); i++) {\n-                    contentLength += calculateContentLength(items.get(i));\n+                for (Object item : items) {\n+                    contentLength += calculateContentLength(item);\n                 }\n-                flatRequest = Publisher.<Object>from(metadata).concat(fromIterable(items));\n+                flatRequest = Publisher.<Object>from(metadata)\n+                        .concat(fromIterable(items))\n+                        .concat(succeeded(EmptyHttpHeaders.INSTANCE));", "originalCommit": "a2c12893734841eea9c18d033884cccf944f7624", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQzMjQyMg==", "url": "https://github.com/apple/servicetalk/pull/1213#discussion_r524432422", "body": "When a request/response is transformed then we have no info of the new payload, thus we revert safe-to-aggregate back to false. ", "bodyText": "When a request/response is transformed then we have no info of the new payload, thus we revert safe-to-aggregate back to false.", "bodyHTML": "<p dir=\"auto\">When a request/response is transformed then we have no info of the new payload, thus we revert safe-to-aggregate back to false.</p>", "author": "tkountis", "createdAt": "2020-11-16T17:10:14Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/StreamingHttpPayloadHolder.java", "diffHunk": "@@ -222,6 +223,9 @@ private void updatePayloadBody(Publisher<Buffer> newPayload, boolean isTransform\n                 // payloadBody() will split trailers if not yet split\n                 newPayload.liftSync(new BridgeFlowControlAndDiscardOperator(payloadBody()));\n         payloadInfo.setOnlyEmitsBuffer(true);\n+        if (isTransform) {\n+            payloadInfo.setSafeToAggregate(false);", "originalCommit": "a2c12893734841eea9c18d033884cccf944f7624", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzNTY3Mw==", "url": "https://github.com/apple/servicetalk/pull/1213#discussion_r525535673", "bodyText": "Discussed offline: users of aggregated API usually assume that the payload body always fits in memory. Transform functions are usually used for logging/metrics/decoration. If they have a use-case when transformation changes the size significantly, they have to handle it using streaming API.", "author": "idelpivnitskiy", "createdAt": "2020-11-17T21:27:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQzMjQyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzNDIyMg==", "url": "https://github.com/apple/servicetalk/pull/1213#discussion_r525534222", "body": "Instead of adding a new test class, consider enhancing the existing one:\r\n```\r\nIndex: servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/ContentLengthTest.java\r\nIDEA additional info:\r\nSubsystem: com.intellij.openapi.diff.impl.patch.CharsetEP\r\n<+>UTF-8\r\n===================================================================\r\n--- servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/ContentLengthTest.java\t(revision a2c12893734841eea9c18d033884cccf944f7624)\r\n+++ servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/ContentLengthTest.java\t(date 1605648191399)\r\n@@ -1,5 +1,5 @@\r\n /*\r\n- * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\r\n+ * Copyright \u00a9 2019-2020 Apple Inc. and the ServiceTalk project authors\r\n  *\r\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  * you may not use this file except in compliance with the License.\r\n@@ -15,10 +15,13 @@\r\n  */\r\n package io.servicetalk.http.netty;\r\n \r\n+import io.servicetalk.buffer.api.Buffer;\r\n import io.servicetalk.concurrent.api.Publisher;\r\n import io.servicetalk.http.api.DefaultHttpHeadersFactory;\r\n+import io.servicetalk.http.api.HttpHeaders;\r\n import io.servicetalk.http.api.HttpMetaData;\r\n import io.servicetalk.http.api.HttpRequest;\r\n+import io.servicetalk.http.api.HttpRequestMethod;\r\n import io.servicetalk.http.api.HttpResponse;\r\n import io.servicetalk.http.api.StreamingHttpRequest;\r\n import io.servicetalk.http.api.StreamingHttpRequests;\r\n@@ -28,23 +31,34 @@\r\n import org.junit.Test;\r\n \r\n import java.util.Collection;\r\n+import java.util.Iterator;\r\n \r\n+import static io.servicetalk.buffer.api.ReadOnlyBufferAllocators.DEFAULT_RO_ALLOCATOR;\r\n import static io.servicetalk.buffer.netty.BufferAllocators.DEFAULT_ALLOCATOR;\r\n import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_LENGTH;\r\n import static io.servicetalk.http.api.HttpProtocolVersion.HTTP_1_1;\r\n+import static io.servicetalk.http.api.HttpRequestMethod.CONNECT;\r\n+import static io.servicetalk.http.api.HttpRequestMethod.DELETE;\r\n import static io.servicetalk.http.api.HttpRequestMethod.GET;\r\n+import static io.servicetalk.http.api.HttpRequestMethod.HEAD;\r\n+import static io.servicetalk.http.api.HttpRequestMethod.OPTIONS;\r\n+import static io.servicetalk.http.api.HttpRequestMethod.PATCH;\r\n+import static io.servicetalk.http.api.HttpRequestMethod.POST;\r\n+import static io.servicetalk.http.api.HttpRequestMethod.PUT;\r\n+import static io.servicetalk.http.api.HttpRequestMethod.TRACE;\r\n import static io.servicetalk.http.api.HttpResponseStatus.OK;\r\n+import static io.servicetalk.http.api.HttpSerializationProviders.textDeserializer;\r\n import static io.servicetalk.http.api.HttpSerializationProviders.textSerializer;\r\n import static io.servicetalk.http.api.StreamingHttpResponses.newResponse;\r\n import static io.servicetalk.http.netty.AbstractNettyHttpServerTest.ExecutorSupplier.CACHED;\r\n import static io.servicetalk.http.netty.HeaderUtils.setRequestContentLength;\r\n import static io.servicetalk.http.netty.HeaderUtils.setResponseContentLength;\r\n+import static org.hamcrest.MatcherAssert.assertThat;\r\n import static org.hamcrest.Matchers.greaterThanOrEqualTo;\r\n import static org.hamcrest.Matchers.hasSize;\r\n import static org.hamcrest.Matchers.instanceOf;\r\n import static org.hamcrest.Matchers.is;\r\n import static org.hamcrest.Matchers.nullValue;\r\n-import static org.junit.Assert.assertThat;\r\n \r\n public class ContentLengthTest extends AbstractNettyHttpServerTest {\r\n \r\n@@ -55,12 +69,36 @@\r\n     }\r\n \r\n     @Test\r\n-    public void shouldCalculateRequestContentLengthFromEmptyPublisher() throws Exception {\r\n-        StreamingHttpRequest request = newAggregatedRequest().toStreamingRequest()\r\n+    public void shouldNotCalculateRequestContentLengthFromEmptyPublisherForGetRequest() throws Exception {\r\n+        shouldNotCalculateRequestContentLengthFromEmptyPublisher(GET);\r\n+        shouldNotCalculateRequestContentLengthFromEmptyPublisher(HEAD);\r\n+        shouldNotCalculateRequestContentLengthFromEmptyPublisher(DELETE);\r\n+        shouldNotCalculateRequestContentLengthFromEmptyPublisher(CONNECT);\r\n+        shouldNotCalculateRequestContentLengthFromEmptyPublisher(OPTIONS);\r\n+        shouldNotCalculateRequestContentLengthFromEmptyPublisher(TRACE);\r\n+    }\r\n+\r\n+    private static void shouldNotCalculateRequestContentLengthFromEmptyPublisher(HttpRequestMethod method)\r\n+            throws Exception {\r\n+        StreamingHttpRequest request = newAggregatedRequest(method).toStreamingRequest()\r\n                 .payloadBody(Publisher.empty());\r\n         setRequestContentLengthAndVerify(request, nullValue(CharSequence.class));\r\n     }\r\n \r\n+    @Test\r\n+    public void shouldCalculateRequestContentLengthFromEmptyPublisherForPostRequest() throws Exception {\r\n+        shouldCalculateRequestContentLengthFromEmptyPublisher(POST);\r\n+        shouldCalculateRequestContentLengthFromEmptyPublisher(PUT);\r\n+        shouldCalculateRequestContentLengthFromEmptyPublisher(PATCH);\r\n+    }\r\n+\r\n+    private static void shouldCalculateRequestContentLengthFromEmptyPublisher(HttpRequestMethod method)\r\n+            throws Exception {\r\n+        StreamingHttpRequest request = newAggregatedRequest(method).toStreamingRequest()\r\n+                .payloadBody(Publisher.empty());\r\n+        setRequestContentLengthAndVerify(request, is(\"0\"));\r\n+    }\r\n+\r\n     @Test\r\n     public void shouldCalculateRequestContentLengthFromSingleItemPublisher() throws Exception {\r\n         StreamingHttpRequest request = newAggregatedRequest().toStreamingRequest()\r\n@@ -82,6 +120,22 @@\r\n         setRequestContentLengthAndVerify(request, is(\"12\"));\r\n     }\r\n \r\n+    @Test\r\n+    public void shouldCalculateRequestContentLengthFromTransformedMultipleItemPublisher() throws Exception {\r\n+        StreamingHttpRequest request = newAggregatedRequest().payloadBody(\"Hello\", textSerializer())\r\n+                .toStreamingRequest().transformPayloadBody(payload -> payload.concat(Publisher.from(\" \", \"World\", \"!\")),\r\n+                        textDeserializer(), textSerializer());\r\n+        setRequestContentLengthAndVerify(request, is(\"12\"));\r\n+    }\r\n+\r\n+    @Test\r\n+    public void shouldCalculateRequestContentLengthFromTransformedRawMultipleItemPublisher() throws Exception {\r\n+        StreamingHttpRequest request = newAggregatedRequest().payloadBody(\"Hello\", textSerializer())\r\n+                .toStreamingRequest().transformRawPayloadBody(payload -> payload.map(obj -> (Buffer) obj)\r\n+                        .concat(Publisher.from(\" \", \"World\", \"!\").map(DEFAULT_RO_ALLOCATOR::fromAscii)));\r\n+        setRequestContentLengthAndVerify(request, is(\"12\"));\r\n+    }\r\n+\r\n     @Test\r\n     public void shouldCalculateResponseContentLengthFromEmptyPublisher() throws Exception {\r\n         StreamingHttpResponse response = newAggregatedResponse().toStreamingResponse()\r\n@@ -110,8 +164,28 @@\r\n         setResponseContentLengthAndVerify(response, is(\"12\"));\r\n     }\r\n \r\n+    @Test\r\n+    public void shouldCalculateResponseContentLengthFromTransformedMultipleItemPublisher() throws Exception {\r\n+        StreamingHttpResponse response = newAggregatedResponse().payloadBody(\"Hello\", textSerializer())\r\n+                .toStreamingResponse().transformPayloadBody(payload -> payload.concat(Publisher.from(\" \", \"World\", \"!\")),\r\n+                        textDeserializer(), textSerializer());\r\n+        setResponseContentLengthAndVerify(response, is(\"12\"));\r\n+    }\r\n+\r\n+    @Test\r\n+    public void shouldCalculateResponseContentLengthFromTransformedRawMultipleItemPublisher() throws Exception {\r\n+        StreamingHttpResponse response = newAggregatedResponse().payloadBody(\"Hello\", textSerializer())\r\n+                .toStreamingResponse().transformRawPayloadBody(payload -> payload.map(obj -> (Buffer) obj)\r\n+                        .concat(Publisher.from(\" \", \"World\", \"!\").map(DEFAULT_RO_ALLOCATOR::fromAscii)));\r\n+        setResponseContentLengthAndVerify(response, is(\"12\"));\r\n+    }\r\n+\r\n     private static HttpRequest newAggregatedRequest() {\r\n-        return awaitSingleIndefinitelyNonNull(StreamingHttpRequests.newRequest(GET, \"/\", HTTP_1_1,\r\n+        return newAggregatedRequest(GET);\r\n+    }\r\n+\r\n+    private static HttpRequest newAggregatedRequest(HttpRequestMethod method) {\r\n+        return awaitSingleIndefinitelyNonNull(StreamingHttpRequests.newRequest(method, \"/\", HTTP_1_1,\r\n                 headersFactory.newHeaders(), DEFAULT_ALLOCATOR, headersFactory).toRequest());\r\n     }\r\n \r\n@@ -124,17 +198,29 @@\r\n                                                          final Matcher<CharSequence> matcher) throws Exception {\r\n         Collection<Object> flattened = setRequestContentLength(request).toFuture().get();\r\n         assertThat(\"Unexpected items in the flattened request.\", flattened, hasSize(greaterThanOrEqualTo(2)));\r\n-        Object firstItem = flattened.iterator().next();\r\n+        Iterator<Object> iterator = flattened.iterator();\r\n+        Object firstItem = iterator.next();\r\n         assertThat(\"Unexpected items in the flattened request.\", firstItem, is(instanceOf(HttpMetaData.class)));\r\n         assertThat(((HttpMetaData) firstItem).headers().get(CONTENT_LENGTH), matcher);\r\n+        assertLastItem(iterator);\r\n     }\r\n \r\n     private static void setResponseContentLengthAndVerify(final StreamingHttpResponse response,\r\n                                                           final Matcher<CharSequence> matcher) throws Exception {\r\n         Collection<Object> flattened = setResponseContentLength(response).toFuture().get();\r\n         assertThat(\"Unexpected items in the flattened response.\", flattened, hasSize(greaterThanOrEqualTo(2)));\r\n-        Object firstItem = flattened.iterator().next();\r\n+        Iterator<Object> iterator = flattened.iterator();\r\n+        Object firstItem = iterator.next();\r\n         assertThat(\"Unexpected items in the flattened response.\", firstItem, is(instanceOf(HttpMetaData.class)));\r\n         assertThat(((HttpMetaData) firstItem).headers().get(CONTENT_LENGTH), matcher);\r\n+        assertLastItem(iterator);\r\n+    }\r\n+\r\n+    private static void assertLastItem(Iterator<Object> iterator) {\r\n+        Object item = null;\r\n+        while (iterator.hasNext()) {\r\n+            item = iterator.next();\r\n+        }\r\n+        assertThat(\"Unexpected last item in the flattened stream.\", item, is(instanceOf(HttpHeaders.class)));\r\n     }\r\n }\r\n```\r\nFeel free to add more test cases there if I missed something.", "bodyText": "Instead of adding a new test class, consider enhancing the existing one:\nIndex: servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/ContentLengthTest.java\nIDEA additional info:\nSubsystem: com.intellij.openapi.diff.impl.patch.CharsetEP\n<+>UTF-8\n===================================================================\n--- servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/ContentLengthTest.java\t(revision a2c12893734841eea9c18d033884cccf944f7624)\n+++ servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/ContentLengthTest.java\t(date 1605648191399)\n@@ -1,5 +1,5 @@\n /*\n- * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ * Copyright \u00a9 2019-2020 Apple Inc. and the ServiceTalk project authors\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -15,10 +15,13 @@\n  */\n package io.servicetalk.http.netty;\n \n+import io.servicetalk.buffer.api.Buffer;\n import io.servicetalk.concurrent.api.Publisher;\n import io.servicetalk.http.api.DefaultHttpHeadersFactory;\n+import io.servicetalk.http.api.HttpHeaders;\n import io.servicetalk.http.api.HttpMetaData;\n import io.servicetalk.http.api.HttpRequest;\n+import io.servicetalk.http.api.HttpRequestMethod;\n import io.servicetalk.http.api.HttpResponse;\n import io.servicetalk.http.api.StreamingHttpRequest;\n import io.servicetalk.http.api.StreamingHttpRequests;\n@@ -28,23 +31,34 @@\n import org.junit.Test;\n \n import java.util.Collection;\n+import java.util.Iterator;\n \n+import static io.servicetalk.buffer.api.ReadOnlyBufferAllocators.DEFAULT_RO_ALLOCATOR;\n import static io.servicetalk.buffer.netty.BufferAllocators.DEFAULT_ALLOCATOR;\n import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_LENGTH;\n import static io.servicetalk.http.api.HttpProtocolVersion.HTTP_1_1;\n+import static io.servicetalk.http.api.HttpRequestMethod.CONNECT;\n+import static io.servicetalk.http.api.HttpRequestMethod.DELETE;\n import static io.servicetalk.http.api.HttpRequestMethod.GET;\n+import static io.servicetalk.http.api.HttpRequestMethod.HEAD;\n+import static io.servicetalk.http.api.HttpRequestMethod.OPTIONS;\n+import static io.servicetalk.http.api.HttpRequestMethod.PATCH;\n+import static io.servicetalk.http.api.HttpRequestMethod.POST;\n+import static io.servicetalk.http.api.HttpRequestMethod.PUT;\n+import static io.servicetalk.http.api.HttpRequestMethod.TRACE;\n import static io.servicetalk.http.api.HttpResponseStatus.OK;\n+import static io.servicetalk.http.api.HttpSerializationProviders.textDeserializer;\n import static io.servicetalk.http.api.HttpSerializationProviders.textSerializer;\n import static io.servicetalk.http.api.StreamingHttpResponses.newResponse;\n import static io.servicetalk.http.netty.AbstractNettyHttpServerTest.ExecutorSupplier.CACHED;\n import static io.servicetalk.http.netty.HeaderUtils.setRequestContentLength;\n import static io.servicetalk.http.netty.HeaderUtils.setResponseContentLength;\n+import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n import static org.hamcrest.Matchers.hasSize;\n import static org.hamcrest.Matchers.instanceOf;\n import static org.hamcrest.Matchers.is;\n import static org.hamcrest.Matchers.nullValue;\n-import static org.junit.Assert.assertThat;\n \n public class ContentLengthTest extends AbstractNettyHttpServerTest {\n \n@@ -55,12 +69,36 @@\n     }\n \n     @Test\n-    public void shouldCalculateRequestContentLengthFromEmptyPublisher() throws Exception {\n-        StreamingHttpRequest request = newAggregatedRequest().toStreamingRequest()\n+    public void shouldNotCalculateRequestContentLengthFromEmptyPublisherForGetRequest() throws Exception {\n+        shouldNotCalculateRequestContentLengthFromEmptyPublisher(GET);\n+        shouldNotCalculateRequestContentLengthFromEmptyPublisher(HEAD);\n+        shouldNotCalculateRequestContentLengthFromEmptyPublisher(DELETE);\n+        shouldNotCalculateRequestContentLengthFromEmptyPublisher(CONNECT);\n+        shouldNotCalculateRequestContentLengthFromEmptyPublisher(OPTIONS);\n+        shouldNotCalculateRequestContentLengthFromEmptyPublisher(TRACE);\n+    }\n+\n+    private static void shouldNotCalculateRequestContentLengthFromEmptyPublisher(HttpRequestMethod method)\n+            throws Exception {\n+        StreamingHttpRequest request = newAggregatedRequest(method).toStreamingRequest()\n                 .payloadBody(Publisher.empty());\n         setRequestContentLengthAndVerify(request, nullValue(CharSequence.class));\n     }\n \n+    @Test\n+    public void shouldCalculateRequestContentLengthFromEmptyPublisherForPostRequest() throws Exception {\n+        shouldCalculateRequestContentLengthFromEmptyPublisher(POST);\n+        shouldCalculateRequestContentLengthFromEmptyPublisher(PUT);\n+        shouldCalculateRequestContentLengthFromEmptyPublisher(PATCH);\n+    }\n+\n+    private static void shouldCalculateRequestContentLengthFromEmptyPublisher(HttpRequestMethod method)\n+            throws Exception {\n+        StreamingHttpRequest request = newAggregatedRequest(method).toStreamingRequest()\n+                .payloadBody(Publisher.empty());\n+        setRequestContentLengthAndVerify(request, is(\"0\"));\n+    }\n+\n     @Test\n     public void shouldCalculateRequestContentLengthFromSingleItemPublisher() throws Exception {\n         StreamingHttpRequest request = newAggregatedRequest().toStreamingRequest()\n@@ -82,6 +120,22 @@\n         setRequestContentLengthAndVerify(request, is(\"12\"));\n     }\n \n+    @Test\n+    public void shouldCalculateRequestContentLengthFromTransformedMultipleItemPublisher() throws Exception {\n+        StreamingHttpRequest request = newAggregatedRequest().payloadBody(\"Hello\", textSerializer())\n+                .toStreamingRequest().transformPayloadBody(payload -> payload.concat(Publisher.from(\" \", \"World\", \"!\")),\n+                        textDeserializer(), textSerializer());\n+        setRequestContentLengthAndVerify(request, is(\"12\"));\n+    }\n+\n+    @Test\n+    public void shouldCalculateRequestContentLengthFromTransformedRawMultipleItemPublisher() throws Exception {\n+        StreamingHttpRequest request = newAggregatedRequest().payloadBody(\"Hello\", textSerializer())\n+                .toStreamingRequest().transformRawPayloadBody(payload -> payload.map(obj -> (Buffer) obj)\n+                        .concat(Publisher.from(\" \", \"World\", \"!\").map(DEFAULT_RO_ALLOCATOR::fromAscii)));\n+        setRequestContentLengthAndVerify(request, is(\"12\"));\n+    }\n+\n     @Test\n     public void shouldCalculateResponseContentLengthFromEmptyPublisher() throws Exception {\n         StreamingHttpResponse response = newAggregatedResponse().toStreamingResponse()\n@@ -110,8 +164,28 @@\n         setResponseContentLengthAndVerify(response, is(\"12\"));\n     }\n \n+    @Test\n+    public void shouldCalculateResponseContentLengthFromTransformedMultipleItemPublisher() throws Exception {\n+        StreamingHttpResponse response = newAggregatedResponse().payloadBody(\"Hello\", textSerializer())\n+                .toStreamingResponse().transformPayloadBody(payload -> payload.concat(Publisher.from(\" \", \"World\", \"!\")),\n+                        textDeserializer(), textSerializer());\n+        setResponseContentLengthAndVerify(response, is(\"12\"));\n+    }\n+\n+    @Test\n+    public void shouldCalculateResponseContentLengthFromTransformedRawMultipleItemPublisher() throws Exception {\n+        StreamingHttpResponse response = newAggregatedResponse().payloadBody(\"Hello\", textSerializer())\n+                .toStreamingResponse().transformRawPayloadBody(payload -> payload.map(obj -> (Buffer) obj)\n+                        .concat(Publisher.from(\" \", \"World\", \"!\").map(DEFAULT_RO_ALLOCATOR::fromAscii)));\n+        setResponseContentLengthAndVerify(response, is(\"12\"));\n+    }\n+\n     private static HttpRequest newAggregatedRequest() {\n-        return awaitSingleIndefinitelyNonNull(StreamingHttpRequests.newRequest(GET, \"/\", HTTP_1_1,\n+        return newAggregatedRequest(GET);\n+    }\n+\n+    private static HttpRequest newAggregatedRequest(HttpRequestMethod method) {\n+        return awaitSingleIndefinitelyNonNull(StreamingHttpRequests.newRequest(method, \"/\", HTTP_1_1,\n                 headersFactory.newHeaders(), DEFAULT_ALLOCATOR, headersFactory).toRequest());\n     }\n \n@@ -124,17 +198,29 @@\n                                                          final Matcher<CharSequence> matcher) throws Exception {\n         Collection<Object> flattened = setRequestContentLength(request).toFuture().get();\n         assertThat(\"Unexpected items in the flattened request.\", flattened, hasSize(greaterThanOrEqualTo(2)));\n-        Object firstItem = flattened.iterator().next();\n+        Iterator<Object> iterator = flattened.iterator();\n+        Object firstItem = iterator.next();\n         assertThat(\"Unexpected items in the flattened request.\", firstItem, is(instanceOf(HttpMetaData.class)));\n         assertThat(((HttpMetaData) firstItem).headers().get(CONTENT_LENGTH), matcher);\n+        assertLastItem(iterator);\n     }\n \n     private static void setResponseContentLengthAndVerify(final StreamingHttpResponse response,\n                                                           final Matcher<CharSequence> matcher) throws Exception {\n         Collection<Object> flattened = setResponseContentLength(response).toFuture().get();\n         assertThat(\"Unexpected items in the flattened response.\", flattened, hasSize(greaterThanOrEqualTo(2)));\n-        Object firstItem = flattened.iterator().next();\n+        Iterator<Object> iterator = flattened.iterator();\n+        Object firstItem = iterator.next();\n         assertThat(\"Unexpected items in the flattened response.\", firstItem, is(instanceOf(HttpMetaData.class)));\n         assertThat(((HttpMetaData) firstItem).headers().get(CONTENT_LENGTH), matcher);\n+        assertLastItem(iterator);\n+    }\n+\n+    private static void assertLastItem(Iterator<Object> iterator) {\n+        Object item = null;\n+        while (iterator.hasNext()) {\n+            item = iterator.next();\n+        }\n+        assertThat(\"Unexpected last item in the flattened stream.\", item, is(instanceOf(HttpHeaders.class)));\n     }\n }\n\nFeel free to add more test cases there if I missed something.", "bodyHTML": "<p dir=\"auto\">Instead of adding a new test class, consider enhancing the existing one:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"Index: servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/ContentLengthTest.java\nIDEA additional info:\nSubsystem: com.intellij.openapi.diff.impl.patch.CharsetEP\n&lt;+&gt;UTF-8\n===================================================================\n--- servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/ContentLengthTest.java\t(revision a2c12893734841eea9c18d033884cccf944f7624)\n+++ servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/ContentLengthTest.java\t(date 1605648191399)\n@@ -1,5 +1,5 @@\n /*\n- * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ * Copyright \u00a9 2019-2020 Apple Inc. and the ServiceTalk project authors\n  *\n  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\n  * you may not use this file except in compliance with the License.\n@@ -15,10 +15,13 @@\n  */\n package io.servicetalk.http.netty;\n \n+import io.servicetalk.buffer.api.Buffer;\n import io.servicetalk.concurrent.api.Publisher;\n import io.servicetalk.http.api.DefaultHttpHeadersFactory;\n+import io.servicetalk.http.api.HttpHeaders;\n import io.servicetalk.http.api.HttpMetaData;\n import io.servicetalk.http.api.HttpRequest;\n+import io.servicetalk.http.api.HttpRequestMethod;\n import io.servicetalk.http.api.HttpResponse;\n import io.servicetalk.http.api.StreamingHttpRequest;\n import io.servicetalk.http.api.StreamingHttpRequests;\n@@ -28,23 +31,34 @@\n import org.junit.Test;\n \n import java.util.Collection;\n+import java.util.Iterator;\n \n+import static io.servicetalk.buffer.api.ReadOnlyBufferAllocators.DEFAULT_RO_ALLOCATOR;\n import static io.servicetalk.buffer.netty.BufferAllocators.DEFAULT_ALLOCATOR;\n import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_LENGTH;\n import static io.servicetalk.http.api.HttpProtocolVersion.HTTP_1_1;\n+import static io.servicetalk.http.api.HttpRequestMethod.CONNECT;\n+import static io.servicetalk.http.api.HttpRequestMethod.DELETE;\n import static io.servicetalk.http.api.HttpRequestMethod.GET;\n+import static io.servicetalk.http.api.HttpRequestMethod.HEAD;\n+import static io.servicetalk.http.api.HttpRequestMethod.OPTIONS;\n+import static io.servicetalk.http.api.HttpRequestMethod.PATCH;\n+import static io.servicetalk.http.api.HttpRequestMethod.POST;\n+import static io.servicetalk.http.api.HttpRequestMethod.PUT;\n+import static io.servicetalk.http.api.HttpRequestMethod.TRACE;\n import static io.servicetalk.http.api.HttpResponseStatus.OK;\n+import static io.servicetalk.http.api.HttpSerializationProviders.textDeserializer;\n import static io.servicetalk.http.api.HttpSerializationProviders.textSerializer;\n import static io.servicetalk.http.api.StreamingHttpResponses.newResponse;\n import static io.servicetalk.http.netty.AbstractNettyHttpServerTest.ExecutorSupplier.CACHED;\n import static io.servicetalk.http.netty.HeaderUtils.setRequestContentLength;\n import static io.servicetalk.http.netty.HeaderUtils.setResponseContentLength;\n+import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n import static org.hamcrest.Matchers.hasSize;\n import static org.hamcrest.Matchers.instanceOf;\n import static org.hamcrest.Matchers.is;\n import static org.hamcrest.Matchers.nullValue;\n-import static org.junit.Assert.assertThat;\n \n public class ContentLengthTest extends AbstractNettyHttpServerTest {\n \n@@ -55,12 +69,36 @@\n     }\n \n     @Test\n-    public void shouldCalculateRequestContentLengthFromEmptyPublisher() throws Exception {\n-        StreamingHttpRequest request = newAggregatedRequest().toStreamingRequest()\n+    public void shouldNotCalculateRequestContentLengthFromEmptyPublisherForGetRequest() throws Exception {\n+        shouldNotCalculateRequestContentLengthFromEmptyPublisher(GET);\n+        shouldNotCalculateRequestContentLengthFromEmptyPublisher(HEAD);\n+        shouldNotCalculateRequestContentLengthFromEmptyPublisher(DELETE);\n+        shouldNotCalculateRequestContentLengthFromEmptyPublisher(CONNECT);\n+        shouldNotCalculateRequestContentLengthFromEmptyPublisher(OPTIONS);\n+        shouldNotCalculateRequestContentLengthFromEmptyPublisher(TRACE);\n+    }\n+\n+    private static void shouldNotCalculateRequestContentLengthFromEmptyPublisher(HttpRequestMethod method)\n+            throws Exception {\n+        StreamingHttpRequest request = newAggregatedRequest(method).toStreamingRequest()\n                 .payloadBody(Publisher.empty());\n         setRequestContentLengthAndVerify(request, nullValue(CharSequence.class));\n     }\n \n+    @Test\n+    public void shouldCalculateRequestContentLengthFromEmptyPublisherForPostRequest() throws Exception {\n+        shouldCalculateRequestContentLengthFromEmptyPublisher(POST);\n+        shouldCalculateRequestContentLengthFromEmptyPublisher(PUT);\n+        shouldCalculateRequestContentLengthFromEmptyPublisher(PATCH);\n+    }\n+\n+    private static void shouldCalculateRequestContentLengthFromEmptyPublisher(HttpRequestMethod method)\n+            throws Exception {\n+        StreamingHttpRequest request = newAggregatedRequest(method).toStreamingRequest()\n+                .payloadBody(Publisher.empty());\n+        setRequestContentLengthAndVerify(request, is(&quot;0&quot;));\n+    }\n+\n     @Test\n     public void shouldCalculateRequestContentLengthFromSingleItemPublisher() throws Exception {\n         StreamingHttpRequest request = newAggregatedRequest().toStreamingRequest()\n@@ -82,6 +120,22 @@\n         setRequestContentLengthAndVerify(request, is(&quot;12&quot;));\n     }\n \n+    @Test\n+    public void shouldCalculateRequestContentLengthFromTransformedMultipleItemPublisher() throws Exception {\n+        StreamingHttpRequest request = newAggregatedRequest().payloadBody(&quot;Hello&quot;, textSerializer())\n+                .toStreamingRequest().transformPayloadBody(payload -&gt; payload.concat(Publisher.from(&quot; &quot;, &quot;World&quot;, &quot;!&quot;)),\n+                        textDeserializer(), textSerializer());\n+        setRequestContentLengthAndVerify(request, is(&quot;12&quot;));\n+    }\n+\n+    @Test\n+    public void shouldCalculateRequestContentLengthFromTransformedRawMultipleItemPublisher() throws Exception {\n+        StreamingHttpRequest request = newAggregatedRequest().payloadBody(&quot;Hello&quot;, textSerializer())\n+                .toStreamingRequest().transformRawPayloadBody(payload -&gt; payload.map(obj -&gt; (Buffer) obj)\n+                        .concat(Publisher.from(&quot; &quot;, &quot;World&quot;, &quot;!&quot;).map(DEFAULT_RO_ALLOCATOR::fromAscii)));\n+        setRequestContentLengthAndVerify(request, is(&quot;12&quot;));\n+    }\n+\n     @Test\n     public void shouldCalculateResponseContentLengthFromEmptyPublisher() throws Exception {\n         StreamingHttpResponse response = newAggregatedResponse().toStreamingResponse()\n@@ -110,8 +164,28 @@\n         setResponseContentLengthAndVerify(response, is(&quot;12&quot;));\n     }\n \n+    @Test\n+    public void shouldCalculateResponseContentLengthFromTransformedMultipleItemPublisher() throws Exception {\n+        StreamingHttpResponse response = newAggregatedResponse().payloadBody(&quot;Hello&quot;, textSerializer())\n+                .toStreamingResponse().transformPayloadBody(payload -&gt; payload.concat(Publisher.from(&quot; &quot;, &quot;World&quot;, &quot;!&quot;)),\n+                        textDeserializer(), textSerializer());\n+        setResponseContentLengthAndVerify(response, is(&quot;12&quot;));\n+    }\n+\n+    @Test\n+    public void shouldCalculateResponseContentLengthFromTransformedRawMultipleItemPublisher() throws Exception {\n+        StreamingHttpResponse response = newAggregatedResponse().payloadBody(&quot;Hello&quot;, textSerializer())\n+                .toStreamingResponse().transformRawPayloadBody(payload -&gt; payload.map(obj -&gt; (Buffer) obj)\n+                        .concat(Publisher.from(&quot; &quot;, &quot;World&quot;, &quot;!&quot;).map(DEFAULT_RO_ALLOCATOR::fromAscii)));\n+        setResponseContentLengthAndVerify(response, is(&quot;12&quot;));\n+    }\n+\n     private static HttpRequest newAggregatedRequest() {\n-        return awaitSingleIndefinitelyNonNull(StreamingHttpRequests.newRequest(GET, &quot;/&quot;, HTTP_1_1,\n+        return newAggregatedRequest(GET);\n+    }\n+\n+    private static HttpRequest newAggregatedRequest(HttpRequestMethod method) {\n+        return awaitSingleIndefinitelyNonNull(StreamingHttpRequests.newRequest(method, &quot;/&quot;, HTTP_1_1,\n                 headersFactory.newHeaders(), DEFAULT_ALLOCATOR, headersFactory).toRequest());\n     }\n \n@@ -124,17 +198,29 @@\n                                                          final Matcher&lt;CharSequence&gt; matcher) throws Exception {\n         Collection&lt;Object&gt; flattened = setRequestContentLength(request).toFuture().get();\n         assertThat(&quot;Unexpected items in the flattened request.&quot;, flattened, hasSize(greaterThanOrEqualTo(2)));\n-        Object firstItem = flattened.iterator().next();\n+        Iterator&lt;Object&gt; iterator = flattened.iterator();\n+        Object firstItem = iterator.next();\n         assertThat(&quot;Unexpected items in the flattened request.&quot;, firstItem, is(instanceOf(HttpMetaData.class)));\n         assertThat(((HttpMetaData) firstItem).headers().get(CONTENT_LENGTH), matcher);\n+        assertLastItem(iterator);\n     }\n \n     private static void setResponseContentLengthAndVerify(final StreamingHttpResponse response,\n                                                           final Matcher&lt;CharSequence&gt; matcher) throws Exception {\n         Collection&lt;Object&gt; flattened = setResponseContentLength(response).toFuture().get();\n         assertThat(&quot;Unexpected items in the flattened response.&quot;, flattened, hasSize(greaterThanOrEqualTo(2)));\n-        Object firstItem = flattened.iterator().next();\n+        Iterator&lt;Object&gt; iterator = flattened.iterator();\n+        Object firstItem = iterator.next();\n         assertThat(&quot;Unexpected items in the flattened response.&quot;, firstItem, is(instanceOf(HttpMetaData.class)));\n         assertThat(((HttpMetaData) firstItem).headers().get(CONTENT_LENGTH), matcher);\n+        assertLastItem(iterator);\n+    }\n+\n+    private static void assertLastItem(Iterator&lt;Object&gt; iterator) {\n+        Object item = null;\n+        while (iterator.hasNext()) {\n+            item = iterator.next();\n+        }\n+        assertThat(&quot;Unexpected last item in the flattened stream.&quot;, item, is(instanceOf(HttpHeaders.class)));\n     }\n }\n\"><pre><code>Index: servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/ContentLengthTest.java\nIDEA additional info:\nSubsystem: com.intellij.openapi.diff.impl.patch.CharsetEP\n&lt;+&gt;UTF-8\n===================================================================\n--- servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/ContentLengthTest.java\t(revision a2c12893734841eea9c18d033884cccf944f7624)\n+++ servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/ContentLengthTest.java\t(date 1605648191399)\n@@ -1,5 +1,5 @@\n /*\n- * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ * Copyright \u00a9 2019-2020 Apple Inc. and the ServiceTalk project authors\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -15,10 +15,13 @@\n  */\n package io.servicetalk.http.netty;\n \n+import io.servicetalk.buffer.api.Buffer;\n import io.servicetalk.concurrent.api.Publisher;\n import io.servicetalk.http.api.DefaultHttpHeadersFactory;\n+import io.servicetalk.http.api.HttpHeaders;\n import io.servicetalk.http.api.HttpMetaData;\n import io.servicetalk.http.api.HttpRequest;\n+import io.servicetalk.http.api.HttpRequestMethod;\n import io.servicetalk.http.api.HttpResponse;\n import io.servicetalk.http.api.StreamingHttpRequest;\n import io.servicetalk.http.api.StreamingHttpRequests;\n@@ -28,23 +31,34 @@\n import org.junit.Test;\n \n import java.util.Collection;\n+import java.util.Iterator;\n \n+import static io.servicetalk.buffer.api.ReadOnlyBufferAllocators.DEFAULT_RO_ALLOCATOR;\n import static io.servicetalk.buffer.netty.BufferAllocators.DEFAULT_ALLOCATOR;\n import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_LENGTH;\n import static io.servicetalk.http.api.HttpProtocolVersion.HTTP_1_1;\n+import static io.servicetalk.http.api.HttpRequestMethod.CONNECT;\n+import static io.servicetalk.http.api.HttpRequestMethod.DELETE;\n import static io.servicetalk.http.api.HttpRequestMethod.GET;\n+import static io.servicetalk.http.api.HttpRequestMethod.HEAD;\n+import static io.servicetalk.http.api.HttpRequestMethod.OPTIONS;\n+import static io.servicetalk.http.api.HttpRequestMethod.PATCH;\n+import static io.servicetalk.http.api.HttpRequestMethod.POST;\n+import static io.servicetalk.http.api.HttpRequestMethod.PUT;\n+import static io.servicetalk.http.api.HttpRequestMethod.TRACE;\n import static io.servicetalk.http.api.HttpResponseStatus.OK;\n+import static io.servicetalk.http.api.HttpSerializationProviders.textDeserializer;\n import static io.servicetalk.http.api.HttpSerializationProviders.textSerializer;\n import static io.servicetalk.http.api.StreamingHttpResponses.newResponse;\n import static io.servicetalk.http.netty.AbstractNettyHttpServerTest.ExecutorSupplier.CACHED;\n import static io.servicetalk.http.netty.HeaderUtils.setRequestContentLength;\n import static io.servicetalk.http.netty.HeaderUtils.setResponseContentLength;\n+import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n import static org.hamcrest.Matchers.hasSize;\n import static org.hamcrest.Matchers.instanceOf;\n import static org.hamcrest.Matchers.is;\n import static org.hamcrest.Matchers.nullValue;\n-import static org.junit.Assert.assertThat;\n \n public class ContentLengthTest extends AbstractNettyHttpServerTest {\n \n@@ -55,12 +69,36 @@\n     }\n \n     @Test\n-    public void shouldCalculateRequestContentLengthFromEmptyPublisher() throws Exception {\n-        StreamingHttpRequest request = newAggregatedRequest().toStreamingRequest()\n+    public void shouldNotCalculateRequestContentLengthFromEmptyPublisherForGetRequest() throws Exception {\n+        shouldNotCalculateRequestContentLengthFromEmptyPublisher(GET);\n+        shouldNotCalculateRequestContentLengthFromEmptyPublisher(HEAD);\n+        shouldNotCalculateRequestContentLengthFromEmptyPublisher(DELETE);\n+        shouldNotCalculateRequestContentLengthFromEmptyPublisher(CONNECT);\n+        shouldNotCalculateRequestContentLengthFromEmptyPublisher(OPTIONS);\n+        shouldNotCalculateRequestContentLengthFromEmptyPublisher(TRACE);\n+    }\n+\n+    private static void shouldNotCalculateRequestContentLengthFromEmptyPublisher(HttpRequestMethod method)\n+            throws Exception {\n+        StreamingHttpRequest request = newAggregatedRequest(method).toStreamingRequest()\n                 .payloadBody(Publisher.empty());\n         setRequestContentLengthAndVerify(request, nullValue(CharSequence.class));\n     }\n \n+    @Test\n+    public void shouldCalculateRequestContentLengthFromEmptyPublisherForPostRequest() throws Exception {\n+        shouldCalculateRequestContentLengthFromEmptyPublisher(POST);\n+        shouldCalculateRequestContentLengthFromEmptyPublisher(PUT);\n+        shouldCalculateRequestContentLengthFromEmptyPublisher(PATCH);\n+    }\n+\n+    private static void shouldCalculateRequestContentLengthFromEmptyPublisher(HttpRequestMethod method)\n+            throws Exception {\n+        StreamingHttpRequest request = newAggregatedRequest(method).toStreamingRequest()\n+                .payloadBody(Publisher.empty());\n+        setRequestContentLengthAndVerify(request, is(\"0\"));\n+    }\n+\n     @Test\n     public void shouldCalculateRequestContentLengthFromSingleItemPublisher() throws Exception {\n         StreamingHttpRequest request = newAggregatedRequest().toStreamingRequest()\n@@ -82,6 +120,22 @@\n         setRequestContentLengthAndVerify(request, is(\"12\"));\n     }\n \n+    @Test\n+    public void shouldCalculateRequestContentLengthFromTransformedMultipleItemPublisher() throws Exception {\n+        StreamingHttpRequest request = newAggregatedRequest().payloadBody(\"Hello\", textSerializer())\n+                .toStreamingRequest().transformPayloadBody(payload -&gt; payload.concat(Publisher.from(\" \", \"World\", \"!\")),\n+                        textDeserializer(), textSerializer());\n+        setRequestContentLengthAndVerify(request, is(\"12\"));\n+    }\n+\n+    @Test\n+    public void shouldCalculateRequestContentLengthFromTransformedRawMultipleItemPublisher() throws Exception {\n+        StreamingHttpRequest request = newAggregatedRequest().payloadBody(\"Hello\", textSerializer())\n+                .toStreamingRequest().transformRawPayloadBody(payload -&gt; payload.map(obj -&gt; (Buffer) obj)\n+                        .concat(Publisher.from(\" \", \"World\", \"!\").map(DEFAULT_RO_ALLOCATOR::fromAscii)));\n+        setRequestContentLengthAndVerify(request, is(\"12\"));\n+    }\n+\n     @Test\n     public void shouldCalculateResponseContentLengthFromEmptyPublisher() throws Exception {\n         StreamingHttpResponse response = newAggregatedResponse().toStreamingResponse()\n@@ -110,8 +164,28 @@\n         setResponseContentLengthAndVerify(response, is(\"12\"));\n     }\n \n+    @Test\n+    public void shouldCalculateResponseContentLengthFromTransformedMultipleItemPublisher() throws Exception {\n+        StreamingHttpResponse response = newAggregatedResponse().payloadBody(\"Hello\", textSerializer())\n+                .toStreamingResponse().transformPayloadBody(payload -&gt; payload.concat(Publisher.from(\" \", \"World\", \"!\")),\n+                        textDeserializer(), textSerializer());\n+        setResponseContentLengthAndVerify(response, is(\"12\"));\n+    }\n+\n+    @Test\n+    public void shouldCalculateResponseContentLengthFromTransformedRawMultipleItemPublisher() throws Exception {\n+        StreamingHttpResponse response = newAggregatedResponse().payloadBody(\"Hello\", textSerializer())\n+                .toStreamingResponse().transformRawPayloadBody(payload -&gt; payload.map(obj -&gt; (Buffer) obj)\n+                        .concat(Publisher.from(\" \", \"World\", \"!\").map(DEFAULT_RO_ALLOCATOR::fromAscii)));\n+        setResponseContentLengthAndVerify(response, is(\"12\"));\n+    }\n+\n     private static HttpRequest newAggregatedRequest() {\n-        return awaitSingleIndefinitelyNonNull(StreamingHttpRequests.newRequest(GET, \"/\", HTTP_1_1,\n+        return newAggregatedRequest(GET);\n+    }\n+\n+    private static HttpRequest newAggregatedRequest(HttpRequestMethod method) {\n+        return awaitSingleIndefinitelyNonNull(StreamingHttpRequests.newRequest(method, \"/\", HTTP_1_1,\n                 headersFactory.newHeaders(), DEFAULT_ALLOCATOR, headersFactory).toRequest());\n     }\n \n@@ -124,17 +198,29 @@\n                                                          final Matcher&lt;CharSequence&gt; matcher) throws Exception {\n         Collection&lt;Object&gt; flattened = setRequestContentLength(request).toFuture().get();\n         assertThat(\"Unexpected items in the flattened request.\", flattened, hasSize(greaterThanOrEqualTo(2)));\n-        Object firstItem = flattened.iterator().next();\n+        Iterator&lt;Object&gt; iterator = flattened.iterator();\n+        Object firstItem = iterator.next();\n         assertThat(\"Unexpected items in the flattened request.\", firstItem, is(instanceOf(HttpMetaData.class)));\n         assertThat(((HttpMetaData) firstItem).headers().get(CONTENT_LENGTH), matcher);\n+        assertLastItem(iterator);\n     }\n \n     private static void setResponseContentLengthAndVerify(final StreamingHttpResponse response,\n                                                           final Matcher&lt;CharSequence&gt; matcher) throws Exception {\n         Collection&lt;Object&gt; flattened = setResponseContentLength(response).toFuture().get();\n         assertThat(\"Unexpected items in the flattened response.\", flattened, hasSize(greaterThanOrEqualTo(2)));\n-        Object firstItem = flattened.iterator().next();\n+        Iterator&lt;Object&gt; iterator = flattened.iterator();\n+        Object firstItem = iterator.next();\n         assertThat(\"Unexpected items in the flattened response.\", firstItem, is(instanceOf(HttpMetaData.class)));\n         assertThat(((HttpMetaData) firstItem).headers().get(CONTENT_LENGTH), matcher);\n+        assertLastItem(iterator);\n+    }\n+\n+    private static void assertLastItem(Iterator&lt;Object&gt; iterator) {\n+        Object item = null;\n+        while (iterator.hasNext()) {\n+            item = iterator.next();\n+        }\n+        assertThat(\"Unexpected last item in the flattened stream.\", item, is(instanceOf(HttpHeaders.class)));\n     }\n }\n</code></pre></div>\n<p dir=\"auto\">Feel free to add more test cases there if I missed something.</p>", "author": "idelpivnitskiy", "createdAt": "2020-11-17T21:24:57Z", "path": "servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/AggregatedRequestsFilterTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.http.api.DefaultHttpHeadersFactory;\n+import io.servicetalk.http.api.FilterableStreamingHttpClient;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.HttpExecutionStrategy;\n+import io.servicetalk.http.api.HttpHeadersFactory;\n+import io.servicetalk.http.api.HttpRequest;\n+import io.servicetalk.http.api.StreamingHttpClient;\n+import io.servicetalk.http.api.StreamingHttpClientFilter;\n+import io.servicetalk.http.api.StreamingHttpClientFilterFactory;\n+import io.servicetalk.http.api.StreamingHttpRequest;\n+import io.servicetalk.http.api.StreamingHttpRequester;\n+import io.servicetalk.http.api.StreamingHttpResponse;\n+import io.servicetalk.transport.api.ServerContext;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static io.servicetalk.buffer.api.EmptyBuffer.EMPTY_BUFFER;\n+import static io.servicetalk.concurrent.api.Publisher.from;\n+import static io.servicetalk.concurrent.api.Single.failed;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static io.servicetalk.http.api.HttpHeaderNames.TRANSFER_ENCODING;\n+import static io.servicetalk.http.api.HttpHeaderValues.CHUNKED;\n+import static io.servicetalk.http.api.HttpProtocolVersion.HTTP_1_1;\n+import static io.servicetalk.http.api.HttpRequestMethod.GET;\n+import static io.servicetalk.http.api.HttpResponseStatus.OK;\n+import static io.servicetalk.http.api.HttpSerializationProviders.textSerializer;\n+import static io.servicetalk.http.api.StreamingHttpRequests.newTransportRequest;\n+import static io.servicetalk.http.netty.HttpServers.forPort;\n+import static java.util.Objects.requireNonNull;\n+import static org.junit.Assert.assertEquals;\n+\n+public class AggregatedRequestsFilterTest {", "originalCommit": "a2c12893734841eea9c18d033884cccf944f7624", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMjkzNg==", "url": "https://github.com/apple/servicetalk/pull/1213#discussion_r530032936", "bodyText": "thx \ud83d\ude80", "author": "tkountis", "createdAt": "2020-11-25T00:35:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzNDIyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzNjM1Mw==", "url": "https://github.com/apple/servicetalk/pull/1213#discussion_r525536353", "body": "Discussed offline: `transformRawPayloadBody` should not add trailers. For trailers, `transform/transformRaw` methods should be used. Also, users are responsible for consuming the original publisher when they apply transformations.", "bodyText": "Discussed offline: transformRawPayloadBody should not add trailers. For trailers, transform/transformRaw methods should be used. Also, users are responsible for consuming the original publisher when they apply transformations.", "bodyHTML": "<p dir=\"auto\">Discussed offline: <code>transformRawPayloadBody</code> should not add trailers. For trailers, <code>transform/transformRaw</code> methods should be used. Also, users are responsible for consuming the original publisher when they apply transformations.</p>", "author": "idelpivnitskiy", "createdAt": "2020-11-17T21:28:56Z", "path": "servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/AggregatedRequestsFilterTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.http.api.DefaultHttpHeadersFactory;\n+import io.servicetalk.http.api.FilterableStreamingHttpClient;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.HttpExecutionStrategy;\n+import io.servicetalk.http.api.HttpHeadersFactory;\n+import io.servicetalk.http.api.HttpRequest;\n+import io.servicetalk.http.api.StreamingHttpClient;\n+import io.servicetalk.http.api.StreamingHttpClientFilter;\n+import io.servicetalk.http.api.StreamingHttpClientFilterFactory;\n+import io.servicetalk.http.api.StreamingHttpRequest;\n+import io.servicetalk.http.api.StreamingHttpRequester;\n+import io.servicetalk.http.api.StreamingHttpResponse;\n+import io.servicetalk.transport.api.ServerContext;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static io.servicetalk.buffer.api.EmptyBuffer.EMPTY_BUFFER;\n+import static io.servicetalk.concurrent.api.Publisher.from;\n+import static io.servicetalk.concurrent.api.Single.failed;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static io.servicetalk.http.api.HttpHeaderNames.TRANSFER_ENCODING;\n+import static io.servicetalk.http.api.HttpHeaderValues.CHUNKED;\n+import static io.servicetalk.http.api.HttpProtocolVersion.HTTP_1_1;\n+import static io.servicetalk.http.api.HttpRequestMethod.GET;\n+import static io.servicetalk.http.api.HttpResponseStatus.OK;\n+import static io.servicetalk.http.api.HttpSerializationProviders.textSerializer;\n+import static io.servicetalk.http.api.StreamingHttpRequests.newTransportRequest;\n+import static io.servicetalk.http.netty.HttpServers.forPort;\n+import static java.util.Objects.requireNonNull;\n+import static org.junit.Assert.assertEquals;\n+\n+public class AggregatedRequestsFilterTest {\n+\n+    private static final StreamingHttpClientFilterFactory BODY_TRANSFORMER_FILTER =\n+            new StreamingHttpClientFilterFactory() {\n+        @Override\n+        public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n+            return new StreamingHttpClientFilter(client) {\n+                @Override\n+                protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n+                                                                final HttpExecutionStrategy strategy,\n+                                                                final StreamingHttpRequest request) {\n+                    BufferAllocator allocator = delegate.executionContext().bufferAllocator();\n+                    request.transformPayloadBody(b -> b.concat(succeeded(allocator.fromAscii(\"red-pill\"))));\n+                    return super.request(delegate, strategy, request);\n+                }\n+            };\n+        }\n+    };\n+\n+    private static final StreamingHttpClientFilterFactory RAW_TRANSFORMER_FILTER =\n+            new StreamingHttpClientFilterFactory() {\n+                @Override\n+                public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n+                    return new StreamingHttpClientFilter(client) {\n+                        @Override\n+                        protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n+                                                                        final HttpExecutionStrategy strategy,\n+                                                                        final StreamingHttpRequest request) {\n+                            BufferAllocator allocator = delegate.executionContext().bufferAllocator();\n+                            HttpHeadersFactory headersFactory = new DefaultHttpHeadersFactory(false, false);\n+\n+                            request.transformRawPayloadBody(b -> from(allocator.fromAscii(\"red-pill\"),\n+                                    headersFactory.newTrailers().add(\"fooA\", \"barA\")));", "originalCommit": "a2c12893734841eea9c18d033884cccf944f7624", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2b3a1eb2bcd276fc3e64a3860fc4f2ace93499d8", "url": "https://github.com/apple/servicetalk/commit/2b3a1eb2bcd276fc3e64a3860fc4f2ace93499d8", "message": "Fix transformed aggregated requests with missing trailers", "committedDate": "2020-11-25T00:20:27Z", "type": "commit"}, {"oid": "3460b0a3ea9782e6a3ed0963d840cd10f27c901a", "url": "https://github.com/apple/servicetalk/commit/3460b0a3ea9782e6a3ed0963d840cd10f27c901a", "message": "Fix comments", "committedDate": "2020-11-25T00:33:22Z", "type": "commit"}, {"oid": "3460b0a3ea9782e6a3ed0963d840cd10f27c901a", "url": "https://github.com/apple/servicetalk/commit/3460b0a3ea9782e6a3ed0963d840cd10f27c901a", "message": "Fix comments", "committedDate": "2020-11-25T00:33:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkwMTMzMA==", "url": "https://github.com/apple/servicetalk/pull/1213#discussion_r532901330", "body": "Consider upgrading the copyright year for this file to 2018-2020", "bodyText": "Consider upgrading the copyright year for this file to 2018-2020", "bodyHTML": "<p dir=\"auto\">Consider upgrading the copyright year for this file to 2018-2020</p>", "author": "idelpivnitskiy", "createdAt": "2020-11-30T21:02:23Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HeaderUtils.java", "diffHunk": "@@ -34,6 +34,7 @@\n \n import static io.servicetalk.concurrent.api.Publisher.from;\n import static io.servicetalk.concurrent.api.Publisher.fromIterable;\n+import static io.servicetalk.concurrent.api.Single.succeeded;", "originalCommit": "3460b0a3ea9782e6a3ed0963d840cd10f27c901a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "50471f208355ada215414c63809ba8e700ea6868", "url": "https://github.com/apple/servicetalk/commit/50471f208355ada215414c63809ba8e700ea6868", "message": "Fix checkstyle", "committedDate": "2020-12-03T18:59:19Z", "type": "commit"}]}