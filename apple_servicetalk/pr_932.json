{"pr_number": 932, "pr_title": "gRPC filters override configured execution strategy for the route", "pr_author": "idelpivnitskiy", "pr_createdAt": "2020-02-04T22:16:49Z", "pr_url": "https://github.com/apple/servicetalk/pull/932", "timeline": [{"oid": "339a2b7b8d335c0e0d39556a4ebe22cee7e0fee9", "url": "https://github.com/apple/servicetalk/commit/339a2b7b8d335c0e0d39556a4ebe22cee7e0fee9", "message": "gRPC filters override configured execution strategy for the route\n\nMotivation:\n\nWhen users append a service filter using `ServiceFactory`, it\nreconstructs the `GrpcService` interface from registered routes,\nwraps it with the filter, and re-registers the service again as\nan independent routes. This logic does not preserve the execution\nstrategy that was used to register the original route and it\nuses the default strategy for a route.\n\nModifications:\n\n- Save the route execution strategy if it was configured for the\noriginal route;\n- Use saved execution strategy when we re-register filtered routes;\n- Add tests to verify the execution strategy configuration when\nusers apply a filter;\n- Close `GrpcPayloadWriter` in the conversion layer from\n`BlockingStreamingRoute` to `StreamingRoute`, because users of\n`BlockingRequestStreamingRoute` does not have access to it;\n\nResult:\n\ngRPC filters does not override configured execution strategy for\nthe route.", "committedDate": "2020-02-04T02:36:34Z", "type": "commit"}, {"oid": "429aebc7d787241a20b08683ba29e7fab2578fcd", "url": "https://github.com/apple/servicetalk/commit/429aebc7d787241a20b08683ba29e7fab2578fcd", "message": "Verify `RouteExecutionStrategy` annotation is ignored on the service filter", "committedDate": "2020-02-04T02:36:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1Nzc0NA==", "url": "https://github.com/apple/servicetalk/pull/932#discussion_r374957744", "body": "@NiteshKant should we account for users that may try-catch routes registration? If they register the same path 2+ times with different route implementations, we will override the strategy here, but later we throw an exception saying that this path was already registered. If users try-catch this exception, internal state will be modified. I can move this `executionStrategies.put` after we register a route if necessary.", "bodyText": "@NiteshKant should we account for users that may try-catch routes registration? If they register the same path 2+ times with different route implementations, we will override the strategy here, but later we throw an exception saying that this path was already registered. If users try-catch this exception, internal state will be modified. I can move this executionStrategies.put after we register a route if necessary.", "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/NiteshKant/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/NiteshKant\">@NiteshKant</a> should we account for users that may try-catch routes registration? If they register the same path 2+ times with different route implementations, we will override the strategy here, but later we throw an exception saying that this path was already registered. If users try-catch this exception, internal state will be modified. I can move this <code>executionStrategies.put</code> after we register a route if necessary.</p>", "author": "idelpivnitskiy", "createdAt": "2020-02-04T22:24:39Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRoutes.java", "diffHunk": "@@ -173,9 +187,18 @@ protected GrpcService newServiceFromRoutes(final AllGrpcRoutes routes) {\n     }\n \n     @Nullable\n-    private GrpcExecutionStrategy executionStrategy(final Method method, final Class<?> clazz) {\n-        return getAndValidateRouteExecutionStrategyAnnotationIfPresent(method, clazz, strategyFactory, errors,\n-                noOffloadsStrategy());\n+    private GrpcExecutionStrategy executionStrategy(final String path, final Method method, final Class<?> clazz) {\n+        // Check if we already have a computed GrpcExecutionStrategy for this path. This may happen when we re-register\n+        // filtered routes:\n+        final GrpcExecutionStrategy saved = executionStrategies.getOrDefault(path, NULL);\n+        if (saved != NULL) {\n+            return saved;\n+        }\n+        final GrpcExecutionStrategy computed = getAndValidateRouteExecutionStrategyAnnotationIfPresent(method, clazz,\n+                strategyFactory, errors, noOffloadsStrategy());\n+        // Save computed value even if it's null to prevent analysing annotations on a service filter class\n+        executionStrategies.put(path, computed);", "originalCommit": "429aebc7d787241a20b08683ba29e7fab2578fcd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQyNDUwOA==", "url": "https://github.com/apple/servicetalk/pull/932#discussion_r375424508", "bodyText": "but later we throw an exception saying that this path was already registered.\n\n\nDid you mean that we will ignore the strategy for a subsequent registration? We are not using executionStrategies to check for duplicate registration, are we?\nI think we should account for cases when a registration exception is caught and retried unless we have a strong reason to believe that is invalid. AFAIR, this is required only for disallowing filters to specify the strategy annotation, rite? I have not thought of that case as to whether it is good or bad, so if we need special code to disallow it, lets refrain from doing that for now and have \"behavior when strategy annotation is defined on filters is undefined\" as our answer.", "author": "NiteshKant", "createdAt": "2020-02-05T18:16:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1Nzc0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYxNTUxOQ==", "url": "https://github.com/apple/servicetalk/pull/932#discussion_r375615519", "bodyText": "I was thinking about a use-case like this:\nServiceFactory.Builder builder = new ServiceFactory.Builder();\nbuilder.testBlocking(noOffloadsStrategy(), serviceImpl);\ntry {\n    builder.testBlocking(anotherStrategy, anotherServiceImpl);\n} catch (IllegalStateException e) {\n    // ignore that this route was already registered\n}\nDon't think we need to verify duplication for the executionStrategies map, because we already do that for routes. An additional check will be useless.\nIn my first impl I stored execution strategy before I verified routes duplication. That's why in the example above users will be in the state when they have serviceImpl with anotherStrategy.\nNow I moved executionStrategies.put(...) after we verify routes duplication. So, nothing will corrupt the internal state.\n\nAFAIR, this is required only for disallowing filters to specify the strategy annotation, rite? I have not thought of that case as to whether it is good or bad.\n\nRight. As we discussed before, ST policy is that if you configure an execution strategy for the route, ST will use it regardless of filters/influencers/etc.\nThe case here is that grpc filter implements the same service interface. Therefore, users can accidentally add @RouteExecutionStrategy annotation on the filter. I think we should ignore it.\n\nso if we need special code to disallow it, lets refrain from doing that for now and have \"behavior when strategy annotation is defined on filters is undefined\" as our answer.\n\nThe code to disallow annotation inspection for filters is trivial. It's just getOrDefault vs get on the map to distinguish key-null entry vs entry for this key does not exist.\nDefined behavior is always better than undefined. I've added this test to demonstrate the problem: https://github.com/apple/servicetalk/pull/932/files#diff-4fbfd0eed0161987f94f03bc6d9e3203R262-R279", "author": "idelpivnitskiy", "createdAt": "2020-02-06T02:42:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1Nzc0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQxMDMxNQ==", "url": "https://github.com/apple/servicetalk/pull/932#discussion_r375410315", "body": "If `onError()` throws from the above `catch` block and then `grpcPayloadWriter.close()` also throws, `concurrentTerminalSubscriber` will ignore this call. You can instead use `concurrentTerminalSubscriber.processOnError()` which returns `false` if it did not deliver the error, in which case we should log.", "bodyText": "If onError() throws from the above catch block and then grpcPayloadWriter.close() also throws, concurrentTerminalSubscriber will ignore this call. You can instead use concurrentTerminalSubscriber.processOnError() which returns false if it did not deliver the error, in which case we should log.", "bodyHTML": "<p dir=\"auto\">If <code>onError()</code> throws from the above <code>catch</code> block and then <code>grpcPayloadWriter.close()</code> also throws, <code>concurrentTerminalSubscriber</code> will ignore this call. You can instead use <code>concurrentTerminalSubscriber.processOnError()</code> which returns <code>false</code> if it did not deliver the error, in which case we should log.</p>", "author": "NiteshKant", "createdAt": "2020-02-05T17:49:33Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRouteConversions.java", "diffHunk": "@@ -107,30 +107,38 @@ public Completable closeAsyncGracefully() {\n                 return new Publisher<Resp>() {\n                     @Override\n                     protected void handleSubscribe(final Subscriber<? super Resp> subscriber) {\n-                        ConnectablePayloadWriter<Resp> connectablePayloadWriter = new ConnectablePayloadWriter<>();\n-                        Publisher<Resp> pub = connectablePayloadWriter.connect();\n-                        Subscriber<? super Resp> concurrentTerminalSubscriber =\n+                        final ConnectablePayloadWriter<Resp> connectablePayloadWriter =\n+                                new ConnectablePayloadWriter<>();\n+                        final Publisher<Resp> pub = connectablePayloadWriter.connect();\n+                        final Subscriber<? super Resp> concurrentTerminalSubscriber =\n                                 new ConcurrentTerminalSubscriber<>(subscriber, false);\n                         toSource(pub).subscribe(concurrentTerminalSubscriber);\n+                        final GrpcPayloadWriter<Resp> grpcPayloadWriter = new GrpcPayloadWriter<Resp>() {\n+                            @Override\n+                            public void write(final Resp resp) throws IOException {\n+                                connectablePayloadWriter.write(resp);\n+                            }\n+\n+                            @Override\n+                            public void close() throws IOException {\n+                                connectablePayloadWriter.close();\n+                            }\n+\n+                            @Override\n+                            public void flush() throws IOException {\n+                                connectablePayloadWriter.flush();\n+                            }\n+                        };\n                         try {\n-                            original.handle(ctx, request.toIterable(), new GrpcPayloadWriter<Resp>() {\n-                                @Override\n-                                public void write(final Resp resp) throws IOException {\n-                                    connectablePayloadWriter.write(resp);\n-                                }\n-\n-                                @Override\n-                                public void close() throws IOException {\n-                                    connectablePayloadWriter.close();\n-                                }\n-\n-                                @Override\n-                                public void flush() throws IOException {\n-                                    connectablePayloadWriter.flush();\n-                                }\n-                            });\n+                            original.handle(ctx, request.toIterable(), grpcPayloadWriter);\n                         } catch (Throwable t) {\n                             concurrentTerminalSubscriber.onError(t);\n+                        } finally {\n+                            try {\n+                                grpcPayloadWriter.close();\n+                            } catch (IOException e) {\n+                                concurrentTerminalSubscriber.onError(e);", "originalCommit": "429aebc7d787241a20b08683ba29e7fab2578fcd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQxNDY1MA==", "url": "https://github.com/apple/servicetalk/pull/932#discussion_r375414650", "body": "It seems like it is trivial to create a merged map for strategies from all routes instead of ignoring them. It is better to not make exceptions here and make sure we have strategies when defined.", "bodyText": "It seems like it is trivial to create a merged map for strategies from all routes instead of ignoring them. It is better to not make exceptions here and make sure we have strategies when defined.", "bodyHTML": "<p dir=\"auto\">It seems like it is trivial to create a merged map for strategies from all routes instead of ignoring them. It is better to not make exceptions here and make sure we have strategies when defined.</p>", "author": "NiteshKant", "createdAt": "2020-02-05T17:57:56Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRoutes.java", "diffHunk": "@@ -159,7 +171,9 @@ public Completable closeAsyncGracefully() {\n             builders[i] = allRoutes[i].routeBuilder;\n             errors.addAll(allRoutes[i].errors);\n         }\n-        return new GrpcRoutes<GrpcService>(GrpcRouter.Builder.merge(builders), errors) {\n+        // At the time of merging all GrpcRoutes together we don't need an executionStrategies map and can pass an empty", "originalCommit": "429aebc7d787241a20b08683ba29e7fab2578fcd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQxNzcwMA==", "url": "https://github.com/apple/servicetalk/pull/932#discussion_r375417700", "body": "Just use `get()` and eliminate defining `NULL` as default?\r\n\r\n```java\r\nfinal GrpcExecutionStrategy saved = executionStrategies.get(path);\r\nif (saved != null) {\r\n    return saved;\r\n}\r\n```", "bodyText": "Just use get() and eliminate defining NULL as default?\nfinal GrpcExecutionStrategy saved = executionStrategies.get(path);\nif (saved != null) {\n    return saved;\n}", "bodyHTML": "<p dir=\"auto\">Just use <code>get()</code> and eliminate defining <code>NULL</code> as default?</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"final GrpcExecutionStrategy saved = executionStrategies.get(path);\nif (saved != null) {\n    return saved;\n}\n\"><pre><span class=\"pl-k\">final</span> <span class=\"pl-smi\">GrpcExecutionStrategy</span> saved <span class=\"pl-k\">=</span> executionStrategies<span class=\"pl-k\">.</span>get(path);\n<span class=\"pl-k\">if</span> (saved <span class=\"pl-k\">!=</span> <span class=\"pl-c1\">null</span>) {\n    <span class=\"pl-k\">return</span> saved;\n}</pre></div>", "author": "NiteshKant", "createdAt": "2020-02-05T18:03:38Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRoutes.java", "diffHunk": "@@ -173,9 +187,18 @@ protected GrpcService newServiceFromRoutes(final AllGrpcRoutes routes) {\n     }\n \n     @Nullable\n-    private GrpcExecutionStrategy executionStrategy(final Method method, final Class<?> clazz) {\n-        return getAndValidateRouteExecutionStrategyAnnotationIfPresent(method, clazz, strategyFactory, errors,\n-                noOffloadsStrategy());\n+    private GrpcExecutionStrategy executionStrategy(final String path, final Method method, final Class<?> clazz) {\n+        // Check if we already have a computed GrpcExecutionStrategy for this path. This may happen when we re-register\n+        // filtered routes:\n+        final GrpcExecutionStrategy saved = executionStrategies.getOrDefault(path, NULL);", "originalCommit": "429aebc7d787241a20b08683ba29e7fab2578fcd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYxNTU0OQ==", "url": "https://github.com/apple/servicetalk/pull/932#discussion_r375615549", "bodyText": "Let's continue this discussion here: #932 (comment)", "author": "idelpivnitskiy", "createdAt": "2020-02-06T02:42:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQxNzcwMA=="}], "type": "inlineReview"}, {"oid": "ae048c8fc858df0de1ffde7168877ff1330a7b82", "url": "https://github.com/apple/servicetalk/commit/ae048c8fc858df0de1ffde7168877ff1330a7b82", "message": "Merge remote-tracking branch 'upstream/master' into grpc-filters-es", "committedDate": "2020-02-06T01:35:49Z", "type": "commit"}, {"oid": "a2e87e92ad5eee48d099f023e44ce91c3a33f6e8", "url": "https://github.com/apple/servicetalk/commit/a2e87e92ad5eee48d099f023e44ce91c3a33f6e8", "message": "Address comments", "committedDate": "2020-02-06T01:51:14Z", "type": "commit"}, {"oid": "0fbb4fbbff1808d58bb6d9b5cee6d150140c40e3", "url": "https://github.com/apple/servicetalk/commit/0fbb4fbbff1808d58bb6d9b5cee6d150140c40e3", "message": "Save execution strategy after we verified route was not registered twice", "committedDate": "2020-02-06T02:09:48Z", "type": "commit"}, {"oid": "5820d3310904811ba595fefc4ac5c84a0639f349", "url": "https://github.com/apple/servicetalk/commit/5820d3310904811ba595fefc4ac5c84a0639f349", "message": "Move executionStrategies map from GrpcRoutes to GrpcRouter", "committedDate": "2020-02-06T02:23:25Z", "type": "commit"}, {"oid": "f32710c634351a6e08f374fce548947454756ed0", "url": "https://github.com/apple/servicetalk/commit/f32710c634351a6e08f374fce548947454756ed0", "message": "Revert unnecessary modifications", "committedDate": "2020-02-06T02:41:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYxMzQwNA==", "url": "https://github.com/apple/servicetalk/pull/932#discussion_r375613404", "body": "nit\r\n```suggestion\r\n                                    LOGGER.error(\"Failed to close GrpcPayloadWriter\", e);\r\n```", "bodyText": "nit\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                LOGGER.error(\"Cannot close GrpcPayloadWriter\", e);\n          \n          \n            \n                                                LOGGER.error(\"Failed to close GrpcPayloadWriter\", e);", "bodyHTML": "<p dir=\"auto\">nit</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                                    <span class=\"pl-c1\">LOGGER</span><span class=\"pl-k\">.</span>error(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"x x-first x-last\">Cannot</span> close GrpcPayloadWriter<span class=\"pl-pds\">\"</span></span>, e);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                                    <span class=\"pl-c1\">LOGGER</span><span class=\"pl-k\">.</span>error(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"x x-first x-last\">Failed to</span> close GrpcPayloadWriter<span class=\"pl-pds\">\"</span></span>, e);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "NiteshKant", "createdAt": "2020-02-06T02:33:02Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRouteConversions.java", "diffHunk": "@@ -137,7 +143,9 @@ public void flush() throws IOException {\n                             try {\n                                 grpcPayloadWriter.close();\n                             } catch (IOException e) {\n-                                concurrentTerminalSubscriber.onError(e);\n+                                if (!concurrentTerminalSubscriber.processOnError(e)) {\n+                                    LOGGER.error(\"Cannot close GrpcPayloadWriter\", e);", "originalCommit": "5820d3310904811ba595fefc4ac5c84a0639f349", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA1OTE3NA==", "url": "https://github.com/apple/servicetalk/pull/932#discussion_r376059174", "body": "```suggestion\r\n                executionStrategies.putAll(builder.executionStrategies);\r\n```\r\n\r\nIf it is simple, add a test to verify, else it is OK.", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            executionStrategies.putAll(executionStrategies);\n          \n          \n            \n                            executionStrategies.putAll(builder.executionStrategies);\n          \n      \n    \n    \n  \n\nIf it is simple, add a test to verify, else it is OK.", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                executionStrategies<span class=\"pl-k\">.</span>putAll(executionStrategies);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                executionStrategies<span class=\"pl-k\">.</span>putAll(<span class=\"x x-first\">builder</span><span class=\"pl-k x x-last\">.</span>executionStrategies);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n\n<p dir=\"auto\">If it is simple, add a test to verify, else it is OK.</p>", "author": "NiteshKant", "createdAt": "2020-02-06T20:16:40Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRouter.java", "diffHunk": "@@ -196,18 +200,25 @@ RouteProviders drainRoutes() {\n             return new RouteProviders(allRoutes);\n         }\n \n+        GrpcExecutionStrategy alreadyRegisteredExecutionStrategy(final String path,\n+                                                                 final GrpcExecutionStrategy defaultValue) {\n+            return executionStrategies.getOrDefault(path, defaultValue);\n+        }\n+\n         static GrpcRouter.Builder merge(final GrpcRouter.Builder... builders) {\n             final Map<String, RouteProvider> routes = new HashMap<>();\n             final Map<String, RouteProvider> streamingRoutes = new HashMap<>();\n             final Map<String, RouteProvider> blockingRoutes = new HashMap<>();\n             final Map<String, RouteProvider> blockingStreamingRoutes = new HashMap<>();\n+            final Map<String, GrpcExecutionStrategy> executionStrategies = new HashMap<>();\n             for (Builder builder : builders) {\n                 mergeRoutes(routes, builder.routes);\n                 mergeRoutes(streamingRoutes, builder.streamingRoutes);\n                 mergeRoutes(blockingRoutes, builder.blockingRoutes);\n                 mergeRoutes(blockingStreamingRoutes, builder.blockingStreamingRoutes);\n+                executionStrategies.putAll(executionStrategies);", "originalCommit": "f32710c634351a6e08f374fce548947454756ed0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA2MTI4MA==", "url": "https://github.com/apple/servicetalk/pull/932#discussion_r376061280", "body": "Rename `alreadyRegisteredExecutionStrategy` => `executionStrategyFor()`\r\n\r\nIt does not seem like \"already registered\" is providing any additional value here.", "bodyText": "Rename alreadyRegisteredExecutionStrategy => executionStrategyFor()\nIt does not seem like \"already registered\" is providing any additional value here.", "bodyHTML": "<p dir=\"auto\">Rename <code>alreadyRegisteredExecutionStrategy</code> =&gt; <code>executionStrategyFor()</code></p>\n<p dir=\"auto\">It does not seem like \"already registered\" is providing any additional value here.</p>", "author": "NiteshKant", "createdAt": "2020-02-06T20:21:24Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRouter.java", "diffHunk": "@@ -196,18 +200,25 @@ RouteProviders drainRoutes() {\n             return new RouteProviders(allRoutes);\n         }\n \n+        GrpcExecutionStrategy alreadyRegisteredExecutionStrategy(final String path,", "originalCommit": "f32710c634351a6e08f374fce548947454756ed0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA2NDczNA==", "url": "https://github.com/apple/servicetalk/pull/932#discussion_r376064734", "body": "`null` executionStrategy has no semantic meaning from a user point of view. We use it as a short-cut internally to avoid method overloads. If we only add non-null strategy for a path in `GrpcRouter` methods, can we simplify this as `null` value meaning no strategy is defined?", "bodyText": "null executionStrategy has no semantic meaning from a user point of view. We use it as a short-cut internally to avoid method overloads. If we only add non-null strategy for a path in GrpcRouter methods, can we simplify this as null value meaning no strategy is defined?", "bodyHTML": "<p dir=\"auto\"><code>null</code> executionStrategy has no semantic meaning from a user point of view. We use it as a short-cut internally to avoid method overloads. If we only add non-null strategy for a path in <code>GrpcRouter</code> methods, can we simplify this as <code>null</code> value meaning no strategy is defined?</p>", "author": "NiteshKant", "createdAt": "2020-02-06T20:29:10Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRoutes.java", "diffHunk": "@@ -173,7 +177,15 @@ protected GrpcService newServiceFromRoutes(final AllGrpcRoutes routes) {\n     }\n \n     @Nullable\n-    private GrpcExecutionStrategy executionStrategy(final Method method, final Class<?> clazz) {\n+    private GrpcExecutionStrategy executionStrategy(final String path, final Method method, final Class<?> clazz) {\n+        // Check if we already have a computed GrpcExecutionStrategy for this path. This happens when we re-register\n+        // filtered routes and have to use the original execution strategy for the route instead of analysing\n+        // annotations on a service-filter class. Because previously registered strategy could be null, we use NULL", "originalCommit": "f32710c634351a6e08f374fce548947454756ed0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjExNDA2Mg==", "url": "https://github.com/apple/servicetalk/pull/932#discussion_r376114062", "bodyText": "This null is not visible for users. null will be here only when users use ServiceFactory.Builder methods that do not take execution strategy and they do not add annotations on the service. For a null use-case we define execution strategy based on the method API: \n  \n    \n      servicetalk/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRouter.java\n    \n    \n         Line 259\n      in\n      412222c\n    \n    \n    \n    \n\n        \n          \n           }, strategy -> executionStrategy == null ? strategy : executionStrategy),", "author": "idelpivnitskiy", "createdAt": "2020-02-06T22:18:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA2NDczNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyNTM0OQ==", "url": "https://github.com/apple/servicetalk/pull/932#discussion_r376125349", "bodyText": "I understand that. I am questioning the need for this awkward NULL marker used here which is trying to distinguish between whether the value stored in the executionStrategies Map for a path is null or there is no mapping for that path.\nIf we do not put a null value in the executionStrategies Map then we do not need this NULL marker here, rite?", "author": "NiteshKant", "createdAt": "2020-02-06T22:48:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA2NDczNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE3NzgxNg==", "url": "https://github.com/apple/servicetalk/pull/932#discussion_r376177816", "bodyText": "The stored path<->null pair helps to understand that we already processed annotations for this route and an execution strategy for this route was null (therefore, we have to infer an execution strategy based on the route API).\nIf we won't store path<->null pair, we don't have a way to distinguish between \"we already know that the execution strategy for this route is null\" (this is when we re-register route with a filter) and \"we don't know the execution strategy for this route and have to process annotations\" (first-time registration of the route).", "author": "idelpivnitskiy", "createdAt": "2020-02-07T01:49:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA2NDczNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE3ODAyOA==", "url": "https://github.com/apple/servicetalk/pull/932#discussion_r376178028", "bodyText": "We need to know this difference because the same code path is used for initial route registration and re-registration of the filtered route.", "author": "idelpivnitskiy", "createdAt": "2020-02-07T01:50:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA2NDczNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjUwMTk1Nw==", "url": "https://github.com/apple/servicetalk/pull/932#discussion_r376501957", "bodyText": "@NiteshKant if the main concern is the awkward NULL marker, I've pushed an alternative impl using a boolean flag: fd575fd\nLMK if this approach looks better.", "author": "idelpivnitskiy", "createdAt": "2020-02-07T17:02:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA2NDczNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU0MTc2MQ==", "url": "https://github.com/apple/servicetalk/pull/932#discussion_r376541761", "bodyText": "IMHO the boolean approach is slightly worse than what you had earlier as it stores state(registerFilters) assuming interactions from GrpcServiceFactory#applyFilterToRoutes().\nIt seems we are working around code to support \"filters should not have strategy annotation\" scenario. Since you seem to be convinced that scenario needs to be validated, lets go with what you had before (NULL marker approach) which looks like a lesser evil.", "author": "NiteshKant", "createdAt": "2020-02-07T18:33:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA2NDczNA=="}], "type": "inlineReview"}, {"oid": "b0cc9f70c83e8452835a5845f662daa3431782aa", "url": "https://github.com/apple/servicetalk/commit/b0cc9f70c83e8452835a5845f662daa3431782aa", "message": "Address comments", "committedDate": "2020-02-06T22:14:54Z", "type": "commit"}, {"oid": "fd575fdf701a6da07743d95068edec6df9525b6f", "url": "https://github.com/apple/servicetalk/commit/fd575fdf701a6da07743d95068edec6df9525b6f", "message": "Use `boolean` flag instead of dummy `NULL` object", "committedDate": "2020-02-07T16:58:48Z", "type": "commit"}, {"oid": "385b321e9c7e204508e91849def96dba06e3ad04", "url": "https://github.com/apple/servicetalk/commit/385b321e9c7e204508e91849def96dba06e3ad04", "message": "Revert \"Use `boolean` flag instead of dummy `NULL` object\"\n\nThis reverts commit fd575fdf701a6da07743d95068edec6df9525b6f.", "committedDate": "2020-02-07T18:39:34Z", "type": "commit"}]}