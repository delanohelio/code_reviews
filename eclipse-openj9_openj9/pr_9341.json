{"pr_number": 9341, "pr_title": "Java 14: track interrupt state when thread is dead", "pr_author": "theresa-m", "pr_createdAt": "2020-04-23T15:20:35Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/9341", "timeline": [{"oid": "d0f53a8c489079fd059b1e92d3d5ada006aa4753", "url": "https://github.com/eclipse-openj9/openj9/commit/d0f53a8c489079fd059b1e92d3d5ada006aa4753", "message": "Java 14: track interrupt state when thread is dead\n\nA new private boolean is added to java.lang.Thread to track the interrupt state since a J9VMThread only exists when the thread is actually running. When a thread is started the interrupt state will be transferred from the deadInterrupt boolean to the J9VMThread and tracked in the vm. When the thread is cleaned up, the interrupt state will be transferred back to be tracked by the deadInterrupt boolean.\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-04-23T15:26:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NjM2NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r413956364", "body": "Why bother introducing this variable at all in versions < 14? In the vmconstantpool.xml the versions can be specified via `versions=\"14-\"`. Similarly the VM code can use `#if JAVA_SPEC_VERSION >= 14`", "bodyText": "Why bother introducing this variable at all in versions < 14? In the vmconstantpool.xml the versions can be specified via versions=\"14-\". Similarly the VM code can use #if JAVA_SPEC_VERSION >= 14", "bodyHTML": "<p dir=\"auto\">Why bother introducing this variable at all in versions &lt; 14? In the vmconstantpool.xml the versions can be specified via <code>versions=\"14-\"</code>. Similarly the VM code can use <code>#if JAVA_SPEC_VERSION &gt;= 14</code></p>", "author": "pshipton", "createdAt": "2020-04-23T16:45:08Z", "path": "jcl/src/java.base/share/classes/java/lang/Thread.java", "diffHunk": "@@ -80,6 +80,13 @@\n \t// Instance variables\n \tprivate long threadRef;\t\t\t\t\t\t\t\t\t// Used by the VM\n \tlong stackSize = 0;\n+    /* For Java 14+:\n+     * deadInterrupt tracks the thread interrupt state when threadRef has no reference (ie thread is not alive). \n+     * Note that this value need not be updated while the thread is running since the interrupt state will be \n+     * tracked by the vm during that time. Because of this the value should not be used over calling\n+     *  isInterrupted() or interrupted().\n+     */\n+\tprivate volatile boolean deadInterrupt;", "originalCommit": "d0f53a8c489079fd059b1e92d3d5ada006aa4753", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NjgyNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r413956824", "body": "Pls use the preprocessor to only include this in Java 14+. Similarly for isInterrupted().", "bodyText": "Pls use the preprocessor to only include this in Java 14+. Similarly for isInterrupted().", "bodyHTML": "<p dir=\"auto\">Pls use the preprocessor to only include this in Java 14+. Similarly for isInterrupted().</p>", "author": "pshipton", "createdAt": "2020-04-23T16:45:46Z", "path": "jcl/src/java.base/share/classes/java/lang/Thread.java", "diffHunk": "@@ -677,6 +684,8 @@ public final ThreadGroup getThreadGroup() {\n \n /**\n  * Posts an interrupt request to the receiver\n+ * \n+ * From Java 14, the interrupt state for threads that are not alive is tracked.", "originalCommit": "d0f53a8c489079fd059b1e92d3d5ada006aa4753", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c1d3d5fbe89f6aa609a2a12975941f0d9a0781e8", "url": "https://github.com/eclipse-openj9/openj9/commit/c1d3d5fbe89f6aa609a2a12975941f0d9a0781e8", "message": "Java 14: track interrupt state when thread is dead\n\nA new private boolean is added to java.lang.Thread to track the interrupt state since a J9VMThread only exists when the thread is actually running. When a thread is started the interrupt state will be transferred from the deadInterrupt boolean to the J9VMThread and tracked in the vm. When the thread is cleaned up, the interrupt state will be transferred back to be tracked by the deadInterrupt boolean.\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-04-24T18:47:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzMTM5NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r414831394", "body": "The indenting is off in the new section. Using spaces instead of tabs like the surrounding code.", "bodyText": "The indenting is off in the new section. Using spaces instead of tabs like the surrounding code.", "bodyHTML": "<p dir=\"auto\">The indenting is off in the new section. Using spaces instead of tabs like the surrounding code.</p>", "author": "pshipton", "createdAt": "2020-04-24T20:04:35Z", "path": "jcl/src/java.base/share/classes/java/lang/Thread.java", "diffHunk": "@@ -79,7 +79,15 @@\n \n \t// Instance variables\n \tprivate long threadRef;\t\t\t\t\t\t\t\t\t// Used by the VM\n-\tlong stackSize = 0;\n+    long stackSize = 0;", "originalCommit": "c1d3d5fbe89f6aa609a2a12975941f0d9a0781e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzNDkwNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r414834905", "body": "This test should be just rolled into test_interruptAtStartSetAfterRun()", "bodyText": "This test should be just rolled into test_interruptAtStartSetAfterRun()", "bodyHTML": "<p dir=\"auto\">This test should be just rolled into test_interruptAtStartSetAfterRun()</p>", "author": "pshipton", "createdAt": "2020-04-24T20:11:26Z", "path": "test/functional/Java14andUp/src/org/openj9/test/java/lang/Test_Thread.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.openj9.test.java.lang;\n+\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+import org.testng.annotations.Test;\n+import org.testng.AssertJUnit;\n+\n+/**\n+ * This test is to verify matching behavior to the RI from the following implementation change\n+ * discussed in the Java 14 release notes:\n+ * \n+ * \"The specification for java.lang.Thread::interrupt allows for an implementation to only track the \n+ * interrupt state for live threads, and previously this is what occurred. As of this release, the \n+ * interrupt state of a Thread is always available, and if you interrupt a thread t before it is started, \n+ * or after it has terminated, the query t.isInterrupted() will return true.\"\n+ */\n+\n+@Test(groups = { \"level.sanity\" })\n+public class Test_Thread {\n+\n+    /* interrupt thread before it has started */\n+    @Test\n+    public void test_interruptBeforeRun() {\n+        String name = \"interruptBeforeRun: \";\n+        Thread t = new Thread();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+        t.interrupt();\n+\n+        /* Verify that the thread was successfully interrupted. */\n+        AssertJUnit.assertTrue(name + \"thread that has not started should have interrupt flag set\", t.isInterrupted());", "originalCommit": "c1d3d5fbe89f6aa609a2a12975941f0d9a0781e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzNzUwMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r414837501", "body": "Pls set a volatile boolean field here, and test it after join(). Similarly in the next test.", "bodyText": "Pls set a volatile boolean field here, and test it after join(). Similarly in the next test.", "bodyHTML": "<p dir=\"auto\">Pls set a volatile boolean field here, and test it after join(). Similarly in the next test.</p>", "author": "pshipton", "createdAt": "2020-04-24T20:16:27Z", "path": "test/functional/Java14andUp/src/org/openj9/test/java/lang/Test_Thread.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.openj9.test.java.lang;\n+\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+import org.testng.annotations.Test;\n+import org.testng.AssertJUnit;\n+\n+/**\n+ * This test is to verify matching behavior to the RI from the following implementation change\n+ * discussed in the Java 14 release notes:\n+ * \n+ * \"The specification for java.lang.Thread::interrupt allows for an implementation to only track the \n+ * interrupt state for live threads, and previously this is what occurred. As of this release, the \n+ * interrupt state of a Thread is always available, and if you interrupt a thread t before it is started, \n+ * or after it has terminated, the query t.isInterrupted() will return true.\"\n+ */\n+\n+@Test(groups = { \"level.sanity\" })\n+public class Test_Thread {\n+\n+    /* interrupt thread before it has started */\n+    @Test\n+    public void test_interruptBeforeRun() {\n+        String name = \"interruptBeforeRun: \";\n+        Thread t = new Thread();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+        t.interrupt();\n+\n+        /* Verify that the thread was successfully interrupted. */\n+        AssertJUnit.assertTrue(name + \"thread that has not started should have interrupt flag set\", t.isInterrupted());\n+    }\n+\n+    /* interrupt thread after it has ended */\n+    @Test\n+    public void test_interruptAfterRun() throws Throwable {\n+        String name = \"interruptAfterRun: \";\n+        Thread t = new Thread();\n+\n+        /* run thread */\n+        t.start();\n+        t.join();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+       t.interrupt();\n+\n+        /* Verify that the thread was successfully interrupted. */\n+        AssertJUnit.assertTrue(name + \"thread that has ended was was interrupted\", t.isInterrupted());    \n+    }\n+\n+    /* if thread is interrupted before start, verify that flag is still set after run. */\n+    @Test\n+    public void test_interruptAtStartSetAfterRun() throws Throwable {\n+        String name = \"interruptAtStartSetAfterRun: \";\n+        Thread t = new Thread();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+        t.interrupt();\n+\n+        /* run thread */\n+        t.run();\n+        t.join();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should be dead\", t.isAlive());\n+        AssertJUnit.assertTrue(name + \"interrupt flag should be set\", t.isInterrupted()); \n+    }\n+\n+    /* Interrupt thread during run, verify that interrupt flag is not set when thread stops running. \n+     * isInterrupted becomes false after InterruptedException is thrown. */\n+    @Test\n+    public void test_interruptDuringRun() throws Throwable {\n+        String name = \"interruptDuringRun: \";\n+        Thread t = new Thread() {\n+            public void run() {\n+                synchronized(this) {\n+                    try {\n+                        wait();\n+                        AssertJUnit.fail(); /* not interrupted */\n+                    } catch (InterruptedException e) {\n+                        /* expected */", "originalCommit": "c1d3d5fbe89f6aa609a2a12975941f0d9a0781e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0MTcwNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r414841706", "body": "This and the join() don't do anything, so this is really the same test as test_interruptBeforeRun().", "bodyText": "This and the join() don't do anything, so this is really the same test as test_interruptBeforeRun().", "bodyHTML": "<p dir=\"auto\">This and the join() don't do anything, so this is really the same test as test_interruptBeforeRun().</p>", "author": "pshipton", "createdAt": "2020-04-24T20:24:47Z", "path": "test/functional/Java14andUp/src/org/openj9/test/java/lang/Test_Thread.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.openj9.test.java.lang;\n+\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+import org.testng.annotations.Test;\n+import org.testng.AssertJUnit;\n+\n+/**\n+ * This test is to verify matching behavior to the RI from the following implementation change\n+ * discussed in the Java 14 release notes:\n+ * \n+ * \"The specification for java.lang.Thread::interrupt allows for an implementation to only track the \n+ * interrupt state for live threads, and previously this is what occurred. As of this release, the \n+ * interrupt state of a Thread is always available, and if you interrupt a thread t before it is started, \n+ * or after it has terminated, the query t.isInterrupted() will return true.\"\n+ */\n+\n+@Test(groups = { \"level.sanity\" })\n+public class Test_Thread {\n+\n+    /* interrupt thread before it has started */\n+    @Test\n+    public void test_interruptBeforeRun() {\n+        String name = \"interruptBeforeRun: \";\n+        Thread t = new Thread();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+        t.interrupt();\n+\n+        /* Verify that the thread was successfully interrupted. */\n+        AssertJUnit.assertTrue(name + \"thread that has not started should have interrupt flag set\", t.isInterrupted());\n+    }\n+\n+    /* interrupt thread after it has ended */\n+    @Test\n+    public void test_interruptAfterRun() throws Throwable {\n+        String name = \"interruptAfterRun: \";\n+        Thread t = new Thread();\n+\n+        /* run thread */\n+        t.start();\n+        t.join();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+       t.interrupt();\n+\n+        /* Verify that the thread was successfully interrupted. */\n+        AssertJUnit.assertTrue(name + \"thread that has ended was was interrupted\", t.isInterrupted());    \n+    }\n+\n+    /* if thread is interrupted before start, verify that flag is still set after run. */\n+    @Test\n+    public void test_interruptAtStartSetAfterRun() throws Throwable {\n+        String name = \"interruptAtStartSetAfterRun: \";\n+        Thread t = new Thread();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+        t.interrupt();\n+\n+        /* run thread */\n+        t.run();", "originalCommit": "c1d3d5fbe89f6aa609a2a12975941f0d9a0781e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0NDQ1NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r414844454", "body": "This and join() don't do anything, this test is the same as test_interruptAtStartSetAfterRun()", "bodyText": "This and join() don't do anything, this test is the same as test_interruptAtStartSetAfterRun()", "bodyHTML": "<p dir=\"auto\">This and join() don't do anything, this test is the same as test_interruptAtStartSetAfterRun()</p>", "author": "pshipton", "createdAt": "2020-04-24T20:29:42Z", "path": "test/functional/Java14andUp/src/org/openj9/test/java/lang/Test_Thread.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.openj9.test.java.lang;\n+\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+import org.testng.annotations.Test;\n+import org.testng.AssertJUnit;\n+\n+/**\n+ * This test is to verify matching behavior to the RI from the following implementation change\n+ * discussed in the Java 14 release notes:\n+ * \n+ * \"The specification for java.lang.Thread::interrupt allows for an implementation to only track the \n+ * interrupt state for live threads, and previously this is what occurred. As of this release, the \n+ * interrupt state of a Thread is always available, and if you interrupt a thread t before it is started, \n+ * or after it has terminated, the query t.isInterrupted() will return true.\"\n+ */\n+\n+@Test(groups = { \"level.sanity\" })\n+public class Test_Thread {\n+\n+    /* interrupt thread before it has started */\n+    @Test\n+    public void test_interruptBeforeRun() {\n+        String name = \"interruptBeforeRun: \";\n+        Thread t = new Thread();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+        t.interrupt();\n+\n+        /* Verify that the thread was successfully interrupted. */\n+        AssertJUnit.assertTrue(name + \"thread that has not started should have interrupt flag set\", t.isInterrupted());\n+    }\n+\n+    /* interrupt thread after it has ended */\n+    @Test\n+    public void test_interruptAfterRun() throws Throwable {\n+        String name = \"interruptAfterRun: \";\n+        Thread t = new Thread();\n+\n+        /* run thread */\n+        t.start();\n+        t.join();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+       t.interrupt();\n+\n+        /* Verify that the thread was successfully interrupted. */\n+        AssertJUnit.assertTrue(name + \"thread that has ended was was interrupted\", t.isInterrupted());    \n+    }\n+\n+    /* if thread is interrupted before start, verify that flag is still set after run. */\n+    @Test\n+    public void test_interruptAtStartSetAfterRun() throws Throwable {\n+        String name = \"interruptAtStartSetAfterRun: \";\n+        Thread t = new Thread();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+        t.interrupt();\n+\n+        /* run thread */\n+        t.run();\n+        t.join();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should be dead\", t.isAlive());\n+        AssertJUnit.assertTrue(name + \"interrupt flag should be set\", t.isInterrupted()); \n+    }\n+\n+    /* Interrupt thread during run, verify that interrupt flag is not set when thread stops running. \n+     * isInterrupted becomes false after InterruptedException is thrown. */\n+    @Test\n+    public void test_interruptDuringRun() throws Throwable {\n+        String name = \"interruptDuringRun: \";\n+        Thread t = new Thread() {\n+            public void run() {\n+                synchronized(this) {\n+                    try {\n+                        wait();\n+                        AssertJUnit.fail(); /* not interrupted */\n+                    } catch (InterruptedException e) {\n+                        /* expected */\n+                    }\n+                }\n+            }\n+        };\n+\n+        /* run thread */\n+        t.start();\n+        AssertJUnit.assertFalse(name + \"thread not yet interrupted during run\", t.isInterrupted());\n+        t.interrupt();\n+        t.join();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should be dead\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted()); \n+    }\n+\n+    /* Interrupt thread at start and during run, verify that interrupt flag is not set when thread stops running.\n+     * isInterrupted becomes false after InterruptedException is thrown. */\n+    @Test\n+    public void test_interruptBeforeAndDuringRun() throws Throwable {\n+        String name = \"interruptBeforeAndDuringRun: \";\n+        Thread t = new Thread() {\n+            public void run() {\n+                synchronized(this) {\n+                    try {\n+                        wait();\n+                        AssertJUnit.fail(); /* not interrupted */\n+                    } catch (InterruptedException e) {\n+                        /* expected */\n+                    }\n+                }\n+            }\n+        };\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+        /* interrupt before run */\n+        t.interrupt();\n+\n+        AssertJUnit.assertTrue(name + \"thread that has not started should have interrupt flag set\", t.isInterrupted());\n+\n+        /* run thread */\n+        t.start();\n+        t.interrupt();\n+        t.join();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should be dead\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should be cleared\", t.isInterrupted()); \n+    }\n+\n+    /* If thread is interrupted before start, Thread.interrupted is set */\n+    @Test\n+    public void test_interruptedStart() throws Throwable {\n+        String name = \"interruptedStart: \";\n+        Thread t = new Thread(){\n+            public void run() throws AssertionError {\n+                AssertJUnit.assertTrue(Thread.interrupted());\n+            }\n+          };\n+\n+        /* interrupt before start */\n+        t.interrupt();\n+\n+        t.start();\n+        t.join();\n+\n+        AssertJUnit.assertFalse(name + \"interrupt flag should be cleared\", t.isInterrupted()); \n+    }\n+\n+    /* If thread is interrupted before run, Thread.interrupted is not set */\n+    @Test\n+    public void test_interruptedRun() throws Throwable {\n+        String name = \"interrupted\";\n+        Thread t = new Thread(){\n+            public void run() throws AssertionError {\n+                AssertJUnit.assertFalse(Thread.interrupted());\n+            }\n+            };\n+\n+        /* interrupt before start */\n+        t.interrupt();\n+\n+        t.run();", "originalCommit": "c1d3d5fbe89f6aa609a2a12975941f0d9a0781e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c2c9a1cb6fa359b15723150e1d0f7a1644557667", "url": "https://github.com/eclipse-openj9/openj9/commit/c2c9a1cb6fa359b15723150e1d0f7a1644557667", "message": "Fix formatting", "committedDate": "2020-04-24T20:53:21Z", "type": "forcePushed"}, {"oid": "c4b895791d3ef2f9e254d6317fbbadc02edfa95d", "url": "https://github.com/eclipse-openj9/openj9/commit/c4b895791d3ef2f9e254d6317fbbadc02edfa95d", "message": "Fix formatting", "committedDate": "2020-04-24T20:54:19Z", "type": "forcePushed"}, {"oid": "99c75c37e3309c53314dbfa310ae3efe4202a60a", "url": "https://github.com/eclipse-openj9/openj9/commit/99c75c37e3309c53314dbfa310ae3efe4202a60a", "message": "Fix formatting", "committedDate": "2020-04-24T20:55:03Z", "type": "forcePushed"}, {"oid": "88c5e35d29688065ac52933a616c805702e4de8b", "url": "https://github.com/eclipse-openj9/openj9/commit/88c5e35d29688065ac52933a616c805702e4de8b", "message": "Formatting", "committedDate": "2020-04-24T20:56:51Z", "type": "forcePushed"}, {"oid": "7db4f6e386800ab9451a3a646d1656d9d035e71a", "url": "https://github.com/eclipse-openj9/openj9/commit/7db4f6e386800ab9451a3a646d1656d9d035e71a", "message": "Java 14: track interrupt state when thread is dead\n\n- A new private boolean is added to java.lang.Thread to track the interrupt state since a J9VMThread only exists when the thread is actually running. When a thread is started the interrupt state will be transferred from the deadInterrupt boolean to the J9VMThread and tracked in the vm. When the thread is cleaned up, the interrupt state will be transferred back to be tracked by the deadInterrupt boolean.\n- Update formatting for Java14AndUp test playlist\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-04-29T18:10:49Z", "type": "forcePushed"}, {"oid": "ba295f22a72c6877721b6b71d3ffaaedcfff215b", "url": "https://github.com/eclipse-openj9/openj9/commit/ba295f22a72c6877721b6b71d3ffaaedcfff215b", "message": "Java 14: track interrupt state when thread is dead\n\n- A new private boolean is added to java.lang.Thread to track the interrupt state since a J9VMThread only exists when the thread is actually running. When a thread is started the interrupt state will be transferred from the deadInterrupt boolean to the J9VMThread and tracked in the vm. When the thread is cleaned up, the interrupt state will be transferred back to be tracked by the deadInterrupt boolean.\n- Update formatting for Java14AndUp test playlist\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-04-29T20:55:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM4MzU1Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r420383556", "body": "Formating nitpick \r\n```suggestion\r\n\t/* deadInterrupt tracks the thread interrupt state when threadRef has no reference (ie thread is not alive). \r\n\t * Note that this value need not be updated while the thread is running since the interrupt state will be \r\n\t * tracked by the vm during that time. Because of this the value should not be used over calling\r\n\t * isInterrupted() or interrupted().\r\n\t */\r\n```", "bodyText": "Formating nitpick\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t/*  deadInterrupt tracks the thread interrupt state when threadRef has no reference (ie thread is not alive). \n          \n          \n            \n            \t* Note that this value need not be updated while the thread is running since the interrupt state will be \n          \n          \n            \n            \t* tracked by the vm during that time. Because of this the value should not be used over calling\n          \n          \n            \n            \t*  isInterrupted() or interrupted().\n          \n          \n            \n            \t*/\n          \n          \n            \n            \t/* deadInterrupt tracks the thread interrupt state when threadRef has no reference (ie thread is not alive). \n          \n          \n            \n            \t * Note that this value need not be updated while the thread is running since the interrupt state will be \n          \n          \n            \n            \t * tracked by the vm during that time. Because of this the value should not be used over calling\n          \n          \n            \n            \t * isInterrupted() or interrupted().\n          \n          \n            \n            \t */", "bodyHTML": "<p dir=\"auto\">Formating nitpick</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">\t<span class=\"pl-c\"><span class=\"pl-c\">/*</span> <span class=\"x x-first x-last\"> </span>deadInterrupt tracks the thread interrupt state when threadRef has no reference (ie thread is not alive). </span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">\t<span class=\"pl-k\">*</span> <span class=\"pl-smi\">Note</span> that <span class=\"pl-c1\">this</span> value need not be updated <span class=\"pl-k\">while</span> the thread is running since the interrupt state will be </td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">\t<span class=\"pl-k\">*</span> tracked by the vm during that time. <span class=\"pl-smi\">Because</span> of <span class=\"pl-c1\">this</span> the value should not be used over calling</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">\t<span class=\"pl-k x x-first\">*</span><span class=\"x x-last\"> </span> isInterrupted() or interrupted()<span class=\"pl-c1\">.</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">\t<span class=\"pl-k\">*/</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">\t<span class=\"pl-c\"><span class=\"pl-c\">/*</span> deadInterrupt tracks the thread interrupt state when threadRef has no reference (ie thread is not alive). </span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">\t<span class=\"x x-first x-last\"> </span><span class=\"pl-k\">*</span> <span class=\"pl-smi\">Note</span> that <span class=\"pl-c1\">this</span> value need not be updated <span class=\"pl-k\">while</span> the thread is running since the interrupt state will be </td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">\t<span class=\"x x-first x-last\"> </span><span class=\"pl-k\">*</span> tracked by the vm during that time. <span class=\"pl-smi\">Because</span> of <span class=\"pl-c1\">this</span> the value should not be used over calling</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">\t<span class=\"x x-first\"> </span><span class=\"pl-k x x-last\">*</span> isInterrupted() or interrupted()<span class=\"pl-c1\">.</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">\t<span class=\"x x-first x-last\"> </span><span class=\"pl-k\">*/</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "DanHeidinga", "createdAt": "2020-05-05T20:24:15Z", "path": "jcl/src/java.base/share/classes/java/lang/Thread.java", "diffHunk": "@@ -80,6 +80,14 @@\n \t// Instance variables\n \tprivate long threadRef;\t\t\t\t\t\t\t\t\t// Used by the VM\n \tlong stackSize = 0;\n+\t/*[IF Java14]*/\n+\t/*  deadInterrupt tracks the thread interrupt state when threadRef has no reference (ie thread is not alive). \n+\t* Note that this value need not be updated while the thread is running since the interrupt state will be \n+\t* tracked by the vm during that time. Because of this the value should not be used over calling\n+\t*  isInterrupted() or interrupted().\n+\t*/", "originalCommit": "ba295f22a72c6877721b6b71d3ffaaedcfff215b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM4NDI0OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r420384249", "body": "Formatting seems odd here too\r\n```suggestion\r\n\t\tdeadInterrupt = true;\r\n```", "bodyText": "Formatting seems odd here too\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tdeadInterrupt = true;\n          \n          \n            \n            \t\tdeadInterrupt = true;", "bodyHTML": "<p dir=\"auto\">Formatting seems odd here too</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">\t\t<span class=\"x x-first x-last\">\t</span>deadInterrupt <span class=\"pl-k\">=</span> <span class=\"pl-c1\">true</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">\t\tdeadInterrupt <span class=\"pl-k\">=</span> <span class=\"pl-c1\">true</span>;</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "DanHeidinga", "createdAt": "2020-05-05T20:25:32Z", "path": "jcl/src/java.base/share/classes/java/lang/Thread.java", "diffHunk": "@@ -700,7 +712,12 @@ public void interrupt() {\n \t\tsun.nio.ch.Interruptible localBlockOn = blockOn;\n \t\tif (localBlockOn != null) {\n \t\t\tlocalBlockOn.interrupt(this);\n-\t\t}\n+        }\n+        /*[IF Java14]*/\n+        if (!isAlive()) {\n+\t\t\tdeadInterrupt = true;", "originalCommit": "ba295f22a72c6877721b6b71d3ffaaedcfff215b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9e2f0d88f51b6e5e8743019d8fe1c1e9d88481f8", "url": "https://github.com/eclipse-openj9/openj9/commit/9e2f0d88f51b6e5e8743019d8fe1c1e9d88481f8", "message": "Java 14: track interrupt state when thread is dead\n\n- A new private boolean is added to java.lang.Thread to track the interrupt state since a J9VMThread only exists when the thread is actually running. When a thread is started the interrupt state will be transferred from the deadInterrupt boolean to the J9VMThread and tracked in the vm. When the thread is cleaned up, the interrupt state will be transferred back to be tracked by the deadInterrupt boolean.\n- Update formatting for Java14AndUp test playlist\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-05-05T22:33:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0MDAwOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r421040008", "body": "Why the second interrupt in this test?  The interrupt state should still be set from the previous interrupt call", "bodyText": "Why the second interrupt in this test?  The interrupt state should still be set from the previous interrupt call", "bodyHTML": "<p dir=\"auto\">Why the second interrupt in this test?  The interrupt state should still be set from the previous interrupt call</p>", "author": "DanHeidinga", "createdAt": "2020-05-06T19:30:58Z", "path": "test/functional/Java14andUp/src/org/openj9/test/java/lang/Test_Thread.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package org.openj9.test.java.lang;\n+\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+import org.testng.annotations.Test;\n+import org.testng.AssertJUnit;\n+\n+/**\n+ * This test is to verify matching behavior to the RI from the following implementation change\n+ * discussed in the Java 14 release notes:\n+ * \n+ * \"The specification for java.lang.Thread::interrupt allows for an implementation to only track the \n+ * interrupt state for live threads, and previously this is what occurred. As of this release, the \n+ * interrupt state of a Thread is always available, and if you interrupt a thread t before it is started, \n+ * or after it has terminated, the query t.isInterrupted() will return true.\"\n+ */\n+\n+@Test(groups = { \"level.sanity\" })\n+public class Test_Thread {\n+\n+    /* interrupt thread after it has ended */\n+    @Test\n+    public void test_interruptAfterRun() throws Throwable {\n+        String name = \"interruptAfterRun: \";\n+        Thread t = new Thread();\n+\n+        /* run thread */\n+        t.start();\n+        t.join();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+        \n+        t.interrupt();\n+\n+        /* Verify that the thread was successfully interrupted. */\n+        AssertJUnit.assertTrue(name + \"thread that has ended was was interrupted\", t.isInterrupted());    \n+    }\n+\n+    /* Verify that thread was sucessfully interrupted before it is started, and that the interrupt flag is \n+     * still set after it is run. */\n+    @Test\n+    public void test_interruptAtStartSetAfterRun() throws Throwable {\n+        String name = \"interruptAtStartSetAfterRun: \";\n+        Thread t = new Thread();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+        t.interrupt();\n+\n+        /* Verify that the thread was successfully interrupted. */\n+        AssertJUnit.assertTrue(name + \"thread that has not started should have interrupt flag set\", t.isInterrupted());\n+\n+        /* run thread */\n+        t.start();\n+        t.join();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should be dead\", t.isAlive());\n+        AssertJUnit.assertTrue(name + \"interrupt flag should be set\", t.isInterrupted()); \n+    }\n+\n+    /* Interrupt thread during run, verify that interrupt flag is not set when thread stops running. \n+     * isInterrupted becomes false after InterruptedException is thrown. */\n+    private volatile boolean bool_interruptDuringRun = false;\n+    @Test\n+    public void test_interruptDuringRun() throws Throwable {\n+        String name = \"interruptDuringRun: \";\n+        Thread t = new Thread() {\n+            public void run() {\n+                synchronized(this) {\n+                    try {\n+                        wait();\n+                    } catch (InterruptedException e) {\n+                        /* expected */\n+                        bool_interruptDuringRun = true;\n+                    }\n+                }\n+            }\n+        };\n+\n+        /* run thread */\n+        t.start();\n+        AssertJUnit.assertFalse(name + \"thread not yet interrupted during run\", t.isInterrupted());\n+        t.interrupt();\n+        t.join();\n+\n+        AssertJUnit.assertTrue(name + \"InterruptedException was thrown during run\", bool_interruptDuringRun);\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should be dead\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted()); \n+    }\n+\n+    /* Interrupt thread at start and during run, verify that interrupt flag is not set when thread stops running.\n+     * isInterrupted becomes false after InterruptedException is thrown. */\n+    private volatile boolean bool_interruptBeforeAndDuringRun = false;\n+    @Test\n+    public void test_interruptBeforeAndDuringRun() throws Throwable {\n+        String name = \"interruptBeforeAndDuringRun: \";\n+        Thread t = new Thread() {\n+            public void run() {\n+                synchronized(this) {\n+                    try {\n+                        wait();\n+                    } catch (InterruptedException e) {\n+                        bool_interruptBeforeAndDuringRun = true;\n+                    }\n+                }\n+            }\n+        };\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+        /* interrupt before run */\n+        t.interrupt();\n+\n+        AssertJUnit.assertTrue(name + \"thread that has not started should have interrupt flag set\", t.isInterrupted());\n+\n+        /* run thread */\n+        t.start();\n+        t.interrupt();", "originalCommit": "f926cc1b1c5176688b72ec10dcba320e7e18d2e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1NjE5OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r421056199", "bodyText": "I think the first one can be removed. This interrupt makes the test confusing.", "author": "theresa-m", "createdAt": "2020-05-06T19:59:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0MDAwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA2MjkwOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r421062908", "bodyText": "I thought the point of this test was the interrupt status from before the thread starts is still relevant when running - which would mean we'd want to remove the 2nd, not the first.  Did I misunderstand?", "author": "DanHeidinga", "createdAt": "2020-05-06T20:12:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0MDAwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4NjkzMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r421086930", "bodyText": "That case should be covered by test_interruptedStart", "author": "theresa-m", "createdAt": "2020-05-06T20:56:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0MDAwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0MTE0OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r421041149", "body": "```suggestion\r\n        /* Verify thread is dead and has been interrupted */\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    /* Verify thread is dead and has not been interrupted */\n          \n          \n            \n                    /* Verify thread is dead and has been interrupted */", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-c\"><span class=\"pl-c\">/*</span> Verify thread is dead and has <span class=\"x x-first x-last\">not </span>been interrupted <span class=\"pl-c\">*/</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-c\"><span class=\"pl-c\">/*</span> Verify thread is dead and has been interrupted <span class=\"pl-c\">*/</span></span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "DanHeidinga", "createdAt": "2020-05-06T19:33:05Z", "path": "test/functional/Java14andUp/src/org/openj9/test/java/lang/Test_Thread.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package org.openj9.test.java.lang;\n+\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+import org.testng.annotations.Test;\n+import org.testng.AssertJUnit;\n+\n+/**\n+ * This test is to verify matching behavior to the RI from the following implementation change\n+ * discussed in the Java 14 release notes:\n+ * \n+ * \"The specification for java.lang.Thread::interrupt allows for an implementation to only track the \n+ * interrupt state for live threads, and previously this is what occurred. As of this release, the \n+ * interrupt state of a Thread is always available, and if you interrupt a thread t before it is started, \n+ * or after it has terminated, the query t.isInterrupted() will return true.\"\n+ */\n+\n+@Test(groups = { \"level.sanity\" })\n+public class Test_Thread {\n+\n+    /* interrupt thread after it has ended */\n+    @Test\n+    public void test_interruptAfterRun() throws Throwable {\n+        String name = \"interruptAfterRun: \";\n+        Thread t = new Thread();\n+\n+        /* run thread */\n+        t.start();\n+        t.join();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+        \n+        t.interrupt();\n+\n+        /* Verify that the thread was successfully interrupted. */\n+        AssertJUnit.assertTrue(name + \"thread that has ended was was interrupted\", t.isInterrupted());    \n+    }\n+\n+    /* Verify that thread was sucessfully interrupted before it is started, and that the interrupt flag is \n+     * still set after it is run. */\n+    @Test\n+    public void test_interruptAtStartSetAfterRun() throws Throwable {\n+        String name = \"interruptAtStartSetAfterRun: \";\n+        Thread t = new Thread();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+        t.interrupt();\n+\n+        /* Verify that the thread was successfully interrupted. */\n+        AssertJUnit.assertTrue(name + \"thread that has not started should have interrupt flag set\", t.isInterrupted());\n+\n+        /* run thread */\n+        t.start();\n+        t.join();\n+\n+        /* Verify thread is dead and has not been interrupted */", "originalCommit": "f926cc1b1c5176688b72ec10dcba320e7e18d2e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0MjA1OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r421042058", "body": "I like this approach.  Can you confirm that the thread is \"isAlive\" at this point?  Otherwise the interrupted() call will return the previous setting of `deadInterrupt`.", "bodyText": "I like this approach.  Can you confirm that the thread is \"isAlive\" at this point?  Otherwise the interrupted() call will return the previous setting of deadInterrupt.", "bodyHTML": "<p dir=\"auto\">I like this approach.  Can you confirm that the thread is \"isAlive\" at this point?  Otherwise the interrupted() call will return the previous setting of <code>deadInterrupt</code>.</p>", "author": "DanHeidinga", "createdAt": "2020-05-06T19:34:37Z", "path": "jcl/src/java.base/share/classes/java/lang/Thread.java", "diffHunk": "@@ -1525,6 +1551,11 @@ void uncaughtException(Throwable e) {\n  * @see J9VMInternals#threadCleanup()\n  */\n void cleanup() {\n+/*[IF Java14]*/\n+\t/* Refresh deadInterrupt value so it is accurate when vm thread is cleaned up. */\t\n+\tdeadInterrupt = interrupted();", "originalCommit": "f926cc1b1c5176688b72ec10dcba320e7e18d2e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA2MjM0NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r421062344", "bodyText": "The thread will still be considered alive at this point. isAlive will start to return false when threadRef is cleared: https://github.com/eclipse/openj9/blob/5a2386c150d3277d326c05224b206ef041ffbc73/jcl/src/java.base/share/classes/java/lang/Thread.java#L1545", "author": "theresa-m", "createdAt": "2020-05-06T20:11:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0MjA1OA=="}], "type": "inlineReview"}, {"oid": "d43bd50fd28e68ab5f1836291fc6083ebdac28c9", "url": "https://github.com/eclipse-openj9/openj9/commit/d43bd50fd28e68ab5f1836291fc6083ebdac28c9", "message": "Java 14: track interrupt state when thread is dead\n\n- A new private boolean is added to java.lang.Thread to track the interrupt state since a J9VMThread only exists when the thread is actually running. When a thread is started the interrupt state will be transferred from the deadInterrupt boolean to the J9VMThread and tracked in the vm. When the thread is cleaned up, the interrupt state will be transferred back to be tracked by the deadInterrupt boolean.\n- Update formatting for Java14AndUp test playlist\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-05-06T19:36:03Z", "type": "forcePushed"}, {"oid": "64f97efabbcf97a5f3fe54a7866319a4e7f0788c", "url": "https://github.com/eclipse-openj9/openj9/commit/64f97efabbcf97a5f3fe54a7866319a4e7f0788c", "message": "Java 14: track interrupt state when thread is dead\n\n- A new private boolean is added to java.lang.Thread to track the interrupt state since a J9VMThread only exists when the thread is actually running. When a thread is started the interrupt state will be transferred from the deadInterrupt boolean to the J9VMThread and tracked in the vm. When the thread is cleaned up, the interrupt state will be transferred back to be tracked by the deadInterrupt boolean.\n- Update formatting for Java14AndUp test playlist\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-05-06T20:04:35Z", "type": "commit"}, {"oid": "64f97efabbcf97a5f3fe54a7866319a4e7f0788c", "url": "https://github.com/eclipse-openj9/openj9/commit/64f97efabbcf97a5f3fe54a7866319a4e7f0788c", "message": "Java 14: track interrupt state when thread is dead\n\n- A new private boolean is added to java.lang.Thread to track the interrupt state since a J9VMThread only exists when the thread is actually running. When a thread is started the interrupt state will be transferred from the deadInterrupt boolean to the J9VMThread and tracked in the vm. When the thread is cleaned up, the interrupt state will be transferred back to be tracked by the deadInterrupt boolean.\n- Update formatting for Java14AndUp test playlist\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-05-06T20:04:35Z", "type": "forcePushed"}]}