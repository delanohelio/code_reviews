{"pr_number": 8230, "pr_title": "Fix Class.getMethod() and Class.getMethods() missing cases", "pr_author": "theresa-m", "pr_createdAt": "2020-01-07T21:54:00Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/8230", "timeline": [{"oid": "4901aa8880abf63122a4de12e76d48ab782cca88", "url": "https://github.com/eclipse-openj9/openj9/commit/4901aa8880abf63122a4de12e76d48ab782cca88", "message": "Search all superinterfaces with base interfaces\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-01-08T16:27:52Z", "type": "forcePushed"}, {"oid": "8bf4dc691e37ba4c7cfc0ebe85f78e8c12736625", "url": "https://github.com/eclipse-openj9/openj9/commit/8bf4dc691e37ba4c7cfc0ebe85f78e8c12736625", "message": "Search all superinterfaces with base interfaces\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-01-09T14:43:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2NzUzMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r366467531", "body": "Is the check `this != Object.class` necessary?", "bodyText": "Is the check this != Object.class necessary?", "bodyHTML": "<p dir=\"auto\">Is the check <code>this != Object.class</code> necessary?</p>", "author": "JasonFengJ9", "createdAt": "2020-01-14T17:17:03Z", "path": "jcl/src/java.base/share/classes/java/lang/Class.java", "diffHunk": "@@ -1488,13 +1489,33 @@ Method getMethodHelper(\n \t\t\treturn null;\n \t\t}\n \t}\n-\tresult = forDeclaredMethod ? getDeclaredMethodImpl(name, parameterTypes, strSig, null) : getMethodImpl(name, parameterTypes, strSig);\n+\t\n+\tif (forDeclaredMethod) {\n+\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n+\t} else {\n+\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n+\t\t * Note: there is no need do so when the method is declared by the current class.\n+\t\t */\n+\t\tif ((result != null) && result.getDeclaringClass().isInterface() && (this != Object.class)) {", "originalCommit": "8bf4dc691e37ba4c7cfc0ebe85f78e8c12736625", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ4OTk5Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r367489992", "bodyText": "I believe this is referring to the javadoc line:\n\nIf C is a class other than Object, then include the result of invoking this algorithm recursively on the superclass of C.\n\nThough in practice I think it may not be needed. @ChengJin01 do you have any insights to this from your testing?", "author": "theresa-m", "createdAt": "2020-01-16T15:40:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2NzUzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUwNTI3OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r367505278", "bodyText": "It looks like this check is also done https://github.com/eclipse/openj9/blob/8bf4dc691e37ba4c7cfc0ebe85f78e8c12736625/jcl/src/java.base/share/classes/java/lang/Class.java#L1594 so its not necessary to do it twice.", "author": "theresa-m", "createdAt": "2020-01-16T16:04:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2NzUzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUxMDE2OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r367510168", "bodyText": "@theresa-m, Object.class should be excluded in the search of superclass in any case. Please modify accordingly if any duplicate and verify the update with all tests.", "author": "ChengJin01", "createdAt": "2020-01-16T16:12:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2NzUzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "7eedaee3f27228e8837b6490e809b2895035c718", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex b727e8bd6..240483293 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1493,19 +1493,19 @@ Method getMethodHelper(\n \tif (forDeclaredMethod) {\n \t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n \t} else {\n-\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n-\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n-\t\t * Note: there is no need do so when the method is declared by the current class.\n-\t\t */\n-\t\tif ((result != null) && result.getDeclaringClass().isInterface() && (this != Object.class)) {\n-\t\t\tif (!this.isInterface()) {\n-\t\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, interfaceSet, name, strSig, parameterTypes);\n-\t\t\t\tcandidateFromInteface = true;\n-\t\t\t} else if (result.getDeclaringClass() != this) { /* only applies if resulting class is not the base class */\n-\t\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, interfaceSet, null, name, strSig, parameterTypes);\n-\t\t\t\tcandidateFromInteface = true;\n+\t\tif (this.isInterface()) {\n+\t\t\t/* if the result is not in the current class, all superinterfaces will need to be searched */\n+\t\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n+\t\t\tif (null == result) {\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, name, strSig, parameterTypes);\n+\t\t\t\tcandidateFromInterface = true;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n+\t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, name, strSig, parameterTypes);\n+\t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t}\n \t}\n", "next_change": {"commit": "0715f9f8f7a3b2920884c427409dff8877a64373", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex 240483293..393d89e26 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1497,14 +1497,14 @@ Method getMethodHelper(\n \t\t\t/* if the result is not in the current class, all superinterfaces will need to be searched */\n \t\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n \t\t\tif (null == result) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, name, strSig, parameterTypes);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t} else {\n \t\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n \t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n \t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, name, strSig, parameterTypes);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t}\n", "next_change": {"commit": "bbc2ff27a563388dd938aa3e7391d367fed07c36", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex 393d89e26..cdfbf8342 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1497,14 +1497,15 @@ Method getMethodHelper(\n \t\t\t/* if the result is not in the current class, all superinterfaces will need to be searched */\n \t\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n \t\t\tif (null == result) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, name, parameterTypes);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, null, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t} else {\n \t\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n \t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n \t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, name, parameterTypes);\n+\t\t\t\tHashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache = new HashMap<>(16);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, infoCache, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t}\n", "next_change": {"commit": "b09b8df1b275eb94e149adf9805c810c72cc95e1", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex cdfbf8342..3f8f99f49 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1505,7 +1505,7 @@ Method getMethodHelper(\n \t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n \t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n \t\t\t\tHashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache = new HashMap<>(16);\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, infoCache, name, parameterTypes);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(infoCache, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t}\n", "next_change": {"commit": "57ec2470aba0d567200e7754f76d4fed5b4110d3", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex 3f8f99f49..ce9664213 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1493,21 +1497,16 @@ Method getMethodHelper(\n \tif (forDeclaredMethod) {\n \t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n \t} else {\n-\t\tif (this.isInterface()) {\n-\t\t\t/* if the result is not in the current class, all superinterfaces will need to be searched */\n-\t\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n-\t\t\tif (null == result) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(null, null, name, parameterTypes);\n-\t\t\t\tcandidateFromInterface = true;\n-\t\t\t}\n-\t\t} else {\n-\t\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n-\t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n-\t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n-\t\t\t\tHashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache = new HashMap<>(16);\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(infoCache, name, parameterTypes);\n-\t\t\t\tcandidateFromInterface = true;\n-\t\t\t}\n+\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n+\t\t * Note: there is no need do so when the method is declared by the current class.\n+\t\t */\n+\t\tif ((result != null) && result.getDeclaringClass().isInterface()\n+\t\t\t&& !this.isInterface() && (this != Object.class)\n+\t\t) {\n+\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n+\t\t\tresult = getMostSpecificMethodFromAllInterfaces(this, interfaceSet, name, strSig, parameterTypes);\n+\t\t\tcandidateFromInteface = true;\n \t\t}\n \t}\n \t\n", "next_change": {"commit": "ce60704e9678db4056d8afe08c13d3a02d554df0", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex ce9664213..815f76604 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1497,16 +1497,20 @@ Method getMethodHelper(\n \tif (forDeclaredMethod) {\n \t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n \t} else {\n-\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n-\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n-\t\t * Note: there is no need do so when the method is declared by the current class.\n-\t\t */\n-\t\tif ((result != null) && result.getDeclaringClass().isInterface()\n-\t\t\t&& !this.isInterface() && (this != Object.class)\n-\t\t) {\n-\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n-\t\t\tresult = getMostSpecificMethodFromAllInterfaces(this, interfaceSet, name, strSig, parameterTypes);\n-\t\t\tcandidateFromInteface = true;\n+\t\tif (this.isInterface()) {\n+\t\t\t/* if the result is not in the current class, all superinterfaces will need to be searched */\n+\t\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n+\t\t\tif (null == result) {\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, name, parameterTypes);\n+\t\t\t\tcandidateFromInterface = true;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n+\t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, name, parameterTypes);\n+\t\t\t\tcandidateFromInterface = true;\n+\t\t\t}\n \t\t}\n \t}\n \t\n", "next_change": {"commit": "2d998299562752395d25a9a94f1f5c3721ff3906", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex 815f76604..aa344ec80 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1501,14 +1501,15 @@ Method getMethodHelper(\n \t\t\t/* if the result is not in the current class, all superinterfaces will need to be searched */\n \t\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n \t\t\tif (null == result) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, name, parameterTypes);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(null, null, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t} else {\n \t\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n \t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n \t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, name, parameterTypes);\n+\t\t\t\tHashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache = new HashMap<>(16);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(infoCache, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t}\n", "next_change": null}]}}, {"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex ce9664213..815f76604 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1515,7 +1519,7 @@ Method getMethodHelper(\n \t}\n \tif (0 == Reflection.filterMethods(this, new Method[] {result}).length) {\n \t\treturn throwExceptionOrReturnNull(throwException, name, parameterTypes);\n-\t}\n+\t}\t\n \n \t/*[PR 127079] Use declaring classloader for Methods */\n \t/*[PR CMVC 104523] ensure parameter types are visible in the receiver's class loader */\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2ODQzOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r366468438", "body": "It appears this method is going to repeat `getMethodImpl(name, parameterTypes, strSig)` regardless of other conditions which is not desirable.", "bodyText": "It appears this method is going to repeat getMethodImpl(name, parameterTypes, strSig) regardless of other conditions which is not desirable.", "bodyHTML": "<p dir=\"auto\">It appears this method is going to repeat <code>getMethodImpl(name, parameterTypes, strSig)</code> regardless of other conditions which is not desirable.</p>", "author": "JasonFengJ9", "createdAt": "2020-01-14T17:19:03Z", "path": "jcl/src/java.base/share/classes/java/lang/Class.java", "diffHunk": "@@ -1488,13 +1489,33 @@ Method getMethodHelper(\n \t\t\treturn null;\n \t\t}\n \t}\n-\tresult = forDeclaredMethod ? getDeclaredMethodImpl(name, parameterTypes, strSig, null) : getMethodImpl(name, parameterTypes, strSig);\n+\t\n+\tif (forDeclaredMethod) {\n+\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n+\t} else {\n+\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n+\t\t * Note: there is no need do so when the method is declared by the current class.\n+\t\t */\n+\t\tif ((result != null) && result.getDeclaringClass().isInterface() && (this != Object.class)) {\n+\t\t\tif (!this.isInterface()) {\n+\t\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, interfaceSet, name, strSig, parameterTypes);", "originalCommit": "8bf4dc691e37ba4c7cfc0ebe85f78e8c12736625", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ5OTI4Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r367499286", "bodyText": "Yes good catch. I can rearrange that to prevent duplicate calls.", "author": "theresa-m", "createdAt": "2020-01-16T15:55:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2ODQzOA=="}], "type": "inlineReview", "revised_code": {"commit": "7eedaee3f27228e8837b6490e809b2895035c718", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex b727e8bd6..240483293 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1493,19 +1493,19 @@ Method getMethodHelper(\n \tif (forDeclaredMethod) {\n \t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n \t} else {\n-\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n-\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n-\t\t * Note: there is no need do so when the method is declared by the current class.\n-\t\t */\n-\t\tif ((result != null) && result.getDeclaringClass().isInterface() && (this != Object.class)) {\n-\t\t\tif (!this.isInterface()) {\n-\t\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, interfaceSet, name, strSig, parameterTypes);\n-\t\t\t\tcandidateFromInteface = true;\n-\t\t\t} else if (result.getDeclaringClass() != this) { /* only applies if resulting class is not the base class */\n-\t\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, interfaceSet, null, name, strSig, parameterTypes);\n-\t\t\t\tcandidateFromInteface = true;\n+\t\tif (this.isInterface()) {\n+\t\t\t/* if the result is not in the current class, all superinterfaces will need to be searched */\n+\t\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n+\t\t\tif (null == result) {\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, name, strSig, parameterTypes);\n+\t\t\t\tcandidateFromInterface = true;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n+\t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, name, strSig, parameterTypes);\n+\t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t}\n \t}\n", "next_change": {"commit": "0715f9f8f7a3b2920884c427409dff8877a64373", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex 240483293..393d89e26 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1497,14 +1497,14 @@ Method getMethodHelper(\n \t\t\t/* if the result is not in the current class, all superinterfaces will need to be searched */\n \t\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n \t\t\tif (null == result) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, name, strSig, parameterTypes);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t} else {\n \t\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n \t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n \t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, name, strSig, parameterTypes);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t}\n", "next_change": {"commit": "bbc2ff27a563388dd938aa3e7391d367fed07c36", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex 393d89e26..cdfbf8342 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1497,14 +1497,15 @@ Method getMethodHelper(\n \t\t\t/* if the result is not in the current class, all superinterfaces will need to be searched */\n \t\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n \t\t\tif (null == result) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, name, parameterTypes);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, null, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t} else {\n \t\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n \t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n \t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, name, parameterTypes);\n+\t\t\t\tHashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache = new HashMap<>(16);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, infoCache, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t}\n", "next_change": {"commit": "b09b8df1b275eb94e149adf9805c810c72cc95e1", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex cdfbf8342..3f8f99f49 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1505,7 +1505,7 @@ Method getMethodHelper(\n \t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n \t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n \t\t\t\tHashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache = new HashMap<>(16);\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, infoCache, name, parameterTypes);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(infoCache, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t}\n", "next_change": {"commit": "57ec2470aba0d567200e7754f76d4fed5b4110d3", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex 3f8f99f49..ce9664213 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1493,21 +1497,16 @@ Method getMethodHelper(\n \tif (forDeclaredMethod) {\n \t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n \t} else {\n-\t\tif (this.isInterface()) {\n-\t\t\t/* if the result is not in the current class, all superinterfaces will need to be searched */\n-\t\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n-\t\t\tif (null == result) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(null, null, name, parameterTypes);\n-\t\t\t\tcandidateFromInterface = true;\n-\t\t\t}\n-\t\t} else {\n-\t\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n-\t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n-\t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n-\t\t\t\tHashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache = new HashMap<>(16);\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(infoCache, name, parameterTypes);\n-\t\t\t\tcandidateFromInterface = true;\n-\t\t\t}\n+\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n+\t\t * Note: there is no need do so when the method is declared by the current class.\n+\t\t */\n+\t\tif ((result != null) && result.getDeclaringClass().isInterface()\n+\t\t\t&& !this.isInterface() && (this != Object.class)\n+\t\t) {\n+\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n+\t\t\tresult = getMostSpecificMethodFromAllInterfaces(this, interfaceSet, name, strSig, parameterTypes);\n+\t\t\tcandidateFromInteface = true;\n \t\t}\n \t}\n \t\n", "next_change": {"commit": "ce60704e9678db4056d8afe08c13d3a02d554df0", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex ce9664213..815f76604 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1497,16 +1497,20 @@ Method getMethodHelper(\n \tif (forDeclaredMethod) {\n \t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n \t} else {\n-\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n-\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n-\t\t * Note: there is no need do so when the method is declared by the current class.\n-\t\t */\n-\t\tif ((result != null) && result.getDeclaringClass().isInterface()\n-\t\t\t&& !this.isInterface() && (this != Object.class)\n-\t\t) {\n-\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n-\t\t\tresult = getMostSpecificMethodFromAllInterfaces(this, interfaceSet, name, strSig, parameterTypes);\n-\t\t\tcandidateFromInteface = true;\n+\t\tif (this.isInterface()) {\n+\t\t\t/* if the result is not in the current class, all superinterfaces will need to be searched */\n+\t\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n+\t\t\tif (null == result) {\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, name, parameterTypes);\n+\t\t\t\tcandidateFromInterface = true;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n+\t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, name, parameterTypes);\n+\t\t\t\tcandidateFromInterface = true;\n+\t\t\t}\n \t\t}\n \t}\n \t\n", "next_change": {"commit": "2d998299562752395d25a9a94f1f5c3721ff3906", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex 815f76604..aa344ec80 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1501,14 +1501,15 @@ Method getMethodHelper(\n \t\t\t/* if the result is not in the current class, all superinterfaces will need to be searched */\n \t\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n \t\t\tif (null == result) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, name, parameterTypes);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(null, null, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t} else {\n \t\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n \t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n \t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, name, parameterTypes);\n+\t\t\t\tHashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache = new HashMap<>(16);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(infoCache, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t}\n", "next_change": null}]}}, {"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex ce9664213..815f76604 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1515,7 +1519,7 @@ Method getMethodHelper(\n \t}\n \tif (0 == Reflection.filterMethods(this, new Method[] {result}).length) {\n \t\treturn throwExceptionOrReturnNull(throwException, name, parameterTypes);\n-\t}\n+\t}\t\n \n \t/*[PR 127079] Use declaring classloader for Methods */\n \t/*[PR CMVC 104523] ensure parameter types are visible in the receiver's class loader */\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2OTEyMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r366469122", "body": "This method might return `null` while initial `result` isn't, this doesn't seem right.", "bodyText": "This method might return null while initial result isn't, this doesn't seem right.", "bodyHTML": "<p dir=\"auto\">This method might return <code>null</code> while initial <code>result</code> isn't, this doesn't seem right.</p>", "author": "JasonFengJ9", "createdAt": "2020-01-14T17:20:29Z", "path": "jcl/src/java.base/share/classes/java/lang/Class.java", "diffHunk": "@@ -1488,13 +1489,33 @@ Method getMethodHelper(\n \t\t\treturn null;\n \t\t}\n \t}\n-\tresult = forDeclaredMethod ? getDeclaredMethodImpl(name, parameterTypes, strSig, null) : getMethodImpl(name, parameterTypes, strSig);\n+\t\n+\tif (forDeclaredMethod) {\n+\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n+\t} else {\n+\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n+\t\t * Note: there is no need do so when the method is declared by the current class.\n+\t\t */\n+\t\tif ((result != null) && result.getDeclaringClass().isInterface() && (this != Object.class)) {\n+\t\t\tif (!this.isInterface()) {\n+\t\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, interfaceSet, name, strSig, parameterTypes);\n+\t\t\t\tcandidateFromInteface = true;\n+\t\t\t} else if (result.getDeclaringClass() != this) { /* only applies if resulting class is not the base class */\n+\t\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, interfaceSet, null, name, strSig, parameterTypes);", "originalCommit": "8bf4dc691e37ba4c7cfc0ebe85f78e8c12736625", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7eedaee3f27228e8837b6490e809b2895035c718", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex b727e8bd6..240483293 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1493,19 +1493,19 @@ Method getMethodHelper(\n \tif (forDeclaredMethod) {\n \t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n \t} else {\n-\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n-\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n-\t\t * Note: there is no need do so when the method is declared by the current class.\n-\t\t */\n-\t\tif ((result != null) && result.getDeclaringClass().isInterface() && (this != Object.class)) {\n-\t\t\tif (!this.isInterface()) {\n-\t\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, interfaceSet, name, strSig, parameterTypes);\n-\t\t\t\tcandidateFromInteface = true;\n-\t\t\t} else if (result.getDeclaringClass() != this) { /* only applies if resulting class is not the base class */\n-\t\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, interfaceSet, null, name, strSig, parameterTypes);\n-\t\t\t\tcandidateFromInteface = true;\n+\t\tif (this.isInterface()) {\n+\t\t\t/* if the result is not in the current class, all superinterfaces will need to be searched */\n+\t\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n+\t\t\tif (null == result) {\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, name, strSig, parameterTypes);\n+\t\t\t\tcandidateFromInterface = true;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n+\t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, name, strSig, parameterTypes);\n+\t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t}\n \t}\n", "next_change": {"commit": "0715f9f8f7a3b2920884c427409dff8877a64373", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex 240483293..393d89e26 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1497,14 +1497,14 @@ Method getMethodHelper(\n \t\t\t/* if the result is not in the current class, all superinterfaces will need to be searched */\n \t\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n \t\t\tif (null == result) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, name, strSig, parameterTypes);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t} else {\n \t\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n \t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n \t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, name, strSig, parameterTypes);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t}\n", "next_change": {"commit": "bbc2ff27a563388dd938aa3e7391d367fed07c36", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex 393d89e26..cdfbf8342 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1497,14 +1497,15 @@ Method getMethodHelper(\n \t\t\t/* if the result is not in the current class, all superinterfaces will need to be searched */\n \t\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n \t\t\tif (null == result) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, name, parameterTypes);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, null, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t} else {\n \t\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n \t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n \t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, name, parameterTypes);\n+\t\t\t\tHashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache = new HashMap<>(16);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, infoCache, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t}\n", "next_change": {"commit": "b09b8df1b275eb94e149adf9805c810c72cc95e1", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex cdfbf8342..3f8f99f49 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1505,7 +1505,7 @@ Method getMethodHelper(\n \t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n \t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n \t\t\t\tHashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache = new HashMap<>(16);\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, infoCache, name, parameterTypes);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(infoCache, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t}\n", "next_change": {"commit": "57ec2470aba0d567200e7754f76d4fed5b4110d3", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex 3f8f99f49..ce9664213 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1493,21 +1497,16 @@ Method getMethodHelper(\n \tif (forDeclaredMethod) {\n \t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n \t} else {\n-\t\tif (this.isInterface()) {\n-\t\t\t/* if the result is not in the current class, all superinterfaces will need to be searched */\n-\t\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n-\t\t\tif (null == result) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(null, null, name, parameterTypes);\n-\t\t\t\tcandidateFromInterface = true;\n-\t\t\t}\n-\t\t} else {\n-\t\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n-\t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n-\t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n-\t\t\t\tHashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache = new HashMap<>(16);\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(infoCache, name, parameterTypes);\n-\t\t\t\tcandidateFromInterface = true;\n-\t\t\t}\n+\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n+\t\t * Note: there is no need do so when the method is declared by the current class.\n+\t\t */\n+\t\tif ((result != null) && result.getDeclaringClass().isInterface()\n+\t\t\t&& !this.isInterface() && (this != Object.class)\n+\t\t) {\n+\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n+\t\t\tresult = getMostSpecificMethodFromAllInterfaces(this, interfaceSet, name, strSig, parameterTypes);\n+\t\t\tcandidateFromInteface = true;\n \t\t}\n \t}\n \t\n", "next_change": {"commit": "ce60704e9678db4056d8afe08c13d3a02d554df0", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex ce9664213..815f76604 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1497,16 +1497,20 @@ Method getMethodHelper(\n \tif (forDeclaredMethod) {\n \t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n \t} else {\n-\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n-\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n-\t\t * Note: there is no need do so when the method is declared by the current class.\n-\t\t */\n-\t\tif ((result != null) && result.getDeclaringClass().isInterface()\n-\t\t\t&& !this.isInterface() && (this != Object.class)\n-\t\t) {\n-\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n-\t\t\tresult = getMostSpecificMethodFromAllInterfaces(this, interfaceSet, name, strSig, parameterTypes);\n-\t\t\tcandidateFromInteface = true;\n+\t\tif (this.isInterface()) {\n+\t\t\t/* if the result is not in the current class, all superinterfaces will need to be searched */\n+\t\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n+\t\t\tif (null == result) {\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, name, parameterTypes);\n+\t\t\t\tcandidateFromInterface = true;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n+\t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, name, parameterTypes);\n+\t\t\t\tcandidateFromInterface = true;\n+\t\t\t}\n \t\t}\n \t}\n \t\n", "next_change": {"commit": "2d998299562752395d25a9a94f1f5c3721ff3906", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex 815f76604..aa344ec80 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1501,14 +1501,15 @@ Method getMethodHelper(\n \t\t\t/* if the result is not in the current class, all superinterfaces will need to be searched */\n \t\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n \t\t\tif (null == result) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, name, parameterTypes);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(null, null, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t} else {\n \t\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n \t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n \t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, name, parameterTypes);\n+\t\t\t\tHashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache = new HashMap<>(16);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(infoCache, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t}\n", "next_change": null}]}}, {"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex ce9664213..815f76604 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1515,7 +1519,7 @@ Method getMethodHelper(\n \t}\n \tif (0 == Reflection.filterMethods(this, new Method[] {result}).length) {\n \t\treturn throwExceptionOrReturnNull(throwException, name, parameterTypes);\n-\t}\n+\t}\t\n \n \t/*[PR 127079] Use declaring classloader for Methods */\n \t/*[PR CMVC 104523] ensure parameter types are visible in the receiver's class loader */\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2OTg1OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r366469858", "body": "Any particular reason to create `new HashSet()` without actual usage after the following method call?", "bodyText": "Any particular reason to create new HashSet() without actual usage after the following method call?", "bodyHTML": "<p dir=\"auto\">Any particular reason to create <code>new HashSet()</code> without actual usage after the following method call?</p>", "author": "JasonFengJ9", "createdAt": "2020-01-14T17:22:06Z", "path": "jcl/src/java.base/share/classes/java/lang/Class.java", "diffHunk": "@@ -1488,13 +1489,33 @@ Method getMethodHelper(\n \t\t\treturn null;\n \t\t}\n \t}\n-\tresult = forDeclaredMethod ? getDeclaredMethodImpl(name, parameterTypes, strSig, null) : getMethodImpl(name, parameterTypes, strSig);\n+\t\n+\tif (forDeclaredMethod) {\n+\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n+\t} else {\n+\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n+\t\t * Note: there is no need do so when the method is declared by the current class.\n+\t\t */\n+\t\tif ((result != null) && result.getDeclaringClass().isInterface() && (this != Object.class)) {\n+\t\t\tif (!this.isInterface()) {\n+\t\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();", "originalCommit": "8bf4dc691e37ba4c7cfc0ebe85f78e8c12736625", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ5NzU5NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r367497595", "bodyText": "If an interface inherits the same superinterface more than once somewhere in its hierarchy the HashSet will save some native calls.\nexample:\ninterface Y extends X {void m() {}}\ninterface Z extends X, Y {}\n\nX will only be searched once. this example is trivial but if X had many superinterfaces it would show an impact.", "author": "theresa-m", "createdAt": "2020-01-16T15:52:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2OTg1OA=="}], "type": "inlineReview", "revised_code": {"commit": "7eedaee3f27228e8837b6490e809b2895035c718", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex b727e8bd6..240483293 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1493,19 +1493,19 @@ Method getMethodHelper(\n \tif (forDeclaredMethod) {\n \t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n \t} else {\n-\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n-\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n-\t\t * Note: there is no need do so when the method is declared by the current class.\n-\t\t */\n-\t\tif ((result != null) && result.getDeclaringClass().isInterface() && (this != Object.class)) {\n-\t\t\tif (!this.isInterface()) {\n-\t\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, interfaceSet, name, strSig, parameterTypes);\n-\t\t\t\tcandidateFromInteface = true;\n-\t\t\t} else if (result.getDeclaringClass() != this) { /* only applies if resulting class is not the base class */\n-\t\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, interfaceSet, null, name, strSig, parameterTypes);\n-\t\t\t\tcandidateFromInteface = true;\n+\t\tif (this.isInterface()) {\n+\t\t\t/* if the result is not in the current class, all superinterfaces will need to be searched */\n+\t\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n+\t\t\tif (null == result) {\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, name, strSig, parameterTypes);\n+\t\t\t\tcandidateFromInterface = true;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n+\t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, name, strSig, parameterTypes);\n+\t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t}\n \t}\n", "next_change": {"commit": "0715f9f8f7a3b2920884c427409dff8877a64373", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex 240483293..393d89e26 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1497,14 +1497,14 @@ Method getMethodHelper(\n \t\t\t/* if the result is not in the current class, all superinterfaces will need to be searched */\n \t\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n \t\t\tif (null == result) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, name, strSig, parameterTypes);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t} else {\n \t\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n \t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n \t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, name, strSig, parameterTypes);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t}\n", "next_change": {"commit": "bbc2ff27a563388dd938aa3e7391d367fed07c36", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex 393d89e26..cdfbf8342 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1497,14 +1497,15 @@ Method getMethodHelper(\n \t\t\t/* if the result is not in the current class, all superinterfaces will need to be searched */\n \t\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n \t\t\tif (null == result) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, name, parameterTypes);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, null, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t} else {\n \t\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n \t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n \t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, name, parameterTypes);\n+\t\t\t\tHashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache = new HashMap<>(16);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, infoCache, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t}\n", "next_change": {"commit": "b09b8df1b275eb94e149adf9805c810c72cc95e1", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex cdfbf8342..3f8f99f49 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1505,7 +1505,7 @@ Method getMethodHelper(\n \t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n \t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n \t\t\t\tHashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache = new HashMap<>(16);\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, infoCache, name, parameterTypes);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(infoCache, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t}\n", "next_change": {"commit": "57ec2470aba0d567200e7754f76d4fed5b4110d3", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex 3f8f99f49..ce9664213 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1493,21 +1497,16 @@ Method getMethodHelper(\n \tif (forDeclaredMethod) {\n \t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n \t} else {\n-\t\tif (this.isInterface()) {\n-\t\t\t/* if the result is not in the current class, all superinterfaces will need to be searched */\n-\t\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n-\t\t\tif (null == result) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(null, null, name, parameterTypes);\n-\t\t\t\tcandidateFromInterface = true;\n-\t\t\t}\n-\t\t} else {\n-\t\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n-\t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n-\t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n-\t\t\t\tHashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache = new HashMap<>(16);\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(infoCache, name, parameterTypes);\n-\t\t\t\tcandidateFromInterface = true;\n-\t\t\t}\n+\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n+\t\t * Note: there is no need do so when the method is declared by the current class.\n+\t\t */\n+\t\tif ((result != null) && result.getDeclaringClass().isInterface()\n+\t\t\t&& !this.isInterface() && (this != Object.class)\n+\t\t) {\n+\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n+\t\t\tresult = getMostSpecificMethodFromAllInterfaces(this, interfaceSet, name, strSig, parameterTypes);\n+\t\t\tcandidateFromInteface = true;\n \t\t}\n \t}\n \t\n", "next_change": {"commit": "ce60704e9678db4056d8afe08c13d3a02d554df0", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex ce9664213..815f76604 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1497,16 +1497,20 @@ Method getMethodHelper(\n \tif (forDeclaredMethod) {\n \t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n \t} else {\n-\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n-\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n-\t\t * Note: there is no need do so when the method is declared by the current class.\n-\t\t */\n-\t\tif ((result != null) && result.getDeclaringClass().isInterface()\n-\t\t\t&& !this.isInterface() && (this != Object.class)\n-\t\t) {\n-\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n-\t\t\tresult = getMostSpecificMethodFromAllInterfaces(this, interfaceSet, name, strSig, parameterTypes);\n-\t\t\tcandidateFromInteface = true;\n+\t\tif (this.isInterface()) {\n+\t\t\t/* if the result is not in the current class, all superinterfaces will need to be searched */\n+\t\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n+\t\t\tif (null == result) {\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, name, parameterTypes);\n+\t\t\t\tcandidateFromInterface = true;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n+\t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, name, parameterTypes);\n+\t\t\t\tcandidateFromInterface = true;\n+\t\t\t}\n \t\t}\n \t}\n \t\n", "next_change": {"commit": "2d998299562752395d25a9a94f1f5c3721ff3906", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex 815f76604..aa344ec80 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1501,14 +1501,15 @@ Method getMethodHelper(\n \t\t\t/* if the result is not in the current class, all superinterfaces will need to be searched */\n \t\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n \t\t\tif (null == result) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, name, parameterTypes);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(null, null, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t} else {\n \t\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n \t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n \t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, name, parameterTypes);\n+\t\t\t\tHashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache = new HashMap<>(16);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(infoCache, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t}\n", "next_change": null}]}}, {"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex ce9664213..815f76604 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1515,7 +1519,7 @@ Method getMethodHelper(\n \t}\n \tif (0 == Reflection.filterMethods(this, new Method[] {result}).length) {\n \t\treturn throwExceptionOrReturnNull(throwException, name, parameterTypes);\n-\t}\n+\t}\t\n \n \t/*[PR 127079] Use declaring classloader for Methods */\n \t/*[PR CMVC 104523] ensure parameter types are visible in the receiver's class loader */\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ3MDExOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r366470119", "body": "Similar comment about this `interfaceSet` as well.", "bodyText": "Similar comment about this interfaceSet as well.", "bodyHTML": "<p dir=\"auto\">Similar comment about this <code>interfaceSet</code> as well.</p>", "author": "JasonFengJ9", "createdAt": "2020-01-14T17:22:35Z", "path": "jcl/src/java.base/share/classes/java/lang/Class.java", "diffHunk": "@@ -1488,13 +1489,33 @@ Method getMethodHelper(\n \t\t\treturn null;\n \t\t}\n \t}\n-\tresult = forDeclaredMethod ? getDeclaredMethodImpl(name, parameterTypes, strSig, null) : getMethodImpl(name, parameterTypes, strSig);\n+\t\n+\tif (forDeclaredMethod) {\n+\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n+\t} else {\n+\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n+\t\t * Note: there is no need do so when the method is declared by the current class.\n+\t\t */\n+\t\tif ((result != null) && result.getDeclaringClass().isInterface() && (this != Object.class)) {\n+\t\t\tif (!this.isInterface()) {\n+\t\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, interfaceSet, name, strSig, parameterTypes);\n+\t\t\t\tcandidateFromInteface = true;\n+\t\t\t} else if (result.getDeclaringClass() != this) { /* only applies if resulting class is not the base class */\n+\t\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();", "originalCommit": "8bf4dc691e37ba4c7cfc0ebe85f78e8c12736625", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7eedaee3f27228e8837b6490e809b2895035c718", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex b727e8bd6..240483293 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1493,19 +1493,19 @@ Method getMethodHelper(\n \tif (forDeclaredMethod) {\n \t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n \t} else {\n-\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n-\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n-\t\t * Note: there is no need do so when the method is declared by the current class.\n-\t\t */\n-\t\tif ((result != null) && result.getDeclaringClass().isInterface() && (this != Object.class)) {\n-\t\t\tif (!this.isInterface()) {\n-\t\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, interfaceSet, name, strSig, parameterTypes);\n-\t\t\t\tcandidateFromInteface = true;\n-\t\t\t} else if (result.getDeclaringClass() != this) { /* only applies if resulting class is not the base class */\n-\t\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, interfaceSet, null, name, strSig, parameterTypes);\n-\t\t\t\tcandidateFromInteface = true;\n+\t\tif (this.isInterface()) {\n+\t\t\t/* if the result is not in the current class, all superinterfaces will need to be searched */\n+\t\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n+\t\t\tif (null == result) {\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, name, strSig, parameterTypes);\n+\t\t\t\tcandidateFromInterface = true;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n+\t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, name, strSig, parameterTypes);\n+\t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t}\n \t}\n", "next_change": {"commit": "0715f9f8f7a3b2920884c427409dff8877a64373", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex 240483293..393d89e26 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1497,14 +1497,14 @@ Method getMethodHelper(\n \t\t\t/* if the result is not in the current class, all superinterfaces will need to be searched */\n \t\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n \t\t\tif (null == result) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, name, strSig, parameterTypes);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t} else {\n \t\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n \t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n \t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, name, strSig, parameterTypes);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t}\n", "next_change": {"commit": "bbc2ff27a563388dd938aa3e7391d367fed07c36", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex 393d89e26..cdfbf8342 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1497,14 +1497,15 @@ Method getMethodHelper(\n \t\t\t/* if the result is not in the current class, all superinterfaces will need to be searched */\n \t\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n \t\t\tif (null == result) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, name, parameterTypes);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, null, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t} else {\n \t\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n \t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n \t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, name, parameterTypes);\n+\t\t\t\tHashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache = new HashMap<>(16);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, infoCache, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t}\n", "next_change": {"commit": "b09b8df1b275eb94e149adf9805c810c72cc95e1", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex cdfbf8342..3f8f99f49 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1505,7 +1505,7 @@ Method getMethodHelper(\n \t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n \t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n \t\t\t\tHashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache = new HashMap<>(16);\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, infoCache, name, parameterTypes);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(infoCache, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t}\n", "next_change": {"commit": "57ec2470aba0d567200e7754f76d4fed5b4110d3", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex 3f8f99f49..ce9664213 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1493,21 +1497,16 @@ Method getMethodHelper(\n \tif (forDeclaredMethod) {\n \t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n \t} else {\n-\t\tif (this.isInterface()) {\n-\t\t\t/* if the result is not in the current class, all superinterfaces will need to be searched */\n-\t\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n-\t\t\tif (null == result) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(null, null, name, parameterTypes);\n-\t\t\t\tcandidateFromInterface = true;\n-\t\t\t}\n-\t\t} else {\n-\t\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n-\t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n-\t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n-\t\t\t\tHashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache = new HashMap<>(16);\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(infoCache, name, parameterTypes);\n-\t\t\t\tcandidateFromInterface = true;\n-\t\t\t}\n+\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n+\t\t * Note: there is no need do so when the method is declared by the current class.\n+\t\t */\n+\t\tif ((result != null) && result.getDeclaringClass().isInterface()\n+\t\t\t&& !this.isInterface() && (this != Object.class)\n+\t\t) {\n+\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n+\t\t\tresult = getMostSpecificMethodFromAllInterfaces(this, interfaceSet, name, strSig, parameterTypes);\n+\t\t\tcandidateFromInteface = true;\n \t\t}\n \t}\n \t\n", "next_change": {"commit": "ce60704e9678db4056d8afe08c13d3a02d554df0", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex ce9664213..815f76604 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1497,16 +1497,20 @@ Method getMethodHelper(\n \tif (forDeclaredMethod) {\n \t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n \t} else {\n-\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n-\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n-\t\t * Note: there is no need do so when the method is declared by the current class.\n-\t\t */\n-\t\tif ((result != null) && result.getDeclaringClass().isInterface()\n-\t\t\t&& !this.isInterface() && (this != Object.class)\n-\t\t) {\n-\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n-\t\t\tresult = getMostSpecificMethodFromAllInterfaces(this, interfaceSet, name, strSig, parameterTypes);\n-\t\t\tcandidateFromInteface = true;\n+\t\tif (this.isInterface()) {\n+\t\t\t/* if the result is not in the current class, all superinterfaces will need to be searched */\n+\t\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n+\t\t\tif (null == result) {\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, name, parameterTypes);\n+\t\t\t\tcandidateFromInterface = true;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n+\t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, name, parameterTypes);\n+\t\t\t\tcandidateFromInterface = true;\n+\t\t\t}\n \t\t}\n \t}\n \t\n", "next_change": {"commit": "2d998299562752395d25a9a94f1f5c3721ff3906", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex 815f76604..aa344ec80 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1501,14 +1501,15 @@ Method getMethodHelper(\n \t\t\t/* if the result is not in the current class, all superinterfaces will need to be searched */\n \t\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n \t\t\tif (null == result) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, null, name, parameterTypes);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(null, null, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t} else {\n \t\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n \t\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom. */\n \t\t\tif ((result != null) && result.getDeclaringClass().isInterface()) {\n-\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, name, parameterTypes);\n+\t\t\t\tHashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache = new HashMap<>(16);\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(infoCache, name, parameterTypes);\n \t\t\t\tcandidateFromInterface = true;\n \t\t\t}\n \t\t}\n", "next_change": null}]}}, {"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex ce9664213..815f76604 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1515,7 +1519,7 @@ Method getMethodHelper(\n \t}\n \tif (0 == Reflection.filterMethods(this, new Method[] {result}).length) {\n \t\treturn throwExceptionOrReturnNull(throwException, name, parameterTypes);\n-\t}\n+\t}\t\n \n \t/*[PR 127079] Use declaring classloader for Methods */\n \t/*[PR CMVC 104523] ensure parameter types are visible in the receiver's class loader */\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"oid": "7eedaee3f27228e8837b6490e809b2895035c718", "url": "https://github.com/eclipse-openj9/openj9/commit/7eedaee3f27228e8837b6490e809b2895035c718", "message": "Search all superinterfaces with base interfaces\n\n- Class.getMethods jteg fixes, and make more similar to hotspot output\n- Class.getMethod interface search logic\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-01-29T14:57:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE3MDkxOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r374170918", "body": "`getMethods()` is going to be invoked for the superclasses from the top to the bottom, and the later invocations include the results of previous calls which seems an overkill.\r\ncan we modify `getMethodImpl(name, parameterTypes, strSig)` to introduce a `startingPoint`, particularly for the case that the method found is declared by an interface class?", "bodyText": "getMethods() is going to be invoked for the superclasses from the top to the bottom, and the later invocations include the results of previous calls which seems an overkill.\ncan we modify getMethodImpl(name, parameterTypes, strSig) to introduce a startingPoint, particularly for the case that the method found is declared by an interface class?", "bodyHTML": "<p dir=\"auto\"><code>getMethods()</code> is going to be invoked for the superclasses from the top to the bottom, and the later invocations include the results of previous calls which seems an overkill.<br>\ncan we modify <code>getMethodImpl(name, parameterTypes, strSig)</code> to introduce a <code>startingPoint</code>, particularly for the case that the method found is declared by an interface class?</p>", "author": "JasonFengJ9", "createdAt": "2020-02-03T15:34:11Z", "path": "jcl/src/java.base/share/classes/java/lang/Class.java", "diffHunk": "@@ -1530,26 +1551,127 @@ Method getMethodHelper(\n \t * Otherwise, the result method is chosen arbitrarily from specific methods.\n \t */\n \tbestCandidate = result;\n-\tClass<?> declaringClass = forDeclaredMethod ? this : result.getDeclaringClass();\n-\twhile (true) {\n-\t\tresult = declaringClass.getDeclaredMethodImpl(name, parameterTypes, strSig, result);\n-\t\tif (result == null) {\n-\t\t\tbreak;\n+\tif (!candidateFromInterface) {\n+\t\tClass<?> declaringClass = forDeclaredMethod ? this : result.getDeclaringClass();\n+\t\twhile (true) {\n+\t\t\tresult = declaringClass.getDeclaredMethodImpl(name, parameterTypes, strSig, result);\n+\t\t\tif (result == null) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tboolean publicMethod = ((result.getModifiers() & Modifier.PUBLIC) != 0);\n+\t\t\tif ((methodList != null) && publicMethod) {\n+\t\t\t\tmethodList.add(result);\n+\t\t\t}\n+\t\t\tif (forDeclaredMethod || publicMethod) {\n+\t\t\t\t// bestCandidate and result have same declaringClass.\n+\t\t\t\tClass<?> candidateRetType = bestCandidate.getReturnType();\n+\t\t\t\tClass<?> resultRetType = result.getReturnType();\n+\t\t\t\tif ((candidateRetType != resultRetType) && candidateRetType.isAssignableFrom(resultRetType)) {\n+\t\t\t\t\tbestCandidate = result;\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n-\t\tboolean publicMethod = ((result.getModifiers() & Modifier.PUBLIC) != 0);\n-\t\tif ((methodList != null) && publicMethod) {\n-\t\t\tmethodList.add(result);\n+\t}\n+\treturn cacheMethod(bestCandidate);\n+}\n+\n+/**\n+ * Helper method searches all interfaces implemented by superclasses from the top to the bottom\n+ * for the most specific method declared in one of these interfaces.\n+ *\n+ * @param currentClass the class to be searched, including the current class and all superclasses\n+ * @param name the specified method's name\n+ * @param strSig the string of the specified method's signature\n+ * @param parameterTypes the types of the arguments of the specified method\n+ * @return the most specific method selected from all interfaces from each superclass of the current class;\n+ *         otherwise, return the method of the first interface from the top superclass\n+ *         if the return types of all specified methods are identical.\n+ */\n+private static Method getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(Class<?> currentClass, String name, String strSig, Class<?>... parameterTypes) {\n+\tMethod candidateMethod = null;\n+\tif (currentClass != Object.class) {\n+\t\t/* get to the top superclass first. if all return types end up being the same the interfaces from this superclass have priority. */\n+\t\tcandidateMethod = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(currentClass.getSuperclass(), name, strSig, parameterTypes);\n+\t\t\n+\t\t/* search all interfaces of current class, comparing against result from previous superclass. */\n+\t\tcandidateMethod = getMostSpecificMethodFromAllInterfacesOfCurrentClass(currentClass, candidateMethod, name, strSig, parameterTypes);\n+\t}\n+\treturn candidateMethod;\n+}\n+\n+/**\n+ * Helper method searches all interfaces implemented by the current class or interface \n+ * for the most specific method declared in one of these interfaces.\n+ *\n+ * @param currentClass the class or interface to be searched\n+ * @param potentialCandidate potential candidate from superclass, null if currentClass is an interface\n+ * @param name the specified method's name\n+ * @param strSig the string of the specified method's signature\n+ * @param parameterTypes the types of the arguments of the specified method\n+ * @return the most specific method selected from all interfaces;\n+ *         otherwise if return types from all qualifying methods are identical, return an arbitrary method.\n+ */\n+private static Method getMostSpecificMethodFromAllInterfacesOfCurrentClass(Class<?> currentClass, Method potentialCandidate, String name, String strSig, Class<?>... parameterTypes) {\n+\tMethod bestMethod = potentialCandidate;\n+\tMethod[] methodCandidates = currentClass.getMethods();", "originalCommit": "7eedaee3f27228e8837b6490e809b2895035c718", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc1ODY1OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r374758658", "bodyText": "I agree that it is overkill.\nI think it would still be useful to take advantage of the getMethods helper functions for the sake of not duplicating code, and combining the logic was helpful in that I was able to improve correctness of getMethod and getMethods at the same time. I can limit the superclasses searches for this particular case.", "author": "theresa-m", "createdAt": "2020-02-04T15:56:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE3MDkxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc3NTgxNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r374775814", "bodyText": "Not against the idea. getMethods() just is a heavyweight api, can getMethodImpl & getDeclaredMethodImpl be used for the superclasses from the top to the bottom instead?\n\nimprove correctness of getMethod and getMethods at the same time\n\ngetMethod() calls getMethodHelper() which is being fixed by this PR.\ndoes getMethods() miss any method?", "author": "JasonFengJ9", "createdAt": "2020-02-04T16:22:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE3MDkxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4NzE3NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r374787174", "bodyText": "Not against the idea. getMethods() just is a heavyweight api, can getMethodImpl & getDeclaredMethodImpl be used for the superclasses from the top to the bottom instead?\n\nI think your idea of adding a startingPoint type variable to getMethodImpl would be a good solution as well.\nedit: Although I'm not sure it would be a simple native change since each call to getMethodImpl uses the entire interface list to determine which interface is the most valid match.\n\n\nimprove correctness of getMethod and getMethods at the same time\n\ngetMethod() calls getMethodHelper() which is being fixed by this PR.\ndoes getMethods() miss any method?\n\nThere is one case for getMethods being fixed here as well that was uncovered by one of the tests from #7623. Maybe that will explain more how that line of thinking came about too :) I will make that more obvious in the issue description.", "author": "theresa-m", "createdAt": "2020-02-04T16:40:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE3MDkxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkzNzM4OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r374937388", "bodyText": "@JasonFengJ9  I made some updates to this approach to tighten things up. getMostSpecificMethodFromAllInterfacesOfCurrentClass will now call getMethodSet directly, and then only search for interfaces and not classes. Let me know what you think.", "author": "theresa-m", "createdAt": "2020-02-04T21:38:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE3MDkxOA=="}], "type": "inlineReview", "revised_code": {"commit": "0715f9f8f7a3b2920884c427409dff8877a64373", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex 240483293..393d89e26 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1606,56 +1605,67 @@ private static Method getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(Cl\n  * @param currentClass the class or interface to be searched\n  * @param potentialCandidate potential candidate from superclass, null if currentClass is an interface\n  * @param name the specified method's name\n- * @param strSig the string of the specified method's signature\n  * @param parameterTypes the types of the arguments of the specified method\n  * @return the most specific method selected from all interfaces;\n  *         otherwise if return types from all qualifying methods are identical, return an arbitrary method.\n  */\n-private static Method getMostSpecificMethodFromAllInterfacesOfCurrentClass(Class<?> currentClass, Method potentialCandidate, String name, String strSig, Class<?>... parameterTypes) {\n+private Method getMostSpecificMethodFromAllInterfacesOfCurrentClass(Class<?> currentClass, Method potentialCandidate, String name, Class<?>... parameterTypes) {\n \tMethod bestMethod = potentialCandidate;\n-\tMethod[] methodCandidates = currentClass.getMethods();\n-\n-\tfor (int index = 0; index < methodCandidates.length; index++) {\n-\t\tMethod candidateMethod = methodCandidates[index];\n+\tHashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache = new HashMap<>(16);\n+\tHashMap<MethodInfo, MethodInfo> methodCandidates = getMethodSet(infoCache, false, true);\n \n-\t\tif (candidateMethod == potentialCandidate) {\n-\t\t\tcontinue;\n+\tfor (MethodInfo mi : methodCandidates.values()) {\n+\t\tif (null == mi.jlrMethods) {\n+\t\t\tbestMethod = getMostSpecificInterfaceMethod(name, parameterTypes, bestMethod, mi.me);\n+\t\t} else {\n+\t\t\tfor (Method m: mi.jlrMethods) {\n+\t\t\t\tbestMethod = getMostSpecificInterfaceMethod(name, parameterTypes, bestMethod, m);\n+\t\t\t}\n \t\t}\n+\t}\n \n-\t\t/* match name and parameters to user specification */\n-\t\tif (!candidateMethod.getDeclaringClass().isInterface() \n-\t\t\t|| !candidateMethod.getName().equals(name) \n-\t\t\t|| !doParameterTypesMatch(candidateMethod.getParameterTypes(), parameterTypes)\n-\t\t) {\n-\t\t\tcontinue;\n-\t\t}\n+\treturn bestMethod;\n+\n+}\n \n-\t\tif (null == bestMethod) {\n+private static Method getMostSpecificInterfaceMethod(String name, Class<?>[] parameterTypes, Method bestMethod, Method candidateMethod) {\n+\tif (candidateMethod == bestMethod) {\n+\t\treturn bestMethod;\n+\t}\n+\n+\t/* match name and parameters to user specification */\n+\tif (!candidateMethod.getDeclaringClass().isInterface() \n+\t\t|| !candidateMethod.getName().equals(name) \n+\t\t|| !doParameterTypesMatch(candidateMethod.getParameterTypes(), parameterTypes)\n+\t) {\n+\t\treturn bestMethod;\n+\t}\n+\n+\tif (null == bestMethod) {\n+\t\tbestMethod = candidateMethod;\n+\t\treturn bestMethod;\n+\t}\n+\n+\tClass<?> bestRetType = bestMethod.getReturnType();\n+\tClass<?> candidateRetType = candidateMethod.getReturnType();\n+\n+\tif (bestRetType == candidateRetType) {\n+\t\tint bestModifiers = bestMethod.getModifiers();\n+\t\tint candidateModifiers = candidateMethod.getModifiers();\n+\t\tClass<?> bestDeclaringClass = bestMethod.getDeclaringClass();\n+\t\tClass<?> candidateDeclaringClass = candidateMethod.getDeclaringClass();\n+\t\t/* if all return types end up being the same, non-static methods take priority over static methods and sub-interfaces take\n+\t\t\tpriority over superinterface */\n+\t\t\tif ((Modifier.isStatic(bestModifiers) && !Modifier.isStatic(candidateModifiers))\n+\t\t\t\t|| methodAOverridesMethodB(candidateDeclaringClass, Modifier.isAbstract(candidateModifiers), candidateDeclaringClass.isInterface(), \n+\t\t\t\tbestDeclaringClass, Modifier.isAbstract(bestModifiers), bestDeclaringClass.isInterface())\n+\t\t) {\n \t\t\tbestMethod = candidateMethod;\n-\t\t\tcontinue;\n \t\t}\n-\n-\t\tClass<?> bestRetType = bestMethod.getReturnType();\n-\t\tClass<?> candidateRetType = candidateMethod.getReturnType();\n-\n-\t\tif (bestRetType == candidateRetType) {\n-\t\t\tint bestModifiers = bestMethod.getModifiers();\n-\t\t\tint candidateModifiers = candidateMethod.getModifiers();\n-\t\t\tClass<?> bestDeclaringClass = bestMethod.getDeclaringClass();\n-\t\t\tClass<?> candidateDeclaringClass = candidateMethod.getDeclaringClass();\n-\t\t\t/* if all return types end up being the same, non-static methods take priority over static methods and sub-interfaces take\n-\t\t\t priority over superinterface */\n-\t\t\t if ((Modifier.isStatic(bestModifiers) && !Modifier.isStatic(candidateModifiers))\n-\t\t\t\t || methodAOverridesMethodB(candidateDeclaringClass, Modifier.isAbstract(candidateModifiers), candidateDeclaringClass.isInterface(), \n-\t\t\t\t bestDeclaringClass, Modifier.isAbstract(bestModifiers), bestDeclaringClass.isInterface())\n-\t\t\t) {\n-\t\t\t\tbestMethod = candidateMethod;\n-\t\t\t}\n-\t\t} else {\n-\t\t\t/* resulting method should have the most specific return type */\n-\t\t\tif (bestRetType.isAssignableFrom(candidateRetType)) {\n-\t\t\t\tbestMethod = candidateMethod;\n-\t\t\t}\n+\t} else {\n+\t\t/* resulting method should have the most specific return type */\n+\t\tif (bestRetType.isAssignableFrom(candidateRetType)) {\n+\t\t\tbestMethod = candidateMethod;\n \t\t}\n \t}\n \n", "next_change": {"commit": "57ec2470aba0d567200e7754f76d4fed5b4110d3", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex 393d89e26..ce9664213 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1580,108 +1580,83 @@ Method getMethodHelper(\n  * for the most specific method declared in one of these interfaces.\n  *\n  * @param currentClass the class to be searched, including the current class and all superclasses\n+ * @param interfaceSet the set of interfaces to be collected\n  * @param name the specified method's name\n+ * @param strSig the string of the specified method's signature\n  * @param parameterTypes the types of the arguments of the specified method\n- * @return the most specific method selected from all interfaces from each superclass of the current class;\n+ * @return the most specific method selected from all interfaces;\n  *         otherwise, return the method of the first interface from the top superclass\n  *         if the return types of all specified methods are identical.\n  */\n-private Method getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(Class<?> currentClass, String name, Class<?>... parameterTypes) {\n+private Method getMostSpecificMethodFromAllInterfaces(Class<?> currentClass, HashSet<Class<?>> interfaceSet, String name, String strSig, Class<?>... parameterTypes) {\n \tMethod candidateMethod = null;\n+\n \tif (currentClass != Object.class) {\n-\t\t/* get to the top superclass first. if all return types end up being the same the interfaces from this superclass have priority. */\n-\t\tcandidateMethod = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(currentClass.getSuperclass(), name, parameterTypes);\n+\t\tcandidateMethod = getMostSpecificMethodFromAllInterfaces(currentClass.getSuperclass(), \n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tinterfaceSet, name, strSig, parameterTypes);\n \t\t\n-\t\t/* search all interfaces of current class, comparing against result from previous superclass. */\n-\t\tcandidateMethod = getMostSpecificMethodFromAllInterfacesOfCurrentClass(currentClass, candidateMethod, name, parameterTypes);\n+\t\t/* getMethodImpl returns the specified method declared by an interface given that\n+\t\t * the current class has not yet implemented this method.\n+\t\t */\n+\t\tMethod resultFromInterface = currentClass.getMethodImpl(name, parameterTypes, strSig);\n+\t\tif (resultFromInterface != null) {\n+\t\t\tClass<?>[] interfacesFromCurrentClass = currentClass.getInterfaces();\n+\t\t\tfor (Class<?> nextInterface : interfacesFromCurrentClass) {\t\t\t\t\n+\t\t\t\t/* No need to search for the duplicate interface */\n+\t\t\t\tif (!interfaceSet.contains(nextInterface)) {\n+\t\t\t\t\tinterfaceSet.add(nextInterface);\n+\t\t\t\t\tMethod resultMethod = getMoreSpecificMethodFromInterface(nextInterface, name, strSig, parameterTypes);\n+\t\t\t\t\t\n+\t\t\t\t\tif (resultMethod != null) {\n+\t\t\t\t\t\tif (candidateMethod == null) {\n+\t\t\t\t\t\t\tcandidateMethod = resultMethod;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tClass<?> resultRetType = resultMethod.getReturnType();\n+\t\t\t\t\t\t\tClass<?> CandidateRetType = candidateMethod.getReturnType();\n+\t\t\t\t\t\t\tif ((CandidateRetType != resultRetType) && CandidateRetType.isAssignableFrom(resultRetType)) {\n+\t\t\t\t\t\t\t\tcandidateMethod = resultMethod;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t}\n+\t\n \treturn candidateMethod;\n }\n \n /**\n- * Helper method searches all interfaces implemented by the current class or interface \n- * for the most specific method declared in one of these interfaces.\n- *\n- * @param currentClass the class or interface to be searched\n- * @param potentialCandidate potential candidate from superclass, null if currentClass is an interface\n+ * Helper method obtains the more specific method declared in the interface\n+ * \n+ * @param currentInterface the interface that declares the specified method\n  * @param name the specified method's name\n+ * @param strSig the string of the specified method's signature\n  * @param parameterTypes the types of the arguments of the specified method\n- * @return the most specific method selected from all interfaces;\n- *         otherwise if return types from all qualifying methods are identical, return an arbitrary method.\n+ * @return the more specific method declared in this interface\n  */\n-private Method getMostSpecificMethodFromAllInterfacesOfCurrentClass(Class<?> currentClass, Method potentialCandidate, String name, Class<?>... parameterTypes) {\n-\tMethod bestMethod = potentialCandidate;\n-\tHashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache = new HashMap<>(16);\n-\tHashMap<MethodInfo, MethodInfo> methodCandidates = getMethodSet(infoCache, false, true);\n-\n-\tfor (MethodInfo mi : methodCandidates.values()) {\n-\t\tif (null == mi.jlrMethods) {\n-\t\t\tbestMethod = getMostSpecificInterfaceMethod(name, parameterTypes, bestMethod, mi.me);\n-\t\t} else {\n-\t\t\tfor (Method m: mi.jlrMethods) {\n-\t\t\t\tbestMethod = getMostSpecificInterfaceMethod(name, parameterTypes, bestMethod, m);\n+private Method getMoreSpecificMethodFromInterface(Class<?> currentInterface, String name, String strSig, Class<?>... parameterTypes) {\n+\tMethod resultMethod = currentInterface.getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n+\tMethod bestCandidate = resultMethod;\n+\t\n+\tif (resultMethod != null) {\n+\t\twhile (true) {\n+\t\t\tresultMethod = currentInterface.getDeclaredMethodImpl(name, parameterTypes, strSig, resultMethod);\n+\t\t\tif (resultMethod == null) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif ((resultMethod.getModifiers() & Modifier.PUBLIC) != 0) {\n+\t\t\t\t// bestCandidate and result have same declaringClass.\n+\t\t\t\tClass<?> bestCandidateRetType = bestCandidate.getReturnType();\n+\t\t\t\tClass<?> resultRetType = resultMethod.getReturnType();\n+\t\t\t\tif ((bestCandidateRetType != resultRetType) && bestCandidateRetType.isAssignableFrom(resultRetType)) {\n+\t\t\t\t\tbestCandidate = resultMethod;\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n \n-\treturn bestMethod;\n-\n-}\n-\n-private static Method getMostSpecificInterfaceMethod(String name, Class<?>[] parameterTypes, Method bestMethod, Method candidateMethod) {\n-\tif (candidateMethod == bestMethod) {\n-\t\treturn bestMethod;\n-\t}\n-\n-\t/* match name and parameters to user specification */\n-\tif (!candidateMethod.getDeclaringClass().isInterface() \n-\t\t|| !candidateMethod.getName().equals(name) \n-\t\t|| !doParameterTypesMatch(candidateMethod.getParameterTypes(), parameterTypes)\n-\t) {\n-\t\treturn bestMethod;\n-\t}\n-\n-\tif (null == bestMethod) {\n-\t\tbestMethod = candidateMethod;\n-\t\treturn bestMethod;\n-\t}\n-\n-\tClass<?> bestRetType = bestMethod.getReturnType();\n-\tClass<?> candidateRetType = candidateMethod.getReturnType();\n-\n-\tif (bestRetType == candidateRetType) {\n-\t\tint bestModifiers = bestMethod.getModifiers();\n-\t\tint candidateModifiers = candidateMethod.getModifiers();\n-\t\tClass<?> bestDeclaringClass = bestMethod.getDeclaringClass();\n-\t\tClass<?> candidateDeclaringClass = candidateMethod.getDeclaringClass();\n-\t\t/* if all return types end up being the same, non-static methods take priority over static methods and sub-interfaces take\n-\t\t\tpriority over superinterface */\n-\t\t\tif ((Modifier.isStatic(bestModifiers) && !Modifier.isStatic(candidateModifiers))\n-\t\t\t\t|| methodAOverridesMethodB(candidateDeclaringClass, Modifier.isAbstract(candidateModifiers), candidateDeclaringClass.isInterface(), \n-\t\t\t\tbestDeclaringClass, Modifier.isAbstract(bestModifiers), bestDeclaringClass.isInterface())\n-\t\t) {\n-\t\t\tbestMethod = candidateMethod;\n-\t\t}\n-\t} else {\n-\t\t/* resulting method should have the most specific return type */\n-\t\tif (bestRetType.isAssignableFrom(candidateRetType)) {\n-\t\t\tbestMethod = candidateMethod;\n-\t\t}\n-\t}\n-\n-\treturn bestMethod;\n-}\n-\n-private static boolean doParameterTypesMatch(Class<?>[] paramList1, Class<?>[] paramList2) {\n-\tif (paramList1.length != paramList2.length) return false;\n-\n-\tfor (int index = 0; index < paramList1.length; index++) {\n-\t\tif (!paramList1[index].equals(paramList2[index])) {\n-\t\t\treturn false;\n-\t\t}\n-\t}\n-\n-\treturn true;\n+\treturn bestCandidate;\n }\n \n /**\n", "next_change": {"commit": "ce60704e9678db4056d8afe08c13d3a02d554df0", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex ce9664213..815f76604 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1580,83 +1584,108 @@ Method getMethodHelper(\n  * for the most specific method declared in one of these interfaces.\n  *\n  * @param currentClass the class to be searched, including the current class and all superclasses\n- * @param interfaceSet the set of interfaces to be collected\n  * @param name the specified method's name\n- * @param strSig the string of the specified method's signature\n  * @param parameterTypes the types of the arguments of the specified method\n- * @return the most specific method selected from all interfaces;\n+ * @return the most specific method selected from all interfaces from each superclass of the current class;\n  *         otherwise, return the method of the first interface from the top superclass\n  *         if the return types of all specified methods are identical.\n  */\n-private Method getMostSpecificMethodFromAllInterfaces(Class<?> currentClass, HashSet<Class<?>> interfaceSet, String name, String strSig, Class<?>... parameterTypes) {\n+private Method getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(Class<?> currentClass, String name, Class<?>... parameterTypes) {\n \tMethod candidateMethod = null;\n-\n \tif (currentClass != Object.class) {\n-\t\tcandidateMethod = getMostSpecificMethodFromAllInterfaces(currentClass.getSuperclass(), \n-\t\t\t\t\t\t\t\t\t\t\t\t\t\tinterfaceSet, name, strSig, parameterTypes);\n+\t\t/* get to the top superclass first. if all return types end up being the same the interfaces from this superclass have priority. */\n+\t\tcandidateMethod = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(currentClass.getSuperclass(), name, parameterTypes);\n \t\t\n-\t\t/* getMethodImpl returns the specified method declared by an interface given that\n-\t\t * the current class has not yet implemented this method.\n-\t\t */\n-\t\tMethod resultFromInterface = currentClass.getMethodImpl(name, parameterTypes, strSig);\n-\t\tif (resultFromInterface != null) {\n-\t\t\tClass<?>[] interfacesFromCurrentClass = currentClass.getInterfaces();\n-\t\t\tfor (Class<?> nextInterface : interfacesFromCurrentClass) {\t\t\t\t\n-\t\t\t\t/* No need to search for the duplicate interface */\n-\t\t\t\tif (!interfaceSet.contains(nextInterface)) {\n-\t\t\t\t\tinterfaceSet.add(nextInterface);\n-\t\t\t\t\tMethod resultMethod = getMoreSpecificMethodFromInterface(nextInterface, name, strSig, parameterTypes);\n-\t\t\t\t\t\n-\t\t\t\t\tif (resultMethod != null) {\n-\t\t\t\t\t\tif (candidateMethod == null) {\n-\t\t\t\t\t\t\tcandidateMethod = resultMethod;\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tClass<?> resultRetType = resultMethod.getReturnType();\n-\t\t\t\t\t\t\tClass<?> CandidateRetType = candidateMethod.getReturnType();\n-\t\t\t\t\t\t\tif ((CandidateRetType != resultRetType) && CandidateRetType.isAssignableFrom(resultRetType)) {\n-\t\t\t\t\t\t\t\tcandidateMethod = resultMethod;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n+\t\t/* search all interfaces of current class, comparing against result from previous superclass. */\n+\t\tcandidateMethod = getMostSpecificMethodFromAllInterfacesOfCurrentClass(currentClass, candidateMethod, name, parameterTypes);\n \t}\n-\t\n \treturn candidateMethod;\n }\n \n /**\n- * Helper method obtains the more specific method declared in the interface\n- * \n- * @param currentInterface the interface that declares the specified method\n+ * Helper method searches all interfaces implemented by the current class or interface \n+ * for the most specific method declared in one of these interfaces.\n+ *\n+ * @param currentClass the class or interface to be searched\n+ * @param potentialCandidate potential candidate from superclass, null if currentClass is an interface\n  * @param name the specified method's name\n- * @param strSig the string of the specified method's signature\n  * @param parameterTypes the types of the arguments of the specified method\n- * @return the more specific method declared in this interface\n+ * @return the most specific method selected from all interfaces;\n+ *         otherwise if return types from all qualifying methods are identical, return an arbitrary method.\n  */\n-private Method getMoreSpecificMethodFromInterface(Class<?> currentInterface, String name, String strSig, Class<?>... parameterTypes) {\n-\tMethod resultMethod = currentInterface.getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n-\tMethod bestCandidate = resultMethod;\n-\t\n-\tif (resultMethod != null) {\n-\t\twhile (true) {\n-\t\t\tresultMethod = currentInterface.getDeclaredMethodImpl(name, parameterTypes, strSig, resultMethod);\n-\t\t\tif (resultMethod == null) {\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\tif ((resultMethod.getModifiers() & Modifier.PUBLIC) != 0) {\n-\t\t\t\t// bestCandidate and result have same declaringClass.\n-\t\t\t\tClass<?> bestCandidateRetType = bestCandidate.getReturnType();\n-\t\t\t\tClass<?> resultRetType = resultMethod.getReturnType();\n-\t\t\t\tif ((bestCandidateRetType != resultRetType) && bestCandidateRetType.isAssignableFrom(resultRetType)) {\n-\t\t\t\t\tbestCandidate = resultMethod;\n-\t\t\t\t}\n+private Method getMostSpecificMethodFromAllInterfacesOfCurrentClass(Class<?> currentClass, Method potentialCandidate, String name, Class<?>... parameterTypes) {\n+\tMethod bestMethod = potentialCandidate;\n+\tHashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache = new HashMap<>(16);\n+\tHashMap<MethodInfo, MethodInfo> methodCandidates = getMethodSet(infoCache, false, true);\n+\n+\tfor (MethodInfo mi : methodCandidates.values()) {\n+\t\tif (null == mi.jlrMethods) {\n+\t\t\tbestMethod = getMostSpecificInterfaceMethod(name, parameterTypes, bestMethod, mi.me);\n+\t\t} else {\n+\t\t\tfor (Method m: mi.jlrMethods) {\n+\t\t\t\tbestMethod = getMostSpecificInterfaceMethod(name, parameterTypes, bestMethod, m);\n \t\t\t}\n \t\t}\n \t}\n \n-\treturn bestCandidate;\n+\treturn bestMethod;\n+\n+}\n+\n+private static Method getMostSpecificInterfaceMethod(String name, Class<?>[] parameterTypes, Method bestMethod, Method candidateMethod) {\n+\tif (candidateMethod == bestMethod) {\n+\t\treturn bestMethod;\n+\t}\n+\n+\t/* match name and parameters to user specification */\n+\tif (!candidateMethod.getDeclaringClass().isInterface() \n+\t\t|| !candidateMethod.getName().equals(name) \n+\t\t|| !doParameterTypesMatch(candidateMethod.getParameterTypes(), parameterTypes)\n+\t) {\n+\t\treturn bestMethod;\n+\t}\n+\n+\tif (null == bestMethod) {\n+\t\tbestMethod = candidateMethod;\n+\t\treturn bestMethod;\n+\t}\n+\n+\tClass<?> bestRetType = bestMethod.getReturnType();\n+\tClass<?> candidateRetType = candidateMethod.getReturnType();\n+\n+\tif (bestRetType == candidateRetType) {\n+\t\tint bestModifiers = bestMethod.getModifiers();\n+\t\tint candidateModifiers = candidateMethod.getModifiers();\n+\t\tClass<?> bestDeclaringClass = bestMethod.getDeclaringClass();\n+\t\tClass<?> candidateDeclaringClass = candidateMethod.getDeclaringClass();\n+\t\t/* if all return types end up being the same, non-static methods take priority over static methods and sub-interfaces take\n+\t\t\tpriority over superinterface */\n+\t\t\tif ((Modifier.isStatic(bestModifiers) && !Modifier.isStatic(candidateModifiers))\n+\t\t\t\t|| methodAOverridesMethodB(candidateDeclaringClass, Modifier.isAbstract(candidateModifiers), candidateDeclaringClass.isInterface(), \n+\t\t\t\tbestDeclaringClass, Modifier.isAbstract(bestModifiers), bestDeclaringClass.isInterface())\n+\t\t) {\n+\t\t\tbestMethod = candidateMethod;\n+\t\t}\n+\t} else {\n+\t\t/* resulting method should have the most specific return type */\n+\t\tif (bestRetType.isAssignableFrom(candidateRetType)) {\n+\t\t\tbestMethod = candidateMethod;\n+\t\t}\n+\t}\n+\n+\treturn bestMethod;\n+}\n+\n+private static boolean doParameterTypesMatch(Class<?>[] paramList1, Class<?>[] paramList2) {\n+\tif (paramList1.length != paramList2.length) return false;\n+\n+\tfor (int index = 0; index < paramList1.length; index++) {\n+\t\tif (!paramList1[index].equals(paramList2[index])) {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\treturn true;\n }\n \n /**\n", "next_change": null}]}}]}}]}}, {"oid": "0715f9f8f7a3b2920884c427409dff8877a64373", "url": "https://github.com/eclipse-openj9/openj9/commit/0715f9f8f7a3b2920884c427409dff8877a64373", "message": "Search all superinterfaces with base interfaces\n\n- Class.getMethods jteg fixes, and make more similar to hotspot output\n- Class.getMethod interface search logic\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-02-04T21:29:12Z", "type": "forcePushed"}, {"oid": "bbc2ff27a563388dd938aa3e7391d367fed07c36", "url": "https://github.com/eclipse-openj9/openj9/commit/bbc2ff27a563388dd938aa3e7391d367fed07c36", "message": "Caching for find interface in superclasses\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-02-12T11:39:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMzNjYwMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r378336600", "body": "is there a chance that `infoCache` could be confused by `localInterfacesOnly` since the key is always `this` class? \r\nI didn't go thorough all use cases, but just wondering if such possibility has been considered.", "bodyText": "is there a chance that infoCache could be confused by localInterfacesOnly since the key is always this class?\nI didn't go thorough all use cases, but just wondering if such possibility has been considered.", "bodyHTML": "<p dir=\"auto\">is there a chance that <code>infoCache</code> could be confused by <code>localInterfacesOnly</code> since the key is always <code>this</code> class?<br>\nI didn't go thorough all use cases, but just wondering if such possibility has been considered.</p>", "author": "JasonFengJ9", "createdAt": "2020-02-12T15:46:28Z", "path": "jcl/src/java.base/share/classes/java/lang/Class.java", "diffHunk": "@@ -1530,28 +1552,146 @@ Method getMethodHelper(\n \t * Otherwise, the result method is chosen arbitrarily from specific methods.\n \t */\n \tbestCandidate = result;\n-\tClass<?> declaringClass = forDeclaredMethod ? this : result.getDeclaringClass();\n-\twhile (true) {\n-\t\tresult = declaringClass.getDeclaredMethodImpl(name, parameterTypes, strSig, result);\n-\t\tif (result == null) {\n-\t\t\tbreak;\n-\t\t}\n-\t\tboolean publicMethod = ((result.getModifiers() & Modifier.PUBLIC) != 0);\n-\t\tif ((methodList != null) && publicMethod) {\n-\t\t\tmethodList.add(result);\n-\t\t}\n-\t\tif (forDeclaredMethod || publicMethod) {\n-\t\t\t// bestCandidate and result have same declaringClass.\n-\t\t\tClass<?> candidateRetType = bestCandidate.getReturnType();\n-\t\t\tClass<?> resultRetType = result.getReturnType();\n-\t\t\tif ((candidateRetType != resultRetType) && candidateRetType.isAssignableFrom(resultRetType)) {\n-\t\t\t\tbestCandidate = result;\n+\tif (!candidateFromInterface) {\n+\t\tClass<?> declaringClass = forDeclaredMethod ? this : result.getDeclaringClass();\n+\t\twhile (true) {\n+\t\t\tresult = declaringClass.getDeclaredMethodImpl(name, parameterTypes, strSig, result);\n+\t\t\tif (result == null) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tboolean publicMethod = ((result.getModifiers() & Modifier.PUBLIC) != 0);\n+\t\t\tif ((methodList != null) && publicMethod) {\n+\t\t\t\tmethodList.add(result);\n+\t\t\t}\n+\t\t\tif (forDeclaredMethod || publicMethod) {\n+\t\t\t\t// bestCandidate and result have same declaringClass.\n+\t\t\t\tClass<?> candidateRetType = bestCandidate.getReturnType();\n+\t\t\t\tClass<?> resultRetType = result.getReturnType();\n+\t\t\t\tif ((candidateRetType != resultRetType) && candidateRetType.isAssignableFrom(resultRetType)) {\n+\t\t\t\t\tbestCandidate = result;\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n \treturn cacheMethod(bestCandidate);\n }\n \n+/**\n+ * Helper method searches all interfaces implemented by superclasses from the top to the bottom\n+ * for the most specific method declared in one of these interfaces.\n+ *\n+ * @param currentClass the class to be searched, including the current class and all superclasses\n+ * @param name the specified method's name\n+ * @param parameterTypes the types of the arguments of the specified method\n+ * @return the most specific method selected from all interfaces from each superclass of the current class;\n+ *         otherwise, return the method of the first interface from the top superclass\n+ *         if the return types of all specified methods are identical.\n+ */\n+private Method getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(Class<?> currentClass, HashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache, \n+\tString name, Class<?>... parameterTypes) \n+{\n+\tMethod candidateMethod = null;\n+\tif (currentClass != Object.class) {\n+\t\t/* get to the top superclass first. if all return types end up being the same the interfaces from this superclass have priority. */\n+\t\tcandidateMethod = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(currentClass.getSuperclass(), infoCache, name, parameterTypes);\n+\t\t\n+\t\t/* search all interfaces of current class, comparing against result from previous superclass. */\n+\t\tcandidateMethod = getMostSpecificMethodFromAllInterfacesOfCurrentClass(currentClass, infoCache, candidateMethod, name, parameterTypes);\n+\t}\n+\treturn candidateMethod;\n+}\n+\n+/**\n+ * Helper method searches all interfaces implemented by the current class or interface \n+ * for the most specific method declared in one of these interfaces.\n+ *\n+ * @param currentClass the class or interface to be searched\n+ * @param potentialCandidate potential candidate from superclass, null if currentClass is an interface\n+ * @param name the specified method's name\n+ * @param parameterTypes the types of the arguments of the specified method\n+ * @return the most specific method selected from all interfaces;\n+ *         otherwise if return types from all qualifying methods are identical, return an arbitrary method.\n+ */\n+private Method getMostSpecificMethodFromAllInterfacesOfCurrentClass(Class<?> currentClass, HashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache,\n+\tMethod potentialCandidate, String name, Class<?>... parameterTypes) \n+{\n+\tMethod bestMethod = potentialCandidate;\n+\t/* if infoCache is passed in, reuse from superclass */\n+\tif (null == infoCache) {\n+\t\tinfoCache = new HashMap<>(16);\n+\t}\n+\tHashMap<MethodInfo, MethodInfo> methodCandidates = getMethodSet(infoCache, false, true);", "originalCommit": "bbc2ff27a563388dd938aa3e7391d367fed07c36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODgyMDUzNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r378820535", "bodyText": "I made some modifications so it is more clear which this is being used by getMethodSet.", "author": "theresa-m", "createdAt": "2020-02-13T12:06:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMzNjYwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkwNzQ0OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r378907449", "bodyText": "infoCache seems not for late use after current getMethodHelper() call hence won't help much performance.\nIn that case, getInterfaces() is a better choice.", "author": "JasonFengJ9", "createdAt": "2020-02-13T14:49:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMzNjYwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ3ODM4Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r476478382", "bodyText": "@theresa-m is there a PR update since last comment?", "author": "JasonFengJ9", "createdAt": "2020-08-25T14:09:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMzNjYwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI4NDY4Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r477284687", "bodyText": "In my opinion getMethodSet is okay. getInterfaces could be used but getMethodSet is already getting interfaces recursively calling getInterfaces. From a maintainability standpoint I think it will be advantageous to maintain one spot for the override logic in update: https://github.com/eclipse/openj9/blob/1ed4919d1a2f9eb58ce7bd4facc99bcb76068bf9/jcl/src/java.base/share/classes/java/lang/Class.java#L3890", "author": "theresa-m", "createdAt": "2020-08-26T13:06:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMzNjYwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI5Mjk2Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r477292966", "bodyText": "An alternative solution as discussed offline would be to move more of this logic into native code however this would require quite a bit of work.", "author": "theresa-m", "createdAt": "2020-08-26T13:18:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMzNjYwMA=="}], "type": "inlineReview", "revised_code": {"commit": "b09b8df1b275eb94e149adf9805c810c72cc95e1", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex cdfbf8342..3f8f99f49 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1605,14 +1606,13 @@ private Method getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(Class<?>\n  * Helper method searches all interfaces implemented by the current class or interface \n  * for the most specific method declared in one of these interfaces.\n  *\n- * @param currentClass the class or interface to be searched\n  * @param potentialCandidate potential candidate from superclass, null if currentClass is an interface\n  * @param name the specified method's name\n  * @param parameterTypes the types of the arguments of the specified method\n  * @return the most specific method selected from all interfaces;\n  *         otherwise if return types from all qualifying methods are identical, return an arbitrary method.\n  */\n-private Method getMostSpecificMethodFromAllInterfacesOfCurrentClass(Class<?> currentClass, HashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache,\n+private Method getMostSpecificMethodFromAllInterfacesOfCurrentClass(HashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache,\n \tMethod potentialCandidate, String name, Class<?>... parameterTypes) \n {\n \tMethod bestMethod = potentialCandidate;\n", "next_change": {"commit": "57ec2470aba0d567200e7754f76d4fed5b4110d3", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex 3f8f99f49..ce9664213 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1581,115 +1580,83 @@ Method getMethodHelper(\n  * for the most specific method declared in one of these interfaces.\n  *\n  * @param currentClass the class to be searched, including the current class and all superclasses\n+ * @param interfaceSet the set of interfaces to be collected\n  * @param name the specified method's name\n+ * @param strSig the string of the specified method's signature\n  * @param parameterTypes the types of the arguments of the specified method\n- * @return the most specific method selected from all interfaces from each superclass of the current class;\n+ * @return the most specific method selected from all interfaces;\n  *         otherwise, return the method of the first interface from the top superclass\n  *         if the return types of all specified methods are identical.\n  */\n-private Method getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(HashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache, \n-\tString name, Class<?>... parameterTypes) \n-{\n+private Method getMostSpecificMethodFromAllInterfaces(Class<?> currentClass, HashSet<Class<?>> interfaceSet, String name, String strSig, Class<?>... parameterTypes) {\n \tMethod candidateMethod = null;\n-\tif (this != Object.class) {\n-\t\t/* get to the top superclass first. if all return types end up being the same the interfaces from this superclass have priority. */\n-\t\tClass superclz = getSuperclass();\n-\t\tcandidateMethod = superclz.getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(infoCache, name, parameterTypes);\n+\n+\tif (currentClass != Object.class) {\n+\t\tcandidateMethod = getMostSpecificMethodFromAllInterfaces(currentClass.getSuperclass(), \n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tinterfaceSet, name, strSig, parameterTypes);\n \t\t\n-\t\t/* search all interfaces of current class, comparing against result from previous superclass. */\n-\t\tcandidateMethod = getMostSpecificMethodFromAllInterfacesOfCurrentClass(infoCache, candidateMethod, name, parameterTypes);\n+\t\t/* getMethodImpl returns the specified method declared by an interface given that\n+\t\t * the current class has not yet implemented this method.\n+\t\t */\n+\t\tMethod resultFromInterface = currentClass.getMethodImpl(name, parameterTypes, strSig);\n+\t\tif (resultFromInterface != null) {\n+\t\t\tClass<?>[] interfacesFromCurrentClass = currentClass.getInterfaces();\n+\t\t\tfor (Class<?> nextInterface : interfacesFromCurrentClass) {\t\t\t\t\n+\t\t\t\t/* No need to search for the duplicate interface */\n+\t\t\t\tif (!interfaceSet.contains(nextInterface)) {\n+\t\t\t\t\tinterfaceSet.add(nextInterface);\n+\t\t\t\t\tMethod resultMethod = getMoreSpecificMethodFromInterface(nextInterface, name, strSig, parameterTypes);\n+\t\t\t\t\t\n+\t\t\t\t\tif (resultMethod != null) {\n+\t\t\t\t\t\tif (candidateMethod == null) {\n+\t\t\t\t\t\t\tcandidateMethod = resultMethod;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tClass<?> resultRetType = resultMethod.getReturnType();\n+\t\t\t\t\t\t\tClass<?> CandidateRetType = candidateMethod.getReturnType();\n+\t\t\t\t\t\t\tif ((CandidateRetType != resultRetType) && CandidateRetType.isAssignableFrom(resultRetType)) {\n+\t\t\t\t\t\t\t\tcandidateMethod = resultMethod;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t}\n+\t\n \treturn candidateMethod;\n }\n \n /**\n- * Helper method searches all interfaces implemented by the current class or interface \n- * for the most specific method declared in one of these interfaces.\n- *\n- * @param potentialCandidate potential candidate from superclass, null if currentClass is an interface\n+ * Helper method obtains the more specific method declared in the interface\n+ * \n+ * @param currentInterface the interface that declares the specified method\n  * @param name the specified method's name\n+ * @param strSig the string of the specified method's signature\n  * @param parameterTypes the types of the arguments of the specified method\n- * @return the most specific method selected from all interfaces;\n- *         otherwise if return types from all qualifying methods are identical, return an arbitrary method.\n+ * @return the more specific method declared in this interface\n  */\n-private Method getMostSpecificMethodFromAllInterfacesOfCurrentClass(HashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache,\n-\tMethod potentialCandidate, String name, Class<?>... parameterTypes) \n-{\n-\tMethod bestMethod = potentialCandidate;\n-\t/* if infoCache is passed in, reuse from superclass */\n-\tif (null == infoCache) {\n-\t\tinfoCache = new HashMap<>(16);\n-\t}\n-\tHashMap<MethodInfo, MethodInfo> methodCandidates = getMethodSet(infoCache, false, true);\n-\n-\tfor (MethodInfo mi : methodCandidates.values()) {\n-\t\tif (null == mi.jlrMethods) {\n-\t\t\tbestMethod = getMostSpecificInterfaceMethod(name, parameterTypes, bestMethod, mi.me);\n-\t\t} else {\n-\t\t\tfor (Method m: mi.jlrMethods) {\n-\t\t\t\tbestMethod = getMostSpecificInterfaceMethod(name, parameterTypes, bestMethod, m);\n+private Method getMoreSpecificMethodFromInterface(Class<?> currentInterface, String name, String strSig, Class<?>... parameterTypes) {\n+\tMethod resultMethod = currentInterface.getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n+\tMethod bestCandidate = resultMethod;\n+\t\n+\tif (resultMethod != null) {\n+\t\twhile (true) {\n+\t\t\tresultMethod = currentInterface.getDeclaredMethodImpl(name, parameterTypes, strSig, resultMethod);\n+\t\t\tif (resultMethod == null) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif ((resultMethod.getModifiers() & Modifier.PUBLIC) != 0) {\n+\t\t\t\t// bestCandidate and result have same declaringClass.\n+\t\t\t\tClass<?> bestCandidateRetType = bestCandidate.getReturnType();\n+\t\t\t\tClass<?> resultRetType = resultMethod.getReturnType();\n+\t\t\t\tif ((bestCandidateRetType != resultRetType) && bestCandidateRetType.isAssignableFrom(resultRetType)) {\n+\t\t\t\t\tbestCandidate = resultMethod;\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n \n-\treturn bestMethod;\n-\n-}\n-\n-private static Method getMostSpecificInterfaceMethod(String name, Class<?>[] parameterTypes, Method bestMethod, Method candidateMethod) {\n-\tif (candidateMethod == bestMethod) {\n-\t\treturn bestMethod;\n-\t}\n-\n-\t/* match name and parameters to user specification */\n-\tif (!candidateMethod.getDeclaringClass().isInterface() \n-\t\t|| !candidateMethod.getName().equals(name) \n-\t\t|| !doParameterTypesMatch(candidateMethod.getParameterTypes(), parameterTypes)\n-\t) {\n-\t\treturn bestMethod;\n-\t}\n-\n-\tif (null == bestMethod) {\n-\t\tbestMethod = candidateMethod;\n-\t\treturn bestMethod;\n-\t}\n-\n-\tClass<?> bestRetType = bestMethod.getReturnType();\n-\tClass<?> candidateRetType = candidateMethod.getReturnType();\n-\n-\tif (bestRetType == candidateRetType) {\n-\t\tint bestModifiers = bestMethod.getModifiers();\n-\t\tint candidateModifiers = candidateMethod.getModifiers();\n-\t\tClass<?> bestDeclaringClass = bestMethod.getDeclaringClass();\n-\t\tClass<?> candidateDeclaringClass = candidateMethod.getDeclaringClass();\n-\t\t/* if all return types end up being the same, non-static methods take priority over static methods and sub-interfaces take\n-\t\t\tpriority over superinterface */\n-\t\t\tif ((Modifier.isStatic(bestModifiers) && !Modifier.isStatic(candidateModifiers))\n-\t\t\t\t|| methodAOverridesMethodB(candidateDeclaringClass, Modifier.isAbstract(candidateModifiers), candidateDeclaringClass.isInterface(), \n-\t\t\t\tbestDeclaringClass, Modifier.isAbstract(bestModifiers), bestDeclaringClass.isInterface())\n-\t\t) {\n-\t\t\tbestMethod = candidateMethod;\n-\t\t}\n-\t} else {\n-\t\t/* resulting method should have the most specific return type */\n-\t\tif (bestRetType.isAssignableFrom(candidateRetType)) {\n-\t\t\tbestMethod = candidateMethod;\n-\t\t}\n-\t}\n-\n-\treturn bestMethod;\n-}\n-\n-private static boolean doParameterTypesMatch(Class<?>[] paramList1, Class<?>[] paramList2) {\n-\tif (paramList1.length != paramList2.length) return false;\n-\n-\tfor (int index = 0; index < paramList1.length; index++) {\n-\t\tif (!paramList1[index].equals(paramList2[index])) {\n-\t\t\treturn false;\n-\t\t}\n-\t}\n-\n-\treturn true;\n+\treturn bestCandidate;\n }\n \n /**\n", "next_change": {"commit": "ce60704e9678db4056d8afe08c13d3a02d554df0", "changed_code": [{"header": "diff --git a/jcl/src/java.base/share/classes/java/lang/Class.java b/jcl/src/java.base/share/classes/java/lang/Class.java\nindex ce9664213..815f76604 100644\n--- a/jcl/src/java.base/share/classes/java/lang/Class.java\n+++ b/jcl/src/java.base/share/classes/java/lang/Class.java\n", "chunk": "@@ -1580,83 +1584,108 @@ Method getMethodHelper(\n  * for the most specific method declared in one of these interfaces.\n  *\n  * @param currentClass the class to be searched, including the current class and all superclasses\n- * @param interfaceSet the set of interfaces to be collected\n  * @param name the specified method's name\n- * @param strSig the string of the specified method's signature\n  * @param parameterTypes the types of the arguments of the specified method\n- * @return the most specific method selected from all interfaces;\n+ * @return the most specific method selected from all interfaces from each superclass of the current class;\n  *         otherwise, return the method of the first interface from the top superclass\n  *         if the return types of all specified methods are identical.\n  */\n-private Method getMostSpecificMethodFromAllInterfaces(Class<?> currentClass, HashSet<Class<?>> interfaceSet, String name, String strSig, Class<?>... parameterTypes) {\n+private Method getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(Class<?> currentClass, String name, Class<?>... parameterTypes) {\n \tMethod candidateMethod = null;\n-\n \tif (currentClass != Object.class) {\n-\t\tcandidateMethod = getMostSpecificMethodFromAllInterfaces(currentClass.getSuperclass(), \n-\t\t\t\t\t\t\t\t\t\t\t\t\t\tinterfaceSet, name, strSig, parameterTypes);\n+\t\t/* get to the top superclass first. if all return types end up being the same the interfaces from this superclass have priority. */\n+\t\tcandidateMethod = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(currentClass.getSuperclass(), name, parameterTypes);\n \t\t\n-\t\t/* getMethodImpl returns the specified method declared by an interface given that\n-\t\t * the current class has not yet implemented this method.\n-\t\t */\n-\t\tMethod resultFromInterface = currentClass.getMethodImpl(name, parameterTypes, strSig);\n-\t\tif (resultFromInterface != null) {\n-\t\t\tClass<?>[] interfacesFromCurrentClass = currentClass.getInterfaces();\n-\t\t\tfor (Class<?> nextInterface : interfacesFromCurrentClass) {\t\t\t\t\n-\t\t\t\t/* No need to search for the duplicate interface */\n-\t\t\t\tif (!interfaceSet.contains(nextInterface)) {\n-\t\t\t\t\tinterfaceSet.add(nextInterface);\n-\t\t\t\t\tMethod resultMethod = getMoreSpecificMethodFromInterface(nextInterface, name, strSig, parameterTypes);\n-\t\t\t\t\t\n-\t\t\t\t\tif (resultMethod != null) {\n-\t\t\t\t\t\tif (candidateMethod == null) {\n-\t\t\t\t\t\t\tcandidateMethod = resultMethod;\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tClass<?> resultRetType = resultMethod.getReturnType();\n-\t\t\t\t\t\t\tClass<?> CandidateRetType = candidateMethod.getReturnType();\n-\t\t\t\t\t\t\tif ((CandidateRetType != resultRetType) && CandidateRetType.isAssignableFrom(resultRetType)) {\n-\t\t\t\t\t\t\t\tcandidateMethod = resultMethod;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n+\t\t/* search all interfaces of current class, comparing against result from previous superclass. */\n+\t\tcandidateMethod = getMostSpecificMethodFromAllInterfacesOfCurrentClass(currentClass, candidateMethod, name, parameterTypes);\n \t}\n-\t\n \treturn candidateMethod;\n }\n \n /**\n- * Helper method obtains the more specific method declared in the interface\n- * \n- * @param currentInterface the interface that declares the specified method\n+ * Helper method searches all interfaces implemented by the current class or interface \n+ * for the most specific method declared in one of these interfaces.\n+ *\n+ * @param currentClass the class or interface to be searched\n+ * @param potentialCandidate potential candidate from superclass, null if currentClass is an interface\n  * @param name the specified method's name\n- * @param strSig the string of the specified method's signature\n  * @param parameterTypes the types of the arguments of the specified method\n- * @return the more specific method declared in this interface\n+ * @return the most specific method selected from all interfaces;\n+ *         otherwise if return types from all qualifying methods are identical, return an arbitrary method.\n  */\n-private Method getMoreSpecificMethodFromInterface(Class<?> currentInterface, String name, String strSig, Class<?>... parameterTypes) {\n-\tMethod resultMethod = currentInterface.getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n-\tMethod bestCandidate = resultMethod;\n-\t\n-\tif (resultMethod != null) {\n-\t\twhile (true) {\n-\t\t\tresultMethod = currentInterface.getDeclaredMethodImpl(name, parameterTypes, strSig, resultMethod);\n-\t\t\tif (resultMethod == null) {\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\tif ((resultMethod.getModifiers() & Modifier.PUBLIC) != 0) {\n-\t\t\t\t// bestCandidate and result have same declaringClass.\n-\t\t\t\tClass<?> bestCandidateRetType = bestCandidate.getReturnType();\n-\t\t\t\tClass<?> resultRetType = resultMethod.getReturnType();\n-\t\t\t\tif ((bestCandidateRetType != resultRetType) && bestCandidateRetType.isAssignableFrom(resultRetType)) {\n-\t\t\t\t\tbestCandidate = resultMethod;\n-\t\t\t\t}\n+private Method getMostSpecificMethodFromAllInterfacesOfCurrentClass(Class<?> currentClass, Method potentialCandidate, String name, Class<?>... parameterTypes) {\n+\tMethod bestMethod = potentialCandidate;\n+\tHashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache = new HashMap<>(16);\n+\tHashMap<MethodInfo, MethodInfo> methodCandidates = getMethodSet(infoCache, false, true);\n+\n+\tfor (MethodInfo mi : methodCandidates.values()) {\n+\t\tif (null == mi.jlrMethods) {\n+\t\t\tbestMethod = getMostSpecificInterfaceMethod(name, parameterTypes, bestMethod, mi.me);\n+\t\t} else {\n+\t\t\tfor (Method m: mi.jlrMethods) {\n+\t\t\t\tbestMethod = getMostSpecificInterfaceMethod(name, parameterTypes, bestMethod, m);\n \t\t\t}\n \t\t}\n \t}\n \n-\treturn bestCandidate;\n+\treturn bestMethod;\n+\n+}\n+\n+private static Method getMostSpecificInterfaceMethod(String name, Class<?>[] parameterTypes, Method bestMethod, Method candidateMethod) {\n+\tif (candidateMethod == bestMethod) {\n+\t\treturn bestMethod;\n+\t}\n+\n+\t/* match name and parameters to user specification */\n+\tif (!candidateMethod.getDeclaringClass().isInterface() \n+\t\t|| !candidateMethod.getName().equals(name) \n+\t\t|| !doParameterTypesMatch(candidateMethod.getParameterTypes(), parameterTypes)\n+\t) {\n+\t\treturn bestMethod;\n+\t}\n+\n+\tif (null == bestMethod) {\n+\t\tbestMethod = candidateMethod;\n+\t\treturn bestMethod;\n+\t}\n+\n+\tClass<?> bestRetType = bestMethod.getReturnType();\n+\tClass<?> candidateRetType = candidateMethod.getReturnType();\n+\n+\tif (bestRetType == candidateRetType) {\n+\t\tint bestModifiers = bestMethod.getModifiers();\n+\t\tint candidateModifiers = candidateMethod.getModifiers();\n+\t\tClass<?> bestDeclaringClass = bestMethod.getDeclaringClass();\n+\t\tClass<?> candidateDeclaringClass = candidateMethod.getDeclaringClass();\n+\t\t/* if all return types end up being the same, non-static methods take priority over static methods and sub-interfaces take\n+\t\t\tpriority over superinterface */\n+\t\t\tif ((Modifier.isStatic(bestModifiers) && !Modifier.isStatic(candidateModifiers))\n+\t\t\t\t|| methodAOverridesMethodB(candidateDeclaringClass, Modifier.isAbstract(candidateModifiers), candidateDeclaringClass.isInterface(), \n+\t\t\t\tbestDeclaringClass, Modifier.isAbstract(bestModifiers), bestDeclaringClass.isInterface())\n+\t\t) {\n+\t\t\tbestMethod = candidateMethod;\n+\t\t}\n+\t} else {\n+\t\t/* resulting method should have the most specific return type */\n+\t\tif (bestRetType.isAssignableFrom(candidateRetType)) {\n+\t\t\tbestMethod = candidateMethod;\n+\t\t}\n+\t}\n+\n+\treturn bestMethod;\n+}\n+\n+private static boolean doParameterTypesMatch(Class<?>[] paramList1, Class<?>[] paramList2) {\n+\tif (paramList1.length != paramList2.length) return false;\n+\n+\tfor (int index = 0; index < paramList1.length; index++) {\n+\t\tif (!paramList1[index].equals(paramList2[index])) {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\treturn true;\n }\n \n /**\n", "next_change": null}]}}]}}]}}, {"oid": "b09b8df1b275eb94e149adf9805c810c72cc95e1", "url": "https://github.com/eclipse-openj9/openj9/commit/b09b8df1b275eb94e149adf9805c810c72cc95e1", "message": "Caching for find interface in superclasses\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-02-13T12:02:41Z", "type": "forcePushed"}, {"oid": "1ed4919d1a2f9eb58ce7bd4facc99bcb76068bf9", "url": "https://github.com/eclipse-openj9/openj9/commit/1ed4919d1a2f9eb58ce7bd4facc99bcb76068bf9", "message": "Caching for find interface in superclasses\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-02-13T14:15:07Z", "type": "forcePushed"}, {"oid": "57ec2470aba0d567200e7754f76d4fed5b4110d3", "url": "https://github.com/eclipse-openj9/openj9/commit/57ec2470aba0d567200e7754f76d4fed5b4110d3", "message": "Fix the missing case of Class.getMethod()\n\nThe change is adding code in the helper method\nof getMethod() to address the missing case when\nthe two specific methods are both declared\nby interfaces.\n\nFixes: #7897\n\nSigned-off-by: Cheng Jin <jincheng@ca.ibm.com>", "committedDate": "2020-08-27T12:41:53Z", "type": "commit"}, {"oid": "ce60704e9678db4056d8afe08c13d3a02d554df0", "url": "https://github.com/eclipse-openj9/openj9/commit/ce60704e9678db4056d8afe08c13d3a02d554df0", "message": "Search all superinterfaces with base interfaces\n\n- Class.getMethods jteg fixes, and make more similar to hotspot output\n- Class.getMethod interface search logic\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-08-27T12:41:53Z", "type": "commit"}, {"oid": "2d998299562752395d25a9a94f1f5c3721ff3906", "url": "https://github.com/eclipse-openj9/openj9/commit/2d998299562752395d25a9a94f1f5c3721ff3906", "message": "Caching for find interface in superclasses\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-08-27T12:41:53Z", "type": "commit"}, {"oid": "2d998299562752395d25a9a94f1f5c3721ff3906", "url": "https://github.com/eclipse-openj9/openj9/commit/2d998299562752395d25a9a94f1f5c3721ff3906", "message": "Caching for find interface in superclasses\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>", "committedDate": "2020-08-27T12:41:53Z", "type": "forcePushed"}]}