{"pr_number": 1157, "pr_title": "system disabled state for principals ", "pr_author": "abvaidya", "pr_createdAt": "2020-10-21T17:25:34Z", "pr_url": "https://github.com/AthenZ/athenz/pull/1157", "merge_commit": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "timeline": [{"oid": "4b44760c9a52f8b833a9171a56950c2aee2474bc", "url": "https://github.com/AthenZ/athenz/commit/4b44760c9a52f8b833a9171a56950c2aee2474bc", "message": "system disabled state for principals", "committedDate": "2020-10-21T06:30:38Z", "type": "commit"}, {"oid": "804c5dd98652af04684fa59d13cf31230a661fe0", "url": "https://github.com/AthenZ/athenz/commit/804c5dd98652af04684fa59d13cf31230a661fe0", "message": "adding a config property to start principal state updater", "committedDate": "2020-10-21T16:44:45Z", "type": "commit"}, {"oid": "45b271a460205ef873d48d4247128daa43779d54", "url": "https://github.com/AthenZ/athenz/commit/45b271a460205ef873d48d4247128daa43779d54", "message": "switching travis log level back to ERROR", "committedDate": "2020-10-21T18:41:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ0ODQ2OQ==", "url": "https://github.com/AthenZ/athenz/pull/1157#discussion_r510448469", "body": "somewhat confusing to call this bit as system disabled since the full attribute with combined bits is also called system disabled. So maybe we should call this bit suspended since that's what we're implementing. ", "bodyText": "somewhat confusing to call this bit as system disabled since the full attribute with combined bits is also called system disabled. So maybe we should call this bit suspended since that's what we're implementing.", "bodyHTML": "<p dir=\"auto\">somewhat confusing to call this bit as system disabled since the full attribute with combined bits is also called system disabled. So maybe we should call this bit suspended since that's what we're implementing.</p>", "author": "havetisyan", "createdAt": "2020-10-22T20:50:14Z", "path": "libs/java/auth_core/src/main/java/com/yahoo/athenz/auth/Principal.java", "diffHunk": "@@ -49,6 +49,31 @@ public static Type getType(int value) {\n         }\n     }\n \n+    /**\n+     * Principal state - active, authority filter disabled or authority system disabled\n+     */\n+    enum State {\n+        ACTIVE(0x00),\n+        AUTHORITY_FILTER_DISABLED(0x01),\n+        AUTHORITY_SYSTEM_DISABLED(0x02);", "originalCommit": "45b271a460205ef873d48d4247128daa43779d54", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f2b6979e4235f325d7eea75d6f63d358c03d8d3c", "changed_code": [{"header": "diff --git a/libs/java/auth_core/src/main/java/com/yahoo/athenz/auth/Principal.java b/libs/java/auth_core/src/main/java/com/yahoo/athenz/auth/Principal.java\nindex 9e4b55217..6976f12b6 100644\n--- a/libs/java/auth_core/src/main/java/com/yahoo/athenz/auth/Principal.java\n+++ b/libs/java/auth_core/src/main/java/com/yahoo/athenz/auth/Principal.java\n", "chunk": "@@ -55,7 +55,7 @@ public interface Principal {\n     enum State {\n         ACTIVE(0x00),\n         AUTHORITY_FILTER_DISABLED(0x01),\n-        AUTHORITY_SYSTEM_DISABLED(0x02);\n+        AUTHORITY_SYSTEM_SUSPENDED(0x02);\n \n         private final int principalState;\n         State(int state) {\n", "next_change": null}]}, "revised_code_in_main": {"commit": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "changed_code": [{"header": "diff --git a/libs/java/auth_core/src/main/java/com/yahoo/athenz/auth/Principal.java b/libs/java/auth_core/src/main/java/com/yahoo/athenz/auth/Principal.java\nindex 9e4b55217..6976f12b6 100644\n--- a/libs/java/auth_core/src/main/java/com/yahoo/athenz/auth/Principal.java\n+++ b/libs/java/auth_core/src/main/java/com/yahoo/athenz/auth/Principal.java\n", "chunk": "@@ -55,7 +55,7 @@ public interface Principal {\n     enum State {\n         ACTIVE(0x00),\n         AUTHORITY_FILTER_DISABLED(0x01),\n-        AUTHORITY_SYSTEM_DISABLED(0x02);\n+        AUTHORITY_SYSTEM_SUSPENDED(0x02);\n \n         private final int principalState;\n         State(int state) {\n", "next_change": null}]}, "commits_in_main": [{"oid": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "message": "Merge commit", "committedDate": null}, {"oid": "1400363e8d698cf08370c89752077ebae043c5be", "committedDate": "2021-12-14 13:48:34 -0800", "message": "correct logging of role principal in audit/access logs"}, {"oid": "d4c733d3e97467a598ba44f0bde5c6a907aa01de", "committedDate": "2022-09-23 13:30:24 -0700", "message": "consistent use of The Athenz Authors copyright in all files (#1967)"}, {"oid": "368d0bc139931c03d31824c4f02394b38e3ead95", "committedDate": "2023-06-02 13:15:05 -0700", "message": "support headless user type - managed by user authority but treated like service (#2197)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ1MDAxNw==", "url": "https://github.com/AthenZ/athenz/pull/1157#discussion_r510450017", "body": "since the queriedState does not change we should get the value outside of the for loop so we can call the method once and not for every principal in the list", "bodyText": "since the queriedState does not change we should get the value outside of the for loop so we can call the method once and not for every principal in the list", "bodyHTML": "<p dir=\"auto\">since the queriedState does not change we should get the value outside of the for loop so we can call the method once and not for every principal in the list</p>", "author": "havetisyan", "createdAt": "2020-10-22T20:52:59Z", "path": "servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java", "diffHunk": "@@ -6402,6 +6403,147 @@ void enforceGroupUserAuthorityRestrictions(final String domainName, final String\n         }\n     }\n \n+    /**\n+     * This method returns list of Principals based on the state parameter supplied\n+     * @param queriedState state of principal\n+     * @return List of Principals from DB\n+     */\n+    List<Principal> getPrincipals(int queriedState) {\n+        List<Principal> principals = new ArrayList<>();\n+        Principal principal;\n+        try (ObjectStoreConnection con = store.getConnection(true, false)) {\n+           List<String> dbPrincipals = con.getPrincipals(queriedState);\n+           for (String dbPrincipal : dbPrincipals) {\n+               principal = ZMSUtils.createPrincipalForName(dbPrincipal, zmsConfig.getUserDomain(), null);\n+               ((SimplePrincipal) principal).setState(Principal.State.getState(queriedState));", "originalCommit": "45b271a460205ef873d48d4247128daa43779d54", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f2b6979e4235f325d7eea75d6f63d358c03d8d3c", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 2c6958b49..2d11e7268 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6413,9 +6413,10 @@ public class DBService implements RolesProvider {\n         Principal principal;\n         try (ObjectStoreConnection con = store.getConnection(true, false)) {\n            List<String> dbPrincipals = con.getPrincipals(queriedState);\n+            Principal.State principalState = Principal.State.getState(queriedState);\n            for (String dbPrincipal : dbPrincipals) {\n                principal = ZMSUtils.createPrincipalForName(dbPrincipal, zmsConfig.getUserDomain(), null);\n-               ((SimplePrincipal) principal).setState(Principal.State.getState(queriedState));\n+               ((SimplePrincipal) principal).setState(principalState);\n                principals.add(principal);\n            }\n         }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 2c6958b49..08f2ee72e 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6413,9 +6413,10 @@ public class DBService implements RolesProvider {\n         Principal principal;\n         try (ObjectStoreConnection con = store.getConnection(true, false)) {\n            List<String> dbPrincipals = con.getPrincipals(queriedState);\n+            Principal.State principalState = Principal.State.getState(queriedState);\n            for (String dbPrincipal : dbPrincipals) {\n                principal = ZMSUtils.createPrincipalForName(dbPrincipal, zmsConfig.getUserDomain(), null);\n-               ((SimplePrincipal) principal).setState(Principal.State.getState(queriedState));\n+               ((SimplePrincipal) principal).setState(principalState);\n                principals.add(principal);\n            }\n         }\n", "next_change": null}]}, "commits_in_main": [{"oid": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "message": "Merge commit", "committedDate": null}, {"oid": "9a9c82c13d156e06dad8464c3a6c52c8e2bc6b89", "committedDate": "2020-10-26 14:15:03 -0700", "message": "remove sending back deprected members field in roles (#1160)"}, {"oid": "31a0dd7362f585f85992d4ff86fbf975d9d736dd", "committedDate": "2020-10-31 14:59:07 -0700", "message": "add azure_subscription field to domains (#1167)"}, {"oid": "c668f48cec94e2c928581b92ffb517f715a4840f", "committedDate": "2020-11-06 18:05:10 -0800", "message": "handle sys disabled null scenario (#1176)"}, {"oid": "f24d15baaaddc96c85fbceb31fcaded756a69f2e", "committedDate": "2020-11-14 16:51:57 -0800", "message": "role tags - generated code and schema changes (#1179)"}, {"oid": "30e272d8a9ec2649a1d876c1c111cf38e27c1743", "committedDate": "2020-12-07 08:48:58 -0800", "message": "putRoleMeta tags support (#1208)"}, {"oid": "f0e0a91b80250236244db9f8cba79e1def809995", "committedDate": "2020-12-23 15:40:53 -0800", "message": "updating group expiry date (#1221)"}, {"oid": "7a2837c7578ab8d36c62b48ecb1d0079c670616b", "committedDate": "2020-12-29 13:44:04 -0800", "message": "granular authz action for managing role members (#1228)"}, {"oid": "d6a0d659fe96486ffcf31bb93e919656be9eaf89", "committedDate": "2021-01-13 08:15:47 -0800", "message": "domain tags implementation (#1235)"}, {"oid": "3c939966592bf7cc6ff25df12a8d21d4c2c89b2b", "committedDate": "2021-01-19 22:05:22 -0800", "message": "client api update for rich authorization requests and consistent naming of entity objects (#1248)"}, {"oid": "3db6ed7b169fce5bbeaa1fae84ff7881e9a4e435", "committedDate": "2021-01-21 09:17:41 -0800", "message": "limit number of role and domain tags (#1255)"}, {"oid": "218b71958d88fb039dfa6e7c5448c7e4d00cb337", "committedDate": "2021-01-25 17:53:41 -0800", "message": "update domain last modified timestamp after tag update (#1262)"}, {"oid": "bccc5fb4dc1c2407a0293f322c3d97711af4297c", "committedDate": "2021-03-07 18:11:58 -0800", "message": "sonarcloud: method always returns same result (#1329)"}, {"oid": "e421f20094d24075d2cec7ab7adecff7d630a286", "committedDate": "2021-03-16 18:08:03 -0700", "message": "expose new domain attribute: business-service (#1357)"}, {"oid": "7b4afd5d40394226b3aa1af8bf10e90e528091b3", "committedDate": "2021-04-01 14:52:30 -0700", "message": "Add memberExpiryDays and serviceExpiryDays support for groups (#1388)"}, {"oid": "5ab30978cc4fc03e1b3022305f6e14a5a425e9e9", "committedDate": "2021-04-07 16:30:50 -0700", "message": "new DomainMetaStore interface support in ZMS (#1430)"}, {"oid": "9bedde4310d6493406d264422f23e16f33213546", "committedDate": "2021-04-08 09:44:29 -0700", "message": "Add group review days to role (#1428)"}, {"oid": "a554c75c51c5945b0e58ae87866de93ff1d5cfbc", "committedDate": "2021-04-15 12:12:02 -0700", "message": "during provider admin setup, ignore deletes (#1444)"}, {"oid": "1c564548381b3c09ad4214d0f30c667e9cc0d022", "committedDate": "2021-04-30 15:22:51 -0700", "message": "log full policy assertion details during delete operations in audit log (#1469)"}, {"oid": "611ac334bfbc1c43ec20154cf9448b96fae365d6", "committedDate": "2021-05-27 16:30:38 -0700", "message": "handle null contition processDomainTags (#1495)"}, {"oid": "addf4424a5bf842b58558c6f61ac0b46277d9535", "committedDate": "2021-06-07 09:38:12 -0700", "message": "allow role/group review regardless of role/group expiry/reminder settings (#1503)"}, {"oid": "4b39ffbd18da3d10a581fb10209806c97b432d28", "committedDate": "2021-06-09 15:31:17 -0700", "message": "enable role review without setting restrictions (#1512)"}, {"oid": "898ff0aa4fddd1a9ed111496cb9e4acb544605af", "committedDate": "2021-06-14 10:42:10 -0700", "message": "Update Tag Values to include '/', ':' (#1517)"}, {"oid": "cf535673b0a4cbcdc81e17c7def4cb6822edd78c", "committedDate": "2021-06-22 06:44:42 -0700", "message": "Allow system admins to set domain meta attribute business service (#1522)"}, {"oid": "934fc3d7fc859731f4beab3b03b83a15ac717a2d", "committedDate": "2021-06-29 12:57:53 -0700", "message": "assertion condition server changes (#1528)"}, {"oid": "1fa51b852890c1576254be6a8a2b5dbebc89865c", "committedDate": "2021-07-21 14:41:19 -0700", "message": "UI : update error message (#1557)"}, {"oid": "09de45bb794eb5e7c29f705b5ce567c75fde4e84", "committedDate": "2021-07-29 15:49:16 -0700", "message": "multi-version policy - introducing version/active in policy object (#1568)"}, {"oid": "4abff4b9952e4836f79bf3f1934baf8fe2bcebf9", "committedDate": "2021-08-08 11:39:07 -0700", "message": "Disable Reminder Review Notifications By Tag zms.DisableReminderNotifications (#1579)"}, {"oid": "6a1523accc3ec83fe54d78c3d919d9cddbcb1b7e", "committedDate": "2021-08-17 18:32:28 -0700", "message": "fixing the order of updates for assertion condition api operations (#1591)"}, {"oid": "66590f4fc47f899f3990f20895f953074e40f259", "committedDate": "2021-09-10 07:55:42 -0700", "message": "Implement multi-version policies endpoints (#1605)"}, {"oid": "1ad624427917493d31bd1b8ffa6303c4d6353055", "committedDate": "2021-09-10 13:51:19 -0700", "message": "update group last modified when user is deleted (#1613)"}, {"oid": "91b116418656f123dae9a3405cb2e498d4d3aff4", "committedDate": "2021-09-12 09:52:05 +0300", "message": "additional validation checks when processing versioned policies (#1614)"}, {"oid": "2531428956f87774f86721f02b430861ca8897ec", "committedDate": "2021-09-14 09:49:34 +0300", "message": "additional checks when setting a policy version as active (#1615)"}, {"oid": "2968c209e870ce57fbdb1fb048a21692d80cfea6", "committedDate": "2021-10-01 07:25:34 -0700", "message": "rdl publishChangeEvents generator (#1624)"}, {"oid": "8a6960ce9878277c5abda1d104ca070831b36230", "committedDate": "2021-10-03 13:48:03 -0700", "message": "Allow specifying version name when creating new policy (#1630)"}, {"oid": "43f619b31bbd9cc3d388aa7ea29eff889cb1272d", "committedDate": "2021-10-21 08:48:51 -0700", "message": "For role expiry notification - record metrics daily while (#1654)"}, {"oid": "389f984270d7d89070c66096e87fafbcb24a261c", "committedDate": "2021-10-26 08:17:36 -0700", "message": "Group tags implementation (#1660)"}, {"oid": "120ab1fa8e9d33fa793c4254d233a09a2c23d173", "committedDate": "2021-10-29 15:08:28 -0700", "message": "Disable Group Expiry Notifications By Tag zms.DisableReminderNotifications (#1663)"}, {"oid": "1400363e8d698cf08370c89752077ebae043c5be", "committedDate": "2021-12-14 13:48:34 -0800", "message": "correct logging of role principal in audit/access logs"}, {"oid": "c8e3a5c91c5deb9640576cd3496a2af11d572f0b", "committedDate": "2021-12-23 15:03:25 -0800", "message": "protect system admin users from being removed from deleteUser api (#1715)"}, {"oid": "020e06e57b357768260f509f08b75c5c068bce53", "committedDate": "2022-02-07 08:01:55 -0800", "message": "Service Visiblity - Domain Dependencies (#1758)"}, {"oid": "fcbd4128e334a9a42f4579d179cf9578d3f4de99", "committedDate": "2022-02-07 10:12:47 -0800", "message": "support new get-stats endpoint to get per-domain/system stats (#1774)"}, {"oid": "ea831a34a70a0475bea8754cb183741dced98ff2", "committedDate": "2022-02-18 09:17:55 -0800", "message": "update pending member api to support getting list for a domain (#1783)"}, {"oid": "f4229124e8e1898810c7aa7b3a4eff37fddae308", "committedDate": "2022-02-18 12:37:32 -0800", "message": "provide option to skip adding principal when onboarding a resource group (#1787)"}, {"oid": "9081feb4c06a1058c941c67923037203d9318cfa", "committedDate": "2022-02-27 14:10:46 -0800", "message": "Domain Dependency for Tenancy (#1789)"}, {"oid": "a5bb615881583fa6f39621e2ea3bf39d3886340b", "committedDate": "2022-03-03 17:20:00 -0800", "message": "extend template keyword support trust field in roles (#1803)"}, {"oid": "3de182bcbedba89fa2aaba12ab9be49aa2156096", "committedDate": "2022-03-19 09:45:40 -0700", "message": "Add provider webhook for verifying removal (#1816)"}, {"oid": "1b0cff1cb9b8e4a231c5cfb342d76b6aad8e08fc", "committedDate": "2022-04-07 14:34:23 -0700", "message": "no need to update domain's last mod timestamp during put dependency call (#1846)"}, {"oid": "baa68eacd6a6b9bbc70c3423006f92cd47b784d7", "committedDate": "2022-05-19 09:30:02 -0700", "message": "Get Auth History implementation (#1875)"}, {"oid": "bea97b165e28b5b2cc286af62c92e536c9fc3ff2", "committedDate": "2022-06-03 13:50:01 -0700", "message": "AuthHistory - Return dependencies instead of list (#1888)"}, {"oid": "7a313e1d581295ae6c786bbc2ed73bb14da37f7d", "committedDate": "2022-07-21 20:16:24 -0700", "message": "allow management of domain memberPurgeExpiryDays setting value (#1928)"}, {"oid": "f288ed7afb018bc07af02dbe9dc8e05ec0896071", "committedDate": "2022-08-15 22:28:01 -0700", "message": "provide header option to return updated object in response (#1942)"}, {"oid": "949bd0634d328d04736b912a002bdfa7421d9f2b", "committedDate": "2022-08-23 10:28:38 -0700", "message": "fix returning role/group objects when requested by ui (#1945)"}, {"oid": "ab7284c9274f4949d23f88ec0dde7b689c0c6980", "committedDate": "2022-09-05 13:12:17 -0700", "message": "auto purge expired role/group members based on server/domain config (#1941)"}, {"oid": "4ab6e748891a014a8b0a1364de099d3fbf4c7468", "committedDate": "2022-09-21 22:22:48 -0700", "message": "enable readWrite db connection for delete expired members (#1964)"}, {"oid": "d4c733d3e97467a598ba44f0bde5c6a907aa01de", "committedDate": "2022-09-23 13:30:24 -0700", "message": "consistent use of The Athenz Authors copyright in all files (#1967)"}, {"oid": "45dcdab92d9e39d5d561b34ef222f863176cc635", "committedDate": "2022-09-26 12:29:01 -0700", "message": "make server purge expiry member day configurable (#1968)"}, {"oid": "d823cccb5163f950655f3859ade41fe031910588", "committedDate": "2022-10-06 14:20:20 -0700", "message": "fix putServiceIdentity logic to allow update of exising pubKey (#1978)"}, {"oid": "91d38ef548e59e29e69349b8a0f5151456b62a0f", "committedDate": "2022-10-07 15:36:36 -0700", "message": "Use correct object type for role member delete notifications (#1981)"}, {"oid": "1d970ce72c2f81aed5576fff068103bbba022aaf", "committedDate": "2022-11-29 23:50:29 +0200", "message": "add gcp project attribute for domains (#2005)"}, {"oid": "c292a1a2fb6e3a300a3060a6bcea6a96f696932c", "committedDate": "2022-12-13 08:56:43 -0800", "message": "Return the correct response from putMembership/putGroupMembership once a pending member was added (#2023)"}, {"oid": "fc5a206d1cb23dd2bbfd9af7e3125ec270ebc022", "committedDate": "2023-01-10 21:48:12 -0800", "message": "allow domain admins to enable audit flag for new roles/groups (#2032)"}, {"oid": "70850ab1de4055e765cf4ead6946b431900ff8c8", "committedDate": "2023-01-23 16:40:36 -0800", "message": "move cloud provider role generation logic out of dbstore library to dbservice (#2043)"}, {"oid": "0ff7ff4f9658fd42e8ee2161d870a89dce5167e4", "committedDate": "2023-02-02 09:18:32 -0800", "message": "Add a requirement for admin approval to delete members in review-enabled roles (#2053)"}, {"oid": "ff57628b890f53c43fec6dd2cacf98a574c95b2d", "committedDate": "2023-02-08 15:55:32 -0800", "message": "extends group with deleteProtection attribute and pending group membe\u2026 (#2067)"}, {"oid": "bb1d69af70a90aeedc28a46604283064e0dad8de", "committedDate": "2023-02-16 07:44:40 -0800", "message": "add audit enable to role (#2055)"}, {"oid": "4ee14d784973ce7da8aba96b35eefdbc5d61d97b", "committedDate": "2023-03-07 11:34:04 -0800", "message": "make aws/gcp assume role action values configurable (#2090)"}, {"oid": "5216da47ef8bca89ba0eae790f72739d9d73fcc6", "committedDate": "2023-03-09 10:36:29 -0800", "message": "Add optional 'description' to role (#2091)"}, {"oid": "d1b98d4614d62fe34b408cfa1a26fb59674d6494", "committedDate": "2023-03-27 16:46:33 -0700", "message": "store GCP project number along with project id in athenz domain metadata (#2113)"}, {"oid": "715cf96c679e817600a0a25160c96878e5eda735", "committedDate": "2023-03-27 18:01:33 -0700", "message": "special resource for gcp starting with service/ (#2115)"}, {"oid": "6e7342a1e98207b87e3eae45341db281b7b3b9c7", "committedDate": "2023-04-13 14:30:39 -0700", "message": "designate separate action for assertions when assuming gcp service accounts (#2127)"}, {"oid": "523f7f753fa2a4a112ae4fb7a5389203af8b9594", "committedDate": "2023-05-29 08:52:21 -0700", "message": "fix role update on expiration and review dates (#2185)"}, {"oid": "7069bf871635c4e5308d37341904241388b1ccda", "committedDate": "2023-05-30 15:31:26 -0700", "message": "support product id (string) format association with domains (#2193)"}, {"oid": "368d0bc139931c03d31824c4f02394b38e3ead95", "committedDate": "2023-06-02 13:15:05 -0700", "message": "support headless user type - managed by user authority but treated like service (#2197)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ2NzY0OA==", "url": "https://github.com/AthenZ/athenz/pull/1157#discussion_r510467648", "body": "complexity of this method seems to me is big so not sure if we have full test coverage. Please run clover and make sure this method is fully covered. I would suggest breaking up into smaller function since then it's easier to mock the tests for edge cases.", "bodyText": "complexity of this method seems to me is big so not sure if we have full test coverage. Please run clover and make sure this method is fully covered. I would suggest breaking up into smaller function since then it's easier to mock the tests for edge cases.", "bodyHTML": "<p dir=\"auto\">complexity of this method seems to me is big so not sure if we have full test coverage. Please run clover and make sure this method is fully covered. I would suggest breaking up into smaller function since then it's easier to mock the tests for edge cases.</p>", "author": "havetisyan", "createdAt": "2020-10-22T21:26:46Z", "path": "servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java", "diffHunk": "@@ -6402,6 +6403,147 @@ void enforceGroupUserAuthorityRestrictions(final String domainName, final String\n         }\n     }\n \n+    /**\n+     * This method returns list of Principals based on the state parameter supplied\n+     * @param queriedState state of principal\n+     * @return List of Principals from DB\n+     */\n+    List<Principal> getPrincipals(int queriedState) {\n+        List<Principal> principals = new ArrayList<>();\n+        Principal principal;\n+        try (ObjectStoreConnection con = store.getConnection(true, false)) {\n+           List<String> dbPrincipals = con.getPrincipals(queriedState);\n+           for (String dbPrincipal : dbPrincipals) {\n+               principal = ZMSUtils.createPrincipalForName(dbPrincipal, zmsConfig.getUserDomain(), null);\n+               ((SimplePrincipal) principal).setState(Principal.State.getState(queriedState));\n+               principals.add(principal);\n+           }\n+        }\n+        return principals;\n+    }\n+\n+    /**\n+     * This method toggles state for supplied Principals based on the flag in DB\n+     * as well as modifies memberships of all roles and groups of current principal(s)\n+     * @param changedPrincipals List of Principals from User Authority\n+     * @param newState new state {@link Principal.State}\n+     */\n+    void updatePrincipalBasedOnAuthorityState(List<Principal> changedPrincipals, Principal.State newState) {", "originalCommit": "45b271a460205ef873d48d4247128daa43779d54", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f2b6979e4235f325d7eea75d6f63d358c03d8d3c", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 2c6958b49..2d11e7268 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6426,121 +6427,120 @@ public class DBService implements RolesProvider {\n      * This method toggles state for supplied Principals based on the flag in DB\n      * as well as modifies memberships of all roles and groups of current principal(s)\n      * @param changedPrincipals List of Principals from User Authority\n-     * @param newState new state {@link Principal.State}\n+     * @param suspended boolean indicating principal's state\n      */\n-    void updatePrincipalBasedOnAuthorityState(List<Principal> changedPrincipals, Principal.State newState) {\n-        final String caller = \"updateMembershipBasedOnUserState\";\n+    void updatePrincipalByStateFromAuthority(List<Principal> changedPrincipals, boolean suspended) {\n+        final String caller = \"updatePrincipalByStateFromAuthority\";\n         List<Principal> updatedUsers = new ArrayList<>();\n-        try (ObjectStoreConnection con = store.getConnection(true, true)) {\n+        if (!changedPrincipals.isEmpty()) {\n+            try (ObjectStoreConnection con = store.getConnection(true, true)) {\n \n-            // first lets update the new state in DB\n-            for (Principal changedPrincipal : changedPrincipals) {\n-                try {\n-                    switch (newState) {\n-                        case ACTIVE:\n-                            if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.ACTIVE.getValue())) {\n-                                updatedUsers.add(changedPrincipal);\n-                            }\n-                            break;\n-                        case AUTHORITY_SYSTEM_DISABLED:\n-                            if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.AUTHORITY_SYSTEM_DISABLED.getValue())) {\n-                                updatedUsers.add(changedPrincipal);\n+                // first lets update the new state in DB\n+                for (Principal changedPrincipal : changedPrincipals) {\n+                    updatePrincipalState(suspended, updatedUsers, con, changedPrincipal);\n+                }\n+                // if new state is updated successfully\n+                // then we need to modify all roles and groups where given principal is member of\n+                if (!updatedUsers.isEmpty()) {\n+                    for (Principal updatedUser : updatedUsers) {\n+                        try {\n+                            updateRoleMembershipsByPrincipalState(suspended, caller, con, updatedUser);\n+                            updateGroupMembershipByPrincipalState(suspended, caller, con, updatedUser);\n+                        } catch (ResourceException ex) {\n+                            if (ex.getCode() == ResourceException.NOT_FOUND) {\n+                                continue;\n                             }\n-                            break;\n-                        default:\n-                            break;\n-                    }\n-                } catch (ResourceException ex) {\n-                    if (ex.getCode() == ResourceException.NOT_FOUND) {\n-                        continue;\n+                            throw ex;\n+                        }\n                     }\n-                    throw ex;\n                 }\n             }\n-            // if new state is updated successfully\n-            // then we need to modify all roles and groups where given principal is member of\n-            if (!updatedUsers.isEmpty()) {\n-\n-                DomainRoleMember domainRoleMember;\n-                DomainGroupMember domainGroupMember;\n-                RoleMember roleMember;\n-                GroupMember groupMember;\n-                List<RoleMember> roleMembersWithUpdatedState;\n-                List<GroupMember> groupMembersWithUpdatedState;\n-                for (Principal updatedUser : updatedUsers) {\n-                    try {\n-                        // get all roles from all domains\n-                        domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n-                        if (!domainRoleMember.getMemberRoles().isEmpty()) {\n-                            for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n-                                roleMember = new RoleMember();\n-                                roleMember.setMemberName(updatedUser.getFullName());\n-                                switch (newState) {\n-                                    case ACTIVE:\n-                                        // if new state is ACTIVE then revert back to previous state for the member\n-                                        roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~newState.getValue());\n-                                        break;\n-                                    case AUTHORITY_SYSTEM_DISABLED:\n-                                        // if new state is SYSTEM_DISABLED then add it on to existing state\n-                                        roleMember.setSystemDisabled(memberRole.getSystemDisabled() | newState.getValue());\n-                                        break;\n-                                    default:\n-                                        break;\n-                                }\n-                                roleMembersWithUpdatedState = new ArrayList<>();\n-                                roleMembersWithUpdatedState.add(roleMember);\n-\n-                                // Following method does Audit entry as well\n-                                if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n-                                        memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-\n-                                    // update our role and domain time-stamps, and invalidate local cache entry\n-                                    con.updateRoleModTimestamp(memberRole.getDomainName(), memberRole.getRoleName());\n-                                    con.updateDomainModTimestamp(memberRole.getDomainName());\n-                                    cacheStore.invalidate(memberRole.getDomainName());\n-                                }\n-                            }\n-                        }\n-                        domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n-                        if (!domainGroupMember.getMemberGroups().isEmpty()) {\n-                            for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n-                                groupMember = new GroupMember();\n-                                groupMember.setMemberName(updatedUser.getFullName());\n-                                switch (newState) {\n-                                    case ACTIVE:\n-                                        // if new state is ACTIVE then revert back to previous state for the member\n-                                        groupMember.setSystemDisabled(currentGroup.getSystemDisabled() & ~newState.getValue());\n-                                        break;\n-                                    case AUTHORITY_SYSTEM_DISABLED:\n-                                        // if new state is SYSTEM_DISABLED then add it on to existing state\n-                                        groupMember.setSystemDisabled(currentGroup.getSystemDisabled() | newState.getValue());\n-                                        break;\n-                                    default:\n-                                        break;\n-                                }\n-                                groupMembersWithUpdatedState = new ArrayList<>();\n-                                groupMembersWithUpdatedState.add(groupMember);\n-\n-                                // Following method does Audit entry as well\n-                                if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n-                                        currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-\n-                                    // update our group and domain time-stamps, and invalidate local cache entry\n-\n-                                    con.updateGroupModTimestamp(currentGroup.getDomainName(), currentGroup.getGroupName());\n-                                    con.updateDomainModTimestamp(currentGroup.getDomainName());\n-                                    cacheStore.invalidate(currentGroup.getDomainName());\n-                                }\n-                            }\n-                        }\n-                    } catch (ResourceException ex) {\n-                        if (ex.getCode() == ResourceException.NOT_FOUND) {\n-                            continue;\n-                        }\n-                        throw ex;\n-                    }\n+        }\n+    }\n+\n+    private void updateGroupMembershipByPrincipalState(boolean suspended, String caller, ObjectStoreConnection con, Principal updatedUser) {\n+        List<GroupMember> groupMembersWithUpdatedState;\n+        GroupMember groupMember;\n+        DomainGroupMember domainGroupMember;\n+        Set<GroupMember> updatedGroups = new HashSet<>();\n+\n+        domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n+        if (!domainGroupMember.getMemberGroups().isEmpty()) {\n+            for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n+                groupMember = new GroupMember();\n+                groupMember.setMemberName(updatedUser.getFullName());\n+                if (suspended) {\n+                    groupMember.setSystemDisabled(currentGroup.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                } else {\n+                    groupMember.setSystemDisabled(currentGroup.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                }\n+                groupMembersWithUpdatedState = new ArrayList<>();\n+                groupMembersWithUpdatedState.add(groupMember);\n+\n+                // Following method does Audit entry as well\n+                if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n+                        currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n+                    updatedGroups.add(currentGroup);\n+                }\n+            }\n+            for (GroupMember updatedGM : updatedGroups) {\n+\n+                // update our group and domain time-stamps, and invalidate local cache entry\n+                con.updateGroupModTimestamp(updatedGM.getDomainName(), updatedGM.getGroupName());\n+                con.updateDomainModTimestamp(updatedGM.getDomainName());\n+                cacheStore.invalidate(updatedGM.getDomainName());\n+            }\n+        }\n+    }\n+\n+    private void updateRoleMembershipsByPrincipalState(boolean suspended, String caller, ObjectStoreConnection con, Principal updatedUser) {\n+        RoleMember roleMember;\n+        List<RoleMember> roleMembersWithUpdatedState;\n+        DomainRoleMember domainRoleMember;\n+        Set<MemberRole> updatedRoles = new HashSet<>();\n+\n+        domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n+        if (!domainRoleMember.getMemberRoles().isEmpty()) {\n+            for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n+                roleMember = new RoleMember();\n+                roleMember.setMemberName(updatedUser.getFullName());\n+                if (suspended) {\n+                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                } else {\n+                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                }\n+                roleMembersWithUpdatedState = new ArrayList<>();\n+                roleMembersWithUpdatedState.add(roleMember);\n+\n+                // Following method does Audit entry as well\n+                if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n+                        memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n+                    updatedRoles.add(memberRole);\n+                }\n+            }\n+            for (MemberRole updatedMR : updatedRoles) {\n+\n+                // update our role and domain time-stamps, and invalidate local cache entry\n+                con.updateRoleModTimestamp(updatedMR.getDomainName(), updatedMR.getRoleName());\n+                con.updateDomainModTimestamp(updatedMR.getDomainName());\n+                cacheStore.invalidate(updatedMR.getDomainName());\n+            }\n+        }\n+    }\n+\n+    private void updatePrincipalState(boolean suspended, List<Principal> updatedUsers, ObjectStoreConnection con, Principal changedPrincipal) {\n+        try {\n+            if (suspended) {\n+                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue())) {\n+                    updatedUsers.add(changedPrincipal);\n+                }\n+            } else {\n+                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.ACTIVE.getValue())) {\n+                    updatedUsers.add(changedPrincipal);\n                 }\n             }\n+        } catch (ResourceException ex) {\n+            LOG.error(\"Exception in updating principal state from Authority {} Moving on.\", ex.getMessage());\n         }\n     }\n \n", "next_change": {"commit": "0dff4be75160c89e9e35b4634db11456460fa25f", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 2d11e7268..08f2ee72e 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6497,50 +6512,29 @@ public class DBService implements RolesProvider {\n         RoleMember roleMember;\n         List<RoleMember> roleMembersWithUpdatedState;\n         DomainRoleMember domainRoleMember;\n-        Set<MemberRole> updatedRoles = new HashSet<>();\n-\n+        int newState;\n+        Set<String> updatedDomains = new HashSet<>();\n         domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n         if (!domainRoleMember.getMemberRoles().isEmpty()) {\n             for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n                 roleMember = new RoleMember();\n                 roleMember.setMemberName(updatedUser.getFullName());\n-                if (suspended) {\n-                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                } else {\n-                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                }\n-                roleMembersWithUpdatedState = new ArrayList<>();\n-                roleMembersWithUpdatedState.add(roleMember);\n+                newState = suspended ? memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n+                        memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n+                roleMember.setSystemDisabled(newState);\n+                roleMembersWithUpdatedState = Collections.singletonList(roleMember);\n \n                 // Following method does Audit entry as well\n                 if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n                         memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-                    updatedRoles.add(memberRole);\n+                    con.updateRoleModTimestamp(memberRole.getDomainName(), memberRole.getRoleName());\n+                    updatedDomains.add(memberRole.getDomainName());\n                 }\n             }\n-            for (MemberRole updatedMR : updatedRoles) {\n-\n-                // update our role and domain time-stamps, and invalidate local cache entry\n-                con.updateRoleModTimestamp(updatedMR.getDomainName(), updatedMR.getRoleName());\n-                con.updateDomainModTimestamp(updatedMR.getDomainName());\n-                cacheStore.invalidate(updatedMR.getDomainName());\n-            }\n-        }\n-    }\n-\n-    private void updatePrincipalState(boolean suspended, List<Principal> updatedUsers, ObjectStoreConnection con, Principal changedPrincipal) {\n-        try {\n-            if (suspended) {\n-                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue())) {\n-                    updatedUsers.add(changedPrincipal);\n-                }\n-            } else {\n-                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.ACTIVE.getValue())) {\n-                    updatedUsers.add(changedPrincipal);\n-                }\n-            }\n-        } catch (ResourceException ex) {\n-            LOG.error(\"Exception in updating principal state from Authority {} Moving on.\", ex.getMessage());\n+            updatedDomains.forEach(dom -> {\n+                con.updateDomainModTimestamp(dom);\n+                cacheStore.invalidate(dom);\n+            });\n         }\n     }\n \n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 2c6958b49..08f2ee72e 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6426,113 +6427,46 @@ public class DBService implements RolesProvider {\n      * This method toggles state for supplied Principals based on the flag in DB\n      * as well as modifies memberships of all roles and groups of current principal(s)\n      * @param changedPrincipals List of Principals from User Authority\n-     * @param newState new state {@link Principal.State}\n+     * @param suspended boolean indicating principal's state\n      */\n-    void updatePrincipalBasedOnAuthorityState(List<Principal> changedPrincipals, Principal.State newState) {\n-        final String caller = \"updateMembershipBasedOnUserState\";\n+    void updatePrincipalByStateFromAuthority(List<Principal> changedPrincipals, boolean suspended) {\n+\n+        if (changedPrincipals.isEmpty()) {\n+            return;\n+        }\n+\n+        final String caller = \"updatePrincipalByStateFromAuthority\";\n         List<Principal> updatedUsers = new ArrayList<>();\n+        int newPrincipalState = suspended ? Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() : Principal.State.ACTIVE.getValue();\n         try (ObjectStoreConnection con = store.getConnection(true, true)) {\n \n             // first lets update the new state in DB\n             for (Principal changedPrincipal : changedPrincipals) {\n                 try {\n-                    switch (newState) {\n-                        case ACTIVE:\n-                            if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.ACTIVE.getValue())) {\n-                                updatedUsers.add(changedPrincipal);\n-                            }\n-                            break;\n-                        case AUTHORITY_SYSTEM_DISABLED:\n-                            if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.AUTHORITY_SYSTEM_DISABLED.getValue())) {\n-                                updatedUsers.add(changedPrincipal);\n-                            }\n-                            break;\n-                        default:\n-                            break;\n+                    if (con.updatePrincipal(changedPrincipal.getFullName(), newPrincipalState)) {\n+                        updatedUsers.add(changedPrincipal);\n                     }\n                 } catch (ResourceException ex) {\n-                    if (ex.getCode() == ResourceException.NOT_FOUND) {\n-                        continue;\n-                    }\n-                    throw ex;\n+                    // log the exception and continue with remaining principals\n+                    LOG.error(\"Exception in updating principal state from Authority {} Moving on.\", ex.getMessage());\n                 }\n             }\n             // if new state is updated successfully\n             // then we need to modify all roles and groups where given principal is member of\n             if (!updatedUsers.isEmpty()) {\n-\n-                DomainRoleMember domainRoleMember;\n-                DomainGroupMember domainGroupMember;\n-                RoleMember roleMember;\n-                GroupMember groupMember;\n-                List<RoleMember> roleMembersWithUpdatedState;\n-                List<GroupMember> groupMembersWithUpdatedState;\n                 for (Principal updatedUser : updatedUsers) {\n+                    // separate try blocks to treat group and role membership 404s separately\n                     try {\n-                        // get all roles from all domains\n-                        domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n-                        if (!domainRoleMember.getMemberRoles().isEmpty()) {\n-                            for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n-                                roleMember = new RoleMember();\n-                                roleMember.setMemberName(updatedUser.getFullName());\n-                                switch (newState) {\n-                                    case ACTIVE:\n-                                        // if new state is ACTIVE then revert back to previous state for the member\n-                                        roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~newState.getValue());\n-                                        break;\n-                                    case AUTHORITY_SYSTEM_DISABLED:\n-                                        // if new state is SYSTEM_DISABLED then add it on to existing state\n-                                        roleMember.setSystemDisabled(memberRole.getSystemDisabled() | newState.getValue());\n-                                        break;\n-                                    default:\n-                                        break;\n-                                }\n-                                roleMembersWithUpdatedState = new ArrayList<>();\n-                                roleMembersWithUpdatedState.add(roleMember);\n-\n-                                // Following method does Audit entry as well\n-                                if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n-                                        memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-\n-                                    // update our role and domain time-stamps, and invalidate local cache entry\n-                                    con.updateRoleModTimestamp(memberRole.getDomainName(), memberRole.getRoleName());\n-                                    con.updateDomainModTimestamp(memberRole.getDomainName());\n-                                    cacheStore.invalidate(memberRole.getDomainName());\n-                                }\n-                            }\n-                        }\n-                        domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n-                        if (!domainGroupMember.getMemberGroups().isEmpty()) {\n-                            for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n-                                groupMember = new GroupMember();\n-                                groupMember.setMemberName(updatedUser.getFullName());\n-                                switch (newState) {\n-                                    case ACTIVE:\n-                                        // if new state is ACTIVE then revert back to previous state for the member\n-                                        groupMember.setSystemDisabled(currentGroup.getSystemDisabled() & ~newState.getValue());\n-                                        break;\n-                                    case AUTHORITY_SYSTEM_DISABLED:\n-                                        // if new state is SYSTEM_DISABLED then add it on to existing state\n-                                        groupMember.setSystemDisabled(currentGroup.getSystemDisabled() | newState.getValue());\n-                                        break;\n-                                    default:\n-                                        break;\n-                                }\n-                                groupMembersWithUpdatedState = new ArrayList<>();\n-                                groupMembersWithUpdatedState.add(groupMember);\n-\n-                                // Following method does Audit entry as well\n-                                if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n-                                        currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-\n-                                    // update our group and domain time-stamps, and invalidate local cache entry\n-\n-                                    con.updateGroupModTimestamp(currentGroup.getDomainName(), currentGroup.getGroupName());\n-                                    con.updateDomainModTimestamp(currentGroup.getDomainName());\n-                                    cacheStore.invalidate(currentGroup.getDomainName());\n-                                }\n-                            }\n+                        updateRoleMembershipsByPrincipalState(suspended, caller, con, updatedUser);\n+                    } catch (ResourceException ex) {\n+                        if (ex.getCode() == ResourceException.NOT_FOUND) {\n+                            continue;\n                         }\n+                        throw ex;\n+                    }\n+                    // separate try blocks to treat group and role membership 404s separately\n+                    try {\n+                        updateGroupMembershipByPrincipalState(suspended, caller, con, updatedUser);\n                     } catch (ResourceException ex) {\n                         if (ex.getCode() == ResourceException.NOT_FOUND) {\n                             continue;\n", "next_change": null}]}, "commits_in_main": [{"oid": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "message": "Merge commit", "committedDate": null}, {"oid": "9a9c82c13d156e06dad8464c3a6c52c8e2bc6b89", "committedDate": "2020-10-26 14:15:03 -0700", "message": "remove sending back deprected members field in roles (#1160)"}, {"oid": "31a0dd7362f585f85992d4ff86fbf975d9d736dd", "committedDate": "2020-10-31 14:59:07 -0700", "message": "add azure_subscription field to domains (#1167)"}, {"oid": "c668f48cec94e2c928581b92ffb517f715a4840f", "committedDate": "2020-11-06 18:05:10 -0800", "message": "handle sys disabled null scenario (#1176)"}, {"oid": "f24d15baaaddc96c85fbceb31fcaded756a69f2e", "committedDate": "2020-11-14 16:51:57 -0800", "message": "role tags - generated code and schema changes (#1179)"}, {"oid": "30e272d8a9ec2649a1d876c1c111cf38e27c1743", "committedDate": "2020-12-07 08:48:58 -0800", "message": "putRoleMeta tags support (#1208)"}, {"oid": "f0e0a91b80250236244db9f8cba79e1def809995", "committedDate": "2020-12-23 15:40:53 -0800", "message": "updating group expiry date (#1221)"}, {"oid": "7a2837c7578ab8d36c62b48ecb1d0079c670616b", "committedDate": "2020-12-29 13:44:04 -0800", "message": "granular authz action for managing role members (#1228)"}, {"oid": "d6a0d659fe96486ffcf31bb93e919656be9eaf89", "committedDate": "2021-01-13 08:15:47 -0800", "message": "domain tags implementation (#1235)"}, {"oid": "3c939966592bf7cc6ff25df12a8d21d4c2c89b2b", "committedDate": "2021-01-19 22:05:22 -0800", "message": "client api update for rich authorization requests and consistent naming of entity objects (#1248)"}, {"oid": "3db6ed7b169fce5bbeaa1fae84ff7881e9a4e435", "committedDate": "2021-01-21 09:17:41 -0800", "message": "limit number of role and domain tags (#1255)"}, {"oid": "218b71958d88fb039dfa6e7c5448c7e4d00cb337", "committedDate": "2021-01-25 17:53:41 -0800", "message": "update domain last modified timestamp after tag update (#1262)"}, {"oid": "bccc5fb4dc1c2407a0293f322c3d97711af4297c", "committedDate": "2021-03-07 18:11:58 -0800", "message": "sonarcloud: method always returns same result (#1329)"}, {"oid": "e421f20094d24075d2cec7ab7adecff7d630a286", "committedDate": "2021-03-16 18:08:03 -0700", "message": "expose new domain attribute: business-service (#1357)"}, {"oid": "7b4afd5d40394226b3aa1af8bf10e90e528091b3", "committedDate": "2021-04-01 14:52:30 -0700", "message": "Add memberExpiryDays and serviceExpiryDays support for groups (#1388)"}, {"oid": "5ab30978cc4fc03e1b3022305f6e14a5a425e9e9", "committedDate": "2021-04-07 16:30:50 -0700", "message": "new DomainMetaStore interface support in ZMS (#1430)"}, {"oid": "9bedde4310d6493406d264422f23e16f33213546", "committedDate": "2021-04-08 09:44:29 -0700", "message": "Add group review days to role (#1428)"}, {"oid": "a554c75c51c5945b0e58ae87866de93ff1d5cfbc", "committedDate": "2021-04-15 12:12:02 -0700", "message": "during provider admin setup, ignore deletes (#1444)"}, {"oid": "1c564548381b3c09ad4214d0f30c667e9cc0d022", "committedDate": "2021-04-30 15:22:51 -0700", "message": "log full policy assertion details during delete operations in audit log (#1469)"}, {"oid": "611ac334bfbc1c43ec20154cf9448b96fae365d6", "committedDate": "2021-05-27 16:30:38 -0700", "message": "handle null contition processDomainTags (#1495)"}, {"oid": "addf4424a5bf842b58558c6f61ac0b46277d9535", "committedDate": "2021-06-07 09:38:12 -0700", "message": "allow role/group review regardless of role/group expiry/reminder settings (#1503)"}, {"oid": "4b39ffbd18da3d10a581fb10209806c97b432d28", "committedDate": "2021-06-09 15:31:17 -0700", "message": "enable role review without setting restrictions (#1512)"}, {"oid": "898ff0aa4fddd1a9ed111496cb9e4acb544605af", "committedDate": "2021-06-14 10:42:10 -0700", "message": "Update Tag Values to include '/', ':' (#1517)"}, {"oid": "cf535673b0a4cbcdc81e17c7def4cb6822edd78c", "committedDate": "2021-06-22 06:44:42 -0700", "message": "Allow system admins to set domain meta attribute business service (#1522)"}, {"oid": "934fc3d7fc859731f4beab3b03b83a15ac717a2d", "committedDate": "2021-06-29 12:57:53 -0700", "message": "assertion condition server changes (#1528)"}, {"oid": "1fa51b852890c1576254be6a8a2b5dbebc89865c", "committedDate": "2021-07-21 14:41:19 -0700", "message": "UI : update error message (#1557)"}, {"oid": "09de45bb794eb5e7c29f705b5ce567c75fde4e84", "committedDate": "2021-07-29 15:49:16 -0700", "message": "multi-version policy - introducing version/active in policy object (#1568)"}, {"oid": "4abff4b9952e4836f79bf3f1934baf8fe2bcebf9", "committedDate": "2021-08-08 11:39:07 -0700", "message": "Disable Reminder Review Notifications By Tag zms.DisableReminderNotifications (#1579)"}, {"oid": "6a1523accc3ec83fe54d78c3d919d9cddbcb1b7e", "committedDate": "2021-08-17 18:32:28 -0700", "message": "fixing the order of updates for assertion condition api operations (#1591)"}, {"oid": "66590f4fc47f899f3990f20895f953074e40f259", "committedDate": "2021-09-10 07:55:42 -0700", "message": "Implement multi-version policies endpoints (#1605)"}, {"oid": "1ad624427917493d31bd1b8ffa6303c4d6353055", "committedDate": "2021-09-10 13:51:19 -0700", "message": "update group last modified when user is deleted (#1613)"}, {"oid": "91b116418656f123dae9a3405cb2e498d4d3aff4", "committedDate": "2021-09-12 09:52:05 +0300", "message": "additional validation checks when processing versioned policies (#1614)"}, {"oid": "2531428956f87774f86721f02b430861ca8897ec", "committedDate": "2021-09-14 09:49:34 +0300", "message": "additional checks when setting a policy version as active (#1615)"}, {"oid": "2968c209e870ce57fbdb1fb048a21692d80cfea6", "committedDate": "2021-10-01 07:25:34 -0700", "message": "rdl publishChangeEvents generator (#1624)"}, {"oid": "8a6960ce9878277c5abda1d104ca070831b36230", "committedDate": "2021-10-03 13:48:03 -0700", "message": "Allow specifying version name when creating new policy (#1630)"}, {"oid": "43f619b31bbd9cc3d388aa7ea29eff889cb1272d", "committedDate": "2021-10-21 08:48:51 -0700", "message": "For role expiry notification - record metrics daily while (#1654)"}, {"oid": "389f984270d7d89070c66096e87fafbcb24a261c", "committedDate": "2021-10-26 08:17:36 -0700", "message": "Group tags implementation (#1660)"}, {"oid": "120ab1fa8e9d33fa793c4254d233a09a2c23d173", "committedDate": "2021-10-29 15:08:28 -0700", "message": "Disable Group Expiry Notifications By Tag zms.DisableReminderNotifications (#1663)"}, {"oid": "1400363e8d698cf08370c89752077ebae043c5be", "committedDate": "2021-12-14 13:48:34 -0800", "message": "correct logging of role principal in audit/access logs"}, {"oid": "c8e3a5c91c5deb9640576cd3496a2af11d572f0b", "committedDate": "2021-12-23 15:03:25 -0800", "message": "protect system admin users from being removed from deleteUser api (#1715)"}, {"oid": "020e06e57b357768260f509f08b75c5c068bce53", "committedDate": "2022-02-07 08:01:55 -0800", "message": "Service Visiblity - Domain Dependencies (#1758)"}, {"oid": "fcbd4128e334a9a42f4579d179cf9578d3f4de99", "committedDate": "2022-02-07 10:12:47 -0800", "message": "support new get-stats endpoint to get per-domain/system stats (#1774)"}, {"oid": "ea831a34a70a0475bea8754cb183741dced98ff2", "committedDate": "2022-02-18 09:17:55 -0800", "message": "update pending member api to support getting list for a domain (#1783)"}, {"oid": "f4229124e8e1898810c7aa7b3a4eff37fddae308", "committedDate": "2022-02-18 12:37:32 -0800", "message": "provide option to skip adding principal when onboarding a resource group (#1787)"}, {"oid": "9081feb4c06a1058c941c67923037203d9318cfa", "committedDate": "2022-02-27 14:10:46 -0800", "message": "Domain Dependency for Tenancy (#1789)"}, {"oid": "a5bb615881583fa6f39621e2ea3bf39d3886340b", "committedDate": "2022-03-03 17:20:00 -0800", "message": "extend template keyword support trust field in roles (#1803)"}, {"oid": "3de182bcbedba89fa2aaba12ab9be49aa2156096", "committedDate": "2022-03-19 09:45:40 -0700", "message": "Add provider webhook for verifying removal (#1816)"}, {"oid": "1b0cff1cb9b8e4a231c5cfb342d76b6aad8e08fc", "committedDate": "2022-04-07 14:34:23 -0700", "message": "no need to update domain's last mod timestamp during put dependency call (#1846)"}, {"oid": "baa68eacd6a6b9bbc70c3423006f92cd47b784d7", "committedDate": "2022-05-19 09:30:02 -0700", "message": "Get Auth History implementation (#1875)"}, {"oid": "bea97b165e28b5b2cc286af62c92e536c9fc3ff2", "committedDate": "2022-06-03 13:50:01 -0700", "message": "AuthHistory - Return dependencies instead of list (#1888)"}, {"oid": "7a313e1d581295ae6c786bbc2ed73bb14da37f7d", "committedDate": "2022-07-21 20:16:24 -0700", "message": "allow management of domain memberPurgeExpiryDays setting value (#1928)"}, {"oid": "f288ed7afb018bc07af02dbe9dc8e05ec0896071", "committedDate": "2022-08-15 22:28:01 -0700", "message": "provide header option to return updated object in response (#1942)"}, {"oid": "949bd0634d328d04736b912a002bdfa7421d9f2b", "committedDate": "2022-08-23 10:28:38 -0700", "message": "fix returning role/group objects when requested by ui (#1945)"}, {"oid": "ab7284c9274f4949d23f88ec0dde7b689c0c6980", "committedDate": "2022-09-05 13:12:17 -0700", "message": "auto purge expired role/group members based on server/domain config (#1941)"}, {"oid": "4ab6e748891a014a8b0a1364de099d3fbf4c7468", "committedDate": "2022-09-21 22:22:48 -0700", "message": "enable readWrite db connection for delete expired members (#1964)"}, {"oid": "d4c733d3e97467a598ba44f0bde5c6a907aa01de", "committedDate": "2022-09-23 13:30:24 -0700", "message": "consistent use of The Athenz Authors copyright in all files (#1967)"}, {"oid": "45dcdab92d9e39d5d561b34ef222f863176cc635", "committedDate": "2022-09-26 12:29:01 -0700", "message": "make server purge expiry member day configurable (#1968)"}, {"oid": "d823cccb5163f950655f3859ade41fe031910588", "committedDate": "2022-10-06 14:20:20 -0700", "message": "fix putServiceIdentity logic to allow update of exising pubKey (#1978)"}, {"oid": "91d38ef548e59e29e69349b8a0f5151456b62a0f", "committedDate": "2022-10-07 15:36:36 -0700", "message": "Use correct object type for role member delete notifications (#1981)"}, {"oid": "1d970ce72c2f81aed5576fff068103bbba022aaf", "committedDate": "2022-11-29 23:50:29 +0200", "message": "add gcp project attribute for domains (#2005)"}, {"oid": "c292a1a2fb6e3a300a3060a6bcea6a96f696932c", "committedDate": "2022-12-13 08:56:43 -0800", "message": "Return the correct response from putMembership/putGroupMembership once a pending member was added (#2023)"}, {"oid": "fc5a206d1cb23dd2bbfd9af7e3125ec270ebc022", "committedDate": "2023-01-10 21:48:12 -0800", "message": "allow domain admins to enable audit flag for new roles/groups (#2032)"}, {"oid": "70850ab1de4055e765cf4ead6946b431900ff8c8", "committedDate": "2023-01-23 16:40:36 -0800", "message": "move cloud provider role generation logic out of dbstore library to dbservice (#2043)"}, {"oid": "0ff7ff4f9658fd42e8ee2161d870a89dce5167e4", "committedDate": "2023-02-02 09:18:32 -0800", "message": "Add a requirement for admin approval to delete members in review-enabled roles (#2053)"}, {"oid": "ff57628b890f53c43fec6dd2cacf98a574c95b2d", "committedDate": "2023-02-08 15:55:32 -0800", "message": "extends group with deleteProtection attribute and pending group membe\u2026 (#2067)"}, {"oid": "bb1d69af70a90aeedc28a46604283064e0dad8de", "committedDate": "2023-02-16 07:44:40 -0800", "message": "add audit enable to role (#2055)"}, {"oid": "4ee14d784973ce7da8aba96b35eefdbc5d61d97b", "committedDate": "2023-03-07 11:34:04 -0800", "message": "make aws/gcp assume role action values configurable (#2090)"}, {"oid": "5216da47ef8bca89ba0eae790f72739d9d73fcc6", "committedDate": "2023-03-09 10:36:29 -0800", "message": "Add optional 'description' to role (#2091)"}, {"oid": "d1b98d4614d62fe34b408cfa1a26fb59674d6494", "committedDate": "2023-03-27 16:46:33 -0700", "message": "store GCP project number along with project id in athenz domain metadata (#2113)"}, {"oid": "715cf96c679e817600a0a25160c96878e5eda735", "committedDate": "2023-03-27 18:01:33 -0700", "message": "special resource for gcp starting with service/ (#2115)"}, {"oid": "6e7342a1e98207b87e3eae45341db281b7b3b9c7", "committedDate": "2023-04-13 14:30:39 -0700", "message": "designate separate action for assertions when assuming gcp service accounts (#2127)"}, {"oid": "523f7f753fa2a4a112ae4fb7a5389203af8b9594", "committedDate": "2023-05-29 08:52:21 -0700", "message": "fix role update on expiration and review dates (#2185)"}, {"oid": "7069bf871635c4e5308d37341904241388b1ccda", "committedDate": "2023-05-30 15:31:26 -0700", "message": "support product id (string) format association with domains (#2193)"}, {"oid": "368d0bc139931c03d31824c4f02394b38e3ead95", "committedDate": "2023-06-02 13:15:05 -0700", "message": "support headless user type - managed by user authority but treated like service (#2197)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ2ODYzNg==", "url": "https://github.com/AthenZ/athenz/pull/1157#discussion_r510468636", "body": "we should check if our list is not empty before doing anything at the beginning of the method otherwise we're just wasting get sql connection.  ", "bodyText": "we should check if our list is not empty before doing anything at the beginning of the method otherwise we're just wasting get sql connection.", "bodyHTML": "<p dir=\"auto\">we should check if our list is not empty before doing anything at the beginning of the method otherwise we're just wasting get sql connection.</p>", "author": "havetisyan", "createdAt": "2020-10-22T21:28:56Z", "path": "servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java", "diffHunk": "@@ -6402,6 +6403,147 @@ void enforceGroupUserAuthorityRestrictions(final String domainName, final String\n         }\n     }\n \n+    /**\n+     * This method returns list of Principals based on the state parameter supplied\n+     * @param queriedState state of principal\n+     * @return List of Principals from DB\n+     */\n+    List<Principal> getPrincipals(int queriedState) {\n+        List<Principal> principals = new ArrayList<>();\n+        Principal principal;\n+        try (ObjectStoreConnection con = store.getConnection(true, false)) {\n+           List<String> dbPrincipals = con.getPrincipals(queriedState);\n+           for (String dbPrincipal : dbPrincipals) {\n+               principal = ZMSUtils.createPrincipalForName(dbPrincipal, zmsConfig.getUserDomain(), null);\n+               ((SimplePrincipal) principal).setState(Principal.State.getState(queriedState));\n+               principals.add(principal);\n+           }\n+        }\n+        return principals;\n+    }\n+\n+    /**\n+     * This method toggles state for supplied Principals based on the flag in DB\n+     * as well as modifies memberships of all roles and groups of current principal(s)\n+     * @param changedPrincipals List of Principals from User Authority\n+     * @param newState new state {@link Principal.State}\n+     */\n+    void updatePrincipalBasedOnAuthorityState(List<Principal> changedPrincipals, Principal.State newState) {\n+        final String caller = \"updateMembershipBasedOnUserState\";\n+        List<Principal> updatedUsers = new ArrayList<>();\n+        try (ObjectStoreConnection con = store.getConnection(true, true)) {\n+\n+            // first lets update the new state in DB\n+            for (Principal changedPrincipal : changedPrincipals) {", "originalCommit": "45b271a460205ef873d48d4247128daa43779d54", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f2b6979e4235f325d7eea75d6f63d358c03d8d3c", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 2c6958b49..2d11e7268 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6426,121 +6427,120 @@ public class DBService implements RolesProvider {\n      * This method toggles state for supplied Principals based on the flag in DB\n      * as well as modifies memberships of all roles and groups of current principal(s)\n      * @param changedPrincipals List of Principals from User Authority\n-     * @param newState new state {@link Principal.State}\n+     * @param suspended boolean indicating principal's state\n      */\n-    void updatePrincipalBasedOnAuthorityState(List<Principal> changedPrincipals, Principal.State newState) {\n-        final String caller = \"updateMembershipBasedOnUserState\";\n+    void updatePrincipalByStateFromAuthority(List<Principal> changedPrincipals, boolean suspended) {\n+        final String caller = \"updatePrincipalByStateFromAuthority\";\n         List<Principal> updatedUsers = new ArrayList<>();\n-        try (ObjectStoreConnection con = store.getConnection(true, true)) {\n+        if (!changedPrincipals.isEmpty()) {\n+            try (ObjectStoreConnection con = store.getConnection(true, true)) {\n \n-            // first lets update the new state in DB\n-            for (Principal changedPrincipal : changedPrincipals) {\n-                try {\n-                    switch (newState) {\n-                        case ACTIVE:\n-                            if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.ACTIVE.getValue())) {\n-                                updatedUsers.add(changedPrincipal);\n-                            }\n-                            break;\n-                        case AUTHORITY_SYSTEM_DISABLED:\n-                            if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.AUTHORITY_SYSTEM_DISABLED.getValue())) {\n-                                updatedUsers.add(changedPrincipal);\n+                // first lets update the new state in DB\n+                for (Principal changedPrincipal : changedPrincipals) {\n+                    updatePrincipalState(suspended, updatedUsers, con, changedPrincipal);\n+                }\n+                // if new state is updated successfully\n+                // then we need to modify all roles and groups where given principal is member of\n+                if (!updatedUsers.isEmpty()) {\n+                    for (Principal updatedUser : updatedUsers) {\n+                        try {\n+                            updateRoleMembershipsByPrincipalState(suspended, caller, con, updatedUser);\n+                            updateGroupMembershipByPrincipalState(suspended, caller, con, updatedUser);\n+                        } catch (ResourceException ex) {\n+                            if (ex.getCode() == ResourceException.NOT_FOUND) {\n+                                continue;\n                             }\n-                            break;\n-                        default:\n-                            break;\n-                    }\n-                } catch (ResourceException ex) {\n-                    if (ex.getCode() == ResourceException.NOT_FOUND) {\n-                        continue;\n+                            throw ex;\n+                        }\n                     }\n-                    throw ex;\n                 }\n             }\n-            // if new state is updated successfully\n-            // then we need to modify all roles and groups where given principal is member of\n-            if (!updatedUsers.isEmpty()) {\n-\n-                DomainRoleMember domainRoleMember;\n-                DomainGroupMember domainGroupMember;\n-                RoleMember roleMember;\n-                GroupMember groupMember;\n-                List<RoleMember> roleMembersWithUpdatedState;\n-                List<GroupMember> groupMembersWithUpdatedState;\n-                for (Principal updatedUser : updatedUsers) {\n-                    try {\n-                        // get all roles from all domains\n-                        domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n-                        if (!domainRoleMember.getMemberRoles().isEmpty()) {\n-                            for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n-                                roleMember = new RoleMember();\n-                                roleMember.setMemberName(updatedUser.getFullName());\n-                                switch (newState) {\n-                                    case ACTIVE:\n-                                        // if new state is ACTIVE then revert back to previous state for the member\n-                                        roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~newState.getValue());\n-                                        break;\n-                                    case AUTHORITY_SYSTEM_DISABLED:\n-                                        // if new state is SYSTEM_DISABLED then add it on to existing state\n-                                        roleMember.setSystemDisabled(memberRole.getSystemDisabled() | newState.getValue());\n-                                        break;\n-                                    default:\n-                                        break;\n-                                }\n-                                roleMembersWithUpdatedState = new ArrayList<>();\n-                                roleMembersWithUpdatedState.add(roleMember);\n-\n-                                // Following method does Audit entry as well\n-                                if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n-                                        memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-\n-                                    // update our role and domain time-stamps, and invalidate local cache entry\n-                                    con.updateRoleModTimestamp(memberRole.getDomainName(), memberRole.getRoleName());\n-                                    con.updateDomainModTimestamp(memberRole.getDomainName());\n-                                    cacheStore.invalidate(memberRole.getDomainName());\n-                                }\n-                            }\n-                        }\n-                        domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n-                        if (!domainGroupMember.getMemberGroups().isEmpty()) {\n-                            for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n-                                groupMember = new GroupMember();\n-                                groupMember.setMemberName(updatedUser.getFullName());\n-                                switch (newState) {\n-                                    case ACTIVE:\n-                                        // if new state is ACTIVE then revert back to previous state for the member\n-                                        groupMember.setSystemDisabled(currentGroup.getSystemDisabled() & ~newState.getValue());\n-                                        break;\n-                                    case AUTHORITY_SYSTEM_DISABLED:\n-                                        // if new state is SYSTEM_DISABLED then add it on to existing state\n-                                        groupMember.setSystemDisabled(currentGroup.getSystemDisabled() | newState.getValue());\n-                                        break;\n-                                    default:\n-                                        break;\n-                                }\n-                                groupMembersWithUpdatedState = new ArrayList<>();\n-                                groupMembersWithUpdatedState.add(groupMember);\n-\n-                                // Following method does Audit entry as well\n-                                if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n-                                        currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-\n-                                    // update our group and domain time-stamps, and invalidate local cache entry\n-\n-                                    con.updateGroupModTimestamp(currentGroup.getDomainName(), currentGroup.getGroupName());\n-                                    con.updateDomainModTimestamp(currentGroup.getDomainName());\n-                                    cacheStore.invalidate(currentGroup.getDomainName());\n-                                }\n-                            }\n-                        }\n-                    } catch (ResourceException ex) {\n-                        if (ex.getCode() == ResourceException.NOT_FOUND) {\n-                            continue;\n-                        }\n-                        throw ex;\n-                    }\n+        }\n+    }\n+\n+    private void updateGroupMembershipByPrincipalState(boolean suspended, String caller, ObjectStoreConnection con, Principal updatedUser) {\n+        List<GroupMember> groupMembersWithUpdatedState;\n+        GroupMember groupMember;\n+        DomainGroupMember domainGroupMember;\n+        Set<GroupMember> updatedGroups = new HashSet<>();\n+\n+        domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n+        if (!domainGroupMember.getMemberGroups().isEmpty()) {\n+            for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n+                groupMember = new GroupMember();\n+                groupMember.setMemberName(updatedUser.getFullName());\n+                if (suspended) {\n+                    groupMember.setSystemDisabled(currentGroup.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                } else {\n+                    groupMember.setSystemDisabled(currentGroup.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                }\n+                groupMembersWithUpdatedState = new ArrayList<>();\n+                groupMembersWithUpdatedState.add(groupMember);\n+\n+                // Following method does Audit entry as well\n+                if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n+                        currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n+                    updatedGroups.add(currentGroup);\n+                }\n+            }\n+            for (GroupMember updatedGM : updatedGroups) {\n+\n+                // update our group and domain time-stamps, and invalidate local cache entry\n+                con.updateGroupModTimestamp(updatedGM.getDomainName(), updatedGM.getGroupName());\n+                con.updateDomainModTimestamp(updatedGM.getDomainName());\n+                cacheStore.invalidate(updatedGM.getDomainName());\n+            }\n+        }\n+    }\n+\n+    private void updateRoleMembershipsByPrincipalState(boolean suspended, String caller, ObjectStoreConnection con, Principal updatedUser) {\n+        RoleMember roleMember;\n+        List<RoleMember> roleMembersWithUpdatedState;\n+        DomainRoleMember domainRoleMember;\n+        Set<MemberRole> updatedRoles = new HashSet<>();\n+\n+        domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n+        if (!domainRoleMember.getMemberRoles().isEmpty()) {\n+            for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n+                roleMember = new RoleMember();\n+                roleMember.setMemberName(updatedUser.getFullName());\n+                if (suspended) {\n+                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                } else {\n+                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                }\n+                roleMembersWithUpdatedState = new ArrayList<>();\n+                roleMembersWithUpdatedState.add(roleMember);\n+\n+                // Following method does Audit entry as well\n+                if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n+                        memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n+                    updatedRoles.add(memberRole);\n+                }\n+            }\n+            for (MemberRole updatedMR : updatedRoles) {\n+\n+                // update our role and domain time-stamps, and invalidate local cache entry\n+                con.updateRoleModTimestamp(updatedMR.getDomainName(), updatedMR.getRoleName());\n+                con.updateDomainModTimestamp(updatedMR.getDomainName());\n+                cacheStore.invalidate(updatedMR.getDomainName());\n+            }\n+        }\n+    }\n+\n+    private void updatePrincipalState(boolean suspended, List<Principal> updatedUsers, ObjectStoreConnection con, Principal changedPrincipal) {\n+        try {\n+            if (suspended) {\n+                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue())) {\n+                    updatedUsers.add(changedPrincipal);\n+                }\n+            } else {\n+                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.ACTIVE.getValue())) {\n+                    updatedUsers.add(changedPrincipal);\n                 }\n             }\n+        } catch (ResourceException ex) {\n+            LOG.error(\"Exception in updating principal state from Authority {} Moving on.\", ex.getMessage());\n         }\n     }\n \n", "next_change": {"commit": "0dff4be75160c89e9e35b4634db11456460fa25f", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 2d11e7268..08f2ee72e 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6497,50 +6512,29 @@ public class DBService implements RolesProvider {\n         RoleMember roleMember;\n         List<RoleMember> roleMembersWithUpdatedState;\n         DomainRoleMember domainRoleMember;\n-        Set<MemberRole> updatedRoles = new HashSet<>();\n-\n+        int newState;\n+        Set<String> updatedDomains = new HashSet<>();\n         domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n         if (!domainRoleMember.getMemberRoles().isEmpty()) {\n             for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n                 roleMember = new RoleMember();\n                 roleMember.setMemberName(updatedUser.getFullName());\n-                if (suspended) {\n-                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                } else {\n-                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                }\n-                roleMembersWithUpdatedState = new ArrayList<>();\n-                roleMembersWithUpdatedState.add(roleMember);\n+                newState = suspended ? memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n+                        memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n+                roleMember.setSystemDisabled(newState);\n+                roleMembersWithUpdatedState = Collections.singletonList(roleMember);\n \n                 // Following method does Audit entry as well\n                 if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n                         memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-                    updatedRoles.add(memberRole);\n+                    con.updateRoleModTimestamp(memberRole.getDomainName(), memberRole.getRoleName());\n+                    updatedDomains.add(memberRole.getDomainName());\n                 }\n             }\n-            for (MemberRole updatedMR : updatedRoles) {\n-\n-                // update our role and domain time-stamps, and invalidate local cache entry\n-                con.updateRoleModTimestamp(updatedMR.getDomainName(), updatedMR.getRoleName());\n-                con.updateDomainModTimestamp(updatedMR.getDomainName());\n-                cacheStore.invalidate(updatedMR.getDomainName());\n-            }\n-        }\n-    }\n-\n-    private void updatePrincipalState(boolean suspended, List<Principal> updatedUsers, ObjectStoreConnection con, Principal changedPrincipal) {\n-        try {\n-            if (suspended) {\n-                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue())) {\n-                    updatedUsers.add(changedPrincipal);\n-                }\n-            } else {\n-                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.ACTIVE.getValue())) {\n-                    updatedUsers.add(changedPrincipal);\n-                }\n-            }\n-        } catch (ResourceException ex) {\n-            LOG.error(\"Exception in updating principal state from Authority {} Moving on.\", ex.getMessage());\n+            updatedDomains.forEach(dom -> {\n+                con.updateDomainModTimestamp(dom);\n+                cacheStore.invalidate(dom);\n+            });\n         }\n     }\n \n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 2c6958b49..08f2ee72e 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6426,113 +6427,46 @@ public class DBService implements RolesProvider {\n      * This method toggles state for supplied Principals based on the flag in DB\n      * as well as modifies memberships of all roles and groups of current principal(s)\n      * @param changedPrincipals List of Principals from User Authority\n-     * @param newState new state {@link Principal.State}\n+     * @param suspended boolean indicating principal's state\n      */\n-    void updatePrincipalBasedOnAuthorityState(List<Principal> changedPrincipals, Principal.State newState) {\n-        final String caller = \"updateMembershipBasedOnUserState\";\n+    void updatePrincipalByStateFromAuthority(List<Principal> changedPrincipals, boolean suspended) {\n+\n+        if (changedPrincipals.isEmpty()) {\n+            return;\n+        }\n+\n+        final String caller = \"updatePrincipalByStateFromAuthority\";\n         List<Principal> updatedUsers = new ArrayList<>();\n+        int newPrincipalState = suspended ? Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() : Principal.State.ACTIVE.getValue();\n         try (ObjectStoreConnection con = store.getConnection(true, true)) {\n \n             // first lets update the new state in DB\n             for (Principal changedPrincipal : changedPrincipals) {\n                 try {\n-                    switch (newState) {\n-                        case ACTIVE:\n-                            if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.ACTIVE.getValue())) {\n-                                updatedUsers.add(changedPrincipal);\n-                            }\n-                            break;\n-                        case AUTHORITY_SYSTEM_DISABLED:\n-                            if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.AUTHORITY_SYSTEM_DISABLED.getValue())) {\n-                                updatedUsers.add(changedPrincipal);\n-                            }\n-                            break;\n-                        default:\n-                            break;\n+                    if (con.updatePrincipal(changedPrincipal.getFullName(), newPrincipalState)) {\n+                        updatedUsers.add(changedPrincipal);\n                     }\n                 } catch (ResourceException ex) {\n-                    if (ex.getCode() == ResourceException.NOT_FOUND) {\n-                        continue;\n-                    }\n-                    throw ex;\n+                    // log the exception and continue with remaining principals\n+                    LOG.error(\"Exception in updating principal state from Authority {} Moving on.\", ex.getMessage());\n                 }\n             }\n             // if new state is updated successfully\n             // then we need to modify all roles and groups where given principal is member of\n             if (!updatedUsers.isEmpty()) {\n-\n-                DomainRoleMember domainRoleMember;\n-                DomainGroupMember domainGroupMember;\n-                RoleMember roleMember;\n-                GroupMember groupMember;\n-                List<RoleMember> roleMembersWithUpdatedState;\n-                List<GroupMember> groupMembersWithUpdatedState;\n                 for (Principal updatedUser : updatedUsers) {\n+                    // separate try blocks to treat group and role membership 404s separately\n                     try {\n-                        // get all roles from all domains\n-                        domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n-                        if (!domainRoleMember.getMemberRoles().isEmpty()) {\n-                            for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n-                                roleMember = new RoleMember();\n-                                roleMember.setMemberName(updatedUser.getFullName());\n-                                switch (newState) {\n-                                    case ACTIVE:\n-                                        // if new state is ACTIVE then revert back to previous state for the member\n-                                        roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~newState.getValue());\n-                                        break;\n-                                    case AUTHORITY_SYSTEM_DISABLED:\n-                                        // if new state is SYSTEM_DISABLED then add it on to existing state\n-                                        roleMember.setSystemDisabled(memberRole.getSystemDisabled() | newState.getValue());\n-                                        break;\n-                                    default:\n-                                        break;\n-                                }\n-                                roleMembersWithUpdatedState = new ArrayList<>();\n-                                roleMembersWithUpdatedState.add(roleMember);\n-\n-                                // Following method does Audit entry as well\n-                                if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n-                                        memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-\n-                                    // update our role and domain time-stamps, and invalidate local cache entry\n-                                    con.updateRoleModTimestamp(memberRole.getDomainName(), memberRole.getRoleName());\n-                                    con.updateDomainModTimestamp(memberRole.getDomainName());\n-                                    cacheStore.invalidate(memberRole.getDomainName());\n-                                }\n-                            }\n-                        }\n-                        domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n-                        if (!domainGroupMember.getMemberGroups().isEmpty()) {\n-                            for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n-                                groupMember = new GroupMember();\n-                                groupMember.setMemberName(updatedUser.getFullName());\n-                                switch (newState) {\n-                                    case ACTIVE:\n-                                        // if new state is ACTIVE then revert back to previous state for the member\n-                                        groupMember.setSystemDisabled(currentGroup.getSystemDisabled() & ~newState.getValue());\n-                                        break;\n-                                    case AUTHORITY_SYSTEM_DISABLED:\n-                                        // if new state is SYSTEM_DISABLED then add it on to existing state\n-                                        groupMember.setSystemDisabled(currentGroup.getSystemDisabled() | newState.getValue());\n-                                        break;\n-                                    default:\n-                                        break;\n-                                }\n-                                groupMembersWithUpdatedState = new ArrayList<>();\n-                                groupMembersWithUpdatedState.add(groupMember);\n-\n-                                // Following method does Audit entry as well\n-                                if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n-                                        currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-\n-                                    // update our group and domain time-stamps, and invalidate local cache entry\n-\n-                                    con.updateGroupModTimestamp(currentGroup.getDomainName(), currentGroup.getGroupName());\n-                                    con.updateDomainModTimestamp(currentGroup.getDomainName());\n-                                    cacheStore.invalidate(currentGroup.getDomainName());\n-                                }\n-                            }\n+                        updateRoleMembershipsByPrincipalState(suspended, caller, con, updatedUser);\n+                    } catch (ResourceException ex) {\n+                        if (ex.getCode() == ResourceException.NOT_FOUND) {\n+                            continue;\n                         }\n+                        throw ex;\n+                    }\n+                    // separate try blocks to treat group and role membership 404s separately\n+                    try {\n+                        updateGroupMembershipByPrincipalState(suspended, caller, con, updatedUser);\n                     } catch (ResourceException ex) {\n                         if (ex.getCode() == ResourceException.NOT_FOUND) {\n                             continue;\n", "next_change": null}]}, "commits_in_main": [{"oid": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "message": "Merge commit", "committedDate": null}, {"oid": "9a9c82c13d156e06dad8464c3a6c52c8e2bc6b89", "committedDate": "2020-10-26 14:15:03 -0700", "message": "remove sending back deprected members field in roles (#1160)"}, {"oid": "31a0dd7362f585f85992d4ff86fbf975d9d736dd", "committedDate": "2020-10-31 14:59:07 -0700", "message": "add azure_subscription field to domains (#1167)"}, {"oid": "c668f48cec94e2c928581b92ffb517f715a4840f", "committedDate": "2020-11-06 18:05:10 -0800", "message": "handle sys disabled null scenario (#1176)"}, {"oid": "f24d15baaaddc96c85fbceb31fcaded756a69f2e", "committedDate": "2020-11-14 16:51:57 -0800", "message": "role tags - generated code and schema changes (#1179)"}, {"oid": "30e272d8a9ec2649a1d876c1c111cf38e27c1743", "committedDate": "2020-12-07 08:48:58 -0800", "message": "putRoleMeta tags support (#1208)"}, {"oid": "f0e0a91b80250236244db9f8cba79e1def809995", "committedDate": "2020-12-23 15:40:53 -0800", "message": "updating group expiry date (#1221)"}, {"oid": "7a2837c7578ab8d36c62b48ecb1d0079c670616b", "committedDate": "2020-12-29 13:44:04 -0800", "message": "granular authz action for managing role members (#1228)"}, {"oid": "d6a0d659fe96486ffcf31bb93e919656be9eaf89", "committedDate": "2021-01-13 08:15:47 -0800", "message": "domain tags implementation (#1235)"}, {"oid": "3c939966592bf7cc6ff25df12a8d21d4c2c89b2b", "committedDate": "2021-01-19 22:05:22 -0800", "message": "client api update for rich authorization requests and consistent naming of entity objects (#1248)"}, {"oid": "3db6ed7b169fce5bbeaa1fae84ff7881e9a4e435", "committedDate": "2021-01-21 09:17:41 -0800", "message": "limit number of role and domain tags (#1255)"}, {"oid": "218b71958d88fb039dfa6e7c5448c7e4d00cb337", "committedDate": "2021-01-25 17:53:41 -0800", "message": "update domain last modified timestamp after tag update (#1262)"}, {"oid": "bccc5fb4dc1c2407a0293f322c3d97711af4297c", "committedDate": "2021-03-07 18:11:58 -0800", "message": "sonarcloud: method always returns same result (#1329)"}, {"oid": "e421f20094d24075d2cec7ab7adecff7d630a286", "committedDate": "2021-03-16 18:08:03 -0700", "message": "expose new domain attribute: business-service (#1357)"}, {"oid": "7b4afd5d40394226b3aa1af8bf10e90e528091b3", "committedDate": "2021-04-01 14:52:30 -0700", "message": "Add memberExpiryDays and serviceExpiryDays support for groups (#1388)"}, {"oid": "5ab30978cc4fc03e1b3022305f6e14a5a425e9e9", "committedDate": "2021-04-07 16:30:50 -0700", "message": "new DomainMetaStore interface support in ZMS (#1430)"}, {"oid": "9bedde4310d6493406d264422f23e16f33213546", "committedDate": "2021-04-08 09:44:29 -0700", "message": "Add group review days to role (#1428)"}, {"oid": "a554c75c51c5945b0e58ae87866de93ff1d5cfbc", "committedDate": "2021-04-15 12:12:02 -0700", "message": "during provider admin setup, ignore deletes (#1444)"}, {"oid": "1c564548381b3c09ad4214d0f30c667e9cc0d022", "committedDate": "2021-04-30 15:22:51 -0700", "message": "log full policy assertion details during delete operations in audit log (#1469)"}, {"oid": "611ac334bfbc1c43ec20154cf9448b96fae365d6", "committedDate": "2021-05-27 16:30:38 -0700", "message": "handle null contition processDomainTags (#1495)"}, {"oid": "addf4424a5bf842b58558c6f61ac0b46277d9535", "committedDate": "2021-06-07 09:38:12 -0700", "message": "allow role/group review regardless of role/group expiry/reminder settings (#1503)"}, {"oid": "4b39ffbd18da3d10a581fb10209806c97b432d28", "committedDate": "2021-06-09 15:31:17 -0700", "message": "enable role review without setting restrictions (#1512)"}, {"oid": "898ff0aa4fddd1a9ed111496cb9e4acb544605af", "committedDate": "2021-06-14 10:42:10 -0700", "message": "Update Tag Values to include '/', ':' (#1517)"}, {"oid": "cf535673b0a4cbcdc81e17c7def4cb6822edd78c", "committedDate": "2021-06-22 06:44:42 -0700", "message": "Allow system admins to set domain meta attribute business service (#1522)"}, {"oid": "934fc3d7fc859731f4beab3b03b83a15ac717a2d", "committedDate": "2021-06-29 12:57:53 -0700", "message": "assertion condition server changes (#1528)"}, {"oid": "1fa51b852890c1576254be6a8a2b5dbebc89865c", "committedDate": "2021-07-21 14:41:19 -0700", "message": "UI : update error message (#1557)"}, {"oid": "09de45bb794eb5e7c29f705b5ce567c75fde4e84", "committedDate": "2021-07-29 15:49:16 -0700", "message": "multi-version policy - introducing version/active in policy object (#1568)"}, {"oid": "4abff4b9952e4836f79bf3f1934baf8fe2bcebf9", "committedDate": "2021-08-08 11:39:07 -0700", "message": "Disable Reminder Review Notifications By Tag zms.DisableReminderNotifications (#1579)"}, {"oid": "6a1523accc3ec83fe54d78c3d919d9cddbcb1b7e", "committedDate": "2021-08-17 18:32:28 -0700", "message": "fixing the order of updates for assertion condition api operations (#1591)"}, {"oid": "66590f4fc47f899f3990f20895f953074e40f259", "committedDate": "2021-09-10 07:55:42 -0700", "message": "Implement multi-version policies endpoints (#1605)"}, {"oid": "1ad624427917493d31bd1b8ffa6303c4d6353055", "committedDate": "2021-09-10 13:51:19 -0700", "message": "update group last modified when user is deleted (#1613)"}, {"oid": "91b116418656f123dae9a3405cb2e498d4d3aff4", "committedDate": "2021-09-12 09:52:05 +0300", "message": "additional validation checks when processing versioned policies (#1614)"}, {"oid": "2531428956f87774f86721f02b430861ca8897ec", "committedDate": "2021-09-14 09:49:34 +0300", "message": "additional checks when setting a policy version as active (#1615)"}, {"oid": "2968c209e870ce57fbdb1fb048a21692d80cfea6", "committedDate": "2021-10-01 07:25:34 -0700", "message": "rdl publishChangeEvents generator (#1624)"}, {"oid": "8a6960ce9878277c5abda1d104ca070831b36230", "committedDate": "2021-10-03 13:48:03 -0700", "message": "Allow specifying version name when creating new policy (#1630)"}, {"oid": "43f619b31bbd9cc3d388aa7ea29eff889cb1272d", "committedDate": "2021-10-21 08:48:51 -0700", "message": "For role expiry notification - record metrics daily while (#1654)"}, {"oid": "389f984270d7d89070c66096e87fafbcb24a261c", "committedDate": "2021-10-26 08:17:36 -0700", "message": "Group tags implementation (#1660)"}, {"oid": "120ab1fa8e9d33fa793c4254d233a09a2c23d173", "committedDate": "2021-10-29 15:08:28 -0700", "message": "Disable Group Expiry Notifications By Tag zms.DisableReminderNotifications (#1663)"}, {"oid": "1400363e8d698cf08370c89752077ebae043c5be", "committedDate": "2021-12-14 13:48:34 -0800", "message": "correct logging of role principal in audit/access logs"}, {"oid": "c8e3a5c91c5deb9640576cd3496a2af11d572f0b", "committedDate": "2021-12-23 15:03:25 -0800", "message": "protect system admin users from being removed from deleteUser api (#1715)"}, {"oid": "020e06e57b357768260f509f08b75c5c068bce53", "committedDate": "2022-02-07 08:01:55 -0800", "message": "Service Visiblity - Domain Dependencies (#1758)"}, {"oid": "fcbd4128e334a9a42f4579d179cf9578d3f4de99", "committedDate": "2022-02-07 10:12:47 -0800", "message": "support new get-stats endpoint to get per-domain/system stats (#1774)"}, {"oid": "ea831a34a70a0475bea8754cb183741dced98ff2", "committedDate": "2022-02-18 09:17:55 -0800", "message": "update pending member api to support getting list for a domain (#1783)"}, {"oid": "f4229124e8e1898810c7aa7b3a4eff37fddae308", "committedDate": "2022-02-18 12:37:32 -0800", "message": "provide option to skip adding principal when onboarding a resource group (#1787)"}, {"oid": "9081feb4c06a1058c941c67923037203d9318cfa", "committedDate": "2022-02-27 14:10:46 -0800", "message": "Domain Dependency for Tenancy (#1789)"}, {"oid": "a5bb615881583fa6f39621e2ea3bf39d3886340b", "committedDate": "2022-03-03 17:20:00 -0800", "message": "extend template keyword support trust field in roles (#1803)"}, {"oid": "3de182bcbedba89fa2aaba12ab9be49aa2156096", "committedDate": "2022-03-19 09:45:40 -0700", "message": "Add provider webhook for verifying removal (#1816)"}, {"oid": "1b0cff1cb9b8e4a231c5cfb342d76b6aad8e08fc", "committedDate": "2022-04-07 14:34:23 -0700", "message": "no need to update domain's last mod timestamp during put dependency call (#1846)"}, {"oid": "baa68eacd6a6b9bbc70c3423006f92cd47b784d7", "committedDate": "2022-05-19 09:30:02 -0700", "message": "Get Auth History implementation (#1875)"}, {"oid": "bea97b165e28b5b2cc286af62c92e536c9fc3ff2", "committedDate": "2022-06-03 13:50:01 -0700", "message": "AuthHistory - Return dependencies instead of list (#1888)"}, {"oid": "7a313e1d581295ae6c786bbc2ed73bb14da37f7d", "committedDate": "2022-07-21 20:16:24 -0700", "message": "allow management of domain memberPurgeExpiryDays setting value (#1928)"}, {"oid": "f288ed7afb018bc07af02dbe9dc8e05ec0896071", "committedDate": "2022-08-15 22:28:01 -0700", "message": "provide header option to return updated object in response (#1942)"}, {"oid": "949bd0634d328d04736b912a002bdfa7421d9f2b", "committedDate": "2022-08-23 10:28:38 -0700", "message": "fix returning role/group objects when requested by ui (#1945)"}, {"oid": "ab7284c9274f4949d23f88ec0dde7b689c0c6980", "committedDate": "2022-09-05 13:12:17 -0700", "message": "auto purge expired role/group members based on server/domain config (#1941)"}, {"oid": "4ab6e748891a014a8b0a1364de099d3fbf4c7468", "committedDate": "2022-09-21 22:22:48 -0700", "message": "enable readWrite db connection for delete expired members (#1964)"}, {"oid": "d4c733d3e97467a598ba44f0bde5c6a907aa01de", "committedDate": "2022-09-23 13:30:24 -0700", "message": "consistent use of The Athenz Authors copyright in all files (#1967)"}, {"oid": "45dcdab92d9e39d5d561b34ef222f863176cc635", "committedDate": "2022-09-26 12:29:01 -0700", "message": "make server purge expiry member day configurable (#1968)"}, {"oid": "d823cccb5163f950655f3859ade41fe031910588", "committedDate": "2022-10-06 14:20:20 -0700", "message": "fix putServiceIdentity logic to allow update of exising pubKey (#1978)"}, {"oid": "91d38ef548e59e29e69349b8a0f5151456b62a0f", "committedDate": "2022-10-07 15:36:36 -0700", "message": "Use correct object type for role member delete notifications (#1981)"}, {"oid": "1d970ce72c2f81aed5576fff068103bbba022aaf", "committedDate": "2022-11-29 23:50:29 +0200", "message": "add gcp project attribute for domains (#2005)"}, {"oid": "c292a1a2fb6e3a300a3060a6bcea6a96f696932c", "committedDate": "2022-12-13 08:56:43 -0800", "message": "Return the correct response from putMembership/putGroupMembership once a pending member was added (#2023)"}, {"oid": "fc5a206d1cb23dd2bbfd9af7e3125ec270ebc022", "committedDate": "2023-01-10 21:48:12 -0800", "message": "allow domain admins to enable audit flag for new roles/groups (#2032)"}, {"oid": "70850ab1de4055e765cf4ead6946b431900ff8c8", "committedDate": "2023-01-23 16:40:36 -0800", "message": "move cloud provider role generation logic out of dbstore library to dbservice (#2043)"}, {"oid": "0ff7ff4f9658fd42e8ee2161d870a89dce5167e4", "committedDate": "2023-02-02 09:18:32 -0800", "message": "Add a requirement for admin approval to delete members in review-enabled roles (#2053)"}, {"oid": "ff57628b890f53c43fec6dd2cacf98a574c95b2d", "committedDate": "2023-02-08 15:55:32 -0800", "message": "extends group with deleteProtection attribute and pending group membe\u2026 (#2067)"}, {"oid": "bb1d69af70a90aeedc28a46604283064e0dad8de", "committedDate": "2023-02-16 07:44:40 -0800", "message": "add audit enable to role (#2055)"}, {"oid": "4ee14d784973ce7da8aba96b35eefdbc5d61d97b", "committedDate": "2023-03-07 11:34:04 -0800", "message": "make aws/gcp assume role action values configurable (#2090)"}, {"oid": "5216da47ef8bca89ba0eae790f72739d9d73fcc6", "committedDate": "2023-03-09 10:36:29 -0800", "message": "Add optional 'description' to role (#2091)"}, {"oid": "d1b98d4614d62fe34b408cfa1a26fb59674d6494", "committedDate": "2023-03-27 16:46:33 -0700", "message": "store GCP project number along with project id in athenz domain metadata (#2113)"}, {"oid": "715cf96c679e817600a0a25160c96878e5eda735", "committedDate": "2023-03-27 18:01:33 -0700", "message": "special resource for gcp starting with service/ (#2115)"}, {"oid": "6e7342a1e98207b87e3eae45341db281b7b3b9c7", "committedDate": "2023-04-13 14:30:39 -0700", "message": "designate separate action for assertions when assuming gcp service accounts (#2127)"}, {"oid": "523f7f753fa2a4a112ae4fb7a5389203af8b9594", "committedDate": "2023-05-29 08:52:21 -0700", "message": "fix role update on expiration and review dates (#2185)"}, {"oid": "7069bf871635c4e5308d37341904241388b1ccda", "committedDate": "2023-05-30 15:31:26 -0700", "message": "support product id (string) format association with domains (#2193)"}, {"oid": "368d0bc139931c03d31824c4f02394b38e3ead95", "committedDate": "2023-06-02 13:15:05 -0700", "message": "support headless user type - managed by user authority but treated like service (#2197)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3MDMzMw==", "url": "https://github.com/AthenZ/athenz/pull/1157#discussion_r510470333", "body": "not sure why we have this switch block. the newState is passed in so no need to check what it is. it should be something like:\r\n\r\nif (con.updatePrincipal(changedPrincipal.getFullName(), newState.getValue())) {\r\n updatedUsers.add(changedPrincipal);\r\n}", "bodyText": "not sure why we have this switch block. the newState is passed in so no need to check what it is. it should be something like:\nif (con.updatePrincipal(changedPrincipal.getFullName(), newState.getValue())) {\nupdatedUsers.add(changedPrincipal);\n}", "bodyHTML": "<p dir=\"auto\">not sure why we have this switch block. the newState is passed in so no need to check what it is. it should be something like:</p>\n<p dir=\"auto\">if (con.updatePrincipal(changedPrincipal.getFullName(), newState.getValue())) {<br>\nupdatedUsers.add(changedPrincipal);<br>\n}</p>", "author": "havetisyan", "createdAt": "2020-10-22T21:32:16Z", "path": "servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java", "diffHunk": "@@ -6402,6 +6403,147 @@ void enforceGroupUserAuthorityRestrictions(final String domainName, final String\n         }\n     }\n \n+    /**\n+     * This method returns list of Principals based on the state parameter supplied\n+     * @param queriedState state of principal\n+     * @return List of Principals from DB\n+     */\n+    List<Principal> getPrincipals(int queriedState) {\n+        List<Principal> principals = new ArrayList<>();\n+        Principal principal;\n+        try (ObjectStoreConnection con = store.getConnection(true, false)) {\n+           List<String> dbPrincipals = con.getPrincipals(queriedState);\n+           for (String dbPrincipal : dbPrincipals) {\n+               principal = ZMSUtils.createPrincipalForName(dbPrincipal, zmsConfig.getUserDomain(), null);\n+               ((SimplePrincipal) principal).setState(Principal.State.getState(queriedState));\n+               principals.add(principal);\n+           }\n+        }\n+        return principals;\n+    }\n+\n+    /**\n+     * This method toggles state for supplied Principals based on the flag in DB\n+     * as well as modifies memberships of all roles and groups of current principal(s)\n+     * @param changedPrincipals List of Principals from User Authority\n+     * @param newState new state {@link Principal.State}\n+     */\n+    void updatePrincipalBasedOnAuthorityState(List<Principal> changedPrincipals, Principal.State newState) {\n+        final String caller = \"updateMembershipBasedOnUserState\";\n+        List<Principal> updatedUsers = new ArrayList<>();\n+        try (ObjectStoreConnection con = store.getConnection(true, true)) {\n+\n+            // first lets update the new state in DB\n+            for (Principal changedPrincipal : changedPrincipals) {\n+                try {\n+                    switch (newState) {", "originalCommit": "45b271a460205ef873d48d4247128daa43779d54", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f2b6979e4235f325d7eea75d6f63d358c03d8d3c", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 2c6958b49..2d11e7268 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6426,121 +6427,120 @@ public class DBService implements RolesProvider {\n      * This method toggles state for supplied Principals based on the flag in DB\n      * as well as modifies memberships of all roles and groups of current principal(s)\n      * @param changedPrincipals List of Principals from User Authority\n-     * @param newState new state {@link Principal.State}\n+     * @param suspended boolean indicating principal's state\n      */\n-    void updatePrincipalBasedOnAuthorityState(List<Principal> changedPrincipals, Principal.State newState) {\n-        final String caller = \"updateMembershipBasedOnUserState\";\n+    void updatePrincipalByStateFromAuthority(List<Principal> changedPrincipals, boolean suspended) {\n+        final String caller = \"updatePrincipalByStateFromAuthority\";\n         List<Principal> updatedUsers = new ArrayList<>();\n-        try (ObjectStoreConnection con = store.getConnection(true, true)) {\n+        if (!changedPrincipals.isEmpty()) {\n+            try (ObjectStoreConnection con = store.getConnection(true, true)) {\n \n-            // first lets update the new state in DB\n-            for (Principal changedPrincipal : changedPrincipals) {\n-                try {\n-                    switch (newState) {\n-                        case ACTIVE:\n-                            if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.ACTIVE.getValue())) {\n-                                updatedUsers.add(changedPrincipal);\n-                            }\n-                            break;\n-                        case AUTHORITY_SYSTEM_DISABLED:\n-                            if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.AUTHORITY_SYSTEM_DISABLED.getValue())) {\n-                                updatedUsers.add(changedPrincipal);\n+                // first lets update the new state in DB\n+                for (Principal changedPrincipal : changedPrincipals) {\n+                    updatePrincipalState(suspended, updatedUsers, con, changedPrincipal);\n+                }\n+                // if new state is updated successfully\n+                // then we need to modify all roles and groups where given principal is member of\n+                if (!updatedUsers.isEmpty()) {\n+                    for (Principal updatedUser : updatedUsers) {\n+                        try {\n+                            updateRoleMembershipsByPrincipalState(suspended, caller, con, updatedUser);\n+                            updateGroupMembershipByPrincipalState(suspended, caller, con, updatedUser);\n+                        } catch (ResourceException ex) {\n+                            if (ex.getCode() == ResourceException.NOT_FOUND) {\n+                                continue;\n                             }\n-                            break;\n-                        default:\n-                            break;\n-                    }\n-                } catch (ResourceException ex) {\n-                    if (ex.getCode() == ResourceException.NOT_FOUND) {\n-                        continue;\n+                            throw ex;\n+                        }\n                     }\n-                    throw ex;\n                 }\n             }\n-            // if new state is updated successfully\n-            // then we need to modify all roles and groups where given principal is member of\n-            if (!updatedUsers.isEmpty()) {\n-\n-                DomainRoleMember domainRoleMember;\n-                DomainGroupMember domainGroupMember;\n-                RoleMember roleMember;\n-                GroupMember groupMember;\n-                List<RoleMember> roleMembersWithUpdatedState;\n-                List<GroupMember> groupMembersWithUpdatedState;\n-                for (Principal updatedUser : updatedUsers) {\n-                    try {\n-                        // get all roles from all domains\n-                        domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n-                        if (!domainRoleMember.getMemberRoles().isEmpty()) {\n-                            for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n-                                roleMember = new RoleMember();\n-                                roleMember.setMemberName(updatedUser.getFullName());\n-                                switch (newState) {\n-                                    case ACTIVE:\n-                                        // if new state is ACTIVE then revert back to previous state for the member\n-                                        roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~newState.getValue());\n-                                        break;\n-                                    case AUTHORITY_SYSTEM_DISABLED:\n-                                        // if new state is SYSTEM_DISABLED then add it on to existing state\n-                                        roleMember.setSystemDisabled(memberRole.getSystemDisabled() | newState.getValue());\n-                                        break;\n-                                    default:\n-                                        break;\n-                                }\n-                                roleMembersWithUpdatedState = new ArrayList<>();\n-                                roleMembersWithUpdatedState.add(roleMember);\n-\n-                                // Following method does Audit entry as well\n-                                if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n-                                        memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-\n-                                    // update our role and domain time-stamps, and invalidate local cache entry\n-                                    con.updateRoleModTimestamp(memberRole.getDomainName(), memberRole.getRoleName());\n-                                    con.updateDomainModTimestamp(memberRole.getDomainName());\n-                                    cacheStore.invalidate(memberRole.getDomainName());\n-                                }\n-                            }\n-                        }\n-                        domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n-                        if (!domainGroupMember.getMemberGroups().isEmpty()) {\n-                            for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n-                                groupMember = new GroupMember();\n-                                groupMember.setMemberName(updatedUser.getFullName());\n-                                switch (newState) {\n-                                    case ACTIVE:\n-                                        // if new state is ACTIVE then revert back to previous state for the member\n-                                        groupMember.setSystemDisabled(currentGroup.getSystemDisabled() & ~newState.getValue());\n-                                        break;\n-                                    case AUTHORITY_SYSTEM_DISABLED:\n-                                        // if new state is SYSTEM_DISABLED then add it on to existing state\n-                                        groupMember.setSystemDisabled(currentGroup.getSystemDisabled() | newState.getValue());\n-                                        break;\n-                                    default:\n-                                        break;\n-                                }\n-                                groupMembersWithUpdatedState = new ArrayList<>();\n-                                groupMembersWithUpdatedState.add(groupMember);\n-\n-                                // Following method does Audit entry as well\n-                                if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n-                                        currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-\n-                                    // update our group and domain time-stamps, and invalidate local cache entry\n-\n-                                    con.updateGroupModTimestamp(currentGroup.getDomainName(), currentGroup.getGroupName());\n-                                    con.updateDomainModTimestamp(currentGroup.getDomainName());\n-                                    cacheStore.invalidate(currentGroup.getDomainName());\n-                                }\n-                            }\n-                        }\n-                    } catch (ResourceException ex) {\n-                        if (ex.getCode() == ResourceException.NOT_FOUND) {\n-                            continue;\n-                        }\n-                        throw ex;\n-                    }\n+        }\n+    }\n+\n+    private void updateGroupMembershipByPrincipalState(boolean suspended, String caller, ObjectStoreConnection con, Principal updatedUser) {\n+        List<GroupMember> groupMembersWithUpdatedState;\n+        GroupMember groupMember;\n+        DomainGroupMember domainGroupMember;\n+        Set<GroupMember> updatedGroups = new HashSet<>();\n+\n+        domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n+        if (!domainGroupMember.getMemberGroups().isEmpty()) {\n+            for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n+                groupMember = new GroupMember();\n+                groupMember.setMemberName(updatedUser.getFullName());\n+                if (suspended) {\n+                    groupMember.setSystemDisabled(currentGroup.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                } else {\n+                    groupMember.setSystemDisabled(currentGroup.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                }\n+                groupMembersWithUpdatedState = new ArrayList<>();\n+                groupMembersWithUpdatedState.add(groupMember);\n+\n+                // Following method does Audit entry as well\n+                if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n+                        currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n+                    updatedGroups.add(currentGroup);\n+                }\n+            }\n+            for (GroupMember updatedGM : updatedGroups) {\n+\n+                // update our group and domain time-stamps, and invalidate local cache entry\n+                con.updateGroupModTimestamp(updatedGM.getDomainName(), updatedGM.getGroupName());\n+                con.updateDomainModTimestamp(updatedGM.getDomainName());\n+                cacheStore.invalidate(updatedGM.getDomainName());\n+            }\n+        }\n+    }\n+\n+    private void updateRoleMembershipsByPrincipalState(boolean suspended, String caller, ObjectStoreConnection con, Principal updatedUser) {\n+        RoleMember roleMember;\n+        List<RoleMember> roleMembersWithUpdatedState;\n+        DomainRoleMember domainRoleMember;\n+        Set<MemberRole> updatedRoles = new HashSet<>();\n+\n+        domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n+        if (!domainRoleMember.getMemberRoles().isEmpty()) {\n+            for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n+                roleMember = new RoleMember();\n+                roleMember.setMemberName(updatedUser.getFullName());\n+                if (suspended) {\n+                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                } else {\n+                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                }\n+                roleMembersWithUpdatedState = new ArrayList<>();\n+                roleMembersWithUpdatedState.add(roleMember);\n+\n+                // Following method does Audit entry as well\n+                if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n+                        memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n+                    updatedRoles.add(memberRole);\n+                }\n+            }\n+            for (MemberRole updatedMR : updatedRoles) {\n+\n+                // update our role and domain time-stamps, and invalidate local cache entry\n+                con.updateRoleModTimestamp(updatedMR.getDomainName(), updatedMR.getRoleName());\n+                con.updateDomainModTimestamp(updatedMR.getDomainName());\n+                cacheStore.invalidate(updatedMR.getDomainName());\n+            }\n+        }\n+    }\n+\n+    private void updatePrincipalState(boolean suspended, List<Principal> updatedUsers, ObjectStoreConnection con, Principal changedPrincipal) {\n+        try {\n+            if (suspended) {\n+                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue())) {\n+                    updatedUsers.add(changedPrincipal);\n+                }\n+            } else {\n+                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.ACTIVE.getValue())) {\n+                    updatedUsers.add(changedPrincipal);\n                 }\n             }\n+        } catch (ResourceException ex) {\n+            LOG.error(\"Exception in updating principal state from Authority {} Moving on.\", ex.getMessage());\n         }\n     }\n \n", "next_change": {"commit": "0dff4be75160c89e9e35b4634db11456460fa25f", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 2d11e7268..08f2ee72e 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6497,50 +6512,29 @@ public class DBService implements RolesProvider {\n         RoleMember roleMember;\n         List<RoleMember> roleMembersWithUpdatedState;\n         DomainRoleMember domainRoleMember;\n-        Set<MemberRole> updatedRoles = new HashSet<>();\n-\n+        int newState;\n+        Set<String> updatedDomains = new HashSet<>();\n         domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n         if (!domainRoleMember.getMemberRoles().isEmpty()) {\n             for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n                 roleMember = new RoleMember();\n                 roleMember.setMemberName(updatedUser.getFullName());\n-                if (suspended) {\n-                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                } else {\n-                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                }\n-                roleMembersWithUpdatedState = new ArrayList<>();\n-                roleMembersWithUpdatedState.add(roleMember);\n+                newState = suspended ? memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n+                        memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n+                roleMember.setSystemDisabled(newState);\n+                roleMembersWithUpdatedState = Collections.singletonList(roleMember);\n \n                 // Following method does Audit entry as well\n                 if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n                         memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-                    updatedRoles.add(memberRole);\n+                    con.updateRoleModTimestamp(memberRole.getDomainName(), memberRole.getRoleName());\n+                    updatedDomains.add(memberRole.getDomainName());\n                 }\n             }\n-            for (MemberRole updatedMR : updatedRoles) {\n-\n-                // update our role and domain time-stamps, and invalidate local cache entry\n-                con.updateRoleModTimestamp(updatedMR.getDomainName(), updatedMR.getRoleName());\n-                con.updateDomainModTimestamp(updatedMR.getDomainName());\n-                cacheStore.invalidate(updatedMR.getDomainName());\n-            }\n-        }\n-    }\n-\n-    private void updatePrincipalState(boolean suspended, List<Principal> updatedUsers, ObjectStoreConnection con, Principal changedPrincipal) {\n-        try {\n-            if (suspended) {\n-                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue())) {\n-                    updatedUsers.add(changedPrincipal);\n-                }\n-            } else {\n-                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.ACTIVE.getValue())) {\n-                    updatedUsers.add(changedPrincipal);\n-                }\n-            }\n-        } catch (ResourceException ex) {\n-            LOG.error(\"Exception in updating principal state from Authority {} Moving on.\", ex.getMessage());\n+            updatedDomains.forEach(dom -> {\n+                con.updateDomainModTimestamp(dom);\n+                cacheStore.invalidate(dom);\n+            });\n         }\n     }\n \n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 2c6958b49..08f2ee72e 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6426,113 +6427,46 @@ public class DBService implements RolesProvider {\n      * This method toggles state for supplied Principals based on the flag in DB\n      * as well as modifies memberships of all roles and groups of current principal(s)\n      * @param changedPrincipals List of Principals from User Authority\n-     * @param newState new state {@link Principal.State}\n+     * @param suspended boolean indicating principal's state\n      */\n-    void updatePrincipalBasedOnAuthorityState(List<Principal> changedPrincipals, Principal.State newState) {\n-        final String caller = \"updateMembershipBasedOnUserState\";\n+    void updatePrincipalByStateFromAuthority(List<Principal> changedPrincipals, boolean suspended) {\n+\n+        if (changedPrincipals.isEmpty()) {\n+            return;\n+        }\n+\n+        final String caller = \"updatePrincipalByStateFromAuthority\";\n         List<Principal> updatedUsers = new ArrayList<>();\n+        int newPrincipalState = suspended ? Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() : Principal.State.ACTIVE.getValue();\n         try (ObjectStoreConnection con = store.getConnection(true, true)) {\n \n             // first lets update the new state in DB\n             for (Principal changedPrincipal : changedPrincipals) {\n                 try {\n-                    switch (newState) {\n-                        case ACTIVE:\n-                            if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.ACTIVE.getValue())) {\n-                                updatedUsers.add(changedPrincipal);\n-                            }\n-                            break;\n-                        case AUTHORITY_SYSTEM_DISABLED:\n-                            if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.AUTHORITY_SYSTEM_DISABLED.getValue())) {\n-                                updatedUsers.add(changedPrincipal);\n-                            }\n-                            break;\n-                        default:\n-                            break;\n+                    if (con.updatePrincipal(changedPrincipal.getFullName(), newPrincipalState)) {\n+                        updatedUsers.add(changedPrincipal);\n                     }\n                 } catch (ResourceException ex) {\n-                    if (ex.getCode() == ResourceException.NOT_FOUND) {\n-                        continue;\n-                    }\n-                    throw ex;\n+                    // log the exception and continue with remaining principals\n+                    LOG.error(\"Exception in updating principal state from Authority {} Moving on.\", ex.getMessage());\n                 }\n             }\n             // if new state is updated successfully\n             // then we need to modify all roles and groups where given principal is member of\n             if (!updatedUsers.isEmpty()) {\n-\n-                DomainRoleMember domainRoleMember;\n-                DomainGroupMember domainGroupMember;\n-                RoleMember roleMember;\n-                GroupMember groupMember;\n-                List<RoleMember> roleMembersWithUpdatedState;\n-                List<GroupMember> groupMembersWithUpdatedState;\n                 for (Principal updatedUser : updatedUsers) {\n+                    // separate try blocks to treat group and role membership 404s separately\n                     try {\n-                        // get all roles from all domains\n-                        domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n-                        if (!domainRoleMember.getMemberRoles().isEmpty()) {\n-                            for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n-                                roleMember = new RoleMember();\n-                                roleMember.setMemberName(updatedUser.getFullName());\n-                                switch (newState) {\n-                                    case ACTIVE:\n-                                        // if new state is ACTIVE then revert back to previous state for the member\n-                                        roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~newState.getValue());\n-                                        break;\n-                                    case AUTHORITY_SYSTEM_DISABLED:\n-                                        // if new state is SYSTEM_DISABLED then add it on to existing state\n-                                        roleMember.setSystemDisabled(memberRole.getSystemDisabled() | newState.getValue());\n-                                        break;\n-                                    default:\n-                                        break;\n-                                }\n-                                roleMembersWithUpdatedState = new ArrayList<>();\n-                                roleMembersWithUpdatedState.add(roleMember);\n-\n-                                // Following method does Audit entry as well\n-                                if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n-                                        memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-\n-                                    // update our role and domain time-stamps, and invalidate local cache entry\n-                                    con.updateRoleModTimestamp(memberRole.getDomainName(), memberRole.getRoleName());\n-                                    con.updateDomainModTimestamp(memberRole.getDomainName());\n-                                    cacheStore.invalidate(memberRole.getDomainName());\n-                                }\n-                            }\n-                        }\n-                        domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n-                        if (!domainGroupMember.getMemberGroups().isEmpty()) {\n-                            for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n-                                groupMember = new GroupMember();\n-                                groupMember.setMemberName(updatedUser.getFullName());\n-                                switch (newState) {\n-                                    case ACTIVE:\n-                                        // if new state is ACTIVE then revert back to previous state for the member\n-                                        groupMember.setSystemDisabled(currentGroup.getSystemDisabled() & ~newState.getValue());\n-                                        break;\n-                                    case AUTHORITY_SYSTEM_DISABLED:\n-                                        // if new state is SYSTEM_DISABLED then add it on to existing state\n-                                        groupMember.setSystemDisabled(currentGroup.getSystemDisabled() | newState.getValue());\n-                                        break;\n-                                    default:\n-                                        break;\n-                                }\n-                                groupMembersWithUpdatedState = new ArrayList<>();\n-                                groupMembersWithUpdatedState.add(groupMember);\n-\n-                                // Following method does Audit entry as well\n-                                if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n-                                        currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-\n-                                    // update our group and domain time-stamps, and invalidate local cache entry\n-\n-                                    con.updateGroupModTimestamp(currentGroup.getDomainName(), currentGroup.getGroupName());\n-                                    con.updateDomainModTimestamp(currentGroup.getDomainName());\n-                                    cacheStore.invalidate(currentGroup.getDomainName());\n-                                }\n-                            }\n+                        updateRoleMembershipsByPrincipalState(suspended, caller, con, updatedUser);\n+                    } catch (ResourceException ex) {\n+                        if (ex.getCode() == ResourceException.NOT_FOUND) {\n+                            continue;\n                         }\n+                        throw ex;\n+                    }\n+                    // separate try blocks to treat group and role membership 404s separately\n+                    try {\n+                        updateGroupMembershipByPrincipalState(suspended, caller, con, updatedUser);\n                     } catch (ResourceException ex) {\n                         if (ex.getCode() == ResourceException.NOT_FOUND) {\n                             continue;\n", "next_change": null}]}, "commits_in_main": [{"oid": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "message": "Merge commit", "committedDate": null}, {"oid": "9a9c82c13d156e06dad8464c3a6c52c8e2bc6b89", "committedDate": "2020-10-26 14:15:03 -0700", "message": "remove sending back deprected members field in roles (#1160)"}, {"oid": "31a0dd7362f585f85992d4ff86fbf975d9d736dd", "committedDate": "2020-10-31 14:59:07 -0700", "message": "add azure_subscription field to domains (#1167)"}, {"oid": "c668f48cec94e2c928581b92ffb517f715a4840f", "committedDate": "2020-11-06 18:05:10 -0800", "message": "handle sys disabled null scenario (#1176)"}, {"oid": "f24d15baaaddc96c85fbceb31fcaded756a69f2e", "committedDate": "2020-11-14 16:51:57 -0800", "message": "role tags - generated code and schema changes (#1179)"}, {"oid": "30e272d8a9ec2649a1d876c1c111cf38e27c1743", "committedDate": "2020-12-07 08:48:58 -0800", "message": "putRoleMeta tags support (#1208)"}, {"oid": "f0e0a91b80250236244db9f8cba79e1def809995", "committedDate": "2020-12-23 15:40:53 -0800", "message": "updating group expiry date (#1221)"}, {"oid": "7a2837c7578ab8d36c62b48ecb1d0079c670616b", "committedDate": "2020-12-29 13:44:04 -0800", "message": "granular authz action for managing role members (#1228)"}, {"oid": "d6a0d659fe96486ffcf31bb93e919656be9eaf89", "committedDate": "2021-01-13 08:15:47 -0800", "message": "domain tags implementation (#1235)"}, {"oid": "3c939966592bf7cc6ff25df12a8d21d4c2c89b2b", "committedDate": "2021-01-19 22:05:22 -0800", "message": "client api update for rich authorization requests and consistent naming of entity objects (#1248)"}, {"oid": "3db6ed7b169fce5bbeaa1fae84ff7881e9a4e435", "committedDate": "2021-01-21 09:17:41 -0800", "message": "limit number of role and domain tags (#1255)"}, {"oid": "218b71958d88fb039dfa6e7c5448c7e4d00cb337", "committedDate": "2021-01-25 17:53:41 -0800", "message": "update domain last modified timestamp after tag update (#1262)"}, {"oid": "bccc5fb4dc1c2407a0293f322c3d97711af4297c", "committedDate": "2021-03-07 18:11:58 -0800", "message": "sonarcloud: method always returns same result (#1329)"}, {"oid": "e421f20094d24075d2cec7ab7adecff7d630a286", "committedDate": "2021-03-16 18:08:03 -0700", "message": "expose new domain attribute: business-service (#1357)"}, {"oid": "7b4afd5d40394226b3aa1af8bf10e90e528091b3", "committedDate": "2021-04-01 14:52:30 -0700", "message": "Add memberExpiryDays and serviceExpiryDays support for groups (#1388)"}, {"oid": "5ab30978cc4fc03e1b3022305f6e14a5a425e9e9", "committedDate": "2021-04-07 16:30:50 -0700", "message": "new DomainMetaStore interface support in ZMS (#1430)"}, {"oid": "9bedde4310d6493406d264422f23e16f33213546", "committedDate": "2021-04-08 09:44:29 -0700", "message": "Add group review days to role (#1428)"}, {"oid": "a554c75c51c5945b0e58ae87866de93ff1d5cfbc", "committedDate": "2021-04-15 12:12:02 -0700", "message": "during provider admin setup, ignore deletes (#1444)"}, {"oid": "1c564548381b3c09ad4214d0f30c667e9cc0d022", "committedDate": "2021-04-30 15:22:51 -0700", "message": "log full policy assertion details during delete operations in audit log (#1469)"}, {"oid": "611ac334bfbc1c43ec20154cf9448b96fae365d6", "committedDate": "2021-05-27 16:30:38 -0700", "message": "handle null contition processDomainTags (#1495)"}, {"oid": "addf4424a5bf842b58558c6f61ac0b46277d9535", "committedDate": "2021-06-07 09:38:12 -0700", "message": "allow role/group review regardless of role/group expiry/reminder settings (#1503)"}, {"oid": "4b39ffbd18da3d10a581fb10209806c97b432d28", "committedDate": "2021-06-09 15:31:17 -0700", "message": "enable role review without setting restrictions (#1512)"}, {"oid": "898ff0aa4fddd1a9ed111496cb9e4acb544605af", "committedDate": "2021-06-14 10:42:10 -0700", "message": "Update Tag Values to include '/', ':' (#1517)"}, {"oid": "cf535673b0a4cbcdc81e17c7def4cb6822edd78c", "committedDate": "2021-06-22 06:44:42 -0700", "message": "Allow system admins to set domain meta attribute business service (#1522)"}, {"oid": "934fc3d7fc859731f4beab3b03b83a15ac717a2d", "committedDate": "2021-06-29 12:57:53 -0700", "message": "assertion condition server changes (#1528)"}, {"oid": "1fa51b852890c1576254be6a8a2b5dbebc89865c", "committedDate": "2021-07-21 14:41:19 -0700", "message": "UI : update error message (#1557)"}, {"oid": "09de45bb794eb5e7c29f705b5ce567c75fde4e84", "committedDate": "2021-07-29 15:49:16 -0700", "message": "multi-version policy - introducing version/active in policy object (#1568)"}, {"oid": "4abff4b9952e4836f79bf3f1934baf8fe2bcebf9", "committedDate": "2021-08-08 11:39:07 -0700", "message": "Disable Reminder Review Notifications By Tag zms.DisableReminderNotifications (#1579)"}, {"oid": "6a1523accc3ec83fe54d78c3d919d9cddbcb1b7e", "committedDate": "2021-08-17 18:32:28 -0700", "message": "fixing the order of updates for assertion condition api operations (#1591)"}, {"oid": "66590f4fc47f899f3990f20895f953074e40f259", "committedDate": "2021-09-10 07:55:42 -0700", "message": "Implement multi-version policies endpoints (#1605)"}, {"oid": "1ad624427917493d31bd1b8ffa6303c4d6353055", "committedDate": "2021-09-10 13:51:19 -0700", "message": "update group last modified when user is deleted (#1613)"}, {"oid": "91b116418656f123dae9a3405cb2e498d4d3aff4", "committedDate": "2021-09-12 09:52:05 +0300", "message": "additional validation checks when processing versioned policies (#1614)"}, {"oid": "2531428956f87774f86721f02b430861ca8897ec", "committedDate": "2021-09-14 09:49:34 +0300", "message": "additional checks when setting a policy version as active (#1615)"}, {"oid": "2968c209e870ce57fbdb1fb048a21692d80cfea6", "committedDate": "2021-10-01 07:25:34 -0700", "message": "rdl publishChangeEvents generator (#1624)"}, {"oid": "8a6960ce9878277c5abda1d104ca070831b36230", "committedDate": "2021-10-03 13:48:03 -0700", "message": "Allow specifying version name when creating new policy (#1630)"}, {"oid": "43f619b31bbd9cc3d388aa7ea29eff889cb1272d", "committedDate": "2021-10-21 08:48:51 -0700", "message": "For role expiry notification - record metrics daily while (#1654)"}, {"oid": "389f984270d7d89070c66096e87fafbcb24a261c", "committedDate": "2021-10-26 08:17:36 -0700", "message": "Group tags implementation (#1660)"}, {"oid": "120ab1fa8e9d33fa793c4254d233a09a2c23d173", "committedDate": "2021-10-29 15:08:28 -0700", "message": "Disable Group Expiry Notifications By Tag zms.DisableReminderNotifications (#1663)"}, {"oid": "1400363e8d698cf08370c89752077ebae043c5be", "committedDate": "2021-12-14 13:48:34 -0800", "message": "correct logging of role principal in audit/access logs"}, {"oid": "c8e3a5c91c5deb9640576cd3496a2af11d572f0b", "committedDate": "2021-12-23 15:03:25 -0800", "message": "protect system admin users from being removed from deleteUser api (#1715)"}, {"oid": "020e06e57b357768260f509f08b75c5c068bce53", "committedDate": "2022-02-07 08:01:55 -0800", "message": "Service Visiblity - Domain Dependencies (#1758)"}, {"oid": "fcbd4128e334a9a42f4579d179cf9578d3f4de99", "committedDate": "2022-02-07 10:12:47 -0800", "message": "support new get-stats endpoint to get per-domain/system stats (#1774)"}, {"oid": "ea831a34a70a0475bea8754cb183741dced98ff2", "committedDate": "2022-02-18 09:17:55 -0800", "message": "update pending member api to support getting list for a domain (#1783)"}, {"oid": "f4229124e8e1898810c7aa7b3a4eff37fddae308", "committedDate": "2022-02-18 12:37:32 -0800", "message": "provide option to skip adding principal when onboarding a resource group (#1787)"}, {"oid": "9081feb4c06a1058c941c67923037203d9318cfa", "committedDate": "2022-02-27 14:10:46 -0800", "message": "Domain Dependency for Tenancy (#1789)"}, {"oid": "a5bb615881583fa6f39621e2ea3bf39d3886340b", "committedDate": "2022-03-03 17:20:00 -0800", "message": "extend template keyword support trust field in roles (#1803)"}, {"oid": "3de182bcbedba89fa2aaba12ab9be49aa2156096", "committedDate": "2022-03-19 09:45:40 -0700", "message": "Add provider webhook for verifying removal (#1816)"}, {"oid": "1b0cff1cb9b8e4a231c5cfb342d76b6aad8e08fc", "committedDate": "2022-04-07 14:34:23 -0700", "message": "no need to update domain's last mod timestamp during put dependency call (#1846)"}, {"oid": "baa68eacd6a6b9bbc70c3423006f92cd47b784d7", "committedDate": "2022-05-19 09:30:02 -0700", "message": "Get Auth History implementation (#1875)"}, {"oid": "bea97b165e28b5b2cc286af62c92e536c9fc3ff2", "committedDate": "2022-06-03 13:50:01 -0700", "message": "AuthHistory - Return dependencies instead of list (#1888)"}, {"oid": "7a313e1d581295ae6c786bbc2ed73bb14da37f7d", "committedDate": "2022-07-21 20:16:24 -0700", "message": "allow management of domain memberPurgeExpiryDays setting value (#1928)"}, {"oid": "f288ed7afb018bc07af02dbe9dc8e05ec0896071", "committedDate": "2022-08-15 22:28:01 -0700", "message": "provide header option to return updated object in response (#1942)"}, {"oid": "949bd0634d328d04736b912a002bdfa7421d9f2b", "committedDate": "2022-08-23 10:28:38 -0700", "message": "fix returning role/group objects when requested by ui (#1945)"}, {"oid": "ab7284c9274f4949d23f88ec0dde7b689c0c6980", "committedDate": "2022-09-05 13:12:17 -0700", "message": "auto purge expired role/group members based on server/domain config (#1941)"}, {"oid": "4ab6e748891a014a8b0a1364de099d3fbf4c7468", "committedDate": "2022-09-21 22:22:48 -0700", "message": "enable readWrite db connection for delete expired members (#1964)"}, {"oid": "d4c733d3e97467a598ba44f0bde5c6a907aa01de", "committedDate": "2022-09-23 13:30:24 -0700", "message": "consistent use of The Athenz Authors copyright in all files (#1967)"}, {"oid": "45dcdab92d9e39d5d561b34ef222f863176cc635", "committedDate": "2022-09-26 12:29:01 -0700", "message": "make server purge expiry member day configurable (#1968)"}, {"oid": "d823cccb5163f950655f3859ade41fe031910588", "committedDate": "2022-10-06 14:20:20 -0700", "message": "fix putServiceIdentity logic to allow update of exising pubKey (#1978)"}, {"oid": "91d38ef548e59e29e69349b8a0f5151456b62a0f", "committedDate": "2022-10-07 15:36:36 -0700", "message": "Use correct object type for role member delete notifications (#1981)"}, {"oid": "1d970ce72c2f81aed5576fff068103bbba022aaf", "committedDate": "2022-11-29 23:50:29 +0200", "message": "add gcp project attribute for domains (#2005)"}, {"oid": "c292a1a2fb6e3a300a3060a6bcea6a96f696932c", "committedDate": "2022-12-13 08:56:43 -0800", "message": "Return the correct response from putMembership/putGroupMembership once a pending member was added (#2023)"}, {"oid": "fc5a206d1cb23dd2bbfd9af7e3125ec270ebc022", "committedDate": "2023-01-10 21:48:12 -0800", "message": "allow domain admins to enable audit flag for new roles/groups (#2032)"}, {"oid": "70850ab1de4055e765cf4ead6946b431900ff8c8", "committedDate": "2023-01-23 16:40:36 -0800", "message": "move cloud provider role generation logic out of dbstore library to dbservice (#2043)"}, {"oid": "0ff7ff4f9658fd42e8ee2161d870a89dce5167e4", "committedDate": "2023-02-02 09:18:32 -0800", "message": "Add a requirement for admin approval to delete members in review-enabled roles (#2053)"}, {"oid": "ff57628b890f53c43fec6dd2cacf98a574c95b2d", "committedDate": "2023-02-08 15:55:32 -0800", "message": "extends group with deleteProtection attribute and pending group membe\u2026 (#2067)"}, {"oid": "bb1d69af70a90aeedc28a46604283064e0dad8de", "committedDate": "2023-02-16 07:44:40 -0800", "message": "add audit enable to role (#2055)"}, {"oid": "4ee14d784973ce7da8aba96b35eefdbc5d61d97b", "committedDate": "2023-03-07 11:34:04 -0800", "message": "make aws/gcp assume role action values configurable (#2090)"}, {"oid": "5216da47ef8bca89ba0eae790f72739d9d73fcc6", "committedDate": "2023-03-09 10:36:29 -0800", "message": "Add optional 'description' to role (#2091)"}, {"oid": "d1b98d4614d62fe34b408cfa1a26fb59674d6494", "committedDate": "2023-03-27 16:46:33 -0700", "message": "store GCP project number along with project id in athenz domain metadata (#2113)"}, {"oid": "715cf96c679e817600a0a25160c96878e5eda735", "committedDate": "2023-03-27 18:01:33 -0700", "message": "special resource for gcp starting with service/ (#2115)"}, {"oid": "6e7342a1e98207b87e3eae45341db281b7b3b9c7", "committedDate": "2023-04-13 14:30:39 -0700", "message": "designate separate action for assertions when assuming gcp service accounts (#2127)"}, {"oid": "523f7f753fa2a4a112ae4fb7a5389203af8b9594", "committedDate": "2023-05-29 08:52:21 -0700", "message": "fix role update on expiration and review dates (#2185)"}, {"oid": "7069bf871635c4e5308d37341904241388b1ccda", "committedDate": "2023-05-30 15:31:26 -0700", "message": "support product id (string) format association with domains (#2193)"}, {"oid": "368d0bc139931c03d31824c4f02394b38e3ead95", "committedDate": "2023-06-02 13:15:05 -0700", "message": "support headless user type - managed by user authority but treated like service (#2197)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3NzQ5OA==", "url": "https://github.com/AthenZ/athenz/pull/1157#discussion_r510477498", "body": "this doesn't look correct to me. since ACTIVE itself is not a state bit I don't think we can use it as is. in this method we're either setting or removing the SUSPENDED bit", "bodyText": "this doesn't look correct to me. since ACTIVE itself is not a state bit I don't think we can use it as is. in this method we're either setting or removing the SUSPENDED bit", "bodyHTML": "<p dir=\"auto\">this doesn't look correct to me. since ACTIVE itself is not a state bit I don't think we can use it as is. in this method we're either setting or removing the SUSPENDED bit</p>", "author": "havetisyan", "createdAt": "2020-10-22T21:47:43Z", "path": "servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java", "diffHunk": "@@ -6402,6 +6403,147 @@ void enforceGroupUserAuthorityRestrictions(final String domainName, final String\n         }\n     }\n \n+    /**\n+     * This method returns list of Principals based on the state parameter supplied\n+     * @param queriedState state of principal\n+     * @return List of Principals from DB\n+     */\n+    List<Principal> getPrincipals(int queriedState) {\n+        List<Principal> principals = new ArrayList<>();\n+        Principal principal;\n+        try (ObjectStoreConnection con = store.getConnection(true, false)) {\n+           List<String> dbPrincipals = con.getPrincipals(queriedState);\n+           for (String dbPrincipal : dbPrincipals) {\n+               principal = ZMSUtils.createPrincipalForName(dbPrincipal, zmsConfig.getUserDomain(), null);\n+               ((SimplePrincipal) principal).setState(Principal.State.getState(queriedState));\n+               principals.add(principal);\n+           }\n+        }\n+        return principals;\n+    }\n+\n+    /**\n+     * This method toggles state for supplied Principals based on the flag in DB\n+     * as well as modifies memberships of all roles and groups of current principal(s)\n+     * @param changedPrincipals List of Principals from User Authority\n+     * @param newState new state {@link Principal.State}\n+     */\n+    void updatePrincipalBasedOnAuthorityState(List<Principal> changedPrincipals, Principal.State newState) {\n+        final String caller = \"updateMembershipBasedOnUserState\";\n+        List<Principal> updatedUsers = new ArrayList<>();\n+        try (ObjectStoreConnection con = store.getConnection(true, true)) {\n+\n+            // first lets update the new state in DB\n+            for (Principal changedPrincipal : changedPrincipals) {\n+                try {\n+                    switch (newState) {\n+                        case ACTIVE:\n+                            if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.ACTIVE.getValue())) {\n+                                updatedUsers.add(changedPrincipal);\n+                            }\n+                            break;\n+                        case AUTHORITY_SYSTEM_DISABLED:\n+                            if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.AUTHORITY_SYSTEM_DISABLED.getValue())) {\n+                                updatedUsers.add(changedPrincipal);\n+                            }\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+                } catch (ResourceException ex) {\n+                    if (ex.getCode() == ResourceException.NOT_FOUND) {\n+                        continue;\n+                    }\n+                    throw ex;\n+                }\n+            }\n+            // if new state is updated successfully\n+            // then we need to modify all roles and groups where given principal is member of\n+            if (!updatedUsers.isEmpty()) {\n+\n+                DomainRoleMember domainRoleMember;\n+                DomainGroupMember domainGroupMember;\n+                RoleMember roleMember;\n+                GroupMember groupMember;\n+                List<RoleMember> roleMembersWithUpdatedState;\n+                List<GroupMember> groupMembersWithUpdatedState;\n+                for (Principal updatedUser : updatedUsers) {\n+                    try {\n+                        // get all roles from all domains\n+                        domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n+                        if (!domainRoleMember.getMemberRoles().isEmpty()) {\n+                            for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n+                                roleMember = new RoleMember();\n+                                roleMember.setMemberName(updatedUser.getFullName());\n+                                switch (newState) {\n+                                    case ACTIVE:\n+                                        // if new state is ACTIVE then revert back to previous state for the member\n+                                        roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~newState.getValue());", "originalCommit": "45b271a460205ef873d48d4247128daa43779d54", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f2b6979e4235f325d7eea75d6f63d358c03d8d3c", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 2c6958b49..2d11e7268 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6426,121 +6427,120 @@ public class DBService implements RolesProvider {\n      * This method toggles state for supplied Principals based on the flag in DB\n      * as well as modifies memberships of all roles and groups of current principal(s)\n      * @param changedPrincipals List of Principals from User Authority\n-     * @param newState new state {@link Principal.State}\n+     * @param suspended boolean indicating principal's state\n      */\n-    void updatePrincipalBasedOnAuthorityState(List<Principal> changedPrincipals, Principal.State newState) {\n-        final String caller = \"updateMembershipBasedOnUserState\";\n+    void updatePrincipalByStateFromAuthority(List<Principal> changedPrincipals, boolean suspended) {\n+        final String caller = \"updatePrincipalByStateFromAuthority\";\n         List<Principal> updatedUsers = new ArrayList<>();\n-        try (ObjectStoreConnection con = store.getConnection(true, true)) {\n+        if (!changedPrincipals.isEmpty()) {\n+            try (ObjectStoreConnection con = store.getConnection(true, true)) {\n \n-            // first lets update the new state in DB\n-            for (Principal changedPrincipal : changedPrincipals) {\n-                try {\n-                    switch (newState) {\n-                        case ACTIVE:\n-                            if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.ACTIVE.getValue())) {\n-                                updatedUsers.add(changedPrincipal);\n-                            }\n-                            break;\n-                        case AUTHORITY_SYSTEM_DISABLED:\n-                            if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.AUTHORITY_SYSTEM_DISABLED.getValue())) {\n-                                updatedUsers.add(changedPrincipal);\n+                // first lets update the new state in DB\n+                for (Principal changedPrincipal : changedPrincipals) {\n+                    updatePrincipalState(suspended, updatedUsers, con, changedPrincipal);\n+                }\n+                // if new state is updated successfully\n+                // then we need to modify all roles and groups where given principal is member of\n+                if (!updatedUsers.isEmpty()) {\n+                    for (Principal updatedUser : updatedUsers) {\n+                        try {\n+                            updateRoleMembershipsByPrincipalState(suspended, caller, con, updatedUser);\n+                            updateGroupMembershipByPrincipalState(suspended, caller, con, updatedUser);\n+                        } catch (ResourceException ex) {\n+                            if (ex.getCode() == ResourceException.NOT_FOUND) {\n+                                continue;\n                             }\n-                            break;\n-                        default:\n-                            break;\n-                    }\n-                } catch (ResourceException ex) {\n-                    if (ex.getCode() == ResourceException.NOT_FOUND) {\n-                        continue;\n+                            throw ex;\n+                        }\n                     }\n-                    throw ex;\n                 }\n             }\n-            // if new state is updated successfully\n-            // then we need to modify all roles and groups where given principal is member of\n-            if (!updatedUsers.isEmpty()) {\n-\n-                DomainRoleMember domainRoleMember;\n-                DomainGroupMember domainGroupMember;\n-                RoleMember roleMember;\n-                GroupMember groupMember;\n-                List<RoleMember> roleMembersWithUpdatedState;\n-                List<GroupMember> groupMembersWithUpdatedState;\n-                for (Principal updatedUser : updatedUsers) {\n-                    try {\n-                        // get all roles from all domains\n-                        domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n-                        if (!domainRoleMember.getMemberRoles().isEmpty()) {\n-                            for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n-                                roleMember = new RoleMember();\n-                                roleMember.setMemberName(updatedUser.getFullName());\n-                                switch (newState) {\n-                                    case ACTIVE:\n-                                        // if new state is ACTIVE then revert back to previous state for the member\n-                                        roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~newState.getValue());\n-                                        break;\n-                                    case AUTHORITY_SYSTEM_DISABLED:\n-                                        // if new state is SYSTEM_DISABLED then add it on to existing state\n-                                        roleMember.setSystemDisabled(memberRole.getSystemDisabled() | newState.getValue());\n-                                        break;\n-                                    default:\n-                                        break;\n-                                }\n-                                roleMembersWithUpdatedState = new ArrayList<>();\n-                                roleMembersWithUpdatedState.add(roleMember);\n-\n-                                // Following method does Audit entry as well\n-                                if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n-                                        memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-\n-                                    // update our role and domain time-stamps, and invalidate local cache entry\n-                                    con.updateRoleModTimestamp(memberRole.getDomainName(), memberRole.getRoleName());\n-                                    con.updateDomainModTimestamp(memberRole.getDomainName());\n-                                    cacheStore.invalidate(memberRole.getDomainName());\n-                                }\n-                            }\n-                        }\n-                        domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n-                        if (!domainGroupMember.getMemberGroups().isEmpty()) {\n-                            for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n-                                groupMember = new GroupMember();\n-                                groupMember.setMemberName(updatedUser.getFullName());\n-                                switch (newState) {\n-                                    case ACTIVE:\n-                                        // if new state is ACTIVE then revert back to previous state for the member\n-                                        groupMember.setSystemDisabled(currentGroup.getSystemDisabled() & ~newState.getValue());\n-                                        break;\n-                                    case AUTHORITY_SYSTEM_DISABLED:\n-                                        // if new state is SYSTEM_DISABLED then add it on to existing state\n-                                        groupMember.setSystemDisabled(currentGroup.getSystemDisabled() | newState.getValue());\n-                                        break;\n-                                    default:\n-                                        break;\n-                                }\n-                                groupMembersWithUpdatedState = new ArrayList<>();\n-                                groupMembersWithUpdatedState.add(groupMember);\n-\n-                                // Following method does Audit entry as well\n-                                if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n-                                        currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-\n-                                    // update our group and domain time-stamps, and invalidate local cache entry\n-\n-                                    con.updateGroupModTimestamp(currentGroup.getDomainName(), currentGroup.getGroupName());\n-                                    con.updateDomainModTimestamp(currentGroup.getDomainName());\n-                                    cacheStore.invalidate(currentGroup.getDomainName());\n-                                }\n-                            }\n-                        }\n-                    } catch (ResourceException ex) {\n-                        if (ex.getCode() == ResourceException.NOT_FOUND) {\n-                            continue;\n-                        }\n-                        throw ex;\n-                    }\n+        }\n+    }\n+\n+    private void updateGroupMembershipByPrincipalState(boolean suspended, String caller, ObjectStoreConnection con, Principal updatedUser) {\n+        List<GroupMember> groupMembersWithUpdatedState;\n+        GroupMember groupMember;\n+        DomainGroupMember domainGroupMember;\n+        Set<GroupMember> updatedGroups = new HashSet<>();\n+\n+        domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n+        if (!domainGroupMember.getMemberGroups().isEmpty()) {\n+            for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n+                groupMember = new GroupMember();\n+                groupMember.setMemberName(updatedUser.getFullName());\n+                if (suspended) {\n+                    groupMember.setSystemDisabled(currentGroup.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                } else {\n+                    groupMember.setSystemDisabled(currentGroup.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                }\n+                groupMembersWithUpdatedState = new ArrayList<>();\n+                groupMembersWithUpdatedState.add(groupMember);\n+\n+                // Following method does Audit entry as well\n+                if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n+                        currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n+                    updatedGroups.add(currentGroup);\n+                }\n+            }\n+            for (GroupMember updatedGM : updatedGroups) {\n+\n+                // update our group and domain time-stamps, and invalidate local cache entry\n+                con.updateGroupModTimestamp(updatedGM.getDomainName(), updatedGM.getGroupName());\n+                con.updateDomainModTimestamp(updatedGM.getDomainName());\n+                cacheStore.invalidate(updatedGM.getDomainName());\n+            }\n+        }\n+    }\n+\n+    private void updateRoleMembershipsByPrincipalState(boolean suspended, String caller, ObjectStoreConnection con, Principal updatedUser) {\n+        RoleMember roleMember;\n+        List<RoleMember> roleMembersWithUpdatedState;\n+        DomainRoleMember domainRoleMember;\n+        Set<MemberRole> updatedRoles = new HashSet<>();\n+\n+        domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n+        if (!domainRoleMember.getMemberRoles().isEmpty()) {\n+            for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n+                roleMember = new RoleMember();\n+                roleMember.setMemberName(updatedUser.getFullName());\n+                if (suspended) {\n+                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                } else {\n+                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                }\n+                roleMembersWithUpdatedState = new ArrayList<>();\n+                roleMembersWithUpdatedState.add(roleMember);\n+\n+                // Following method does Audit entry as well\n+                if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n+                        memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n+                    updatedRoles.add(memberRole);\n+                }\n+            }\n+            for (MemberRole updatedMR : updatedRoles) {\n+\n+                // update our role and domain time-stamps, and invalidate local cache entry\n+                con.updateRoleModTimestamp(updatedMR.getDomainName(), updatedMR.getRoleName());\n+                con.updateDomainModTimestamp(updatedMR.getDomainName());\n+                cacheStore.invalidate(updatedMR.getDomainName());\n+            }\n+        }\n+    }\n+\n+    private void updatePrincipalState(boolean suspended, List<Principal> updatedUsers, ObjectStoreConnection con, Principal changedPrincipal) {\n+        try {\n+            if (suspended) {\n+                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue())) {\n+                    updatedUsers.add(changedPrincipal);\n+                }\n+            } else {\n+                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.ACTIVE.getValue())) {\n+                    updatedUsers.add(changedPrincipal);\n                 }\n             }\n+        } catch (ResourceException ex) {\n+            LOG.error(\"Exception in updating principal state from Authority {} Moving on.\", ex.getMessage());\n         }\n     }\n \n", "next_change": {"commit": "0dff4be75160c89e9e35b4634db11456460fa25f", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 2d11e7268..08f2ee72e 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6497,50 +6512,29 @@ public class DBService implements RolesProvider {\n         RoleMember roleMember;\n         List<RoleMember> roleMembersWithUpdatedState;\n         DomainRoleMember domainRoleMember;\n-        Set<MemberRole> updatedRoles = new HashSet<>();\n-\n+        int newState;\n+        Set<String> updatedDomains = new HashSet<>();\n         domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n         if (!domainRoleMember.getMemberRoles().isEmpty()) {\n             for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n                 roleMember = new RoleMember();\n                 roleMember.setMemberName(updatedUser.getFullName());\n-                if (suspended) {\n-                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                } else {\n-                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                }\n-                roleMembersWithUpdatedState = new ArrayList<>();\n-                roleMembersWithUpdatedState.add(roleMember);\n+                newState = suspended ? memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n+                        memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n+                roleMember.setSystemDisabled(newState);\n+                roleMembersWithUpdatedState = Collections.singletonList(roleMember);\n \n                 // Following method does Audit entry as well\n                 if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n                         memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-                    updatedRoles.add(memberRole);\n+                    con.updateRoleModTimestamp(memberRole.getDomainName(), memberRole.getRoleName());\n+                    updatedDomains.add(memberRole.getDomainName());\n                 }\n             }\n-            for (MemberRole updatedMR : updatedRoles) {\n-\n-                // update our role and domain time-stamps, and invalidate local cache entry\n-                con.updateRoleModTimestamp(updatedMR.getDomainName(), updatedMR.getRoleName());\n-                con.updateDomainModTimestamp(updatedMR.getDomainName());\n-                cacheStore.invalidate(updatedMR.getDomainName());\n-            }\n-        }\n-    }\n-\n-    private void updatePrincipalState(boolean suspended, List<Principal> updatedUsers, ObjectStoreConnection con, Principal changedPrincipal) {\n-        try {\n-            if (suspended) {\n-                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue())) {\n-                    updatedUsers.add(changedPrincipal);\n-                }\n-            } else {\n-                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.ACTIVE.getValue())) {\n-                    updatedUsers.add(changedPrincipal);\n-                }\n-            }\n-        } catch (ResourceException ex) {\n-            LOG.error(\"Exception in updating principal state from Authority {} Moving on.\", ex.getMessage());\n+            updatedDomains.forEach(dom -> {\n+                con.updateDomainModTimestamp(dom);\n+                cacheStore.invalidate(dom);\n+            });\n         }\n     }\n \n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 2c6958b49..08f2ee72e 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6426,113 +6427,46 @@ public class DBService implements RolesProvider {\n      * This method toggles state for supplied Principals based on the flag in DB\n      * as well as modifies memberships of all roles and groups of current principal(s)\n      * @param changedPrincipals List of Principals from User Authority\n-     * @param newState new state {@link Principal.State}\n+     * @param suspended boolean indicating principal's state\n      */\n-    void updatePrincipalBasedOnAuthorityState(List<Principal> changedPrincipals, Principal.State newState) {\n-        final String caller = \"updateMembershipBasedOnUserState\";\n+    void updatePrincipalByStateFromAuthority(List<Principal> changedPrincipals, boolean suspended) {\n+\n+        if (changedPrincipals.isEmpty()) {\n+            return;\n+        }\n+\n+        final String caller = \"updatePrincipalByStateFromAuthority\";\n         List<Principal> updatedUsers = new ArrayList<>();\n+        int newPrincipalState = suspended ? Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() : Principal.State.ACTIVE.getValue();\n         try (ObjectStoreConnection con = store.getConnection(true, true)) {\n \n             // first lets update the new state in DB\n             for (Principal changedPrincipal : changedPrincipals) {\n                 try {\n-                    switch (newState) {\n-                        case ACTIVE:\n-                            if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.ACTIVE.getValue())) {\n-                                updatedUsers.add(changedPrincipal);\n-                            }\n-                            break;\n-                        case AUTHORITY_SYSTEM_DISABLED:\n-                            if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.AUTHORITY_SYSTEM_DISABLED.getValue())) {\n-                                updatedUsers.add(changedPrincipal);\n-                            }\n-                            break;\n-                        default:\n-                            break;\n+                    if (con.updatePrincipal(changedPrincipal.getFullName(), newPrincipalState)) {\n+                        updatedUsers.add(changedPrincipal);\n                     }\n                 } catch (ResourceException ex) {\n-                    if (ex.getCode() == ResourceException.NOT_FOUND) {\n-                        continue;\n-                    }\n-                    throw ex;\n+                    // log the exception and continue with remaining principals\n+                    LOG.error(\"Exception in updating principal state from Authority {} Moving on.\", ex.getMessage());\n                 }\n             }\n             // if new state is updated successfully\n             // then we need to modify all roles and groups where given principal is member of\n             if (!updatedUsers.isEmpty()) {\n-\n-                DomainRoleMember domainRoleMember;\n-                DomainGroupMember domainGroupMember;\n-                RoleMember roleMember;\n-                GroupMember groupMember;\n-                List<RoleMember> roleMembersWithUpdatedState;\n-                List<GroupMember> groupMembersWithUpdatedState;\n                 for (Principal updatedUser : updatedUsers) {\n+                    // separate try blocks to treat group and role membership 404s separately\n                     try {\n-                        // get all roles from all domains\n-                        domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n-                        if (!domainRoleMember.getMemberRoles().isEmpty()) {\n-                            for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n-                                roleMember = new RoleMember();\n-                                roleMember.setMemberName(updatedUser.getFullName());\n-                                switch (newState) {\n-                                    case ACTIVE:\n-                                        // if new state is ACTIVE then revert back to previous state for the member\n-                                        roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~newState.getValue());\n-                                        break;\n-                                    case AUTHORITY_SYSTEM_DISABLED:\n-                                        // if new state is SYSTEM_DISABLED then add it on to existing state\n-                                        roleMember.setSystemDisabled(memberRole.getSystemDisabled() | newState.getValue());\n-                                        break;\n-                                    default:\n-                                        break;\n-                                }\n-                                roleMembersWithUpdatedState = new ArrayList<>();\n-                                roleMembersWithUpdatedState.add(roleMember);\n-\n-                                // Following method does Audit entry as well\n-                                if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n-                                        memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-\n-                                    // update our role and domain time-stamps, and invalidate local cache entry\n-                                    con.updateRoleModTimestamp(memberRole.getDomainName(), memberRole.getRoleName());\n-                                    con.updateDomainModTimestamp(memberRole.getDomainName());\n-                                    cacheStore.invalidate(memberRole.getDomainName());\n-                                }\n-                            }\n-                        }\n-                        domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n-                        if (!domainGroupMember.getMemberGroups().isEmpty()) {\n-                            for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n-                                groupMember = new GroupMember();\n-                                groupMember.setMemberName(updatedUser.getFullName());\n-                                switch (newState) {\n-                                    case ACTIVE:\n-                                        // if new state is ACTIVE then revert back to previous state for the member\n-                                        groupMember.setSystemDisabled(currentGroup.getSystemDisabled() & ~newState.getValue());\n-                                        break;\n-                                    case AUTHORITY_SYSTEM_DISABLED:\n-                                        // if new state is SYSTEM_DISABLED then add it on to existing state\n-                                        groupMember.setSystemDisabled(currentGroup.getSystemDisabled() | newState.getValue());\n-                                        break;\n-                                    default:\n-                                        break;\n-                                }\n-                                groupMembersWithUpdatedState = new ArrayList<>();\n-                                groupMembersWithUpdatedState.add(groupMember);\n-\n-                                // Following method does Audit entry as well\n-                                if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n-                                        currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-\n-                                    // update our group and domain time-stamps, and invalidate local cache entry\n-\n-                                    con.updateGroupModTimestamp(currentGroup.getDomainName(), currentGroup.getGroupName());\n-                                    con.updateDomainModTimestamp(currentGroup.getDomainName());\n-                                    cacheStore.invalidate(currentGroup.getDomainName());\n-                                }\n-                            }\n+                        updateRoleMembershipsByPrincipalState(suspended, caller, con, updatedUser);\n+                    } catch (ResourceException ex) {\n+                        if (ex.getCode() == ResourceException.NOT_FOUND) {\n+                            continue;\n                         }\n+                        throw ex;\n+                    }\n+                    // separate try blocks to treat group and role membership 404s separately\n+                    try {\n+                        updateGroupMembershipByPrincipalState(suspended, caller, con, updatedUser);\n                     } catch (ResourceException ex) {\n                         if (ex.getCode() == ResourceException.NOT_FOUND) {\n                             continue;\n", "next_change": null}]}, "commits_in_main": [{"oid": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "message": "Merge commit", "committedDate": null}, {"oid": "9a9c82c13d156e06dad8464c3a6c52c8e2bc6b89", "committedDate": "2020-10-26 14:15:03 -0700", "message": "remove sending back deprected members field in roles (#1160)"}, {"oid": "31a0dd7362f585f85992d4ff86fbf975d9d736dd", "committedDate": "2020-10-31 14:59:07 -0700", "message": "add azure_subscription field to domains (#1167)"}, {"oid": "c668f48cec94e2c928581b92ffb517f715a4840f", "committedDate": "2020-11-06 18:05:10 -0800", "message": "handle sys disabled null scenario (#1176)"}, {"oid": "f24d15baaaddc96c85fbceb31fcaded756a69f2e", "committedDate": "2020-11-14 16:51:57 -0800", "message": "role tags - generated code and schema changes (#1179)"}, {"oid": "30e272d8a9ec2649a1d876c1c111cf38e27c1743", "committedDate": "2020-12-07 08:48:58 -0800", "message": "putRoleMeta tags support (#1208)"}, {"oid": "f0e0a91b80250236244db9f8cba79e1def809995", "committedDate": "2020-12-23 15:40:53 -0800", "message": "updating group expiry date (#1221)"}, {"oid": "7a2837c7578ab8d36c62b48ecb1d0079c670616b", "committedDate": "2020-12-29 13:44:04 -0800", "message": "granular authz action for managing role members (#1228)"}, {"oid": "d6a0d659fe96486ffcf31bb93e919656be9eaf89", "committedDate": "2021-01-13 08:15:47 -0800", "message": "domain tags implementation (#1235)"}, {"oid": "3c939966592bf7cc6ff25df12a8d21d4c2c89b2b", "committedDate": "2021-01-19 22:05:22 -0800", "message": "client api update for rich authorization requests and consistent naming of entity objects (#1248)"}, {"oid": "3db6ed7b169fce5bbeaa1fae84ff7881e9a4e435", "committedDate": "2021-01-21 09:17:41 -0800", "message": "limit number of role and domain tags (#1255)"}, {"oid": "218b71958d88fb039dfa6e7c5448c7e4d00cb337", "committedDate": "2021-01-25 17:53:41 -0800", "message": "update domain last modified timestamp after tag update (#1262)"}, {"oid": "bccc5fb4dc1c2407a0293f322c3d97711af4297c", "committedDate": "2021-03-07 18:11:58 -0800", "message": "sonarcloud: method always returns same result (#1329)"}, {"oid": "e421f20094d24075d2cec7ab7adecff7d630a286", "committedDate": "2021-03-16 18:08:03 -0700", "message": "expose new domain attribute: business-service (#1357)"}, {"oid": "7b4afd5d40394226b3aa1af8bf10e90e528091b3", "committedDate": "2021-04-01 14:52:30 -0700", "message": "Add memberExpiryDays and serviceExpiryDays support for groups (#1388)"}, {"oid": "5ab30978cc4fc03e1b3022305f6e14a5a425e9e9", "committedDate": "2021-04-07 16:30:50 -0700", "message": "new DomainMetaStore interface support in ZMS (#1430)"}, {"oid": "9bedde4310d6493406d264422f23e16f33213546", "committedDate": "2021-04-08 09:44:29 -0700", "message": "Add group review days to role (#1428)"}, {"oid": "a554c75c51c5945b0e58ae87866de93ff1d5cfbc", "committedDate": "2021-04-15 12:12:02 -0700", "message": "during provider admin setup, ignore deletes (#1444)"}, {"oid": "1c564548381b3c09ad4214d0f30c667e9cc0d022", "committedDate": "2021-04-30 15:22:51 -0700", "message": "log full policy assertion details during delete operations in audit log (#1469)"}, {"oid": "611ac334bfbc1c43ec20154cf9448b96fae365d6", "committedDate": "2021-05-27 16:30:38 -0700", "message": "handle null contition processDomainTags (#1495)"}, {"oid": "addf4424a5bf842b58558c6f61ac0b46277d9535", "committedDate": "2021-06-07 09:38:12 -0700", "message": "allow role/group review regardless of role/group expiry/reminder settings (#1503)"}, {"oid": "4b39ffbd18da3d10a581fb10209806c97b432d28", "committedDate": "2021-06-09 15:31:17 -0700", "message": "enable role review without setting restrictions (#1512)"}, {"oid": "898ff0aa4fddd1a9ed111496cb9e4acb544605af", "committedDate": "2021-06-14 10:42:10 -0700", "message": "Update Tag Values to include '/', ':' (#1517)"}, {"oid": "cf535673b0a4cbcdc81e17c7def4cb6822edd78c", "committedDate": "2021-06-22 06:44:42 -0700", "message": "Allow system admins to set domain meta attribute business service (#1522)"}, {"oid": "934fc3d7fc859731f4beab3b03b83a15ac717a2d", "committedDate": "2021-06-29 12:57:53 -0700", "message": "assertion condition server changes (#1528)"}, {"oid": "1fa51b852890c1576254be6a8a2b5dbebc89865c", "committedDate": "2021-07-21 14:41:19 -0700", "message": "UI : update error message (#1557)"}, {"oid": "09de45bb794eb5e7c29f705b5ce567c75fde4e84", "committedDate": "2021-07-29 15:49:16 -0700", "message": "multi-version policy - introducing version/active in policy object (#1568)"}, {"oid": "4abff4b9952e4836f79bf3f1934baf8fe2bcebf9", "committedDate": "2021-08-08 11:39:07 -0700", "message": "Disable Reminder Review Notifications By Tag zms.DisableReminderNotifications (#1579)"}, {"oid": "6a1523accc3ec83fe54d78c3d919d9cddbcb1b7e", "committedDate": "2021-08-17 18:32:28 -0700", "message": "fixing the order of updates for assertion condition api operations (#1591)"}, {"oid": "66590f4fc47f899f3990f20895f953074e40f259", "committedDate": "2021-09-10 07:55:42 -0700", "message": "Implement multi-version policies endpoints (#1605)"}, {"oid": "1ad624427917493d31bd1b8ffa6303c4d6353055", "committedDate": "2021-09-10 13:51:19 -0700", "message": "update group last modified when user is deleted (#1613)"}, {"oid": "91b116418656f123dae9a3405cb2e498d4d3aff4", "committedDate": "2021-09-12 09:52:05 +0300", "message": "additional validation checks when processing versioned policies (#1614)"}, {"oid": "2531428956f87774f86721f02b430861ca8897ec", "committedDate": "2021-09-14 09:49:34 +0300", "message": "additional checks when setting a policy version as active (#1615)"}, {"oid": "2968c209e870ce57fbdb1fb048a21692d80cfea6", "committedDate": "2021-10-01 07:25:34 -0700", "message": "rdl publishChangeEvents generator (#1624)"}, {"oid": "8a6960ce9878277c5abda1d104ca070831b36230", "committedDate": "2021-10-03 13:48:03 -0700", "message": "Allow specifying version name when creating new policy (#1630)"}, {"oid": "43f619b31bbd9cc3d388aa7ea29eff889cb1272d", "committedDate": "2021-10-21 08:48:51 -0700", "message": "For role expiry notification - record metrics daily while (#1654)"}, {"oid": "389f984270d7d89070c66096e87fafbcb24a261c", "committedDate": "2021-10-26 08:17:36 -0700", "message": "Group tags implementation (#1660)"}, {"oid": "120ab1fa8e9d33fa793c4254d233a09a2c23d173", "committedDate": "2021-10-29 15:08:28 -0700", "message": "Disable Group Expiry Notifications By Tag zms.DisableReminderNotifications (#1663)"}, {"oid": "1400363e8d698cf08370c89752077ebae043c5be", "committedDate": "2021-12-14 13:48:34 -0800", "message": "correct logging of role principal in audit/access logs"}, {"oid": "c8e3a5c91c5deb9640576cd3496a2af11d572f0b", "committedDate": "2021-12-23 15:03:25 -0800", "message": "protect system admin users from being removed from deleteUser api (#1715)"}, {"oid": "020e06e57b357768260f509f08b75c5c068bce53", "committedDate": "2022-02-07 08:01:55 -0800", "message": "Service Visiblity - Domain Dependencies (#1758)"}, {"oid": "fcbd4128e334a9a42f4579d179cf9578d3f4de99", "committedDate": "2022-02-07 10:12:47 -0800", "message": "support new get-stats endpoint to get per-domain/system stats (#1774)"}, {"oid": "ea831a34a70a0475bea8754cb183741dced98ff2", "committedDate": "2022-02-18 09:17:55 -0800", "message": "update pending member api to support getting list for a domain (#1783)"}, {"oid": "f4229124e8e1898810c7aa7b3a4eff37fddae308", "committedDate": "2022-02-18 12:37:32 -0800", "message": "provide option to skip adding principal when onboarding a resource group (#1787)"}, {"oid": "9081feb4c06a1058c941c67923037203d9318cfa", "committedDate": "2022-02-27 14:10:46 -0800", "message": "Domain Dependency for Tenancy (#1789)"}, {"oid": "a5bb615881583fa6f39621e2ea3bf39d3886340b", "committedDate": "2022-03-03 17:20:00 -0800", "message": "extend template keyword support trust field in roles (#1803)"}, {"oid": "3de182bcbedba89fa2aaba12ab9be49aa2156096", "committedDate": "2022-03-19 09:45:40 -0700", "message": "Add provider webhook for verifying removal (#1816)"}, {"oid": "1b0cff1cb9b8e4a231c5cfb342d76b6aad8e08fc", "committedDate": "2022-04-07 14:34:23 -0700", "message": "no need to update domain's last mod timestamp during put dependency call (#1846)"}, {"oid": "baa68eacd6a6b9bbc70c3423006f92cd47b784d7", "committedDate": "2022-05-19 09:30:02 -0700", "message": "Get Auth History implementation (#1875)"}, {"oid": "bea97b165e28b5b2cc286af62c92e536c9fc3ff2", "committedDate": "2022-06-03 13:50:01 -0700", "message": "AuthHistory - Return dependencies instead of list (#1888)"}, {"oid": "7a313e1d581295ae6c786bbc2ed73bb14da37f7d", "committedDate": "2022-07-21 20:16:24 -0700", "message": "allow management of domain memberPurgeExpiryDays setting value (#1928)"}, {"oid": "f288ed7afb018bc07af02dbe9dc8e05ec0896071", "committedDate": "2022-08-15 22:28:01 -0700", "message": "provide header option to return updated object in response (#1942)"}, {"oid": "949bd0634d328d04736b912a002bdfa7421d9f2b", "committedDate": "2022-08-23 10:28:38 -0700", "message": "fix returning role/group objects when requested by ui (#1945)"}, {"oid": "ab7284c9274f4949d23f88ec0dde7b689c0c6980", "committedDate": "2022-09-05 13:12:17 -0700", "message": "auto purge expired role/group members based on server/domain config (#1941)"}, {"oid": "4ab6e748891a014a8b0a1364de099d3fbf4c7468", "committedDate": "2022-09-21 22:22:48 -0700", "message": "enable readWrite db connection for delete expired members (#1964)"}, {"oid": "d4c733d3e97467a598ba44f0bde5c6a907aa01de", "committedDate": "2022-09-23 13:30:24 -0700", "message": "consistent use of The Athenz Authors copyright in all files (#1967)"}, {"oid": "45dcdab92d9e39d5d561b34ef222f863176cc635", "committedDate": "2022-09-26 12:29:01 -0700", "message": "make server purge expiry member day configurable (#1968)"}, {"oid": "d823cccb5163f950655f3859ade41fe031910588", "committedDate": "2022-10-06 14:20:20 -0700", "message": "fix putServiceIdentity logic to allow update of exising pubKey (#1978)"}, {"oid": "91d38ef548e59e29e69349b8a0f5151456b62a0f", "committedDate": "2022-10-07 15:36:36 -0700", "message": "Use correct object type for role member delete notifications (#1981)"}, {"oid": "1d970ce72c2f81aed5576fff068103bbba022aaf", "committedDate": "2022-11-29 23:50:29 +0200", "message": "add gcp project attribute for domains (#2005)"}, {"oid": "c292a1a2fb6e3a300a3060a6bcea6a96f696932c", "committedDate": "2022-12-13 08:56:43 -0800", "message": "Return the correct response from putMembership/putGroupMembership once a pending member was added (#2023)"}, {"oid": "fc5a206d1cb23dd2bbfd9af7e3125ec270ebc022", "committedDate": "2023-01-10 21:48:12 -0800", "message": "allow domain admins to enable audit flag for new roles/groups (#2032)"}, {"oid": "70850ab1de4055e765cf4ead6946b431900ff8c8", "committedDate": "2023-01-23 16:40:36 -0800", "message": "move cloud provider role generation logic out of dbstore library to dbservice (#2043)"}, {"oid": "0ff7ff4f9658fd42e8ee2161d870a89dce5167e4", "committedDate": "2023-02-02 09:18:32 -0800", "message": "Add a requirement for admin approval to delete members in review-enabled roles (#2053)"}, {"oid": "ff57628b890f53c43fec6dd2cacf98a574c95b2d", "committedDate": "2023-02-08 15:55:32 -0800", "message": "extends group with deleteProtection attribute and pending group membe\u2026 (#2067)"}, {"oid": "bb1d69af70a90aeedc28a46604283064e0dad8de", "committedDate": "2023-02-16 07:44:40 -0800", "message": "add audit enable to role (#2055)"}, {"oid": "4ee14d784973ce7da8aba96b35eefdbc5d61d97b", "committedDate": "2023-03-07 11:34:04 -0800", "message": "make aws/gcp assume role action values configurable (#2090)"}, {"oid": "5216da47ef8bca89ba0eae790f72739d9d73fcc6", "committedDate": "2023-03-09 10:36:29 -0800", "message": "Add optional 'description' to role (#2091)"}, {"oid": "d1b98d4614d62fe34b408cfa1a26fb59674d6494", "committedDate": "2023-03-27 16:46:33 -0700", "message": "store GCP project number along with project id in athenz domain metadata (#2113)"}, {"oid": "715cf96c679e817600a0a25160c96878e5eda735", "committedDate": "2023-03-27 18:01:33 -0700", "message": "special resource for gcp starting with service/ (#2115)"}, {"oid": "6e7342a1e98207b87e3eae45341db281b7b3b9c7", "committedDate": "2023-04-13 14:30:39 -0700", "message": "designate separate action for assertions when assuming gcp service accounts (#2127)"}, {"oid": "523f7f753fa2a4a112ae4fb7a5389203af8b9594", "committedDate": "2023-05-29 08:52:21 -0700", "message": "fix role update on expiration and review dates (#2185)"}, {"oid": "7069bf871635c4e5308d37341904241388b1ccda", "committedDate": "2023-05-30 15:31:26 -0700", "message": "support product id (string) format association with domains (#2193)"}, {"oid": "368d0bc139931c03d31824c4f02394b38e3ead95", "committedDate": "2023-06-02 13:15:05 -0700", "message": "support headless user type - managed by user authority but treated like service (#2197)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3ODYxMA==", "url": "https://github.com/AthenZ/athenz/pull/1157#discussion_r510478610", "body": "since we might get lots of matches from the same domain (typically a user is included in smaller number of domains in lots of roles), we should probably keep track of domains in a set and then update the set at the end so that each domain is only updated once instead of multiple db calls.", "bodyText": "since we might get lots of matches from the same domain (typically a user is included in smaller number of domains in lots of roles), we should probably keep track of domains in a set and then update the set at the end so that each domain is only updated once instead of multiple db calls.", "bodyHTML": "<p dir=\"auto\">since we might get lots of matches from the same domain (typically a user is included in smaller number of domains in lots of roles), we should probably keep track of domains in a set and then update the set at the end so that each domain is only updated once instead of multiple db calls.</p>", "author": "havetisyan", "createdAt": "2020-10-22T21:50:20Z", "path": "servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java", "diffHunk": "@@ -6402,6 +6403,147 @@ void enforceGroupUserAuthorityRestrictions(final String domainName, final String\n         }\n     }\n \n+    /**\n+     * This method returns list of Principals based on the state parameter supplied\n+     * @param queriedState state of principal\n+     * @return List of Principals from DB\n+     */\n+    List<Principal> getPrincipals(int queriedState) {\n+        List<Principal> principals = new ArrayList<>();\n+        Principal principal;\n+        try (ObjectStoreConnection con = store.getConnection(true, false)) {\n+           List<String> dbPrincipals = con.getPrincipals(queriedState);\n+           for (String dbPrincipal : dbPrincipals) {\n+               principal = ZMSUtils.createPrincipalForName(dbPrincipal, zmsConfig.getUserDomain(), null);\n+               ((SimplePrincipal) principal).setState(Principal.State.getState(queriedState));\n+               principals.add(principal);\n+           }\n+        }\n+        return principals;\n+    }\n+\n+    /**\n+     * This method toggles state for supplied Principals based on the flag in DB\n+     * as well as modifies memberships of all roles and groups of current principal(s)\n+     * @param changedPrincipals List of Principals from User Authority\n+     * @param newState new state {@link Principal.State}\n+     */\n+    void updatePrincipalBasedOnAuthorityState(List<Principal> changedPrincipals, Principal.State newState) {\n+        final String caller = \"updateMembershipBasedOnUserState\";\n+        List<Principal> updatedUsers = new ArrayList<>();\n+        try (ObjectStoreConnection con = store.getConnection(true, true)) {\n+\n+            // first lets update the new state in DB\n+            for (Principal changedPrincipal : changedPrincipals) {\n+                try {\n+                    switch (newState) {\n+                        case ACTIVE:\n+                            if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.ACTIVE.getValue())) {\n+                                updatedUsers.add(changedPrincipal);\n+                            }\n+                            break;\n+                        case AUTHORITY_SYSTEM_DISABLED:\n+                            if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.AUTHORITY_SYSTEM_DISABLED.getValue())) {\n+                                updatedUsers.add(changedPrincipal);\n+                            }\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+                } catch (ResourceException ex) {\n+                    if (ex.getCode() == ResourceException.NOT_FOUND) {\n+                        continue;\n+                    }\n+                    throw ex;\n+                }\n+            }\n+            // if new state is updated successfully\n+            // then we need to modify all roles and groups where given principal is member of\n+            if (!updatedUsers.isEmpty()) {\n+\n+                DomainRoleMember domainRoleMember;\n+                DomainGroupMember domainGroupMember;\n+                RoleMember roleMember;\n+                GroupMember groupMember;\n+                List<RoleMember> roleMembersWithUpdatedState;\n+                List<GroupMember> groupMembersWithUpdatedState;\n+                for (Principal updatedUser : updatedUsers) {\n+                    try {\n+                        // get all roles from all domains\n+                        domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n+                        if (!domainRoleMember.getMemberRoles().isEmpty()) {\n+                            for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n+                                roleMember = new RoleMember();\n+                                roleMember.setMemberName(updatedUser.getFullName());\n+                                switch (newState) {\n+                                    case ACTIVE:\n+                                        // if new state is ACTIVE then revert back to previous state for the member\n+                                        roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~newState.getValue());\n+                                        break;\n+                                    case AUTHORITY_SYSTEM_DISABLED:\n+                                        // if new state is SYSTEM_DISABLED then add it on to existing state\n+                                        roleMember.setSystemDisabled(memberRole.getSystemDisabled() | newState.getValue());\n+                                        break;\n+                                    default:\n+                                        break;\n+                                }\n+                                roleMembersWithUpdatedState = new ArrayList<>();\n+                                roleMembersWithUpdatedState.add(roleMember);\n+\n+                                // Following method does Audit entry as well\n+                                if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n+                                        memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n+\n+                                    // update our role and domain time-stamps, and invalidate local cache entry\n+                                    con.updateRoleModTimestamp(memberRole.getDomainName(), memberRole.getRoleName());\n+                                    con.updateDomainModTimestamp(memberRole.getDomainName());", "originalCommit": "45b271a460205ef873d48d4247128daa43779d54", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f2b6979e4235f325d7eea75d6f63d358c03d8d3c", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 2c6958b49..2d11e7268 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6426,121 +6427,120 @@ public class DBService implements RolesProvider {\n      * This method toggles state for supplied Principals based on the flag in DB\n      * as well as modifies memberships of all roles and groups of current principal(s)\n      * @param changedPrincipals List of Principals from User Authority\n-     * @param newState new state {@link Principal.State}\n+     * @param suspended boolean indicating principal's state\n      */\n-    void updatePrincipalBasedOnAuthorityState(List<Principal> changedPrincipals, Principal.State newState) {\n-        final String caller = \"updateMembershipBasedOnUserState\";\n+    void updatePrincipalByStateFromAuthority(List<Principal> changedPrincipals, boolean suspended) {\n+        final String caller = \"updatePrincipalByStateFromAuthority\";\n         List<Principal> updatedUsers = new ArrayList<>();\n-        try (ObjectStoreConnection con = store.getConnection(true, true)) {\n+        if (!changedPrincipals.isEmpty()) {\n+            try (ObjectStoreConnection con = store.getConnection(true, true)) {\n \n-            // first lets update the new state in DB\n-            for (Principal changedPrincipal : changedPrincipals) {\n-                try {\n-                    switch (newState) {\n-                        case ACTIVE:\n-                            if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.ACTIVE.getValue())) {\n-                                updatedUsers.add(changedPrincipal);\n-                            }\n-                            break;\n-                        case AUTHORITY_SYSTEM_DISABLED:\n-                            if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.AUTHORITY_SYSTEM_DISABLED.getValue())) {\n-                                updatedUsers.add(changedPrincipal);\n+                // first lets update the new state in DB\n+                for (Principal changedPrincipal : changedPrincipals) {\n+                    updatePrincipalState(suspended, updatedUsers, con, changedPrincipal);\n+                }\n+                // if new state is updated successfully\n+                // then we need to modify all roles and groups where given principal is member of\n+                if (!updatedUsers.isEmpty()) {\n+                    for (Principal updatedUser : updatedUsers) {\n+                        try {\n+                            updateRoleMembershipsByPrincipalState(suspended, caller, con, updatedUser);\n+                            updateGroupMembershipByPrincipalState(suspended, caller, con, updatedUser);\n+                        } catch (ResourceException ex) {\n+                            if (ex.getCode() == ResourceException.NOT_FOUND) {\n+                                continue;\n                             }\n-                            break;\n-                        default:\n-                            break;\n-                    }\n-                } catch (ResourceException ex) {\n-                    if (ex.getCode() == ResourceException.NOT_FOUND) {\n-                        continue;\n+                            throw ex;\n+                        }\n                     }\n-                    throw ex;\n                 }\n             }\n-            // if new state is updated successfully\n-            // then we need to modify all roles and groups where given principal is member of\n-            if (!updatedUsers.isEmpty()) {\n-\n-                DomainRoleMember domainRoleMember;\n-                DomainGroupMember domainGroupMember;\n-                RoleMember roleMember;\n-                GroupMember groupMember;\n-                List<RoleMember> roleMembersWithUpdatedState;\n-                List<GroupMember> groupMembersWithUpdatedState;\n-                for (Principal updatedUser : updatedUsers) {\n-                    try {\n-                        // get all roles from all domains\n-                        domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n-                        if (!domainRoleMember.getMemberRoles().isEmpty()) {\n-                            for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n-                                roleMember = new RoleMember();\n-                                roleMember.setMemberName(updatedUser.getFullName());\n-                                switch (newState) {\n-                                    case ACTIVE:\n-                                        // if new state is ACTIVE then revert back to previous state for the member\n-                                        roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~newState.getValue());\n-                                        break;\n-                                    case AUTHORITY_SYSTEM_DISABLED:\n-                                        // if new state is SYSTEM_DISABLED then add it on to existing state\n-                                        roleMember.setSystemDisabled(memberRole.getSystemDisabled() | newState.getValue());\n-                                        break;\n-                                    default:\n-                                        break;\n-                                }\n-                                roleMembersWithUpdatedState = new ArrayList<>();\n-                                roleMembersWithUpdatedState.add(roleMember);\n-\n-                                // Following method does Audit entry as well\n-                                if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n-                                        memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-\n-                                    // update our role and domain time-stamps, and invalidate local cache entry\n-                                    con.updateRoleModTimestamp(memberRole.getDomainName(), memberRole.getRoleName());\n-                                    con.updateDomainModTimestamp(memberRole.getDomainName());\n-                                    cacheStore.invalidate(memberRole.getDomainName());\n-                                }\n-                            }\n-                        }\n-                        domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n-                        if (!domainGroupMember.getMemberGroups().isEmpty()) {\n-                            for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n-                                groupMember = new GroupMember();\n-                                groupMember.setMemberName(updatedUser.getFullName());\n-                                switch (newState) {\n-                                    case ACTIVE:\n-                                        // if new state is ACTIVE then revert back to previous state for the member\n-                                        groupMember.setSystemDisabled(currentGroup.getSystemDisabled() & ~newState.getValue());\n-                                        break;\n-                                    case AUTHORITY_SYSTEM_DISABLED:\n-                                        // if new state is SYSTEM_DISABLED then add it on to existing state\n-                                        groupMember.setSystemDisabled(currentGroup.getSystemDisabled() | newState.getValue());\n-                                        break;\n-                                    default:\n-                                        break;\n-                                }\n-                                groupMembersWithUpdatedState = new ArrayList<>();\n-                                groupMembersWithUpdatedState.add(groupMember);\n-\n-                                // Following method does Audit entry as well\n-                                if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n-                                        currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-\n-                                    // update our group and domain time-stamps, and invalidate local cache entry\n-\n-                                    con.updateGroupModTimestamp(currentGroup.getDomainName(), currentGroup.getGroupName());\n-                                    con.updateDomainModTimestamp(currentGroup.getDomainName());\n-                                    cacheStore.invalidate(currentGroup.getDomainName());\n-                                }\n-                            }\n-                        }\n-                    } catch (ResourceException ex) {\n-                        if (ex.getCode() == ResourceException.NOT_FOUND) {\n-                            continue;\n-                        }\n-                        throw ex;\n-                    }\n+        }\n+    }\n+\n+    private void updateGroupMembershipByPrincipalState(boolean suspended, String caller, ObjectStoreConnection con, Principal updatedUser) {\n+        List<GroupMember> groupMembersWithUpdatedState;\n+        GroupMember groupMember;\n+        DomainGroupMember domainGroupMember;\n+        Set<GroupMember> updatedGroups = new HashSet<>();\n+\n+        domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n+        if (!domainGroupMember.getMemberGroups().isEmpty()) {\n+            for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n+                groupMember = new GroupMember();\n+                groupMember.setMemberName(updatedUser.getFullName());\n+                if (suspended) {\n+                    groupMember.setSystemDisabled(currentGroup.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                } else {\n+                    groupMember.setSystemDisabled(currentGroup.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                }\n+                groupMembersWithUpdatedState = new ArrayList<>();\n+                groupMembersWithUpdatedState.add(groupMember);\n+\n+                // Following method does Audit entry as well\n+                if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n+                        currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n+                    updatedGroups.add(currentGroup);\n+                }\n+            }\n+            for (GroupMember updatedGM : updatedGroups) {\n+\n+                // update our group and domain time-stamps, and invalidate local cache entry\n+                con.updateGroupModTimestamp(updatedGM.getDomainName(), updatedGM.getGroupName());\n+                con.updateDomainModTimestamp(updatedGM.getDomainName());\n+                cacheStore.invalidate(updatedGM.getDomainName());\n+            }\n+        }\n+    }\n+\n+    private void updateRoleMembershipsByPrincipalState(boolean suspended, String caller, ObjectStoreConnection con, Principal updatedUser) {\n+        RoleMember roleMember;\n+        List<RoleMember> roleMembersWithUpdatedState;\n+        DomainRoleMember domainRoleMember;\n+        Set<MemberRole> updatedRoles = new HashSet<>();\n+\n+        domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n+        if (!domainRoleMember.getMemberRoles().isEmpty()) {\n+            for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n+                roleMember = new RoleMember();\n+                roleMember.setMemberName(updatedUser.getFullName());\n+                if (suspended) {\n+                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                } else {\n+                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                }\n+                roleMembersWithUpdatedState = new ArrayList<>();\n+                roleMembersWithUpdatedState.add(roleMember);\n+\n+                // Following method does Audit entry as well\n+                if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n+                        memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n+                    updatedRoles.add(memberRole);\n+                }\n+            }\n+            for (MemberRole updatedMR : updatedRoles) {\n+\n+                // update our role and domain time-stamps, and invalidate local cache entry\n+                con.updateRoleModTimestamp(updatedMR.getDomainName(), updatedMR.getRoleName());\n+                con.updateDomainModTimestamp(updatedMR.getDomainName());\n+                cacheStore.invalidate(updatedMR.getDomainName());\n+            }\n+        }\n+    }\n+\n+    private void updatePrincipalState(boolean suspended, List<Principal> updatedUsers, ObjectStoreConnection con, Principal changedPrincipal) {\n+        try {\n+            if (suspended) {\n+                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue())) {\n+                    updatedUsers.add(changedPrincipal);\n+                }\n+            } else {\n+                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.ACTIVE.getValue())) {\n+                    updatedUsers.add(changedPrincipal);\n                 }\n             }\n+        } catch (ResourceException ex) {\n+            LOG.error(\"Exception in updating principal state from Authority {} Moving on.\", ex.getMessage());\n         }\n     }\n \n", "next_change": {"commit": "0dff4be75160c89e9e35b4634db11456460fa25f", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 2d11e7268..08f2ee72e 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6497,50 +6512,29 @@ public class DBService implements RolesProvider {\n         RoleMember roleMember;\n         List<RoleMember> roleMembersWithUpdatedState;\n         DomainRoleMember domainRoleMember;\n-        Set<MemberRole> updatedRoles = new HashSet<>();\n-\n+        int newState;\n+        Set<String> updatedDomains = new HashSet<>();\n         domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n         if (!domainRoleMember.getMemberRoles().isEmpty()) {\n             for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n                 roleMember = new RoleMember();\n                 roleMember.setMemberName(updatedUser.getFullName());\n-                if (suspended) {\n-                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                } else {\n-                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                }\n-                roleMembersWithUpdatedState = new ArrayList<>();\n-                roleMembersWithUpdatedState.add(roleMember);\n+                newState = suspended ? memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n+                        memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n+                roleMember.setSystemDisabled(newState);\n+                roleMembersWithUpdatedState = Collections.singletonList(roleMember);\n \n                 // Following method does Audit entry as well\n                 if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n                         memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-                    updatedRoles.add(memberRole);\n+                    con.updateRoleModTimestamp(memberRole.getDomainName(), memberRole.getRoleName());\n+                    updatedDomains.add(memberRole.getDomainName());\n                 }\n             }\n-            for (MemberRole updatedMR : updatedRoles) {\n-\n-                // update our role and domain time-stamps, and invalidate local cache entry\n-                con.updateRoleModTimestamp(updatedMR.getDomainName(), updatedMR.getRoleName());\n-                con.updateDomainModTimestamp(updatedMR.getDomainName());\n-                cacheStore.invalidate(updatedMR.getDomainName());\n-            }\n-        }\n-    }\n-\n-    private void updatePrincipalState(boolean suspended, List<Principal> updatedUsers, ObjectStoreConnection con, Principal changedPrincipal) {\n-        try {\n-            if (suspended) {\n-                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue())) {\n-                    updatedUsers.add(changedPrincipal);\n-                }\n-            } else {\n-                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.ACTIVE.getValue())) {\n-                    updatedUsers.add(changedPrincipal);\n-                }\n-            }\n-        } catch (ResourceException ex) {\n-            LOG.error(\"Exception in updating principal state from Authority {} Moving on.\", ex.getMessage());\n+            updatedDomains.forEach(dom -> {\n+                con.updateDomainModTimestamp(dom);\n+                cacheStore.invalidate(dom);\n+            });\n         }\n     }\n \n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 2c6958b49..08f2ee72e 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6426,113 +6427,46 @@ public class DBService implements RolesProvider {\n      * This method toggles state for supplied Principals based on the flag in DB\n      * as well as modifies memberships of all roles and groups of current principal(s)\n      * @param changedPrincipals List of Principals from User Authority\n-     * @param newState new state {@link Principal.State}\n+     * @param suspended boolean indicating principal's state\n      */\n-    void updatePrincipalBasedOnAuthorityState(List<Principal> changedPrincipals, Principal.State newState) {\n-        final String caller = \"updateMembershipBasedOnUserState\";\n+    void updatePrincipalByStateFromAuthority(List<Principal> changedPrincipals, boolean suspended) {\n+\n+        if (changedPrincipals.isEmpty()) {\n+            return;\n+        }\n+\n+        final String caller = \"updatePrincipalByStateFromAuthority\";\n         List<Principal> updatedUsers = new ArrayList<>();\n+        int newPrincipalState = suspended ? Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() : Principal.State.ACTIVE.getValue();\n         try (ObjectStoreConnection con = store.getConnection(true, true)) {\n \n             // first lets update the new state in DB\n             for (Principal changedPrincipal : changedPrincipals) {\n                 try {\n-                    switch (newState) {\n-                        case ACTIVE:\n-                            if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.ACTIVE.getValue())) {\n-                                updatedUsers.add(changedPrincipal);\n-                            }\n-                            break;\n-                        case AUTHORITY_SYSTEM_DISABLED:\n-                            if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.AUTHORITY_SYSTEM_DISABLED.getValue())) {\n-                                updatedUsers.add(changedPrincipal);\n-                            }\n-                            break;\n-                        default:\n-                            break;\n+                    if (con.updatePrincipal(changedPrincipal.getFullName(), newPrincipalState)) {\n+                        updatedUsers.add(changedPrincipal);\n                     }\n                 } catch (ResourceException ex) {\n-                    if (ex.getCode() == ResourceException.NOT_FOUND) {\n-                        continue;\n-                    }\n-                    throw ex;\n+                    // log the exception and continue with remaining principals\n+                    LOG.error(\"Exception in updating principal state from Authority {} Moving on.\", ex.getMessage());\n                 }\n             }\n             // if new state is updated successfully\n             // then we need to modify all roles and groups where given principal is member of\n             if (!updatedUsers.isEmpty()) {\n-\n-                DomainRoleMember domainRoleMember;\n-                DomainGroupMember domainGroupMember;\n-                RoleMember roleMember;\n-                GroupMember groupMember;\n-                List<RoleMember> roleMembersWithUpdatedState;\n-                List<GroupMember> groupMembersWithUpdatedState;\n                 for (Principal updatedUser : updatedUsers) {\n+                    // separate try blocks to treat group and role membership 404s separately\n                     try {\n-                        // get all roles from all domains\n-                        domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n-                        if (!domainRoleMember.getMemberRoles().isEmpty()) {\n-                            for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n-                                roleMember = new RoleMember();\n-                                roleMember.setMemberName(updatedUser.getFullName());\n-                                switch (newState) {\n-                                    case ACTIVE:\n-                                        // if new state is ACTIVE then revert back to previous state for the member\n-                                        roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~newState.getValue());\n-                                        break;\n-                                    case AUTHORITY_SYSTEM_DISABLED:\n-                                        // if new state is SYSTEM_DISABLED then add it on to existing state\n-                                        roleMember.setSystemDisabled(memberRole.getSystemDisabled() | newState.getValue());\n-                                        break;\n-                                    default:\n-                                        break;\n-                                }\n-                                roleMembersWithUpdatedState = new ArrayList<>();\n-                                roleMembersWithUpdatedState.add(roleMember);\n-\n-                                // Following method does Audit entry as well\n-                                if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n-                                        memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-\n-                                    // update our role and domain time-stamps, and invalidate local cache entry\n-                                    con.updateRoleModTimestamp(memberRole.getDomainName(), memberRole.getRoleName());\n-                                    con.updateDomainModTimestamp(memberRole.getDomainName());\n-                                    cacheStore.invalidate(memberRole.getDomainName());\n-                                }\n-                            }\n-                        }\n-                        domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n-                        if (!domainGroupMember.getMemberGroups().isEmpty()) {\n-                            for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n-                                groupMember = new GroupMember();\n-                                groupMember.setMemberName(updatedUser.getFullName());\n-                                switch (newState) {\n-                                    case ACTIVE:\n-                                        // if new state is ACTIVE then revert back to previous state for the member\n-                                        groupMember.setSystemDisabled(currentGroup.getSystemDisabled() & ~newState.getValue());\n-                                        break;\n-                                    case AUTHORITY_SYSTEM_DISABLED:\n-                                        // if new state is SYSTEM_DISABLED then add it on to existing state\n-                                        groupMember.setSystemDisabled(currentGroup.getSystemDisabled() | newState.getValue());\n-                                        break;\n-                                    default:\n-                                        break;\n-                                }\n-                                groupMembersWithUpdatedState = new ArrayList<>();\n-                                groupMembersWithUpdatedState.add(groupMember);\n-\n-                                // Following method does Audit entry as well\n-                                if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n-                                        currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-\n-                                    // update our group and domain time-stamps, and invalidate local cache entry\n-\n-                                    con.updateGroupModTimestamp(currentGroup.getDomainName(), currentGroup.getGroupName());\n-                                    con.updateDomainModTimestamp(currentGroup.getDomainName());\n-                                    cacheStore.invalidate(currentGroup.getDomainName());\n-                                }\n-                            }\n+                        updateRoleMembershipsByPrincipalState(suspended, caller, con, updatedUser);\n+                    } catch (ResourceException ex) {\n+                        if (ex.getCode() == ResourceException.NOT_FOUND) {\n+                            continue;\n                         }\n+                        throw ex;\n+                    }\n+                    // separate try blocks to treat group and role membership 404s separately\n+                    try {\n+                        updateGroupMembershipByPrincipalState(suspended, caller, con, updatedUser);\n                     } catch (ResourceException ex) {\n                         if (ex.getCode() == ResourceException.NOT_FOUND) {\n                             continue;\n", "next_change": null}]}, "commits_in_main": [{"oid": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "message": "Merge commit", "committedDate": null}, {"oid": "9a9c82c13d156e06dad8464c3a6c52c8e2bc6b89", "committedDate": "2020-10-26 14:15:03 -0700", "message": "remove sending back deprected members field in roles (#1160)"}, {"oid": "31a0dd7362f585f85992d4ff86fbf975d9d736dd", "committedDate": "2020-10-31 14:59:07 -0700", "message": "add azure_subscription field to domains (#1167)"}, {"oid": "c668f48cec94e2c928581b92ffb517f715a4840f", "committedDate": "2020-11-06 18:05:10 -0800", "message": "handle sys disabled null scenario (#1176)"}, {"oid": "f24d15baaaddc96c85fbceb31fcaded756a69f2e", "committedDate": "2020-11-14 16:51:57 -0800", "message": "role tags - generated code and schema changes (#1179)"}, {"oid": "30e272d8a9ec2649a1d876c1c111cf38e27c1743", "committedDate": "2020-12-07 08:48:58 -0800", "message": "putRoleMeta tags support (#1208)"}, {"oid": "f0e0a91b80250236244db9f8cba79e1def809995", "committedDate": "2020-12-23 15:40:53 -0800", "message": "updating group expiry date (#1221)"}, {"oid": "7a2837c7578ab8d36c62b48ecb1d0079c670616b", "committedDate": "2020-12-29 13:44:04 -0800", "message": "granular authz action for managing role members (#1228)"}, {"oid": "d6a0d659fe96486ffcf31bb93e919656be9eaf89", "committedDate": "2021-01-13 08:15:47 -0800", "message": "domain tags implementation (#1235)"}, {"oid": "3c939966592bf7cc6ff25df12a8d21d4c2c89b2b", "committedDate": "2021-01-19 22:05:22 -0800", "message": "client api update for rich authorization requests and consistent naming of entity objects (#1248)"}, {"oid": "3db6ed7b169fce5bbeaa1fae84ff7881e9a4e435", "committedDate": "2021-01-21 09:17:41 -0800", "message": "limit number of role and domain tags (#1255)"}, {"oid": "218b71958d88fb039dfa6e7c5448c7e4d00cb337", "committedDate": "2021-01-25 17:53:41 -0800", "message": "update domain last modified timestamp after tag update (#1262)"}, {"oid": "bccc5fb4dc1c2407a0293f322c3d97711af4297c", "committedDate": "2021-03-07 18:11:58 -0800", "message": "sonarcloud: method always returns same result (#1329)"}, {"oid": "e421f20094d24075d2cec7ab7adecff7d630a286", "committedDate": "2021-03-16 18:08:03 -0700", "message": "expose new domain attribute: business-service (#1357)"}, {"oid": "7b4afd5d40394226b3aa1af8bf10e90e528091b3", "committedDate": "2021-04-01 14:52:30 -0700", "message": "Add memberExpiryDays and serviceExpiryDays support for groups (#1388)"}, {"oid": "5ab30978cc4fc03e1b3022305f6e14a5a425e9e9", "committedDate": "2021-04-07 16:30:50 -0700", "message": "new DomainMetaStore interface support in ZMS (#1430)"}, {"oid": "9bedde4310d6493406d264422f23e16f33213546", "committedDate": "2021-04-08 09:44:29 -0700", "message": "Add group review days to role (#1428)"}, {"oid": "a554c75c51c5945b0e58ae87866de93ff1d5cfbc", "committedDate": "2021-04-15 12:12:02 -0700", "message": "during provider admin setup, ignore deletes (#1444)"}, {"oid": "1c564548381b3c09ad4214d0f30c667e9cc0d022", "committedDate": "2021-04-30 15:22:51 -0700", "message": "log full policy assertion details during delete operations in audit log (#1469)"}, {"oid": "611ac334bfbc1c43ec20154cf9448b96fae365d6", "committedDate": "2021-05-27 16:30:38 -0700", "message": "handle null contition processDomainTags (#1495)"}, {"oid": "addf4424a5bf842b58558c6f61ac0b46277d9535", "committedDate": "2021-06-07 09:38:12 -0700", "message": "allow role/group review regardless of role/group expiry/reminder settings (#1503)"}, {"oid": "4b39ffbd18da3d10a581fb10209806c97b432d28", "committedDate": "2021-06-09 15:31:17 -0700", "message": "enable role review without setting restrictions (#1512)"}, {"oid": "898ff0aa4fddd1a9ed111496cb9e4acb544605af", "committedDate": "2021-06-14 10:42:10 -0700", "message": "Update Tag Values to include '/', ':' (#1517)"}, {"oid": "cf535673b0a4cbcdc81e17c7def4cb6822edd78c", "committedDate": "2021-06-22 06:44:42 -0700", "message": "Allow system admins to set domain meta attribute business service (#1522)"}, {"oid": "934fc3d7fc859731f4beab3b03b83a15ac717a2d", "committedDate": "2021-06-29 12:57:53 -0700", "message": "assertion condition server changes (#1528)"}, {"oid": "1fa51b852890c1576254be6a8a2b5dbebc89865c", "committedDate": "2021-07-21 14:41:19 -0700", "message": "UI : update error message (#1557)"}, {"oid": "09de45bb794eb5e7c29f705b5ce567c75fde4e84", "committedDate": "2021-07-29 15:49:16 -0700", "message": "multi-version policy - introducing version/active in policy object (#1568)"}, {"oid": "4abff4b9952e4836f79bf3f1934baf8fe2bcebf9", "committedDate": "2021-08-08 11:39:07 -0700", "message": "Disable Reminder Review Notifications By Tag zms.DisableReminderNotifications (#1579)"}, {"oid": "6a1523accc3ec83fe54d78c3d919d9cddbcb1b7e", "committedDate": "2021-08-17 18:32:28 -0700", "message": "fixing the order of updates for assertion condition api operations (#1591)"}, {"oid": "66590f4fc47f899f3990f20895f953074e40f259", "committedDate": "2021-09-10 07:55:42 -0700", "message": "Implement multi-version policies endpoints (#1605)"}, {"oid": "1ad624427917493d31bd1b8ffa6303c4d6353055", "committedDate": "2021-09-10 13:51:19 -0700", "message": "update group last modified when user is deleted (#1613)"}, {"oid": "91b116418656f123dae9a3405cb2e498d4d3aff4", "committedDate": "2021-09-12 09:52:05 +0300", "message": "additional validation checks when processing versioned policies (#1614)"}, {"oid": "2531428956f87774f86721f02b430861ca8897ec", "committedDate": "2021-09-14 09:49:34 +0300", "message": "additional checks when setting a policy version as active (#1615)"}, {"oid": "2968c209e870ce57fbdb1fb048a21692d80cfea6", "committedDate": "2021-10-01 07:25:34 -0700", "message": "rdl publishChangeEvents generator (#1624)"}, {"oid": "8a6960ce9878277c5abda1d104ca070831b36230", "committedDate": "2021-10-03 13:48:03 -0700", "message": "Allow specifying version name when creating new policy (#1630)"}, {"oid": "43f619b31bbd9cc3d388aa7ea29eff889cb1272d", "committedDate": "2021-10-21 08:48:51 -0700", "message": "For role expiry notification - record metrics daily while (#1654)"}, {"oid": "389f984270d7d89070c66096e87fafbcb24a261c", "committedDate": "2021-10-26 08:17:36 -0700", "message": "Group tags implementation (#1660)"}, {"oid": "120ab1fa8e9d33fa793c4254d233a09a2c23d173", "committedDate": "2021-10-29 15:08:28 -0700", "message": "Disable Group Expiry Notifications By Tag zms.DisableReminderNotifications (#1663)"}, {"oid": "1400363e8d698cf08370c89752077ebae043c5be", "committedDate": "2021-12-14 13:48:34 -0800", "message": "correct logging of role principal in audit/access logs"}, {"oid": "c8e3a5c91c5deb9640576cd3496a2af11d572f0b", "committedDate": "2021-12-23 15:03:25 -0800", "message": "protect system admin users from being removed from deleteUser api (#1715)"}, {"oid": "020e06e57b357768260f509f08b75c5c068bce53", "committedDate": "2022-02-07 08:01:55 -0800", "message": "Service Visiblity - Domain Dependencies (#1758)"}, {"oid": "fcbd4128e334a9a42f4579d179cf9578d3f4de99", "committedDate": "2022-02-07 10:12:47 -0800", "message": "support new get-stats endpoint to get per-domain/system stats (#1774)"}, {"oid": "ea831a34a70a0475bea8754cb183741dced98ff2", "committedDate": "2022-02-18 09:17:55 -0800", "message": "update pending member api to support getting list for a domain (#1783)"}, {"oid": "f4229124e8e1898810c7aa7b3a4eff37fddae308", "committedDate": "2022-02-18 12:37:32 -0800", "message": "provide option to skip adding principal when onboarding a resource group (#1787)"}, {"oid": "9081feb4c06a1058c941c67923037203d9318cfa", "committedDate": "2022-02-27 14:10:46 -0800", "message": "Domain Dependency for Tenancy (#1789)"}, {"oid": "a5bb615881583fa6f39621e2ea3bf39d3886340b", "committedDate": "2022-03-03 17:20:00 -0800", "message": "extend template keyword support trust field in roles (#1803)"}, {"oid": "3de182bcbedba89fa2aaba12ab9be49aa2156096", "committedDate": "2022-03-19 09:45:40 -0700", "message": "Add provider webhook for verifying removal (#1816)"}, {"oid": "1b0cff1cb9b8e4a231c5cfb342d76b6aad8e08fc", "committedDate": "2022-04-07 14:34:23 -0700", "message": "no need to update domain's last mod timestamp during put dependency call (#1846)"}, {"oid": "baa68eacd6a6b9bbc70c3423006f92cd47b784d7", "committedDate": "2022-05-19 09:30:02 -0700", "message": "Get Auth History implementation (#1875)"}, {"oid": "bea97b165e28b5b2cc286af62c92e536c9fc3ff2", "committedDate": "2022-06-03 13:50:01 -0700", "message": "AuthHistory - Return dependencies instead of list (#1888)"}, {"oid": "7a313e1d581295ae6c786bbc2ed73bb14da37f7d", "committedDate": "2022-07-21 20:16:24 -0700", "message": "allow management of domain memberPurgeExpiryDays setting value (#1928)"}, {"oid": "f288ed7afb018bc07af02dbe9dc8e05ec0896071", "committedDate": "2022-08-15 22:28:01 -0700", "message": "provide header option to return updated object in response (#1942)"}, {"oid": "949bd0634d328d04736b912a002bdfa7421d9f2b", "committedDate": "2022-08-23 10:28:38 -0700", "message": "fix returning role/group objects when requested by ui (#1945)"}, {"oid": "ab7284c9274f4949d23f88ec0dde7b689c0c6980", "committedDate": "2022-09-05 13:12:17 -0700", "message": "auto purge expired role/group members based on server/domain config (#1941)"}, {"oid": "4ab6e748891a014a8b0a1364de099d3fbf4c7468", "committedDate": "2022-09-21 22:22:48 -0700", "message": "enable readWrite db connection for delete expired members (#1964)"}, {"oid": "d4c733d3e97467a598ba44f0bde5c6a907aa01de", "committedDate": "2022-09-23 13:30:24 -0700", "message": "consistent use of The Athenz Authors copyright in all files (#1967)"}, {"oid": "45dcdab92d9e39d5d561b34ef222f863176cc635", "committedDate": "2022-09-26 12:29:01 -0700", "message": "make server purge expiry member day configurable (#1968)"}, {"oid": "d823cccb5163f950655f3859ade41fe031910588", "committedDate": "2022-10-06 14:20:20 -0700", "message": "fix putServiceIdentity logic to allow update of exising pubKey (#1978)"}, {"oid": "91d38ef548e59e29e69349b8a0f5151456b62a0f", "committedDate": "2022-10-07 15:36:36 -0700", "message": "Use correct object type for role member delete notifications (#1981)"}, {"oid": "1d970ce72c2f81aed5576fff068103bbba022aaf", "committedDate": "2022-11-29 23:50:29 +0200", "message": "add gcp project attribute for domains (#2005)"}, {"oid": "c292a1a2fb6e3a300a3060a6bcea6a96f696932c", "committedDate": "2022-12-13 08:56:43 -0800", "message": "Return the correct response from putMembership/putGroupMembership once a pending member was added (#2023)"}, {"oid": "fc5a206d1cb23dd2bbfd9af7e3125ec270ebc022", "committedDate": "2023-01-10 21:48:12 -0800", "message": "allow domain admins to enable audit flag for new roles/groups (#2032)"}, {"oid": "70850ab1de4055e765cf4ead6946b431900ff8c8", "committedDate": "2023-01-23 16:40:36 -0800", "message": "move cloud provider role generation logic out of dbstore library to dbservice (#2043)"}, {"oid": "0ff7ff4f9658fd42e8ee2161d870a89dce5167e4", "committedDate": "2023-02-02 09:18:32 -0800", "message": "Add a requirement for admin approval to delete members in review-enabled roles (#2053)"}, {"oid": "ff57628b890f53c43fec6dd2cacf98a574c95b2d", "committedDate": "2023-02-08 15:55:32 -0800", "message": "extends group with deleteProtection attribute and pending group membe\u2026 (#2067)"}, {"oid": "bb1d69af70a90aeedc28a46604283064e0dad8de", "committedDate": "2023-02-16 07:44:40 -0800", "message": "add audit enable to role (#2055)"}, {"oid": "4ee14d784973ce7da8aba96b35eefdbc5d61d97b", "committedDate": "2023-03-07 11:34:04 -0800", "message": "make aws/gcp assume role action values configurable (#2090)"}, {"oid": "5216da47ef8bca89ba0eae790f72739d9d73fcc6", "committedDate": "2023-03-09 10:36:29 -0800", "message": "Add optional 'description' to role (#2091)"}, {"oid": "d1b98d4614d62fe34b408cfa1a26fb59674d6494", "committedDate": "2023-03-27 16:46:33 -0700", "message": "store GCP project number along with project id in athenz domain metadata (#2113)"}, {"oid": "715cf96c679e817600a0a25160c96878e5eda735", "committedDate": "2023-03-27 18:01:33 -0700", "message": "special resource for gcp starting with service/ (#2115)"}, {"oid": "6e7342a1e98207b87e3eae45341db281b7b3b9c7", "committedDate": "2023-04-13 14:30:39 -0700", "message": "designate separate action for assertions when assuming gcp service accounts (#2127)"}, {"oid": "523f7f753fa2a4a112ae4fb7a5389203af8b9594", "committedDate": "2023-05-29 08:52:21 -0700", "message": "fix role update on expiration and review dates (#2185)"}, {"oid": "7069bf871635c4e5308d37341904241388b1ccda", "committedDate": "2023-05-30 15:31:26 -0700", "message": "support product id (string) format association with domains (#2193)"}, {"oid": "368d0bc139931c03d31824c4f02394b38e3ead95", "committedDate": "2023-06-02 13:15:05 -0700", "message": "support headless user type - managed by user authority but treated like service (#2197)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3ODg1Mg==", "url": "https://github.com/AthenZ/athenz/pull/1157#discussion_r510478852", "body": "same comments as roles", "bodyText": "same comments as roles", "bodyHTML": "<p dir=\"auto\">same comments as roles</p>", "author": "havetisyan", "createdAt": "2020-10-22T21:50:54Z", "path": "servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java", "diffHunk": "@@ -6402,6 +6403,147 @@ void enforceGroupUserAuthorityRestrictions(final String domainName, final String\n         }\n     }\n \n+    /**\n+     * This method returns list of Principals based on the state parameter supplied\n+     * @param queriedState state of principal\n+     * @return List of Principals from DB\n+     */\n+    List<Principal> getPrincipals(int queriedState) {\n+        List<Principal> principals = new ArrayList<>();\n+        Principal principal;\n+        try (ObjectStoreConnection con = store.getConnection(true, false)) {\n+           List<String> dbPrincipals = con.getPrincipals(queriedState);\n+           for (String dbPrincipal : dbPrincipals) {\n+               principal = ZMSUtils.createPrincipalForName(dbPrincipal, zmsConfig.getUserDomain(), null);\n+               ((SimplePrincipal) principal).setState(Principal.State.getState(queriedState));\n+               principals.add(principal);\n+           }\n+        }\n+        return principals;\n+    }\n+\n+    /**\n+     * This method toggles state for supplied Principals based on the flag in DB\n+     * as well as modifies memberships of all roles and groups of current principal(s)\n+     * @param changedPrincipals List of Principals from User Authority\n+     * @param newState new state {@link Principal.State}\n+     */\n+    void updatePrincipalBasedOnAuthorityState(List<Principal> changedPrincipals, Principal.State newState) {\n+        final String caller = \"updateMembershipBasedOnUserState\";\n+        List<Principal> updatedUsers = new ArrayList<>();\n+        try (ObjectStoreConnection con = store.getConnection(true, true)) {\n+\n+            // first lets update the new state in DB\n+            for (Principal changedPrincipal : changedPrincipals) {\n+                try {\n+                    switch (newState) {\n+                        case ACTIVE:\n+                            if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.ACTIVE.getValue())) {\n+                                updatedUsers.add(changedPrincipal);\n+                            }\n+                            break;\n+                        case AUTHORITY_SYSTEM_DISABLED:\n+                            if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.AUTHORITY_SYSTEM_DISABLED.getValue())) {\n+                                updatedUsers.add(changedPrincipal);\n+                            }\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+                } catch (ResourceException ex) {\n+                    if (ex.getCode() == ResourceException.NOT_FOUND) {\n+                        continue;\n+                    }\n+                    throw ex;\n+                }\n+            }\n+            // if new state is updated successfully\n+            // then we need to modify all roles and groups where given principal is member of\n+            if (!updatedUsers.isEmpty()) {\n+\n+                DomainRoleMember domainRoleMember;\n+                DomainGroupMember domainGroupMember;\n+                RoleMember roleMember;\n+                GroupMember groupMember;\n+                List<RoleMember> roleMembersWithUpdatedState;\n+                List<GroupMember> groupMembersWithUpdatedState;\n+                for (Principal updatedUser : updatedUsers) {\n+                    try {\n+                        // get all roles from all domains\n+                        domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n+                        if (!domainRoleMember.getMemberRoles().isEmpty()) {\n+                            for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n+                                roleMember = new RoleMember();\n+                                roleMember.setMemberName(updatedUser.getFullName());\n+                                switch (newState) {\n+                                    case ACTIVE:\n+                                        // if new state is ACTIVE then revert back to previous state for the member\n+                                        roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~newState.getValue());\n+                                        break;\n+                                    case AUTHORITY_SYSTEM_DISABLED:\n+                                        // if new state is SYSTEM_DISABLED then add it on to existing state\n+                                        roleMember.setSystemDisabled(memberRole.getSystemDisabled() | newState.getValue());\n+                                        break;\n+                                    default:\n+                                        break;\n+                                }\n+                                roleMembersWithUpdatedState = new ArrayList<>();\n+                                roleMembersWithUpdatedState.add(roleMember);\n+\n+                                // Following method does Audit entry as well\n+                                if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n+                                        memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n+\n+                                    // update our role and domain time-stamps, and invalidate local cache entry\n+                                    con.updateRoleModTimestamp(memberRole.getDomainName(), memberRole.getRoleName());\n+                                    con.updateDomainModTimestamp(memberRole.getDomainName());\n+                                    cacheStore.invalidate(memberRole.getDomainName());\n+                                }\n+                            }\n+                        }\n+                        domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n+                        if (!domainGroupMember.getMemberGroups().isEmpty()) {", "originalCommit": "45b271a460205ef873d48d4247128daa43779d54", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f2b6979e4235f325d7eea75d6f63d358c03d8d3c", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 2c6958b49..2d11e7268 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6426,121 +6427,120 @@ public class DBService implements RolesProvider {\n      * This method toggles state for supplied Principals based on the flag in DB\n      * as well as modifies memberships of all roles and groups of current principal(s)\n      * @param changedPrincipals List of Principals from User Authority\n-     * @param newState new state {@link Principal.State}\n+     * @param suspended boolean indicating principal's state\n      */\n-    void updatePrincipalBasedOnAuthorityState(List<Principal> changedPrincipals, Principal.State newState) {\n-        final String caller = \"updateMembershipBasedOnUserState\";\n+    void updatePrincipalByStateFromAuthority(List<Principal> changedPrincipals, boolean suspended) {\n+        final String caller = \"updatePrincipalByStateFromAuthority\";\n         List<Principal> updatedUsers = new ArrayList<>();\n-        try (ObjectStoreConnection con = store.getConnection(true, true)) {\n+        if (!changedPrincipals.isEmpty()) {\n+            try (ObjectStoreConnection con = store.getConnection(true, true)) {\n \n-            // first lets update the new state in DB\n-            for (Principal changedPrincipal : changedPrincipals) {\n-                try {\n-                    switch (newState) {\n-                        case ACTIVE:\n-                            if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.ACTIVE.getValue())) {\n-                                updatedUsers.add(changedPrincipal);\n-                            }\n-                            break;\n-                        case AUTHORITY_SYSTEM_DISABLED:\n-                            if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.AUTHORITY_SYSTEM_DISABLED.getValue())) {\n-                                updatedUsers.add(changedPrincipal);\n+                // first lets update the new state in DB\n+                for (Principal changedPrincipal : changedPrincipals) {\n+                    updatePrincipalState(suspended, updatedUsers, con, changedPrincipal);\n+                }\n+                // if new state is updated successfully\n+                // then we need to modify all roles and groups where given principal is member of\n+                if (!updatedUsers.isEmpty()) {\n+                    for (Principal updatedUser : updatedUsers) {\n+                        try {\n+                            updateRoleMembershipsByPrincipalState(suspended, caller, con, updatedUser);\n+                            updateGroupMembershipByPrincipalState(suspended, caller, con, updatedUser);\n+                        } catch (ResourceException ex) {\n+                            if (ex.getCode() == ResourceException.NOT_FOUND) {\n+                                continue;\n                             }\n-                            break;\n-                        default:\n-                            break;\n-                    }\n-                } catch (ResourceException ex) {\n-                    if (ex.getCode() == ResourceException.NOT_FOUND) {\n-                        continue;\n+                            throw ex;\n+                        }\n                     }\n-                    throw ex;\n                 }\n             }\n-            // if new state is updated successfully\n-            // then we need to modify all roles and groups where given principal is member of\n-            if (!updatedUsers.isEmpty()) {\n-\n-                DomainRoleMember domainRoleMember;\n-                DomainGroupMember domainGroupMember;\n-                RoleMember roleMember;\n-                GroupMember groupMember;\n-                List<RoleMember> roleMembersWithUpdatedState;\n-                List<GroupMember> groupMembersWithUpdatedState;\n-                for (Principal updatedUser : updatedUsers) {\n-                    try {\n-                        // get all roles from all domains\n-                        domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n-                        if (!domainRoleMember.getMemberRoles().isEmpty()) {\n-                            for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n-                                roleMember = new RoleMember();\n-                                roleMember.setMemberName(updatedUser.getFullName());\n-                                switch (newState) {\n-                                    case ACTIVE:\n-                                        // if new state is ACTIVE then revert back to previous state for the member\n-                                        roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~newState.getValue());\n-                                        break;\n-                                    case AUTHORITY_SYSTEM_DISABLED:\n-                                        // if new state is SYSTEM_DISABLED then add it on to existing state\n-                                        roleMember.setSystemDisabled(memberRole.getSystemDisabled() | newState.getValue());\n-                                        break;\n-                                    default:\n-                                        break;\n-                                }\n-                                roleMembersWithUpdatedState = new ArrayList<>();\n-                                roleMembersWithUpdatedState.add(roleMember);\n-\n-                                // Following method does Audit entry as well\n-                                if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n-                                        memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-\n-                                    // update our role and domain time-stamps, and invalidate local cache entry\n-                                    con.updateRoleModTimestamp(memberRole.getDomainName(), memberRole.getRoleName());\n-                                    con.updateDomainModTimestamp(memberRole.getDomainName());\n-                                    cacheStore.invalidate(memberRole.getDomainName());\n-                                }\n-                            }\n-                        }\n-                        domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n-                        if (!domainGroupMember.getMemberGroups().isEmpty()) {\n-                            for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n-                                groupMember = new GroupMember();\n-                                groupMember.setMemberName(updatedUser.getFullName());\n-                                switch (newState) {\n-                                    case ACTIVE:\n-                                        // if new state is ACTIVE then revert back to previous state for the member\n-                                        groupMember.setSystemDisabled(currentGroup.getSystemDisabled() & ~newState.getValue());\n-                                        break;\n-                                    case AUTHORITY_SYSTEM_DISABLED:\n-                                        // if new state is SYSTEM_DISABLED then add it on to existing state\n-                                        groupMember.setSystemDisabled(currentGroup.getSystemDisabled() | newState.getValue());\n-                                        break;\n-                                    default:\n-                                        break;\n-                                }\n-                                groupMembersWithUpdatedState = new ArrayList<>();\n-                                groupMembersWithUpdatedState.add(groupMember);\n-\n-                                // Following method does Audit entry as well\n-                                if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n-                                        currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-\n-                                    // update our group and domain time-stamps, and invalidate local cache entry\n-\n-                                    con.updateGroupModTimestamp(currentGroup.getDomainName(), currentGroup.getGroupName());\n-                                    con.updateDomainModTimestamp(currentGroup.getDomainName());\n-                                    cacheStore.invalidate(currentGroup.getDomainName());\n-                                }\n-                            }\n-                        }\n-                    } catch (ResourceException ex) {\n-                        if (ex.getCode() == ResourceException.NOT_FOUND) {\n-                            continue;\n-                        }\n-                        throw ex;\n-                    }\n+        }\n+    }\n+\n+    private void updateGroupMembershipByPrincipalState(boolean suspended, String caller, ObjectStoreConnection con, Principal updatedUser) {\n+        List<GroupMember> groupMembersWithUpdatedState;\n+        GroupMember groupMember;\n+        DomainGroupMember domainGroupMember;\n+        Set<GroupMember> updatedGroups = new HashSet<>();\n+\n+        domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n+        if (!domainGroupMember.getMemberGroups().isEmpty()) {\n+            for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n+                groupMember = new GroupMember();\n+                groupMember.setMemberName(updatedUser.getFullName());\n+                if (suspended) {\n+                    groupMember.setSystemDisabled(currentGroup.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                } else {\n+                    groupMember.setSystemDisabled(currentGroup.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                }\n+                groupMembersWithUpdatedState = new ArrayList<>();\n+                groupMembersWithUpdatedState.add(groupMember);\n+\n+                // Following method does Audit entry as well\n+                if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n+                        currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n+                    updatedGroups.add(currentGroup);\n+                }\n+            }\n+            for (GroupMember updatedGM : updatedGroups) {\n+\n+                // update our group and domain time-stamps, and invalidate local cache entry\n+                con.updateGroupModTimestamp(updatedGM.getDomainName(), updatedGM.getGroupName());\n+                con.updateDomainModTimestamp(updatedGM.getDomainName());\n+                cacheStore.invalidate(updatedGM.getDomainName());\n+            }\n+        }\n+    }\n+\n+    private void updateRoleMembershipsByPrincipalState(boolean suspended, String caller, ObjectStoreConnection con, Principal updatedUser) {\n+        RoleMember roleMember;\n+        List<RoleMember> roleMembersWithUpdatedState;\n+        DomainRoleMember domainRoleMember;\n+        Set<MemberRole> updatedRoles = new HashSet<>();\n+\n+        domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n+        if (!domainRoleMember.getMemberRoles().isEmpty()) {\n+            for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n+                roleMember = new RoleMember();\n+                roleMember.setMemberName(updatedUser.getFullName());\n+                if (suspended) {\n+                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                } else {\n+                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                }\n+                roleMembersWithUpdatedState = new ArrayList<>();\n+                roleMembersWithUpdatedState.add(roleMember);\n+\n+                // Following method does Audit entry as well\n+                if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n+                        memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n+                    updatedRoles.add(memberRole);\n+                }\n+            }\n+            for (MemberRole updatedMR : updatedRoles) {\n+\n+                // update our role and domain time-stamps, and invalidate local cache entry\n+                con.updateRoleModTimestamp(updatedMR.getDomainName(), updatedMR.getRoleName());\n+                con.updateDomainModTimestamp(updatedMR.getDomainName());\n+                cacheStore.invalidate(updatedMR.getDomainName());\n+            }\n+        }\n+    }\n+\n+    private void updatePrincipalState(boolean suspended, List<Principal> updatedUsers, ObjectStoreConnection con, Principal changedPrincipal) {\n+        try {\n+            if (suspended) {\n+                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue())) {\n+                    updatedUsers.add(changedPrincipal);\n+                }\n+            } else {\n+                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.ACTIVE.getValue())) {\n+                    updatedUsers.add(changedPrincipal);\n                 }\n             }\n+        } catch (ResourceException ex) {\n+            LOG.error(\"Exception in updating principal state from Authority {} Moving on.\", ex.getMessage());\n         }\n     }\n \n", "next_change": {"commit": "0dff4be75160c89e9e35b4634db11456460fa25f", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 2d11e7268..08f2ee72e 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6497,50 +6512,29 @@ public class DBService implements RolesProvider {\n         RoleMember roleMember;\n         List<RoleMember> roleMembersWithUpdatedState;\n         DomainRoleMember domainRoleMember;\n-        Set<MemberRole> updatedRoles = new HashSet<>();\n-\n+        int newState;\n+        Set<String> updatedDomains = new HashSet<>();\n         domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n         if (!domainRoleMember.getMemberRoles().isEmpty()) {\n             for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n                 roleMember = new RoleMember();\n                 roleMember.setMemberName(updatedUser.getFullName());\n-                if (suspended) {\n-                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                } else {\n-                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                }\n-                roleMembersWithUpdatedState = new ArrayList<>();\n-                roleMembersWithUpdatedState.add(roleMember);\n+                newState = suspended ? memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n+                        memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n+                roleMember.setSystemDisabled(newState);\n+                roleMembersWithUpdatedState = Collections.singletonList(roleMember);\n \n                 // Following method does Audit entry as well\n                 if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n                         memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-                    updatedRoles.add(memberRole);\n+                    con.updateRoleModTimestamp(memberRole.getDomainName(), memberRole.getRoleName());\n+                    updatedDomains.add(memberRole.getDomainName());\n                 }\n             }\n-            for (MemberRole updatedMR : updatedRoles) {\n-\n-                // update our role and domain time-stamps, and invalidate local cache entry\n-                con.updateRoleModTimestamp(updatedMR.getDomainName(), updatedMR.getRoleName());\n-                con.updateDomainModTimestamp(updatedMR.getDomainName());\n-                cacheStore.invalidate(updatedMR.getDomainName());\n-            }\n-        }\n-    }\n-\n-    private void updatePrincipalState(boolean suspended, List<Principal> updatedUsers, ObjectStoreConnection con, Principal changedPrincipal) {\n-        try {\n-            if (suspended) {\n-                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue())) {\n-                    updatedUsers.add(changedPrincipal);\n-                }\n-            } else {\n-                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.ACTIVE.getValue())) {\n-                    updatedUsers.add(changedPrincipal);\n-                }\n-            }\n-        } catch (ResourceException ex) {\n-            LOG.error(\"Exception in updating principal state from Authority {} Moving on.\", ex.getMessage());\n+            updatedDomains.forEach(dom -> {\n+                con.updateDomainModTimestamp(dom);\n+                cacheStore.invalidate(dom);\n+            });\n         }\n     }\n \n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 2c6958b49..08f2ee72e 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6426,113 +6427,46 @@ public class DBService implements RolesProvider {\n      * This method toggles state for supplied Principals based on the flag in DB\n      * as well as modifies memberships of all roles and groups of current principal(s)\n      * @param changedPrincipals List of Principals from User Authority\n-     * @param newState new state {@link Principal.State}\n+     * @param suspended boolean indicating principal's state\n      */\n-    void updatePrincipalBasedOnAuthorityState(List<Principal> changedPrincipals, Principal.State newState) {\n-        final String caller = \"updateMembershipBasedOnUserState\";\n+    void updatePrincipalByStateFromAuthority(List<Principal> changedPrincipals, boolean suspended) {\n+\n+        if (changedPrincipals.isEmpty()) {\n+            return;\n+        }\n+\n+        final String caller = \"updatePrincipalByStateFromAuthority\";\n         List<Principal> updatedUsers = new ArrayList<>();\n+        int newPrincipalState = suspended ? Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() : Principal.State.ACTIVE.getValue();\n         try (ObjectStoreConnection con = store.getConnection(true, true)) {\n \n             // first lets update the new state in DB\n             for (Principal changedPrincipal : changedPrincipals) {\n                 try {\n-                    switch (newState) {\n-                        case ACTIVE:\n-                            if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.ACTIVE.getValue())) {\n-                                updatedUsers.add(changedPrincipal);\n-                            }\n-                            break;\n-                        case AUTHORITY_SYSTEM_DISABLED:\n-                            if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.AUTHORITY_SYSTEM_DISABLED.getValue())) {\n-                                updatedUsers.add(changedPrincipal);\n-                            }\n-                            break;\n-                        default:\n-                            break;\n+                    if (con.updatePrincipal(changedPrincipal.getFullName(), newPrincipalState)) {\n+                        updatedUsers.add(changedPrincipal);\n                     }\n                 } catch (ResourceException ex) {\n-                    if (ex.getCode() == ResourceException.NOT_FOUND) {\n-                        continue;\n-                    }\n-                    throw ex;\n+                    // log the exception and continue with remaining principals\n+                    LOG.error(\"Exception in updating principal state from Authority {} Moving on.\", ex.getMessage());\n                 }\n             }\n             // if new state is updated successfully\n             // then we need to modify all roles and groups where given principal is member of\n             if (!updatedUsers.isEmpty()) {\n-\n-                DomainRoleMember domainRoleMember;\n-                DomainGroupMember domainGroupMember;\n-                RoleMember roleMember;\n-                GroupMember groupMember;\n-                List<RoleMember> roleMembersWithUpdatedState;\n-                List<GroupMember> groupMembersWithUpdatedState;\n                 for (Principal updatedUser : updatedUsers) {\n+                    // separate try blocks to treat group and role membership 404s separately\n                     try {\n-                        // get all roles from all domains\n-                        domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n-                        if (!domainRoleMember.getMemberRoles().isEmpty()) {\n-                            for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n-                                roleMember = new RoleMember();\n-                                roleMember.setMemberName(updatedUser.getFullName());\n-                                switch (newState) {\n-                                    case ACTIVE:\n-                                        // if new state is ACTIVE then revert back to previous state for the member\n-                                        roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~newState.getValue());\n-                                        break;\n-                                    case AUTHORITY_SYSTEM_DISABLED:\n-                                        // if new state is SYSTEM_DISABLED then add it on to existing state\n-                                        roleMember.setSystemDisabled(memberRole.getSystemDisabled() | newState.getValue());\n-                                        break;\n-                                    default:\n-                                        break;\n-                                }\n-                                roleMembersWithUpdatedState = new ArrayList<>();\n-                                roleMembersWithUpdatedState.add(roleMember);\n-\n-                                // Following method does Audit entry as well\n-                                if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n-                                        memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-\n-                                    // update our role and domain time-stamps, and invalidate local cache entry\n-                                    con.updateRoleModTimestamp(memberRole.getDomainName(), memberRole.getRoleName());\n-                                    con.updateDomainModTimestamp(memberRole.getDomainName());\n-                                    cacheStore.invalidate(memberRole.getDomainName());\n-                                }\n-                            }\n-                        }\n-                        domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n-                        if (!domainGroupMember.getMemberGroups().isEmpty()) {\n-                            for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n-                                groupMember = new GroupMember();\n-                                groupMember.setMemberName(updatedUser.getFullName());\n-                                switch (newState) {\n-                                    case ACTIVE:\n-                                        // if new state is ACTIVE then revert back to previous state for the member\n-                                        groupMember.setSystemDisabled(currentGroup.getSystemDisabled() & ~newState.getValue());\n-                                        break;\n-                                    case AUTHORITY_SYSTEM_DISABLED:\n-                                        // if new state is SYSTEM_DISABLED then add it on to existing state\n-                                        groupMember.setSystemDisabled(currentGroup.getSystemDisabled() | newState.getValue());\n-                                        break;\n-                                    default:\n-                                        break;\n-                                }\n-                                groupMembersWithUpdatedState = new ArrayList<>();\n-                                groupMembersWithUpdatedState.add(groupMember);\n-\n-                                // Following method does Audit entry as well\n-                                if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n-                                        currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-\n-                                    // update our group and domain time-stamps, and invalidate local cache entry\n-\n-                                    con.updateGroupModTimestamp(currentGroup.getDomainName(), currentGroup.getGroupName());\n-                                    con.updateDomainModTimestamp(currentGroup.getDomainName());\n-                                    cacheStore.invalidate(currentGroup.getDomainName());\n-                                }\n-                            }\n+                        updateRoleMembershipsByPrincipalState(suspended, caller, con, updatedUser);\n+                    } catch (ResourceException ex) {\n+                        if (ex.getCode() == ResourceException.NOT_FOUND) {\n+                            continue;\n                         }\n+                        throw ex;\n+                    }\n+                    // separate try blocks to treat group and role membership 404s separately\n+                    try {\n+                        updateGroupMembershipByPrincipalState(suspended, caller, con, updatedUser);\n                     } catch (ResourceException ex) {\n                         if (ex.getCode() == ResourceException.NOT_FOUND) {\n                             continue;\n", "next_change": null}]}, "commits_in_main": [{"oid": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "message": "Merge commit", "committedDate": null}, {"oid": "9a9c82c13d156e06dad8464c3a6c52c8e2bc6b89", "committedDate": "2020-10-26 14:15:03 -0700", "message": "remove sending back deprected members field in roles (#1160)"}, {"oid": "31a0dd7362f585f85992d4ff86fbf975d9d736dd", "committedDate": "2020-10-31 14:59:07 -0700", "message": "add azure_subscription field to domains (#1167)"}, {"oid": "c668f48cec94e2c928581b92ffb517f715a4840f", "committedDate": "2020-11-06 18:05:10 -0800", "message": "handle sys disabled null scenario (#1176)"}, {"oid": "f24d15baaaddc96c85fbceb31fcaded756a69f2e", "committedDate": "2020-11-14 16:51:57 -0800", "message": "role tags - generated code and schema changes (#1179)"}, {"oid": "30e272d8a9ec2649a1d876c1c111cf38e27c1743", "committedDate": "2020-12-07 08:48:58 -0800", "message": "putRoleMeta tags support (#1208)"}, {"oid": "f0e0a91b80250236244db9f8cba79e1def809995", "committedDate": "2020-12-23 15:40:53 -0800", "message": "updating group expiry date (#1221)"}, {"oid": "7a2837c7578ab8d36c62b48ecb1d0079c670616b", "committedDate": "2020-12-29 13:44:04 -0800", "message": "granular authz action for managing role members (#1228)"}, {"oid": "d6a0d659fe96486ffcf31bb93e919656be9eaf89", "committedDate": "2021-01-13 08:15:47 -0800", "message": "domain tags implementation (#1235)"}, {"oid": "3c939966592bf7cc6ff25df12a8d21d4c2c89b2b", "committedDate": "2021-01-19 22:05:22 -0800", "message": "client api update for rich authorization requests and consistent naming of entity objects (#1248)"}, {"oid": "3db6ed7b169fce5bbeaa1fae84ff7881e9a4e435", "committedDate": "2021-01-21 09:17:41 -0800", "message": "limit number of role and domain tags (#1255)"}, {"oid": "218b71958d88fb039dfa6e7c5448c7e4d00cb337", "committedDate": "2021-01-25 17:53:41 -0800", "message": "update domain last modified timestamp after tag update (#1262)"}, {"oid": "bccc5fb4dc1c2407a0293f322c3d97711af4297c", "committedDate": "2021-03-07 18:11:58 -0800", "message": "sonarcloud: method always returns same result (#1329)"}, {"oid": "e421f20094d24075d2cec7ab7adecff7d630a286", "committedDate": "2021-03-16 18:08:03 -0700", "message": "expose new domain attribute: business-service (#1357)"}, {"oid": "7b4afd5d40394226b3aa1af8bf10e90e528091b3", "committedDate": "2021-04-01 14:52:30 -0700", "message": "Add memberExpiryDays and serviceExpiryDays support for groups (#1388)"}, {"oid": "5ab30978cc4fc03e1b3022305f6e14a5a425e9e9", "committedDate": "2021-04-07 16:30:50 -0700", "message": "new DomainMetaStore interface support in ZMS (#1430)"}, {"oid": "9bedde4310d6493406d264422f23e16f33213546", "committedDate": "2021-04-08 09:44:29 -0700", "message": "Add group review days to role (#1428)"}, {"oid": "a554c75c51c5945b0e58ae87866de93ff1d5cfbc", "committedDate": "2021-04-15 12:12:02 -0700", "message": "during provider admin setup, ignore deletes (#1444)"}, {"oid": "1c564548381b3c09ad4214d0f30c667e9cc0d022", "committedDate": "2021-04-30 15:22:51 -0700", "message": "log full policy assertion details during delete operations in audit log (#1469)"}, {"oid": "611ac334bfbc1c43ec20154cf9448b96fae365d6", "committedDate": "2021-05-27 16:30:38 -0700", "message": "handle null contition processDomainTags (#1495)"}, {"oid": "addf4424a5bf842b58558c6f61ac0b46277d9535", "committedDate": "2021-06-07 09:38:12 -0700", "message": "allow role/group review regardless of role/group expiry/reminder settings (#1503)"}, {"oid": "4b39ffbd18da3d10a581fb10209806c97b432d28", "committedDate": "2021-06-09 15:31:17 -0700", "message": "enable role review without setting restrictions (#1512)"}, {"oid": "898ff0aa4fddd1a9ed111496cb9e4acb544605af", "committedDate": "2021-06-14 10:42:10 -0700", "message": "Update Tag Values to include '/', ':' (#1517)"}, {"oid": "cf535673b0a4cbcdc81e17c7def4cb6822edd78c", "committedDate": "2021-06-22 06:44:42 -0700", "message": "Allow system admins to set domain meta attribute business service (#1522)"}, {"oid": "934fc3d7fc859731f4beab3b03b83a15ac717a2d", "committedDate": "2021-06-29 12:57:53 -0700", "message": "assertion condition server changes (#1528)"}, {"oid": "1fa51b852890c1576254be6a8a2b5dbebc89865c", "committedDate": "2021-07-21 14:41:19 -0700", "message": "UI : update error message (#1557)"}, {"oid": "09de45bb794eb5e7c29f705b5ce567c75fde4e84", "committedDate": "2021-07-29 15:49:16 -0700", "message": "multi-version policy - introducing version/active in policy object (#1568)"}, {"oid": "4abff4b9952e4836f79bf3f1934baf8fe2bcebf9", "committedDate": "2021-08-08 11:39:07 -0700", "message": "Disable Reminder Review Notifications By Tag zms.DisableReminderNotifications (#1579)"}, {"oid": "6a1523accc3ec83fe54d78c3d919d9cddbcb1b7e", "committedDate": "2021-08-17 18:32:28 -0700", "message": "fixing the order of updates for assertion condition api operations (#1591)"}, {"oid": "66590f4fc47f899f3990f20895f953074e40f259", "committedDate": "2021-09-10 07:55:42 -0700", "message": "Implement multi-version policies endpoints (#1605)"}, {"oid": "1ad624427917493d31bd1b8ffa6303c4d6353055", "committedDate": "2021-09-10 13:51:19 -0700", "message": "update group last modified when user is deleted (#1613)"}, {"oid": "91b116418656f123dae9a3405cb2e498d4d3aff4", "committedDate": "2021-09-12 09:52:05 +0300", "message": "additional validation checks when processing versioned policies (#1614)"}, {"oid": "2531428956f87774f86721f02b430861ca8897ec", "committedDate": "2021-09-14 09:49:34 +0300", "message": "additional checks when setting a policy version as active (#1615)"}, {"oid": "2968c209e870ce57fbdb1fb048a21692d80cfea6", "committedDate": "2021-10-01 07:25:34 -0700", "message": "rdl publishChangeEvents generator (#1624)"}, {"oid": "8a6960ce9878277c5abda1d104ca070831b36230", "committedDate": "2021-10-03 13:48:03 -0700", "message": "Allow specifying version name when creating new policy (#1630)"}, {"oid": "43f619b31bbd9cc3d388aa7ea29eff889cb1272d", "committedDate": "2021-10-21 08:48:51 -0700", "message": "For role expiry notification - record metrics daily while (#1654)"}, {"oid": "389f984270d7d89070c66096e87fafbcb24a261c", "committedDate": "2021-10-26 08:17:36 -0700", "message": "Group tags implementation (#1660)"}, {"oid": "120ab1fa8e9d33fa793c4254d233a09a2c23d173", "committedDate": "2021-10-29 15:08:28 -0700", "message": "Disable Group Expiry Notifications By Tag zms.DisableReminderNotifications (#1663)"}, {"oid": "1400363e8d698cf08370c89752077ebae043c5be", "committedDate": "2021-12-14 13:48:34 -0800", "message": "correct logging of role principal in audit/access logs"}, {"oid": "c8e3a5c91c5deb9640576cd3496a2af11d572f0b", "committedDate": "2021-12-23 15:03:25 -0800", "message": "protect system admin users from being removed from deleteUser api (#1715)"}, {"oid": "020e06e57b357768260f509f08b75c5c068bce53", "committedDate": "2022-02-07 08:01:55 -0800", "message": "Service Visiblity - Domain Dependencies (#1758)"}, {"oid": "fcbd4128e334a9a42f4579d179cf9578d3f4de99", "committedDate": "2022-02-07 10:12:47 -0800", "message": "support new get-stats endpoint to get per-domain/system stats (#1774)"}, {"oid": "ea831a34a70a0475bea8754cb183741dced98ff2", "committedDate": "2022-02-18 09:17:55 -0800", "message": "update pending member api to support getting list for a domain (#1783)"}, {"oid": "f4229124e8e1898810c7aa7b3a4eff37fddae308", "committedDate": "2022-02-18 12:37:32 -0800", "message": "provide option to skip adding principal when onboarding a resource group (#1787)"}, {"oid": "9081feb4c06a1058c941c67923037203d9318cfa", "committedDate": "2022-02-27 14:10:46 -0800", "message": "Domain Dependency for Tenancy (#1789)"}, {"oid": "a5bb615881583fa6f39621e2ea3bf39d3886340b", "committedDate": "2022-03-03 17:20:00 -0800", "message": "extend template keyword support trust field in roles (#1803)"}, {"oid": "3de182bcbedba89fa2aaba12ab9be49aa2156096", "committedDate": "2022-03-19 09:45:40 -0700", "message": "Add provider webhook for verifying removal (#1816)"}, {"oid": "1b0cff1cb9b8e4a231c5cfb342d76b6aad8e08fc", "committedDate": "2022-04-07 14:34:23 -0700", "message": "no need to update domain's last mod timestamp during put dependency call (#1846)"}, {"oid": "baa68eacd6a6b9bbc70c3423006f92cd47b784d7", "committedDate": "2022-05-19 09:30:02 -0700", "message": "Get Auth History implementation (#1875)"}, {"oid": "bea97b165e28b5b2cc286af62c92e536c9fc3ff2", "committedDate": "2022-06-03 13:50:01 -0700", "message": "AuthHistory - Return dependencies instead of list (#1888)"}, {"oid": "7a313e1d581295ae6c786bbc2ed73bb14da37f7d", "committedDate": "2022-07-21 20:16:24 -0700", "message": "allow management of domain memberPurgeExpiryDays setting value (#1928)"}, {"oid": "f288ed7afb018bc07af02dbe9dc8e05ec0896071", "committedDate": "2022-08-15 22:28:01 -0700", "message": "provide header option to return updated object in response (#1942)"}, {"oid": "949bd0634d328d04736b912a002bdfa7421d9f2b", "committedDate": "2022-08-23 10:28:38 -0700", "message": "fix returning role/group objects when requested by ui (#1945)"}, {"oid": "ab7284c9274f4949d23f88ec0dde7b689c0c6980", "committedDate": "2022-09-05 13:12:17 -0700", "message": "auto purge expired role/group members based on server/domain config (#1941)"}, {"oid": "4ab6e748891a014a8b0a1364de099d3fbf4c7468", "committedDate": "2022-09-21 22:22:48 -0700", "message": "enable readWrite db connection for delete expired members (#1964)"}, {"oid": "d4c733d3e97467a598ba44f0bde5c6a907aa01de", "committedDate": "2022-09-23 13:30:24 -0700", "message": "consistent use of The Athenz Authors copyright in all files (#1967)"}, {"oid": "45dcdab92d9e39d5d561b34ef222f863176cc635", "committedDate": "2022-09-26 12:29:01 -0700", "message": "make server purge expiry member day configurable (#1968)"}, {"oid": "d823cccb5163f950655f3859ade41fe031910588", "committedDate": "2022-10-06 14:20:20 -0700", "message": "fix putServiceIdentity logic to allow update of exising pubKey (#1978)"}, {"oid": "91d38ef548e59e29e69349b8a0f5151456b62a0f", "committedDate": "2022-10-07 15:36:36 -0700", "message": "Use correct object type for role member delete notifications (#1981)"}, {"oid": "1d970ce72c2f81aed5576fff068103bbba022aaf", "committedDate": "2022-11-29 23:50:29 +0200", "message": "add gcp project attribute for domains (#2005)"}, {"oid": "c292a1a2fb6e3a300a3060a6bcea6a96f696932c", "committedDate": "2022-12-13 08:56:43 -0800", "message": "Return the correct response from putMembership/putGroupMembership once a pending member was added (#2023)"}, {"oid": "fc5a206d1cb23dd2bbfd9af7e3125ec270ebc022", "committedDate": "2023-01-10 21:48:12 -0800", "message": "allow domain admins to enable audit flag for new roles/groups (#2032)"}, {"oid": "70850ab1de4055e765cf4ead6946b431900ff8c8", "committedDate": "2023-01-23 16:40:36 -0800", "message": "move cloud provider role generation logic out of dbstore library to dbservice (#2043)"}, {"oid": "0ff7ff4f9658fd42e8ee2161d870a89dce5167e4", "committedDate": "2023-02-02 09:18:32 -0800", "message": "Add a requirement for admin approval to delete members in review-enabled roles (#2053)"}, {"oid": "ff57628b890f53c43fec6dd2cacf98a574c95b2d", "committedDate": "2023-02-08 15:55:32 -0800", "message": "extends group with deleteProtection attribute and pending group membe\u2026 (#2067)"}, {"oid": "bb1d69af70a90aeedc28a46604283064e0dad8de", "committedDate": "2023-02-16 07:44:40 -0800", "message": "add audit enable to role (#2055)"}, {"oid": "4ee14d784973ce7da8aba96b35eefdbc5d61d97b", "committedDate": "2023-03-07 11:34:04 -0800", "message": "make aws/gcp assume role action values configurable (#2090)"}, {"oid": "5216da47ef8bca89ba0eae790f72739d9d73fcc6", "committedDate": "2023-03-09 10:36:29 -0800", "message": "Add optional 'description' to role (#2091)"}, {"oid": "d1b98d4614d62fe34b408cfa1a26fb59674d6494", "committedDate": "2023-03-27 16:46:33 -0700", "message": "store GCP project number along with project id in athenz domain metadata (#2113)"}, {"oid": "715cf96c679e817600a0a25160c96878e5eda735", "committedDate": "2023-03-27 18:01:33 -0700", "message": "special resource for gcp starting with service/ (#2115)"}, {"oid": "6e7342a1e98207b87e3eae45341db281b7b3b9c7", "committedDate": "2023-04-13 14:30:39 -0700", "message": "designate separate action for assertions when assuming gcp service accounts (#2127)"}, {"oid": "523f7f753fa2a4a112ae4fb7a5389203af8b9594", "committedDate": "2023-05-29 08:52:21 -0700", "message": "fix role update on expiration and review dates (#2185)"}, {"oid": "7069bf871635c4e5308d37341904241388b1ccda", "committedDate": "2023-05-30 15:31:26 -0700", "message": "support product id (string) format association with domains (#2193)"}, {"oid": "368d0bc139931c03d31824c4f02394b38e3ead95", "committedDate": "2023-06-02 13:15:05 -0700", "message": "support headless user type - managed by user authority but treated like service (#2197)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4MDA0OQ==", "url": "https://github.com/AthenZ/athenz/pull/1157#discussion_r510480049", "body": "please update the zms conf file to have a small description of these options since by default feature is off and must be enabled", "bodyText": "please update the zms conf file to have a small description of these options since by default feature is off and must be enabled", "bodyHTML": "<p dir=\"auto\">please update the zms conf file to have a small description of these options since by default feature is off and must be enabled</p>", "author": "havetisyan", "createdAt": "2020-10-22T21:53:49Z", "path": "servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java", "diffHunk": "@@ -298,4 +298,9 @@\n     public static final int ZMS_DISABLED_AUTHORITY_FILTER = 0x01;\n \n     public static final String ZMS_PROP_STATUS_CHECKER_FACTORY_CLASS = \"athenz.zms.status_checker_factory_class\";\n+\n+    public static final String ZMS_PROP_ENABLE_PRINCIPAL_STATE_UPDATER        = \"athenz.zms.enable_principal_state_updater\";", "originalCommit": "45b271a460205ef873d48d4247128daa43779d54", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "934fc3d7fc859731f4beab3b03b83a15ac717a2d", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\nindex 9ebd379fd..c82f91f8e 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\n", "chunk": "@@ -303,4 +321,6 @@ public final class ZMSConsts {\n     public static final String ZMS_PROP_PRINCIPAL_STATE_UPDATER_FREQUENCY = \"athenz.zms.principal_state_updater_frequency\";\n     public static final String ZMS_PROP_PRINCIPAL_STATE_UPDATER_FREQUENCY_DEFAULT = \"30\"; // in minutes\n     public static final String ZMS_PROP_PRINCIPAL_STATE_UPDATER_DISABLE_TIMER = \"athenz.zms.disable_principal_state_updater_timer_task\";\n+\n+    public static final String ZMS_PROP_QUOTA_ASSERTION_CONDITIONS = \"athenz.zms.quota_assertion_conditions\";\n }\n", "next_change": {"commit": "66590f4fc47f899f3990f20895f953074e40f259", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\nindex c82f91f8e..38c69f672 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\n", "chunk": "@@ -323,4 +327,6 @@ public final class ZMSConsts {\n     public static final String ZMS_PROP_PRINCIPAL_STATE_UPDATER_DISABLE_TIMER = \"athenz.zms.disable_principal_state_updater_timer_task\";\n \n     public static final String ZMS_PROP_QUOTA_ASSERTION_CONDITIONS = \"athenz.zms.quota_assertion_conditions\";\n+\n+    public static final String ZMS_PROP_MAX_POLICY_VERSIONS_DEFAULT = \"3\";\n }\n", "next_change": {"commit": "2968c209e870ce57fbdb1fb048a21692d80cfea6", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\nindex 38c69f672..99215ce15 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\n", "chunk": "@@ -329,4 +329,9 @@ public final class ZMSConsts {\n     public static final String ZMS_PROP_QUOTA_ASSERTION_CONDITIONS = \"athenz.zms.quota_assertion_conditions\";\n \n     public static final String ZMS_PROP_MAX_POLICY_VERSIONS_DEFAULT = \"3\";\n+    \n+    public static final String ZMS_PROP_DOMAIN_CHANGE_TOPIC_NAMES = \"athenz.zms.domain_changes_topic_names\";\n+    public static final String ZMS_PROP_DOMAIN_CHANGE_PUBLISHER_FACTORY_CLASS = \"athenz.zms.domain_change_publisher_factory_class\";\n+    public static final String ZMS_PROP_DOMAIN_CHANGE_PUBLISHER_DEFAULT = \"com.yahoo.athenz.common.messaging.impl.NoOpDomainChangePublisherFactory\";\n+\n }\n", "next_change": {"commit": "3b936a5bc36a83e89c21d4b2150920a3a677cb25", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\nindex 99215ce15..67e19bc18 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\n", "chunk": "@@ -334,4 +343,6 @@ public final class ZMSConsts {\n     public static final String ZMS_PROP_DOMAIN_CHANGE_PUBLISHER_FACTORY_CLASS = \"athenz.zms.domain_change_publisher_factory_class\";\n     public static final String ZMS_PROP_DOMAIN_CHANGE_PUBLISHER_DEFAULT = \"com.yahoo.athenz.common.messaging.impl.NoOpDomainChangePublisherFactory\";\n \n+    public static final String DISABLE_REMINDER_NOTIFICATIONS_TAG = \"zms.DisableReminderNotifications\";\n+    public static final String DISABLE_EXPIRATION_NOTIFICATIONS_TAG = \"zms.DisableExpirationNotifications\";\n }\n", "next_change": {"commit": "3de182bcbedba89fa2aaba12ab9be49aa2156096", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\nindex 67e19bc18..5bdf7574c 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\n", "chunk": "@@ -345,4 +345,19 @@ public final class ZMSConsts {\n \n     public static final String DISABLE_REMINDER_NOTIFICATIONS_TAG = \"zms.DisableReminderNotifications\";\n     public static final String DISABLE_EXPIRATION_NOTIFICATIONS_TAG = \"zms.DisableExpirationNotifications\";\n+    public static final String ZMS_PROP_PROVIDER_READ_TIMEOUT       = \"athenz.zms.provider.client.read_timeout\";\n+    public static final String ZMS_PROP_PROVIDER_TRUST_STORE = \"athenz.zms.provider.client.truststore\";\n+    public static final String ZMS_PROP_PROVIDER_TRUST_STORE_PASSWORD = \"athenz.zms.provider.client.truststore_password\";\n+    public static final String ZMS_PROP_PROVIDER_APP_NAME = \"athenz.zms.provider.client.app_name\";\n+    public static final String ZMS_PROP_PROVIDER_CERT_PATH = \"athenz.zms.provider.client.cert_path\";\n+    public static final String ZMS_PROP_PROVIDER_KEY_PATH = \"athenz.zms.provider.client.key_path\";\n+    public static final String ZMS_PROP_PROVIDER_MAX_POOL_ROUTE = \"athenz.zms.provider.client.max_pool_route\";\n+    public static final String ZMS_PROP_PROVIDER_MAX_POOL_TOTAL = \"athenz.zms.provider.client.max_pool_total\";\n+    public static final String ZMS_PROP_PROVIDER_RETRY_INTERVAL_MS = \"athenz.zms.provider.client.retry_interval_ms\";\n+    public static final String ZMS_PROP_PROVIDER_MAX_RETRIES = \"athenz.zms.provider.client.max_retries\";\n+    public static final String ZMS_PROP_PROVIDER_CONNECT_TIMEOUT_MS = \"athenz.zms.provider.client.connect_timeout_ms\";\n+    public static final String ZMS_PROP_PROVIDER_READ_TIMEOUT_MS = \"athenz.zms.provider.client.read_timeout_ms\";\n+\n+    public static final String PROVIDER_RESPONSE_ALLOW = \"allow\";\n+    public static final String PROVIDER_RESPONSE_DENY = \"deny\";\n }\n", "next_change": {"commit": "baa68eacd6a6b9bbc70c3423006f92cd47b784d7", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\nindex 5bdf7574c..4be98778b 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\n", "chunk": "@@ -360,4 +362,6 @@ public final class ZMSConsts {\n \n     public static final String PROVIDER_RESPONSE_ALLOW = \"allow\";\n     public static final String PROVIDER_RESPONSE_DENY = \"deny\";\n+    public static final String ZMS_PROP_AUTH_HISTORY_DYNAMODB_TABLE = \"athenz.zms.auth_history.dynamodb.table\";\n+    public static final String ZMS_DEFAULT_AUTH_HISTORY_DYNAMODB_TABLE = \"Athenz-Auth-History\";\n }\n", "next_change": {"commit": "08564d00f6facd436f28a5c3f352488893e0e91c", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\nindex 4be98778b..d9f6de188 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\n", "chunk": "@@ -364,4 +364,5 @@ public final class ZMSConsts {\n     public static final String PROVIDER_RESPONSE_DENY = \"deny\";\n     public static final String ZMS_PROP_AUTH_HISTORY_DYNAMODB_TABLE = \"athenz.zms.auth_history.dynamodb.table\";\n     public static final String ZMS_DEFAULT_AUTH_HISTORY_DYNAMODB_TABLE = \"Athenz-Auth-History\";\n+    public static final String ZMS_PROP_AUTH_HISTORY_DYNAMODB_REGION = \"athenz.zms.auth_history.dynamodb.region\";\n }\n", "next_change": {"commit": "bea97b165e28b5b2cc286af62c92e536c9fc3ff2", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\nindex d9f6de188..79ea96098 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\n", "chunk": "@@ -365,4 +365,6 @@ public final class ZMSConsts {\n     public static final String ZMS_PROP_AUTH_HISTORY_DYNAMODB_TABLE = \"athenz.zms.auth_history.dynamodb.table\";\n     public static final String ZMS_DEFAULT_AUTH_HISTORY_DYNAMODB_TABLE = \"Athenz-Auth-History\";\n     public static final String ZMS_PROP_AUTH_HISTORY_DYNAMODB_REGION = \"athenz.zms.auth_history.dynamodb.region\";\n+    public static final String ZMS_DYNAMODB_URI_DOMAIN_INDEX_NAME = \"uriDomain-index\";\n+    public static final String ZMS_DYNAMODB_PRINCIPAL_DOMAIN_INDEX_NAME = \"principalDomain-index\";\n }\n", "next_change": {"commit": "a5c604e0a9b71f7cfeadab486c45d0bd19ca5582", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\nindex 79ea96098..24650037d 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\n", "chunk": "@@ -362,9 +362,9 @@ public final class ZMSConsts {\n \n     public static final String PROVIDER_RESPONSE_ALLOW = \"allow\";\n     public static final String PROVIDER_RESPONSE_DENY = \"deny\";\n-    public static final String ZMS_PROP_AUTH_HISTORY_DYNAMODB_TABLE = \"athenz.zms.auth_history.dynamodb.table\";\n+    public static final String ZMS_PROP_AUTH_HISTORY_DYNAMODB_TABLE = \"athenz.zms.auth_history_dynamodb_table\";\n     public static final String ZMS_DEFAULT_AUTH_HISTORY_DYNAMODB_TABLE = \"Athenz-Auth-History\";\n-    public static final String ZMS_PROP_AUTH_HISTORY_DYNAMODB_REGION = \"athenz.zms.auth_history.dynamodb.region\";\n+    public static final String ZMS_PROP_AUTH_HISTORY_DYNAMODB_REGION = \"athenz.zms.auth_history_dynamodb_region\";\n     public static final String ZMS_DYNAMODB_URI_DOMAIN_INDEX_NAME = \"uriDomain-index\";\n     public static final String ZMS_DYNAMODB_PRINCIPAL_DOMAIN_INDEX_NAME = \"principalDomain-index\";\n }\n", "next_change": {"commit": "ab7284c9274f4949d23f88ec0dde7b689c0c6980", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\nindex 24650037d..824ecb6a0 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\n", "chunk": "@@ -367,4 +369,12 @@ public final class ZMSConsts {\n     public static final String ZMS_PROP_AUTH_HISTORY_DYNAMODB_REGION = \"athenz.zms.auth_history_dynamodb_region\";\n     public static final String ZMS_DYNAMODB_URI_DOMAIN_INDEX_NAME = \"uriDomain-index\";\n     public static final String ZMS_DYNAMODB_PRINCIPAL_DOMAIN_INDEX_NAME = \"principalDomain-index\";\n+\n+    // purge task\n+    public static final String PURGE_TASK_AUDIT_REF = \"Expired member purged automatically\";\n+    public static final String ZMS_PROP_PURGE_TASK_MAX_DB_CALLS_PER_RUN = \"purge_task_max_db_calls_per_run\";\n+    public static final Integer PURGE_TASK_MAX_DB_CALLS_PER_RUN_DEF = 20;\n+    public static final String ZMS_PROP_PURGE_TASK_LIMIT_PER_CALL = \"purge_task_limit_per_call\";\n+    public static final Integer PURGE_TASK_LIMIT_PER_CALL_DEF = 500;\n+    public static final int DELAY_PURGE_EXPIRED_MEMBERS_DAYS_DEFAULT = 180;\n }\n", "next_change": {"commit": "45dcdab92d9e39d5d561b34ef222f863176cc635", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\nindex 824ecb6a0..38441a4c5 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\n", "chunk": "@@ -371,10 +371,10 @@ public final class ZMSConsts {\n     public static final String ZMS_DYNAMODB_PRINCIPAL_DOMAIN_INDEX_NAME = \"principalDomain-index\";\n \n     // purge task\n-    public static final String PURGE_TASK_AUDIT_REF = \"Expired member purged automatically\";\n-    public static final String ZMS_PROP_PURGE_TASK_MAX_DB_CALLS_PER_RUN = \"purge_task_max_db_calls_per_run\";\n-    public static final Integer PURGE_TASK_MAX_DB_CALLS_PER_RUN_DEF = 20;\n-    public static final String ZMS_PROP_PURGE_TASK_LIMIT_PER_CALL = \"purge_task_limit_per_call\";\n-    public static final Integer PURGE_TASK_LIMIT_PER_CALL_DEF = 500;\n-    public static final int DELAY_PURGE_EXPIRED_MEMBERS_DAYS_DEFAULT = 180;\n+    public static final String ZMS_PROP_PURGE_TASK_MAX_DB_CALLS_PER_RUN = \"athenz.zms.purge_task_max_db_calls_per_run\";\n+    public static final Integer ZMS_PURGE_TASK_MAX_DB_CALLS_PER_RUN_DEF = 20;\n+    public static final String ZMS_PROP_PURGE_TASK_LIMIT_PER_CALL = \"athenz.zms.purge_task_limit_per_call\";\n+    public static final Integer ZMS_PURGE_TASK_LIMIT_PER_CALL_DEF = 500;\n+    public static final String ZMS_PROP_PURGE_MEMBER_EXPIRY_DAYS = \"athenz.zms.purge_member_expiry_days\";\n+    public static final Integer ZMS_PURGE_MEMBER_EXPIRY_DAYS_DEF = 180;\n }\n", "next_change": {"commit": "0ff7ff4f9658fd42e8ee2161d870a89dce5167e4", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\nindex 38441a4c5..780b90e9b 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\n", "chunk": "@@ -377,4 +382,8 @@ public final class ZMSConsts {\n     public static final Integer ZMS_PURGE_TASK_LIMIT_PER_CALL_DEF = 500;\n     public static final String ZMS_PROP_PURGE_MEMBER_EXPIRY_DAYS = \"athenz.zms.purge_member_expiry_days\";\n     public static final Integer ZMS_PURGE_MEMBER_EXPIRY_DAYS_DEF = 180;\n+\n+    //pending member\n+    public static final String PENDING_REQUEST_ADD_STATE = \"ADD\";\n+    public static final String PENDING_REQUEST_DELETE_STATE = \"DELETE\";\n }\n", "next_change": {"commit": "7069bf871635c4e5308d37341904241388b1ccda", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\nindex 780b90e9b..48fbee0d8 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\n", "chunk": "@@ -383,6 +394,11 @@ public final class ZMSConsts {\n     public static final String ZMS_PROP_PURGE_MEMBER_EXPIRY_DAYS = \"athenz.zms.purge_member_expiry_days\";\n     public static final Integer ZMS_PURGE_MEMBER_EXPIRY_DAYS_DEF = 180;\n \n+    public static final String ZMS_PROP_ENFORCE_UNIQUE_AWS_ACCOUNTS = \"athenz.zms.enforce_unique_aws_accounts\";\n+    public static final String ZMS_PROP_ENFORCE_UNIQUE_AZURE_SUBSCRIPTIONS = \"athenz.zms.enforce_unique_azure_subscriptions\";\n+    public static final String ZMS_PROP_ENFORCE_UNIQUE_GCP_PROJECTS = \"athenz.zms.enforce_unique_gcp_projects\";\n+    public static final String ZMS_PROP_ENFORCE_UNIQUE_PRODUCT_IDS = \"athenz.zms.enforce_unique_product_ids\";\n+\n     //pending member\n     public static final String PENDING_REQUEST_ADD_STATE = \"ADD\";\n     public static final String PENDING_REQUEST_DELETE_STATE = \"DELETE\";\n", "next_change": {"commit": "82a1f1a2df6f7f7e24f7f79b8b2fc1107607c63b", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\nindex 48fbee0d8..f1c2e46ce 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSConsts.java\n", "chunk": "@@ -402,4 +404,8 @@ public final class ZMSConsts {\n     //pending member\n     public static final String PENDING_REQUEST_ADD_STATE = \"ADD\";\n     public static final String PENDING_REQUEST_DELETE_STATE = \"DELETE\";\n+\n+    public static final String ZMS_PROP_JSON_MAX_NESTING_DEPTH = \"athenz.zms.json_max_nesting_depth\";\n+    public static final String ZMS_PROP_JSON_MAX_NUMBER_LENGTH = \"athenz.zms.json_max_number_length\";\n+    public static final String ZMS_PROP_JSON_MAX_STRING_LENGTH = \"athenz.zms.json_max_string_length\";\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "message": "Merge commit", "committedDate": null}, {"oid": "31a0dd7362f585f85992d4ff86fbf975d9d736dd", "committedDate": "2020-10-31 14:59:07 -0700", "message": "add azure_subscription field to domains (#1167)"}, {"oid": "7023fb2e0461d7289be1f8b847a37c8e8f9f0359", "committedDate": "2021-01-10 11:50:00 -0800", "message": "Define new authorization_details entity configuration object (#1233)"}, {"oid": "caac34d64db80a6a58cb3418187fc7d0336b3b46", "committedDate": "2021-01-14 22:07:07 -0800", "message": "rich authorization request support (#1246)"}, {"oid": "3c939966592bf7cc6ff25df12a8d21d4c2c89b2b", "committedDate": "2021-01-19 22:05:22 -0800", "message": "client api update for rich authorization requests and consistent naming of entity objects (#1248)"}, {"oid": "3db6ed7b169fce5bbeaa1fae84ff7881e9a4e435", "committedDate": "2021-01-21 09:17:41 -0800", "message": "limit number of role and domain tags (#1255)"}, {"oid": "b95c4676e5037bc6d9eed2bc4dff051daca886bd", "committedDate": "2021-01-22 08:59:56 -0800", "message": "dependency library package updates (#1256)"}, {"oid": "d4f8ed5ad17ecae7b8b238e2756b2d1a0d7191e8", "committedDate": "2021-02-02 17:13:10 -0800", "message": "replace yahoo org references with AthenZ (#1274)"}, {"oid": "acbf4b2b8a6ce662587a3a2eb95ba22873a31e08", "committedDate": "2021-03-10 13:37:47 -0800", "message": "sonarcloud: validate cors origin/header values against allow list + format (#1333)"}, {"oid": "fb32423f568d8ab7cbae4377b4c439018c6a57c1", "committedDate": "2021-03-14 18:37:38 -0700", "message": "new domain and group meta attributes (#1339)"}, {"oid": "5ab30978cc4fc03e1b3022305f6e14a5a425e9e9", "committedDate": "2021-04-07 16:30:50 -0700", "message": "new DomainMetaStore interface support in ZMS (#1430)"}, {"oid": "9bedde4310d6493406d264422f23e16f33213546", "committedDate": "2021-04-08 09:44:29 -0700", "message": "Add group review days to role (#1428)"}, {"oid": "cf535673b0a4cbcdc81e17c7def4cb6822edd78c", "committedDate": "2021-06-22 06:44:42 -0700", "message": "Allow system admins to set domain meta attribute business service (#1522)"}, {"oid": "934fc3d7fc859731f4beab3b03b83a15ac717a2d", "committedDate": "2021-06-29 12:57:53 -0700", "message": "assertion condition server changes (#1528)"}, {"oid": "09de45bb794eb5e7c29f705b5ce567c75fde4e84", "committedDate": "2021-07-29 15:49:16 -0700", "message": "multi-version policy - introducing version/active in policy object (#1568)"}, {"oid": "66590f4fc47f899f3990f20895f953074e40f259", "committedDate": "2021-09-10 07:55:42 -0700", "message": "Implement multi-version policies endpoints (#1605)"}, {"oid": "2968c209e870ce57fbdb1fb048a21692d80cfea6", "committedDate": "2021-10-01 07:25:34 -0700", "message": "rdl publishChangeEvents generator (#1624)"}, {"oid": "389f984270d7d89070c66096e87fafbcb24a261c", "committedDate": "2021-10-26 08:17:36 -0700", "message": "Group tags implementation (#1660)"}, {"oid": "ebf64c278039a27573dabec7e20b27f6524c480c", "committedDate": "2022-01-05 10:37:10 -0800", "message": "correct handling of user authority if not set (#1733)"}, {"oid": "a92c936952fd4c58ea03663c1dbf2d0e5b8892db", "committedDate": "2022-01-20 15:01:37 -0800", "message": "make role validation config based, remove support for wildcards (#1752)"}, {"oid": "020e06e57b357768260f509f08b75c5c068bce53", "committedDate": "2022-02-07 08:01:55 -0800", "message": "Service Visiblity - Domain Dependencies (#1758)"}, {"oid": "3b936a5bc36a83e89c21d4b2150920a3a677cb25", "committedDate": "2022-03-08 08:38:50 -0800", "message": "disable role member expiry notification (#1805)"}, {"oid": "3de182bcbedba89fa2aaba12ab9be49aa2156096", "committedDate": "2022-03-19 09:45:40 -0700", "message": "Add provider webhook for verifying removal (#1816)"}, {"oid": "baa68eacd6a6b9bbc70c3423006f92cd47b784d7", "committedDate": "2022-05-19 09:30:02 -0700", "message": "Get Auth History implementation (#1875)"}, {"oid": "08564d00f6facd436f28a5c3f352488893e0e91c", "committedDate": "2022-05-24 11:18:41 -0700", "message": "Expose authentication history in zms-cli and ZMS Java / go clients (#1881)"}, {"oid": "bea97b165e28b5b2cc286af62c92e536c9fc3ff2", "committedDate": "2022-06-03 13:50:01 -0700", "message": "AuthHistory - Return dependencies instead of list (#1888)"}, {"oid": "a5c604e0a9b71f7cfeadab486c45d0bd19ca5582", "committedDate": "2022-07-04 14:27:33 -0700", "message": "Auth History fixes (#1911)"}, {"oid": "7a313e1d581295ae6c786bbc2ed73bb14da37f7d", "committedDate": "2022-07-21 20:16:24 -0700", "message": "allow management of domain memberPurgeExpiryDays setting value (#1928)"}, {"oid": "ab7284c9274f4949d23f88ec0dde7b689c0c6980", "committedDate": "2022-09-05 13:12:17 -0700", "message": "auto purge expired role/group members based on server/domain config (#1941)"}, {"oid": "d4c733d3e97467a598ba44f0bde5c6a907aa01de", "committedDate": "2022-09-23 13:30:24 -0700", "message": "consistent use of The Athenz Authors copyright in all files (#1967)"}, {"oid": "45dcdab92d9e39d5d561b34ef222f863176cc635", "committedDate": "2022-09-26 12:29:01 -0700", "message": "make server purge expiry member day configurable (#1968)"}, {"oid": "1d970ce72c2f81aed5576fff068103bbba022aaf", "committedDate": "2022-11-29 23:50:29 +0200", "message": "add gcp project attribute for domains (#2005)"}, {"oid": "70850ab1de4055e765cf4ead6946b431900ff8c8", "committedDate": "2023-01-23 16:40:36 -0800", "message": "move cloud provider role generation logic out of dbstore library to dbservice (#2043)"}, {"oid": "0ff7ff4f9658fd42e8ee2161d870a89dce5167e4", "committedDate": "2023-02-02 09:18:32 -0800", "message": "Add a requirement for admin approval to delete members in review-enabled roles (#2053)"}, {"oid": "4ee14d784973ce7da8aba96b35eefdbc5d61d97b", "committedDate": "2023-03-07 11:34:04 -0800", "message": "make aws/gcp assume role action values configurable (#2090)"}, {"oid": "d1b98d4614d62fe34b408cfa1a26fb59674d6494", "committedDate": "2023-03-27 16:46:33 -0700", "message": "store GCP project number along with project id in athenz domain metadata (#2113)"}, {"oid": "6e7342a1e98207b87e3eae45341db281b7b3b9c7", "committedDate": "2023-04-13 14:30:39 -0700", "message": "designate separate action for assertions when assuming gcp service accounts (#2127)"}, {"oid": "d070f416d600e09d2bb9ec2c5b699cc28b0325b5", "committedDate": "2023-04-28 07:56:05 -0700", "message": "config setting for reserved top level domains (#2147)"}, {"oid": "43f43436a2d192a5df6c6ef01857e924f9eda6c6", "committedDate": "2023-05-29 09:59:53 -0700", "message": "disallow by default services with _ in their names (#2191)"}, {"oid": "7069bf871635c4e5308d37341904241388b1ccda", "committedDate": "2023-05-30 15:31:26 -0700", "message": "support product id (string) format association with domains (#2193)"}, {"oid": "368d0bc139931c03d31824c4f02394b38e3ead95", "committedDate": "2023-06-02 13:15:05 -0700", "message": "support headless user type - managed by user authority but treated like service (#2197)"}, {"oid": "82a1f1a2df6f7f7e24f7f79b8b2fc1107607c63b", "committedDate": "2023-06-08 07:43:21 -0700", "message": "increased/configure json string limit for jackson (#2203)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4MTg0Mw==", "url": "https://github.com/AthenZ/athenz/pull/1157#discussion_r510481843", "body": "1) we should fetch the enablePrincipalStateUpdater setting in this method and most likely it can just be a local setting since it's not used anywhere else.\r\n\r\n2) where are using principalStateUpdater member? I see no references", "bodyText": "we should fetch the enablePrincipalStateUpdater setting in this method and most likely it can just be a local setting since it's not used anywhere else.\n\n\nwhere are using principalStateUpdater member? I see no references", "bodyHTML": "<ol dir=\"auto\">\n<li>\n<p dir=\"auto\">we should fetch the enablePrincipalStateUpdater setting in this method and most likely it can just be a local setting since it's not used anywhere else.</p>\n</li>\n<li>\n<p dir=\"auto\">where are using principalStateUpdater member? I see no references</p>\n</li>\n</ol>", "author": "havetisyan", "createdAt": "2020-10-22T21:57:55Z", "path": "servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSImpl.java", "diffHunk": "@@ -577,6 +578,16 @@ public ZMSImpl() {\n         // load the StatusChecker\n \n         loadStatusChecker();\n+\n+        // system disabled from UserAuthority\n+        \n+        initializePrincipalStateUpdater();\n+    }\n+\n+    private void initializePrincipalStateUpdater() {\n+        if (enablePrincipalStateUpdater) {", "originalCommit": "45b271a460205ef873d48d4247128daa43779d54", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f2b6979e4235f325d7eea75d6f63d358c03d8d3c", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSImpl.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSImpl.java\nindex 5f70840db..d90fcb1cc 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSImpl.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSImpl.java\n", "chunk": "@@ -585,8 +583,8 @@ public class ZMSImpl implements Authorizer, KeyStore, ZMSHandler {\n     }\n \n     private void initializePrincipalStateUpdater() {\n-        if (enablePrincipalStateUpdater) {\n-            principalStateUpdater = new PrincipalStateUpdater(this.dbService, this.userAuthority);\n+        if (Boolean.parseBoolean(System.getProperty(ZMSConsts.ZMS_PROP_ENABLE_PRINCIPAL_STATE_UPDATER, \"false\"))) {\n+            new PrincipalStateUpdater(this.dbService, this.userAuthority);\n         }\n     }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSImpl.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSImpl.java\nindex 5f70840db..d90fcb1cc 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSImpl.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSImpl.java\n", "chunk": "@@ -585,8 +583,8 @@ public class ZMSImpl implements Authorizer, KeyStore, ZMSHandler {\n     }\n \n     private void initializePrincipalStateUpdater() {\n-        if (enablePrincipalStateUpdater) {\n-            principalStateUpdater = new PrincipalStateUpdater(this.dbService, this.userAuthority);\n+        if (Boolean.parseBoolean(System.getProperty(ZMSConsts.ZMS_PROP_ENABLE_PRINCIPAL_STATE_UPDATER, \"false\"))) {\n+            new PrincipalStateUpdater(this.dbService, this.userAuthority);\n         }\n     }\n \n", "next_change": {"commit": "6a550734b6b31a86833bee2242067e47753e83dd", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSImpl.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSImpl.java\nindex d90fcb1cc..ca49fce46 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSImpl.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSImpl.java\n", "chunk": "@@ -589,8 +652,9 @@ public class ZMSImpl implements Authorizer, KeyStore, ZMSHandler {\n     }\n \n     private void setNotificationManager() {\n-        ZMSNotificationTaskFactory zmsNotificationTaskFactory = new ZMSNotificationTaskFactory(dbService, userDomainPrefix);\n-        notificationManager = new NotificationManager(zmsNotificationTaskFactory.getNotificationTasks());\n+        notificationToEmailConverterCommon = new NotificationToEmailConverterCommon(userAuthority);\n+        ZMSNotificationTaskFactory zmsNotificationTaskFactory = new ZMSNotificationTaskFactory(dbService, userDomainPrefix, notificationToEmailConverterCommon);\n+        notificationManager = new NotificationManager(zmsNotificationTaskFactory.getNotificationTasks(), userAuthority);\n     }\n \n     void loadSystemProperties() {\n", "next_change": {"commit": "eed8de5e7e706770ab9f73de2f138e5691066ade", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSImpl.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSImpl.java\nindex ca49fce46..c917d0952 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSImpl.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSImpl.java\n", "chunk": "@@ -660,7 +662,7 @@ public class ZMSImpl implements Authorizer, KeyStore, ZMSHandler {\n     void loadSystemProperties() {\n         String propFile = System.getProperty(ZMSConsts.ZMS_PROP_FILE_NAME,\n                 getRootDir() + \"/conf/zms_server/zms.properties\");\n-        ConfigProperties.loadProperties(propFile);\n+        new ConfigManager().addConfigSource(ConfigProviderFile.PROVIDER_DESCRIPTION_PREFIX + propFile);\n     }\n \n     void setAuthorityKeyStore() {\n", "next_change": {"commit": "53dda79ade254991ede23e735fa7abf280c790a0", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSImpl.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSImpl.java\nindex c917d0952..506bd4d3b 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSImpl.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/ZMSImpl.java\n", "chunk": "@@ -662,7 +712,11 @@ public class ZMSImpl implements Authorizer, KeyStore, ZMSHandler {\n     void loadSystemProperties() {\n         String propFile = System.getProperty(ZMSConsts.ZMS_PROP_FILE_NAME,\n                 getRootDir() + \"/conf/zms_server/zms.properties\");\n-        new ConfigManager().addConfigSource(ConfigProviderFile.PROVIDER_DESCRIPTION_PREFIX + propFile);\n+        try {\n+            CONFIG_MANAGER.addConfigSource(ConfigProviderFile.PROVIDER_DESCRIPTION_PREFIX + propFile);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e.getMessage());\n+        }\n     }\n \n     void setAuthorityKeyStore() {\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "message": "Merge commit", "committedDate": null}, {"oid": "9a9c82c13d156e06dad8464c3a6c52c8e2bc6b89", "committedDate": "2020-10-26 14:15:03 -0700", "message": "remove sending back deprected members field in roles (#1160)"}, {"oid": "31a0dd7362f585f85992d4ff86fbf975d9d736dd", "committedDate": "2020-10-31 14:59:07 -0700", "message": "add azure_subscription field to domains (#1167)"}, {"oid": "566bb863f7cd3b88bda9df1fc6e489cfc980a63f", "committedDate": "2020-11-02 08:02:23 -0800", "message": "fix domain list arg order + unit tests (#1171)"}, {"oid": "f24d15baaaddc96c85fbceb31fcaded756a69f2e", "committedDate": "2020-11-14 16:51:57 -0800", "message": "role tags - generated code and schema changes (#1179)"}, {"oid": "2768c7bbe559d607b4bf11d810cf789b4b0e6fcd", "committedDate": "2020-12-02 13:18:04 -0800", "message": "match principal validation with rdl definitions (#1203)"}, {"oid": "a058372626ae5bc93eee82ddfdb3b7c9a3556488", "committedDate": "2020-12-18 18:46:33 -0800", "message": "set role group member expiry (#1215)"}, {"oid": "7a2837c7578ab8d36c62b48ecb1d0079c670616b", "committedDate": "2020-12-29 13:44:04 -0800", "message": "granular authz action for managing role members (#1228)"}, {"oid": "e1fa1a140cf4c3160b077a7a3c6587c3fd32fac8", "committedDate": "2021-01-10 09:51:23 -0800", "message": "domain tags schema changes, generated code and clients changes (#1229)"}, {"oid": "7023fb2e0461d7289be1f8b847a37c8e8f9f0359", "committedDate": "2021-01-10 11:50:00 -0800", "message": "Define new authorization_details entity configuration object (#1233)"}, {"oid": "d6a0d659fe96486ffcf31bb93e919656be9eaf89", "committedDate": "2021-01-13 08:15:47 -0800", "message": "domain tags implementation (#1235)"}, {"oid": "83e130dbc88dd2072d9a090a1029cadab4046dff", "committedDate": "2021-01-14 17:01:16 -0800", "message": "make tenancy admin role optional (#1245)"}, {"oid": "caac34d64db80a6a58cb3418187fc7d0336b3b46", "committedDate": "2021-01-14 22:07:07 -0800", "message": "rich authorization request support (#1246)"}, {"oid": "3c939966592bf7cc6ff25df12a8d21d4c2c89b2b", "committedDate": "2021-01-19 22:05:22 -0800", "message": "client api update for rich authorization requests and consistent naming of entity objects (#1248)"}, {"oid": "5e69fac2145086cfb38d1a587a96422fa81d0da0", "committedDate": "2021-02-19 14:12:44 -0800", "message": "add support for groups for resource lookup api  (#1305)"}, {"oid": "87c08625ab9c49bcd847de4f92598f98113e536c", "committedDate": "2021-02-23 13:42:29 -0800", "message": "check for template keywords both null and empty (#1309)"}, {"oid": "24ee0ca10e0b7da8070e01543d3258d54b0d034f", "committedDate": "2021-03-01 20:46:22 -0800", "message": "do not modify db assertion objects during access checks (#1318)"}, {"oid": "acbf4b2b8a6ce662587a3a2eb95ba22873a31e08", "committedDate": "2021-03-10 13:37:47 -0800", "message": "sonarcloud: validate cors origin/header values against allow list + format (#1333)"}, {"oid": "850a91cf5ce8fb1d216683fb938d7fc4fa8fc280", "committedDate": "2021-03-14 18:37:53 -0700", "message": "sonarcloud: Format specifiers should be used instead of string concatenation (#1341)"}, {"oid": "e421f20094d24075d2cec7ab7adecff7d630a286", "committedDate": "2021-03-16 18:08:03 -0700", "message": "expose new domain attribute: business-service (#1357)"}, {"oid": "7b4afd5d40394226b3aa1af8bf10e90e528091b3", "committedDate": "2021-04-01 14:52:30 -0700", "message": "Add memberExpiryDays and serviceExpiryDays support for groups (#1388)"}, {"oid": "5ab30978cc4fc03e1b3022305f6e14a5a425e9e9", "committedDate": "2021-04-07 16:30:50 -0700", "message": "new DomainMetaStore interface support in ZMS (#1430)"}, {"oid": "9bedde4310d6493406d264422f23e16f33213546", "committedDate": "2021-04-08 09:44:29 -0700", "message": "Add group review days to role (#1428)"}, {"oid": "b7440c2f5047542429ff5c003f4731c2bdbad008", "committedDate": "2021-04-09 12:27:51 -0700", "message": "more specific resource for tenancy admins with resource groups (#1435)"}, {"oid": "a554c75c51c5945b0e58ae87866de93ff1d5cfbc", "committedDate": "2021-04-15 12:12:02 -0700", "message": "during provider admin setup, ignore deletes (#1444)"}, {"oid": "9958828d33f47aaf75d94e179093147734ef04ff", "committedDate": "2021-04-27 08:48:31 -0700", "message": "Add api: get valid values for domain meta attributes (#1456)"}, {"oid": "93873ecb0266153a6cc507ded2de9811afe2ab94", "committedDate": "2021-04-30 08:16:33 -0700", "message": "Extend getUserList ZMS API to take an optional domain name #1466 (#1467)"}, {"oid": "4d4493ecd12a1ea80eb3cdde47e0d1e40a5d4225", "committedDate": "2021-06-06 14:52:17 -0700", "message": "Add zms endpoint: Get all server template meta details (#1504)"}, {"oid": "addf4424a5bf842b58558c6f61ac0b46277d9535", "committedDate": "2021-06-07 09:38:12 -0700", "message": "allow role/group review regardless of role/group expiry/reminder settings (#1503)"}, {"oid": "60952200a20db3437c67a07bb9bb2844659ecad2", "committedDate": "2021-06-17 10:17:51 -0700", "message": "New endpoint for UI: Get all valid authrority attributes (#1520)"}, {"oid": "cf535673b0a4cbcdc81e17c7def4cb6822edd78c", "committedDate": "2021-06-22 06:44:42 -0700", "message": "Allow system admins to set domain meta attribute business service (#1522)"}, {"oid": "c4da9f0043c656943d9098729a840dd0e1ec4f52", "committedDate": "2021-06-22 09:18:20 -0700", "message": "UI: Onboard template to domain (#1505)"}, {"oid": "3fa0d07e4df2f5ec8d3718dffe129c03511cc5ea", "committedDate": "2021-06-22 17:24:46 -0700", "message": "Assertion conditions implementation - core, clients, DB schema changes (#1523)"}, {"oid": "934fc3d7fc859731f4beab3b03b83a15ac717a2d", "committedDate": "2021-06-29 12:57:53 -0700", "message": "assertion condition server changes (#1528)"}, {"oid": "c1b1cb81c7a7e54e03a9c7f8171f3cb7bad3ce66", "committedDate": "2021-06-30 15:49:18 -0700", "message": "Add missing attributes in \"getSignedDomains\" call (#1530)"}, {"oid": "5f2d654f7657b7ac1b2575144998aa6cfea5f126", "committedDate": "2021-07-19 09:01:03 -0700", "message": "proper handling of disabled domains from zms to zts (#1556)"}, {"oid": "09de45bb794eb5e7c29f705b5ce567c75fde4e84", "committedDate": "2021-07-29 15:49:16 -0700", "message": "multi-version policy - introducing version/active in policy object (#1568)"}, {"oid": "6a550734b6b31a86833bee2242067e47753e83dd", "committedDate": "2021-08-01 10:24:43 -0700", "message": "For notifications - get recipient email from User Authority (#1561)"}, {"oid": "41caa478a1eb12a21c5e146a64b715df69ae805b", "committedDate": "2021-08-02 16:49:56 -0700", "message": "extend getJWSDomain api to support etags and return all domain data (#1570)"}, {"oid": "ddb325c17a8271637b94bcac42eeb0f3f0d0c324", "committedDate": "2021-08-08 10:52:18 -0700", "message": "Extend group expiration (#1584)"}, {"oid": "eed8de5e7e706770ab9f73de2f138e5691066ade", "committedDate": "2021-08-17 12:17:47 -0700", "message": "New config management package (#1569)"}, {"oid": "696ca890b65564cbd85f3a60ef93e3aae438538b", "committedDate": "2021-08-17 19:08:48 -0700", "message": "correctly support new config manager library that returns empty values instead of nulls (#1592)"}, {"oid": "6788dc080d223722174934964a221fb06ca74e4c", "committedDate": "2021-09-08 13:39:18 -0700", "message": "support p1363 format for jws data with ec keys in zms as well (#1611)"}, {"oid": "66590f4fc47f899f3990f20895f953074e40f259", "committedDate": "2021-09-10 07:55:42 -0700", "message": "Implement multi-version policies endpoints (#1605)"}, {"oid": "91b116418656f123dae9a3405cb2e498d4d3aff4", "committedDate": "2021-09-12 09:52:05 +0300", "message": "additional validation checks when processing versioned policies (#1614)"}, {"oid": "29b42dc28d24b5a7cede9ba6f574df877fef3b82", "committedDate": "2021-09-19 09:17:34 -0700", "message": "Add version and active status to policy list (#1625)"}, {"oid": "2968c209e870ce57fbdb1fb048a21692d80cfea6", "committedDate": "2021-10-01 07:25:34 -0700", "message": "rdl publishChangeEvents generator (#1624)"}, {"oid": "d38aa09f84a8ddae889b9e8dba05ba435e933028", "committedDate": "2021-10-04 13:32:27 -0700", "message": "skip creating event objects if no publishers are registered (#1635)"}, {"oid": "be378f83e1ae7cca2946cbdd3ed7c3082d4fb219", "committedDate": "2021-10-04 14:03:22 -0700", "message": "Fix setting policy version active as null return 500 instead of 404 when trying to create a new active  policy which already exists (#1638)"}, {"oid": "194945cc31885a4be3b4a10de6e2bad4b7d98b0d", "committedDate": "2021-10-20 18:28:29 -0700", "message": "putRoleMeta can now be called by principals (#1657)"}, {"oid": "389f984270d7d89070c66096e87fafbcb24a261c", "committedDate": "2021-10-26 08:17:36 -0700", "message": "Group tags implementation (#1660)"}, {"oid": "1400363e8d698cf08370c89752077ebae043c5be", "committedDate": "2021-12-14 13:48:34 -0800", "message": "correct logging of role principal in audit/access logs"}, {"oid": "53dda79ade254991ede23e735fa7abf280c790a0", "committedDate": "2021-12-23 20:39:07 +0200", "message": "Use Config Manager to refresh configuration variables from AWS Parameter Store"}, {"oid": "c8e3a5c91c5deb9640576cd3496a2af11d572f0b", "committedDate": "2021-12-23 15:03:25 -0800", "message": "protect system admin users from being removed from deleteUser api (#1715)"}, {"oid": "ebf64c278039a27573dabec7e20b27f6524c480c", "committedDate": "2022-01-05 10:37:10 -0800", "message": "correct handling of user authority if not set (#1733)"}, {"oid": "0e3d88db92b43846dab3790e270c0f5989500925", "committedDate": "2022-01-06 10:11:34 -0800", "message": "update manual install steps with fixes (#1736)"}, {"oid": "e4c6de501909f03949ef09df55d285295cdf2fd9", "committedDate": "2022-01-12 16:59:13 -0800", "message": "Letting ZMSImpl initialize, when change publisher is not initialized fully"}, {"oid": "7bba0296334535128502dfa01e7699168ecdbf67", "committedDate": "2022-01-18 14:04:33 -0800", "message": "role consistency check when deleting roles or adding assertions (#1727)"}, {"oid": "a92c936952fd4c58ea03663c1dbf2d0e5b8892db", "committedDate": "2022-01-20 15:01:37 -0800", "message": "make role validation config based, remove support for wildcards (#1752)"}, {"oid": "020e06e57b357768260f509f08b75c5c068bce53", "committedDate": "2022-02-07 08:01:55 -0800", "message": "Service Visiblity - Domain Dependencies (#1758)"}, {"oid": "fcbd4128e334a9a42f4579d179cf9578d3f4de99", "committedDate": "2022-02-07 10:12:47 -0800", "message": "support new get-stats endpoint to get per-domain/system stats (#1774)"}, {"oid": "d530b95caa64b3db45c822ce9014b50cd4184caa", "committedDate": "2022-02-14 13:37:19 -0800", "message": "For domain dependency, sys admin can be a service (#1781)"}, {"oid": "ea831a34a70a0475bea8754cb183741dced98ff2", "committedDate": "2022-02-18 09:17:55 -0800", "message": "update pending member api to support getting list for a domain (#1783)"}, {"oid": "f4229124e8e1898810c7aa7b3a4eff37fddae308", "committedDate": "2022-02-18 12:37:32 -0800", "message": "provide option to skip adding principal when onboarding a resource group (#1787)"}, {"oid": "9081feb4c06a1058c941c67923037203d9318cfa", "committedDate": "2022-02-27 14:10:46 -0800", "message": "Domain Dependency for Tenancy (#1789)"}, {"oid": "a5bb615881583fa6f39621e2ea3bf39d3886340b", "committedDate": "2022-03-03 17:20:00 -0800", "message": "extend template keyword support trust field in roles (#1803)"}, {"oid": "c583b29239fa7c0864e7a4f3eb7b63e7f65a7564", "committedDate": "2022-03-10 11:10:08 -0800", "message": "return server template names in sorted order (#1812)"}, {"oid": "3de182bcbedba89fa2aaba12ab9be49aa2156096", "committedDate": "2022-03-19 09:45:40 -0700", "message": "Add provider webhook for verifying removal (#1816)"}, {"oid": "3619839ba4867cd0214730290771d1ca19ab7752", "committedDate": "2022-03-23 12:31:31 -0700", "message": "Endpoint to get dependent services and resource groups (#1818)"}, {"oid": "3cd20cbb07064a26b10fd708a5f10de580fd1f85", "committedDate": "2022-03-31 17:28:40 -0700", "message": "reset provider list if role has no members (#1839)"}, {"oid": "3223be5f17e151bd6775dd181faf58d1ce66d826", "committedDate": "2022-04-06 19:40:57 -0700", "message": "remove unnecessary is member check from member decision calls (#1845)"}, {"oid": "2311c1e322517482dc43a0a8754d550b5f934e52", "committedDate": "2022-04-15 13:12:21 -0700", "message": "When deleting tenant resource group roles, delete dependency if the (#1850)"}, {"oid": "6fac69959050796bbd8cda4334125db02b7e666d", "committedDate": "2022-04-15 15:02:46 -0700", "message": "remove unused method arguments (#1854)"}, {"oid": "6d137194a11c740deb7fcc1e4234f84b70419862", "committedDate": "2022-05-10 20:47:54 -0700", "message": "update to jetty 11, remove jersey from client impl (#1865)"}, {"oid": "ea4a2ab0c4d2631186673da578e77b83a775aab3", "committedDate": "2022-05-17 17:00:18 -0700", "message": "expose servlet context to web application (#1874)"}, {"oid": "69680d3ff1e27e2c9cfa9c4a5737a9af008a0191", "committedDate": "2022-05-19 09:29:28 -0700", "message": "add /info endpoint for zms/zts servers (#1877)"}, {"oid": "baa68eacd6a6b9bbc70c3423006f92cd47b784d7", "committedDate": "2022-05-19 09:30:02 -0700", "message": "Get Auth History implementation (#1875)"}, {"oid": "cecaf4d1ee59baaf6b51a63bc2b9b11b1cacfa78", "committedDate": "2022-05-19 13:14:01 -0700", "message": "unit tests for the /info endpoints (#1879)"}, {"oid": "bea97b165e28b5b2cc286af62c92e536c9fc3ff2", "committedDate": "2022-06-03 13:50:01 -0700", "message": "AuthHistory - Return dependencies instead of list (#1888)"}, {"oid": "f660d9b393b33300e9313436ae0ab70d215db2a5", "committedDate": "2022-07-08 15:29:09 -0700", "message": "allow users to remove themselves from roles/groups (#1913)"}, {"oid": "7a313e1d581295ae6c786bbc2ed73bb14da37f7d", "committedDate": "2022-07-21 20:16:24 -0700", "message": "allow management of domain memberPurgeExpiryDays setting value (#1928)"}, {"oid": "f288ed7afb018bc07af02dbe9dc8e05ec0896071", "committedDate": "2022-08-15 22:28:01 -0700", "message": "provide header option to return updated object in response (#1942)"}, {"oid": "ab7284c9274f4949d23f88ec0dde7b689c0c6980", "committedDate": "2022-09-05 13:12:17 -0700", "message": "auto purge expired role/group members based on server/domain config (#1941)"}, {"oid": "d4c733d3e97467a598ba44f0bde5c6a907aa01de", "committedDate": "2022-09-23 13:30:24 -0700", "message": "consistent use of The Athenz Authors copyright in all files (#1967)"}, {"oid": "4c8e210cb2ff255738fa399428edd98ce32b8810", "committedDate": "2022-11-02 19:34:54 -0700", "message": "during role delete check policy usage against primary db (#1999)"}, {"oid": "32ed76944c7fedc3a3ae831e59a68f62402c15cb", "committedDate": "2022-11-15 10:36:47 -0800", "message": "ignore errors when adding a new user to an empty admin role (#2001)"}, {"oid": "1d970ce72c2f81aed5576fff068103bbba022aaf", "committedDate": "2022-11-29 23:50:29 +0200", "message": "add gcp project attribute for domains (#2005)"}, {"oid": "fc5a206d1cb23dd2bbfd9af7e3125ec270ebc022", "committedDate": "2023-01-10 21:48:12 -0800", "message": "allow domain admins to enable audit flag for new roles/groups (#2032)"}, {"oid": "13615da88d1fc96620634afa9806a1ec45e8947e", "committedDate": "2023-01-12 22:08:19 -0800", "message": "use correct role prefix when filtering tenant resource group roles (#2037)"}, {"oid": "0ff7ff4f9658fd42e8ee2161d870a89dce5167e4", "committedDate": "2023-02-02 09:18:32 -0800", "message": "Add a requirement for admin approval to delete members in review-enabled roles (#2053)"}, {"oid": "bb1d69af70a90aeedc28a46604283064e0dad8de", "committedDate": "2023-02-16 07:44:40 -0800", "message": "add audit enable to role (#2055)"}, {"oid": "5216da47ef8bca89ba0eae790f72739d9d73fcc6", "committedDate": "2023-03-09 10:36:29 -0800", "message": "Add optional 'description' to role (#2091)"}, {"oid": "d1b98d4614d62fe34b408cfa1a26fb59674d6494", "committedDate": "2023-03-27 16:46:33 -0700", "message": "store GCP project number along with project id in athenz domain metadata (#2113)"}, {"oid": "fa82a891cb4a0982320ba21603d8ccaab4b83dde", "committedDate": "2023-04-24 08:45:50 -0700", "message": "fix NPE while setting User Authority Expiration\tfor role without members (#2142)"}, {"oid": "d070f416d600e09d2bb9ec2c5b699cc28b0325b5", "committedDate": "2023-04-28 07:56:05 -0700", "message": "config setting for reserved top level domains (#2147)"}, {"oid": "43f43436a2d192a5df6c6ef01857e924f9eda6c6", "committedDate": "2023-05-29 09:59:53 -0700", "message": "disallow by default services with _ in their names (#2191)"}, {"oid": "7069bf871635c4e5308d37341904241388b1ccda", "committedDate": "2023-05-30 15:31:26 -0700", "message": "support product id (string) format association with domains (#2193)"}, {"oid": "368d0bc139931c03d31824c4f02394b38e3ead95", "committedDate": "2023-06-02 13:15:05 -0700", "message": "support headless user type - managed by user authority but treated like service (#2197)"}, {"oid": "82a1f1a2df6f7f7e24f7f79b8b2fc1107607c63b", "committedDate": "2023-06-08 07:43:21 -0700", "message": "increased/configure json string limit for jackson (#2203)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4MjQ5OA==", "url": "https://github.com/AthenZ/athenz/pull/1157#discussion_r510482498", "body": "any reason to get the principal id first - instead of just updating the principal entry based on the name? ", "bodyText": "any reason to get the principal id first - instead of just updating the principal entry based on the name?", "bodyHTML": "<p dir=\"auto\">any reason to get the principal id first - instead of just updating the principal entry based on the name?</p>", "author": "havetisyan", "createdAt": "2020-10-22T21:59:27Z", "path": "servers/zms/src/main/java/com/yahoo/athenz/zms/store/jdbc/JDBCConnection.java", "diffHunk": "@@ -5603,6 +5605,43 @@ public DomainGroupMember getPrincipalGroups(String principal, String domainName)\n         return groups;\n     }\n \n+\n+    @Override\n+    public boolean updatePrincipal(String principal, int newState) {\n+        final String caller = \"updatePrincipal\";\n+\n+        int principalId = getPrincipalId(principal);\n+        if (principalId == 0) {\n+            throw notFoundError(caller, ZMSConsts.OBJECT_PRINCIPAL, principal);\n+        }\n+        int affectedRows;\n+        try (PreparedStatement ps = con.prepareStatement(SQL_UPDATE_PRINCIPAL)) {", "originalCommit": "45b271a460205ef873d48d4247128daa43779d54", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f2b6979e4235f325d7eea75d6f63d358c03d8d3c", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/store/jdbc/JDBCConnection.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/store/jdbc/JDBCConnection.java\nindex a931d0503..40fa3473f 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/store/jdbc/JDBCConnection.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/store/jdbc/JDBCConnection.java\n", "chunk": "@@ -5610,14 +5610,10 @@ public class JDBCConnection implements ObjectStoreConnection {\n     public boolean updatePrincipal(String principal, int newState) {\n         final String caller = \"updatePrincipal\";\n \n-        int principalId = getPrincipalId(principal);\n-        if (principalId == 0) {\n-            throw notFoundError(caller, ZMSConsts.OBJECT_PRINCIPAL, principal);\n-        }\n         int affectedRows;\n         try (PreparedStatement ps = con.prepareStatement(SQL_UPDATE_PRINCIPAL)) {\n             ps.setInt(1, newState);\n-            ps.setInt(2, principalId);\n+            ps.setString(2, principal);\n             affectedRows = executeUpdate(ps, caller);\n         } catch (SQLException ex) {\n             throw sqlError(ex, caller);\n", "next_change": null}]}, "revised_code_in_main": {"commit": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/store/jdbc/JDBCConnection.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/store/jdbc/JDBCConnection.java\nindex a931d0503..793fa4fad 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/store/jdbc/JDBCConnection.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/store/jdbc/JDBCConnection.java\n", "chunk": "@@ -5610,14 +5610,10 @@ public class JDBCConnection implements ObjectStoreConnection {\n     public boolean updatePrincipal(String principal, int newState) {\n         final String caller = \"updatePrincipal\";\n \n-        int principalId = getPrincipalId(principal);\n-        if (principalId == 0) {\n-            throw notFoundError(caller, ZMSConsts.OBJECT_PRINCIPAL, principal);\n-        }\n         int affectedRows;\n         try (PreparedStatement ps = con.prepareStatement(SQL_UPDATE_PRINCIPAL)) {\n             ps.setInt(1, newState);\n-            ps.setInt(2, principalId);\n+            ps.setString(2, principal);\n             affectedRows = executeUpdate(ps, caller);\n         } catch (SQLException ex) {\n             throw sqlError(ex, caller);\n", "next_change": null}]}, "commits_in_main": [{"oid": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "message": "Merge commit", "committedDate": null}, {"oid": "486ed4542fb4fc70ba0c3d8cb26a198c1f001f60", "committedDate": "2020-10-30 14:10:06 -0700", "message": "If both expration and review dates are set, start sending (#1166)"}, {"oid": "31a0dd7362f585f85992d4ff86fbf975d9d736dd", "committedDate": "2020-10-31 14:59:07 -0700", "message": "add azure_subscription field to domains (#1167)"}, {"oid": "b005cb0209503f3a89e10b43d9ecb0997472e335", "committedDate": "2020-11-01 10:37:27 -0800", "message": "archive file connection store (#1170)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4Mjc5Ng==", "url": "https://github.com/AthenZ/athenz/pull/1157#discussion_r510482796", "body": "prefer using the column names since it's easier to add more fields later and not worry about the order", "bodyText": "prefer using the column names since it's easier to add more fields later and not worry about the order", "bodyHTML": "<p dir=\"auto\">prefer using the column names since it's easier to add more fields later and not worry about the order</p>", "author": "havetisyan", "createdAt": "2020-10-22T22:00:10Z", "path": "servers/zms/src/main/java/com/yahoo/athenz/zms/store/jdbc/JDBCConnection.java", "diffHunk": "@@ -5603,6 +5605,43 @@ public DomainGroupMember getPrincipalGroups(String principal, String domainName)\n         return groups;\n     }\n \n+\n+    @Override\n+    public boolean updatePrincipal(String principal, int newState) {\n+        final String caller = \"updatePrincipal\";\n+\n+        int principalId = getPrincipalId(principal);\n+        if (principalId == 0) {\n+            throw notFoundError(caller, ZMSConsts.OBJECT_PRINCIPAL, principal);\n+        }\n+        int affectedRows;\n+        try (PreparedStatement ps = con.prepareStatement(SQL_UPDATE_PRINCIPAL)) {\n+            ps.setInt(1, newState);\n+            ps.setInt(2, principalId);\n+            affectedRows = executeUpdate(ps, caller);\n+        } catch (SQLException ex) {\n+            throw sqlError(ex, caller);\n+        }\n+        return (affectedRows > 0);\n+    }\n+\n+    @Override\n+    public List<String> getPrincipals(int queriedState) {\n+        final String caller = \"getPrincipals\";\n+        List<String> principals = new ArrayList<>();\n+        try (PreparedStatement ps = con.prepareStatement(SQL_GET_PRINCIPAL)) {\n+            ps.setInt(1, queriedState);\n+            try (ResultSet rs = executeQuery(ps, caller)) {\n+                while (rs.next()) {\n+                    principals.add(rs.getString(1));", "originalCommit": "45b271a460205ef873d48d4247128daa43779d54", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f2b6979e4235f325d7eea75d6f63d358c03d8d3c", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/store/jdbc/JDBCConnection.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/store/jdbc/JDBCConnection.java\nindex a931d0503..40fa3473f 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/store/jdbc/JDBCConnection.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/store/jdbc/JDBCConnection.java\n", "chunk": "@@ -5633,7 +5629,7 @@ public class JDBCConnection implements ObjectStoreConnection {\n             ps.setInt(1, queriedState);\n             try (ResultSet rs = executeQuery(ps, caller)) {\n                 while (rs.next()) {\n-                    principals.add(rs.getString(1));\n+                    principals.add(rs.getString(ZMSConsts.DB_COLUMN_NAME));\n                 }\n             }\n         } catch (SQLException ex) {\n", "next_change": null}]}, "revised_code_in_main": {"commit": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/store/jdbc/JDBCConnection.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/store/jdbc/JDBCConnection.java\nindex a931d0503..793fa4fad 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/store/jdbc/JDBCConnection.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/store/jdbc/JDBCConnection.java\n", "chunk": "@@ -5633,7 +5629,7 @@ public class JDBCConnection implements ObjectStoreConnection {\n             ps.setInt(1, queriedState);\n             try (ResultSet rs = executeQuery(ps, caller)) {\n                 while (rs.next()) {\n-                    principals.add(rs.getString(1));\n+                    principals.add(rs.getString(ZMSConsts.DB_COLUMN_NAME));\n                 }\n             }\n         } catch (SQLException ex) {\n", "next_change": null}]}, "commits_in_main": [{"oid": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "message": "Merge commit", "committedDate": null}, {"oid": "486ed4542fb4fc70ba0c3d8cb26a198c1f001f60", "committedDate": "2020-10-30 14:10:06 -0700", "message": "If both expration and review dates are set, start sending (#1166)"}, {"oid": "31a0dd7362f585f85992d4ff86fbf975d9d736dd", "committedDate": "2020-10-31 14:59:07 -0700", "message": "add azure_subscription field to domains (#1167)"}, {"oid": "b005cb0209503f3a89e10b43d9ecb0997472e335", "committedDate": "2020-11-01 10:37:27 -0800", "message": "archive file connection store (#1170)"}]}, {"oid": "f2b6979e4235f325d7eea75d6f63d358c03d8d3c", "url": "https://github.com/AthenZ/athenz/commit/f2b6979e4235f325d7eea75d6f63d358c03d8d3c", "message": "addressing review comments", "committedDate": "2020-10-23T06:18:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAwMzcyNg==", "url": "https://github.com/AthenZ/athenz/pull/1157#discussion_r511003726", "body": "this should be within the if block so we're not wasting create the listing if there is nothing to do. or better yet in order not to have the whole function as we have now within an if block, it's simpler just do the check up front and return and that makes it easier to follow:\r\n\r\nif (chargedPrincipals.isEmpty()) {\r\n  return;\r\n}\r\n\r\n// continue with the rest of the method\r\n\r\nfinal String caller = \"updatePrincipalByStateFromAuthority\";\r\nList<Principal> updatedUsers = new ArrayList<>();\r\n...", "bodyText": "this should be within the if block so we're not wasting create the listing if there is nothing to do. or better yet in order not to have the whole function as we have now within an if block, it's simpler just do the check up front and return and that makes it easier to follow:\nif (chargedPrincipals.isEmpty()) {\nreturn;\n}\n// continue with the rest of the method\nfinal String caller = \"updatePrincipalByStateFromAuthority\";\nList updatedUsers = new ArrayList<>();\n...", "bodyHTML": "<p dir=\"auto\">this should be within the if block so we're not wasting create the listing if there is nothing to do. or better yet in order not to have the whole function as we have now within an if block, it's simpler just do the check up front and return and that makes it easier to follow:</p>\n<p dir=\"auto\">if (chargedPrincipals.isEmpty()) {<br>\nreturn;<br>\n}</p>\n<p dir=\"auto\">// continue with the rest of the method</p>\n<p dir=\"auto\">final String caller = \"updatePrincipalByStateFromAuthority\";<br>\nList updatedUsers = new ArrayList&lt;&gt;();<br>\n...</p>", "author": "havetisyan", "createdAt": "2020-10-23T16:32:46Z", "path": "servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java", "diffHunk": "@@ -6402,6 +6403,147 @@ void enforceGroupUserAuthorityRestrictions(final String domainName, final String\n         }\n     }\n \n+    /**\n+     * This method returns list of Principals based on the state parameter supplied\n+     * @param queriedState state of principal\n+     * @return List of Principals from DB\n+     */\n+    List<Principal> getPrincipals(int queriedState) {\n+        List<Principal> principals = new ArrayList<>();\n+        Principal principal;\n+        try (ObjectStoreConnection con = store.getConnection(true, false)) {\n+           List<String> dbPrincipals = con.getPrincipals(queriedState);\n+            Principal.State principalState = Principal.State.getState(queriedState);\n+           for (String dbPrincipal : dbPrincipals) {\n+               principal = ZMSUtils.createPrincipalForName(dbPrincipal, zmsConfig.getUserDomain(), null);\n+               ((SimplePrincipal) principal).setState(principalState);\n+               principals.add(principal);\n+           }\n+        }\n+        return principals;\n+    }\n+\n+    /**\n+     * This method toggles state for supplied Principals based on the flag in DB\n+     * as well as modifies memberships of all roles and groups of current principal(s)\n+     * @param changedPrincipals List of Principals from User Authority\n+     * @param suspended boolean indicating principal's state\n+     */\n+    void updatePrincipalByStateFromAuthority(List<Principal> changedPrincipals, boolean suspended) {\n+        final String caller = \"updatePrincipalByStateFromAuthority\";\n+        List<Principal> updatedUsers = new ArrayList<>();", "originalCommit": "f2b6979e4235f325d7eea75d6f63d358c03d8d3c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0dff4be75160c89e9e35b4634db11456460fa25f", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 2d11e7268..08f2ee72e 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6430,28 +6430,48 @@ public class DBService implements RolesProvider {\n      * @param suspended boolean indicating principal's state\n      */\n     void updatePrincipalByStateFromAuthority(List<Principal> changedPrincipals, boolean suspended) {\n+\n+        if (changedPrincipals.isEmpty()) {\n+            return;\n+        }\n+\n         final String caller = \"updatePrincipalByStateFromAuthority\";\n         List<Principal> updatedUsers = new ArrayList<>();\n-        if (!changedPrincipals.isEmpty()) {\n-            try (ObjectStoreConnection con = store.getConnection(true, true)) {\n+        int newPrincipalState = suspended ? Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() : Principal.State.ACTIVE.getValue();\n+        try (ObjectStoreConnection con = store.getConnection(true, true)) {\n \n-                // first lets update the new state in DB\n-                for (Principal changedPrincipal : changedPrincipals) {\n-                    updatePrincipalState(suspended, updatedUsers, con, changedPrincipal);\n-                }\n-                // if new state is updated successfully\n-                // then we need to modify all roles and groups where given principal is member of\n-                if (!updatedUsers.isEmpty()) {\n-                    for (Principal updatedUser : updatedUsers) {\n-                        try {\n-                            updateRoleMembershipsByPrincipalState(suspended, caller, con, updatedUser);\n-                            updateGroupMembershipByPrincipalState(suspended, caller, con, updatedUser);\n-                        } catch (ResourceException ex) {\n-                            if (ex.getCode() == ResourceException.NOT_FOUND) {\n-                                continue;\n-                            }\n-                            throw ex;\n+            // first lets update the new state in DB\n+            for (Principal changedPrincipal : changedPrincipals) {\n+                try {\n+                    if (con.updatePrincipal(changedPrincipal.getFullName(), newPrincipalState)) {\n+                        updatedUsers.add(changedPrincipal);\n+                    }\n+                } catch (ResourceException ex) {\n+                    // log the exception and continue with remaining principals\n+                    LOG.error(\"Exception in updating principal state from Authority {} Moving on.\", ex.getMessage());\n+                }\n+            }\n+            // if new state is updated successfully\n+            // then we need to modify all roles and groups where given principal is member of\n+            if (!updatedUsers.isEmpty()) {\n+                for (Principal updatedUser : updatedUsers) {\n+                    // separate try blocks to treat group and role membership 404s separately\n+                    try {\n+                        updateRoleMembershipsByPrincipalState(suspended, caller, con, updatedUser);\n+                    } catch (ResourceException ex) {\n+                        if (ex.getCode() == ResourceException.NOT_FOUND) {\n+                            continue;\n+                        }\n+                        throw ex;\n+                    }\n+                    // separate try blocks to treat group and role membership 404s separately\n+                    try {\n+                        updateGroupMembershipByPrincipalState(suspended, caller, con, updatedUser);\n+                    } catch (ResourceException ex) {\n+                        if (ex.getCode() == ResourceException.NOT_FOUND) {\n+                            continue;\n                         }\n+                        throw ex;\n                     }\n                 }\n             }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 2d11e7268..08f2ee72e 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6430,28 +6430,48 @@ public class DBService implements RolesProvider {\n      * @param suspended boolean indicating principal's state\n      */\n     void updatePrincipalByStateFromAuthority(List<Principal> changedPrincipals, boolean suspended) {\n+\n+        if (changedPrincipals.isEmpty()) {\n+            return;\n+        }\n+\n         final String caller = \"updatePrincipalByStateFromAuthority\";\n         List<Principal> updatedUsers = new ArrayList<>();\n-        if (!changedPrincipals.isEmpty()) {\n-            try (ObjectStoreConnection con = store.getConnection(true, true)) {\n+        int newPrincipalState = suspended ? Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() : Principal.State.ACTIVE.getValue();\n+        try (ObjectStoreConnection con = store.getConnection(true, true)) {\n \n-                // first lets update the new state in DB\n-                for (Principal changedPrincipal : changedPrincipals) {\n-                    updatePrincipalState(suspended, updatedUsers, con, changedPrincipal);\n-                }\n-                // if new state is updated successfully\n-                // then we need to modify all roles and groups where given principal is member of\n-                if (!updatedUsers.isEmpty()) {\n-                    for (Principal updatedUser : updatedUsers) {\n-                        try {\n-                            updateRoleMembershipsByPrincipalState(suspended, caller, con, updatedUser);\n-                            updateGroupMembershipByPrincipalState(suspended, caller, con, updatedUser);\n-                        } catch (ResourceException ex) {\n-                            if (ex.getCode() == ResourceException.NOT_FOUND) {\n-                                continue;\n-                            }\n-                            throw ex;\n+            // first lets update the new state in DB\n+            for (Principal changedPrincipal : changedPrincipals) {\n+                try {\n+                    if (con.updatePrincipal(changedPrincipal.getFullName(), newPrincipalState)) {\n+                        updatedUsers.add(changedPrincipal);\n+                    }\n+                } catch (ResourceException ex) {\n+                    // log the exception and continue with remaining principals\n+                    LOG.error(\"Exception in updating principal state from Authority {} Moving on.\", ex.getMessage());\n+                }\n+            }\n+            // if new state is updated successfully\n+            // then we need to modify all roles and groups where given principal is member of\n+            if (!updatedUsers.isEmpty()) {\n+                for (Principal updatedUser : updatedUsers) {\n+                    // separate try blocks to treat group and role membership 404s separately\n+                    try {\n+                        updateRoleMembershipsByPrincipalState(suspended, caller, con, updatedUser);\n+                    } catch (ResourceException ex) {\n+                        if (ex.getCode() == ResourceException.NOT_FOUND) {\n+                            continue;\n+                        }\n+                        throw ex;\n+                    }\n+                    // separate try blocks to treat group and role membership 404s separately\n+                    try {\n+                        updateGroupMembershipByPrincipalState(suspended, caller, con, updatedUser);\n+                    } catch (ResourceException ex) {\n+                        if (ex.getCode() == ResourceException.NOT_FOUND) {\n+                            continue;\n                         }\n+                        throw ex;\n                     }\n                 }\n             }\n", "next_change": {"commit": "934fc3d7fc859731f4beab3b03b83a15ac717a2d", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 08f2ee72e..519c44bf5 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6478,22 +6890,271 @@ public class DBService implements RolesProvider {\n         }\n     }\n \n+    void executePutAssertionConditions(ResourceContext ctx, String domainName, String policyName, long assertionId,\n+                                       AssertionConditions assertionConditions, String auditRef, String caller) {\n+\n+        // our exception handling code does the check for retry count\n+        // and throws the exception it had received when the retry\n+        // count reaches 0\n+\n+        for (int retryCount = defaultRetryCount; ; retryCount--) {\n+\n+            try (ObjectStoreConnection con = store.getConnection(false, true)) {\n+\n+                // first verify that auditing requirements are met\n+\n+                checkDomainAuditEnabled(con, domainName, auditRef, caller, getPrincipalName(ctx), AUDIT_TYPE_POLICY);\n+\n+                // now we need verify our quota check\n+\n+                quotaCheck.checkAssertionConditionsQuota(con, assertionId, assertionConditions, caller);\n+\n+                // process our insert assertion condition.\n+\n+                if (!con.insertAssertionConditions(assertionId, assertionConditions)) {\n+                    throw ZMSUtils.requestError(String.format(\"%s: unable to insert assertion conditions for policy=%s assertionId=%d\", caller, policyName, assertionId), caller);\n+                }\n+\n+                // update our policy and domain time-stamps, and invalidate local cache entry\n+\n+                saveChanges(con, domainName);\n+                con.updatePolicyModTimestamp(domainName, policyName);\n+\n+                // audit log the request\n+                StringBuilder auditDetails = new StringBuilder(ZMSConsts.STRING_BLDR_SIZE_DEFAULT);\n+                auditDetails.append(\"{\\\"policy\\\": \\\"\").append(policyName)\n+                        .append(\"\\\", \\\"assertionId\\\": \").append(assertionId)\n+                        .append(\", \");\n+                auditLogAssertionConditions(auditDetails, assertionConditions.getConditionsList(), \"new-assertion-conditions\");\n+                auditDetails.append(\"}\");\n+\n+                auditLogRequest(ctx, domainName, auditRef, caller, ZMSConsts.HTTP_PUT,\n+                        policyName, auditDetails.toString());\n+\n+                return;\n+\n+            } catch (ResourceException ex) {\n+\n+                // otherwise check if we need to retry or return failure\n+                if (!shouldRetryOperation(ex, retryCount)) {\n+                    throw ex;\n+                }\n+            }\n+        }\n+    }\n+\n+    void executePutAssertionCondition(ResourceContext ctx, String domainName, String policyName, long assertionId,\n+                                      AssertionCondition assertionCondition, String auditRef, String caller) {\n+\n+        // our exception handling code does the check for retry count\n+        // and throws the exception it had received when the retry\n+        // count reaches 0\n+\n+        for (int retryCount = defaultRetryCount; ; retryCount--) {\n+\n+            try (ObjectStoreConnection con = store.getConnection(false, true)) {\n+\n+                // first verify that auditing requirements are met\n+\n+                checkDomainAuditEnabled(con, domainName, auditRef, caller, getPrincipalName(ctx), AUDIT_TYPE_POLICY);\n+\n+                // process our insert assertion condition.\n+\n+                if (assertionCondition.getId() == null) {\n+\n+                    // now we need verify our quota check\n+                    quotaCheck.checkAssertionConditionQuota(con, assertionId, assertionCondition, caller);\n+\n+                    // no condition id in the request. so we are going to generate the next condition id for\n+                    // the given assertion id and then use it to insert given keys\n+                    assertionCondition.setId(con.getNextConditionId(assertionId, caller));\n+                    if (!con.insertAssertionCondition(assertionId, assertionCondition)) {\n+                        throw ZMSUtils.requestError(String.format(\"%s: unable to insert new assertion condition for policy=%s assertionId=%d\", caller, policyName, assertionId), caller);\n+                    }\n+                } else {\n+\n+                    // existing assertion condition keys found with given condition id. so delete existing keys from DB for the given condition id\n+                    if (!con.deleteAssertionCondition(assertionId, assertionCondition.getId())) {\n+                        throw ZMSUtils.notFoundError(String.format(\"%s: unable to delete assertion condition during putAssertionCondition for policy=%s assertionId=%d conditionId=%d\"\n+                                , caller, policyName, assertionId, assertionCondition.getId()), caller);\n+                    }\n+                    // now we need verify our quota check after deleting the old entries\n+                    quotaCheck.checkAssertionConditionQuota(con, assertionId, assertionCondition, caller);\n+\n+                    // now insert the new keys against existing condition id\n+                    if (!con.insertAssertionCondition(assertionId, assertionCondition)) {\n+                        throw ZMSUtils.requestError(String.format(\"%s: unable to insert assertion condition for policy=%s assertionId=%d\", caller, policyName, assertionId), caller);\n+                    }\n+                }\n+\n+                // update our policy and domain time-stamps, and invalidate local cache entry\n+\n+                saveChanges(con, domainName);\n+                con.updatePolicyModTimestamp(domainName, policyName);\n+\n+                // audit log the request\n+                StringBuilder auditDetails = new StringBuilder(ZMSConsts.STRING_BLDR_SIZE_DEFAULT);\n+                auditDetails.append(\"{\\\"policy\\\": \\\"\").append(policyName)\n+                        .append(\"\\\", \\\"assertionId\\\": \").append(assertionId)\n+                        .append(\", \\\"new-assertion-condition\\\": \");\n+                auditLogAssertionCondition(auditDetails, assertionCondition, true);\n+                auditDetails.append(\"}\");\n+\n+                auditLogRequest(ctx, domainName, auditRef, caller, ZMSConsts.HTTP_PUT,\n+                        policyName, auditDetails.toString());\n+\n+                return;\n+\n+            } catch (ResourceException ex) {\n+\n+                // otherwise check if we need to retry or return failure\n+                if (!shouldRetryOperation(ex, retryCount)) {\n+                    throw ex;\n+                }\n+            }\n+        }\n+    }\n+\n+    public void executeDeleteAssertionConditions(ResourceContext ctx, String domainName, String policyName, Long assertionId, String auditRef, String caller) {\n+\n+        // our exception handling code does the check for retry count\n+        // and throws the exception it had received when the retry\n+        // count reaches 0\n+\n+        for (int retryCount = defaultRetryCount; ; retryCount--) {\n+\n+            try (ObjectStoreConnection con = store.getConnection(true, true)) {\n+\n+                // first verify that auditing requirements are met\n+\n+                checkDomainAuditEnabled(con, domainName, auditRef, caller, getPrincipalName(ctx), AUDIT_TYPE_POLICY);\n+\n+                // fetch the assertion for our audit log\n+\n+                List<AssertionCondition> assertionConditions = con.getAssertionConditions(assertionId);\n+                if (assertionConditions == null) {\n+                    throw ZMSUtils.notFoundError(String.format(\"%s: unable to read assertion conditions for policy=%s assertionId=%d\", caller,\n+                            policyName, assertionId), caller);\n+                }\n+\n+                // process our delete assertion conditions. since this is a \"single\"\n+                // operation, we are not using any transactions.\n+\n+                if (!con.deleteAssertionConditions(assertionId)) {\n+                    throw ZMSUtils.notFoundError(String.format(\"%s: unable to delete assertion conditions for policy=%s assertionId=%d\", caller,\n+                            policyName, assertionId), caller);\n+                }\n+\n+                // update our policy and domain time-stamps, and invalidate local cache entry\n+\n+                con.updatePolicyModTimestamp(domainName, policyName);\n+                con.updateDomainModTimestamp(domainName);\n+                cacheStore.invalidate(domainName);\n+\n+                // audit log the request\n+\n+                StringBuilder auditDetails = new StringBuilder(ZMSConsts.STRING_BLDR_SIZE_DEFAULT);\n+                auditDetails.append(\"{\\\"policy\\\": \\\"\").append(policyName)\n+                        .append(\"\\\", \\\"assertionId\\\": \").append(assertionId)\n+                        .append(\", \");\n+                auditLogAssertionConditions(auditDetails, assertionConditions, \"deleted-assertion-conditions\");\n+                auditDetails.append(\"}\");\n+\n+                auditLogRequest(ctx, domainName, auditRef, caller, ZMSConsts.HTTP_DELETE,\n+                        policyName, auditDetails.toString());\n+\n+                return;\n+\n+            } catch (ResourceException ex) {\n+\n+                // otherwise check if we need to retry or return failure\n+\n+                if (!shouldRetryOperation(ex, retryCount)) {\n+                    throw ex;\n+                }\n+            }\n+        }\n+    }\n+\n+    public void executeDeleteAssertionCondition(ResourceContext ctx, String domainName, String policyName, Long assertionId, Integer conditionId, String auditRef, String caller) {\n+        // our exception handling code does the check for retry count\n+        // and throws the exception it had received when the retry\n+        // count reaches 0\n+\n+        for (int retryCount = defaultRetryCount; ; retryCount--) {\n+\n+            try (ObjectStoreConnection con = store.getConnection(true, true)) {\n+\n+                // first verify that auditing requirements are met\n+\n+                checkDomainAuditEnabled(con, domainName, auditRef, caller, getPrincipalName(ctx), AUDIT_TYPE_POLICY);\n+\n+                // fetch the assertion for our audit log\n+\n+                AssertionCondition assertionCondition = con.getAssertionCondition(assertionId, conditionId);\n+                if (assertionCondition == null) {\n+                    throw ZMSUtils.notFoundError(String.format(\"%s: unable to read assertion condition for policy=%s assertionId=%d conditionId=%d\"\n+                            , caller, policyName, assertionId, conditionId), caller);\n+                }\n+\n+                // process our delete assertion condition. since this is a \"single\"\n+                // operation, we are not using any transactions.\n+\n+                if (!con.deleteAssertionCondition(assertionId, conditionId)) {\n+                    throw ZMSUtils.notFoundError(String.format(\"%s: unable to delete assertion condition for policy=%s assertionId=%d conditionId=%d\"\n+                            , caller, policyName, assertionId, conditionId), caller);\n+                }\n+\n+                // update our policy and domain time-stamps, and invalidate local cache entry\n+\n+                con.updatePolicyModTimestamp(domainName, policyName);\n+                con.updateDomainModTimestamp(domainName);\n+                cacheStore.invalidate(domainName);\n+\n+                // audit log the request\n+\n+                StringBuilder auditDetails = new StringBuilder(ZMSConsts.STRING_BLDR_SIZE_DEFAULT);\n+                auditDetails.append(\"{\\\"policy\\\": \\\"\").append(policyName)\n+                        .append(\"\\\", \\\"assertionId\\\": \").append(assertionId)\n+                        .append(\", \\\"deleted-assertion-condition\\\": \");\n+                auditLogAssertionCondition(auditDetails, assertionCondition, true);\n+                auditDetails.append(\"}\");\n+\n+                auditLogRequest(ctx, domainName, auditRef, caller, ZMSConsts.HTTP_DELETE,\n+                        policyName, auditDetails.toString());\n+\n+                return;\n+\n+            } catch (ResourceException ex) {\n+\n+                // otherwise check if we need to retry or return failure\n+\n+                if (!shouldRetryOperation(ex, retryCount)) {\n+                    throw ex;\n+                }\n+            }\n+        }\n+    }\n+\n     private void updateGroupMembershipByPrincipalState(boolean suspended, String caller, ObjectStoreConnection con, Principal updatedUser) {\n         List<GroupMember> groupMembersWithUpdatedState;\n         GroupMember groupMember;\n         DomainGroupMember domainGroupMember;\n-        int newState;\n+        int newState, oldState;\n         Set<String> updatedDomains = new HashSet<>();\n         domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n         if (!domainGroupMember.getMemberGroups().isEmpty()) {\n             for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n                 groupMember = new GroupMember();\n                 groupMember.setMemberName(updatedUser.getFullName());\n-                newState = suspended ? currentGroup.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n-                        currentGroup.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n+                oldState = 0;\n+                if (groupMember.getSystemDisabled() != null) {\n+                    oldState = groupMember.getSystemDisabled();\n+                }\n+                newState = suspended ? oldState | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n+                        oldState & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n                 groupMember.setSystemDisabled(newState);\n                 groupMembersWithUpdatedState = Collections.singletonList(groupMember);\n-\n                 // Following method does Audit entry as well\n                 if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n                         currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "message": "Merge commit", "committedDate": null}, {"oid": "9a9c82c13d156e06dad8464c3a6c52c8e2bc6b89", "committedDate": "2020-10-26 14:15:03 -0700", "message": "remove sending back deprected members field in roles (#1160)"}, {"oid": "31a0dd7362f585f85992d4ff86fbf975d9d736dd", "committedDate": "2020-10-31 14:59:07 -0700", "message": "add azure_subscription field to domains (#1167)"}, {"oid": "c668f48cec94e2c928581b92ffb517f715a4840f", "committedDate": "2020-11-06 18:05:10 -0800", "message": "handle sys disabled null scenario (#1176)"}, {"oid": "f24d15baaaddc96c85fbceb31fcaded756a69f2e", "committedDate": "2020-11-14 16:51:57 -0800", "message": "role tags - generated code and schema changes (#1179)"}, {"oid": "30e272d8a9ec2649a1d876c1c111cf38e27c1743", "committedDate": "2020-12-07 08:48:58 -0800", "message": "putRoleMeta tags support (#1208)"}, {"oid": "f0e0a91b80250236244db9f8cba79e1def809995", "committedDate": "2020-12-23 15:40:53 -0800", "message": "updating group expiry date (#1221)"}, {"oid": "7a2837c7578ab8d36c62b48ecb1d0079c670616b", "committedDate": "2020-12-29 13:44:04 -0800", "message": "granular authz action for managing role members (#1228)"}, {"oid": "d6a0d659fe96486ffcf31bb93e919656be9eaf89", "committedDate": "2021-01-13 08:15:47 -0800", "message": "domain tags implementation (#1235)"}, {"oid": "3c939966592bf7cc6ff25df12a8d21d4c2c89b2b", "committedDate": "2021-01-19 22:05:22 -0800", "message": "client api update for rich authorization requests and consistent naming of entity objects (#1248)"}, {"oid": "3db6ed7b169fce5bbeaa1fae84ff7881e9a4e435", "committedDate": "2021-01-21 09:17:41 -0800", "message": "limit number of role and domain tags (#1255)"}, {"oid": "218b71958d88fb039dfa6e7c5448c7e4d00cb337", "committedDate": "2021-01-25 17:53:41 -0800", "message": "update domain last modified timestamp after tag update (#1262)"}, {"oid": "bccc5fb4dc1c2407a0293f322c3d97711af4297c", "committedDate": "2021-03-07 18:11:58 -0800", "message": "sonarcloud: method always returns same result (#1329)"}, {"oid": "e421f20094d24075d2cec7ab7adecff7d630a286", "committedDate": "2021-03-16 18:08:03 -0700", "message": "expose new domain attribute: business-service (#1357)"}, {"oid": "7b4afd5d40394226b3aa1af8bf10e90e528091b3", "committedDate": "2021-04-01 14:52:30 -0700", "message": "Add memberExpiryDays and serviceExpiryDays support for groups (#1388)"}, {"oid": "5ab30978cc4fc03e1b3022305f6e14a5a425e9e9", "committedDate": "2021-04-07 16:30:50 -0700", "message": "new DomainMetaStore interface support in ZMS (#1430)"}, {"oid": "9bedde4310d6493406d264422f23e16f33213546", "committedDate": "2021-04-08 09:44:29 -0700", "message": "Add group review days to role (#1428)"}, {"oid": "a554c75c51c5945b0e58ae87866de93ff1d5cfbc", "committedDate": "2021-04-15 12:12:02 -0700", "message": "during provider admin setup, ignore deletes (#1444)"}, {"oid": "1c564548381b3c09ad4214d0f30c667e9cc0d022", "committedDate": "2021-04-30 15:22:51 -0700", "message": "log full policy assertion details during delete operations in audit log (#1469)"}, {"oid": "611ac334bfbc1c43ec20154cf9448b96fae365d6", "committedDate": "2021-05-27 16:30:38 -0700", "message": "handle null contition processDomainTags (#1495)"}, {"oid": "addf4424a5bf842b58558c6f61ac0b46277d9535", "committedDate": "2021-06-07 09:38:12 -0700", "message": "allow role/group review regardless of role/group expiry/reminder settings (#1503)"}, {"oid": "4b39ffbd18da3d10a581fb10209806c97b432d28", "committedDate": "2021-06-09 15:31:17 -0700", "message": "enable role review without setting restrictions (#1512)"}, {"oid": "898ff0aa4fddd1a9ed111496cb9e4acb544605af", "committedDate": "2021-06-14 10:42:10 -0700", "message": "Update Tag Values to include '/', ':' (#1517)"}, {"oid": "cf535673b0a4cbcdc81e17c7def4cb6822edd78c", "committedDate": "2021-06-22 06:44:42 -0700", "message": "Allow system admins to set domain meta attribute business service (#1522)"}, {"oid": "934fc3d7fc859731f4beab3b03b83a15ac717a2d", "committedDate": "2021-06-29 12:57:53 -0700", "message": "assertion condition server changes (#1528)"}, {"oid": "1fa51b852890c1576254be6a8a2b5dbebc89865c", "committedDate": "2021-07-21 14:41:19 -0700", "message": "UI : update error message (#1557)"}, {"oid": "09de45bb794eb5e7c29f705b5ce567c75fde4e84", "committedDate": "2021-07-29 15:49:16 -0700", "message": "multi-version policy - introducing version/active in policy object (#1568)"}, {"oid": "4abff4b9952e4836f79bf3f1934baf8fe2bcebf9", "committedDate": "2021-08-08 11:39:07 -0700", "message": "Disable Reminder Review Notifications By Tag zms.DisableReminderNotifications (#1579)"}, {"oid": "6a1523accc3ec83fe54d78c3d919d9cddbcb1b7e", "committedDate": "2021-08-17 18:32:28 -0700", "message": "fixing the order of updates for assertion condition api operations (#1591)"}, {"oid": "66590f4fc47f899f3990f20895f953074e40f259", "committedDate": "2021-09-10 07:55:42 -0700", "message": "Implement multi-version policies endpoints (#1605)"}, {"oid": "1ad624427917493d31bd1b8ffa6303c4d6353055", "committedDate": "2021-09-10 13:51:19 -0700", "message": "update group last modified when user is deleted (#1613)"}, {"oid": "91b116418656f123dae9a3405cb2e498d4d3aff4", "committedDate": "2021-09-12 09:52:05 +0300", "message": "additional validation checks when processing versioned policies (#1614)"}, {"oid": "2531428956f87774f86721f02b430861ca8897ec", "committedDate": "2021-09-14 09:49:34 +0300", "message": "additional checks when setting a policy version as active (#1615)"}, {"oid": "2968c209e870ce57fbdb1fb048a21692d80cfea6", "committedDate": "2021-10-01 07:25:34 -0700", "message": "rdl publishChangeEvents generator (#1624)"}, {"oid": "8a6960ce9878277c5abda1d104ca070831b36230", "committedDate": "2021-10-03 13:48:03 -0700", "message": "Allow specifying version name when creating new policy (#1630)"}, {"oid": "43f619b31bbd9cc3d388aa7ea29eff889cb1272d", "committedDate": "2021-10-21 08:48:51 -0700", "message": "For role expiry notification - record metrics daily while (#1654)"}, {"oid": "389f984270d7d89070c66096e87fafbcb24a261c", "committedDate": "2021-10-26 08:17:36 -0700", "message": "Group tags implementation (#1660)"}, {"oid": "120ab1fa8e9d33fa793c4254d233a09a2c23d173", "committedDate": "2021-10-29 15:08:28 -0700", "message": "Disable Group Expiry Notifications By Tag zms.DisableReminderNotifications (#1663)"}, {"oid": "1400363e8d698cf08370c89752077ebae043c5be", "committedDate": "2021-12-14 13:48:34 -0800", "message": "correct logging of role principal in audit/access logs"}, {"oid": "c8e3a5c91c5deb9640576cd3496a2af11d572f0b", "committedDate": "2021-12-23 15:03:25 -0800", "message": "protect system admin users from being removed from deleteUser api (#1715)"}, {"oid": "020e06e57b357768260f509f08b75c5c068bce53", "committedDate": "2022-02-07 08:01:55 -0800", "message": "Service Visiblity - Domain Dependencies (#1758)"}, {"oid": "fcbd4128e334a9a42f4579d179cf9578d3f4de99", "committedDate": "2022-02-07 10:12:47 -0800", "message": "support new get-stats endpoint to get per-domain/system stats (#1774)"}, {"oid": "ea831a34a70a0475bea8754cb183741dced98ff2", "committedDate": "2022-02-18 09:17:55 -0800", "message": "update pending member api to support getting list for a domain (#1783)"}, {"oid": "f4229124e8e1898810c7aa7b3a4eff37fddae308", "committedDate": "2022-02-18 12:37:32 -0800", "message": "provide option to skip adding principal when onboarding a resource group (#1787)"}, {"oid": "9081feb4c06a1058c941c67923037203d9318cfa", "committedDate": "2022-02-27 14:10:46 -0800", "message": "Domain Dependency for Tenancy (#1789)"}, {"oid": "a5bb615881583fa6f39621e2ea3bf39d3886340b", "committedDate": "2022-03-03 17:20:00 -0800", "message": "extend template keyword support trust field in roles (#1803)"}, {"oid": "3de182bcbedba89fa2aaba12ab9be49aa2156096", "committedDate": "2022-03-19 09:45:40 -0700", "message": "Add provider webhook for verifying removal (#1816)"}, {"oid": "1b0cff1cb9b8e4a231c5cfb342d76b6aad8e08fc", "committedDate": "2022-04-07 14:34:23 -0700", "message": "no need to update domain's last mod timestamp during put dependency call (#1846)"}, {"oid": "baa68eacd6a6b9bbc70c3423006f92cd47b784d7", "committedDate": "2022-05-19 09:30:02 -0700", "message": "Get Auth History implementation (#1875)"}, {"oid": "bea97b165e28b5b2cc286af62c92e536c9fc3ff2", "committedDate": "2022-06-03 13:50:01 -0700", "message": "AuthHistory - Return dependencies instead of list (#1888)"}, {"oid": "7a313e1d581295ae6c786bbc2ed73bb14da37f7d", "committedDate": "2022-07-21 20:16:24 -0700", "message": "allow management of domain memberPurgeExpiryDays setting value (#1928)"}, {"oid": "f288ed7afb018bc07af02dbe9dc8e05ec0896071", "committedDate": "2022-08-15 22:28:01 -0700", "message": "provide header option to return updated object in response (#1942)"}, {"oid": "949bd0634d328d04736b912a002bdfa7421d9f2b", "committedDate": "2022-08-23 10:28:38 -0700", "message": "fix returning role/group objects when requested by ui (#1945)"}, {"oid": "ab7284c9274f4949d23f88ec0dde7b689c0c6980", "committedDate": "2022-09-05 13:12:17 -0700", "message": "auto purge expired role/group members based on server/domain config (#1941)"}, {"oid": "4ab6e748891a014a8b0a1364de099d3fbf4c7468", "committedDate": "2022-09-21 22:22:48 -0700", "message": "enable readWrite db connection for delete expired members (#1964)"}, {"oid": "d4c733d3e97467a598ba44f0bde5c6a907aa01de", "committedDate": "2022-09-23 13:30:24 -0700", "message": "consistent use of The Athenz Authors copyright in all files (#1967)"}, {"oid": "45dcdab92d9e39d5d561b34ef222f863176cc635", "committedDate": "2022-09-26 12:29:01 -0700", "message": "make server purge expiry member day configurable (#1968)"}, {"oid": "d823cccb5163f950655f3859ade41fe031910588", "committedDate": "2022-10-06 14:20:20 -0700", "message": "fix putServiceIdentity logic to allow update of exising pubKey (#1978)"}, {"oid": "91d38ef548e59e29e69349b8a0f5151456b62a0f", "committedDate": "2022-10-07 15:36:36 -0700", "message": "Use correct object type for role member delete notifications (#1981)"}, {"oid": "1d970ce72c2f81aed5576fff068103bbba022aaf", "committedDate": "2022-11-29 23:50:29 +0200", "message": "add gcp project attribute for domains (#2005)"}, {"oid": "c292a1a2fb6e3a300a3060a6bcea6a96f696932c", "committedDate": "2022-12-13 08:56:43 -0800", "message": "Return the correct response from putMembership/putGroupMembership once a pending member was added (#2023)"}, {"oid": "fc5a206d1cb23dd2bbfd9af7e3125ec270ebc022", "committedDate": "2023-01-10 21:48:12 -0800", "message": "allow domain admins to enable audit flag for new roles/groups (#2032)"}, {"oid": "70850ab1de4055e765cf4ead6946b431900ff8c8", "committedDate": "2023-01-23 16:40:36 -0800", "message": "move cloud provider role generation logic out of dbstore library to dbservice (#2043)"}, {"oid": "0ff7ff4f9658fd42e8ee2161d870a89dce5167e4", "committedDate": "2023-02-02 09:18:32 -0800", "message": "Add a requirement for admin approval to delete members in review-enabled roles (#2053)"}, {"oid": "ff57628b890f53c43fec6dd2cacf98a574c95b2d", "committedDate": "2023-02-08 15:55:32 -0800", "message": "extends group with deleteProtection attribute and pending group membe\u2026 (#2067)"}, {"oid": "bb1d69af70a90aeedc28a46604283064e0dad8de", "committedDate": "2023-02-16 07:44:40 -0800", "message": "add audit enable to role (#2055)"}, {"oid": "4ee14d784973ce7da8aba96b35eefdbc5d61d97b", "committedDate": "2023-03-07 11:34:04 -0800", "message": "make aws/gcp assume role action values configurable (#2090)"}, {"oid": "5216da47ef8bca89ba0eae790f72739d9d73fcc6", "committedDate": "2023-03-09 10:36:29 -0800", "message": "Add optional 'description' to role (#2091)"}, {"oid": "d1b98d4614d62fe34b408cfa1a26fb59674d6494", "committedDate": "2023-03-27 16:46:33 -0700", "message": "store GCP project number along with project id in athenz domain metadata (#2113)"}, {"oid": "715cf96c679e817600a0a25160c96878e5eda735", "committedDate": "2023-03-27 18:01:33 -0700", "message": "special resource for gcp starting with service/ (#2115)"}, {"oid": "6e7342a1e98207b87e3eae45341db281b7b3b9c7", "committedDate": "2023-04-13 14:30:39 -0700", "message": "designate separate action for assertions when assuming gcp service accounts (#2127)"}, {"oid": "523f7f753fa2a4a112ae4fb7a5389203af8b9594", "committedDate": "2023-05-29 08:52:21 -0700", "message": "fix role update on expiration and review dates (#2185)"}, {"oid": "7069bf871635c4e5308d37341904241388b1ccda", "committedDate": "2023-05-30 15:31:26 -0700", "message": "support product id (string) format association with domains (#2193)"}, {"oid": "368d0bc139931c03d31824c4f02394b38e3ead95", "committedDate": "2023-06-02 13:15:05 -0700", "message": "support headless user type - managed by user authority but treated like service (#2197)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAwNzEzNw==", "url": "https://github.com/AthenZ/athenz/pull/1157#discussion_r511007137", "body": "need to update this command to use the name field instead of principal_id", "bodyText": "need to update this command to use the name field instead of principal_id", "bodyHTML": "<p dir=\"auto\">need to update this command to use the name field instead of principal_id</p>", "author": "havetisyan", "createdAt": "2020-10-23T16:39:18Z", "path": "servers/zms/src/main/java/com/yahoo/athenz/zms/store/jdbc/JDBCConnection.java", "diffHunk": "@@ -479,6 +479,8 @@\n             + \"JOIN principal ON principal.principal_id=principal_group_member.principal_id \"\n             + \"JOIN domain ON domain.domain_id=principal_group.domain_id \"\n             + \"WHERE principal_group_member.last_notified_time=? AND principal_group_member.server=?;\";\n+    private static final String SQL_UPDATE_PRINCIPAL = \"UPDATE principal SET system_suspended=? WHERE principal_id=?;\";", "originalCommit": "f2b6979e4235f325d7eea75d6f63d358c03d8d3c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0dff4be75160c89e9e35b4634db11456460fa25f", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/store/jdbc/JDBCConnection.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/store/jdbc/JDBCConnection.java\nindex 40fa3473f..793fa4fad 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/store/jdbc/JDBCConnection.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/store/jdbc/JDBCConnection.java\n", "chunk": "@@ -479,7 +479,7 @@ public class JDBCConnection implements ObjectStoreConnection {\n             + \"JOIN principal ON principal.principal_id=principal_group_member.principal_id \"\n             + \"JOIN domain ON domain.domain_id=principal_group.domain_id \"\n             + \"WHERE principal_group_member.last_notified_time=? AND principal_group_member.server=?;\";\n-    private static final String SQL_UPDATE_PRINCIPAL = \"UPDATE principal SET system_suspended=? WHERE principal_id=?;\";\n+    private static final String SQL_UPDATE_PRINCIPAL = \"UPDATE principal SET system_suspended=? WHERE name=?;\";\n     private static final String SQL_GET_PRINCIPAL = \"SELECT name FROM principal WHERE system_suspended=?;\";\n \n     private static final String CACHE_DOMAIN    = \"d:\";\n", "next_change": null}]}, "revised_code_in_main": {"commit": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/store/jdbc/JDBCConnection.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/store/jdbc/JDBCConnection.java\nindex 40fa3473f..793fa4fad 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/store/jdbc/JDBCConnection.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/store/jdbc/JDBCConnection.java\n", "chunk": "@@ -479,7 +479,7 @@ public class JDBCConnection implements ObjectStoreConnection {\n             + \"JOIN principal ON principal.principal_id=principal_group_member.principal_id \"\n             + \"JOIN domain ON domain.domain_id=principal_group.domain_id \"\n             + \"WHERE principal_group_member.last_notified_time=? AND principal_group_member.server=?;\";\n-    private static final String SQL_UPDATE_PRINCIPAL = \"UPDATE principal SET system_suspended=? WHERE principal_id=?;\";\n+    private static final String SQL_UPDATE_PRINCIPAL = \"UPDATE principal SET system_suspended=? WHERE name=?;\";\n     private static final String SQL_GET_PRINCIPAL = \"SELECT name FROM principal WHERE system_suspended=?;\";\n \n     private static final String CACHE_DOMAIN    = \"d:\";\n", "next_change": null}]}, "commits_in_main": [{"oid": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "message": "Merge commit", "committedDate": null}, {"oid": "486ed4542fb4fc70ba0c3d8cb26a198c1f001f60", "committedDate": "2020-10-30 14:10:06 -0700", "message": "If both expration and review dates are set, start sending (#1166)"}, {"oid": "31a0dd7362f585f85992d4ff86fbf975d9d736dd", "committedDate": "2020-10-31 14:59:07 -0700", "message": "add azure_subscription field to domains (#1167)"}, {"oid": "b005cb0209503f3a89e10b43d9ecb0997472e335", "committedDate": "2020-11-01 10:37:27 -0800", "message": "archive file connection store (#1170)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxMTYyNg==", "url": "https://github.com/AthenZ/athenz/pull/1157#discussion_r511011626", "body": "no need to create an array list with one member all the time. Instead use Collections.singletonList()", "bodyText": "no need to create an array list with one member all the time. Instead use Collections.singletonList()", "bodyHTML": "<p dir=\"auto\">no need to create an array list with one member all the time. Instead use Collections.singletonList()</p>", "author": "havetisyan", "createdAt": "2020-10-23T16:47:24Z", "path": "servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java", "diffHunk": "@@ -6402,6 +6403,147 @@ void enforceGroupUserAuthorityRestrictions(final String domainName, final String\n         }\n     }\n \n+    /**\n+     * This method returns list of Principals based on the state parameter supplied\n+     * @param queriedState state of principal\n+     * @return List of Principals from DB\n+     */\n+    List<Principal> getPrincipals(int queriedState) {\n+        List<Principal> principals = new ArrayList<>();\n+        Principal principal;\n+        try (ObjectStoreConnection con = store.getConnection(true, false)) {\n+           List<String> dbPrincipals = con.getPrincipals(queriedState);\n+            Principal.State principalState = Principal.State.getState(queriedState);\n+           for (String dbPrincipal : dbPrincipals) {\n+               principal = ZMSUtils.createPrincipalForName(dbPrincipal, zmsConfig.getUserDomain(), null);\n+               ((SimplePrincipal) principal).setState(principalState);\n+               principals.add(principal);\n+           }\n+        }\n+        return principals;\n+    }\n+\n+    /**\n+     * This method toggles state for supplied Principals based on the flag in DB\n+     * as well as modifies memberships of all roles and groups of current principal(s)\n+     * @param changedPrincipals List of Principals from User Authority\n+     * @param suspended boolean indicating principal's state\n+     */\n+    void updatePrincipalByStateFromAuthority(List<Principal> changedPrincipals, boolean suspended) {\n+        final String caller = \"updatePrincipalByStateFromAuthority\";\n+        List<Principal> updatedUsers = new ArrayList<>();\n+        if (!changedPrincipals.isEmpty()) {\n+            try (ObjectStoreConnection con = store.getConnection(true, true)) {\n+\n+                // first lets update the new state in DB\n+                for (Principal changedPrincipal : changedPrincipals) {\n+                    updatePrincipalState(suspended, updatedUsers, con, changedPrincipal);\n+                }\n+                // if new state is updated successfully\n+                // then we need to modify all roles and groups where given principal is member of\n+                if (!updatedUsers.isEmpty()) {\n+                    for (Principal updatedUser : updatedUsers) {\n+                        try {\n+                            updateRoleMembershipsByPrincipalState(suspended, caller, con, updatedUser);\n+                            updateGroupMembershipByPrincipalState(suspended, caller, con, updatedUser);\n+                        } catch (ResourceException ex) {\n+                            if (ex.getCode() == ResourceException.NOT_FOUND) {\n+                                continue;\n+                            }\n+                            throw ex;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void updateGroupMembershipByPrincipalState(boolean suspended, String caller, ObjectStoreConnection con, Principal updatedUser) {\n+        List<GroupMember> groupMembersWithUpdatedState;\n+        GroupMember groupMember;\n+        DomainGroupMember domainGroupMember;\n+        Set<GroupMember> updatedGroups = new HashSet<>();\n+\n+        domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n+        if (!domainGroupMember.getMemberGroups().isEmpty()) {\n+            for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n+                groupMember = new GroupMember();\n+                groupMember.setMemberName(updatedUser.getFullName());\n+                if (suspended) {\n+                    groupMember.setSystemDisabled(currentGroup.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                } else {\n+                    groupMember.setSystemDisabled(currentGroup.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                }\n+                groupMembersWithUpdatedState = new ArrayList<>();\n+                groupMembersWithUpdatedState.add(groupMember);\n+\n+                // Following method does Audit entry as well\n+                if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n+                        currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n+                    updatedGroups.add(currentGroup);\n+                }\n+            }\n+            for (GroupMember updatedGM : updatedGroups) {\n+\n+                // update our group and domain time-stamps, and invalidate local cache entry\n+                con.updateGroupModTimestamp(updatedGM.getDomainName(), updatedGM.getGroupName());\n+                con.updateDomainModTimestamp(updatedGM.getDomainName());\n+                cacheStore.invalidate(updatedGM.getDomainName());\n+            }\n+        }\n+    }\n+\n+    private void updateRoleMembershipsByPrincipalState(boolean suspended, String caller, ObjectStoreConnection con, Principal updatedUser) {\n+        RoleMember roleMember;\n+        List<RoleMember> roleMembersWithUpdatedState;\n+        DomainRoleMember domainRoleMember;\n+        Set<MemberRole> updatedRoles = new HashSet<>();\n+\n+        domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n+        if (!domainRoleMember.getMemberRoles().isEmpty()) {\n+            for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n+                roleMember = new RoleMember();\n+                roleMember.setMemberName(updatedUser.getFullName());\n+                if (suspended) {\n+                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                } else {\n+                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                }\n+                roleMembersWithUpdatedState = new ArrayList<>();", "originalCommit": "f2b6979e4235f325d7eea75d6f63d358c03d8d3c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0dff4be75160c89e9e35b4634db11456460fa25f", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 2d11e7268..08f2ee72e 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6497,50 +6512,29 @@ public class DBService implements RolesProvider {\n         RoleMember roleMember;\n         List<RoleMember> roleMembersWithUpdatedState;\n         DomainRoleMember domainRoleMember;\n-        Set<MemberRole> updatedRoles = new HashSet<>();\n-\n+        int newState;\n+        Set<String> updatedDomains = new HashSet<>();\n         domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n         if (!domainRoleMember.getMemberRoles().isEmpty()) {\n             for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n                 roleMember = new RoleMember();\n                 roleMember.setMemberName(updatedUser.getFullName());\n-                if (suspended) {\n-                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                } else {\n-                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                }\n-                roleMembersWithUpdatedState = new ArrayList<>();\n-                roleMembersWithUpdatedState.add(roleMember);\n+                newState = suspended ? memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n+                        memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n+                roleMember.setSystemDisabled(newState);\n+                roleMembersWithUpdatedState = Collections.singletonList(roleMember);\n \n                 // Following method does Audit entry as well\n                 if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n                         memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-                    updatedRoles.add(memberRole);\n+                    con.updateRoleModTimestamp(memberRole.getDomainName(), memberRole.getRoleName());\n+                    updatedDomains.add(memberRole.getDomainName());\n                 }\n             }\n-            for (MemberRole updatedMR : updatedRoles) {\n-\n-                // update our role and domain time-stamps, and invalidate local cache entry\n-                con.updateRoleModTimestamp(updatedMR.getDomainName(), updatedMR.getRoleName());\n-                con.updateDomainModTimestamp(updatedMR.getDomainName());\n-                cacheStore.invalidate(updatedMR.getDomainName());\n-            }\n-        }\n-    }\n-\n-    private void updatePrincipalState(boolean suspended, List<Principal> updatedUsers, ObjectStoreConnection con, Principal changedPrincipal) {\n-        try {\n-            if (suspended) {\n-                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue())) {\n-                    updatedUsers.add(changedPrincipal);\n-                }\n-            } else {\n-                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.ACTIVE.getValue())) {\n-                    updatedUsers.add(changedPrincipal);\n-                }\n-            }\n-        } catch (ResourceException ex) {\n-            LOG.error(\"Exception in updating principal state from Authority {} Moving on.\", ex.getMessage());\n+            updatedDomains.forEach(dom -> {\n+                con.updateDomainModTimestamp(dom);\n+                cacheStore.invalidate(dom);\n+            });\n         }\n     }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 2d11e7268..08f2ee72e 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6497,50 +6512,29 @@ public class DBService implements RolesProvider {\n         RoleMember roleMember;\n         List<RoleMember> roleMembersWithUpdatedState;\n         DomainRoleMember domainRoleMember;\n-        Set<MemberRole> updatedRoles = new HashSet<>();\n-\n+        int newState;\n+        Set<String> updatedDomains = new HashSet<>();\n         domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n         if (!domainRoleMember.getMemberRoles().isEmpty()) {\n             for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n                 roleMember = new RoleMember();\n                 roleMember.setMemberName(updatedUser.getFullName());\n-                if (suspended) {\n-                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                } else {\n-                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                }\n-                roleMembersWithUpdatedState = new ArrayList<>();\n-                roleMembersWithUpdatedState.add(roleMember);\n+                newState = suspended ? memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n+                        memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n+                roleMember.setSystemDisabled(newState);\n+                roleMembersWithUpdatedState = Collections.singletonList(roleMember);\n \n                 // Following method does Audit entry as well\n                 if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n                         memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-                    updatedRoles.add(memberRole);\n+                    con.updateRoleModTimestamp(memberRole.getDomainName(), memberRole.getRoleName());\n+                    updatedDomains.add(memberRole.getDomainName());\n                 }\n             }\n-            for (MemberRole updatedMR : updatedRoles) {\n-\n-                // update our role and domain time-stamps, and invalidate local cache entry\n-                con.updateRoleModTimestamp(updatedMR.getDomainName(), updatedMR.getRoleName());\n-                con.updateDomainModTimestamp(updatedMR.getDomainName());\n-                cacheStore.invalidate(updatedMR.getDomainName());\n-            }\n-        }\n-    }\n-\n-    private void updatePrincipalState(boolean suspended, List<Principal> updatedUsers, ObjectStoreConnection con, Principal changedPrincipal) {\n-        try {\n-            if (suspended) {\n-                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue())) {\n-                    updatedUsers.add(changedPrincipal);\n-                }\n-            } else {\n-                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.ACTIVE.getValue())) {\n-                    updatedUsers.add(changedPrincipal);\n-                }\n-            }\n-        } catch (ResourceException ex) {\n-            LOG.error(\"Exception in updating principal state from Authority {} Moving on.\", ex.getMessage());\n+            updatedDomains.forEach(dom -> {\n+                con.updateDomainModTimestamp(dom);\n+                cacheStore.invalidate(dom);\n+            });\n         }\n     }\n \n", "next_change": {"commit": "2968c209e870ce57fbdb1fb048a21692d80cfea6", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 08f2ee72e..ebcf806b9 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6538,6 +7757,21 @@ public class DBService implements RolesProvider {\n         }\n     }\n \n+\n+\n+    private void addDomainChangeMessage(ResourceContext ctx, String domainName, String objectName, DomainChangeMessage.ObjectType objectType) {\n+        if (ctx != null) {\n+            ctx.addDomainChangeMessage(new DomainChangeMessage()\n+                .setDomainName(domainName)\n+                .setObjectName(objectName)\n+                .setObjectType(objectType)\n+                .setApiName(ctx.getApiName())\n+                .setPublished(Instant.now().toEpochMilli())\n+                .setMessageId(java.util.UUID.randomUUID().toString())\n+            );\n+        }\n+    }\n+\n     class UserAuthorityFilterEnforcer implements Runnable {\n \n         public UserAuthorityFilterEnforcer() {\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "message": "Merge commit", "committedDate": null}, {"oid": "9a9c82c13d156e06dad8464c3a6c52c8e2bc6b89", "committedDate": "2020-10-26 14:15:03 -0700", "message": "remove sending back deprected members field in roles (#1160)"}, {"oid": "31a0dd7362f585f85992d4ff86fbf975d9d736dd", "committedDate": "2020-10-31 14:59:07 -0700", "message": "add azure_subscription field to domains (#1167)"}, {"oid": "c668f48cec94e2c928581b92ffb517f715a4840f", "committedDate": "2020-11-06 18:05:10 -0800", "message": "handle sys disabled null scenario (#1176)"}, {"oid": "f24d15baaaddc96c85fbceb31fcaded756a69f2e", "committedDate": "2020-11-14 16:51:57 -0800", "message": "role tags - generated code and schema changes (#1179)"}, {"oid": "30e272d8a9ec2649a1d876c1c111cf38e27c1743", "committedDate": "2020-12-07 08:48:58 -0800", "message": "putRoleMeta tags support (#1208)"}, {"oid": "f0e0a91b80250236244db9f8cba79e1def809995", "committedDate": "2020-12-23 15:40:53 -0800", "message": "updating group expiry date (#1221)"}, {"oid": "7a2837c7578ab8d36c62b48ecb1d0079c670616b", "committedDate": "2020-12-29 13:44:04 -0800", "message": "granular authz action for managing role members (#1228)"}, {"oid": "d6a0d659fe96486ffcf31bb93e919656be9eaf89", "committedDate": "2021-01-13 08:15:47 -0800", "message": "domain tags implementation (#1235)"}, {"oid": "3c939966592bf7cc6ff25df12a8d21d4c2c89b2b", "committedDate": "2021-01-19 22:05:22 -0800", "message": "client api update for rich authorization requests and consistent naming of entity objects (#1248)"}, {"oid": "3db6ed7b169fce5bbeaa1fae84ff7881e9a4e435", "committedDate": "2021-01-21 09:17:41 -0800", "message": "limit number of role and domain tags (#1255)"}, {"oid": "218b71958d88fb039dfa6e7c5448c7e4d00cb337", "committedDate": "2021-01-25 17:53:41 -0800", "message": "update domain last modified timestamp after tag update (#1262)"}, {"oid": "bccc5fb4dc1c2407a0293f322c3d97711af4297c", "committedDate": "2021-03-07 18:11:58 -0800", "message": "sonarcloud: method always returns same result (#1329)"}, {"oid": "e421f20094d24075d2cec7ab7adecff7d630a286", "committedDate": "2021-03-16 18:08:03 -0700", "message": "expose new domain attribute: business-service (#1357)"}, {"oid": "7b4afd5d40394226b3aa1af8bf10e90e528091b3", "committedDate": "2021-04-01 14:52:30 -0700", "message": "Add memberExpiryDays and serviceExpiryDays support for groups (#1388)"}, {"oid": "5ab30978cc4fc03e1b3022305f6e14a5a425e9e9", "committedDate": "2021-04-07 16:30:50 -0700", "message": "new DomainMetaStore interface support in ZMS (#1430)"}, {"oid": "9bedde4310d6493406d264422f23e16f33213546", "committedDate": "2021-04-08 09:44:29 -0700", "message": "Add group review days to role (#1428)"}, {"oid": "a554c75c51c5945b0e58ae87866de93ff1d5cfbc", "committedDate": "2021-04-15 12:12:02 -0700", "message": "during provider admin setup, ignore deletes (#1444)"}, {"oid": "1c564548381b3c09ad4214d0f30c667e9cc0d022", "committedDate": "2021-04-30 15:22:51 -0700", "message": "log full policy assertion details during delete operations in audit log (#1469)"}, {"oid": "611ac334bfbc1c43ec20154cf9448b96fae365d6", "committedDate": "2021-05-27 16:30:38 -0700", "message": "handle null contition processDomainTags (#1495)"}, {"oid": "addf4424a5bf842b58558c6f61ac0b46277d9535", "committedDate": "2021-06-07 09:38:12 -0700", "message": "allow role/group review regardless of role/group expiry/reminder settings (#1503)"}, {"oid": "4b39ffbd18da3d10a581fb10209806c97b432d28", "committedDate": "2021-06-09 15:31:17 -0700", "message": "enable role review without setting restrictions (#1512)"}, {"oid": "898ff0aa4fddd1a9ed111496cb9e4acb544605af", "committedDate": "2021-06-14 10:42:10 -0700", "message": "Update Tag Values to include '/', ':' (#1517)"}, {"oid": "cf535673b0a4cbcdc81e17c7def4cb6822edd78c", "committedDate": "2021-06-22 06:44:42 -0700", "message": "Allow system admins to set domain meta attribute business service (#1522)"}, {"oid": "934fc3d7fc859731f4beab3b03b83a15ac717a2d", "committedDate": "2021-06-29 12:57:53 -0700", "message": "assertion condition server changes (#1528)"}, {"oid": "1fa51b852890c1576254be6a8a2b5dbebc89865c", "committedDate": "2021-07-21 14:41:19 -0700", "message": "UI : update error message (#1557)"}, {"oid": "09de45bb794eb5e7c29f705b5ce567c75fde4e84", "committedDate": "2021-07-29 15:49:16 -0700", "message": "multi-version policy - introducing version/active in policy object (#1568)"}, {"oid": "4abff4b9952e4836f79bf3f1934baf8fe2bcebf9", "committedDate": "2021-08-08 11:39:07 -0700", "message": "Disable Reminder Review Notifications By Tag zms.DisableReminderNotifications (#1579)"}, {"oid": "6a1523accc3ec83fe54d78c3d919d9cddbcb1b7e", "committedDate": "2021-08-17 18:32:28 -0700", "message": "fixing the order of updates for assertion condition api operations (#1591)"}, {"oid": "66590f4fc47f899f3990f20895f953074e40f259", "committedDate": "2021-09-10 07:55:42 -0700", "message": "Implement multi-version policies endpoints (#1605)"}, {"oid": "1ad624427917493d31bd1b8ffa6303c4d6353055", "committedDate": "2021-09-10 13:51:19 -0700", "message": "update group last modified when user is deleted (#1613)"}, {"oid": "91b116418656f123dae9a3405cb2e498d4d3aff4", "committedDate": "2021-09-12 09:52:05 +0300", "message": "additional validation checks when processing versioned policies (#1614)"}, {"oid": "2531428956f87774f86721f02b430861ca8897ec", "committedDate": "2021-09-14 09:49:34 +0300", "message": "additional checks when setting a policy version as active (#1615)"}, {"oid": "2968c209e870ce57fbdb1fb048a21692d80cfea6", "committedDate": "2021-10-01 07:25:34 -0700", "message": "rdl publishChangeEvents generator (#1624)"}, {"oid": "8a6960ce9878277c5abda1d104ca070831b36230", "committedDate": "2021-10-03 13:48:03 -0700", "message": "Allow specifying version name when creating new policy (#1630)"}, {"oid": "43f619b31bbd9cc3d388aa7ea29eff889cb1272d", "committedDate": "2021-10-21 08:48:51 -0700", "message": "For role expiry notification - record metrics daily while (#1654)"}, {"oid": "389f984270d7d89070c66096e87fafbcb24a261c", "committedDate": "2021-10-26 08:17:36 -0700", "message": "Group tags implementation (#1660)"}, {"oid": "120ab1fa8e9d33fa793c4254d233a09a2c23d173", "committedDate": "2021-10-29 15:08:28 -0700", "message": "Disable Group Expiry Notifications By Tag zms.DisableReminderNotifications (#1663)"}, {"oid": "1400363e8d698cf08370c89752077ebae043c5be", "committedDate": "2021-12-14 13:48:34 -0800", "message": "correct logging of role principal in audit/access logs"}, {"oid": "c8e3a5c91c5deb9640576cd3496a2af11d572f0b", "committedDate": "2021-12-23 15:03:25 -0800", "message": "protect system admin users from being removed from deleteUser api (#1715)"}, {"oid": "020e06e57b357768260f509f08b75c5c068bce53", "committedDate": "2022-02-07 08:01:55 -0800", "message": "Service Visiblity - Domain Dependencies (#1758)"}, {"oid": "fcbd4128e334a9a42f4579d179cf9578d3f4de99", "committedDate": "2022-02-07 10:12:47 -0800", "message": "support new get-stats endpoint to get per-domain/system stats (#1774)"}, {"oid": "ea831a34a70a0475bea8754cb183741dced98ff2", "committedDate": "2022-02-18 09:17:55 -0800", "message": "update pending member api to support getting list for a domain (#1783)"}, {"oid": "f4229124e8e1898810c7aa7b3a4eff37fddae308", "committedDate": "2022-02-18 12:37:32 -0800", "message": "provide option to skip adding principal when onboarding a resource group (#1787)"}, {"oid": "9081feb4c06a1058c941c67923037203d9318cfa", "committedDate": "2022-02-27 14:10:46 -0800", "message": "Domain Dependency for Tenancy (#1789)"}, {"oid": "a5bb615881583fa6f39621e2ea3bf39d3886340b", "committedDate": "2022-03-03 17:20:00 -0800", "message": "extend template keyword support trust field in roles (#1803)"}, {"oid": "3de182bcbedba89fa2aaba12ab9be49aa2156096", "committedDate": "2022-03-19 09:45:40 -0700", "message": "Add provider webhook for verifying removal (#1816)"}, {"oid": "1b0cff1cb9b8e4a231c5cfb342d76b6aad8e08fc", "committedDate": "2022-04-07 14:34:23 -0700", "message": "no need to update domain's last mod timestamp during put dependency call (#1846)"}, {"oid": "baa68eacd6a6b9bbc70c3423006f92cd47b784d7", "committedDate": "2022-05-19 09:30:02 -0700", "message": "Get Auth History implementation (#1875)"}, {"oid": "bea97b165e28b5b2cc286af62c92e536c9fc3ff2", "committedDate": "2022-06-03 13:50:01 -0700", "message": "AuthHistory - Return dependencies instead of list (#1888)"}, {"oid": "7a313e1d581295ae6c786bbc2ed73bb14da37f7d", "committedDate": "2022-07-21 20:16:24 -0700", "message": "allow management of domain memberPurgeExpiryDays setting value (#1928)"}, {"oid": "f288ed7afb018bc07af02dbe9dc8e05ec0896071", "committedDate": "2022-08-15 22:28:01 -0700", "message": "provide header option to return updated object in response (#1942)"}, {"oid": "949bd0634d328d04736b912a002bdfa7421d9f2b", "committedDate": "2022-08-23 10:28:38 -0700", "message": "fix returning role/group objects when requested by ui (#1945)"}, {"oid": "ab7284c9274f4949d23f88ec0dde7b689c0c6980", "committedDate": "2022-09-05 13:12:17 -0700", "message": "auto purge expired role/group members based on server/domain config (#1941)"}, {"oid": "4ab6e748891a014a8b0a1364de099d3fbf4c7468", "committedDate": "2022-09-21 22:22:48 -0700", "message": "enable readWrite db connection for delete expired members (#1964)"}, {"oid": "d4c733d3e97467a598ba44f0bde5c6a907aa01de", "committedDate": "2022-09-23 13:30:24 -0700", "message": "consistent use of The Athenz Authors copyright in all files (#1967)"}, {"oid": "45dcdab92d9e39d5d561b34ef222f863176cc635", "committedDate": "2022-09-26 12:29:01 -0700", "message": "make server purge expiry member day configurable (#1968)"}, {"oid": "d823cccb5163f950655f3859ade41fe031910588", "committedDate": "2022-10-06 14:20:20 -0700", "message": "fix putServiceIdentity logic to allow update of exising pubKey (#1978)"}, {"oid": "91d38ef548e59e29e69349b8a0f5151456b62a0f", "committedDate": "2022-10-07 15:36:36 -0700", "message": "Use correct object type for role member delete notifications (#1981)"}, {"oid": "1d970ce72c2f81aed5576fff068103bbba022aaf", "committedDate": "2022-11-29 23:50:29 +0200", "message": "add gcp project attribute for domains (#2005)"}, {"oid": "c292a1a2fb6e3a300a3060a6bcea6a96f696932c", "committedDate": "2022-12-13 08:56:43 -0800", "message": "Return the correct response from putMembership/putGroupMembership once a pending member was added (#2023)"}, {"oid": "fc5a206d1cb23dd2bbfd9af7e3125ec270ebc022", "committedDate": "2023-01-10 21:48:12 -0800", "message": "allow domain admins to enable audit flag for new roles/groups (#2032)"}, {"oid": "70850ab1de4055e765cf4ead6946b431900ff8c8", "committedDate": "2023-01-23 16:40:36 -0800", "message": "move cloud provider role generation logic out of dbstore library to dbservice (#2043)"}, {"oid": "0ff7ff4f9658fd42e8ee2161d870a89dce5167e4", "committedDate": "2023-02-02 09:18:32 -0800", "message": "Add a requirement for admin approval to delete members in review-enabled roles (#2053)"}, {"oid": "ff57628b890f53c43fec6dd2cacf98a574c95b2d", "committedDate": "2023-02-08 15:55:32 -0800", "message": "extends group with deleteProtection attribute and pending group membe\u2026 (#2067)"}, {"oid": "bb1d69af70a90aeedc28a46604283064e0dad8de", "committedDate": "2023-02-16 07:44:40 -0800", "message": "add audit enable to role (#2055)"}, {"oid": "4ee14d784973ce7da8aba96b35eefdbc5d61d97b", "committedDate": "2023-03-07 11:34:04 -0800", "message": "make aws/gcp assume role action values configurable (#2090)"}, {"oid": "5216da47ef8bca89ba0eae790f72739d9d73fcc6", "committedDate": "2023-03-09 10:36:29 -0800", "message": "Add optional 'description' to role (#2091)"}, {"oid": "d1b98d4614d62fe34b408cfa1a26fb59674d6494", "committedDate": "2023-03-27 16:46:33 -0700", "message": "store GCP project number along with project id in athenz domain metadata (#2113)"}, {"oid": "715cf96c679e817600a0a25160c96878e5eda735", "committedDate": "2023-03-27 18:01:33 -0700", "message": "special resource for gcp starting with service/ (#2115)"}, {"oid": "6e7342a1e98207b87e3eae45341db281b7b3b9c7", "committedDate": "2023-04-13 14:30:39 -0700", "message": "designate separate action for assertions when assuming gcp service accounts (#2127)"}, {"oid": "523f7f753fa2a4a112ae4fb7a5389203af8b9594", "committedDate": "2023-05-29 08:52:21 -0700", "message": "fix role update on expiration and review dates (#2185)"}, {"oid": "7069bf871635c4e5308d37341904241388b1ccda", "committedDate": "2023-05-30 15:31:26 -0700", "message": "support product id (string) format association with domains (#2193)"}, {"oid": "368d0bc139931c03d31824c4f02394b38e3ead95", "committedDate": "2023-06-02 13:15:05 -0700", "message": "support headless user type - managed by user authority but treated like service (#2197)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxMzQyNw==", "url": "https://github.com/AthenZ/athenz/pull/1157#discussion_r511013427", "body": "the use of the this does not look correct since we're still processing the domain multiple times. if the principal is part of 10 roles in a domain, then we're updating the role mod timestamp for 10 roles, but then we're doing the same thing for the same domain 10 times.\r\n\r\ninstead of painting a updatedRoles struct, we should maintain:\r\n\r\nSet<String> updatedDomains;\r\n\r\nand then in the function we just call\r\n\r\ncon.updateRoleModTimestamp(memberRole.getDomainName(), memberRole.getRoleName());\r\nupdatedDomains.put(memberRole.getDomainName()); // this will ignore all duplicates\r\n\r\nthen outside of the for loop you can just iterate through the domain names and call\r\n\r\ncon.updateDomainModTimestamp(updatedMR.getDomainName());\r\ncacheStore.invalidate(updatedMR.getDomainName());", "bodyText": "the use of the this does not look correct since we're still processing the domain multiple times. if the principal is part of 10 roles in a domain, then we're updating the role mod timestamp for 10 roles, but then we're doing the same thing for the same domain 10 times.\ninstead of painting a updatedRoles struct, we should maintain:\nSet updatedDomains;\nand then in the function we just call\ncon.updateRoleModTimestamp(memberRole.getDomainName(), memberRole.getRoleName());\nupdatedDomains.put(memberRole.getDomainName()); // this will ignore all duplicates\nthen outside of the for loop you can just iterate through the domain names and call\ncon.updateDomainModTimestamp(updatedMR.getDomainName());\ncacheStore.invalidate(updatedMR.getDomainName());", "bodyHTML": "<p dir=\"auto\">the use of the this does not look correct since we're still processing the domain multiple times. if the principal is part of 10 roles in a domain, then we're updating the role mod timestamp for 10 roles, but then we're doing the same thing for the same domain 10 times.</p>\n<p dir=\"auto\">instead of painting a updatedRoles struct, we should maintain:</p>\n<p dir=\"auto\">Set updatedDomains;</p>\n<p dir=\"auto\">and then in the function we just call</p>\n<p dir=\"auto\">con.updateRoleModTimestamp(memberRole.getDomainName(), memberRole.getRoleName());<br>\nupdatedDomains.put(memberRole.getDomainName()); // this will ignore all duplicates</p>\n<p dir=\"auto\">then outside of the for loop you can just iterate through the domain names and call</p>\n<p dir=\"auto\">con.updateDomainModTimestamp(updatedMR.getDomainName());<br>\ncacheStore.invalidate(updatedMR.getDomainName());</p>", "author": "havetisyan", "createdAt": "2020-10-23T16:50:50Z", "path": "servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java", "diffHunk": "@@ -6402,6 +6403,147 @@ void enforceGroupUserAuthorityRestrictions(final String domainName, final String\n         }\n     }\n \n+    /**\n+     * This method returns list of Principals based on the state parameter supplied\n+     * @param queriedState state of principal\n+     * @return List of Principals from DB\n+     */\n+    List<Principal> getPrincipals(int queriedState) {\n+        List<Principal> principals = new ArrayList<>();\n+        Principal principal;\n+        try (ObjectStoreConnection con = store.getConnection(true, false)) {\n+           List<String> dbPrincipals = con.getPrincipals(queriedState);\n+            Principal.State principalState = Principal.State.getState(queriedState);\n+           for (String dbPrincipal : dbPrincipals) {\n+               principal = ZMSUtils.createPrincipalForName(dbPrincipal, zmsConfig.getUserDomain(), null);\n+               ((SimplePrincipal) principal).setState(principalState);\n+               principals.add(principal);\n+           }\n+        }\n+        return principals;\n+    }\n+\n+    /**\n+     * This method toggles state for supplied Principals based on the flag in DB\n+     * as well as modifies memberships of all roles and groups of current principal(s)\n+     * @param changedPrincipals List of Principals from User Authority\n+     * @param suspended boolean indicating principal's state\n+     */\n+    void updatePrincipalByStateFromAuthority(List<Principal> changedPrincipals, boolean suspended) {\n+        final String caller = \"updatePrincipalByStateFromAuthority\";\n+        List<Principal> updatedUsers = new ArrayList<>();\n+        if (!changedPrincipals.isEmpty()) {\n+            try (ObjectStoreConnection con = store.getConnection(true, true)) {\n+\n+                // first lets update the new state in DB\n+                for (Principal changedPrincipal : changedPrincipals) {\n+                    updatePrincipalState(suspended, updatedUsers, con, changedPrincipal);\n+                }\n+                // if new state is updated successfully\n+                // then we need to modify all roles and groups where given principal is member of\n+                if (!updatedUsers.isEmpty()) {\n+                    for (Principal updatedUser : updatedUsers) {\n+                        try {\n+                            updateRoleMembershipsByPrincipalState(suspended, caller, con, updatedUser);\n+                            updateGroupMembershipByPrincipalState(suspended, caller, con, updatedUser);\n+                        } catch (ResourceException ex) {\n+                            if (ex.getCode() == ResourceException.NOT_FOUND) {\n+                                continue;\n+                            }\n+                            throw ex;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void updateGroupMembershipByPrincipalState(boolean suspended, String caller, ObjectStoreConnection con, Principal updatedUser) {\n+        List<GroupMember> groupMembersWithUpdatedState;\n+        GroupMember groupMember;\n+        DomainGroupMember domainGroupMember;\n+        Set<GroupMember> updatedGroups = new HashSet<>();\n+\n+        domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n+        if (!domainGroupMember.getMemberGroups().isEmpty()) {\n+            for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n+                groupMember = new GroupMember();\n+                groupMember.setMemberName(updatedUser.getFullName());\n+                if (suspended) {\n+                    groupMember.setSystemDisabled(currentGroup.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                } else {\n+                    groupMember.setSystemDisabled(currentGroup.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                }\n+                groupMembersWithUpdatedState = new ArrayList<>();\n+                groupMembersWithUpdatedState.add(groupMember);\n+\n+                // Following method does Audit entry as well\n+                if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n+                        currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n+                    updatedGroups.add(currentGroup);\n+                }\n+            }\n+            for (GroupMember updatedGM : updatedGroups) {\n+\n+                // update our group and domain time-stamps, and invalidate local cache entry\n+                con.updateGroupModTimestamp(updatedGM.getDomainName(), updatedGM.getGroupName());\n+                con.updateDomainModTimestamp(updatedGM.getDomainName());\n+                cacheStore.invalidate(updatedGM.getDomainName());\n+            }\n+        }\n+    }\n+\n+    private void updateRoleMembershipsByPrincipalState(boolean suspended, String caller, ObjectStoreConnection con, Principal updatedUser) {\n+        RoleMember roleMember;\n+        List<RoleMember> roleMembersWithUpdatedState;\n+        DomainRoleMember domainRoleMember;\n+        Set<MemberRole> updatedRoles = new HashSet<>();\n+\n+        domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n+        if (!domainRoleMember.getMemberRoles().isEmpty()) {\n+            for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n+                roleMember = new RoleMember();\n+                roleMember.setMemberName(updatedUser.getFullName());\n+                if (suspended) {\n+                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                } else {\n+                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                }\n+                roleMembersWithUpdatedState = new ArrayList<>();\n+                roleMembersWithUpdatedState.add(roleMember);\n+\n+                // Following method does Audit entry as well\n+                if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n+                        memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n+                    updatedRoles.add(memberRole);", "originalCommit": "f2b6979e4235f325d7eea75d6f63d358c03d8d3c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0dff4be75160c89e9e35b4634db11456460fa25f", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 2d11e7268..08f2ee72e 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6497,50 +6512,29 @@ public class DBService implements RolesProvider {\n         RoleMember roleMember;\n         List<RoleMember> roleMembersWithUpdatedState;\n         DomainRoleMember domainRoleMember;\n-        Set<MemberRole> updatedRoles = new HashSet<>();\n-\n+        int newState;\n+        Set<String> updatedDomains = new HashSet<>();\n         domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n         if (!domainRoleMember.getMemberRoles().isEmpty()) {\n             for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n                 roleMember = new RoleMember();\n                 roleMember.setMemberName(updatedUser.getFullName());\n-                if (suspended) {\n-                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                } else {\n-                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                }\n-                roleMembersWithUpdatedState = new ArrayList<>();\n-                roleMembersWithUpdatedState.add(roleMember);\n+                newState = suspended ? memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n+                        memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n+                roleMember.setSystemDisabled(newState);\n+                roleMembersWithUpdatedState = Collections.singletonList(roleMember);\n \n                 // Following method does Audit entry as well\n                 if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n                         memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-                    updatedRoles.add(memberRole);\n+                    con.updateRoleModTimestamp(memberRole.getDomainName(), memberRole.getRoleName());\n+                    updatedDomains.add(memberRole.getDomainName());\n                 }\n             }\n-            for (MemberRole updatedMR : updatedRoles) {\n-\n-                // update our role and domain time-stamps, and invalidate local cache entry\n-                con.updateRoleModTimestamp(updatedMR.getDomainName(), updatedMR.getRoleName());\n-                con.updateDomainModTimestamp(updatedMR.getDomainName());\n-                cacheStore.invalidate(updatedMR.getDomainName());\n-            }\n-        }\n-    }\n-\n-    private void updatePrincipalState(boolean suspended, List<Principal> updatedUsers, ObjectStoreConnection con, Principal changedPrincipal) {\n-        try {\n-            if (suspended) {\n-                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue())) {\n-                    updatedUsers.add(changedPrincipal);\n-                }\n-            } else {\n-                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.ACTIVE.getValue())) {\n-                    updatedUsers.add(changedPrincipal);\n-                }\n-            }\n-        } catch (ResourceException ex) {\n-            LOG.error(\"Exception in updating principal state from Authority {} Moving on.\", ex.getMessage());\n+            updatedDomains.forEach(dom -> {\n+                con.updateDomainModTimestamp(dom);\n+                cacheStore.invalidate(dom);\n+            });\n         }\n     }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 2d11e7268..08f2ee72e 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6497,50 +6512,29 @@ public class DBService implements RolesProvider {\n         RoleMember roleMember;\n         List<RoleMember> roleMembersWithUpdatedState;\n         DomainRoleMember domainRoleMember;\n-        Set<MemberRole> updatedRoles = new HashSet<>();\n-\n+        int newState;\n+        Set<String> updatedDomains = new HashSet<>();\n         domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n         if (!domainRoleMember.getMemberRoles().isEmpty()) {\n             for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n                 roleMember = new RoleMember();\n                 roleMember.setMemberName(updatedUser.getFullName());\n-                if (suspended) {\n-                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                } else {\n-                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                }\n-                roleMembersWithUpdatedState = new ArrayList<>();\n-                roleMembersWithUpdatedState.add(roleMember);\n+                newState = suspended ? memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n+                        memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n+                roleMember.setSystemDisabled(newState);\n+                roleMembersWithUpdatedState = Collections.singletonList(roleMember);\n \n                 // Following method does Audit entry as well\n                 if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n                         memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-                    updatedRoles.add(memberRole);\n+                    con.updateRoleModTimestamp(memberRole.getDomainName(), memberRole.getRoleName());\n+                    updatedDomains.add(memberRole.getDomainName());\n                 }\n             }\n-            for (MemberRole updatedMR : updatedRoles) {\n-\n-                // update our role and domain time-stamps, and invalidate local cache entry\n-                con.updateRoleModTimestamp(updatedMR.getDomainName(), updatedMR.getRoleName());\n-                con.updateDomainModTimestamp(updatedMR.getDomainName());\n-                cacheStore.invalidate(updatedMR.getDomainName());\n-            }\n-        }\n-    }\n-\n-    private void updatePrincipalState(boolean suspended, List<Principal> updatedUsers, ObjectStoreConnection con, Principal changedPrincipal) {\n-        try {\n-            if (suspended) {\n-                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue())) {\n-                    updatedUsers.add(changedPrincipal);\n-                }\n-            } else {\n-                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.ACTIVE.getValue())) {\n-                    updatedUsers.add(changedPrincipal);\n-                }\n-            }\n-        } catch (ResourceException ex) {\n-            LOG.error(\"Exception in updating principal state from Authority {} Moving on.\", ex.getMessage());\n+            updatedDomains.forEach(dom -> {\n+                con.updateDomainModTimestamp(dom);\n+                cacheStore.invalidate(dom);\n+            });\n         }\n     }\n \n", "next_change": {"commit": "2968c209e870ce57fbdb1fb048a21692d80cfea6", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 08f2ee72e..ebcf806b9 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6538,6 +7757,21 @@ public class DBService implements RolesProvider {\n         }\n     }\n \n+\n+\n+    private void addDomainChangeMessage(ResourceContext ctx, String domainName, String objectName, DomainChangeMessage.ObjectType objectType) {\n+        if (ctx != null) {\n+            ctx.addDomainChangeMessage(new DomainChangeMessage()\n+                .setDomainName(domainName)\n+                .setObjectName(objectName)\n+                .setObjectType(objectType)\n+                .setApiName(ctx.getApiName())\n+                .setPublished(Instant.now().toEpochMilli())\n+                .setMessageId(java.util.UUID.randomUUID().toString())\n+            );\n+        }\n+    }\n+\n     class UserAuthorityFilterEnforcer implements Runnable {\n \n         public UserAuthorityFilterEnforcer() {\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "message": "Merge commit", "committedDate": null}, {"oid": "9a9c82c13d156e06dad8464c3a6c52c8e2bc6b89", "committedDate": "2020-10-26 14:15:03 -0700", "message": "remove sending back deprected members field in roles (#1160)"}, {"oid": "31a0dd7362f585f85992d4ff86fbf975d9d736dd", "committedDate": "2020-10-31 14:59:07 -0700", "message": "add azure_subscription field to domains (#1167)"}, {"oid": "c668f48cec94e2c928581b92ffb517f715a4840f", "committedDate": "2020-11-06 18:05:10 -0800", "message": "handle sys disabled null scenario (#1176)"}, {"oid": "f24d15baaaddc96c85fbceb31fcaded756a69f2e", "committedDate": "2020-11-14 16:51:57 -0800", "message": "role tags - generated code and schema changes (#1179)"}, {"oid": "30e272d8a9ec2649a1d876c1c111cf38e27c1743", "committedDate": "2020-12-07 08:48:58 -0800", "message": "putRoleMeta tags support (#1208)"}, {"oid": "f0e0a91b80250236244db9f8cba79e1def809995", "committedDate": "2020-12-23 15:40:53 -0800", "message": "updating group expiry date (#1221)"}, {"oid": "7a2837c7578ab8d36c62b48ecb1d0079c670616b", "committedDate": "2020-12-29 13:44:04 -0800", "message": "granular authz action for managing role members (#1228)"}, {"oid": "d6a0d659fe96486ffcf31bb93e919656be9eaf89", "committedDate": "2021-01-13 08:15:47 -0800", "message": "domain tags implementation (#1235)"}, {"oid": "3c939966592bf7cc6ff25df12a8d21d4c2c89b2b", "committedDate": "2021-01-19 22:05:22 -0800", "message": "client api update for rich authorization requests and consistent naming of entity objects (#1248)"}, {"oid": "3db6ed7b169fce5bbeaa1fae84ff7881e9a4e435", "committedDate": "2021-01-21 09:17:41 -0800", "message": "limit number of role and domain tags (#1255)"}, {"oid": "218b71958d88fb039dfa6e7c5448c7e4d00cb337", "committedDate": "2021-01-25 17:53:41 -0800", "message": "update domain last modified timestamp after tag update (#1262)"}, {"oid": "bccc5fb4dc1c2407a0293f322c3d97711af4297c", "committedDate": "2021-03-07 18:11:58 -0800", "message": "sonarcloud: method always returns same result (#1329)"}, {"oid": "e421f20094d24075d2cec7ab7adecff7d630a286", "committedDate": "2021-03-16 18:08:03 -0700", "message": "expose new domain attribute: business-service (#1357)"}, {"oid": "7b4afd5d40394226b3aa1af8bf10e90e528091b3", "committedDate": "2021-04-01 14:52:30 -0700", "message": "Add memberExpiryDays and serviceExpiryDays support for groups (#1388)"}, {"oid": "5ab30978cc4fc03e1b3022305f6e14a5a425e9e9", "committedDate": "2021-04-07 16:30:50 -0700", "message": "new DomainMetaStore interface support in ZMS (#1430)"}, {"oid": "9bedde4310d6493406d264422f23e16f33213546", "committedDate": "2021-04-08 09:44:29 -0700", "message": "Add group review days to role (#1428)"}, {"oid": "a554c75c51c5945b0e58ae87866de93ff1d5cfbc", "committedDate": "2021-04-15 12:12:02 -0700", "message": "during provider admin setup, ignore deletes (#1444)"}, {"oid": "1c564548381b3c09ad4214d0f30c667e9cc0d022", "committedDate": "2021-04-30 15:22:51 -0700", "message": "log full policy assertion details during delete operations in audit log (#1469)"}, {"oid": "611ac334bfbc1c43ec20154cf9448b96fae365d6", "committedDate": "2021-05-27 16:30:38 -0700", "message": "handle null contition processDomainTags (#1495)"}, {"oid": "addf4424a5bf842b58558c6f61ac0b46277d9535", "committedDate": "2021-06-07 09:38:12 -0700", "message": "allow role/group review regardless of role/group expiry/reminder settings (#1503)"}, {"oid": "4b39ffbd18da3d10a581fb10209806c97b432d28", "committedDate": "2021-06-09 15:31:17 -0700", "message": "enable role review without setting restrictions (#1512)"}, {"oid": "898ff0aa4fddd1a9ed111496cb9e4acb544605af", "committedDate": "2021-06-14 10:42:10 -0700", "message": "Update Tag Values to include '/', ':' (#1517)"}, {"oid": "cf535673b0a4cbcdc81e17c7def4cb6822edd78c", "committedDate": "2021-06-22 06:44:42 -0700", "message": "Allow system admins to set domain meta attribute business service (#1522)"}, {"oid": "934fc3d7fc859731f4beab3b03b83a15ac717a2d", "committedDate": "2021-06-29 12:57:53 -0700", "message": "assertion condition server changes (#1528)"}, {"oid": "1fa51b852890c1576254be6a8a2b5dbebc89865c", "committedDate": "2021-07-21 14:41:19 -0700", "message": "UI : update error message (#1557)"}, {"oid": "09de45bb794eb5e7c29f705b5ce567c75fde4e84", "committedDate": "2021-07-29 15:49:16 -0700", "message": "multi-version policy - introducing version/active in policy object (#1568)"}, {"oid": "4abff4b9952e4836f79bf3f1934baf8fe2bcebf9", "committedDate": "2021-08-08 11:39:07 -0700", "message": "Disable Reminder Review Notifications By Tag zms.DisableReminderNotifications (#1579)"}, {"oid": "6a1523accc3ec83fe54d78c3d919d9cddbcb1b7e", "committedDate": "2021-08-17 18:32:28 -0700", "message": "fixing the order of updates for assertion condition api operations (#1591)"}, {"oid": "66590f4fc47f899f3990f20895f953074e40f259", "committedDate": "2021-09-10 07:55:42 -0700", "message": "Implement multi-version policies endpoints (#1605)"}, {"oid": "1ad624427917493d31bd1b8ffa6303c4d6353055", "committedDate": "2021-09-10 13:51:19 -0700", "message": "update group last modified when user is deleted (#1613)"}, {"oid": "91b116418656f123dae9a3405cb2e498d4d3aff4", "committedDate": "2021-09-12 09:52:05 +0300", "message": "additional validation checks when processing versioned policies (#1614)"}, {"oid": "2531428956f87774f86721f02b430861ca8897ec", "committedDate": "2021-09-14 09:49:34 +0300", "message": "additional checks when setting a policy version as active (#1615)"}, {"oid": "2968c209e870ce57fbdb1fb048a21692d80cfea6", "committedDate": "2021-10-01 07:25:34 -0700", "message": "rdl publishChangeEvents generator (#1624)"}, {"oid": "8a6960ce9878277c5abda1d104ca070831b36230", "committedDate": "2021-10-03 13:48:03 -0700", "message": "Allow specifying version name when creating new policy (#1630)"}, {"oid": "43f619b31bbd9cc3d388aa7ea29eff889cb1272d", "committedDate": "2021-10-21 08:48:51 -0700", "message": "For role expiry notification - record metrics daily while (#1654)"}, {"oid": "389f984270d7d89070c66096e87fafbcb24a261c", "committedDate": "2021-10-26 08:17:36 -0700", "message": "Group tags implementation (#1660)"}, {"oid": "120ab1fa8e9d33fa793c4254d233a09a2c23d173", "committedDate": "2021-10-29 15:08:28 -0700", "message": "Disable Group Expiry Notifications By Tag zms.DisableReminderNotifications (#1663)"}, {"oid": "1400363e8d698cf08370c89752077ebae043c5be", "committedDate": "2021-12-14 13:48:34 -0800", "message": "correct logging of role principal in audit/access logs"}, {"oid": "c8e3a5c91c5deb9640576cd3496a2af11d572f0b", "committedDate": "2021-12-23 15:03:25 -0800", "message": "protect system admin users from being removed from deleteUser api (#1715)"}, {"oid": "020e06e57b357768260f509f08b75c5c068bce53", "committedDate": "2022-02-07 08:01:55 -0800", "message": "Service Visiblity - Domain Dependencies (#1758)"}, {"oid": "fcbd4128e334a9a42f4579d179cf9578d3f4de99", "committedDate": "2022-02-07 10:12:47 -0800", "message": "support new get-stats endpoint to get per-domain/system stats (#1774)"}, {"oid": "ea831a34a70a0475bea8754cb183741dced98ff2", "committedDate": "2022-02-18 09:17:55 -0800", "message": "update pending member api to support getting list for a domain (#1783)"}, {"oid": "f4229124e8e1898810c7aa7b3a4eff37fddae308", "committedDate": "2022-02-18 12:37:32 -0800", "message": "provide option to skip adding principal when onboarding a resource group (#1787)"}, {"oid": "9081feb4c06a1058c941c67923037203d9318cfa", "committedDate": "2022-02-27 14:10:46 -0800", "message": "Domain Dependency for Tenancy (#1789)"}, {"oid": "a5bb615881583fa6f39621e2ea3bf39d3886340b", "committedDate": "2022-03-03 17:20:00 -0800", "message": "extend template keyword support trust field in roles (#1803)"}, {"oid": "3de182bcbedba89fa2aaba12ab9be49aa2156096", "committedDate": "2022-03-19 09:45:40 -0700", "message": "Add provider webhook for verifying removal (#1816)"}, {"oid": "1b0cff1cb9b8e4a231c5cfb342d76b6aad8e08fc", "committedDate": "2022-04-07 14:34:23 -0700", "message": "no need to update domain's last mod timestamp during put dependency call (#1846)"}, {"oid": "baa68eacd6a6b9bbc70c3423006f92cd47b784d7", "committedDate": "2022-05-19 09:30:02 -0700", "message": "Get Auth History implementation (#1875)"}, {"oid": "bea97b165e28b5b2cc286af62c92e536c9fc3ff2", "committedDate": "2022-06-03 13:50:01 -0700", "message": "AuthHistory - Return dependencies instead of list (#1888)"}, {"oid": "7a313e1d581295ae6c786bbc2ed73bb14da37f7d", "committedDate": "2022-07-21 20:16:24 -0700", "message": "allow management of domain memberPurgeExpiryDays setting value (#1928)"}, {"oid": "f288ed7afb018bc07af02dbe9dc8e05ec0896071", "committedDate": "2022-08-15 22:28:01 -0700", "message": "provide header option to return updated object in response (#1942)"}, {"oid": "949bd0634d328d04736b912a002bdfa7421d9f2b", "committedDate": "2022-08-23 10:28:38 -0700", "message": "fix returning role/group objects when requested by ui (#1945)"}, {"oid": "ab7284c9274f4949d23f88ec0dde7b689c0c6980", "committedDate": "2022-09-05 13:12:17 -0700", "message": "auto purge expired role/group members based on server/domain config (#1941)"}, {"oid": "4ab6e748891a014a8b0a1364de099d3fbf4c7468", "committedDate": "2022-09-21 22:22:48 -0700", "message": "enable readWrite db connection for delete expired members (#1964)"}, {"oid": "d4c733d3e97467a598ba44f0bde5c6a907aa01de", "committedDate": "2022-09-23 13:30:24 -0700", "message": "consistent use of The Athenz Authors copyright in all files (#1967)"}, {"oid": "45dcdab92d9e39d5d561b34ef222f863176cc635", "committedDate": "2022-09-26 12:29:01 -0700", "message": "make server purge expiry member day configurable (#1968)"}, {"oid": "d823cccb5163f950655f3859ade41fe031910588", "committedDate": "2022-10-06 14:20:20 -0700", "message": "fix putServiceIdentity logic to allow update of exising pubKey (#1978)"}, {"oid": "91d38ef548e59e29e69349b8a0f5151456b62a0f", "committedDate": "2022-10-07 15:36:36 -0700", "message": "Use correct object type for role member delete notifications (#1981)"}, {"oid": "1d970ce72c2f81aed5576fff068103bbba022aaf", "committedDate": "2022-11-29 23:50:29 +0200", "message": "add gcp project attribute for domains (#2005)"}, {"oid": "c292a1a2fb6e3a300a3060a6bcea6a96f696932c", "committedDate": "2022-12-13 08:56:43 -0800", "message": "Return the correct response from putMembership/putGroupMembership once a pending member was added (#2023)"}, {"oid": "fc5a206d1cb23dd2bbfd9af7e3125ec270ebc022", "committedDate": "2023-01-10 21:48:12 -0800", "message": "allow domain admins to enable audit flag for new roles/groups (#2032)"}, {"oid": "70850ab1de4055e765cf4ead6946b431900ff8c8", "committedDate": "2023-01-23 16:40:36 -0800", "message": "move cloud provider role generation logic out of dbstore library to dbservice (#2043)"}, {"oid": "0ff7ff4f9658fd42e8ee2161d870a89dce5167e4", "committedDate": "2023-02-02 09:18:32 -0800", "message": "Add a requirement for admin approval to delete members in review-enabled roles (#2053)"}, {"oid": "ff57628b890f53c43fec6dd2cacf98a574c95b2d", "committedDate": "2023-02-08 15:55:32 -0800", "message": "extends group with deleteProtection attribute and pending group membe\u2026 (#2067)"}, {"oid": "bb1d69af70a90aeedc28a46604283064e0dad8de", "committedDate": "2023-02-16 07:44:40 -0800", "message": "add audit enable to role (#2055)"}, {"oid": "4ee14d784973ce7da8aba96b35eefdbc5d61d97b", "committedDate": "2023-03-07 11:34:04 -0800", "message": "make aws/gcp assume role action values configurable (#2090)"}, {"oid": "5216da47ef8bca89ba0eae790f72739d9d73fcc6", "committedDate": "2023-03-09 10:36:29 -0800", "message": "Add optional 'description' to role (#2091)"}, {"oid": "d1b98d4614d62fe34b408cfa1a26fb59674d6494", "committedDate": "2023-03-27 16:46:33 -0700", "message": "store GCP project number along with project id in athenz domain metadata (#2113)"}, {"oid": "715cf96c679e817600a0a25160c96878e5eda735", "committedDate": "2023-03-27 18:01:33 -0700", "message": "special resource for gcp starting with service/ (#2115)"}, {"oid": "6e7342a1e98207b87e3eae45341db281b7b3b9c7", "committedDate": "2023-04-13 14:30:39 -0700", "message": "designate separate action for assertions when assuming gcp service accounts (#2127)"}, {"oid": "523f7f753fa2a4a112ae4fb7a5389203af8b9594", "committedDate": "2023-05-29 08:52:21 -0700", "message": "fix role update on expiration and review dates (#2185)"}, {"oid": "7069bf871635c4e5308d37341904241388b1ccda", "committedDate": "2023-05-30 15:31:26 -0700", "message": "support product id (string) format association with domains (#2193)"}, {"oid": "368d0bc139931c03d31824c4f02394b38e3ead95", "committedDate": "2023-06-02 13:15:05 -0700", "message": "support headless user type - managed by user authority but treated like service (#2197)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxNDc0MA==", "url": "https://github.com/AthenZ/athenz/pull/1157#discussion_r511014740", "body": "we should simplify this by calling the updatePrincipal only once. \r\n\r\nnewState = suspended ? Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() : Principal.State.ACTIVE.getValue();\r\nif (con.updatePrincipal(changedPrincipal.getFullName(), newState)) {\r\n    updatedUsers.add(changedPrincipal);\r\n}\r\n\r\n", "bodyText": "we should simplify this by calling the updatePrincipal only once.\nnewState = suspended ? Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() : Principal.State.ACTIVE.getValue();\nif (con.updatePrincipal(changedPrincipal.getFullName(), newState)) {\nupdatedUsers.add(changedPrincipal);\n}", "bodyHTML": "<p dir=\"auto\">we should simplify this by calling the updatePrincipal only once.</p>\n<p dir=\"auto\">newState = suspended ? Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() : Principal.State.ACTIVE.getValue();<br>\nif (con.updatePrincipal(changedPrincipal.getFullName(), newState)) {<br>\nupdatedUsers.add(changedPrincipal);<br>\n}</p>", "author": "havetisyan", "createdAt": "2020-10-23T16:53:29Z", "path": "servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java", "diffHunk": "@@ -6402,6 +6403,147 @@ void enforceGroupUserAuthorityRestrictions(final String domainName, final String\n         }\n     }\n \n+    /**\n+     * This method returns list of Principals based on the state parameter supplied\n+     * @param queriedState state of principal\n+     * @return List of Principals from DB\n+     */\n+    List<Principal> getPrincipals(int queriedState) {\n+        List<Principal> principals = new ArrayList<>();\n+        Principal principal;\n+        try (ObjectStoreConnection con = store.getConnection(true, false)) {\n+           List<String> dbPrincipals = con.getPrincipals(queriedState);\n+            Principal.State principalState = Principal.State.getState(queriedState);\n+           for (String dbPrincipal : dbPrincipals) {\n+               principal = ZMSUtils.createPrincipalForName(dbPrincipal, zmsConfig.getUserDomain(), null);\n+               ((SimplePrincipal) principal).setState(principalState);\n+               principals.add(principal);\n+           }\n+        }\n+        return principals;\n+    }\n+\n+    /**\n+     * This method toggles state for supplied Principals based on the flag in DB\n+     * as well as modifies memberships of all roles and groups of current principal(s)\n+     * @param changedPrincipals List of Principals from User Authority\n+     * @param suspended boolean indicating principal's state\n+     */\n+    void updatePrincipalByStateFromAuthority(List<Principal> changedPrincipals, boolean suspended) {\n+        final String caller = \"updatePrincipalByStateFromAuthority\";\n+        List<Principal> updatedUsers = new ArrayList<>();\n+        if (!changedPrincipals.isEmpty()) {\n+            try (ObjectStoreConnection con = store.getConnection(true, true)) {\n+\n+                // first lets update the new state in DB\n+                for (Principal changedPrincipal : changedPrincipals) {\n+                    updatePrincipalState(suspended, updatedUsers, con, changedPrincipal);\n+                }\n+                // if new state is updated successfully\n+                // then we need to modify all roles and groups where given principal is member of\n+                if (!updatedUsers.isEmpty()) {\n+                    for (Principal updatedUser : updatedUsers) {\n+                        try {\n+                            updateRoleMembershipsByPrincipalState(suspended, caller, con, updatedUser);\n+                            updateGroupMembershipByPrincipalState(suspended, caller, con, updatedUser);\n+                        } catch (ResourceException ex) {\n+                            if (ex.getCode() == ResourceException.NOT_FOUND) {\n+                                continue;\n+                            }\n+                            throw ex;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void updateGroupMembershipByPrincipalState(boolean suspended, String caller, ObjectStoreConnection con, Principal updatedUser) {\n+        List<GroupMember> groupMembersWithUpdatedState;\n+        GroupMember groupMember;\n+        DomainGroupMember domainGroupMember;\n+        Set<GroupMember> updatedGroups = new HashSet<>();\n+\n+        domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n+        if (!domainGroupMember.getMemberGroups().isEmpty()) {\n+            for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n+                groupMember = new GroupMember();\n+                groupMember.setMemberName(updatedUser.getFullName());\n+                if (suspended) {\n+                    groupMember.setSystemDisabled(currentGroup.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                } else {\n+                    groupMember.setSystemDisabled(currentGroup.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                }\n+                groupMembersWithUpdatedState = new ArrayList<>();\n+                groupMembersWithUpdatedState.add(groupMember);\n+\n+                // Following method does Audit entry as well\n+                if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n+                        currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n+                    updatedGroups.add(currentGroup);\n+                }\n+            }\n+            for (GroupMember updatedGM : updatedGroups) {\n+\n+                // update our group and domain time-stamps, and invalidate local cache entry\n+                con.updateGroupModTimestamp(updatedGM.getDomainName(), updatedGM.getGroupName());\n+                con.updateDomainModTimestamp(updatedGM.getDomainName());\n+                cacheStore.invalidate(updatedGM.getDomainName());\n+            }\n+        }\n+    }\n+\n+    private void updateRoleMembershipsByPrincipalState(boolean suspended, String caller, ObjectStoreConnection con, Principal updatedUser) {\n+        RoleMember roleMember;\n+        List<RoleMember> roleMembersWithUpdatedState;\n+        DomainRoleMember domainRoleMember;\n+        Set<MemberRole> updatedRoles = new HashSet<>();\n+\n+        domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n+        if (!domainRoleMember.getMemberRoles().isEmpty()) {\n+            for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n+                roleMember = new RoleMember();\n+                roleMember.setMemberName(updatedUser.getFullName());\n+                if (suspended) {\n+                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                } else {\n+                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                }\n+                roleMembersWithUpdatedState = new ArrayList<>();\n+                roleMembersWithUpdatedState.add(roleMember);\n+\n+                // Following method does Audit entry as well\n+                if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n+                        memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n+                    updatedRoles.add(memberRole);\n+                }\n+            }\n+            for (MemberRole updatedMR : updatedRoles) {\n+\n+                // update our role and domain time-stamps, and invalidate local cache entry\n+                con.updateRoleModTimestamp(updatedMR.getDomainName(), updatedMR.getRoleName());\n+                con.updateDomainModTimestamp(updatedMR.getDomainName());\n+                cacheStore.invalidate(updatedMR.getDomainName());\n+            }\n+        }\n+    }\n+\n+    private void updatePrincipalState(boolean suspended, List<Principal> updatedUsers, ObjectStoreConnection con, Principal changedPrincipal) {\n+        try {\n+            if (suspended) {", "originalCommit": "f2b6979e4235f325d7eea75d6f63d358c03d8d3c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0dff4be75160c89e9e35b4634db11456460fa25f", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 2d11e7268..08f2ee72e 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6497,50 +6512,29 @@ public class DBService implements RolesProvider {\n         RoleMember roleMember;\n         List<RoleMember> roleMembersWithUpdatedState;\n         DomainRoleMember domainRoleMember;\n-        Set<MemberRole> updatedRoles = new HashSet<>();\n-\n+        int newState;\n+        Set<String> updatedDomains = new HashSet<>();\n         domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n         if (!domainRoleMember.getMemberRoles().isEmpty()) {\n             for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n                 roleMember = new RoleMember();\n                 roleMember.setMemberName(updatedUser.getFullName());\n-                if (suspended) {\n-                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                } else {\n-                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                }\n-                roleMembersWithUpdatedState = new ArrayList<>();\n-                roleMembersWithUpdatedState.add(roleMember);\n+                newState = suspended ? memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n+                        memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n+                roleMember.setSystemDisabled(newState);\n+                roleMembersWithUpdatedState = Collections.singletonList(roleMember);\n \n                 // Following method does Audit entry as well\n                 if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n                         memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-                    updatedRoles.add(memberRole);\n+                    con.updateRoleModTimestamp(memberRole.getDomainName(), memberRole.getRoleName());\n+                    updatedDomains.add(memberRole.getDomainName());\n                 }\n             }\n-            for (MemberRole updatedMR : updatedRoles) {\n-\n-                // update our role and domain time-stamps, and invalidate local cache entry\n-                con.updateRoleModTimestamp(updatedMR.getDomainName(), updatedMR.getRoleName());\n-                con.updateDomainModTimestamp(updatedMR.getDomainName());\n-                cacheStore.invalidate(updatedMR.getDomainName());\n-            }\n-        }\n-    }\n-\n-    private void updatePrincipalState(boolean suspended, List<Principal> updatedUsers, ObjectStoreConnection con, Principal changedPrincipal) {\n-        try {\n-            if (suspended) {\n-                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue())) {\n-                    updatedUsers.add(changedPrincipal);\n-                }\n-            } else {\n-                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.ACTIVE.getValue())) {\n-                    updatedUsers.add(changedPrincipal);\n-                }\n-            }\n-        } catch (ResourceException ex) {\n-            LOG.error(\"Exception in updating principal state from Authority {} Moving on.\", ex.getMessage());\n+            updatedDomains.forEach(dom -> {\n+                con.updateDomainModTimestamp(dom);\n+                cacheStore.invalidate(dom);\n+            });\n         }\n     }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 2d11e7268..08f2ee72e 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6497,50 +6512,29 @@ public class DBService implements RolesProvider {\n         RoleMember roleMember;\n         List<RoleMember> roleMembersWithUpdatedState;\n         DomainRoleMember domainRoleMember;\n-        Set<MemberRole> updatedRoles = new HashSet<>();\n-\n+        int newState;\n+        Set<String> updatedDomains = new HashSet<>();\n         domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n         if (!domainRoleMember.getMemberRoles().isEmpty()) {\n             for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n                 roleMember = new RoleMember();\n                 roleMember.setMemberName(updatedUser.getFullName());\n-                if (suspended) {\n-                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                } else {\n-                    roleMember.setSystemDisabled(memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                }\n-                roleMembersWithUpdatedState = new ArrayList<>();\n-                roleMembersWithUpdatedState.add(roleMember);\n+                newState = suspended ? memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n+                        memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n+                roleMember.setSystemDisabled(newState);\n+                roleMembersWithUpdatedState = Collections.singletonList(roleMember);\n \n                 // Following method does Audit entry as well\n                 if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n                         memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-                    updatedRoles.add(memberRole);\n+                    con.updateRoleModTimestamp(memberRole.getDomainName(), memberRole.getRoleName());\n+                    updatedDomains.add(memberRole.getDomainName());\n                 }\n             }\n-            for (MemberRole updatedMR : updatedRoles) {\n-\n-                // update our role and domain time-stamps, and invalidate local cache entry\n-                con.updateRoleModTimestamp(updatedMR.getDomainName(), updatedMR.getRoleName());\n-                con.updateDomainModTimestamp(updatedMR.getDomainName());\n-                cacheStore.invalidate(updatedMR.getDomainName());\n-            }\n-        }\n-    }\n-\n-    private void updatePrincipalState(boolean suspended, List<Principal> updatedUsers, ObjectStoreConnection con, Principal changedPrincipal) {\n-        try {\n-            if (suspended) {\n-                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue())) {\n-                    updatedUsers.add(changedPrincipal);\n-                }\n-            } else {\n-                if (con.updatePrincipal(changedPrincipal.getFullName(), Principal.State.ACTIVE.getValue())) {\n-                    updatedUsers.add(changedPrincipal);\n-                }\n-            }\n-        } catch (ResourceException ex) {\n-            LOG.error(\"Exception in updating principal state from Authority {} Moving on.\", ex.getMessage());\n+            updatedDomains.forEach(dom -> {\n+                con.updateDomainModTimestamp(dom);\n+                cacheStore.invalidate(dom);\n+            });\n         }\n     }\n \n", "next_change": {"commit": "2968c209e870ce57fbdb1fb048a21692d80cfea6", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 08f2ee72e..ebcf806b9 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6538,6 +7757,21 @@ public class DBService implements RolesProvider {\n         }\n     }\n \n+\n+\n+    private void addDomainChangeMessage(ResourceContext ctx, String domainName, String objectName, DomainChangeMessage.ObjectType objectType) {\n+        if (ctx != null) {\n+            ctx.addDomainChangeMessage(new DomainChangeMessage()\n+                .setDomainName(domainName)\n+                .setObjectName(objectName)\n+                .setObjectType(objectType)\n+                .setApiName(ctx.getApiName())\n+                .setPublished(Instant.now().toEpochMilli())\n+                .setMessageId(java.util.UUID.randomUUID().toString())\n+            );\n+        }\n+    }\n+\n     class UserAuthorityFilterEnforcer implements Runnable {\n \n         public UserAuthorityFilterEnforcer() {\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "message": "Merge commit", "committedDate": null}, {"oid": "9a9c82c13d156e06dad8464c3a6c52c8e2bc6b89", "committedDate": "2020-10-26 14:15:03 -0700", "message": "remove sending back deprected members field in roles (#1160)"}, {"oid": "31a0dd7362f585f85992d4ff86fbf975d9d736dd", "committedDate": "2020-10-31 14:59:07 -0700", "message": "add azure_subscription field to domains (#1167)"}, {"oid": "c668f48cec94e2c928581b92ffb517f715a4840f", "committedDate": "2020-11-06 18:05:10 -0800", "message": "handle sys disabled null scenario (#1176)"}, {"oid": "f24d15baaaddc96c85fbceb31fcaded756a69f2e", "committedDate": "2020-11-14 16:51:57 -0800", "message": "role tags - generated code and schema changes (#1179)"}, {"oid": "30e272d8a9ec2649a1d876c1c111cf38e27c1743", "committedDate": "2020-12-07 08:48:58 -0800", "message": "putRoleMeta tags support (#1208)"}, {"oid": "f0e0a91b80250236244db9f8cba79e1def809995", "committedDate": "2020-12-23 15:40:53 -0800", "message": "updating group expiry date (#1221)"}, {"oid": "7a2837c7578ab8d36c62b48ecb1d0079c670616b", "committedDate": "2020-12-29 13:44:04 -0800", "message": "granular authz action for managing role members (#1228)"}, {"oid": "d6a0d659fe96486ffcf31bb93e919656be9eaf89", "committedDate": "2021-01-13 08:15:47 -0800", "message": "domain tags implementation (#1235)"}, {"oid": "3c939966592bf7cc6ff25df12a8d21d4c2c89b2b", "committedDate": "2021-01-19 22:05:22 -0800", "message": "client api update for rich authorization requests and consistent naming of entity objects (#1248)"}, {"oid": "3db6ed7b169fce5bbeaa1fae84ff7881e9a4e435", "committedDate": "2021-01-21 09:17:41 -0800", "message": "limit number of role and domain tags (#1255)"}, {"oid": "218b71958d88fb039dfa6e7c5448c7e4d00cb337", "committedDate": "2021-01-25 17:53:41 -0800", "message": "update domain last modified timestamp after tag update (#1262)"}, {"oid": "bccc5fb4dc1c2407a0293f322c3d97711af4297c", "committedDate": "2021-03-07 18:11:58 -0800", "message": "sonarcloud: method always returns same result (#1329)"}, {"oid": "e421f20094d24075d2cec7ab7adecff7d630a286", "committedDate": "2021-03-16 18:08:03 -0700", "message": "expose new domain attribute: business-service (#1357)"}, {"oid": "7b4afd5d40394226b3aa1af8bf10e90e528091b3", "committedDate": "2021-04-01 14:52:30 -0700", "message": "Add memberExpiryDays and serviceExpiryDays support for groups (#1388)"}, {"oid": "5ab30978cc4fc03e1b3022305f6e14a5a425e9e9", "committedDate": "2021-04-07 16:30:50 -0700", "message": "new DomainMetaStore interface support in ZMS (#1430)"}, {"oid": "9bedde4310d6493406d264422f23e16f33213546", "committedDate": "2021-04-08 09:44:29 -0700", "message": "Add group review days to role (#1428)"}, {"oid": "a554c75c51c5945b0e58ae87866de93ff1d5cfbc", "committedDate": "2021-04-15 12:12:02 -0700", "message": "during provider admin setup, ignore deletes (#1444)"}, {"oid": "1c564548381b3c09ad4214d0f30c667e9cc0d022", "committedDate": "2021-04-30 15:22:51 -0700", "message": "log full policy assertion details during delete operations in audit log (#1469)"}, {"oid": "611ac334bfbc1c43ec20154cf9448b96fae365d6", "committedDate": "2021-05-27 16:30:38 -0700", "message": "handle null contition processDomainTags (#1495)"}, {"oid": "addf4424a5bf842b58558c6f61ac0b46277d9535", "committedDate": "2021-06-07 09:38:12 -0700", "message": "allow role/group review regardless of role/group expiry/reminder settings (#1503)"}, {"oid": "4b39ffbd18da3d10a581fb10209806c97b432d28", "committedDate": "2021-06-09 15:31:17 -0700", "message": "enable role review without setting restrictions (#1512)"}, {"oid": "898ff0aa4fddd1a9ed111496cb9e4acb544605af", "committedDate": "2021-06-14 10:42:10 -0700", "message": "Update Tag Values to include '/', ':' (#1517)"}, {"oid": "cf535673b0a4cbcdc81e17c7def4cb6822edd78c", "committedDate": "2021-06-22 06:44:42 -0700", "message": "Allow system admins to set domain meta attribute business service (#1522)"}, {"oid": "934fc3d7fc859731f4beab3b03b83a15ac717a2d", "committedDate": "2021-06-29 12:57:53 -0700", "message": "assertion condition server changes (#1528)"}, {"oid": "1fa51b852890c1576254be6a8a2b5dbebc89865c", "committedDate": "2021-07-21 14:41:19 -0700", "message": "UI : update error message (#1557)"}, {"oid": "09de45bb794eb5e7c29f705b5ce567c75fde4e84", "committedDate": "2021-07-29 15:49:16 -0700", "message": "multi-version policy - introducing version/active in policy object (#1568)"}, {"oid": "4abff4b9952e4836f79bf3f1934baf8fe2bcebf9", "committedDate": "2021-08-08 11:39:07 -0700", "message": "Disable Reminder Review Notifications By Tag zms.DisableReminderNotifications (#1579)"}, {"oid": "6a1523accc3ec83fe54d78c3d919d9cddbcb1b7e", "committedDate": "2021-08-17 18:32:28 -0700", "message": "fixing the order of updates for assertion condition api operations (#1591)"}, {"oid": "66590f4fc47f899f3990f20895f953074e40f259", "committedDate": "2021-09-10 07:55:42 -0700", "message": "Implement multi-version policies endpoints (#1605)"}, {"oid": "1ad624427917493d31bd1b8ffa6303c4d6353055", "committedDate": "2021-09-10 13:51:19 -0700", "message": "update group last modified when user is deleted (#1613)"}, {"oid": "91b116418656f123dae9a3405cb2e498d4d3aff4", "committedDate": "2021-09-12 09:52:05 +0300", "message": "additional validation checks when processing versioned policies (#1614)"}, {"oid": "2531428956f87774f86721f02b430861ca8897ec", "committedDate": "2021-09-14 09:49:34 +0300", "message": "additional checks when setting a policy version as active (#1615)"}, {"oid": "2968c209e870ce57fbdb1fb048a21692d80cfea6", "committedDate": "2021-10-01 07:25:34 -0700", "message": "rdl publishChangeEvents generator (#1624)"}, {"oid": "8a6960ce9878277c5abda1d104ca070831b36230", "committedDate": "2021-10-03 13:48:03 -0700", "message": "Allow specifying version name when creating new policy (#1630)"}, {"oid": "43f619b31bbd9cc3d388aa7ea29eff889cb1272d", "committedDate": "2021-10-21 08:48:51 -0700", "message": "For role expiry notification - record metrics daily while (#1654)"}, {"oid": "389f984270d7d89070c66096e87fafbcb24a261c", "committedDate": "2021-10-26 08:17:36 -0700", "message": "Group tags implementation (#1660)"}, {"oid": "120ab1fa8e9d33fa793c4254d233a09a2c23d173", "committedDate": "2021-10-29 15:08:28 -0700", "message": "Disable Group Expiry Notifications By Tag zms.DisableReminderNotifications (#1663)"}, {"oid": "1400363e8d698cf08370c89752077ebae043c5be", "committedDate": "2021-12-14 13:48:34 -0800", "message": "correct logging of role principal in audit/access logs"}, {"oid": "c8e3a5c91c5deb9640576cd3496a2af11d572f0b", "committedDate": "2021-12-23 15:03:25 -0800", "message": "protect system admin users from being removed from deleteUser api (#1715)"}, {"oid": "020e06e57b357768260f509f08b75c5c068bce53", "committedDate": "2022-02-07 08:01:55 -0800", "message": "Service Visiblity - Domain Dependencies (#1758)"}, {"oid": "fcbd4128e334a9a42f4579d179cf9578d3f4de99", "committedDate": "2022-02-07 10:12:47 -0800", "message": "support new get-stats endpoint to get per-domain/system stats (#1774)"}, {"oid": "ea831a34a70a0475bea8754cb183741dced98ff2", "committedDate": "2022-02-18 09:17:55 -0800", "message": "update pending member api to support getting list for a domain (#1783)"}, {"oid": "f4229124e8e1898810c7aa7b3a4eff37fddae308", "committedDate": "2022-02-18 12:37:32 -0800", "message": "provide option to skip adding principal when onboarding a resource group (#1787)"}, {"oid": "9081feb4c06a1058c941c67923037203d9318cfa", "committedDate": "2022-02-27 14:10:46 -0800", "message": "Domain Dependency for Tenancy (#1789)"}, {"oid": "a5bb615881583fa6f39621e2ea3bf39d3886340b", "committedDate": "2022-03-03 17:20:00 -0800", "message": "extend template keyword support trust field in roles (#1803)"}, {"oid": "3de182bcbedba89fa2aaba12ab9be49aa2156096", "committedDate": "2022-03-19 09:45:40 -0700", "message": "Add provider webhook for verifying removal (#1816)"}, {"oid": "1b0cff1cb9b8e4a231c5cfb342d76b6aad8e08fc", "committedDate": "2022-04-07 14:34:23 -0700", "message": "no need to update domain's last mod timestamp during put dependency call (#1846)"}, {"oid": "baa68eacd6a6b9bbc70c3423006f92cd47b784d7", "committedDate": "2022-05-19 09:30:02 -0700", "message": "Get Auth History implementation (#1875)"}, {"oid": "bea97b165e28b5b2cc286af62c92e536c9fc3ff2", "committedDate": "2022-06-03 13:50:01 -0700", "message": "AuthHistory - Return dependencies instead of list (#1888)"}, {"oid": "7a313e1d581295ae6c786bbc2ed73bb14da37f7d", "committedDate": "2022-07-21 20:16:24 -0700", "message": "allow management of domain memberPurgeExpiryDays setting value (#1928)"}, {"oid": "f288ed7afb018bc07af02dbe9dc8e05ec0896071", "committedDate": "2022-08-15 22:28:01 -0700", "message": "provide header option to return updated object in response (#1942)"}, {"oid": "949bd0634d328d04736b912a002bdfa7421d9f2b", "committedDate": "2022-08-23 10:28:38 -0700", "message": "fix returning role/group objects when requested by ui (#1945)"}, {"oid": "ab7284c9274f4949d23f88ec0dde7b689c0c6980", "committedDate": "2022-09-05 13:12:17 -0700", "message": "auto purge expired role/group members based on server/domain config (#1941)"}, {"oid": "4ab6e748891a014a8b0a1364de099d3fbf4c7468", "committedDate": "2022-09-21 22:22:48 -0700", "message": "enable readWrite db connection for delete expired members (#1964)"}, {"oid": "d4c733d3e97467a598ba44f0bde5c6a907aa01de", "committedDate": "2022-09-23 13:30:24 -0700", "message": "consistent use of The Athenz Authors copyright in all files (#1967)"}, {"oid": "45dcdab92d9e39d5d561b34ef222f863176cc635", "committedDate": "2022-09-26 12:29:01 -0700", "message": "make server purge expiry member day configurable (#1968)"}, {"oid": "d823cccb5163f950655f3859ade41fe031910588", "committedDate": "2022-10-06 14:20:20 -0700", "message": "fix putServiceIdentity logic to allow update of exising pubKey (#1978)"}, {"oid": "91d38ef548e59e29e69349b8a0f5151456b62a0f", "committedDate": "2022-10-07 15:36:36 -0700", "message": "Use correct object type for role member delete notifications (#1981)"}, {"oid": "1d970ce72c2f81aed5576fff068103bbba022aaf", "committedDate": "2022-11-29 23:50:29 +0200", "message": "add gcp project attribute for domains (#2005)"}, {"oid": "c292a1a2fb6e3a300a3060a6bcea6a96f696932c", "committedDate": "2022-12-13 08:56:43 -0800", "message": "Return the correct response from putMembership/putGroupMembership once a pending member was added (#2023)"}, {"oid": "fc5a206d1cb23dd2bbfd9af7e3125ec270ebc022", "committedDate": "2023-01-10 21:48:12 -0800", "message": "allow domain admins to enable audit flag for new roles/groups (#2032)"}, {"oid": "70850ab1de4055e765cf4ead6946b431900ff8c8", "committedDate": "2023-01-23 16:40:36 -0800", "message": "move cloud provider role generation logic out of dbstore library to dbservice (#2043)"}, {"oid": "0ff7ff4f9658fd42e8ee2161d870a89dce5167e4", "committedDate": "2023-02-02 09:18:32 -0800", "message": "Add a requirement for admin approval to delete members in review-enabled roles (#2053)"}, {"oid": "ff57628b890f53c43fec6dd2cacf98a574c95b2d", "committedDate": "2023-02-08 15:55:32 -0800", "message": "extends group with deleteProtection attribute and pending group membe\u2026 (#2067)"}, {"oid": "bb1d69af70a90aeedc28a46604283064e0dad8de", "committedDate": "2023-02-16 07:44:40 -0800", "message": "add audit enable to role (#2055)"}, {"oid": "4ee14d784973ce7da8aba96b35eefdbc5d61d97b", "committedDate": "2023-03-07 11:34:04 -0800", "message": "make aws/gcp assume role action values configurable (#2090)"}, {"oid": "5216da47ef8bca89ba0eae790f72739d9d73fcc6", "committedDate": "2023-03-09 10:36:29 -0800", "message": "Add optional 'description' to role (#2091)"}, {"oid": "d1b98d4614d62fe34b408cfa1a26fb59674d6494", "committedDate": "2023-03-27 16:46:33 -0700", "message": "store GCP project number along with project id in athenz domain metadata (#2113)"}, {"oid": "715cf96c679e817600a0a25160c96878e5eda735", "committedDate": "2023-03-27 18:01:33 -0700", "message": "special resource for gcp starting with service/ (#2115)"}, {"oid": "6e7342a1e98207b87e3eae45341db281b7b3b9c7", "committedDate": "2023-04-13 14:30:39 -0700", "message": "designate separate action for assertions when assuming gcp service accounts (#2127)"}, {"oid": "523f7f753fa2a4a112ae4fb7a5389203af8b9594", "committedDate": "2023-05-29 08:52:21 -0700", "message": "fix role update on expiration and review dates (#2185)"}, {"oid": "7069bf871635c4e5308d37341904241388b1ccda", "committedDate": "2023-05-30 15:31:26 -0700", "message": "support product id (string) format association with domains (#2193)"}, {"oid": "368d0bc139931c03d31824c4f02394b38e3ead95", "committedDate": "2023-06-02 13:15:05 -0700", "message": "support headless user type - managed by user authority but treated like service (#2197)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxNTExOA==", "url": "https://github.com/AthenZ/athenz/pull/1157#discussion_r511015118", "body": "see the comment in the role section which applies here as well.", "bodyText": "see the comment in the role section which applies here as well.", "bodyHTML": "<p dir=\"auto\">see the comment in the role section which applies here as well.</p>", "author": "havetisyan", "createdAt": "2020-10-23T16:54:17Z", "path": "servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java", "diffHunk": "@@ -6402,6 +6403,147 @@ void enforceGroupUserAuthorityRestrictions(final String domainName, final String\n         }\n     }\n \n+    /**\n+     * This method returns list of Principals based on the state parameter supplied\n+     * @param queriedState state of principal\n+     * @return List of Principals from DB\n+     */\n+    List<Principal> getPrincipals(int queriedState) {\n+        List<Principal> principals = new ArrayList<>();\n+        Principal principal;\n+        try (ObjectStoreConnection con = store.getConnection(true, false)) {\n+           List<String> dbPrincipals = con.getPrincipals(queriedState);\n+            Principal.State principalState = Principal.State.getState(queriedState);\n+           for (String dbPrincipal : dbPrincipals) {\n+               principal = ZMSUtils.createPrincipalForName(dbPrincipal, zmsConfig.getUserDomain(), null);\n+               ((SimplePrincipal) principal).setState(principalState);\n+               principals.add(principal);\n+           }\n+        }\n+        return principals;\n+    }\n+\n+    /**\n+     * This method toggles state for supplied Principals based on the flag in DB\n+     * as well as modifies memberships of all roles and groups of current principal(s)\n+     * @param changedPrincipals List of Principals from User Authority\n+     * @param suspended boolean indicating principal's state\n+     */\n+    void updatePrincipalByStateFromAuthority(List<Principal> changedPrincipals, boolean suspended) {\n+        final String caller = \"updatePrincipalByStateFromAuthority\";\n+        List<Principal> updatedUsers = new ArrayList<>();\n+        if (!changedPrincipals.isEmpty()) {\n+            try (ObjectStoreConnection con = store.getConnection(true, true)) {\n+\n+                // first lets update the new state in DB\n+                for (Principal changedPrincipal : changedPrincipals) {\n+                    updatePrincipalState(suspended, updatedUsers, con, changedPrincipal);\n+                }\n+                // if new state is updated successfully\n+                // then we need to modify all roles and groups where given principal is member of\n+                if (!updatedUsers.isEmpty()) {\n+                    for (Principal updatedUser : updatedUsers) {\n+                        try {\n+                            updateRoleMembershipsByPrincipalState(suspended, caller, con, updatedUser);\n+                            updateGroupMembershipByPrincipalState(suspended, caller, con, updatedUser);\n+                        } catch (ResourceException ex) {\n+                            if (ex.getCode() == ResourceException.NOT_FOUND) {\n+                                continue;\n+                            }\n+                            throw ex;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void updateGroupMembershipByPrincipalState(boolean suspended, String caller, ObjectStoreConnection con, Principal updatedUser) {\n+        List<GroupMember> groupMembersWithUpdatedState;\n+        GroupMember groupMember;\n+        DomainGroupMember domainGroupMember;\n+        Set<GroupMember> updatedGroups = new HashSet<>();\n+\n+        domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n+        if (!domainGroupMember.getMemberGroups().isEmpty()) {\n+            for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n+                groupMember = new GroupMember();\n+                groupMember.setMemberName(updatedUser.getFullName());\n+                if (suspended) {\n+                    groupMember.setSystemDisabled(currentGroup.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                } else {\n+                    groupMember.setSystemDisabled(currentGroup.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                }\n+                groupMembersWithUpdatedState = new ArrayList<>();\n+                groupMembersWithUpdatedState.add(groupMember);\n+\n+                // Following method does Audit entry as well\n+                if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n+                        currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n+                    updatedGroups.add(currentGroup);", "originalCommit": "f2b6979e4235f325d7eea75d6f63d358c03d8d3c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0dff4be75160c89e9e35b4634db11456460fa25f", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 2d11e7268..08f2ee72e 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6462,34 +6482,29 @@ public class DBService implements RolesProvider {\n         List<GroupMember> groupMembersWithUpdatedState;\n         GroupMember groupMember;\n         DomainGroupMember domainGroupMember;\n-        Set<GroupMember> updatedGroups = new HashSet<>();\n-\n+        int newState;\n+        Set<String> updatedDomains = new HashSet<>();\n         domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n         if (!domainGroupMember.getMemberGroups().isEmpty()) {\n             for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n                 groupMember = new GroupMember();\n                 groupMember.setMemberName(updatedUser.getFullName());\n-                if (suspended) {\n-                    groupMember.setSystemDisabled(currentGroup.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                } else {\n-                    groupMember.setSystemDisabled(currentGroup.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                }\n-                groupMembersWithUpdatedState = new ArrayList<>();\n-                groupMembersWithUpdatedState.add(groupMember);\n+                newState = suspended ? currentGroup.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n+                        currentGroup.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n+                groupMember.setSystemDisabled(newState);\n+                groupMembersWithUpdatedState = Collections.singletonList(groupMember);\n \n                 // Following method does Audit entry as well\n                 if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n                         currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-                    updatedGroups.add(currentGroup);\n+                    con.updateGroupModTimestamp(currentGroup.getDomainName(), currentGroup.getGroupName());\n+                    updatedDomains.add(currentGroup.getDomainName());\n                 }\n             }\n-            for (GroupMember updatedGM : updatedGroups) {\n-\n-                // update our group and domain time-stamps, and invalidate local cache entry\n-                con.updateGroupModTimestamp(updatedGM.getDomainName(), updatedGM.getGroupName());\n-                con.updateDomainModTimestamp(updatedGM.getDomainName());\n-                cacheStore.invalidate(updatedGM.getDomainName());\n-            }\n+            updatedDomains.forEach(dom -> {\n+                con.updateDomainModTimestamp(dom);\n+                cacheStore.invalidate(dom);\n+            });\n         }\n     }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 2d11e7268..08f2ee72e 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6462,34 +6482,29 @@ public class DBService implements RolesProvider {\n         List<GroupMember> groupMembersWithUpdatedState;\n         GroupMember groupMember;\n         DomainGroupMember domainGroupMember;\n-        Set<GroupMember> updatedGroups = new HashSet<>();\n-\n+        int newState;\n+        Set<String> updatedDomains = new HashSet<>();\n         domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n         if (!domainGroupMember.getMemberGroups().isEmpty()) {\n             for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n                 groupMember = new GroupMember();\n                 groupMember.setMemberName(updatedUser.getFullName());\n-                if (suspended) {\n-                    groupMember.setSystemDisabled(currentGroup.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                } else {\n-                    groupMember.setSystemDisabled(currentGroup.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                }\n-                groupMembersWithUpdatedState = new ArrayList<>();\n-                groupMembersWithUpdatedState.add(groupMember);\n+                newState = suspended ? currentGroup.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n+                        currentGroup.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n+                groupMember.setSystemDisabled(newState);\n+                groupMembersWithUpdatedState = Collections.singletonList(groupMember);\n \n                 // Following method does Audit entry as well\n                 if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n                         currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-                    updatedGroups.add(currentGroup);\n+                    con.updateGroupModTimestamp(currentGroup.getDomainName(), currentGroup.getGroupName());\n+                    updatedDomains.add(currentGroup.getDomainName());\n                 }\n             }\n-            for (GroupMember updatedGM : updatedGroups) {\n-\n-                // update our group and domain time-stamps, and invalidate local cache entry\n-                con.updateGroupModTimestamp(updatedGM.getDomainName(), updatedGM.getGroupName());\n-                con.updateDomainModTimestamp(updatedGM.getDomainName());\n-                cacheStore.invalidate(updatedGM.getDomainName());\n-            }\n+            updatedDomains.forEach(dom -> {\n+                con.updateDomainModTimestamp(dom);\n+                cacheStore.invalidate(dom);\n+            });\n         }\n     }\n \n", "next_change": {"commit": "c668f48cec94e2c928581b92ffb517f715a4840f", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 08f2ee72e..824e0aa8a 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6512,15 +6483,19 @@ public class DBService implements RolesProvider {\n         RoleMember roleMember;\n         List<RoleMember> roleMembersWithUpdatedState;\n         DomainRoleMember domainRoleMember;\n-        int newState;\n+        int newState, oldState;\n         Set<String> updatedDomains = new HashSet<>();\n         domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n         if (!domainRoleMember.getMemberRoles().isEmpty()) {\n             for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n                 roleMember = new RoleMember();\n                 roleMember.setMemberName(updatedUser.getFullName());\n-                newState = suspended ? memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n-                        memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n+                oldState = 0;\n+                if (memberRole.getSystemDisabled() != null) {\n+                    oldState = memberRole.getSystemDisabled();\n+                }\n+                newState = suspended ? oldState | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n+                        oldState & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n                 roleMember.setSystemDisabled(newState);\n                 roleMembersWithUpdatedState = Collections.singletonList(roleMember);\n \n", "next_change": {"commit": "a5bb615881583fa6f39621e2ea3bf39d3886340b", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 824e0aa8a..8274a1809 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6446,61 +7563,487 @@ public class DBService implements RolesProvider {\n         }\n     }\n \n-    private void updateGroupMembershipByPrincipalState(boolean suspended, String caller, ObjectStoreConnection con, Principal updatedUser) {\n-        List<GroupMember> groupMembersWithUpdatedState;\n-        GroupMember groupMember;\n-        DomainGroupMember domainGroupMember;\n-        int newState, oldState;\n-        Set<String> updatedDomains = new HashSet<>();\n-        domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n-        if (!domainGroupMember.getMemberGroups().isEmpty()) {\n-            for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n-                groupMember = new GroupMember();\n-                groupMember.setMemberName(updatedUser.getFullName());\n-                oldState = 0;\n-                if (groupMember.getSystemDisabled() != null) {\n-                    oldState = groupMember.getSystemDisabled();\n-                }\n-                newState = suspended ? oldState | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n-                        oldState & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n-                groupMember.setSystemDisabled(newState);\n-                groupMembersWithUpdatedState = Collections.singletonList(groupMember);\n-                // Following method does Audit entry as well\n-                if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n-                        currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-                    con.updateGroupModTimestamp(currentGroup.getDomainName(), currentGroup.getGroupName());\n-                    updatedDomains.add(currentGroup.getDomainName());\n-                }\n-            }\n-            updatedDomains.forEach(dom -> {\n-                con.updateDomainModTimestamp(dom);\n-                cacheStore.invalidate(dom);\n-            });\n-        }\n-    }\n+    void executePutAssertionConditions(ResourceContext ctx, String domainName, String policyName, long assertionId,\n+                                       AssertionConditions assertionConditions, String auditRef, String caller) {\n \n-    private void updateRoleMembershipsByPrincipalState(boolean suspended, String caller, ObjectStoreConnection con, Principal updatedUser) {\n-        RoleMember roleMember;\n-        List<RoleMember> roleMembersWithUpdatedState;\n-        DomainRoleMember domainRoleMember;\n-        int newState, oldState;\n-        Set<String> updatedDomains = new HashSet<>();\n-        domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n-        if (!domainRoleMember.getMemberRoles().isEmpty()) {\n-            for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n-                roleMember = new RoleMember();\n-                roleMember.setMemberName(updatedUser.getFullName());\n-                oldState = 0;\n-                if (memberRole.getSystemDisabled() != null) {\n-                    oldState = memberRole.getSystemDisabled();\n-                }\n-                newState = suspended ? oldState | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n-                        oldState & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n-                roleMember.setSystemDisabled(newState);\n-                roleMembersWithUpdatedState = Collections.singletonList(roleMember);\n+        // our exception handling code does the check for retry count\n+        // and throws the exception it had received when the retry\n+        // count reaches 0\n \n-                // Following method does Audit entry as well\n-                if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n+        for (int retryCount = defaultRetryCount; ; retryCount--) {\n+\n+            try (ObjectStoreConnection con = store.getConnection(false, true)) {\n+\n+                // first verify that auditing requirements are met\n+\n+                checkDomainAuditEnabled(con, domainName, auditRef, caller, getPrincipalName(ctx), AUDIT_TYPE_POLICY);\n+\n+                // now we need verify our quota check\n+\n+                quotaCheck.checkAssertionConditionsQuota(con, assertionId, assertionConditions, caller);\n+\n+                // process our insert assertion condition.\n+\n+                if (!con.insertAssertionConditions(assertionId, assertionConditions)) {\n+                    throw ZMSUtils.requestError(String.format(\"%s: unable to insert assertion conditions for policy=%s assertionId=%d\", caller, policyName, assertionId), caller);\n+                }\n+\n+                // update our policy and domain time-stamps, and invalidate local cache entry\n+\n+                con.updatePolicyModTimestamp(domainName, policyName, null);\n+                saveChanges(con, domainName);\n+\n+\n+                // audit log the request\n+                StringBuilder auditDetails = new StringBuilder(ZMSConsts.STRING_BLDR_SIZE_DEFAULT);\n+                auditDetails.append(\"{\\\"policy\\\": \\\"\").append(policyName)\n+                        .append(\"\\\", \\\"assertionId\\\": \").append(assertionId)\n+                        .append(\", \");\n+                auditLogAssertionConditions(auditDetails, assertionConditions.getConditionsList(), \"new-assertion-conditions\");\n+                auditDetails.append(\"}\");\n+\n+                auditLogRequest(ctx, domainName, auditRef, caller, ZMSConsts.HTTP_PUT,\n+                        policyName, auditDetails.toString());\n+\n+                // add domain change event\n+                addDomainChangeMessage(ctx, domainName, policyName, DomainChangeMessage.ObjectType.POLICY);\n+                \n+                return;\n+\n+            } catch (ResourceException ex) {\n+\n+                // otherwise check if we need to retry or return failure\n+                if (!shouldRetryOperation(ex, retryCount)) {\n+                    throw ex;\n+                }\n+            }\n+        }\n+    }\n+\n+    void executePutAssertionCondition(ResourceContext ctx, String domainName, String policyName, long assertionId,\n+                                      AssertionCondition assertionCondition, String auditRef, String caller) {\n+\n+        // our exception handling code does the check for retry count\n+        // and throws the exception it had received when the retry\n+        // count reaches 0\n+\n+        for (int retryCount = defaultRetryCount; ; retryCount--) {\n+\n+            try (ObjectStoreConnection con = store.getConnection(false, true)) {\n+\n+                // first verify that auditing requirements are met\n+\n+                checkDomainAuditEnabled(con, domainName, auditRef, caller, getPrincipalName(ctx), AUDIT_TYPE_POLICY);\n+\n+                // process our insert assertion condition.\n+\n+                if (assertionCondition.getId() == null) {\n+\n+                    // now we need verify our quota check\n+                    quotaCheck.checkAssertionConditionQuota(con, assertionId, assertionCondition, caller);\n+\n+                    // no condition id in the request. so we are going to generate the next condition id for\n+                    // the given assertion id and then use it to insert given keys\n+                    assertionCondition.setId(con.getNextConditionId(assertionId, caller));\n+                    if (!con.insertAssertionCondition(assertionId, assertionCondition)) {\n+                        throw ZMSUtils.requestError(String.format(\"%s: unable to insert new assertion condition for policy=%s assertionId=%d\", caller, policyName, assertionId), caller);\n+                    }\n+                } else {\n+\n+                    // existing assertion condition keys found with given condition id. so delete existing keys from DB for the given condition id\n+                    if (!con.deleteAssertionCondition(assertionId, assertionCondition.getId())) {\n+                        throw ZMSUtils.notFoundError(String.format(\"%s: unable to delete assertion condition during putAssertionCondition for policy=%s assertionId=%d conditionId=%d\"\n+                                , caller, policyName, assertionId, assertionCondition.getId()), caller);\n+                    }\n+                    // now we need verify our quota check after deleting the old entries\n+                    quotaCheck.checkAssertionConditionQuota(con, assertionId, assertionCondition, caller);\n+\n+                    // now insert the new keys against existing condition id\n+                    if (!con.insertAssertionCondition(assertionId, assertionCondition)) {\n+                        throw ZMSUtils.requestError(String.format(\"%s: unable to insert assertion condition for policy=%s assertionId=%d\", caller, policyName, assertionId), caller);\n+                    }\n+                }\n+\n+                // update our policy and domain time-stamps, and invalidate local cache entry\n+\n+                con.updatePolicyModTimestamp(domainName, policyName, null);\n+                saveChanges(con, domainName);\n+\n+\n+                // audit log the request\n+                StringBuilder auditDetails = new StringBuilder(ZMSConsts.STRING_BLDR_SIZE_DEFAULT);\n+                auditDetails.append(\"{\\\"policy\\\": \\\"\").append(policyName)\n+                        .append(\"\\\", \\\"assertionId\\\": \").append(assertionId)\n+                        .append(\", \\\"new-assertion-condition\\\": \");\n+                auditLogAssertionCondition(auditDetails, assertionCondition, true);\n+                auditDetails.append(\"}\");\n+\n+                auditLogRequest(ctx, domainName, auditRef, caller, ZMSConsts.HTTP_PUT,\n+                        policyName, auditDetails.toString());\n+\n+                // add domain change event\n+                addDomainChangeMessage(ctx, domainName, policyName, DomainChangeMessage.ObjectType.POLICY);\n+                \n+                return;\n+\n+            } catch (ResourceException ex) {\n+\n+                // otherwise check if we need to retry or return failure\n+                if (!shouldRetryOperation(ex, retryCount)) {\n+                    throw ex;\n+                }\n+            }\n+        }\n+    }\n+\n+    public void executeDeleteAssertionConditions(ResourceContext ctx, String domainName, String policyName, Long assertionId, String auditRef, String caller) {\n+\n+        // our exception handling code does the check for retry count\n+        // and throws the exception it had received when the retry\n+        // count reaches 0\n+\n+        for (int retryCount = defaultRetryCount; ; retryCount--) {\n+\n+            try (ObjectStoreConnection con = store.getConnection(true, true)) {\n+\n+                // first verify that auditing requirements are met\n+\n+                checkDomainAuditEnabled(con, domainName, auditRef, caller, getPrincipalName(ctx), AUDIT_TYPE_POLICY);\n+\n+                // fetch the assertion for our audit log\n+\n+                List<AssertionCondition> assertionConditions = con.getAssertionConditions(assertionId);\n+                if (assertionConditions == null) {\n+                    throw ZMSUtils.notFoundError(String.format(\"%s: unable to read assertion conditions for policy=%s assertionId=%d\", caller,\n+                            policyName, assertionId), caller);\n+                }\n+\n+                // process our delete assertion conditions. since this is a \"single\"\n+                // operation, we are not using any transactions.\n+\n+                if (!con.deleteAssertionConditions(assertionId)) {\n+                    throw ZMSUtils.notFoundError(String.format(\"%s: unable to delete assertion conditions for policy=%s assertionId=%d\", caller,\n+                            policyName, assertionId), caller);\n+                }\n+\n+                // update our policy and domain time-stamps, and invalidate local cache entry\n+\n+                con.updatePolicyModTimestamp(domainName, policyName, null);\n+                con.updateDomainModTimestamp(domainName);\n+                cacheStore.invalidate(domainName);\n+\n+                // audit log the request\n+\n+                StringBuilder auditDetails = new StringBuilder(ZMSConsts.STRING_BLDR_SIZE_DEFAULT);\n+                auditDetails.append(\"{\\\"policy\\\": \\\"\").append(policyName)\n+                        .append(\"\\\", \\\"assertionId\\\": \").append(assertionId)\n+                        .append(\", \");\n+                auditLogAssertionConditions(auditDetails, assertionConditions, \"deleted-assertion-conditions\");\n+                auditDetails.append(\"}\");\n+\n+                auditLogRequest(ctx, domainName, auditRef, caller, ZMSConsts.HTTP_DELETE,\n+                        policyName, auditDetails.toString());\n+\n+                // add domain change event\n+                addDomainChangeMessage(ctx, domainName, policyName, DomainChangeMessage.ObjectType.POLICY);\n+                \n+                return;\n+\n+            } catch (ResourceException ex) {\n+\n+                // otherwise check if we need to retry or return failure\n+\n+                if (!shouldRetryOperation(ex, retryCount)) {\n+                    throw ex;\n+                }\n+            }\n+        }\n+    }\n+\n+    public void executeDeleteAssertionCondition(ResourceContext ctx, String domainName, String policyName, Long assertionId, Integer conditionId, String auditRef, String caller) {\n+        // our exception handling code does the check for retry count\n+        // and throws the exception it had received when the retry\n+        // count reaches 0\n+\n+        for (int retryCount = defaultRetryCount; ; retryCount--) {\n+\n+            try (ObjectStoreConnection con = store.getConnection(true, true)) {\n+\n+                // first verify that auditing requirements are met\n+\n+                checkDomainAuditEnabled(con, domainName, auditRef, caller, getPrincipalName(ctx), AUDIT_TYPE_POLICY);\n+\n+                // fetch the assertion for our audit log\n+\n+                AssertionCondition assertionCondition = con.getAssertionCondition(assertionId, conditionId);\n+                if (assertionCondition == null) {\n+                    throw ZMSUtils.notFoundError(String.format(\"%s: unable to read assertion condition for policy=%s assertionId=%d conditionId=%d\"\n+                            , caller, policyName, assertionId, conditionId), caller);\n+                }\n+\n+                // process our delete assertion condition. since this is a \"single\"\n+                // operation, we are not using any transactions.\n+\n+                if (!con.deleteAssertionCondition(assertionId, conditionId)) {\n+                    throw ZMSUtils.notFoundError(String.format(\"%s: unable to delete assertion condition for policy=%s assertionId=%d conditionId=%d\"\n+                            , caller, policyName, assertionId, conditionId), caller);\n+                }\n+\n+                // update our policy and domain time-stamps, and invalidate local cache entry\n+\n+                con.updatePolicyModTimestamp(domainName, policyName, null);\n+                con.updateDomainModTimestamp(domainName);\n+                cacheStore.invalidate(domainName);\n+\n+                // audit log the request\n+\n+                StringBuilder auditDetails = new StringBuilder(ZMSConsts.STRING_BLDR_SIZE_DEFAULT);\n+                auditDetails.append(\"{\\\"policy\\\": \\\"\").append(policyName)\n+                        .append(\"\\\", \\\"assertionId\\\": \").append(assertionId)\n+                        .append(\", \\\"deleted-assertion-condition\\\": \");\n+                auditLogAssertionCondition(auditDetails, assertionCondition, true);\n+                auditDetails.append(\"}\");\n+\n+                auditLogRequest(ctx, domainName, auditRef, caller, ZMSConsts.HTTP_DELETE,\n+                        policyName, auditDetails.toString());\n+\n+                // add domain change event\n+                addDomainChangeMessage(ctx, domainName, policyName, DomainChangeMessage.ObjectType.POLICY);\n+                \n+                return;\n+\n+            } catch (ResourceException ex) {\n+\n+                // otherwise check if we need to retry or return failure\n+\n+                if (!shouldRetryOperation(ex, retryCount)) {\n+                    throw ex;\n+                }\n+            }\n+        }\n+    }\n+\n+    public void putDomainDependency(ResourceContext ctx, String domainName, String service, String auditRef, String caller) {\n+\n+        // our exception handling code does the check for retry count\n+        // and throws the exception it had received when the retry\n+        // count reaches 0\n+\n+        for (int retryCount = defaultRetryCount; ; retryCount--) {\n+\n+            try (ObjectStoreConnection con = store.getConnection(false, true)) {\n+\n+                final String principal = getPrincipalName(ctx);\n+\n+                // first verify that auditing requirements are met\n+\n+                checkDomainAuditEnabled(con, domainName, auditRef, caller, principal, AUDIT_TYPE_DOMAIN);\n+\n+                // verify domain exists\n+\n+                Domain domain = con.getDomain(domainName);\n+                if (domain == null) {\n+                    con.rollbackChanges();\n+                    throw ZMSUtils.notFoundError(caller + \": Unknown domain: \" + domainName, caller);\n+                }\n+\n+                // now process the request\n+\n+                StringBuilder auditDetails = new StringBuilder(ZMSConsts.STRING_BLDR_SIZE_DEFAULT);\n+                if (!processDomainDependency(con, domainName, service, auditDetails)) {\n+                    con.rollbackChanges();\n+                    throw ZMSUtils.internalServerError(\"unable to put dependency on domain \" + domainName + \" for service \" + service, caller);\n+                }\n+\n+                // update our domain time-stamp and save changes\n+\n+                saveChanges(con, domainName);\n+\n+                // audit log the request\n+\n+                auditLogRequest(ctx, domainName, auditRef, caller, ZMSConsts.HTTP_PUT,\n+                        service, auditDetails.toString());\n+\n+                // add domain change event\n+                addDomainChangeMessage(ctx, domainName, service, DomainChangeMessage.ObjectType.DOMAIN);\n+\n+                return;\n+\n+            } catch (ResourceException ex) {\n+                if (!shouldRetryOperation(ex, retryCount)) {\n+                    throw ex;\n+                }\n+            }\n+        }\n+    }\n+\n+    public void deleteDomainDependency(ResourceContext ctx, String domainName, String service, String auditRef, String caller) {\n+\n+        // our exception handling code does the check for retry count\n+        // and throws the exception it had received when the retry\n+        // count reaches 0\n+\n+        for (int retryCount = defaultRetryCount; ; retryCount--) {\n+\n+            try (ObjectStoreConnection con = store.getConnection(false, true)) {\n+\n+                final String principal = getPrincipalName(ctx);\n+\n+                // first verify that auditing requirements are met\n+\n+                checkDomainAuditEnabled(con, domainName, auditRef, caller, principal, AUDIT_TYPE_DOMAIN);\n+\n+                // verify domain exists\n+\n+                Domain domain = con.getDomain(domainName);\n+                if (domain == null) {\n+                    con.rollbackChanges();\n+                    throw ZMSUtils.notFoundError(caller + \": Unknown domain: \" + domainName, caller);\n+                }\n+\n+                // now process the request\n+\n+                StringBuilder auditDetails = new StringBuilder(ZMSConsts.STRING_BLDR_SIZE_DEFAULT);\n+                if (!processDeleteDomainDependency(con, domainName, service, auditDetails)) {\n+                    con.rollbackChanges();\n+                    throw ZMSUtils.internalServerError(\"unable to delete dependency on domain \" + domainName + \" for service \" + service, caller);\n+                }\n+\n+                // update our domain time-stamp and save changes\n+\n+                saveChanges(con, domainName);\n+\n+                // audit log the request\n+\n+                auditLogRequest(ctx, domainName, auditRef, caller, ZMSConsts.HTTP_DELETE,\n+                        service, auditDetails.toString());\n+\n+                // add domain change event\n+                addDomainChangeMessage(ctx, domainName, service, DomainChangeMessage.ObjectType.DOMAIN);\n+\n+                return;\n+\n+            } catch (ResourceException ex) {\n+                if (!shouldRetryOperation(ex, retryCount)) {\n+                    throw ex;\n+                }\n+            }\n+        }\n+    }\n+\n+    private boolean processDomainDependency(ObjectStoreConnection con, String domainName, String service,\n+                                            StringBuilder auditDetails) {\n+\n+        boolean requestSuccess = con.insertDomainDependency(domainName, service);\n+\n+        // if we didn't insert a dependency then we need to return failure\n+\n+        if (!requestSuccess) {\n+            return false;\n+        }\n+\n+        // open our audit record and log the dependency\n+\n+        auditDetails.append(\"{\\\"domain-dependencies\\\": \");\n+        auditDetails.append(\"{\\\"domain\\\": \\\"\").append(domainName)\n+                .append(\"\\\", \\\"service\\\": \\\"\").append(service).append(\"\\\"}\")\n+                .append('}');\n+\n+        return true;\n+    }\n+\n+    private boolean processDeleteDomainDependency(ObjectStoreConnection con, String domainName, String service,\n+                                                  StringBuilder auditDetails) {\n+\n+        boolean requestSuccess = con.deleteDomainDependency(domainName, service);\n+\n+        // if we didn't delete the dependency then we need to return failure\n+\n+        if (!requestSuccess) {\n+            return false;\n+        }\n+\n+        // open our audit record and log the dependency\n+\n+        auditDetails.append(\"{\\\"delete-domain-dependencies\\\": \");\n+        auditDetails.append(\"{\\\"domain\\\": \\\"\").append(domainName)\n+                .append(\"\\\", \\\"service\\\": \\\"\").append(service).append(\"\\\"}\")\n+                .append('}');\n+\n+        return true;\n+    }\n+\n+    public ServiceIdentityList listServiceDependencies(String domainName) {\n+        try (ObjectStoreConnection con = store.getConnection(true, false)) {\n+            ServiceIdentityList serviceIdentityList = new ServiceIdentityList();\n+            serviceIdentityList.setNames(con.listServiceDependencies(domainName));\n+            return serviceIdentityList;\n+        }\n+    }\n+\n+    public DomainList listDomainDependencies(String service) {\n+        try (ObjectStoreConnection con = store.getConnection(true, false)) {\n+            DomainList domainList = new DomainList();\n+            domainList.setNames(con.listDomainDependencies(service));\n+            return domainList;\n+        }\n+    }\n+\n+    private void updateGroupMembershipByPrincipalState(boolean suspended, String caller, ObjectStoreConnection con, Principal updatedUser) {\n+        List<GroupMember> groupMembersWithUpdatedState;\n+        GroupMember groupMember;\n+        DomainGroupMember domainGroupMember;\n+        int newState, oldState;\n+        Set<String> updatedDomains = new HashSet<>();\n+        domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n+        if (!domainGroupMember.getMemberGroups().isEmpty()) {\n+            for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n+                groupMember = new GroupMember();\n+                groupMember.setMemberName(updatedUser.getFullName());\n+                oldState = 0;\n+                if (groupMember.getSystemDisabled() != null) {\n+                    oldState = groupMember.getSystemDisabled();\n+                }\n+                newState = suspended ? oldState | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n+                        oldState & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n+                groupMember.setSystemDisabled(newState);\n+                groupMembersWithUpdatedState = Collections.singletonList(groupMember);\n+                // Following method does Audit entry as well\n+                if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n+                        currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n+                    con.updateGroupModTimestamp(currentGroup.getDomainName(), currentGroup.getGroupName());\n+                    updatedDomains.add(currentGroup.getDomainName());\n+                }\n+            }\n+            updatedDomains.forEach(dom -> {\n+                con.updateDomainModTimestamp(dom);\n+                cacheStore.invalidate(dom);\n+            });\n+        }\n+    }\n+\n+    private void updateRoleMembershipsByPrincipalState(boolean suspended, String caller, ObjectStoreConnection con, Principal updatedUser) {\n+        RoleMember roleMember;\n+        List<RoleMember> roleMembersWithUpdatedState;\n+        DomainRoleMember domainRoleMember;\n+        int newState, oldState;\n+        Set<String> updatedDomains = new HashSet<>();\n+        domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n+        if (!domainRoleMember.getMemberRoles().isEmpty()) {\n+            for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n+                roleMember = new RoleMember();\n+                roleMember.setMemberName(updatedUser.getFullName());\n+                oldState = 0;\n+                if (memberRole.getSystemDisabled() != null) {\n+                    oldState = memberRole.getSystemDisabled();\n+                }\n+                newState = suspended ? oldState | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n+                        oldState & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n+                roleMember.setSystemDisabled(newState);\n+                roleMembersWithUpdatedState = Collections.singletonList(roleMember);\n+\n+                // Following method does Audit entry as well\n+                if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n                         memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n                     con.updateRoleModTimestamp(memberRole.getDomainName(), memberRole.getRoleName());\n                     updatedDomains.add(memberRole.getDomainName());\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "message": "Merge commit", "committedDate": null}, {"oid": "9a9c82c13d156e06dad8464c3a6c52c8e2bc6b89", "committedDate": "2020-10-26 14:15:03 -0700", "message": "remove sending back deprected members field in roles (#1160)"}, {"oid": "31a0dd7362f585f85992d4ff86fbf975d9d736dd", "committedDate": "2020-10-31 14:59:07 -0700", "message": "add azure_subscription field to domains (#1167)"}, {"oid": "c668f48cec94e2c928581b92ffb517f715a4840f", "committedDate": "2020-11-06 18:05:10 -0800", "message": "handle sys disabled null scenario (#1176)"}, {"oid": "f24d15baaaddc96c85fbceb31fcaded756a69f2e", "committedDate": "2020-11-14 16:51:57 -0800", "message": "role tags - generated code and schema changes (#1179)"}, {"oid": "30e272d8a9ec2649a1d876c1c111cf38e27c1743", "committedDate": "2020-12-07 08:48:58 -0800", "message": "putRoleMeta tags support (#1208)"}, {"oid": "f0e0a91b80250236244db9f8cba79e1def809995", "committedDate": "2020-12-23 15:40:53 -0800", "message": "updating group expiry date (#1221)"}, {"oid": "7a2837c7578ab8d36c62b48ecb1d0079c670616b", "committedDate": "2020-12-29 13:44:04 -0800", "message": "granular authz action for managing role members (#1228)"}, {"oid": "d6a0d659fe96486ffcf31bb93e919656be9eaf89", "committedDate": "2021-01-13 08:15:47 -0800", "message": "domain tags implementation (#1235)"}, {"oid": "3c939966592bf7cc6ff25df12a8d21d4c2c89b2b", "committedDate": "2021-01-19 22:05:22 -0800", "message": "client api update for rich authorization requests and consistent naming of entity objects (#1248)"}, {"oid": "3db6ed7b169fce5bbeaa1fae84ff7881e9a4e435", "committedDate": "2021-01-21 09:17:41 -0800", "message": "limit number of role and domain tags (#1255)"}, {"oid": "218b71958d88fb039dfa6e7c5448c7e4d00cb337", "committedDate": "2021-01-25 17:53:41 -0800", "message": "update domain last modified timestamp after tag update (#1262)"}, {"oid": "bccc5fb4dc1c2407a0293f322c3d97711af4297c", "committedDate": "2021-03-07 18:11:58 -0800", "message": "sonarcloud: method always returns same result (#1329)"}, {"oid": "e421f20094d24075d2cec7ab7adecff7d630a286", "committedDate": "2021-03-16 18:08:03 -0700", "message": "expose new domain attribute: business-service (#1357)"}, {"oid": "7b4afd5d40394226b3aa1af8bf10e90e528091b3", "committedDate": "2021-04-01 14:52:30 -0700", "message": "Add memberExpiryDays and serviceExpiryDays support for groups (#1388)"}, {"oid": "5ab30978cc4fc03e1b3022305f6e14a5a425e9e9", "committedDate": "2021-04-07 16:30:50 -0700", "message": "new DomainMetaStore interface support in ZMS (#1430)"}, {"oid": "9bedde4310d6493406d264422f23e16f33213546", "committedDate": "2021-04-08 09:44:29 -0700", "message": "Add group review days to role (#1428)"}, {"oid": "a554c75c51c5945b0e58ae87866de93ff1d5cfbc", "committedDate": "2021-04-15 12:12:02 -0700", "message": "during provider admin setup, ignore deletes (#1444)"}, {"oid": "1c564548381b3c09ad4214d0f30c667e9cc0d022", "committedDate": "2021-04-30 15:22:51 -0700", "message": "log full policy assertion details during delete operations in audit log (#1469)"}, {"oid": "611ac334bfbc1c43ec20154cf9448b96fae365d6", "committedDate": "2021-05-27 16:30:38 -0700", "message": "handle null contition processDomainTags (#1495)"}, {"oid": "addf4424a5bf842b58558c6f61ac0b46277d9535", "committedDate": "2021-06-07 09:38:12 -0700", "message": "allow role/group review regardless of role/group expiry/reminder settings (#1503)"}, {"oid": "4b39ffbd18da3d10a581fb10209806c97b432d28", "committedDate": "2021-06-09 15:31:17 -0700", "message": "enable role review without setting restrictions (#1512)"}, {"oid": "898ff0aa4fddd1a9ed111496cb9e4acb544605af", "committedDate": "2021-06-14 10:42:10 -0700", "message": "Update Tag Values to include '/', ':' (#1517)"}, {"oid": "cf535673b0a4cbcdc81e17c7def4cb6822edd78c", "committedDate": "2021-06-22 06:44:42 -0700", "message": "Allow system admins to set domain meta attribute business service (#1522)"}, {"oid": "934fc3d7fc859731f4beab3b03b83a15ac717a2d", "committedDate": "2021-06-29 12:57:53 -0700", "message": "assertion condition server changes (#1528)"}, {"oid": "1fa51b852890c1576254be6a8a2b5dbebc89865c", "committedDate": "2021-07-21 14:41:19 -0700", "message": "UI : update error message (#1557)"}, {"oid": "09de45bb794eb5e7c29f705b5ce567c75fde4e84", "committedDate": "2021-07-29 15:49:16 -0700", "message": "multi-version policy - introducing version/active in policy object (#1568)"}, {"oid": "4abff4b9952e4836f79bf3f1934baf8fe2bcebf9", "committedDate": "2021-08-08 11:39:07 -0700", "message": "Disable Reminder Review Notifications By Tag zms.DisableReminderNotifications (#1579)"}, {"oid": "6a1523accc3ec83fe54d78c3d919d9cddbcb1b7e", "committedDate": "2021-08-17 18:32:28 -0700", "message": "fixing the order of updates for assertion condition api operations (#1591)"}, {"oid": "66590f4fc47f899f3990f20895f953074e40f259", "committedDate": "2021-09-10 07:55:42 -0700", "message": "Implement multi-version policies endpoints (#1605)"}, {"oid": "1ad624427917493d31bd1b8ffa6303c4d6353055", "committedDate": "2021-09-10 13:51:19 -0700", "message": "update group last modified when user is deleted (#1613)"}, {"oid": "91b116418656f123dae9a3405cb2e498d4d3aff4", "committedDate": "2021-09-12 09:52:05 +0300", "message": "additional validation checks when processing versioned policies (#1614)"}, {"oid": "2531428956f87774f86721f02b430861ca8897ec", "committedDate": "2021-09-14 09:49:34 +0300", "message": "additional checks when setting a policy version as active (#1615)"}, {"oid": "2968c209e870ce57fbdb1fb048a21692d80cfea6", "committedDate": "2021-10-01 07:25:34 -0700", "message": "rdl publishChangeEvents generator (#1624)"}, {"oid": "8a6960ce9878277c5abda1d104ca070831b36230", "committedDate": "2021-10-03 13:48:03 -0700", "message": "Allow specifying version name when creating new policy (#1630)"}, {"oid": "43f619b31bbd9cc3d388aa7ea29eff889cb1272d", "committedDate": "2021-10-21 08:48:51 -0700", "message": "For role expiry notification - record metrics daily while (#1654)"}, {"oid": "389f984270d7d89070c66096e87fafbcb24a261c", "committedDate": "2021-10-26 08:17:36 -0700", "message": "Group tags implementation (#1660)"}, {"oid": "120ab1fa8e9d33fa793c4254d233a09a2c23d173", "committedDate": "2021-10-29 15:08:28 -0700", "message": "Disable Group Expiry Notifications By Tag zms.DisableReminderNotifications (#1663)"}, {"oid": "1400363e8d698cf08370c89752077ebae043c5be", "committedDate": "2021-12-14 13:48:34 -0800", "message": "correct logging of role principal in audit/access logs"}, {"oid": "c8e3a5c91c5deb9640576cd3496a2af11d572f0b", "committedDate": "2021-12-23 15:03:25 -0800", "message": "protect system admin users from being removed from deleteUser api (#1715)"}, {"oid": "020e06e57b357768260f509f08b75c5c068bce53", "committedDate": "2022-02-07 08:01:55 -0800", "message": "Service Visiblity - Domain Dependencies (#1758)"}, {"oid": "fcbd4128e334a9a42f4579d179cf9578d3f4de99", "committedDate": "2022-02-07 10:12:47 -0800", "message": "support new get-stats endpoint to get per-domain/system stats (#1774)"}, {"oid": "ea831a34a70a0475bea8754cb183741dced98ff2", "committedDate": "2022-02-18 09:17:55 -0800", "message": "update pending member api to support getting list for a domain (#1783)"}, {"oid": "f4229124e8e1898810c7aa7b3a4eff37fddae308", "committedDate": "2022-02-18 12:37:32 -0800", "message": "provide option to skip adding principal when onboarding a resource group (#1787)"}, {"oid": "9081feb4c06a1058c941c67923037203d9318cfa", "committedDate": "2022-02-27 14:10:46 -0800", "message": "Domain Dependency for Tenancy (#1789)"}, {"oid": "a5bb615881583fa6f39621e2ea3bf39d3886340b", "committedDate": "2022-03-03 17:20:00 -0800", "message": "extend template keyword support trust field in roles (#1803)"}, {"oid": "3de182bcbedba89fa2aaba12ab9be49aa2156096", "committedDate": "2022-03-19 09:45:40 -0700", "message": "Add provider webhook for verifying removal (#1816)"}, {"oid": "1b0cff1cb9b8e4a231c5cfb342d76b6aad8e08fc", "committedDate": "2022-04-07 14:34:23 -0700", "message": "no need to update domain's last mod timestamp during put dependency call (#1846)"}, {"oid": "baa68eacd6a6b9bbc70c3423006f92cd47b784d7", "committedDate": "2022-05-19 09:30:02 -0700", "message": "Get Auth History implementation (#1875)"}, {"oid": "bea97b165e28b5b2cc286af62c92e536c9fc3ff2", "committedDate": "2022-06-03 13:50:01 -0700", "message": "AuthHistory - Return dependencies instead of list (#1888)"}, {"oid": "7a313e1d581295ae6c786bbc2ed73bb14da37f7d", "committedDate": "2022-07-21 20:16:24 -0700", "message": "allow management of domain memberPurgeExpiryDays setting value (#1928)"}, {"oid": "f288ed7afb018bc07af02dbe9dc8e05ec0896071", "committedDate": "2022-08-15 22:28:01 -0700", "message": "provide header option to return updated object in response (#1942)"}, {"oid": "949bd0634d328d04736b912a002bdfa7421d9f2b", "committedDate": "2022-08-23 10:28:38 -0700", "message": "fix returning role/group objects when requested by ui (#1945)"}, {"oid": "ab7284c9274f4949d23f88ec0dde7b689c0c6980", "committedDate": "2022-09-05 13:12:17 -0700", "message": "auto purge expired role/group members based on server/domain config (#1941)"}, {"oid": "4ab6e748891a014a8b0a1364de099d3fbf4c7468", "committedDate": "2022-09-21 22:22:48 -0700", "message": "enable readWrite db connection for delete expired members (#1964)"}, {"oid": "d4c733d3e97467a598ba44f0bde5c6a907aa01de", "committedDate": "2022-09-23 13:30:24 -0700", "message": "consistent use of The Athenz Authors copyright in all files (#1967)"}, {"oid": "45dcdab92d9e39d5d561b34ef222f863176cc635", "committedDate": "2022-09-26 12:29:01 -0700", "message": "make server purge expiry member day configurable (#1968)"}, {"oid": "d823cccb5163f950655f3859ade41fe031910588", "committedDate": "2022-10-06 14:20:20 -0700", "message": "fix putServiceIdentity logic to allow update of exising pubKey (#1978)"}, {"oid": "91d38ef548e59e29e69349b8a0f5151456b62a0f", "committedDate": "2022-10-07 15:36:36 -0700", "message": "Use correct object type for role member delete notifications (#1981)"}, {"oid": "1d970ce72c2f81aed5576fff068103bbba022aaf", "committedDate": "2022-11-29 23:50:29 +0200", "message": "add gcp project attribute for domains (#2005)"}, {"oid": "c292a1a2fb6e3a300a3060a6bcea6a96f696932c", "committedDate": "2022-12-13 08:56:43 -0800", "message": "Return the correct response from putMembership/putGroupMembership once a pending member was added (#2023)"}, {"oid": "fc5a206d1cb23dd2bbfd9af7e3125ec270ebc022", "committedDate": "2023-01-10 21:48:12 -0800", "message": "allow domain admins to enable audit flag for new roles/groups (#2032)"}, {"oid": "70850ab1de4055e765cf4ead6946b431900ff8c8", "committedDate": "2023-01-23 16:40:36 -0800", "message": "move cloud provider role generation logic out of dbstore library to dbservice (#2043)"}, {"oid": "0ff7ff4f9658fd42e8ee2161d870a89dce5167e4", "committedDate": "2023-02-02 09:18:32 -0800", "message": "Add a requirement for admin approval to delete members in review-enabled roles (#2053)"}, {"oid": "ff57628b890f53c43fec6dd2cacf98a574c95b2d", "committedDate": "2023-02-08 15:55:32 -0800", "message": "extends group with deleteProtection attribute and pending group membe\u2026 (#2067)"}, {"oid": "bb1d69af70a90aeedc28a46604283064e0dad8de", "committedDate": "2023-02-16 07:44:40 -0800", "message": "add audit enable to role (#2055)"}, {"oid": "4ee14d784973ce7da8aba96b35eefdbc5d61d97b", "committedDate": "2023-03-07 11:34:04 -0800", "message": "make aws/gcp assume role action values configurable (#2090)"}, {"oid": "5216da47ef8bca89ba0eae790f72739d9d73fcc6", "committedDate": "2023-03-09 10:36:29 -0800", "message": "Add optional 'description' to role (#2091)"}, {"oid": "d1b98d4614d62fe34b408cfa1a26fb59674d6494", "committedDate": "2023-03-27 16:46:33 -0700", "message": "store GCP project number along with project id in athenz domain metadata (#2113)"}, {"oid": "715cf96c679e817600a0a25160c96878e5eda735", "committedDate": "2023-03-27 18:01:33 -0700", "message": "special resource for gcp starting with service/ (#2115)"}, {"oid": "6e7342a1e98207b87e3eae45341db281b7b3b9c7", "committedDate": "2023-04-13 14:30:39 -0700", "message": "designate separate action for assertions when assuming gcp service accounts (#2127)"}, {"oid": "523f7f753fa2a4a112ae4fb7a5389203af8b9594", "committedDate": "2023-05-29 08:52:21 -0700", "message": "fix role update on expiration and review dates (#2185)"}, {"oid": "7069bf871635c4e5308d37341904241388b1ccda", "committedDate": "2023-05-30 15:31:26 -0700", "message": "support product id (string) format association with domains (#2193)"}, {"oid": "368d0bc139931c03d31824c4f02394b38e3ead95", "committedDate": "2023-06-02 13:15:05 -0700", "message": "support headless user type - managed by user authority but treated like service (#2197)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxNjU2Mg==", "url": "https://github.com/AthenZ/athenz/pull/1157#discussion_r511016562", "body": "let's call groupMember.setSystemDisabled only once.\r\nwe should determine the state and then just pass that to the method e.g. \r\n\r\nstate = suspended ? a : b;\r\ngroupMember.setSystemDisabled(state);\r\n", "bodyText": "let's call groupMember.setSystemDisabled only once.\nwe should determine the state and then just pass that to the method e.g.\nstate = suspended ? a : b;\ngroupMember.setSystemDisabled(state);", "bodyHTML": "<p dir=\"auto\">let's call groupMember.setSystemDisabled only once.<br>\nwe should determine the state and then just pass that to the method e.g.</p>\n<p dir=\"auto\">state = suspended ? a : b;<br>\ngroupMember.setSystemDisabled(state);</p>", "author": "havetisyan", "createdAt": "2020-10-23T16:56:55Z", "path": "servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java", "diffHunk": "@@ -6402,6 +6403,147 @@ void enforceGroupUserAuthorityRestrictions(final String domainName, final String\n         }\n     }\n \n+    /**\n+     * This method returns list of Principals based on the state parameter supplied\n+     * @param queriedState state of principal\n+     * @return List of Principals from DB\n+     */\n+    List<Principal> getPrincipals(int queriedState) {\n+        List<Principal> principals = new ArrayList<>();\n+        Principal principal;\n+        try (ObjectStoreConnection con = store.getConnection(true, false)) {\n+           List<String> dbPrincipals = con.getPrincipals(queriedState);\n+            Principal.State principalState = Principal.State.getState(queriedState);\n+           for (String dbPrincipal : dbPrincipals) {\n+               principal = ZMSUtils.createPrincipalForName(dbPrincipal, zmsConfig.getUserDomain(), null);\n+               ((SimplePrincipal) principal).setState(principalState);\n+               principals.add(principal);\n+           }\n+        }\n+        return principals;\n+    }\n+\n+    /**\n+     * This method toggles state for supplied Principals based on the flag in DB\n+     * as well as modifies memberships of all roles and groups of current principal(s)\n+     * @param changedPrincipals List of Principals from User Authority\n+     * @param suspended boolean indicating principal's state\n+     */\n+    void updatePrincipalByStateFromAuthority(List<Principal> changedPrincipals, boolean suspended) {\n+        final String caller = \"updatePrincipalByStateFromAuthority\";\n+        List<Principal> updatedUsers = new ArrayList<>();\n+        if (!changedPrincipals.isEmpty()) {\n+            try (ObjectStoreConnection con = store.getConnection(true, true)) {\n+\n+                // first lets update the new state in DB\n+                for (Principal changedPrincipal : changedPrincipals) {\n+                    updatePrincipalState(suspended, updatedUsers, con, changedPrincipal);\n+                }\n+                // if new state is updated successfully\n+                // then we need to modify all roles and groups where given principal is member of\n+                if (!updatedUsers.isEmpty()) {\n+                    for (Principal updatedUser : updatedUsers) {\n+                        try {\n+                            updateRoleMembershipsByPrincipalState(suspended, caller, con, updatedUser);\n+                            updateGroupMembershipByPrincipalState(suspended, caller, con, updatedUser);\n+                        } catch (ResourceException ex) {\n+                            if (ex.getCode() == ResourceException.NOT_FOUND) {\n+                                continue;\n+                            }\n+                            throw ex;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void updateGroupMembershipByPrincipalState(boolean suspended, String caller, ObjectStoreConnection con, Principal updatedUser) {\n+        List<GroupMember> groupMembersWithUpdatedState;\n+        GroupMember groupMember;\n+        DomainGroupMember domainGroupMember;\n+        Set<GroupMember> updatedGroups = new HashSet<>();\n+\n+        domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n+        if (!domainGroupMember.getMemberGroups().isEmpty()) {\n+            for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n+                groupMember = new GroupMember();\n+                groupMember.setMemberName(updatedUser.getFullName());\n+                if (suspended) {", "originalCommit": "f2b6979e4235f325d7eea75d6f63d358c03d8d3c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0dff4be75160c89e9e35b4634db11456460fa25f", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 2d11e7268..08f2ee72e 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6462,34 +6482,29 @@ public class DBService implements RolesProvider {\n         List<GroupMember> groupMembersWithUpdatedState;\n         GroupMember groupMember;\n         DomainGroupMember domainGroupMember;\n-        Set<GroupMember> updatedGroups = new HashSet<>();\n-\n+        int newState;\n+        Set<String> updatedDomains = new HashSet<>();\n         domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n         if (!domainGroupMember.getMemberGroups().isEmpty()) {\n             for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n                 groupMember = new GroupMember();\n                 groupMember.setMemberName(updatedUser.getFullName());\n-                if (suspended) {\n-                    groupMember.setSystemDisabled(currentGroup.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                } else {\n-                    groupMember.setSystemDisabled(currentGroup.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                }\n-                groupMembersWithUpdatedState = new ArrayList<>();\n-                groupMembersWithUpdatedState.add(groupMember);\n+                newState = suspended ? currentGroup.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n+                        currentGroup.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n+                groupMember.setSystemDisabled(newState);\n+                groupMembersWithUpdatedState = Collections.singletonList(groupMember);\n \n                 // Following method does Audit entry as well\n                 if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n                         currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-                    updatedGroups.add(currentGroup);\n+                    con.updateGroupModTimestamp(currentGroup.getDomainName(), currentGroup.getGroupName());\n+                    updatedDomains.add(currentGroup.getDomainName());\n                 }\n             }\n-            for (GroupMember updatedGM : updatedGroups) {\n-\n-                // update our group and domain time-stamps, and invalidate local cache entry\n-                con.updateGroupModTimestamp(updatedGM.getDomainName(), updatedGM.getGroupName());\n-                con.updateDomainModTimestamp(updatedGM.getDomainName());\n-                cacheStore.invalidate(updatedGM.getDomainName());\n-            }\n+            updatedDomains.forEach(dom -> {\n+                con.updateDomainModTimestamp(dom);\n+                cacheStore.invalidate(dom);\n+            });\n         }\n     }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 2d11e7268..08f2ee72e 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6462,34 +6482,29 @@ public class DBService implements RolesProvider {\n         List<GroupMember> groupMembersWithUpdatedState;\n         GroupMember groupMember;\n         DomainGroupMember domainGroupMember;\n-        Set<GroupMember> updatedGroups = new HashSet<>();\n-\n+        int newState;\n+        Set<String> updatedDomains = new HashSet<>();\n         domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n         if (!domainGroupMember.getMemberGroups().isEmpty()) {\n             for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n                 groupMember = new GroupMember();\n                 groupMember.setMemberName(updatedUser.getFullName());\n-                if (suspended) {\n-                    groupMember.setSystemDisabled(currentGroup.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                } else {\n-                    groupMember.setSystemDisabled(currentGroup.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                }\n-                groupMembersWithUpdatedState = new ArrayList<>();\n-                groupMembersWithUpdatedState.add(groupMember);\n+                newState = suspended ? currentGroup.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n+                        currentGroup.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n+                groupMember.setSystemDisabled(newState);\n+                groupMembersWithUpdatedState = Collections.singletonList(groupMember);\n \n                 // Following method does Audit entry as well\n                 if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n                         currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-                    updatedGroups.add(currentGroup);\n+                    con.updateGroupModTimestamp(currentGroup.getDomainName(), currentGroup.getGroupName());\n+                    updatedDomains.add(currentGroup.getDomainName());\n                 }\n             }\n-            for (GroupMember updatedGM : updatedGroups) {\n-\n-                // update our group and domain time-stamps, and invalidate local cache entry\n-                con.updateGroupModTimestamp(updatedGM.getDomainName(), updatedGM.getGroupName());\n-                con.updateDomainModTimestamp(updatedGM.getDomainName());\n-                cacheStore.invalidate(updatedGM.getDomainName());\n-            }\n+            updatedDomains.forEach(dom -> {\n+                con.updateDomainModTimestamp(dom);\n+                cacheStore.invalidate(dom);\n+            });\n         }\n     }\n \n", "next_change": {"commit": "c668f48cec94e2c928581b92ffb517f715a4840f", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 08f2ee72e..824e0aa8a 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6512,15 +6483,19 @@ public class DBService implements RolesProvider {\n         RoleMember roleMember;\n         List<RoleMember> roleMembersWithUpdatedState;\n         DomainRoleMember domainRoleMember;\n-        int newState;\n+        int newState, oldState;\n         Set<String> updatedDomains = new HashSet<>();\n         domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n         if (!domainRoleMember.getMemberRoles().isEmpty()) {\n             for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n                 roleMember = new RoleMember();\n                 roleMember.setMemberName(updatedUser.getFullName());\n-                newState = suspended ? memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n-                        memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n+                oldState = 0;\n+                if (memberRole.getSystemDisabled() != null) {\n+                    oldState = memberRole.getSystemDisabled();\n+                }\n+                newState = suspended ? oldState | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n+                        oldState & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n                 roleMember.setSystemDisabled(newState);\n                 roleMembersWithUpdatedState = Collections.singletonList(roleMember);\n \n", "next_change": {"commit": "a5bb615881583fa6f39621e2ea3bf39d3886340b", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 824e0aa8a..8274a1809 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6446,61 +7563,487 @@ public class DBService implements RolesProvider {\n         }\n     }\n \n-    private void updateGroupMembershipByPrincipalState(boolean suspended, String caller, ObjectStoreConnection con, Principal updatedUser) {\n-        List<GroupMember> groupMembersWithUpdatedState;\n-        GroupMember groupMember;\n-        DomainGroupMember domainGroupMember;\n-        int newState, oldState;\n-        Set<String> updatedDomains = new HashSet<>();\n-        domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n-        if (!domainGroupMember.getMemberGroups().isEmpty()) {\n-            for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n-                groupMember = new GroupMember();\n-                groupMember.setMemberName(updatedUser.getFullName());\n-                oldState = 0;\n-                if (groupMember.getSystemDisabled() != null) {\n-                    oldState = groupMember.getSystemDisabled();\n-                }\n-                newState = suspended ? oldState | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n-                        oldState & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n-                groupMember.setSystemDisabled(newState);\n-                groupMembersWithUpdatedState = Collections.singletonList(groupMember);\n-                // Following method does Audit entry as well\n-                if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n-                        currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-                    con.updateGroupModTimestamp(currentGroup.getDomainName(), currentGroup.getGroupName());\n-                    updatedDomains.add(currentGroup.getDomainName());\n-                }\n-            }\n-            updatedDomains.forEach(dom -> {\n-                con.updateDomainModTimestamp(dom);\n-                cacheStore.invalidate(dom);\n-            });\n-        }\n-    }\n+    void executePutAssertionConditions(ResourceContext ctx, String domainName, String policyName, long assertionId,\n+                                       AssertionConditions assertionConditions, String auditRef, String caller) {\n \n-    private void updateRoleMembershipsByPrincipalState(boolean suspended, String caller, ObjectStoreConnection con, Principal updatedUser) {\n-        RoleMember roleMember;\n-        List<RoleMember> roleMembersWithUpdatedState;\n-        DomainRoleMember domainRoleMember;\n-        int newState, oldState;\n-        Set<String> updatedDomains = new HashSet<>();\n-        domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n-        if (!domainRoleMember.getMemberRoles().isEmpty()) {\n-            for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n-                roleMember = new RoleMember();\n-                roleMember.setMemberName(updatedUser.getFullName());\n-                oldState = 0;\n-                if (memberRole.getSystemDisabled() != null) {\n-                    oldState = memberRole.getSystemDisabled();\n-                }\n-                newState = suspended ? oldState | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n-                        oldState & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n-                roleMember.setSystemDisabled(newState);\n-                roleMembersWithUpdatedState = Collections.singletonList(roleMember);\n+        // our exception handling code does the check for retry count\n+        // and throws the exception it had received when the retry\n+        // count reaches 0\n \n-                // Following method does Audit entry as well\n-                if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n+        for (int retryCount = defaultRetryCount; ; retryCount--) {\n+\n+            try (ObjectStoreConnection con = store.getConnection(false, true)) {\n+\n+                // first verify that auditing requirements are met\n+\n+                checkDomainAuditEnabled(con, domainName, auditRef, caller, getPrincipalName(ctx), AUDIT_TYPE_POLICY);\n+\n+                // now we need verify our quota check\n+\n+                quotaCheck.checkAssertionConditionsQuota(con, assertionId, assertionConditions, caller);\n+\n+                // process our insert assertion condition.\n+\n+                if (!con.insertAssertionConditions(assertionId, assertionConditions)) {\n+                    throw ZMSUtils.requestError(String.format(\"%s: unable to insert assertion conditions for policy=%s assertionId=%d\", caller, policyName, assertionId), caller);\n+                }\n+\n+                // update our policy and domain time-stamps, and invalidate local cache entry\n+\n+                con.updatePolicyModTimestamp(domainName, policyName, null);\n+                saveChanges(con, domainName);\n+\n+\n+                // audit log the request\n+                StringBuilder auditDetails = new StringBuilder(ZMSConsts.STRING_BLDR_SIZE_DEFAULT);\n+                auditDetails.append(\"{\\\"policy\\\": \\\"\").append(policyName)\n+                        .append(\"\\\", \\\"assertionId\\\": \").append(assertionId)\n+                        .append(\", \");\n+                auditLogAssertionConditions(auditDetails, assertionConditions.getConditionsList(), \"new-assertion-conditions\");\n+                auditDetails.append(\"}\");\n+\n+                auditLogRequest(ctx, domainName, auditRef, caller, ZMSConsts.HTTP_PUT,\n+                        policyName, auditDetails.toString());\n+\n+                // add domain change event\n+                addDomainChangeMessage(ctx, domainName, policyName, DomainChangeMessage.ObjectType.POLICY);\n+                \n+                return;\n+\n+            } catch (ResourceException ex) {\n+\n+                // otherwise check if we need to retry or return failure\n+                if (!shouldRetryOperation(ex, retryCount)) {\n+                    throw ex;\n+                }\n+            }\n+        }\n+    }\n+\n+    void executePutAssertionCondition(ResourceContext ctx, String domainName, String policyName, long assertionId,\n+                                      AssertionCondition assertionCondition, String auditRef, String caller) {\n+\n+        // our exception handling code does the check for retry count\n+        // and throws the exception it had received when the retry\n+        // count reaches 0\n+\n+        for (int retryCount = defaultRetryCount; ; retryCount--) {\n+\n+            try (ObjectStoreConnection con = store.getConnection(false, true)) {\n+\n+                // first verify that auditing requirements are met\n+\n+                checkDomainAuditEnabled(con, domainName, auditRef, caller, getPrincipalName(ctx), AUDIT_TYPE_POLICY);\n+\n+                // process our insert assertion condition.\n+\n+                if (assertionCondition.getId() == null) {\n+\n+                    // now we need verify our quota check\n+                    quotaCheck.checkAssertionConditionQuota(con, assertionId, assertionCondition, caller);\n+\n+                    // no condition id in the request. so we are going to generate the next condition id for\n+                    // the given assertion id and then use it to insert given keys\n+                    assertionCondition.setId(con.getNextConditionId(assertionId, caller));\n+                    if (!con.insertAssertionCondition(assertionId, assertionCondition)) {\n+                        throw ZMSUtils.requestError(String.format(\"%s: unable to insert new assertion condition for policy=%s assertionId=%d\", caller, policyName, assertionId), caller);\n+                    }\n+                } else {\n+\n+                    // existing assertion condition keys found with given condition id. so delete existing keys from DB for the given condition id\n+                    if (!con.deleteAssertionCondition(assertionId, assertionCondition.getId())) {\n+                        throw ZMSUtils.notFoundError(String.format(\"%s: unable to delete assertion condition during putAssertionCondition for policy=%s assertionId=%d conditionId=%d\"\n+                                , caller, policyName, assertionId, assertionCondition.getId()), caller);\n+                    }\n+                    // now we need verify our quota check after deleting the old entries\n+                    quotaCheck.checkAssertionConditionQuota(con, assertionId, assertionCondition, caller);\n+\n+                    // now insert the new keys against existing condition id\n+                    if (!con.insertAssertionCondition(assertionId, assertionCondition)) {\n+                        throw ZMSUtils.requestError(String.format(\"%s: unable to insert assertion condition for policy=%s assertionId=%d\", caller, policyName, assertionId), caller);\n+                    }\n+                }\n+\n+                // update our policy and domain time-stamps, and invalidate local cache entry\n+\n+                con.updatePolicyModTimestamp(domainName, policyName, null);\n+                saveChanges(con, domainName);\n+\n+\n+                // audit log the request\n+                StringBuilder auditDetails = new StringBuilder(ZMSConsts.STRING_BLDR_SIZE_DEFAULT);\n+                auditDetails.append(\"{\\\"policy\\\": \\\"\").append(policyName)\n+                        .append(\"\\\", \\\"assertionId\\\": \").append(assertionId)\n+                        .append(\", \\\"new-assertion-condition\\\": \");\n+                auditLogAssertionCondition(auditDetails, assertionCondition, true);\n+                auditDetails.append(\"}\");\n+\n+                auditLogRequest(ctx, domainName, auditRef, caller, ZMSConsts.HTTP_PUT,\n+                        policyName, auditDetails.toString());\n+\n+                // add domain change event\n+                addDomainChangeMessage(ctx, domainName, policyName, DomainChangeMessage.ObjectType.POLICY);\n+                \n+                return;\n+\n+            } catch (ResourceException ex) {\n+\n+                // otherwise check if we need to retry or return failure\n+                if (!shouldRetryOperation(ex, retryCount)) {\n+                    throw ex;\n+                }\n+            }\n+        }\n+    }\n+\n+    public void executeDeleteAssertionConditions(ResourceContext ctx, String domainName, String policyName, Long assertionId, String auditRef, String caller) {\n+\n+        // our exception handling code does the check for retry count\n+        // and throws the exception it had received when the retry\n+        // count reaches 0\n+\n+        for (int retryCount = defaultRetryCount; ; retryCount--) {\n+\n+            try (ObjectStoreConnection con = store.getConnection(true, true)) {\n+\n+                // first verify that auditing requirements are met\n+\n+                checkDomainAuditEnabled(con, domainName, auditRef, caller, getPrincipalName(ctx), AUDIT_TYPE_POLICY);\n+\n+                // fetch the assertion for our audit log\n+\n+                List<AssertionCondition> assertionConditions = con.getAssertionConditions(assertionId);\n+                if (assertionConditions == null) {\n+                    throw ZMSUtils.notFoundError(String.format(\"%s: unable to read assertion conditions for policy=%s assertionId=%d\", caller,\n+                            policyName, assertionId), caller);\n+                }\n+\n+                // process our delete assertion conditions. since this is a \"single\"\n+                // operation, we are not using any transactions.\n+\n+                if (!con.deleteAssertionConditions(assertionId)) {\n+                    throw ZMSUtils.notFoundError(String.format(\"%s: unable to delete assertion conditions for policy=%s assertionId=%d\", caller,\n+                            policyName, assertionId), caller);\n+                }\n+\n+                // update our policy and domain time-stamps, and invalidate local cache entry\n+\n+                con.updatePolicyModTimestamp(domainName, policyName, null);\n+                con.updateDomainModTimestamp(domainName);\n+                cacheStore.invalidate(domainName);\n+\n+                // audit log the request\n+\n+                StringBuilder auditDetails = new StringBuilder(ZMSConsts.STRING_BLDR_SIZE_DEFAULT);\n+                auditDetails.append(\"{\\\"policy\\\": \\\"\").append(policyName)\n+                        .append(\"\\\", \\\"assertionId\\\": \").append(assertionId)\n+                        .append(\", \");\n+                auditLogAssertionConditions(auditDetails, assertionConditions, \"deleted-assertion-conditions\");\n+                auditDetails.append(\"}\");\n+\n+                auditLogRequest(ctx, domainName, auditRef, caller, ZMSConsts.HTTP_DELETE,\n+                        policyName, auditDetails.toString());\n+\n+                // add domain change event\n+                addDomainChangeMessage(ctx, domainName, policyName, DomainChangeMessage.ObjectType.POLICY);\n+                \n+                return;\n+\n+            } catch (ResourceException ex) {\n+\n+                // otherwise check if we need to retry or return failure\n+\n+                if (!shouldRetryOperation(ex, retryCount)) {\n+                    throw ex;\n+                }\n+            }\n+        }\n+    }\n+\n+    public void executeDeleteAssertionCondition(ResourceContext ctx, String domainName, String policyName, Long assertionId, Integer conditionId, String auditRef, String caller) {\n+        // our exception handling code does the check for retry count\n+        // and throws the exception it had received when the retry\n+        // count reaches 0\n+\n+        for (int retryCount = defaultRetryCount; ; retryCount--) {\n+\n+            try (ObjectStoreConnection con = store.getConnection(true, true)) {\n+\n+                // first verify that auditing requirements are met\n+\n+                checkDomainAuditEnabled(con, domainName, auditRef, caller, getPrincipalName(ctx), AUDIT_TYPE_POLICY);\n+\n+                // fetch the assertion for our audit log\n+\n+                AssertionCondition assertionCondition = con.getAssertionCondition(assertionId, conditionId);\n+                if (assertionCondition == null) {\n+                    throw ZMSUtils.notFoundError(String.format(\"%s: unable to read assertion condition for policy=%s assertionId=%d conditionId=%d\"\n+                            , caller, policyName, assertionId, conditionId), caller);\n+                }\n+\n+                // process our delete assertion condition. since this is a \"single\"\n+                // operation, we are not using any transactions.\n+\n+                if (!con.deleteAssertionCondition(assertionId, conditionId)) {\n+                    throw ZMSUtils.notFoundError(String.format(\"%s: unable to delete assertion condition for policy=%s assertionId=%d conditionId=%d\"\n+                            , caller, policyName, assertionId, conditionId), caller);\n+                }\n+\n+                // update our policy and domain time-stamps, and invalidate local cache entry\n+\n+                con.updatePolicyModTimestamp(domainName, policyName, null);\n+                con.updateDomainModTimestamp(domainName);\n+                cacheStore.invalidate(domainName);\n+\n+                // audit log the request\n+\n+                StringBuilder auditDetails = new StringBuilder(ZMSConsts.STRING_BLDR_SIZE_DEFAULT);\n+                auditDetails.append(\"{\\\"policy\\\": \\\"\").append(policyName)\n+                        .append(\"\\\", \\\"assertionId\\\": \").append(assertionId)\n+                        .append(\", \\\"deleted-assertion-condition\\\": \");\n+                auditLogAssertionCondition(auditDetails, assertionCondition, true);\n+                auditDetails.append(\"}\");\n+\n+                auditLogRequest(ctx, domainName, auditRef, caller, ZMSConsts.HTTP_DELETE,\n+                        policyName, auditDetails.toString());\n+\n+                // add domain change event\n+                addDomainChangeMessage(ctx, domainName, policyName, DomainChangeMessage.ObjectType.POLICY);\n+                \n+                return;\n+\n+            } catch (ResourceException ex) {\n+\n+                // otherwise check if we need to retry or return failure\n+\n+                if (!shouldRetryOperation(ex, retryCount)) {\n+                    throw ex;\n+                }\n+            }\n+        }\n+    }\n+\n+    public void putDomainDependency(ResourceContext ctx, String domainName, String service, String auditRef, String caller) {\n+\n+        // our exception handling code does the check for retry count\n+        // and throws the exception it had received when the retry\n+        // count reaches 0\n+\n+        for (int retryCount = defaultRetryCount; ; retryCount--) {\n+\n+            try (ObjectStoreConnection con = store.getConnection(false, true)) {\n+\n+                final String principal = getPrincipalName(ctx);\n+\n+                // first verify that auditing requirements are met\n+\n+                checkDomainAuditEnabled(con, domainName, auditRef, caller, principal, AUDIT_TYPE_DOMAIN);\n+\n+                // verify domain exists\n+\n+                Domain domain = con.getDomain(domainName);\n+                if (domain == null) {\n+                    con.rollbackChanges();\n+                    throw ZMSUtils.notFoundError(caller + \": Unknown domain: \" + domainName, caller);\n+                }\n+\n+                // now process the request\n+\n+                StringBuilder auditDetails = new StringBuilder(ZMSConsts.STRING_BLDR_SIZE_DEFAULT);\n+                if (!processDomainDependency(con, domainName, service, auditDetails)) {\n+                    con.rollbackChanges();\n+                    throw ZMSUtils.internalServerError(\"unable to put dependency on domain \" + domainName + \" for service \" + service, caller);\n+                }\n+\n+                // update our domain time-stamp and save changes\n+\n+                saveChanges(con, domainName);\n+\n+                // audit log the request\n+\n+                auditLogRequest(ctx, domainName, auditRef, caller, ZMSConsts.HTTP_PUT,\n+                        service, auditDetails.toString());\n+\n+                // add domain change event\n+                addDomainChangeMessage(ctx, domainName, service, DomainChangeMessage.ObjectType.DOMAIN);\n+\n+                return;\n+\n+            } catch (ResourceException ex) {\n+                if (!shouldRetryOperation(ex, retryCount)) {\n+                    throw ex;\n+                }\n+            }\n+        }\n+    }\n+\n+    public void deleteDomainDependency(ResourceContext ctx, String domainName, String service, String auditRef, String caller) {\n+\n+        // our exception handling code does the check for retry count\n+        // and throws the exception it had received when the retry\n+        // count reaches 0\n+\n+        for (int retryCount = defaultRetryCount; ; retryCount--) {\n+\n+            try (ObjectStoreConnection con = store.getConnection(false, true)) {\n+\n+                final String principal = getPrincipalName(ctx);\n+\n+                // first verify that auditing requirements are met\n+\n+                checkDomainAuditEnabled(con, domainName, auditRef, caller, principal, AUDIT_TYPE_DOMAIN);\n+\n+                // verify domain exists\n+\n+                Domain domain = con.getDomain(domainName);\n+                if (domain == null) {\n+                    con.rollbackChanges();\n+                    throw ZMSUtils.notFoundError(caller + \": Unknown domain: \" + domainName, caller);\n+                }\n+\n+                // now process the request\n+\n+                StringBuilder auditDetails = new StringBuilder(ZMSConsts.STRING_BLDR_SIZE_DEFAULT);\n+                if (!processDeleteDomainDependency(con, domainName, service, auditDetails)) {\n+                    con.rollbackChanges();\n+                    throw ZMSUtils.internalServerError(\"unable to delete dependency on domain \" + domainName + \" for service \" + service, caller);\n+                }\n+\n+                // update our domain time-stamp and save changes\n+\n+                saveChanges(con, domainName);\n+\n+                // audit log the request\n+\n+                auditLogRequest(ctx, domainName, auditRef, caller, ZMSConsts.HTTP_DELETE,\n+                        service, auditDetails.toString());\n+\n+                // add domain change event\n+                addDomainChangeMessage(ctx, domainName, service, DomainChangeMessage.ObjectType.DOMAIN);\n+\n+                return;\n+\n+            } catch (ResourceException ex) {\n+                if (!shouldRetryOperation(ex, retryCount)) {\n+                    throw ex;\n+                }\n+            }\n+        }\n+    }\n+\n+    private boolean processDomainDependency(ObjectStoreConnection con, String domainName, String service,\n+                                            StringBuilder auditDetails) {\n+\n+        boolean requestSuccess = con.insertDomainDependency(domainName, service);\n+\n+        // if we didn't insert a dependency then we need to return failure\n+\n+        if (!requestSuccess) {\n+            return false;\n+        }\n+\n+        // open our audit record and log the dependency\n+\n+        auditDetails.append(\"{\\\"domain-dependencies\\\": \");\n+        auditDetails.append(\"{\\\"domain\\\": \\\"\").append(domainName)\n+                .append(\"\\\", \\\"service\\\": \\\"\").append(service).append(\"\\\"}\")\n+                .append('}');\n+\n+        return true;\n+    }\n+\n+    private boolean processDeleteDomainDependency(ObjectStoreConnection con, String domainName, String service,\n+                                                  StringBuilder auditDetails) {\n+\n+        boolean requestSuccess = con.deleteDomainDependency(domainName, service);\n+\n+        // if we didn't delete the dependency then we need to return failure\n+\n+        if (!requestSuccess) {\n+            return false;\n+        }\n+\n+        // open our audit record and log the dependency\n+\n+        auditDetails.append(\"{\\\"delete-domain-dependencies\\\": \");\n+        auditDetails.append(\"{\\\"domain\\\": \\\"\").append(domainName)\n+                .append(\"\\\", \\\"service\\\": \\\"\").append(service).append(\"\\\"}\")\n+                .append('}');\n+\n+        return true;\n+    }\n+\n+    public ServiceIdentityList listServiceDependencies(String domainName) {\n+        try (ObjectStoreConnection con = store.getConnection(true, false)) {\n+            ServiceIdentityList serviceIdentityList = new ServiceIdentityList();\n+            serviceIdentityList.setNames(con.listServiceDependencies(domainName));\n+            return serviceIdentityList;\n+        }\n+    }\n+\n+    public DomainList listDomainDependencies(String service) {\n+        try (ObjectStoreConnection con = store.getConnection(true, false)) {\n+            DomainList domainList = new DomainList();\n+            domainList.setNames(con.listDomainDependencies(service));\n+            return domainList;\n+        }\n+    }\n+\n+    private void updateGroupMembershipByPrincipalState(boolean suspended, String caller, ObjectStoreConnection con, Principal updatedUser) {\n+        List<GroupMember> groupMembersWithUpdatedState;\n+        GroupMember groupMember;\n+        DomainGroupMember domainGroupMember;\n+        int newState, oldState;\n+        Set<String> updatedDomains = new HashSet<>();\n+        domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n+        if (!domainGroupMember.getMemberGroups().isEmpty()) {\n+            for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n+                groupMember = new GroupMember();\n+                groupMember.setMemberName(updatedUser.getFullName());\n+                oldState = 0;\n+                if (groupMember.getSystemDisabled() != null) {\n+                    oldState = groupMember.getSystemDisabled();\n+                }\n+                newState = suspended ? oldState | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n+                        oldState & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n+                groupMember.setSystemDisabled(newState);\n+                groupMembersWithUpdatedState = Collections.singletonList(groupMember);\n+                // Following method does Audit entry as well\n+                if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n+                        currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n+                    con.updateGroupModTimestamp(currentGroup.getDomainName(), currentGroup.getGroupName());\n+                    updatedDomains.add(currentGroup.getDomainName());\n+                }\n+            }\n+            updatedDomains.forEach(dom -> {\n+                con.updateDomainModTimestamp(dom);\n+                cacheStore.invalidate(dom);\n+            });\n+        }\n+    }\n+\n+    private void updateRoleMembershipsByPrincipalState(boolean suspended, String caller, ObjectStoreConnection con, Principal updatedUser) {\n+        RoleMember roleMember;\n+        List<RoleMember> roleMembersWithUpdatedState;\n+        DomainRoleMember domainRoleMember;\n+        int newState, oldState;\n+        Set<String> updatedDomains = new HashSet<>();\n+        domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n+        if (!domainRoleMember.getMemberRoles().isEmpty()) {\n+            for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n+                roleMember = new RoleMember();\n+                roleMember.setMemberName(updatedUser.getFullName());\n+                oldState = 0;\n+                if (memberRole.getSystemDisabled() != null) {\n+                    oldState = memberRole.getSystemDisabled();\n+                }\n+                newState = suspended ? oldState | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n+                        oldState & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n+                roleMember.setSystemDisabled(newState);\n+                roleMembersWithUpdatedState = Collections.singletonList(roleMember);\n+\n+                // Following method does Audit entry as well\n+                if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n                         memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n                     con.updateRoleModTimestamp(memberRole.getDomainName(), memberRole.getRoleName());\n                     updatedDomains.add(memberRole.getDomainName());\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "message": "Merge commit", "committedDate": null}, {"oid": "9a9c82c13d156e06dad8464c3a6c52c8e2bc6b89", "committedDate": "2020-10-26 14:15:03 -0700", "message": "remove sending back deprected members field in roles (#1160)"}, {"oid": "31a0dd7362f585f85992d4ff86fbf975d9d736dd", "committedDate": "2020-10-31 14:59:07 -0700", "message": "add azure_subscription field to domains (#1167)"}, {"oid": "c668f48cec94e2c928581b92ffb517f715a4840f", "committedDate": "2020-11-06 18:05:10 -0800", "message": "handle sys disabled null scenario (#1176)"}, {"oid": "f24d15baaaddc96c85fbceb31fcaded756a69f2e", "committedDate": "2020-11-14 16:51:57 -0800", "message": "role tags - generated code and schema changes (#1179)"}, {"oid": "30e272d8a9ec2649a1d876c1c111cf38e27c1743", "committedDate": "2020-12-07 08:48:58 -0800", "message": "putRoleMeta tags support (#1208)"}, {"oid": "f0e0a91b80250236244db9f8cba79e1def809995", "committedDate": "2020-12-23 15:40:53 -0800", "message": "updating group expiry date (#1221)"}, {"oid": "7a2837c7578ab8d36c62b48ecb1d0079c670616b", "committedDate": "2020-12-29 13:44:04 -0800", "message": "granular authz action for managing role members (#1228)"}, {"oid": "d6a0d659fe96486ffcf31bb93e919656be9eaf89", "committedDate": "2021-01-13 08:15:47 -0800", "message": "domain tags implementation (#1235)"}, {"oid": "3c939966592bf7cc6ff25df12a8d21d4c2c89b2b", "committedDate": "2021-01-19 22:05:22 -0800", "message": "client api update for rich authorization requests and consistent naming of entity objects (#1248)"}, {"oid": "3db6ed7b169fce5bbeaa1fae84ff7881e9a4e435", "committedDate": "2021-01-21 09:17:41 -0800", "message": "limit number of role and domain tags (#1255)"}, {"oid": "218b71958d88fb039dfa6e7c5448c7e4d00cb337", "committedDate": "2021-01-25 17:53:41 -0800", "message": "update domain last modified timestamp after tag update (#1262)"}, {"oid": "bccc5fb4dc1c2407a0293f322c3d97711af4297c", "committedDate": "2021-03-07 18:11:58 -0800", "message": "sonarcloud: method always returns same result (#1329)"}, {"oid": "e421f20094d24075d2cec7ab7adecff7d630a286", "committedDate": "2021-03-16 18:08:03 -0700", "message": "expose new domain attribute: business-service (#1357)"}, {"oid": "7b4afd5d40394226b3aa1af8bf10e90e528091b3", "committedDate": "2021-04-01 14:52:30 -0700", "message": "Add memberExpiryDays and serviceExpiryDays support for groups (#1388)"}, {"oid": "5ab30978cc4fc03e1b3022305f6e14a5a425e9e9", "committedDate": "2021-04-07 16:30:50 -0700", "message": "new DomainMetaStore interface support in ZMS (#1430)"}, {"oid": "9bedde4310d6493406d264422f23e16f33213546", "committedDate": "2021-04-08 09:44:29 -0700", "message": "Add group review days to role (#1428)"}, {"oid": "a554c75c51c5945b0e58ae87866de93ff1d5cfbc", "committedDate": "2021-04-15 12:12:02 -0700", "message": "during provider admin setup, ignore deletes (#1444)"}, {"oid": "1c564548381b3c09ad4214d0f30c667e9cc0d022", "committedDate": "2021-04-30 15:22:51 -0700", "message": "log full policy assertion details during delete operations in audit log (#1469)"}, {"oid": "611ac334bfbc1c43ec20154cf9448b96fae365d6", "committedDate": "2021-05-27 16:30:38 -0700", "message": "handle null contition processDomainTags (#1495)"}, {"oid": "addf4424a5bf842b58558c6f61ac0b46277d9535", "committedDate": "2021-06-07 09:38:12 -0700", "message": "allow role/group review regardless of role/group expiry/reminder settings (#1503)"}, {"oid": "4b39ffbd18da3d10a581fb10209806c97b432d28", "committedDate": "2021-06-09 15:31:17 -0700", "message": "enable role review without setting restrictions (#1512)"}, {"oid": "898ff0aa4fddd1a9ed111496cb9e4acb544605af", "committedDate": "2021-06-14 10:42:10 -0700", "message": "Update Tag Values to include '/', ':' (#1517)"}, {"oid": "cf535673b0a4cbcdc81e17c7def4cb6822edd78c", "committedDate": "2021-06-22 06:44:42 -0700", "message": "Allow system admins to set domain meta attribute business service (#1522)"}, {"oid": "934fc3d7fc859731f4beab3b03b83a15ac717a2d", "committedDate": "2021-06-29 12:57:53 -0700", "message": "assertion condition server changes (#1528)"}, {"oid": "1fa51b852890c1576254be6a8a2b5dbebc89865c", "committedDate": "2021-07-21 14:41:19 -0700", "message": "UI : update error message (#1557)"}, {"oid": "09de45bb794eb5e7c29f705b5ce567c75fde4e84", "committedDate": "2021-07-29 15:49:16 -0700", "message": "multi-version policy - introducing version/active in policy object (#1568)"}, {"oid": "4abff4b9952e4836f79bf3f1934baf8fe2bcebf9", "committedDate": "2021-08-08 11:39:07 -0700", "message": "Disable Reminder Review Notifications By Tag zms.DisableReminderNotifications (#1579)"}, {"oid": "6a1523accc3ec83fe54d78c3d919d9cddbcb1b7e", "committedDate": "2021-08-17 18:32:28 -0700", "message": "fixing the order of updates for assertion condition api operations (#1591)"}, {"oid": "66590f4fc47f899f3990f20895f953074e40f259", "committedDate": "2021-09-10 07:55:42 -0700", "message": "Implement multi-version policies endpoints (#1605)"}, {"oid": "1ad624427917493d31bd1b8ffa6303c4d6353055", "committedDate": "2021-09-10 13:51:19 -0700", "message": "update group last modified when user is deleted (#1613)"}, {"oid": "91b116418656f123dae9a3405cb2e498d4d3aff4", "committedDate": "2021-09-12 09:52:05 +0300", "message": "additional validation checks when processing versioned policies (#1614)"}, {"oid": "2531428956f87774f86721f02b430861ca8897ec", "committedDate": "2021-09-14 09:49:34 +0300", "message": "additional checks when setting a policy version as active (#1615)"}, {"oid": "2968c209e870ce57fbdb1fb048a21692d80cfea6", "committedDate": "2021-10-01 07:25:34 -0700", "message": "rdl publishChangeEvents generator (#1624)"}, {"oid": "8a6960ce9878277c5abda1d104ca070831b36230", "committedDate": "2021-10-03 13:48:03 -0700", "message": "Allow specifying version name when creating new policy (#1630)"}, {"oid": "43f619b31bbd9cc3d388aa7ea29eff889cb1272d", "committedDate": "2021-10-21 08:48:51 -0700", "message": "For role expiry notification - record metrics daily while (#1654)"}, {"oid": "389f984270d7d89070c66096e87fafbcb24a261c", "committedDate": "2021-10-26 08:17:36 -0700", "message": "Group tags implementation (#1660)"}, {"oid": "120ab1fa8e9d33fa793c4254d233a09a2c23d173", "committedDate": "2021-10-29 15:08:28 -0700", "message": "Disable Group Expiry Notifications By Tag zms.DisableReminderNotifications (#1663)"}, {"oid": "1400363e8d698cf08370c89752077ebae043c5be", "committedDate": "2021-12-14 13:48:34 -0800", "message": "correct logging of role principal in audit/access logs"}, {"oid": "c8e3a5c91c5deb9640576cd3496a2af11d572f0b", "committedDate": "2021-12-23 15:03:25 -0800", "message": "protect system admin users from being removed from deleteUser api (#1715)"}, {"oid": "020e06e57b357768260f509f08b75c5c068bce53", "committedDate": "2022-02-07 08:01:55 -0800", "message": "Service Visiblity - Domain Dependencies (#1758)"}, {"oid": "fcbd4128e334a9a42f4579d179cf9578d3f4de99", "committedDate": "2022-02-07 10:12:47 -0800", "message": "support new get-stats endpoint to get per-domain/system stats (#1774)"}, {"oid": "ea831a34a70a0475bea8754cb183741dced98ff2", "committedDate": "2022-02-18 09:17:55 -0800", "message": "update pending member api to support getting list for a domain (#1783)"}, {"oid": "f4229124e8e1898810c7aa7b3a4eff37fddae308", "committedDate": "2022-02-18 12:37:32 -0800", "message": "provide option to skip adding principal when onboarding a resource group (#1787)"}, {"oid": "9081feb4c06a1058c941c67923037203d9318cfa", "committedDate": "2022-02-27 14:10:46 -0800", "message": "Domain Dependency for Tenancy (#1789)"}, {"oid": "a5bb615881583fa6f39621e2ea3bf39d3886340b", "committedDate": "2022-03-03 17:20:00 -0800", "message": "extend template keyword support trust field in roles (#1803)"}, {"oid": "3de182bcbedba89fa2aaba12ab9be49aa2156096", "committedDate": "2022-03-19 09:45:40 -0700", "message": "Add provider webhook for verifying removal (#1816)"}, {"oid": "1b0cff1cb9b8e4a231c5cfb342d76b6aad8e08fc", "committedDate": "2022-04-07 14:34:23 -0700", "message": "no need to update domain's last mod timestamp during put dependency call (#1846)"}, {"oid": "baa68eacd6a6b9bbc70c3423006f92cd47b784d7", "committedDate": "2022-05-19 09:30:02 -0700", "message": "Get Auth History implementation (#1875)"}, {"oid": "bea97b165e28b5b2cc286af62c92e536c9fc3ff2", "committedDate": "2022-06-03 13:50:01 -0700", "message": "AuthHistory - Return dependencies instead of list (#1888)"}, {"oid": "7a313e1d581295ae6c786bbc2ed73bb14da37f7d", "committedDate": "2022-07-21 20:16:24 -0700", "message": "allow management of domain memberPurgeExpiryDays setting value (#1928)"}, {"oid": "f288ed7afb018bc07af02dbe9dc8e05ec0896071", "committedDate": "2022-08-15 22:28:01 -0700", "message": "provide header option to return updated object in response (#1942)"}, {"oid": "949bd0634d328d04736b912a002bdfa7421d9f2b", "committedDate": "2022-08-23 10:28:38 -0700", "message": "fix returning role/group objects when requested by ui (#1945)"}, {"oid": "ab7284c9274f4949d23f88ec0dde7b689c0c6980", "committedDate": "2022-09-05 13:12:17 -0700", "message": "auto purge expired role/group members based on server/domain config (#1941)"}, {"oid": "4ab6e748891a014a8b0a1364de099d3fbf4c7468", "committedDate": "2022-09-21 22:22:48 -0700", "message": "enable readWrite db connection for delete expired members (#1964)"}, {"oid": "d4c733d3e97467a598ba44f0bde5c6a907aa01de", "committedDate": "2022-09-23 13:30:24 -0700", "message": "consistent use of The Athenz Authors copyright in all files (#1967)"}, {"oid": "45dcdab92d9e39d5d561b34ef222f863176cc635", "committedDate": "2022-09-26 12:29:01 -0700", "message": "make server purge expiry member day configurable (#1968)"}, {"oid": "d823cccb5163f950655f3859ade41fe031910588", "committedDate": "2022-10-06 14:20:20 -0700", "message": "fix putServiceIdentity logic to allow update of exising pubKey (#1978)"}, {"oid": "91d38ef548e59e29e69349b8a0f5151456b62a0f", "committedDate": "2022-10-07 15:36:36 -0700", "message": "Use correct object type for role member delete notifications (#1981)"}, {"oid": "1d970ce72c2f81aed5576fff068103bbba022aaf", "committedDate": "2022-11-29 23:50:29 +0200", "message": "add gcp project attribute for domains (#2005)"}, {"oid": "c292a1a2fb6e3a300a3060a6bcea6a96f696932c", "committedDate": "2022-12-13 08:56:43 -0800", "message": "Return the correct response from putMembership/putGroupMembership once a pending member was added (#2023)"}, {"oid": "fc5a206d1cb23dd2bbfd9af7e3125ec270ebc022", "committedDate": "2023-01-10 21:48:12 -0800", "message": "allow domain admins to enable audit flag for new roles/groups (#2032)"}, {"oid": "70850ab1de4055e765cf4ead6946b431900ff8c8", "committedDate": "2023-01-23 16:40:36 -0800", "message": "move cloud provider role generation logic out of dbstore library to dbservice (#2043)"}, {"oid": "0ff7ff4f9658fd42e8ee2161d870a89dce5167e4", "committedDate": "2023-02-02 09:18:32 -0800", "message": "Add a requirement for admin approval to delete members in review-enabled roles (#2053)"}, {"oid": "ff57628b890f53c43fec6dd2cacf98a574c95b2d", "committedDate": "2023-02-08 15:55:32 -0800", "message": "extends group with deleteProtection attribute and pending group membe\u2026 (#2067)"}, {"oid": "bb1d69af70a90aeedc28a46604283064e0dad8de", "committedDate": "2023-02-16 07:44:40 -0800", "message": "add audit enable to role (#2055)"}, {"oid": "4ee14d784973ce7da8aba96b35eefdbc5d61d97b", "committedDate": "2023-03-07 11:34:04 -0800", "message": "make aws/gcp assume role action values configurable (#2090)"}, {"oid": "5216da47ef8bca89ba0eae790f72739d9d73fcc6", "committedDate": "2023-03-09 10:36:29 -0800", "message": "Add optional 'description' to role (#2091)"}, {"oid": "d1b98d4614d62fe34b408cfa1a26fb59674d6494", "committedDate": "2023-03-27 16:46:33 -0700", "message": "store GCP project number along with project id in athenz domain metadata (#2113)"}, {"oid": "715cf96c679e817600a0a25160c96878e5eda735", "committedDate": "2023-03-27 18:01:33 -0700", "message": "special resource for gcp starting with service/ (#2115)"}, {"oid": "6e7342a1e98207b87e3eae45341db281b7b3b9c7", "committedDate": "2023-04-13 14:30:39 -0700", "message": "designate separate action for assertions when assuming gcp service accounts (#2127)"}, {"oid": "523f7f753fa2a4a112ae4fb7a5389203af8b9594", "committedDate": "2023-05-29 08:52:21 -0700", "message": "fix role update on expiration and review dates (#2185)"}, {"oid": "7069bf871635c4e5308d37341904241388b1ccda", "committedDate": "2023-05-30 15:31:26 -0700", "message": "support product id (string) format association with domains (#2193)"}, {"oid": "368d0bc139931c03d31824c4f02394b38e3ead95", "committedDate": "2023-06-02 13:15:05 -0700", "message": "support headless user type - managed by user authority but treated like service (#2197)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxNjc3NQ==", "url": "https://github.com/AthenZ/athenz/pull/1157#discussion_r511016775", "body": "no need to create an array list with one member all the time. Instead use Collections.singletonList()", "bodyText": "no need to create an array list with one member all the time. Instead use Collections.singletonList()", "bodyHTML": "<p dir=\"auto\">no need to create an array list with one member all the time. Instead use Collections.singletonList()</p>", "author": "havetisyan", "createdAt": "2020-10-23T16:57:17Z", "path": "servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java", "diffHunk": "@@ -6402,6 +6403,147 @@ void enforceGroupUserAuthorityRestrictions(final String domainName, final String\n         }\n     }\n \n+    /**\n+     * This method returns list of Principals based on the state parameter supplied\n+     * @param queriedState state of principal\n+     * @return List of Principals from DB\n+     */\n+    List<Principal> getPrincipals(int queriedState) {\n+        List<Principal> principals = new ArrayList<>();\n+        Principal principal;\n+        try (ObjectStoreConnection con = store.getConnection(true, false)) {\n+           List<String> dbPrincipals = con.getPrincipals(queriedState);\n+            Principal.State principalState = Principal.State.getState(queriedState);\n+           for (String dbPrincipal : dbPrincipals) {\n+               principal = ZMSUtils.createPrincipalForName(dbPrincipal, zmsConfig.getUserDomain(), null);\n+               ((SimplePrincipal) principal).setState(principalState);\n+               principals.add(principal);\n+           }\n+        }\n+        return principals;\n+    }\n+\n+    /**\n+     * This method toggles state for supplied Principals based on the flag in DB\n+     * as well as modifies memberships of all roles and groups of current principal(s)\n+     * @param changedPrincipals List of Principals from User Authority\n+     * @param suspended boolean indicating principal's state\n+     */\n+    void updatePrincipalByStateFromAuthority(List<Principal> changedPrincipals, boolean suspended) {\n+        final String caller = \"updatePrincipalByStateFromAuthority\";\n+        List<Principal> updatedUsers = new ArrayList<>();\n+        if (!changedPrincipals.isEmpty()) {\n+            try (ObjectStoreConnection con = store.getConnection(true, true)) {\n+\n+                // first lets update the new state in DB\n+                for (Principal changedPrincipal : changedPrincipals) {\n+                    updatePrincipalState(suspended, updatedUsers, con, changedPrincipal);\n+                }\n+                // if new state is updated successfully\n+                // then we need to modify all roles and groups where given principal is member of\n+                if (!updatedUsers.isEmpty()) {\n+                    for (Principal updatedUser : updatedUsers) {\n+                        try {\n+                            updateRoleMembershipsByPrincipalState(suspended, caller, con, updatedUser);\n+                            updateGroupMembershipByPrincipalState(suspended, caller, con, updatedUser);\n+                        } catch (ResourceException ex) {\n+                            if (ex.getCode() == ResourceException.NOT_FOUND) {\n+                                continue;\n+                            }\n+                            throw ex;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void updateGroupMembershipByPrincipalState(boolean suspended, String caller, ObjectStoreConnection con, Principal updatedUser) {\n+        List<GroupMember> groupMembersWithUpdatedState;\n+        GroupMember groupMember;\n+        DomainGroupMember domainGroupMember;\n+        Set<GroupMember> updatedGroups = new HashSet<>();\n+\n+        domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n+        if (!domainGroupMember.getMemberGroups().isEmpty()) {\n+            for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n+                groupMember = new GroupMember();\n+                groupMember.setMemberName(updatedUser.getFullName());\n+                if (suspended) {\n+                    groupMember.setSystemDisabled(currentGroup.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                } else {\n+                    groupMember.setSystemDisabled(currentGroup.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n+                }\n+                groupMembersWithUpdatedState = new ArrayList<>();", "originalCommit": "f2b6979e4235f325d7eea75d6f63d358c03d8d3c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0dff4be75160c89e9e35b4634db11456460fa25f", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 2d11e7268..08f2ee72e 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6462,34 +6482,29 @@ public class DBService implements RolesProvider {\n         List<GroupMember> groupMembersWithUpdatedState;\n         GroupMember groupMember;\n         DomainGroupMember domainGroupMember;\n-        Set<GroupMember> updatedGroups = new HashSet<>();\n-\n+        int newState;\n+        Set<String> updatedDomains = new HashSet<>();\n         domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n         if (!domainGroupMember.getMemberGroups().isEmpty()) {\n             for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n                 groupMember = new GroupMember();\n                 groupMember.setMemberName(updatedUser.getFullName());\n-                if (suspended) {\n-                    groupMember.setSystemDisabled(currentGroup.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                } else {\n-                    groupMember.setSystemDisabled(currentGroup.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                }\n-                groupMembersWithUpdatedState = new ArrayList<>();\n-                groupMembersWithUpdatedState.add(groupMember);\n+                newState = suspended ? currentGroup.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n+                        currentGroup.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n+                groupMember.setSystemDisabled(newState);\n+                groupMembersWithUpdatedState = Collections.singletonList(groupMember);\n \n                 // Following method does Audit entry as well\n                 if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n                         currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-                    updatedGroups.add(currentGroup);\n+                    con.updateGroupModTimestamp(currentGroup.getDomainName(), currentGroup.getGroupName());\n+                    updatedDomains.add(currentGroup.getDomainName());\n                 }\n             }\n-            for (GroupMember updatedGM : updatedGroups) {\n-\n-                // update our group and domain time-stamps, and invalidate local cache entry\n-                con.updateGroupModTimestamp(updatedGM.getDomainName(), updatedGM.getGroupName());\n-                con.updateDomainModTimestamp(updatedGM.getDomainName());\n-                cacheStore.invalidate(updatedGM.getDomainName());\n-            }\n+            updatedDomains.forEach(dom -> {\n+                con.updateDomainModTimestamp(dom);\n+                cacheStore.invalidate(dom);\n+            });\n         }\n     }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 2d11e7268..08f2ee72e 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6462,34 +6482,29 @@ public class DBService implements RolesProvider {\n         List<GroupMember> groupMembersWithUpdatedState;\n         GroupMember groupMember;\n         DomainGroupMember domainGroupMember;\n-        Set<GroupMember> updatedGroups = new HashSet<>();\n-\n+        int newState;\n+        Set<String> updatedDomains = new HashSet<>();\n         domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n         if (!domainGroupMember.getMemberGroups().isEmpty()) {\n             for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n                 groupMember = new GroupMember();\n                 groupMember.setMemberName(updatedUser.getFullName());\n-                if (suspended) {\n-                    groupMember.setSystemDisabled(currentGroup.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                } else {\n-                    groupMember.setSystemDisabled(currentGroup.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue());\n-                }\n-                groupMembersWithUpdatedState = new ArrayList<>();\n-                groupMembersWithUpdatedState.add(groupMember);\n+                newState = suspended ? currentGroup.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n+                        currentGroup.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n+                groupMember.setSystemDisabled(newState);\n+                groupMembersWithUpdatedState = Collections.singletonList(groupMember);\n \n                 // Following method does Audit entry as well\n                 if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n                         currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-                    updatedGroups.add(currentGroup);\n+                    con.updateGroupModTimestamp(currentGroup.getDomainName(), currentGroup.getGroupName());\n+                    updatedDomains.add(currentGroup.getDomainName());\n                 }\n             }\n-            for (GroupMember updatedGM : updatedGroups) {\n-\n-                // update our group and domain time-stamps, and invalidate local cache entry\n-                con.updateGroupModTimestamp(updatedGM.getDomainName(), updatedGM.getGroupName());\n-                con.updateDomainModTimestamp(updatedGM.getDomainName());\n-                cacheStore.invalidate(updatedGM.getDomainName());\n-            }\n+            updatedDomains.forEach(dom -> {\n+                con.updateDomainModTimestamp(dom);\n+                cacheStore.invalidate(dom);\n+            });\n         }\n     }\n \n", "next_change": {"commit": "c668f48cec94e2c928581b92ffb517f715a4840f", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 08f2ee72e..824e0aa8a 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6512,15 +6483,19 @@ public class DBService implements RolesProvider {\n         RoleMember roleMember;\n         List<RoleMember> roleMembersWithUpdatedState;\n         DomainRoleMember domainRoleMember;\n-        int newState;\n+        int newState, oldState;\n         Set<String> updatedDomains = new HashSet<>();\n         domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n         if (!domainRoleMember.getMemberRoles().isEmpty()) {\n             for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n                 roleMember = new RoleMember();\n                 roleMember.setMemberName(updatedUser.getFullName());\n-                newState = suspended ? memberRole.getSystemDisabled() | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n-                        memberRole.getSystemDisabled() & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n+                oldState = 0;\n+                if (memberRole.getSystemDisabled() != null) {\n+                    oldState = memberRole.getSystemDisabled();\n+                }\n+                newState = suspended ? oldState | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n+                        oldState & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n                 roleMember.setSystemDisabled(newState);\n                 roleMembersWithUpdatedState = Collections.singletonList(roleMember);\n \n", "next_change": {"commit": "a5bb615881583fa6f39621e2ea3bf39d3886340b", "changed_code": [{"header": "diff --git a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\nindex 824e0aa8a..8274a1809 100644\n--- a/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n+++ b/servers/zms/src/main/java/com/yahoo/athenz/zms/DBService.java\n", "chunk": "@@ -6446,61 +7563,487 @@ public class DBService implements RolesProvider {\n         }\n     }\n \n-    private void updateGroupMembershipByPrincipalState(boolean suspended, String caller, ObjectStoreConnection con, Principal updatedUser) {\n-        List<GroupMember> groupMembersWithUpdatedState;\n-        GroupMember groupMember;\n-        DomainGroupMember domainGroupMember;\n-        int newState, oldState;\n-        Set<String> updatedDomains = new HashSet<>();\n-        domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n-        if (!domainGroupMember.getMemberGroups().isEmpty()) {\n-            for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n-                groupMember = new GroupMember();\n-                groupMember.setMemberName(updatedUser.getFullName());\n-                oldState = 0;\n-                if (groupMember.getSystemDisabled() != null) {\n-                    oldState = groupMember.getSystemDisabled();\n-                }\n-                newState = suspended ? oldState | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n-                        oldState & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n-                groupMember.setSystemDisabled(newState);\n-                groupMembersWithUpdatedState = Collections.singletonList(groupMember);\n-                // Following method does Audit entry as well\n-                if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n-                        currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n-                    con.updateGroupModTimestamp(currentGroup.getDomainName(), currentGroup.getGroupName());\n-                    updatedDomains.add(currentGroup.getDomainName());\n-                }\n-            }\n-            updatedDomains.forEach(dom -> {\n-                con.updateDomainModTimestamp(dom);\n-                cacheStore.invalidate(dom);\n-            });\n-        }\n-    }\n+    void executePutAssertionConditions(ResourceContext ctx, String domainName, String policyName, long assertionId,\n+                                       AssertionConditions assertionConditions, String auditRef, String caller) {\n \n-    private void updateRoleMembershipsByPrincipalState(boolean suspended, String caller, ObjectStoreConnection con, Principal updatedUser) {\n-        RoleMember roleMember;\n-        List<RoleMember> roleMembersWithUpdatedState;\n-        DomainRoleMember domainRoleMember;\n-        int newState, oldState;\n-        Set<String> updatedDomains = new HashSet<>();\n-        domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n-        if (!domainRoleMember.getMemberRoles().isEmpty()) {\n-            for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n-                roleMember = new RoleMember();\n-                roleMember.setMemberName(updatedUser.getFullName());\n-                oldState = 0;\n-                if (memberRole.getSystemDisabled() != null) {\n-                    oldState = memberRole.getSystemDisabled();\n-                }\n-                newState = suspended ? oldState | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n-                        oldState & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n-                roleMember.setSystemDisabled(newState);\n-                roleMembersWithUpdatedState = Collections.singletonList(roleMember);\n+        // our exception handling code does the check for retry count\n+        // and throws the exception it had received when the retry\n+        // count reaches 0\n \n-                // Following method does Audit entry as well\n-                if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n+        for (int retryCount = defaultRetryCount; ; retryCount--) {\n+\n+            try (ObjectStoreConnection con = store.getConnection(false, true)) {\n+\n+                // first verify that auditing requirements are met\n+\n+                checkDomainAuditEnabled(con, domainName, auditRef, caller, getPrincipalName(ctx), AUDIT_TYPE_POLICY);\n+\n+                // now we need verify our quota check\n+\n+                quotaCheck.checkAssertionConditionsQuota(con, assertionId, assertionConditions, caller);\n+\n+                // process our insert assertion condition.\n+\n+                if (!con.insertAssertionConditions(assertionId, assertionConditions)) {\n+                    throw ZMSUtils.requestError(String.format(\"%s: unable to insert assertion conditions for policy=%s assertionId=%d\", caller, policyName, assertionId), caller);\n+                }\n+\n+                // update our policy and domain time-stamps, and invalidate local cache entry\n+\n+                con.updatePolicyModTimestamp(domainName, policyName, null);\n+                saveChanges(con, domainName);\n+\n+\n+                // audit log the request\n+                StringBuilder auditDetails = new StringBuilder(ZMSConsts.STRING_BLDR_SIZE_DEFAULT);\n+                auditDetails.append(\"{\\\"policy\\\": \\\"\").append(policyName)\n+                        .append(\"\\\", \\\"assertionId\\\": \").append(assertionId)\n+                        .append(\", \");\n+                auditLogAssertionConditions(auditDetails, assertionConditions.getConditionsList(), \"new-assertion-conditions\");\n+                auditDetails.append(\"}\");\n+\n+                auditLogRequest(ctx, domainName, auditRef, caller, ZMSConsts.HTTP_PUT,\n+                        policyName, auditDetails.toString());\n+\n+                // add domain change event\n+                addDomainChangeMessage(ctx, domainName, policyName, DomainChangeMessage.ObjectType.POLICY);\n+                \n+                return;\n+\n+            } catch (ResourceException ex) {\n+\n+                // otherwise check if we need to retry or return failure\n+                if (!shouldRetryOperation(ex, retryCount)) {\n+                    throw ex;\n+                }\n+            }\n+        }\n+    }\n+\n+    void executePutAssertionCondition(ResourceContext ctx, String domainName, String policyName, long assertionId,\n+                                      AssertionCondition assertionCondition, String auditRef, String caller) {\n+\n+        // our exception handling code does the check for retry count\n+        // and throws the exception it had received when the retry\n+        // count reaches 0\n+\n+        for (int retryCount = defaultRetryCount; ; retryCount--) {\n+\n+            try (ObjectStoreConnection con = store.getConnection(false, true)) {\n+\n+                // first verify that auditing requirements are met\n+\n+                checkDomainAuditEnabled(con, domainName, auditRef, caller, getPrincipalName(ctx), AUDIT_TYPE_POLICY);\n+\n+                // process our insert assertion condition.\n+\n+                if (assertionCondition.getId() == null) {\n+\n+                    // now we need verify our quota check\n+                    quotaCheck.checkAssertionConditionQuota(con, assertionId, assertionCondition, caller);\n+\n+                    // no condition id in the request. so we are going to generate the next condition id for\n+                    // the given assertion id and then use it to insert given keys\n+                    assertionCondition.setId(con.getNextConditionId(assertionId, caller));\n+                    if (!con.insertAssertionCondition(assertionId, assertionCondition)) {\n+                        throw ZMSUtils.requestError(String.format(\"%s: unable to insert new assertion condition for policy=%s assertionId=%d\", caller, policyName, assertionId), caller);\n+                    }\n+                } else {\n+\n+                    // existing assertion condition keys found with given condition id. so delete existing keys from DB for the given condition id\n+                    if (!con.deleteAssertionCondition(assertionId, assertionCondition.getId())) {\n+                        throw ZMSUtils.notFoundError(String.format(\"%s: unable to delete assertion condition during putAssertionCondition for policy=%s assertionId=%d conditionId=%d\"\n+                                , caller, policyName, assertionId, assertionCondition.getId()), caller);\n+                    }\n+                    // now we need verify our quota check after deleting the old entries\n+                    quotaCheck.checkAssertionConditionQuota(con, assertionId, assertionCondition, caller);\n+\n+                    // now insert the new keys against existing condition id\n+                    if (!con.insertAssertionCondition(assertionId, assertionCondition)) {\n+                        throw ZMSUtils.requestError(String.format(\"%s: unable to insert assertion condition for policy=%s assertionId=%d\", caller, policyName, assertionId), caller);\n+                    }\n+                }\n+\n+                // update our policy and domain time-stamps, and invalidate local cache entry\n+\n+                con.updatePolicyModTimestamp(domainName, policyName, null);\n+                saveChanges(con, domainName);\n+\n+\n+                // audit log the request\n+                StringBuilder auditDetails = new StringBuilder(ZMSConsts.STRING_BLDR_SIZE_DEFAULT);\n+                auditDetails.append(\"{\\\"policy\\\": \\\"\").append(policyName)\n+                        .append(\"\\\", \\\"assertionId\\\": \").append(assertionId)\n+                        .append(\", \\\"new-assertion-condition\\\": \");\n+                auditLogAssertionCondition(auditDetails, assertionCondition, true);\n+                auditDetails.append(\"}\");\n+\n+                auditLogRequest(ctx, domainName, auditRef, caller, ZMSConsts.HTTP_PUT,\n+                        policyName, auditDetails.toString());\n+\n+                // add domain change event\n+                addDomainChangeMessage(ctx, domainName, policyName, DomainChangeMessage.ObjectType.POLICY);\n+                \n+                return;\n+\n+            } catch (ResourceException ex) {\n+\n+                // otherwise check if we need to retry or return failure\n+                if (!shouldRetryOperation(ex, retryCount)) {\n+                    throw ex;\n+                }\n+            }\n+        }\n+    }\n+\n+    public void executeDeleteAssertionConditions(ResourceContext ctx, String domainName, String policyName, Long assertionId, String auditRef, String caller) {\n+\n+        // our exception handling code does the check for retry count\n+        // and throws the exception it had received when the retry\n+        // count reaches 0\n+\n+        for (int retryCount = defaultRetryCount; ; retryCount--) {\n+\n+            try (ObjectStoreConnection con = store.getConnection(true, true)) {\n+\n+                // first verify that auditing requirements are met\n+\n+                checkDomainAuditEnabled(con, domainName, auditRef, caller, getPrincipalName(ctx), AUDIT_TYPE_POLICY);\n+\n+                // fetch the assertion for our audit log\n+\n+                List<AssertionCondition> assertionConditions = con.getAssertionConditions(assertionId);\n+                if (assertionConditions == null) {\n+                    throw ZMSUtils.notFoundError(String.format(\"%s: unable to read assertion conditions for policy=%s assertionId=%d\", caller,\n+                            policyName, assertionId), caller);\n+                }\n+\n+                // process our delete assertion conditions. since this is a \"single\"\n+                // operation, we are not using any transactions.\n+\n+                if (!con.deleteAssertionConditions(assertionId)) {\n+                    throw ZMSUtils.notFoundError(String.format(\"%s: unable to delete assertion conditions for policy=%s assertionId=%d\", caller,\n+                            policyName, assertionId), caller);\n+                }\n+\n+                // update our policy and domain time-stamps, and invalidate local cache entry\n+\n+                con.updatePolicyModTimestamp(domainName, policyName, null);\n+                con.updateDomainModTimestamp(domainName);\n+                cacheStore.invalidate(domainName);\n+\n+                // audit log the request\n+\n+                StringBuilder auditDetails = new StringBuilder(ZMSConsts.STRING_BLDR_SIZE_DEFAULT);\n+                auditDetails.append(\"{\\\"policy\\\": \\\"\").append(policyName)\n+                        .append(\"\\\", \\\"assertionId\\\": \").append(assertionId)\n+                        .append(\", \");\n+                auditLogAssertionConditions(auditDetails, assertionConditions, \"deleted-assertion-conditions\");\n+                auditDetails.append(\"}\");\n+\n+                auditLogRequest(ctx, domainName, auditRef, caller, ZMSConsts.HTTP_DELETE,\n+                        policyName, auditDetails.toString());\n+\n+                // add domain change event\n+                addDomainChangeMessage(ctx, domainName, policyName, DomainChangeMessage.ObjectType.POLICY);\n+                \n+                return;\n+\n+            } catch (ResourceException ex) {\n+\n+                // otherwise check if we need to retry or return failure\n+\n+                if (!shouldRetryOperation(ex, retryCount)) {\n+                    throw ex;\n+                }\n+            }\n+        }\n+    }\n+\n+    public void executeDeleteAssertionCondition(ResourceContext ctx, String domainName, String policyName, Long assertionId, Integer conditionId, String auditRef, String caller) {\n+        // our exception handling code does the check for retry count\n+        // and throws the exception it had received when the retry\n+        // count reaches 0\n+\n+        for (int retryCount = defaultRetryCount; ; retryCount--) {\n+\n+            try (ObjectStoreConnection con = store.getConnection(true, true)) {\n+\n+                // first verify that auditing requirements are met\n+\n+                checkDomainAuditEnabled(con, domainName, auditRef, caller, getPrincipalName(ctx), AUDIT_TYPE_POLICY);\n+\n+                // fetch the assertion for our audit log\n+\n+                AssertionCondition assertionCondition = con.getAssertionCondition(assertionId, conditionId);\n+                if (assertionCondition == null) {\n+                    throw ZMSUtils.notFoundError(String.format(\"%s: unable to read assertion condition for policy=%s assertionId=%d conditionId=%d\"\n+                            , caller, policyName, assertionId, conditionId), caller);\n+                }\n+\n+                // process our delete assertion condition. since this is a \"single\"\n+                // operation, we are not using any transactions.\n+\n+                if (!con.deleteAssertionCondition(assertionId, conditionId)) {\n+                    throw ZMSUtils.notFoundError(String.format(\"%s: unable to delete assertion condition for policy=%s assertionId=%d conditionId=%d\"\n+                            , caller, policyName, assertionId, conditionId), caller);\n+                }\n+\n+                // update our policy and domain time-stamps, and invalidate local cache entry\n+\n+                con.updatePolicyModTimestamp(domainName, policyName, null);\n+                con.updateDomainModTimestamp(domainName);\n+                cacheStore.invalidate(domainName);\n+\n+                // audit log the request\n+\n+                StringBuilder auditDetails = new StringBuilder(ZMSConsts.STRING_BLDR_SIZE_DEFAULT);\n+                auditDetails.append(\"{\\\"policy\\\": \\\"\").append(policyName)\n+                        .append(\"\\\", \\\"assertionId\\\": \").append(assertionId)\n+                        .append(\", \\\"deleted-assertion-condition\\\": \");\n+                auditLogAssertionCondition(auditDetails, assertionCondition, true);\n+                auditDetails.append(\"}\");\n+\n+                auditLogRequest(ctx, domainName, auditRef, caller, ZMSConsts.HTTP_DELETE,\n+                        policyName, auditDetails.toString());\n+\n+                // add domain change event\n+                addDomainChangeMessage(ctx, domainName, policyName, DomainChangeMessage.ObjectType.POLICY);\n+                \n+                return;\n+\n+            } catch (ResourceException ex) {\n+\n+                // otherwise check if we need to retry or return failure\n+\n+                if (!shouldRetryOperation(ex, retryCount)) {\n+                    throw ex;\n+                }\n+            }\n+        }\n+    }\n+\n+    public void putDomainDependency(ResourceContext ctx, String domainName, String service, String auditRef, String caller) {\n+\n+        // our exception handling code does the check for retry count\n+        // and throws the exception it had received when the retry\n+        // count reaches 0\n+\n+        for (int retryCount = defaultRetryCount; ; retryCount--) {\n+\n+            try (ObjectStoreConnection con = store.getConnection(false, true)) {\n+\n+                final String principal = getPrincipalName(ctx);\n+\n+                // first verify that auditing requirements are met\n+\n+                checkDomainAuditEnabled(con, domainName, auditRef, caller, principal, AUDIT_TYPE_DOMAIN);\n+\n+                // verify domain exists\n+\n+                Domain domain = con.getDomain(domainName);\n+                if (domain == null) {\n+                    con.rollbackChanges();\n+                    throw ZMSUtils.notFoundError(caller + \": Unknown domain: \" + domainName, caller);\n+                }\n+\n+                // now process the request\n+\n+                StringBuilder auditDetails = new StringBuilder(ZMSConsts.STRING_BLDR_SIZE_DEFAULT);\n+                if (!processDomainDependency(con, domainName, service, auditDetails)) {\n+                    con.rollbackChanges();\n+                    throw ZMSUtils.internalServerError(\"unable to put dependency on domain \" + domainName + \" for service \" + service, caller);\n+                }\n+\n+                // update our domain time-stamp and save changes\n+\n+                saveChanges(con, domainName);\n+\n+                // audit log the request\n+\n+                auditLogRequest(ctx, domainName, auditRef, caller, ZMSConsts.HTTP_PUT,\n+                        service, auditDetails.toString());\n+\n+                // add domain change event\n+                addDomainChangeMessage(ctx, domainName, service, DomainChangeMessage.ObjectType.DOMAIN);\n+\n+                return;\n+\n+            } catch (ResourceException ex) {\n+                if (!shouldRetryOperation(ex, retryCount)) {\n+                    throw ex;\n+                }\n+            }\n+        }\n+    }\n+\n+    public void deleteDomainDependency(ResourceContext ctx, String domainName, String service, String auditRef, String caller) {\n+\n+        // our exception handling code does the check for retry count\n+        // and throws the exception it had received when the retry\n+        // count reaches 0\n+\n+        for (int retryCount = defaultRetryCount; ; retryCount--) {\n+\n+            try (ObjectStoreConnection con = store.getConnection(false, true)) {\n+\n+                final String principal = getPrincipalName(ctx);\n+\n+                // first verify that auditing requirements are met\n+\n+                checkDomainAuditEnabled(con, domainName, auditRef, caller, principal, AUDIT_TYPE_DOMAIN);\n+\n+                // verify domain exists\n+\n+                Domain domain = con.getDomain(domainName);\n+                if (domain == null) {\n+                    con.rollbackChanges();\n+                    throw ZMSUtils.notFoundError(caller + \": Unknown domain: \" + domainName, caller);\n+                }\n+\n+                // now process the request\n+\n+                StringBuilder auditDetails = new StringBuilder(ZMSConsts.STRING_BLDR_SIZE_DEFAULT);\n+                if (!processDeleteDomainDependency(con, domainName, service, auditDetails)) {\n+                    con.rollbackChanges();\n+                    throw ZMSUtils.internalServerError(\"unable to delete dependency on domain \" + domainName + \" for service \" + service, caller);\n+                }\n+\n+                // update our domain time-stamp and save changes\n+\n+                saveChanges(con, domainName);\n+\n+                // audit log the request\n+\n+                auditLogRequest(ctx, domainName, auditRef, caller, ZMSConsts.HTTP_DELETE,\n+                        service, auditDetails.toString());\n+\n+                // add domain change event\n+                addDomainChangeMessage(ctx, domainName, service, DomainChangeMessage.ObjectType.DOMAIN);\n+\n+                return;\n+\n+            } catch (ResourceException ex) {\n+                if (!shouldRetryOperation(ex, retryCount)) {\n+                    throw ex;\n+                }\n+            }\n+        }\n+    }\n+\n+    private boolean processDomainDependency(ObjectStoreConnection con, String domainName, String service,\n+                                            StringBuilder auditDetails) {\n+\n+        boolean requestSuccess = con.insertDomainDependency(domainName, service);\n+\n+        // if we didn't insert a dependency then we need to return failure\n+\n+        if (!requestSuccess) {\n+            return false;\n+        }\n+\n+        // open our audit record and log the dependency\n+\n+        auditDetails.append(\"{\\\"domain-dependencies\\\": \");\n+        auditDetails.append(\"{\\\"domain\\\": \\\"\").append(domainName)\n+                .append(\"\\\", \\\"service\\\": \\\"\").append(service).append(\"\\\"}\")\n+                .append('}');\n+\n+        return true;\n+    }\n+\n+    private boolean processDeleteDomainDependency(ObjectStoreConnection con, String domainName, String service,\n+                                                  StringBuilder auditDetails) {\n+\n+        boolean requestSuccess = con.deleteDomainDependency(domainName, service);\n+\n+        // if we didn't delete the dependency then we need to return failure\n+\n+        if (!requestSuccess) {\n+            return false;\n+        }\n+\n+        // open our audit record and log the dependency\n+\n+        auditDetails.append(\"{\\\"delete-domain-dependencies\\\": \");\n+        auditDetails.append(\"{\\\"domain\\\": \\\"\").append(domainName)\n+                .append(\"\\\", \\\"service\\\": \\\"\").append(service).append(\"\\\"}\")\n+                .append('}');\n+\n+        return true;\n+    }\n+\n+    public ServiceIdentityList listServiceDependencies(String domainName) {\n+        try (ObjectStoreConnection con = store.getConnection(true, false)) {\n+            ServiceIdentityList serviceIdentityList = new ServiceIdentityList();\n+            serviceIdentityList.setNames(con.listServiceDependencies(domainName));\n+            return serviceIdentityList;\n+        }\n+    }\n+\n+    public DomainList listDomainDependencies(String service) {\n+        try (ObjectStoreConnection con = store.getConnection(true, false)) {\n+            DomainList domainList = new DomainList();\n+            domainList.setNames(con.listDomainDependencies(service));\n+            return domainList;\n+        }\n+    }\n+\n+    private void updateGroupMembershipByPrincipalState(boolean suspended, String caller, ObjectStoreConnection con, Principal updatedUser) {\n+        List<GroupMember> groupMembersWithUpdatedState;\n+        GroupMember groupMember;\n+        DomainGroupMember domainGroupMember;\n+        int newState, oldState;\n+        Set<String> updatedDomains = new HashSet<>();\n+        domainGroupMember = con.getPrincipalGroups(updatedUser.getFullName(), null);\n+        if (!domainGroupMember.getMemberGroups().isEmpty()) {\n+            for (GroupMember currentGroup : domainGroupMember.getMemberGroups()) {\n+                groupMember = new GroupMember();\n+                groupMember.setMemberName(updatedUser.getFullName());\n+                oldState = 0;\n+                if (groupMember.getSystemDisabled() != null) {\n+                    oldState = groupMember.getSystemDisabled();\n+                }\n+                newState = suspended ? oldState | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n+                        oldState & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n+                groupMember.setSystemDisabled(newState);\n+                groupMembersWithUpdatedState = Collections.singletonList(groupMember);\n+                // Following method does Audit entry as well\n+                if (updateGroupMemberDisabledState(null, con, groupMembersWithUpdatedState, currentGroup.getDomainName(),\n+                        currentGroup.getGroupName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n+                    con.updateGroupModTimestamp(currentGroup.getDomainName(), currentGroup.getGroupName());\n+                    updatedDomains.add(currentGroup.getDomainName());\n+                }\n+            }\n+            updatedDomains.forEach(dom -> {\n+                con.updateDomainModTimestamp(dom);\n+                cacheStore.invalidate(dom);\n+            });\n+        }\n+    }\n+\n+    private void updateRoleMembershipsByPrincipalState(boolean suspended, String caller, ObjectStoreConnection con, Principal updatedUser) {\n+        RoleMember roleMember;\n+        List<RoleMember> roleMembersWithUpdatedState;\n+        DomainRoleMember domainRoleMember;\n+        int newState, oldState;\n+        Set<String> updatedDomains = new HashSet<>();\n+        domainRoleMember = con.getPrincipalRoles(updatedUser.getFullName(), null);\n+        if (!domainRoleMember.getMemberRoles().isEmpty()) {\n+            for (MemberRole memberRole : domainRoleMember.getMemberRoles()) {\n+                roleMember = new RoleMember();\n+                roleMember.setMemberName(updatedUser.getFullName());\n+                oldState = 0;\n+                if (memberRole.getSystemDisabled() != null) {\n+                    oldState = memberRole.getSystemDisabled();\n+                }\n+                newState = suspended ? oldState | Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue() :\n+                        oldState & ~Principal.State.AUTHORITY_SYSTEM_SUSPENDED.getValue();\n+                roleMember.setSystemDisabled(newState);\n+                roleMembersWithUpdatedState = Collections.singletonList(roleMember);\n+\n+                // Following method does Audit entry as well\n+                if (updateRoleMemberDisabledState(null, con, roleMembersWithUpdatedState, memberRole.getDomainName(),\n                         memberRole.getRoleName(), ZMSConsts.SYS_AUTH_MONITOR, AUDIT_REF, caller)) {\n                     con.updateRoleModTimestamp(memberRole.getDomainName(), memberRole.getRoleName());\n                     updatedDomains.add(memberRole.getDomainName());\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "e34ebcf544293ebd1aafd5474dae1c59105bf8a7", "message": "Merge commit", "committedDate": null}, {"oid": "9a9c82c13d156e06dad8464c3a6c52c8e2bc6b89", "committedDate": "2020-10-26 14:15:03 -0700", "message": "remove sending back deprected members field in roles (#1160)"}, {"oid": "31a0dd7362f585f85992d4ff86fbf975d9d736dd", "committedDate": "2020-10-31 14:59:07 -0700", "message": "add azure_subscription field to domains (#1167)"}, {"oid": "c668f48cec94e2c928581b92ffb517f715a4840f", "committedDate": "2020-11-06 18:05:10 -0800", "message": "handle sys disabled null scenario (#1176)"}, {"oid": "f24d15baaaddc96c85fbceb31fcaded756a69f2e", "committedDate": "2020-11-14 16:51:57 -0800", "message": "role tags - generated code and schema changes (#1179)"}, {"oid": "30e272d8a9ec2649a1d876c1c111cf38e27c1743", "committedDate": "2020-12-07 08:48:58 -0800", "message": "putRoleMeta tags support (#1208)"}, {"oid": "f0e0a91b80250236244db9f8cba79e1def809995", "committedDate": "2020-12-23 15:40:53 -0800", "message": "updating group expiry date (#1221)"}, {"oid": "7a2837c7578ab8d36c62b48ecb1d0079c670616b", "committedDate": "2020-12-29 13:44:04 -0800", "message": "granular authz action for managing role members (#1228)"}, {"oid": "d6a0d659fe96486ffcf31bb93e919656be9eaf89", "committedDate": "2021-01-13 08:15:47 -0800", "message": "domain tags implementation (#1235)"}, {"oid": "3c939966592bf7cc6ff25df12a8d21d4c2c89b2b", "committedDate": "2021-01-19 22:05:22 -0800", "message": "client api update for rich authorization requests and consistent naming of entity objects (#1248)"}, {"oid": "3db6ed7b169fce5bbeaa1fae84ff7881e9a4e435", "committedDate": "2021-01-21 09:17:41 -0800", "message": "limit number of role and domain tags (#1255)"}, {"oid": "218b71958d88fb039dfa6e7c5448c7e4d00cb337", "committedDate": "2021-01-25 17:53:41 -0800", "message": "update domain last modified timestamp after tag update (#1262)"}, {"oid": "bccc5fb4dc1c2407a0293f322c3d97711af4297c", "committedDate": "2021-03-07 18:11:58 -0800", "message": "sonarcloud: method always returns same result (#1329)"}, {"oid": "e421f20094d24075d2cec7ab7adecff7d630a286", "committedDate": "2021-03-16 18:08:03 -0700", "message": "expose new domain attribute: business-service (#1357)"}, {"oid": "7b4afd5d40394226b3aa1af8bf10e90e528091b3", "committedDate": "2021-04-01 14:52:30 -0700", "message": "Add memberExpiryDays and serviceExpiryDays support for groups (#1388)"}, {"oid": "5ab30978cc4fc03e1b3022305f6e14a5a425e9e9", "committedDate": "2021-04-07 16:30:50 -0700", "message": "new DomainMetaStore interface support in ZMS (#1430)"}, {"oid": "9bedde4310d6493406d264422f23e16f33213546", "committedDate": "2021-04-08 09:44:29 -0700", "message": "Add group review days to role (#1428)"}, {"oid": "a554c75c51c5945b0e58ae87866de93ff1d5cfbc", "committedDate": "2021-04-15 12:12:02 -0700", "message": "during provider admin setup, ignore deletes (#1444)"}, {"oid": "1c564548381b3c09ad4214d0f30c667e9cc0d022", "committedDate": "2021-04-30 15:22:51 -0700", "message": "log full policy assertion details during delete operations in audit log (#1469)"}, {"oid": "611ac334bfbc1c43ec20154cf9448b96fae365d6", "committedDate": "2021-05-27 16:30:38 -0700", "message": "handle null contition processDomainTags (#1495)"}, {"oid": "addf4424a5bf842b58558c6f61ac0b46277d9535", "committedDate": "2021-06-07 09:38:12 -0700", "message": "allow role/group review regardless of role/group expiry/reminder settings (#1503)"}, {"oid": "4b39ffbd18da3d10a581fb10209806c97b432d28", "committedDate": "2021-06-09 15:31:17 -0700", "message": "enable role review without setting restrictions (#1512)"}, {"oid": "898ff0aa4fddd1a9ed111496cb9e4acb544605af", "committedDate": "2021-06-14 10:42:10 -0700", "message": "Update Tag Values to include '/', ':' (#1517)"}, {"oid": "cf535673b0a4cbcdc81e17c7def4cb6822edd78c", "committedDate": "2021-06-22 06:44:42 -0700", "message": "Allow system admins to set domain meta attribute business service (#1522)"}, {"oid": "934fc3d7fc859731f4beab3b03b83a15ac717a2d", "committedDate": "2021-06-29 12:57:53 -0700", "message": "assertion condition server changes (#1528)"}, {"oid": "1fa51b852890c1576254be6a8a2b5dbebc89865c", "committedDate": "2021-07-21 14:41:19 -0700", "message": "UI : update error message (#1557)"}, {"oid": "09de45bb794eb5e7c29f705b5ce567c75fde4e84", "committedDate": "2021-07-29 15:49:16 -0700", "message": "multi-version policy - introducing version/active in policy object (#1568)"}, {"oid": "4abff4b9952e4836f79bf3f1934baf8fe2bcebf9", "committedDate": "2021-08-08 11:39:07 -0700", "message": "Disable Reminder Review Notifications By Tag zms.DisableReminderNotifications (#1579)"}, {"oid": "6a1523accc3ec83fe54d78c3d919d9cddbcb1b7e", "committedDate": "2021-08-17 18:32:28 -0700", "message": "fixing the order of updates for assertion condition api operations (#1591)"}, {"oid": "66590f4fc47f899f3990f20895f953074e40f259", "committedDate": "2021-09-10 07:55:42 -0700", "message": "Implement multi-version policies endpoints (#1605)"}, {"oid": "1ad624427917493d31bd1b8ffa6303c4d6353055", "committedDate": "2021-09-10 13:51:19 -0700", "message": "update group last modified when user is deleted (#1613)"}, {"oid": "91b116418656f123dae9a3405cb2e498d4d3aff4", "committedDate": "2021-09-12 09:52:05 +0300", "message": "additional validation checks when processing versioned policies (#1614)"}, {"oid": "2531428956f87774f86721f02b430861ca8897ec", "committedDate": "2021-09-14 09:49:34 +0300", "message": "additional checks when setting a policy version as active (#1615)"}, {"oid": "2968c209e870ce57fbdb1fb048a21692d80cfea6", "committedDate": "2021-10-01 07:25:34 -0700", "message": "rdl publishChangeEvents generator (#1624)"}, {"oid": "8a6960ce9878277c5abda1d104ca070831b36230", "committedDate": "2021-10-03 13:48:03 -0700", "message": "Allow specifying version name when creating new policy (#1630)"}, {"oid": "43f619b31bbd9cc3d388aa7ea29eff889cb1272d", "committedDate": "2021-10-21 08:48:51 -0700", "message": "For role expiry notification - record metrics daily while (#1654)"}, {"oid": "389f984270d7d89070c66096e87fafbcb24a261c", "committedDate": "2021-10-26 08:17:36 -0700", "message": "Group tags implementation (#1660)"}, {"oid": "120ab1fa8e9d33fa793c4254d233a09a2c23d173", "committedDate": "2021-10-29 15:08:28 -0700", "message": "Disable Group Expiry Notifications By Tag zms.DisableReminderNotifications (#1663)"}, {"oid": "1400363e8d698cf08370c89752077ebae043c5be", "committedDate": "2021-12-14 13:48:34 -0800", "message": "correct logging of role principal in audit/access logs"}, {"oid": "c8e3a5c91c5deb9640576cd3496a2af11d572f0b", "committedDate": "2021-12-23 15:03:25 -0800", "message": "protect system admin users from being removed from deleteUser api (#1715)"}, {"oid": "020e06e57b357768260f509f08b75c5c068bce53", "committedDate": "2022-02-07 08:01:55 -0800", "message": "Service Visiblity - Domain Dependencies (#1758)"}, {"oid": "fcbd4128e334a9a42f4579d179cf9578d3f4de99", "committedDate": "2022-02-07 10:12:47 -0800", "message": "support new get-stats endpoint to get per-domain/system stats (#1774)"}, {"oid": "ea831a34a70a0475bea8754cb183741dced98ff2", "committedDate": "2022-02-18 09:17:55 -0800", "message": "update pending member api to support getting list for a domain (#1783)"}, {"oid": "f4229124e8e1898810c7aa7b3a4eff37fddae308", "committedDate": "2022-02-18 12:37:32 -0800", "message": "provide option to skip adding principal when onboarding a resource group (#1787)"}, {"oid": "9081feb4c06a1058c941c67923037203d9318cfa", "committedDate": "2022-02-27 14:10:46 -0800", "message": "Domain Dependency for Tenancy (#1789)"}, {"oid": "a5bb615881583fa6f39621e2ea3bf39d3886340b", "committedDate": "2022-03-03 17:20:00 -0800", "message": "extend template keyword support trust field in roles (#1803)"}, {"oid": "3de182bcbedba89fa2aaba12ab9be49aa2156096", "committedDate": "2022-03-19 09:45:40 -0700", "message": "Add provider webhook for verifying removal (#1816)"}, {"oid": "1b0cff1cb9b8e4a231c5cfb342d76b6aad8e08fc", "committedDate": "2022-04-07 14:34:23 -0700", "message": "no need to update domain's last mod timestamp during put dependency call (#1846)"}, {"oid": "baa68eacd6a6b9bbc70c3423006f92cd47b784d7", "committedDate": "2022-05-19 09:30:02 -0700", "message": "Get Auth History implementation (#1875)"}, {"oid": "bea97b165e28b5b2cc286af62c92e536c9fc3ff2", "committedDate": "2022-06-03 13:50:01 -0700", "message": "AuthHistory - Return dependencies instead of list (#1888)"}, {"oid": "7a313e1d581295ae6c786bbc2ed73bb14da37f7d", "committedDate": "2022-07-21 20:16:24 -0700", "message": "allow management of domain memberPurgeExpiryDays setting value (#1928)"}, {"oid": "f288ed7afb018bc07af02dbe9dc8e05ec0896071", "committedDate": "2022-08-15 22:28:01 -0700", "message": "provide header option to return updated object in response (#1942)"}, {"oid": "949bd0634d328d04736b912a002bdfa7421d9f2b", "committedDate": "2022-08-23 10:28:38 -0700", "message": "fix returning role/group objects when requested by ui (#1945)"}, {"oid": "ab7284c9274f4949d23f88ec0dde7b689c0c6980", "committedDate": "2022-09-05 13:12:17 -0700", "message": "auto purge expired role/group members based on server/domain config (#1941)"}, {"oid": "4ab6e748891a014a8b0a1364de099d3fbf4c7468", "committedDate": "2022-09-21 22:22:48 -0700", "message": "enable readWrite db connection for delete expired members (#1964)"}, {"oid": "d4c733d3e97467a598ba44f0bde5c6a907aa01de", "committedDate": "2022-09-23 13:30:24 -0700", "message": "consistent use of The Athenz Authors copyright in all files (#1967)"}, {"oid": "45dcdab92d9e39d5d561b34ef222f863176cc635", "committedDate": "2022-09-26 12:29:01 -0700", "message": "make server purge expiry member day configurable (#1968)"}, {"oid": "d823cccb5163f950655f3859ade41fe031910588", "committedDate": "2022-10-06 14:20:20 -0700", "message": "fix putServiceIdentity logic to allow update of exising pubKey (#1978)"}, {"oid": "91d38ef548e59e29e69349b8a0f5151456b62a0f", "committedDate": "2022-10-07 15:36:36 -0700", "message": "Use correct object type for role member delete notifications (#1981)"}, {"oid": "1d970ce72c2f81aed5576fff068103bbba022aaf", "committedDate": "2022-11-29 23:50:29 +0200", "message": "add gcp project attribute for domains (#2005)"}, {"oid": "c292a1a2fb6e3a300a3060a6bcea6a96f696932c", "committedDate": "2022-12-13 08:56:43 -0800", "message": "Return the correct response from putMembership/putGroupMembership once a pending member was added (#2023)"}, {"oid": "fc5a206d1cb23dd2bbfd9af7e3125ec270ebc022", "committedDate": "2023-01-10 21:48:12 -0800", "message": "allow domain admins to enable audit flag for new roles/groups (#2032)"}, {"oid": "70850ab1de4055e765cf4ead6946b431900ff8c8", "committedDate": "2023-01-23 16:40:36 -0800", "message": "move cloud provider role generation logic out of dbstore library to dbservice (#2043)"}, {"oid": "0ff7ff4f9658fd42e8ee2161d870a89dce5167e4", "committedDate": "2023-02-02 09:18:32 -0800", "message": "Add a requirement for admin approval to delete members in review-enabled roles (#2053)"}, {"oid": "ff57628b890f53c43fec6dd2cacf98a574c95b2d", "committedDate": "2023-02-08 15:55:32 -0800", "message": "extends group with deleteProtection attribute and pending group membe\u2026 (#2067)"}, {"oid": "bb1d69af70a90aeedc28a46604283064e0dad8de", "committedDate": "2023-02-16 07:44:40 -0800", "message": "add audit enable to role (#2055)"}, {"oid": "4ee14d784973ce7da8aba96b35eefdbc5d61d97b", "committedDate": "2023-03-07 11:34:04 -0800", "message": "make aws/gcp assume role action values configurable (#2090)"}, {"oid": "5216da47ef8bca89ba0eae790f72739d9d73fcc6", "committedDate": "2023-03-09 10:36:29 -0800", "message": "Add optional 'description' to role (#2091)"}, {"oid": "d1b98d4614d62fe34b408cfa1a26fb59674d6494", "committedDate": "2023-03-27 16:46:33 -0700", "message": "store GCP project number along with project id in athenz domain metadata (#2113)"}, {"oid": "715cf96c679e817600a0a25160c96878e5eda735", "committedDate": "2023-03-27 18:01:33 -0700", "message": "special resource for gcp starting with service/ (#2115)"}, {"oid": "6e7342a1e98207b87e3eae45341db281b7b3b9c7", "committedDate": "2023-04-13 14:30:39 -0700", "message": "designate separate action for assertions when assuming gcp service accounts (#2127)"}, {"oid": "523f7f753fa2a4a112ae4fb7a5389203af8b9594", "committedDate": "2023-05-29 08:52:21 -0700", "message": "fix role update on expiration and review dates (#2185)"}, {"oid": "7069bf871635c4e5308d37341904241388b1ccda", "committedDate": "2023-05-30 15:31:26 -0700", "message": "support product id (string) format association with domains (#2193)"}, {"oid": "368d0bc139931c03d31824c4f02394b38e3ead95", "committedDate": "2023-06-02 13:15:05 -0700", "message": "support headless user type - managed by user authority but treated like service (#2197)"}]}, {"oid": "0dff4be75160c89e9e35b4634db11456460fa25f", "url": "https://github.com/AthenZ/athenz/commit/0dff4be75160c89e9e35b4634db11456460fa25f", "message": "addressing review comments", "committedDate": "2020-10-23T19:00:42Z", "type": "commit"}]}