{"pr_number": 7524, "pr_title": "[KEYCLOAK-15200] Complement methods for accessing users with Stream v\u2026", "pr_author": "sguilhen", "pr_createdAt": "2020-10-21T17:35:10Z", "pr_url": "https://github.com/keycloak/keycloak/pull/7524", "merge_commit": "aa4673517308a2f6b8214b192eb2151554564718", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc4NDQwNg==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511784406", "body": "`ldapQuery.getResultList()` doesn't seem to return `null` so maybe this `if` may be removed?", "bodyText": "ldapQuery.getResultList() doesn't seem to return null so maybe this if may be removed?", "bodyHTML": "<p dir=\"auto\"><code>ldapQuery.getResultList()</code> doesn't seem to return <code>null</code> so maybe this <code>if</code> may be removed?</p>", "author": "martin-kanis", "createdAt": "2020-10-26T08:23:53Z", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java", "diffHunk": "@@ -257,23 +256,18 @@ public boolean supportsCredentialAuthenticationFor(String type) {\n              List<LDAPObject> ldapObjects = ldapQuery.getResultList();\n \n              if (ldapObjects == null || ldapObjects.isEmpty()) {", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk4NDgwMg==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511984802", "bodyText": "Yeah, good point.", "author": "sguilhen", "createdAt": "2020-10-26T14:05:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc4NDQwNg=="}], "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "changed_code": [{"header": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\nindex 1c8f5d22b0..45d34e572f 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n", "chunk": "@@ -255,10 +256,6 @@ public class LDAPStorageProvider implements UserStorageProvider,\n \n              List<LDAPObject> ldapObjects = ldapQuery.getResultList();\n \n-             if (ldapObjects == null || ldapObjects.isEmpty()) {\n-                 return Stream.empty();\n-             }\n-\n              return ldapObjects.stream().map(ldapUser -> {\n                  String ldapUsername = LDAPUtils.getUsername(ldapUser, this.ldapIdentityStore.getConfig());\n                  UserModel localUser = session.userLocalStorage().getUserByUsername(ldapUsername, realm);\n", "next_change": null}]}, "revised_code_in_main": {"commit": "aa4673517308a2f6b8214b192eb2151554564718", "changed_code": [{"header": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\nindex 1c8f5d22b0..45d34e572f 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n", "chunk": "@@ -255,10 +256,6 @@ public class LDAPStorageProvider implements UserStorageProvider,\n \n              List<LDAPObject> ldapObjects = ldapQuery.getResultList();\n \n-             if (ldapObjects == null || ldapObjects.isEmpty()) {\n-                 return Stream.empty();\n-             }\n-\n              return ldapObjects.stream().map(ldapUser -> {\n                  String ldapUsername = LDAPUtils.getUsername(ldapUser, this.ldapIdentityStore.getConfig());\n                  UserModel localUser = session.userLocalStorage().getUserByUsername(ldapUsername, realm);\n", "next_change": {"commit": "ba8e2fef6b0a47727f03d58f4fe2809d6e65c017", "changed_code": [{"header": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\nindex 45d34e572f..89804f9554 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n", "chunk": "@@ -258,7 +259,7 @@ public class LDAPStorageProvider implements UserStorageProvider,\n \n              return ldapObjects.stream().map(ldapUser -> {\n                  String ldapUsername = LDAPUtils.getUsername(ldapUser, this.ldapIdentityStore.getConfig());\n-                 UserModel localUser = session.userLocalStorage().getUserByUsername(ldapUsername, realm);\n+                 UserModel localUser = session.userLocalStorage().getUserByUsername(realm, ldapUsername);\n                  if (localUser == null) {\n                      return importUserFromLDAP(session, realm, ldapUser);\n                  } else {\n", "next_change": {"commit": "1bc6133e4ecee8f4ebd9b10f8f92d0fca4e11d8e", "changed_code": [{"header": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\nindex 89804f9554..dbf9803b1b 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n", "chunk": "@@ -259,7 +264,7 @@ public class LDAPStorageProvider implements UserStorageProvider,\n \n              return ldapObjects.stream().map(ldapUser -> {\n                  String ldapUsername = LDAPUtils.getUsername(ldapUser, this.ldapIdentityStore.getConfig());\n-                 UserModel localUser = session.userLocalStorage().getUserByUsername(realm, ldapUsername);\n+                 UserModel localUser = UserStoragePrivateUtil.userLocalStorage(session).getUserByUsername(realm, ldapUsername);\n                  if (localUser == null) {\n                      return importUserFromLDAP(session, realm, ldapUser);\n                  } else {\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "aa4673517308a2f6b8214b192eb2151554564718", "message": "Merge commit", "committedDate": null}, {"oid": "84df008bc2173df12b6cbfa58047ebc120d1f413", "committedDate": "2020-11-18 21:07:51 +0100", "message": "[KEYCLOAK-16341] Make the new stream-based methods in server-spi user interfaces default instead of the collection-based versions.  - this ensures that providing implementation for the collection-based methods is enough, which preserves    backwards compatibility with older custom implementations.  - alternative interfaces now allow new implementations to focus on the stream variants of the query methods."}, {"oid": "edef93cd491e545de642fd39d0df0a53cecee830", "committedDate": "2020-12-07 19:48:35 +0100", "message": "[KEYCLOAK-16232] Streamify the UserCredentialStore and UserCredentialManager interfaces"}, {"oid": "8e376aef51b4b5d7ade4e5196ee628a086c1749a", "committedDate": "2020-12-10 08:57:53 +0100", "message": "KEYCLOAK-15847 Add MapUserProvider"}, {"oid": "1402d021deb014310027ba506e6cfa7686b315b4", "committedDate": "2021-01-08 13:55:48 +0100", "message": "KEYCLOAK-14846 Default roles processing"}, {"oid": "ba8e2fef6b0a47727f03d58f4fe2809d6e65c017", "committedDate": "2021-01-18 16:56:10 +0100", "message": "KEYCLOAK-15524 Cleanup user related interfaces"}, {"oid": "82fc4012983ea3f6dc2a24f157ab7ced57150465", "committedDate": "2021-03-16 17:55:24 +0100", "message": "[KEYCLOAK-9841] use LDAPUser UUID as an identifier instead of username"}, {"oid": "b4536a394abc8551ce9af24491278a56e25c2290", "committedDate": "2021-08-03 13:40:02 +0200", "message": "Missing null check for session.userCache() added"}, {"oid": "11e5f66c60ea53140dbc711a59b683f33462f9b9", "committedDate": "2021-09-14 20:27:09 +0200", "message": "KEYCLOAK-19056 EDIT MODE field should not be leave empty (#8380)"}, {"oid": "cb4a513e24a317402ca7c1042bb4f4f25706a122", "committedDate": "2022-04-12 14:38:17 +0200", "message": "Fail authenticate if credentialInput is not of type UserCredentialModel"}, {"oid": "703e868a5129c147d723e8c367c7eb962843e280", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Preparation for moving User Storage SPI"}, {"oid": "bc8fd21dc6495b7f43f3466eb3545055753114ae", "committedDate": "2022-06-21 08:53:06 +0200", "message": "SingleUserCredentialManager moving in - UserStorageManager now handles authentication for old Kerberos+LDAP style - new getUserByCredential method in MapUserProvider would eventually do the same."}, {"oid": "e396d0daa1fed0cb82cf761fe3b461ba24118a10", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Renaming SingleUserCredentialManager and UserModel.getUserCredentialManager(): - class SingleUserCredentialManager to SingleEntityCredentialManager - method UserModel.getUserCredentialManager() to credentialManager()"}, {"oid": "1bc6133e4ecee8f4ebd9b10f8f92d0fca4e11d8e", "committedDate": "2022-06-21 08:53:06 +0200", "message": "redirect calls to userLocalStorage from legacy modules (federation, ldap, sssd, kerberos)"}, {"oid": "d41764b19bbb682b187f37a60b71de9a6eb7d612", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Inline deprecated methods in legacy code"}, {"oid": "cb0c88182148fd352969383a33f2eeb56cc4de9f", "committedDate": "2022-06-21 08:53:06 +0200", "message": "rename SingleEntityCredentialManager to SubjectCredentialManager"}, {"oid": "cc9326fcad3aa209adba8f1c16daae8f2699a702", "committedDate": "2022-09-16 20:35:50 +0200", "message": "Delay LDAPObject creation until mandatory attributes are set (#14341)"}, {"oid": "883e83e62540168593046e34292849e16c009760", "committedDate": "2022-10-25 09:01:33 +0200", "message": "Remove deprecated methods from data providers and models"}, {"oid": "1e4401f52135164a20344dcd43207df0316eca03", "committedDate": "2023-03-02 08:21:38 +0100", "message": "Avoid returning the same entity multiple times from separate searches"}, {"oid": "fd6a6ec3ad328cf9581369299c68317f7fcc5d00", "committedDate": "2023-05-19 08:40:41 +0200", "message": "Make LDAP `searchForUsersStream` consistent with other storages"}, {"oid": "bdbbd2959d2fbe2ea2f1a76fdaea8f2984acf29c", "committedDate": "2023-05-23 11:48:33 +0200", "message": "User search with LDAP federation not consistent"}, {"oid": "a175efcb72902a767342941136fe7515733e6f2f", "committedDate": "2023-05-31 11:47:54 +0200", "message": "Split `UserQueryProvider` into `UserQueryMethods` and `UserCountMethods` and make `LdapStorageProvider` implement only `UserQueryMethods` Co-authored-by: mhajas <mhajas@redhat.com>"}, {"oid": "512e30b2105affb583030a4ce31928e33e664fbe", "committedDate": "2023-05-31 14:38:04 +0200", "message": "Add escaping for fields with wildcard search"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc5NDAxNA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511794014", "body": "I think we need to be more careful with `skip` which throws an `IllegalArgumentException` when a negative number is provided.", "bodyText": "I think we need to be more careful with skip which throws an IllegalArgumentException when a negative number is provided.", "bodyHTML": "<p dir=\"auto\">I think we need to be more careful with <code>skip</code> which throws an <code>IllegalArgumentException</code> when a negative number is provided.</p>", "author": "martin-kanis", "createdAt": "2020-10-26T08:41:43Z", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java", "diffHunk": "@@ -393,65 +387,42 @@ public int getUsersCount(RealmModel realm) {\n             }\n         }\n \n-        List<UserModel> searchResults =new LinkedList<UserModel>();\n-\n         List<LDAPObject> ldapUsers = searchLDAP(realm, params, maxResults + firstResult);\n-        int counter = 0;\n-        for (LDAPObject ldapUser : ldapUsers) {\n-            if (counter++ < firstResult) continue;\n-            String ldapUsername = LDAPUtils.getUsername(ldapUser, this.ldapIdentityStore.getConfig());\n-            if (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null) {\n-                UserModel imported = importUserFromLDAP(session, realm, ldapUser);\n-                searchResults.add(imported);\n-            }\n-        }\n-\n-        return searchResults;\n+        return ldapUsers.stream().skip(firstResult).filter(ldapObject -> {", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk4NTMwMA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511985300", "bodyText": "You are right, I think I've added some guards somewhere but forgot to check all other places", "author": "sguilhen", "createdAt": "2020-10-26T14:05:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc5NDAxNA=="}], "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "changed_code": [{"header": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\nindex 1c8f5d22b0..45d34e572f 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n", "chunk": "@@ -387,11 +384,16 @@ public class LDAPStorageProvider implements UserStorageProvider,\n             }\n         }\n \n-        List<LDAPObject> ldapUsers = searchLDAP(realm, params, maxResults + firstResult);\n-        return ldapUsers.stream().skip(firstResult).filter(ldapObject -> {\n-            String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n-            return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n-        }).map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n+        Stream<LDAPObject> stream = searchLDAP(realm, params).stream()\n+            .filter(ldapObject -> {\n+                String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n+                return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n+            });\n+        if (firstResult > 0)\n+            stream = stream.skip(firstResult);\n+        if (maxResults >= 0)\n+            stream = stream.limit(maxResults);\n+        return stream.map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n     }\n \n     @Override\n", "next_change": null}]}, "revised_code_in_main": {"commit": "aa4673517308a2f6b8214b192eb2151554564718", "changed_code": [{"header": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\nindex 1c8f5d22b0..45d34e572f 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n", "chunk": "@@ -387,11 +384,16 @@ public class LDAPStorageProvider implements UserStorageProvider,\n             }\n         }\n \n-        List<LDAPObject> ldapUsers = searchLDAP(realm, params, maxResults + firstResult);\n-        return ldapUsers.stream().skip(firstResult).filter(ldapObject -> {\n-            String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n-            return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n-        }).map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n+        Stream<LDAPObject> stream = searchLDAP(realm, params).stream()\n+            .filter(ldapObject -> {\n+                String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n+                return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n+            });\n+        if (firstResult > 0)\n+            stream = stream.skip(firstResult);\n+        if (maxResults >= 0)\n+            stream = stream.limit(maxResults);\n+        return stream.map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n     }\n \n     @Override\n", "next_change": {"commit": "8e376aef51b4b5d7ade4e5196ee628a086c1749a", "changed_code": [{"header": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\nindex 45d34e572f..524499e423 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n", "chunk": "@@ -402,7 +401,7 @@ public class LDAPStorageProvider implements UserStorageProvider,\n     }\n \n     @Override\n-    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, Integer firstResult, Integer maxResults) {\n         return realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n             .sorted(ldapMappersComparator.sortAsc())\n             .map(mapperModel ->\n", "next_change": {"commit": "ba8e2fef6b0a47727f03d58f4fe2809d6e65c017", "changed_code": [{"header": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\nindex 524499e423..89804f9554 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n", "chunk": "@@ -386,41 +379,34 @@ public class LDAPStorageProvider implements UserStorageProvider,\n         Stream<LDAPObject> stream = searchLDAP(realm, params).stream()\n             .filter(ldapObject -> {\n                 String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n-                return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n+                return (session.userLocalStorage().getUserByUsername(realm, ldapUsername) == null);\n             });\n-        if (firstResult > 0)\n-            stream = stream.skip(firstResult);\n-        if (maxResults >= 0)\n-            stream = stream.limit(maxResults);\n-        return stream.map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n-    }\n \n-    @Override\n-    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group) {\n-        return getGroupMembersStream(realm, group, 0, Integer.MAX_VALUE - 1);\n+        return paginatedStream(stream, firstResult, maxResults).map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n     }\n \n     @Override\n     public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, Integer firstResult, Integer maxResults) {\n+        int first = firstResult == null ? 0 : firstResult;\n+        int max = maxResults == null ? DEFAULT_MAX_RESULTS : maxResults;\n+\n         return realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n             .sorted(ldapMappersComparator.sortAsc())\n             .map(mapperModel ->\n-                mapperManager.getMapper(mapperModel).getGroupMembers(realm, group, firstResult, maxResults))\n+                mapperManager.getMapper(mapperModel).getGroupMembers(realm, group, first, max))\n             .filter(((Predicate<List>) List::isEmpty).negate())\n             .map(List::stream)\n             .findFirst().orElse(Stream.empty());\n     }\n \n-    @Override\n-    public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role) {\n-        return getRoleMembersStream(realm, role, 0, Integer.MAX_VALUE - 1);\n-    }\n-\n     @Override\n     public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role, Integer firstResult, Integer maxResults) {\n+        int first = firstResult == null ? 0 : firstResult;\n+        int max = maxResults == null ? DEFAULT_MAX_RESULTS : maxResults;\n+\n         return realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n                 .sorted(ldapMappersComparator.sortAsc())\n-                .map(mapperModel -> mapperManager.getMapper(mapperModel).getRoleMembers(realm, role, firstResult, maxResults))\n+                .map(mapperModel -> mapperManager.getMapper(mapperModel).getRoleMembers(realm, role, first, max))\n                 .filter(((Predicate<List>) List::isEmpty).negate())\n                 .map(List::stream)\n                 .findFirst().orElse(Stream.empty());\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "aa4673517308a2f6b8214b192eb2151554564718", "message": "Merge commit", "committedDate": null}, {"oid": "84df008bc2173df12b6cbfa58047ebc120d1f413", "committedDate": "2020-11-18 21:07:51 +0100", "message": "[KEYCLOAK-16341] Make the new stream-based methods in server-spi user interfaces default instead of the collection-based versions.  - this ensures that providing implementation for the collection-based methods is enough, which preserves    backwards compatibility with older custom implementations.  - alternative interfaces now allow new implementations to focus on the stream variants of the query methods."}, {"oid": "edef93cd491e545de642fd39d0df0a53cecee830", "committedDate": "2020-12-07 19:48:35 +0100", "message": "[KEYCLOAK-16232] Streamify the UserCredentialStore and UserCredentialManager interfaces"}, {"oid": "8e376aef51b4b5d7ade4e5196ee628a086c1749a", "committedDate": "2020-12-10 08:57:53 +0100", "message": "KEYCLOAK-15847 Add MapUserProvider"}, {"oid": "1402d021deb014310027ba506e6cfa7686b315b4", "committedDate": "2021-01-08 13:55:48 +0100", "message": "KEYCLOAK-14846 Default roles processing"}, {"oid": "ba8e2fef6b0a47727f03d58f4fe2809d6e65c017", "committedDate": "2021-01-18 16:56:10 +0100", "message": "KEYCLOAK-15524 Cleanup user related interfaces"}, {"oid": "82fc4012983ea3f6dc2a24f157ab7ced57150465", "committedDate": "2021-03-16 17:55:24 +0100", "message": "[KEYCLOAK-9841] use LDAPUser UUID as an identifier instead of username"}, {"oid": "b4536a394abc8551ce9af24491278a56e25c2290", "committedDate": "2021-08-03 13:40:02 +0200", "message": "Missing null check for session.userCache() added"}, {"oid": "11e5f66c60ea53140dbc711a59b683f33462f9b9", "committedDate": "2021-09-14 20:27:09 +0200", "message": "KEYCLOAK-19056 EDIT MODE field should not be leave empty (#8380)"}, {"oid": "cb4a513e24a317402ca7c1042bb4f4f25706a122", "committedDate": "2022-04-12 14:38:17 +0200", "message": "Fail authenticate if credentialInput is not of type UserCredentialModel"}, {"oid": "703e868a5129c147d723e8c367c7eb962843e280", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Preparation for moving User Storage SPI"}, {"oid": "bc8fd21dc6495b7f43f3466eb3545055753114ae", "committedDate": "2022-06-21 08:53:06 +0200", "message": "SingleUserCredentialManager moving in - UserStorageManager now handles authentication for old Kerberos+LDAP style - new getUserByCredential method in MapUserProvider would eventually do the same."}, {"oid": "e396d0daa1fed0cb82cf761fe3b461ba24118a10", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Renaming SingleUserCredentialManager and UserModel.getUserCredentialManager(): - class SingleUserCredentialManager to SingleEntityCredentialManager - method UserModel.getUserCredentialManager() to credentialManager()"}, {"oid": "1bc6133e4ecee8f4ebd9b10f8f92d0fca4e11d8e", "committedDate": "2022-06-21 08:53:06 +0200", "message": "redirect calls to userLocalStorage from legacy modules (federation, ldap, sssd, kerberos)"}, {"oid": "d41764b19bbb682b187f37a60b71de9a6eb7d612", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Inline deprecated methods in legacy code"}, {"oid": "cb0c88182148fd352969383a33f2eeb56cc4de9f", "committedDate": "2022-06-21 08:53:06 +0200", "message": "rename SingleEntityCredentialManager to SubjectCredentialManager"}, {"oid": "cc9326fcad3aa209adba8f1c16daae8f2699a702", "committedDate": "2022-09-16 20:35:50 +0200", "message": "Delay LDAPObject creation until mandatory attributes are set (#14341)"}, {"oid": "883e83e62540168593046e34292849e16c009760", "committedDate": "2022-10-25 09:01:33 +0200", "message": "Remove deprecated methods from data providers and models"}, {"oid": "1e4401f52135164a20344dcd43207df0316eca03", "committedDate": "2023-03-02 08:21:38 +0100", "message": "Avoid returning the same entity multiple times from separate searches"}, {"oid": "fd6a6ec3ad328cf9581369299c68317f7fcc5d00", "committedDate": "2023-05-19 08:40:41 +0200", "message": "Make LDAP `searchForUsersStream` consistent with other storages"}, {"oid": "bdbbd2959d2fbe2ea2f1a76fdaea8f2984acf29c", "committedDate": "2023-05-23 11:48:33 +0200", "message": "User search with LDAP federation not consistent"}, {"oid": "a175efcb72902a767342941136fe7515733e6f2f", "committedDate": "2023-05-31 11:47:54 +0200", "message": "Split `UserQueryProvider` into `UserQueryMethods` and `UserCountMethods` and make `LdapStorageProvider` implement only `UserQueryMethods` Co-authored-by: mhajas <mhajas@redhat.com>"}, {"oid": "512e30b2105affb583030a4ce31928e33e664fbe", "committedDate": "2023-05-31 14:38:04 +0200", "message": "Add escaping for fields with wildcard search"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc5OTIyOQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511799229", "body": "This lambda can be avoided like this: `((Predicate<List>) List::isEmpty).negate()`", "bodyText": "This lambda can be avoided like this: ((Predicate<List>) List::isEmpty).negate()", "bodyHTML": "<p dir=\"auto\">This lambda can be avoided like this: <code>((Predicate&lt;List&gt;) List::isEmpty).negate()</code></p>", "author": "martin-kanis", "createdAt": "2020-10-26T08:51:05Z", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java", "diffHunk": "@@ -393,65 +387,42 @@ public int getUsersCount(RealmModel realm) {\n             }\n         }\n \n-        List<UserModel> searchResults =new LinkedList<UserModel>();\n-\n         List<LDAPObject> ldapUsers = searchLDAP(realm, params, maxResults + firstResult);\n-        int counter = 0;\n-        for (LDAPObject ldapUser : ldapUsers) {\n-            if (counter++ < firstResult) continue;\n-            String ldapUsername = LDAPUtils.getUsername(ldapUser, this.ldapIdentityStore.getConfig());\n-            if (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null) {\n-                UserModel imported = importUserFromLDAP(session, realm, ldapUser);\n-                searchResults.add(imported);\n-            }\n-        }\n-\n-        return searchResults;\n+        return ldapUsers.stream().skip(firstResult).filter(ldapObject -> {\n+            String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n+            return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n+        }).map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n     }\n \n     @Override\n-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group) {\n-        return getGroupMembers(realm, group, 0, Integer.MAX_VALUE - 1);\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group) {\n+        return getGroupMembersStream(realm, group, 0, Integer.MAX_VALUE - 1);\n     }\n \n     @Override\n-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n-        List<ComponentModel> sortedMappers = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n-                .sorted(ldapMappersComparator.sortAsc())\n-                .collect(Collectors.toList());\n-\n-        for (ComponentModel mapperModel : sortedMappers) {\n-            LDAPStorageMapper ldapMapper = mapperManager.getMapper(mapperModel);\n-            List<UserModel> users = ldapMapper.getGroupMembers(realm, group, firstResult, maxResults);\n-\n-            // Sufficient for now\n-            if (users.size() > 0) {\n-                return users;\n-            }\n-        }\n-        return Collections.emptyList();\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n+        List<UserModel> users = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n+            .sorted(ldapMappersComparator.sortAsc())\n+            .map(mapperModel ->\n+                mapperManager.getMapper(mapperModel).getGroupMembers(realm, group, firstResult, maxResults))\n+            .filter(list -> list.size() > 0)", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk4NTQzOA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511985438", "bodyText": "I like the suggestion, will change it.", "author": "sguilhen", "createdAt": "2020-10-26T14:06:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc5OTIyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "changed_code": [{"header": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\nindex 1c8f5d22b0..45d34e572f 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n", "chunk": "@@ -401,13 +403,13 @@ public class LDAPStorageProvider implements UserStorageProvider,\n \n     @Override\n     public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n-        List<UserModel> users = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n+        return realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n             .sorted(ldapMappersComparator.sortAsc())\n             .map(mapperModel ->\n                 mapperManager.getMapper(mapperModel).getGroupMembers(realm, group, firstResult, maxResults))\n-            .filter(list -> list.size() > 0)\n-            .findFirst().orElse(null);\n-        return users == null ? Stream.empty() : users.stream();\n+            .filter(((Predicate<List>) List::isEmpty).negate())\n+            .map(List::stream)\n+            .findFirst().orElse(Stream.empty());\n     }\n \n     @Override\n", "next_change": null}]}, "revised_code_in_main": {"commit": "aa4673517308a2f6b8214b192eb2151554564718", "changed_code": [{"header": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\nindex 1c8f5d22b0..45d34e572f 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n", "chunk": "@@ -401,13 +403,13 @@ public class LDAPStorageProvider implements UserStorageProvider,\n \n     @Override\n     public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n-        List<UserModel> users = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n+        return realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n             .sorted(ldapMappersComparator.sortAsc())\n             .map(mapperModel ->\n                 mapperManager.getMapper(mapperModel).getGroupMembers(realm, group, firstResult, maxResults))\n-            .filter(list -> list.size() > 0)\n-            .findFirst().orElse(null);\n-        return users == null ? Stream.empty() : users.stream();\n+            .filter(((Predicate<List>) List::isEmpty).negate())\n+            .map(List::stream)\n+            .findFirst().orElse(Stream.empty());\n     }\n \n     @Override\n", "next_change": {"commit": "8e376aef51b4b5d7ade4e5196ee628a086c1749a", "changed_code": [{"header": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\nindex 45d34e572f..524499e423 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n", "chunk": "@@ -418,7 +417,7 @@ public class LDAPStorageProvider implements UserStorageProvider,\n     }\n \n     @Override\n-    public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role, int firstResult, int maxResults) {\n+    public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role, Integer firstResult, Integer maxResults) {\n         return realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n                 .sorted(ldapMappersComparator.sortAsc())\n                 .map(mapperModel -> mapperManager.getMapper(mapperModel).getRoleMembers(realm, role, firstResult, maxResults))\n", "next_change": {"commit": "ba8e2fef6b0a47727f03d58f4fe2809d6e65c017", "changed_code": [{"header": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\nindex 524499e423..89804f9554 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n", "chunk": "@@ -386,41 +379,34 @@ public class LDAPStorageProvider implements UserStorageProvider,\n         Stream<LDAPObject> stream = searchLDAP(realm, params).stream()\n             .filter(ldapObject -> {\n                 String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n-                return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n+                return (session.userLocalStorage().getUserByUsername(realm, ldapUsername) == null);\n             });\n-        if (firstResult > 0)\n-            stream = stream.skip(firstResult);\n-        if (maxResults >= 0)\n-            stream = stream.limit(maxResults);\n-        return stream.map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n-    }\n \n-    @Override\n-    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group) {\n-        return getGroupMembersStream(realm, group, 0, Integer.MAX_VALUE - 1);\n+        return paginatedStream(stream, firstResult, maxResults).map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n     }\n \n     @Override\n     public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, Integer firstResult, Integer maxResults) {\n+        int first = firstResult == null ? 0 : firstResult;\n+        int max = maxResults == null ? DEFAULT_MAX_RESULTS : maxResults;\n+\n         return realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n             .sorted(ldapMappersComparator.sortAsc())\n             .map(mapperModel ->\n-                mapperManager.getMapper(mapperModel).getGroupMembers(realm, group, firstResult, maxResults))\n+                mapperManager.getMapper(mapperModel).getGroupMembers(realm, group, first, max))\n             .filter(((Predicate<List>) List::isEmpty).negate())\n             .map(List::stream)\n             .findFirst().orElse(Stream.empty());\n     }\n \n-    @Override\n-    public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role) {\n-        return getRoleMembersStream(realm, role, 0, Integer.MAX_VALUE - 1);\n-    }\n-\n     @Override\n     public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role, Integer firstResult, Integer maxResults) {\n+        int first = firstResult == null ? 0 : firstResult;\n+        int max = maxResults == null ? DEFAULT_MAX_RESULTS : maxResults;\n+\n         return realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n                 .sorted(ldapMappersComparator.sortAsc())\n-                .map(mapperModel -> mapperManager.getMapper(mapperModel).getRoleMembers(realm, role, firstResult, maxResults))\n+                .map(mapperModel -> mapperManager.getMapper(mapperModel).getRoleMembers(realm, role, first, max))\n                 .filter(((Predicate<List>) List::isEmpty).negate())\n                 .map(List::stream)\n                 .findFirst().orElse(Stream.empty());\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "aa4673517308a2f6b8214b192eb2151554564718", "message": "Merge commit", "committedDate": null}, {"oid": "84df008bc2173df12b6cbfa58047ebc120d1f413", "committedDate": "2020-11-18 21:07:51 +0100", "message": "[KEYCLOAK-16341] Make the new stream-based methods in server-spi user interfaces default instead of the collection-based versions.  - this ensures that providing implementation for the collection-based methods is enough, which preserves    backwards compatibility with older custom implementations.  - alternative interfaces now allow new implementations to focus on the stream variants of the query methods."}, {"oid": "edef93cd491e545de642fd39d0df0a53cecee830", "committedDate": "2020-12-07 19:48:35 +0100", "message": "[KEYCLOAK-16232] Streamify the UserCredentialStore and UserCredentialManager interfaces"}, {"oid": "8e376aef51b4b5d7ade4e5196ee628a086c1749a", "committedDate": "2020-12-10 08:57:53 +0100", "message": "KEYCLOAK-15847 Add MapUserProvider"}, {"oid": "1402d021deb014310027ba506e6cfa7686b315b4", "committedDate": "2021-01-08 13:55:48 +0100", "message": "KEYCLOAK-14846 Default roles processing"}, {"oid": "ba8e2fef6b0a47727f03d58f4fe2809d6e65c017", "committedDate": "2021-01-18 16:56:10 +0100", "message": "KEYCLOAK-15524 Cleanup user related interfaces"}, {"oid": "82fc4012983ea3f6dc2a24f157ab7ced57150465", "committedDate": "2021-03-16 17:55:24 +0100", "message": "[KEYCLOAK-9841] use LDAPUser UUID as an identifier instead of username"}, {"oid": "b4536a394abc8551ce9af24491278a56e25c2290", "committedDate": "2021-08-03 13:40:02 +0200", "message": "Missing null check for session.userCache() added"}, {"oid": "11e5f66c60ea53140dbc711a59b683f33462f9b9", "committedDate": "2021-09-14 20:27:09 +0200", "message": "KEYCLOAK-19056 EDIT MODE field should not be leave empty (#8380)"}, {"oid": "cb4a513e24a317402ca7c1042bb4f4f25706a122", "committedDate": "2022-04-12 14:38:17 +0200", "message": "Fail authenticate if credentialInput is not of type UserCredentialModel"}, {"oid": "703e868a5129c147d723e8c367c7eb962843e280", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Preparation for moving User Storage SPI"}, {"oid": "bc8fd21dc6495b7f43f3466eb3545055753114ae", "committedDate": "2022-06-21 08:53:06 +0200", "message": "SingleUserCredentialManager moving in - UserStorageManager now handles authentication for old Kerberos+LDAP style - new getUserByCredential method in MapUserProvider would eventually do the same."}, {"oid": "e396d0daa1fed0cb82cf761fe3b461ba24118a10", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Renaming SingleUserCredentialManager and UserModel.getUserCredentialManager(): - class SingleUserCredentialManager to SingleEntityCredentialManager - method UserModel.getUserCredentialManager() to credentialManager()"}, {"oid": "1bc6133e4ecee8f4ebd9b10f8f92d0fca4e11d8e", "committedDate": "2022-06-21 08:53:06 +0200", "message": "redirect calls to userLocalStorage from legacy modules (federation, ldap, sssd, kerberos)"}, {"oid": "d41764b19bbb682b187f37a60b71de9a6eb7d612", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Inline deprecated methods in legacy code"}, {"oid": "cb0c88182148fd352969383a33f2eeb56cc4de9f", "committedDate": "2022-06-21 08:53:06 +0200", "message": "rename SingleEntityCredentialManager to SubjectCredentialManager"}, {"oid": "cc9326fcad3aa209adba8f1c16daae8f2699a702", "committedDate": "2022-09-16 20:35:50 +0200", "message": "Delay LDAPObject creation until mandatory attributes are set (#14341)"}, {"oid": "883e83e62540168593046e34292849e16c009760", "committedDate": "2022-10-25 09:01:33 +0200", "message": "Remove deprecated methods from data providers and models"}, {"oid": "1e4401f52135164a20344dcd43207df0316eca03", "committedDate": "2023-03-02 08:21:38 +0100", "message": "Avoid returning the same entity multiple times from separate searches"}, {"oid": "fd6a6ec3ad328cf9581369299c68317f7fcc5d00", "committedDate": "2023-05-19 08:40:41 +0200", "message": "Make LDAP `searchForUsersStream` consistent with other storages"}, {"oid": "bdbbd2959d2fbe2ea2f1a76fdaea8f2984acf29c", "committedDate": "2023-05-23 11:48:33 +0200", "message": "User search with LDAP federation not consistent"}, {"oid": "a175efcb72902a767342941136fe7515733e6f2f", "committedDate": "2023-05-31 11:47:54 +0200", "message": "Split `UserQueryProvider` into `UserQueryMethods` and `UserCountMethods` and make `LdapStorageProvider` implement only `UserQueryMethods` Co-authored-by: mhajas <mhajas@redhat.com>"}, {"oid": "512e30b2105affb583030a4ce31928e33e664fbe", "committedDate": "2023-05-31 14:38:04 +0200", "message": "Add escaping for fields with wildcard search"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwMDcxNQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511800715", "body": "Maybe it can be simplified like \r\n```\r\nreturn...\r\n.map(List::stream)\r\n.findFirst().orElse(Stream.empty());\r\n``` ", "bodyText": "Maybe it can be simplified like\nreturn...\n.map(List::stream)\n.findFirst().orElse(Stream.empty());", "bodyHTML": "<p dir=\"auto\">Maybe it can be simplified like</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"return...\n.map(List::stream)\n.findFirst().orElse(Stream.empty());\n\"><pre><code>return...\n.map(List::stream)\n.findFirst().orElse(Stream.empty());\n</code></pre></div>", "author": "martin-kanis", "createdAt": "2020-10-26T08:53:45Z", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java", "diffHunk": "@@ -393,65 +387,42 @@ public int getUsersCount(RealmModel realm) {\n             }\n         }\n \n-        List<UserModel> searchResults =new LinkedList<UserModel>();\n-\n         List<LDAPObject> ldapUsers = searchLDAP(realm, params, maxResults + firstResult);\n-        int counter = 0;\n-        for (LDAPObject ldapUser : ldapUsers) {\n-            if (counter++ < firstResult) continue;\n-            String ldapUsername = LDAPUtils.getUsername(ldapUser, this.ldapIdentityStore.getConfig());\n-            if (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null) {\n-                UserModel imported = importUserFromLDAP(session, realm, ldapUser);\n-                searchResults.add(imported);\n-            }\n-        }\n-\n-        return searchResults;\n+        return ldapUsers.stream().skip(firstResult).filter(ldapObject -> {\n+            String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n+            return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n+        }).map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n     }\n \n     @Override\n-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group) {\n-        return getGroupMembers(realm, group, 0, Integer.MAX_VALUE - 1);\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group) {\n+        return getGroupMembersStream(realm, group, 0, Integer.MAX_VALUE - 1);\n     }\n \n     @Override\n-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n-        List<ComponentModel> sortedMappers = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n-                .sorted(ldapMappersComparator.sortAsc())\n-                .collect(Collectors.toList());\n-\n-        for (ComponentModel mapperModel : sortedMappers) {\n-            LDAPStorageMapper ldapMapper = mapperManager.getMapper(mapperModel);\n-            List<UserModel> users = ldapMapper.getGroupMembers(realm, group, firstResult, maxResults);\n-\n-            // Sufficient for now\n-            if (users.size() > 0) {\n-                return users;\n-            }\n-        }\n-        return Collections.emptyList();\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n+        List<UserModel> users = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n+            .sorted(ldapMappersComparator.sortAsc())\n+            .map(mapperModel ->\n+                mapperManager.getMapper(mapperModel).getGroupMembers(realm, group, firstResult, maxResults))\n+            .filter(list -> list.size() > 0)\n+            .findFirst().orElse(null);\n+        return users == null ? Stream.empty() : users.stream();", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk4NjQyMA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511986420", "bodyText": "I suppose this would work, yes. I will make the change", "author": "sguilhen", "createdAt": "2020-10-26T14:07:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwMDcxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI3NDUyMA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r512274520", "bodyText": "Prefer list.isEmpty() to list.size() where possible. The former is simple check while the latter may need to enumerate the items e.g. in case of LinkedList", "author": "hmlnarik", "createdAt": "2020-10-26T21:18:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwMDcxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "changed_code": [{"header": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\nindex 1c8f5d22b0..45d34e572f 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n", "chunk": "@@ -401,13 +403,13 @@ public class LDAPStorageProvider implements UserStorageProvider,\n \n     @Override\n     public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n-        List<UserModel> users = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n+        return realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n             .sorted(ldapMappersComparator.sortAsc())\n             .map(mapperModel ->\n                 mapperManager.getMapper(mapperModel).getGroupMembers(realm, group, firstResult, maxResults))\n-            .filter(list -> list.size() > 0)\n-            .findFirst().orElse(null);\n-        return users == null ? Stream.empty() : users.stream();\n+            .filter(((Predicate<List>) List::isEmpty).negate())\n+            .map(List::stream)\n+            .findFirst().orElse(Stream.empty());\n     }\n \n     @Override\n", "next_change": null}]}, "revised_code_in_main": {"commit": "aa4673517308a2f6b8214b192eb2151554564718", "changed_code": [{"header": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\nindex 1c8f5d22b0..45d34e572f 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n", "chunk": "@@ -401,13 +403,13 @@ public class LDAPStorageProvider implements UserStorageProvider,\n \n     @Override\n     public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n-        List<UserModel> users = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n+        return realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n             .sorted(ldapMappersComparator.sortAsc())\n             .map(mapperModel ->\n                 mapperManager.getMapper(mapperModel).getGroupMembers(realm, group, firstResult, maxResults))\n-            .filter(list -> list.size() > 0)\n-            .findFirst().orElse(null);\n-        return users == null ? Stream.empty() : users.stream();\n+            .filter(((Predicate<List>) List::isEmpty).negate())\n+            .map(List::stream)\n+            .findFirst().orElse(Stream.empty());\n     }\n \n     @Override\n", "next_change": {"commit": "8e376aef51b4b5d7ade4e5196ee628a086c1749a", "changed_code": [{"header": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\nindex 45d34e572f..524499e423 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n", "chunk": "@@ -418,7 +417,7 @@ public class LDAPStorageProvider implements UserStorageProvider,\n     }\n \n     @Override\n-    public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role, int firstResult, int maxResults) {\n+    public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role, Integer firstResult, Integer maxResults) {\n         return realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n                 .sorted(ldapMappersComparator.sortAsc())\n                 .map(mapperModel -> mapperManager.getMapper(mapperModel).getRoleMembers(realm, role, firstResult, maxResults))\n", "next_change": {"commit": "ba8e2fef6b0a47727f03d58f4fe2809d6e65c017", "changed_code": [{"header": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\nindex 524499e423..89804f9554 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n", "chunk": "@@ -386,41 +379,34 @@ public class LDAPStorageProvider implements UserStorageProvider,\n         Stream<LDAPObject> stream = searchLDAP(realm, params).stream()\n             .filter(ldapObject -> {\n                 String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n-                return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n+                return (session.userLocalStorage().getUserByUsername(realm, ldapUsername) == null);\n             });\n-        if (firstResult > 0)\n-            stream = stream.skip(firstResult);\n-        if (maxResults >= 0)\n-            stream = stream.limit(maxResults);\n-        return stream.map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n-    }\n \n-    @Override\n-    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group) {\n-        return getGroupMembersStream(realm, group, 0, Integer.MAX_VALUE - 1);\n+        return paginatedStream(stream, firstResult, maxResults).map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n     }\n \n     @Override\n     public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, Integer firstResult, Integer maxResults) {\n+        int first = firstResult == null ? 0 : firstResult;\n+        int max = maxResults == null ? DEFAULT_MAX_RESULTS : maxResults;\n+\n         return realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n             .sorted(ldapMappersComparator.sortAsc())\n             .map(mapperModel ->\n-                mapperManager.getMapper(mapperModel).getGroupMembers(realm, group, firstResult, maxResults))\n+                mapperManager.getMapper(mapperModel).getGroupMembers(realm, group, first, max))\n             .filter(((Predicate<List>) List::isEmpty).negate())\n             .map(List::stream)\n             .findFirst().orElse(Stream.empty());\n     }\n \n-    @Override\n-    public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role) {\n-        return getRoleMembersStream(realm, role, 0, Integer.MAX_VALUE - 1);\n-    }\n-\n     @Override\n     public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role, Integer firstResult, Integer maxResults) {\n+        int first = firstResult == null ? 0 : firstResult;\n+        int max = maxResults == null ? DEFAULT_MAX_RESULTS : maxResults;\n+\n         return realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n                 .sorted(ldapMappersComparator.sortAsc())\n-                .map(mapperModel -> mapperManager.getMapper(mapperModel).getRoleMembers(realm, role, firstResult, maxResults))\n+                .map(mapperModel -> mapperManager.getMapper(mapperModel).getRoleMembers(realm, role, first, max))\n                 .filter(((Predicate<List>) List::isEmpty).negate())\n                 .map(List::stream)\n                 .findFirst().orElse(Stream.empty());\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "aa4673517308a2f6b8214b192eb2151554564718", "message": "Merge commit", "committedDate": null}, {"oid": "84df008bc2173df12b6cbfa58047ebc120d1f413", "committedDate": "2020-11-18 21:07:51 +0100", "message": "[KEYCLOAK-16341] Make the new stream-based methods in server-spi user interfaces default instead of the collection-based versions.  - this ensures that providing implementation for the collection-based methods is enough, which preserves    backwards compatibility with older custom implementations.  - alternative interfaces now allow new implementations to focus on the stream variants of the query methods."}, {"oid": "edef93cd491e545de642fd39d0df0a53cecee830", "committedDate": "2020-12-07 19:48:35 +0100", "message": "[KEYCLOAK-16232] Streamify the UserCredentialStore and UserCredentialManager interfaces"}, {"oid": "8e376aef51b4b5d7ade4e5196ee628a086c1749a", "committedDate": "2020-12-10 08:57:53 +0100", "message": "KEYCLOAK-15847 Add MapUserProvider"}, {"oid": "1402d021deb014310027ba506e6cfa7686b315b4", "committedDate": "2021-01-08 13:55:48 +0100", "message": "KEYCLOAK-14846 Default roles processing"}, {"oid": "ba8e2fef6b0a47727f03d58f4fe2809d6e65c017", "committedDate": "2021-01-18 16:56:10 +0100", "message": "KEYCLOAK-15524 Cleanup user related interfaces"}, {"oid": "82fc4012983ea3f6dc2a24f157ab7ced57150465", "committedDate": "2021-03-16 17:55:24 +0100", "message": "[KEYCLOAK-9841] use LDAPUser UUID as an identifier instead of username"}, {"oid": "b4536a394abc8551ce9af24491278a56e25c2290", "committedDate": "2021-08-03 13:40:02 +0200", "message": "Missing null check for session.userCache() added"}, {"oid": "11e5f66c60ea53140dbc711a59b683f33462f9b9", "committedDate": "2021-09-14 20:27:09 +0200", "message": "KEYCLOAK-19056 EDIT MODE field should not be leave empty (#8380)"}, {"oid": "cb4a513e24a317402ca7c1042bb4f4f25706a122", "committedDate": "2022-04-12 14:38:17 +0200", "message": "Fail authenticate if credentialInput is not of type UserCredentialModel"}, {"oid": "703e868a5129c147d723e8c367c7eb962843e280", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Preparation for moving User Storage SPI"}, {"oid": "bc8fd21dc6495b7f43f3466eb3545055753114ae", "committedDate": "2022-06-21 08:53:06 +0200", "message": "SingleUserCredentialManager moving in - UserStorageManager now handles authentication for old Kerberos+LDAP style - new getUserByCredential method in MapUserProvider would eventually do the same."}, {"oid": "e396d0daa1fed0cb82cf761fe3b461ba24118a10", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Renaming SingleUserCredentialManager and UserModel.getUserCredentialManager(): - class SingleUserCredentialManager to SingleEntityCredentialManager - method UserModel.getUserCredentialManager() to credentialManager()"}, {"oid": "1bc6133e4ecee8f4ebd9b10f8f92d0fca4e11d8e", "committedDate": "2022-06-21 08:53:06 +0200", "message": "redirect calls to userLocalStorage from legacy modules (federation, ldap, sssd, kerberos)"}, {"oid": "d41764b19bbb682b187f37a60b71de9a6eb7d612", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Inline deprecated methods in legacy code"}, {"oid": "cb0c88182148fd352969383a33f2eeb56cc4de9f", "committedDate": "2022-06-21 08:53:06 +0200", "message": "rename SingleEntityCredentialManager to SubjectCredentialManager"}, {"oid": "cc9326fcad3aa209adba8f1c16daae8f2699a702", "committedDate": "2022-09-16 20:35:50 +0200", "message": "Delay LDAPObject creation until mandatory attributes are set (#14341)"}, {"oid": "883e83e62540168593046e34292849e16c009760", "committedDate": "2022-10-25 09:01:33 +0200", "message": "Remove deprecated methods from data providers and models"}, {"oid": "1e4401f52135164a20344dcd43207df0316eca03", "committedDate": "2023-03-02 08:21:38 +0100", "message": "Avoid returning the same entity multiple times from separate searches"}, {"oid": "fd6a6ec3ad328cf9581369299c68317f7fcc5d00", "committedDate": "2023-05-19 08:40:41 +0200", "message": "Make LDAP `searchForUsersStream` consistent with other storages"}, {"oid": "bdbbd2959d2fbe2ea2f1a76fdaea8f2984acf29c", "committedDate": "2023-05-23 11:48:33 +0200", "message": "User search with LDAP federation not consistent"}, {"oid": "a175efcb72902a767342941136fe7515733e6f2f", "committedDate": "2023-05-31 11:47:54 +0200", "message": "Split `UserQueryProvider` into `UserQueryMethods` and `UserCountMethods` and make `LdapStorageProvider` implement only `UserQueryMethods` Co-authored-by: mhajas <mhajas@redhat.com>"}, {"oid": "512e30b2105affb583030a4ce31928e33e664fbe", "committedDate": "2023-05-31 14:38:04 +0200", "message": "Add escaping for fields with wildcard search"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwMTQ2MA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511801460", "body": "Same as above", "bodyText": "Same as above", "bodyHTML": "<p dir=\"auto\">Same as above</p>", "author": "martin-kanis", "createdAt": "2020-10-26T08:55:00Z", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java", "diffHunk": "@@ -393,65 +387,42 @@ public int getUsersCount(RealmModel realm) {\n             }\n         }\n \n-        List<UserModel> searchResults =new LinkedList<UserModel>();\n-\n         List<LDAPObject> ldapUsers = searchLDAP(realm, params, maxResults + firstResult);\n-        int counter = 0;\n-        for (LDAPObject ldapUser : ldapUsers) {\n-            if (counter++ < firstResult) continue;\n-            String ldapUsername = LDAPUtils.getUsername(ldapUser, this.ldapIdentityStore.getConfig());\n-            if (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null) {\n-                UserModel imported = importUserFromLDAP(session, realm, ldapUser);\n-                searchResults.add(imported);\n-            }\n-        }\n-\n-        return searchResults;\n+        return ldapUsers.stream().skip(firstResult).filter(ldapObject -> {\n+            String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n+            return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n+        }).map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n     }\n \n     @Override\n-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group) {\n-        return getGroupMembers(realm, group, 0, Integer.MAX_VALUE - 1);\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group) {\n+        return getGroupMembersStream(realm, group, 0, Integer.MAX_VALUE - 1);\n     }\n \n     @Override\n-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n-        List<ComponentModel> sortedMappers = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n-                .sorted(ldapMappersComparator.sortAsc())\n-                .collect(Collectors.toList());\n-\n-        for (ComponentModel mapperModel : sortedMappers) {\n-            LDAPStorageMapper ldapMapper = mapperManager.getMapper(mapperModel);\n-            List<UserModel> users = ldapMapper.getGroupMembers(realm, group, firstResult, maxResults);\n-\n-            // Sufficient for now\n-            if (users.size() > 0) {\n-                return users;\n-            }\n-        }\n-        return Collections.emptyList();\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n+        List<UserModel> users = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n+            .sorted(ldapMappersComparator.sortAsc())\n+            .map(mapperModel ->\n+                mapperManager.getMapper(mapperModel).getGroupMembers(realm, group, firstResult, maxResults))\n+            .filter(list -> list.size() > 0)\n+            .findFirst().orElse(null);\n+        return users == null ? Stream.empty() : users.stream();\n     }\n \n     @Override\n-    public List<UserModel> getRoleMembers(RealmModel realm, RoleModel role) {\n-        return getRoleMembers(realm, role, 0, Integer.MAX_VALUE - 1);\n+    public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role) {\n+        return getRoleMembersStream(realm, role, 0, Integer.MAX_VALUE - 1);\n     }\n \n     @Override\n-    public List<UserModel> getRoleMembers(RealmModel realm, RoleModel role, int firstResult, int maxResults) {\n-        List<ComponentModel> sortedMappers = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n+    public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role, int firstResult, int maxResults) {\n+        List<UserModel> users = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n                 .sorted(ldapMappersComparator.sortAsc())\n-                .collect(Collectors.toList());\n-        for (ComponentModel mapperModel : sortedMappers) {\n-            LDAPStorageMapper ldapMapper = mapperManager.getMapper(mapperModel);\n-            List<UserModel> users = ldapMapper.getRoleMembers(realm, role, firstResult, maxResults);\n-\n-            // Sufficient for now\n-            if (users.size() > 0) {\n-                return users;\n-            }\n-        }\n-        return Collections.emptyList();\n+                .map(mapperModel -> mapperManager.getMapper(mapperModel).getRoleMembers(realm, role, firstResult, maxResults))\n+                .filter(list -> list.size() > 0)", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk4NjUzMA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511986530", "bodyText": "Noted", "author": "sguilhen", "createdAt": "2020-10-26T14:07:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwMTQ2MA=="}], "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "changed_code": [{"header": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\nindex 1c8f5d22b0..45d34e572f 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n", "chunk": "@@ -417,12 +419,12 @@ public class LDAPStorageProvider implements UserStorageProvider,\n \n     @Override\n     public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role, int firstResult, int maxResults) {\n-        List<UserModel> users = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n+        return realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n                 .sorted(ldapMappersComparator.sortAsc())\n                 .map(mapperModel -> mapperManager.getMapper(mapperModel).getRoleMembers(realm, role, firstResult, maxResults))\n-                .filter(list -> list.size() > 0)\n-                .findFirst().orElse(null);\n-        return users == null ? Stream.empty() : users.stream();\n+                .filter(((Predicate<List>) List::isEmpty).negate())\n+                .map(List::stream)\n+                .findFirst().orElse(Stream.empty());\n     }\n \n     public List<UserModel> loadUsersByUsernames(List<String> usernames, RealmModel realm) {\n", "next_change": null}]}, "revised_code_in_main": {"commit": "aa4673517308a2f6b8214b192eb2151554564718", "changed_code": [{"header": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\nindex 1c8f5d22b0..45d34e572f 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n", "chunk": "@@ -417,12 +419,12 @@ public class LDAPStorageProvider implements UserStorageProvider,\n \n     @Override\n     public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role, int firstResult, int maxResults) {\n-        List<UserModel> users = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n+        return realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n                 .sorted(ldapMappersComparator.sortAsc())\n                 .map(mapperModel -> mapperManager.getMapper(mapperModel).getRoleMembers(realm, role, firstResult, maxResults))\n-                .filter(list -> list.size() > 0)\n-                .findFirst().orElse(null);\n-        return users == null ? Stream.empty() : users.stream();\n+                .filter(((Predicate<List>) List::isEmpty).negate())\n+                .map(List::stream)\n+                .findFirst().orElse(Stream.empty());\n     }\n \n     public List<UserModel> loadUsersByUsernames(List<String> usernames, RealmModel realm) {\n", "next_change": {"commit": "ba8e2fef6b0a47727f03d58f4fe2809d6e65c017", "changed_code": [{"header": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\nindex 45d34e572f..89804f9554 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n", "chunk": "@@ -387,41 +379,34 @@ public class LDAPStorageProvider implements UserStorageProvider,\n         Stream<LDAPObject> stream = searchLDAP(realm, params).stream()\n             .filter(ldapObject -> {\n                 String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n-                return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n+                return (session.userLocalStorage().getUserByUsername(realm, ldapUsername) == null);\n             });\n-        if (firstResult > 0)\n-            stream = stream.skip(firstResult);\n-        if (maxResults >= 0)\n-            stream = stream.limit(maxResults);\n-        return stream.map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n-    }\n \n-    @Override\n-    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group) {\n-        return getGroupMembersStream(realm, group, 0, Integer.MAX_VALUE - 1);\n+        return paginatedStream(stream, firstResult, maxResults).map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n     }\n \n     @Override\n-    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, Integer firstResult, Integer maxResults) {\n+        int first = firstResult == null ? 0 : firstResult;\n+        int max = maxResults == null ? DEFAULT_MAX_RESULTS : maxResults;\n+\n         return realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n             .sorted(ldapMappersComparator.sortAsc())\n             .map(mapperModel ->\n-                mapperManager.getMapper(mapperModel).getGroupMembers(realm, group, firstResult, maxResults))\n+                mapperManager.getMapper(mapperModel).getGroupMembers(realm, group, first, max))\n             .filter(((Predicate<List>) List::isEmpty).negate())\n             .map(List::stream)\n             .findFirst().orElse(Stream.empty());\n     }\n \n     @Override\n-    public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role) {\n-        return getRoleMembersStream(realm, role, 0, Integer.MAX_VALUE - 1);\n-    }\n+    public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role, Integer firstResult, Integer maxResults) {\n+        int first = firstResult == null ? 0 : firstResult;\n+        int max = maxResults == null ? DEFAULT_MAX_RESULTS : maxResults;\n \n-    @Override\n-    public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role, int firstResult, int maxResults) {\n         return realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n                 .sorted(ldapMappersComparator.sortAsc())\n-                .map(mapperModel -> mapperManager.getMapper(mapperModel).getRoleMembers(realm, role, firstResult, maxResults))\n+                .map(mapperModel -> mapperManager.getMapper(mapperModel).getRoleMembers(realm, role, first, max))\n                 .filter(((Predicate<List>) List::isEmpty).negate())\n                 .map(List::stream)\n                 .findFirst().orElse(Stream.empty());\n", "next_change": null}, {"header": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\nindex 45d34e572f..89804f9554 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n", "chunk": "@@ -430,7 +415,7 @@ public class LDAPStorageProvider implements UserStorageProvider,\n     public List<UserModel> loadUsersByUsernames(List<String> usernames, RealmModel realm) {\n         List<UserModel> result = new ArrayList<>();\n         for (String username : usernames) {\n-            UserModel kcUser = session.users().getUserByUsername(username, realm);\n+            UserModel kcUser = session.users().getUserByUsername(realm, username);\n             if (kcUser == null) {\n                 logger.warnf(\"User '%s' referenced by membership wasn't found in LDAP\", username);\n             } else if (model.isImportEnabled() && !model.getId().equals(kcUser.getFederationLink())) {\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "aa4673517308a2f6b8214b192eb2151554564718", "message": "Merge commit", "committedDate": null}, {"oid": "84df008bc2173df12b6cbfa58047ebc120d1f413", "committedDate": "2020-11-18 21:07:51 +0100", "message": "[KEYCLOAK-16341] Make the new stream-based methods in server-spi user interfaces default instead of the collection-based versions.  - this ensures that providing implementation for the collection-based methods is enough, which preserves    backwards compatibility with older custom implementations.  - alternative interfaces now allow new implementations to focus on the stream variants of the query methods."}, {"oid": "edef93cd491e545de642fd39d0df0a53cecee830", "committedDate": "2020-12-07 19:48:35 +0100", "message": "[KEYCLOAK-16232] Streamify the UserCredentialStore and UserCredentialManager interfaces"}, {"oid": "8e376aef51b4b5d7ade4e5196ee628a086c1749a", "committedDate": "2020-12-10 08:57:53 +0100", "message": "KEYCLOAK-15847 Add MapUserProvider"}, {"oid": "1402d021deb014310027ba506e6cfa7686b315b4", "committedDate": "2021-01-08 13:55:48 +0100", "message": "KEYCLOAK-14846 Default roles processing"}, {"oid": "ba8e2fef6b0a47727f03d58f4fe2809d6e65c017", "committedDate": "2021-01-18 16:56:10 +0100", "message": "KEYCLOAK-15524 Cleanup user related interfaces"}, {"oid": "82fc4012983ea3f6dc2a24f157ab7ced57150465", "committedDate": "2021-03-16 17:55:24 +0100", "message": "[KEYCLOAK-9841] use LDAPUser UUID as an identifier instead of username"}, {"oid": "b4536a394abc8551ce9af24491278a56e25c2290", "committedDate": "2021-08-03 13:40:02 +0200", "message": "Missing null check for session.userCache() added"}, {"oid": "11e5f66c60ea53140dbc711a59b683f33462f9b9", "committedDate": "2021-09-14 20:27:09 +0200", "message": "KEYCLOAK-19056 EDIT MODE field should not be leave empty (#8380)"}, {"oid": "cb4a513e24a317402ca7c1042bb4f4f25706a122", "committedDate": "2022-04-12 14:38:17 +0200", "message": "Fail authenticate if credentialInput is not of type UserCredentialModel"}, {"oid": "703e868a5129c147d723e8c367c7eb962843e280", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Preparation for moving User Storage SPI"}, {"oid": "bc8fd21dc6495b7f43f3466eb3545055753114ae", "committedDate": "2022-06-21 08:53:06 +0200", "message": "SingleUserCredentialManager moving in - UserStorageManager now handles authentication for old Kerberos+LDAP style - new getUserByCredential method in MapUserProvider would eventually do the same."}, {"oid": "e396d0daa1fed0cb82cf761fe3b461ba24118a10", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Renaming SingleUserCredentialManager and UserModel.getUserCredentialManager(): - class SingleUserCredentialManager to SingleEntityCredentialManager - method UserModel.getUserCredentialManager() to credentialManager()"}, {"oid": "1bc6133e4ecee8f4ebd9b10f8f92d0fca4e11d8e", "committedDate": "2022-06-21 08:53:06 +0200", "message": "redirect calls to userLocalStorage from legacy modules (federation, ldap, sssd, kerberos)"}, {"oid": "d41764b19bbb682b187f37a60b71de9a6eb7d612", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Inline deprecated methods in legacy code"}, {"oid": "cb0c88182148fd352969383a33f2eeb56cc4de9f", "committedDate": "2022-06-21 08:53:06 +0200", "message": "rename SingleEntityCredentialManager to SubjectCredentialManager"}, {"oid": "cc9326fcad3aa209adba8f1c16daae8f2699a702", "committedDate": "2022-09-16 20:35:50 +0200", "message": "Delay LDAPObject creation until mandatory attributes are set (#14341)"}, {"oid": "883e83e62540168593046e34292849e16c009760", "committedDate": "2022-10-25 09:01:33 +0200", "message": "Remove deprecated methods from data providers and models"}, {"oid": "1e4401f52135164a20344dcd43207df0316eca03", "committedDate": "2023-03-02 08:21:38 +0100", "message": "Avoid returning the same entity multiple times from separate searches"}, {"oid": "fd6a6ec3ad328cf9581369299c68317f7fcc5d00", "committedDate": "2023-05-19 08:40:41 +0200", "message": "Make LDAP `searchForUsersStream` consistent with other storages"}, {"oid": "bdbbd2959d2fbe2ea2f1a76fdaea8f2984acf29c", "committedDate": "2023-05-23 11:48:33 +0200", "message": "User search with LDAP federation not consistent"}, {"oid": "a175efcb72902a767342941136fe7515733e6f2f", "committedDate": "2023-05-31 11:47:54 +0200", "message": "Split `UserQueryProvider` into `UserQueryMethods` and `UserCountMethods` and make `LdapStorageProvider` implement only `UserQueryMethods` Co-authored-by: mhajas <mhajas@redhat.com>"}, {"oid": "512e30b2105affb583030a4ce31928e33e664fbe", "committedDate": "2023-05-31 14:38:04 +0200", "message": "Add escaping for fields with wildcard search"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwMTU3Mg==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511801572", "body": "Same as above", "bodyText": "Same as above", "bodyHTML": "<p dir=\"auto\">Same as above</p>", "author": "martin-kanis", "createdAt": "2020-10-26T08:55:10Z", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java", "diffHunk": "@@ -393,65 +387,42 @@ public int getUsersCount(RealmModel realm) {\n             }\n         }\n \n-        List<UserModel> searchResults =new LinkedList<UserModel>();\n-\n         List<LDAPObject> ldapUsers = searchLDAP(realm, params, maxResults + firstResult);\n-        int counter = 0;\n-        for (LDAPObject ldapUser : ldapUsers) {\n-            if (counter++ < firstResult) continue;\n-            String ldapUsername = LDAPUtils.getUsername(ldapUser, this.ldapIdentityStore.getConfig());\n-            if (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null) {\n-                UserModel imported = importUserFromLDAP(session, realm, ldapUser);\n-                searchResults.add(imported);\n-            }\n-        }\n-\n-        return searchResults;\n+        return ldapUsers.stream().skip(firstResult).filter(ldapObject -> {\n+            String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n+            return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n+        }).map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n     }\n \n     @Override\n-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group) {\n-        return getGroupMembers(realm, group, 0, Integer.MAX_VALUE - 1);\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group) {\n+        return getGroupMembersStream(realm, group, 0, Integer.MAX_VALUE - 1);\n     }\n \n     @Override\n-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n-        List<ComponentModel> sortedMappers = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n-                .sorted(ldapMappersComparator.sortAsc())\n-                .collect(Collectors.toList());\n-\n-        for (ComponentModel mapperModel : sortedMappers) {\n-            LDAPStorageMapper ldapMapper = mapperManager.getMapper(mapperModel);\n-            List<UserModel> users = ldapMapper.getGroupMembers(realm, group, firstResult, maxResults);\n-\n-            // Sufficient for now\n-            if (users.size() > 0) {\n-                return users;\n-            }\n-        }\n-        return Collections.emptyList();\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n+        List<UserModel> users = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n+            .sorted(ldapMappersComparator.sortAsc())\n+            .map(mapperModel ->\n+                mapperManager.getMapper(mapperModel).getGroupMembers(realm, group, firstResult, maxResults))\n+            .filter(list -> list.size() > 0)\n+            .findFirst().orElse(null);\n+        return users == null ? Stream.empty() : users.stream();\n     }\n \n     @Override\n-    public List<UserModel> getRoleMembers(RealmModel realm, RoleModel role) {\n-        return getRoleMembers(realm, role, 0, Integer.MAX_VALUE - 1);\n+    public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role) {\n+        return getRoleMembersStream(realm, role, 0, Integer.MAX_VALUE - 1);\n     }\n \n     @Override\n-    public List<UserModel> getRoleMembers(RealmModel realm, RoleModel role, int firstResult, int maxResults) {\n-        List<ComponentModel> sortedMappers = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n+    public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role, int firstResult, int maxResults) {\n+        List<UserModel> users = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n                 .sorted(ldapMappersComparator.sortAsc())\n-                .collect(Collectors.toList());\n-        for (ComponentModel mapperModel : sortedMappers) {\n-            LDAPStorageMapper ldapMapper = mapperManager.getMapper(mapperModel);\n-            List<UserModel> users = ldapMapper.getRoleMembers(realm, role, firstResult, maxResults);\n-\n-            // Sufficient for now\n-            if (users.size() > 0) {\n-                return users;\n-            }\n-        }\n-        return Collections.emptyList();\n+                .map(mapperModel -> mapperManager.getMapper(mapperModel).getRoleMembers(realm, role, firstResult, maxResults))\n+                .filter(list -> list.size() > 0)\n+                .findFirst().orElse(null);\n+        return users == null ? Stream.empty() : users.stream();", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "changed_code": [{"header": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\nindex 1c8f5d22b0..45d34e572f 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n", "chunk": "@@ -417,12 +419,12 @@ public class LDAPStorageProvider implements UserStorageProvider,\n \n     @Override\n     public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role, int firstResult, int maxResults) {\n-        List<UserModel> users = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n+        return realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n                 .sorted(ldapMappersComparator.sortAsc())\n                 .map(mapperModel -> mapperManager.getMapper(mapperModel).getRoleMembers(realm, role, firstResult, maxResults))\n-                .filter(list -> list.size() > 0)\n-                .findFirst().orElse(null);\n-        return users == null ? Stream.empty() : users.stream();\n+                .filter(((Predicate<List>) List::isEmpty).negate())\n+                .map(List::stream)\n+                .findFirst().orElse(Stream.empty());\n     }\n \n     public List<UserModel> loadUsersByUsernames(List<String> usernames, RealmModel realm) {\n", "next_change": null}]}, "revised_code_in_main": {"commit": "aa4673517308a2f6b8214b192eb2151554564718", "changed_code": [{"header": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\nindex 1c8f5d22b0..45d34e572f 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n", "chunk": "@@ -417,12 +419,12 @@ public class LDAPStorageProvider implements UserStorageProvider,\n \n     @Override\n     public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role, int firstResult, int maxResults) {\n-        List<UserModel> users = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n+        return realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n                 .sorted(ldapMappersComparator.sortAsc())\n                 .map(mapperModel -> mapperManager.getMapper(mapperModel).getRoleMembers(realm, role, firstResult, maxResults))\n-                .filter(list -> list.size() > 0)\n-                .findFirst().orElse(null);\n-        return users == null ? Stream.empty() : users.stream();\n+                .filter(((Predicate<List>) List::isEmpty).negate())\n+                .map(List::stream)\n+                .findFirst().orElse(Stream.empty());\n     }\n \n     public List<UserModel> loadUsersByUsernames(List<String> usernames, RealmModel realm) {\n", "next_change": {"commit": "ba8e2fef6b0a47727f03d58f4fe2809d6e65c017", "changed_code": [{"header": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\nindex 45d34e572f..89804f9554 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n", "chunk": "@@ -387,41 +379,34 @@ public class LDAPStorageProvider implements UserStorageProvider,\n         Stream<LDAPObject> stream = searchLDAP(realm, params).stream()\n             .filter(ldapObject -> {\n                 String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n-                return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n+                return (session.userLocalStorage().getUserByUsername(realm, ldapUsername) == null);\n             });\n-        if (firstResult > 0)\n-            stream = stream.skip(firstResult);\n-        if (maxResults >= 0)\n-            stream = stream.limit(maxResults);\n-        return stream.map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n-    }\n \n-    @Override\n-    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group) {\n-        return getGroupMembersStream(realm, group, 0, Integer.MAX_VALUE - 1);\n+        return paginatedStream(stream, firstResult, maxResults).map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n     }\n \n     @Override\n-    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, Integer firstResult, Integer maxResults) {\n+        int first = firstResult == null ? 0 : firstResult;\n+        int max = maxResults == null ? DEFAULT_MAX_RESULTS : maxResults;\n+\n         return realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n             .sorted(ldapMappersComparator.sortAsc())\n             .map(mapperModel ->\n-                mapperManager.getMapper(mapperModel).getGroupMembers(realm, group, firstResult, maxResults))\n+                mapperManager.getMapper(mapperModel).getGroupMembers(realm, group, first, max))\n             .filter(((Predicate<List>) List::isEmpty).negate())\n             .map(List::stream)\n             .findFirst().orElse(Stream.empty());\n     }\n \n     @Override\n-    public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role) {\n-        return getRoleMembersStream(realm, role, 0, Integer.MAX_VALUE - 1);\n-    }\n+    public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role, Integer firstResult, Integer maxResults) {\n+        int first = firstResult == null ? 0 : firstResult;\n+        int max = maxResults == null ? DEFAULT_MAX_RESULTS : maxResults;\n \n-    @Override\n-    public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role, int firstResult, int maxResults) {\n         return realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n                 .sorted(ldapMappersComparator.sortAsc())\n-                .map(mapperModel -> mapperManager.getMapper(mapperModel).getRoleMembers(realm, role, firstResult, maxResults))\n+                .map(mapperModel -> mapperManager.getMapper(mapperModel).getRoleMembers(realm, role, first, max))\n                 .filter(((Predicate<List>) List::isEmpty).negate())\n                 .map(List::stream)\n                 .findFirst().orElse(Stream.empty());\n", "next_change": null}, {"header": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\nindex 45d34e572f..89804f9554 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n", "chunk": "@@ -430,7 +415,7 @@ public class LDAPStorageProvider implements UserStorageProvider,\n     public List<UserModel> loadUsersByUsernames(List<String> usernames, RealmModel realm) {\n         List<UserModel> result = new ArrayList<>();\n         for (String username : usernames) {\n-            UserModel kcUser = session.users().getUserByUsername(username, realm);\n+            UserModel kcUser = session.users().getUserByUsername(realm, username);\n             if (kcUser == null) {\n                 logger.warnf(\"User '%s' referenced by membership wasn't found in LDAP\", username);\n             } else if (model.isImportEnabled() && !model.getId().equals(kcUser.getFederationLink())) {\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "aa4673517308a2f6b8214b192eb2151554564718", "message": "Merge commit", "committedDate": null}, {"oid": "84df008bc2173df12b6cbfa58047ebc120d1f413", "committedDate": "2020-11-18 21:07:51 +0100", "message": "[KEYCLOAK-16341] Make the new stream-based methods in server-spi user interfaces default instead of the collection-based versions.  - this ensures that providing implementation for the collection-based methods is enough, which preserves    backwards compatibility with older custom implementations.  - alternative interfaces now allow new implementations to focus on the stream variants of the query methods."}, {"oid": "edef93cd491e545de642fd39d0df0a53cecee830", "committedDate": "2020-12-07 19:48:35 +0100", "message": "[KEYCLOAK-16232] Streamify the UserCredentialStore and UserCredentialManager interfaces"}, {"oid": "8e376aef51b4b5d7ade4e5196ee628a086c1749a", "committedDate": "2020-12-10 08:57:53 +0100", "message": "KEYCLOAK-15847 Add MapUserProvider"}, {"oid": "1402d021deb014310027ba506e6cfa7686b315b4", "committedDate": "2021-01-08 13:55:48 +0100", "message": "KEYCLOAK-14846 Default roles processing"}, {"oid": "ba8e2fef6b0a47727f03d58f4fe2809d6e65c017", "committedDate": "2021-01-18 16:56:10 +0100", "message": "KEYCLOAK-15524 Cleanup user related interfaces"}, {"oid": "82fc4012983ea3f6dc2a24f157ab7ced57150465", "committedDate": "2021-03-16 17:55:24 +0100", "message": "[KEYCLOAK-9841] use LDAPUser UUID as an identifier instead of username"}, {"oid": "b4536a394abc8551ce9af24491278a56e25c2290", "committedDate": "2021-08-03 13:40:02 +0200", "message": "Missing null check for session.userCache() added"}, {"oid": "11e5f66c60ea53140dbc711a59b683f33462f9b9", "committedDate": "2021-09-14 20:27:09 +0200", "message": "KEYCLOAK-19056 EDIT MODE field should not be leave empty (#8380)"}, {"oid": "cb4a513e24a317402ca7c1042bb4f4f25706a122", "committedDate": "2022-04-12 14:38:17 +0200", "message": "Fail authenticate if credentialInput is not of type UserCredentialModel"}, {"oid": "703e868a5129c147d723e8c367c7eb962843e280", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Preparation for moving User Storage SPI"}, {"oid": "bc8fd21dc6495b7f43f3466eb3545055753114ae", "committedDate": "2022-06-21 08:53:06 +0200", "message": "SingleUserCredentialManager moving in - UserStorageManager now handles authentication for old Kerberos+LDAP style - new getUserByCredential method in MapUserProvider would eventually do the same."}, {"oid": "e396d0daa1fed0cb82cf761fe3b461ba24118a10", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Renaming SingleUserCredentialManager and UserModel.getUserCredentialManager(): - class SingleUserCredentialManager to SingleEntityCredentialManager - method UserModel.getUserCredentialManager() to credentialManager()"}, {"oid": "1bc6133e4ecee8f4ebd9b10f8f92d0fca4e11d8e", "committedDate": "2022-06-21 08:53:06 +0200", "message": "redirect calls to userLocalStorage from legacy modules (federation, ldap, sssd, kerberos)"}, {"oid": "d41764b19bbb682b187f37a60b71de9a6eb7d612", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Inline deprecated methods in legacy code"}, {"oid": "cb0c88182148fd352969383a33f2eeb56cc4de9f", "committedDate": "2022-06-21 08:53:06 +0200", "message": "rename SingleEntityCredentialManager to SubjectCredentialManager"}, {"oid": "cc9326fcad3aa209adba8f1c16daae8f2699a702", "committedDate": "2022-09-16 20:35:50 +0200", "message": "Delay LDAPObject creation until mandatory attributes are set (#14341)"}, {"oid": "883e83e62540168593046e34292849e16c009760", "committedDate": "2022-10-25 09:01:33 +0200", "message": "Remove deprecated methods from data providers and models"}, {"oid": "1e4401f52135164a20344dcd43207df0316eca03", "committedDate": "2023-03-02 08:21:38 +0100", "message": "Avoid returning the same entity multiple times from separate searches"}, {"oid": "fd6a6ec3ad328cf9581369299c68317f7fcc5d00", "committedDate": "2023-05-19 08:40:41 +0200", "message": "Make LDAP `searchForUsersStream` consistent with other storages"}, {"oid": "bdbbd2959d2fbe2ea2f1a76fdaea8f2984acf29c", "committedDate": "2023-05-23 11:48:33 +0200", "message": "User search with LDAP federation not consistent"}, {"oid": "a175efcb72902a767342941136fe7515733e6f2f", "committedDate": "2023-05-31 11:47:54 +0200", "message": "Split `UserQueryProvider` into `UserQueryMethods` and `UserCountMethods` and make `LdapStorageProvider` implement only `UserQueryMethods` Co-authored-by: mhajas <mhajas@redhat.com>"}, {"oid": "512e30b2105affb583030a4ce31928e33e664fbe", "committedDate": "2023-05-31 14:38:04 +0200", "message": "Add escaping for fields with wildcard search"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgzMzQ0NA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511833444", "body": "Is this equal to the collection variant? Shouldn't there be `Stream.concat(super.getRequiredActionsStream(), Stream.of(RequiredAction.UPDATE_PASSWORD.toString())).distinct();` ?", "bodyText": "Is this equal to the collection variant? Shouldn't there be Stream.concat(super.getRequiredActionsStream(), Stream.of(RequiredAction.UPDATE_PASSWORD.toString())).distinct(); ?", "bodyHTML": "<p dir=\"auto\">Is this equal to the collection variant? Shouldn't there be <code>Stream.concat(super.getRequiredActionsStream(), Stream.of(RequiredAction.UPDATE_PASSWORD.toString())).distinct();</code> ?</p>", "author": "martin-kanis", "createdAt": "2020-10-26T09:47:50Z", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/msad/MSADUserAccountControlStorageMapper.java", "diffHunk": "@@ -299,18 +300,13 @@ public void removeRequiredAction(String action) {\n         }\n \n         @Override\n-        public Set<String> getRequiredActions() {\n-            Set<String> requiredActions = super.getRequiredActions();\n-\n+        public Stream<String> getRequiredActionsStream() {\n             if (ldapProvider.getEditMode() == UserStorageProvider.EditMode.WRITABLE) {\n                 if (getPwdLastSet() == 0 || getUserAccountControl(ldapUser).has(UserAccountControl.PASSWORD_EXPIRED)) {\n-                    requiredActions = new HashSet<>(requiredActions);\n-                    requiredActions.add(RequiredAction.UPDATE_PASSWORD.toString());\n-                    return requiredActions;\n+                    return Stream.of(RequiredAction.UPDATE_PASSWORD.toString());", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAwMDU0Nw==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r512000547", "bodyText": "You are absolutely right, I misread the if() section and didn't see the creation of the collection with the values already obtained by calling super.getRequiredActions().", "author": "sguilhen", "createdAt": "2020-10-26T14:26:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgzMzQ0NA=="}], "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "changed_code": [{"header": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/msad/MSADUserAccountControlStorageMapper.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/msad/MSADUserAccountControlStorageMapper.java\nindex 78174a882f..b76ecf641a 100644\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/msad/MSADUserAccountControlStorageMapper.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/msad/MSADUserAccountControlStorageMapper.java\n", "chunk": "@@ -303,7 +303,8 @@ public class MSADUserAccountControlStorageMapper extends AbstractLDAPStorageMapp\n         public Stream<String> getRequiredActionsStream() {\n             if (ldapProvider.getEditMode() == UserStorageProvider.EditMode.WRITABLE) {\n                 if (getPwdLastSet() == 0 || getUserAccountControl(ldapUser).has(UserAccountControl.PASSWORD_EXPIRED)) {\n-                    return Stream.of(RequiredAction.UPDATE_PASSWORD.toString());\n+                    return Stream.concat(super.getRequiredActionsStream(), Stream.of(RequiredAction.UPDATE_PASSWORD.toString()))\n+                            .distinct();\n                 }\n             }\n             return super.getRequiredActionsStream();\n", "next_change": null}]}, "revised_code_in_main": {"commit": "aa4673517308a2f6b8214b192eb2151554564718", "changed_code": [{"header": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/msad/MSADUserAccountControlStorageMapper.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/msad/MSADUserAccountControlStorageMapper.java\nindex 78174a882f..b76ecf641a 100644\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/msad/MSADUserAccountControlStorageMapper.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/msad/MSADUserAccountControlStorageMapper.java\n", "chunk": "@@ -303,7 +303,8 @@ public class MSADUserAccountControlStorageMapper extends AbstractLDAPStorageMapp\n         public Stream<String> getRequiredActionsStream() {\n             if (ldapProvider.getEditMode() == UserStorageProvider.EditMode.WRITABLE) {\n                 if (getPwdLastSet() == 0 || getUserAccountControl(ldapUser).has(UserAccountControl.PASSWORD_EXPIRED)) {\n-                    return Stream.of(RequiredAction.UPDATE_PASSWORD.toString());\n+                    return Stream.concat(super.getRequiredActionsStream(), Stream.of(RequiredAction.UPDATE_PASSWORD.toString()))\n+                            .distinct();\n                 }\n             }\n             return super.getRequiredActionsStream();\n", "next_change": {"commit": "e58eeca80066d225e390c4237c6b83636648325e", "changed_code": [{"header": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/msad/MSADUserAccountControlStorageMapper.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/msad/MSADUserAccountControlStorageMapper.java\nindex b76ecf641a..6c1c9de4c7 100644\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/msad/MSADUserAccountControlStorageMapper.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/msad/MSADUserAccountControlStorageMapper.java\n", "chunk": "@@ -303,6 +328,7 @@ public class MSADUserAccountControlStorageMapper extends AbstractLDAPStorageMapp\n         public Stream<String> getRequiredActionsStream() {\n             if (ldapProvider.getEditMode() == UserStorageProvider.EditMode.WRITABLE) {\n                 if (getPwdLastSet() == 0 || getUserAccountControl(ldapUser).has(UserAccountControl.PASSWORD_EXPIRED)) {\n+                    MSADUserAccountControlStorageMapper.logger.tracef(\"Required action UPDATE_PASSWORD is set in LDAP for user '%s' in realm '%s'\", getUsername(), getRealmName());\n                     return Stream.concat(super.getRequiredActionsStream(), Stream.of(RequiredAction.UPDATE_PASSWORD.toString()))\n                             .distinct();\n                 }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "aa4673517308a2f6b8214b192eb2151554564718", "message": "Merge commit", "committedDate": null}, {"oid": "73d0bb34c4d8a6826e538f2a81bef515732a59c9", "committedDate": "2020-12-07 19:48:35 +0100", "message": "[KEYCLOAK-16232] Replace usages of deprecated collection-based methods with the respective stream variants"}, {"oid": "e58eeca80066d225e390c4237c6b83636648325e", "committedDate": "2021-07-28 08:47:01 +0200", "message": "KEYCLOAK-18706 Add UPDATE_PASSWORD required action only to authenticationSession when MSAD requires user to change password"}, {"oid": "418d1e34714b5587c1900054bc499213c11dbc1b", "committedDate": "2021-08-18 17:39:19 +0200", "message": "KEYCLOAK-19039 Sync UPDATE_PASSWORD required action to only to MSAD with WRITABLE edit mode. Add tests for MSAD mapper"}, {"oid": "91e88f554ea38d41a7f6c6aeb72ecdfae543c615", "committedDate": "2022-06-03 12:25:14 -0300", "message": "Replaces instances of `himself` with more inclusive language"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg1NzI4Nw==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511857287", "body": "Couldn't we just return already obtained identities? `federatedIdentities.stream();`?", "bodyText": "Couldn't we just return already obtained identities? federatedIdentities.stream();?", "bodyHTML": "<p dir=\"auto\">Couldn't we just return already obtained identities? <code>federatedIdentities.stream();</code>?</p>", "author": "martin-kanis", "createdAt": "2020-10-26T10:27:18Z", "path": "model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java", "diffHunk": "@@ -578,64 +576,65 @@ public int getUsersCount(Map<String, String> params, RealmModel realm, Set<Strin\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm, int firstResult, int maxResults, boolean includeServiceAccounts) {\n-        return getDelegate().getUsers(realm, firstResult, maxResults, includeServiceAccounts);\n+    public Stream<UserModel> getUsersStream(RealmModel realm, int firstResult, int maxResults, boolean includeServiceAccounts) {\n+        return getDelegate().getUsersStream(realm, firstResult, maxResults, includeServiceAccounts);\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm) {\n-        return getUsers(realm, false);\n+    public Stream<UserModel> getUsersStream(RealmModel realm) {\n+        return getUsersStream(realm, false);\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm, int firstResult, int maxResults) {\n-         return getUsers(realm, firstResult, maxResults, false);\n+    public Stream<UserModel> getUsersStream(RealmModel realm, int firstResult, int maxResults) {\n+         return getUsersStream(realm, firstResult, maxResults, false);\n     }\n \n     @Override\n-    public List<UserModel> searchForUser(String search, RealmModel realm) {\n-        return getDelegate().searchForUser(search, realm);\n+    public Stream<UserModel> searchForUserStream(String search, RealmModel realm) {\n+        return getDelegate().searchForUserStream(search, realm);\n     }\n \n     @Override\n-    public List<UserModel> searchForUser(String search, RealmModel realm, int firstResult, int maxResults) {\n-        return getDelegate().searchForUser(search, realm, firstResult, maxResults);\n+    public Stream<UserModel> searchForUserStream(String search, RealmModel realm, int firstResult, int maxResults) {\n+        return getDelegate().searchForUserStream(search, realm, firstResult, maxResults);\n     }\n \n     @Override\n-    public List<UserModel> searchForUser(Map<String, String> attributes, RealmModel realm) {\n-        return getDelegate().searchForUser(attributes, realm);\n+    public Stream<UserModel> searchForUserStream(Map<String, String> attributes, RealmModel realm) {\n+        return getDelegate().searchForUserStream(attributes, realm);\n     }\n \n     @Override\n-    public List<UserModel> searchForUser(Map<String, String> attributes, RealmModel realm, int firstResult, int maxResults) {\n-        return getDelegate().searchForUser(attributes, realm, firstResult, maxResults);\n+    public Stream<UserModel> searchForUserStream(Map<String, String> attributes, RealmModel realm, int firstResult, int maxResults) {\n+        return getDelegate().searchForUserStream(attributes, realm, firstResult, maxResults);\n     }\n \n     @Override\n-    public List<UserModel> searchForUserByUserAttribute(String attrName, String attrValue, RealmModel realm) {\n-        return getDelegate().searchForUserByUserAttribute(attrName, attrValue, realm);\n+    public Stream<UserModel> searchForUserByUserAttributeStream(String attrName, String attrValue, RealmModel realm) {\n+        return getDelegate().searchForUserByUserAttributeStream(attrName, attrValue, realm);\n     }\n \n     @Override\n-    public Set<FederatedIdentityModel> getFederatedIdentities(UserModel user, RealmModel realm) {\n+    public Stream<FederatedIdentityModel> getFederatedIdentitiesStream(UserModel user, RealmModel realm) {\n         logger.tracev(\"getFederatedIdentities: {0}\", user.getUsername());\n \n         String cacheKey = getFederatedIdentityLinksCacheKey(user.getId());\n         if (realmInvalidations.contains(realm.getId()) || invalidations.contains(user.getId()) || invalidations.contains(cacheKey)) {\n-            return getDelegate().getFederatedIdentities(user, realm);\n+            return getDelegate().getFederatedIdentitiesStream(user, realm);\n         }\n \n         CachedFederatedIdentityLinks cachedLinks = cache.get(cacheKey, CachedFederatedIdentityLinks.class);\n \n         if (cachedLinks == null) {\n             Long loaded = cache.getCurrentRevision(cacheKey);\n-            Set<FederatedIdentityModel> federatedIdentities = getDelegate().getFederatedIdentities(user, realm);\n+            Set<FederatedIdentityModel> federatedIdentities = getDelegate().getFederatedIdentitiesStream(user, realm)\n+                    .collect(Collectors.toSet());\n             cachedLinks = new CachedFederatedIdentityLinks(loaded, cacheKey, realm, federatedIdentities);\n             cache.addRevisioned(cachedLinks, startupRevision);\n-            return federatedIdentities;\n+            return getDelegate().getFederatedIdentitiesStream(user, realm);", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAwMzE1NQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r512003155", "bodyText": "Yeah, we could do that. This is one of the places where using streams leads to code that is a bit odd - we get a stream, consume it into a collection, then get the cached collection and streamify it again.", "author": "sguilhen", "createdAt": "2020-10-26T14:29:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg1NzI4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "changed_code": [{"header": "diff --git a/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java b/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java\nindex d7657ebd7e..6a0c37e105 100755\n--- a/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java\n+++ b/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java\n", "chunk": "@@ -632,7 +632,7 @@ public class UserCacheSession implements UserCache {\n                     .collect(Collectors.toSet());\n             cachedLinks = new CachedFederatedIdentityLinks(loaded, cacheKey, realm, federatedIdentities);\n             cache.addRevisioned(cachedLinks, startupRevision);\n-            return getDelegate().getFederatedIdentitiesStream(user, realm);\n+            return federatedIdentities.stream();\n         } else {\n             return cachedLinks.getFederatedIdentities().stream();\n         }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "aa4673517308a2f6b8214b192eb2151554564718", "changed_code": [{"header": "diff --git a/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java b/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java\nindex d7657ebd7e..6a0c37e105 100755\n--- a/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java\n+++ b/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java\n", "chunk": "@@ -632,7 +632,7 @@ public class UserCacheSession implements UserCache {\n                     .collect(Collectors.toSet());\n             cachedLinks = new CachedFederatedIdentityLinks(loaded, cacheKey, realm, federatedIdentities);\n             cache.addRevisioned(cachedLinks, startupRevision);\n-            return getDelegate().getFederatedIdentitiesStream(user, realm);\n+            return federatedIdentities.stream();\n         } else {\n             return cachedLinks.getFederatedIdentities().stream();\n         }\n", "next_change": {"commit": "ba8e2fef6b0a47727f03d58f4fe2809d6e65c017", "changed_code": [{"header": "diff --git a/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java b/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java\nindex 6a0c37e105..ed0dc22790 100755\n--- a/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java\n+++ b/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java\n", "chunk": "@@ -586,49 +581,49 @@ public class UserCacheSession implements UserCache {\n     }\n \n     @Override\n-    public Stream<UserModel> getUsersStream(RealmModel realm, int firstResult, int maxResults) {\n+    public Stream<UserModel> getUsersStream(RealmModel realm, Integer firstResult, Integer maxResults) {\n          return getUsersStream(realm, firstResult, maxResults, false);\n     }\n \n     @Override\n-    public Stream<UserModel> searchForUserStream(String search, RealmModel realm) {\n-        return getDelegate().searchForUserStream(search, realm);\n+    public Stream<UserModel> searchForUserStream(RealmModel realm, String search) {\n+        return getDelegate().searchForUserStream(realm, search);\n     }\n \n     @Override\n-    public Stream<UserModel> searchForUserStream(String search, RealmModel realm, int firstResult, int maxResults) {\n-        return getDelegate().searchForUserStream(search, realm, firstResult, maxResults);\n+    public Stream<UserModel> searchForUserStream(RealmModel realm, String search, Integer firstResult, Integer maxResults) {\n+        return getDelegate().searchForUserStream(realm, search, firstResult, maxResults);\n     }\n \n     @Override\n-    public Stream<UserModel> searchForUserStream(Map<String, String> attributes, RealmModel realm) {\n-        return getDelegate().searchForUserStream(attributes, realm);\n+    public Stream<UserModel> searchForUserStream(RealmModel realm, Map<String, String> attributes) {\n+        return getDelegate().searchForUserStream(realm, attributes);\n     }\n \n     @Override\n-    public Stream<UserModel> searchForUserStream(Map<String, String> attributes, RealmModel realm, int firstResult, int maxResults) {\n-        return getDelegate().searchForUserStream(attributes, realm, firstResult, maxResults);\n+    public Stream<UserModel> searchForUserStream(RealmModel realm, Map<String, String> attributes, Integer firstResult, Integer maxResults) {\n+        return getDelegate().searchForUserStream(realm, attributes, firstResult, maxResults);\n     }\n \n     @Override\n-    public Stream<UserModel> searchForUserByUserAttributeStream(String attrName, String attrValue, RealmModel realm) {\n-        return getDelegate().searchForUserByUserAttributeStream(attrName, attrValue, realm);\n+    public Stream<UserModel> searchForUserByUserAttributeStream(RealmModel realm, String attrName, String attrValue) {\n+        return getDelegate().searchForUserByUserAttributeStream(realm, attrName, attrValue);\n     }\n \n     @Override\n-    public Stream<FederatedIdentityModel> getFederatedIdentitiesStream(UserModel user, RealmModel realm) {\n+    public Stream<FederatedIdentityModel> getFederatedIdentitiesStream(RealmModel realm, UserModel user) {\n         logger.tracev(\"getFederatedIdentities: {0}\", user.getUsername());\n \n         String cacheKey = getFederatedIdentityLinksCacheKey(user.getId());\n         if (realmInvalidations.contains(realm.getId()) || invalidations.contains(user.getId()) || invalidations.contains(cacheKey)) {\n-            return getDelegate().getFederatedIdentitiesStream(user, realm);\n+            return getDelegate().getFederatedIdentitiesStream(realm, user);\n         }\n \n         CachedFederatedIdentityLinks cachedLinks = cache.get(cacheKey, CachedFederatedIdentityLinks.class);\n \n         if (cachedLinks == null) {\n             Long loaded = cache.getCurrentRevision(cacheKey);\n-            Set<FederatedIdentityModel> federatedIdentities = getDelegate().getFederatedIdentitiesStream(user, realm)\n+            Set<FederatedIdentityModel> federatedIdentities = getDelegate().getFederatedIdentitiesStream(realm, user)\n                     .collect(Collectors.toSet());\n             cachedLinks = new CachedFederatedIdentityLinks(loaded, cacheKey, realm, federatedIdentities);\n             cache.addRevisioned(cachedLinks, startupRevision);\n", "next_change": null}, {"header": "diff --git a/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java b/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java\nindex 6a0c37e105..ed0dc22790 100755\n--- a/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java\n+++ b/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java\n", "chunk": "@@ -639,21 +634,17 @@ public class UserCacheSession implements UserCache {\n     }\n \n     @Override\n-    public FederatedIdentityModel getFederatedIdentity(UserModel user, String socialProvider, RealmModel realm) {\n+    public FederatedIdentityModel getFederatedIdentity(RealmModel realm, UserModel user, String socialProvider) {\n         logger.tracev(\"getFederatedIdentity: {0} {1}\", user.getUsername(), socialProvider);\n \n         String cacheKey = getFederatedIdentityLinksCacheKey(user.getId());\n         if (realmInvalidations.contains(realm.getId()) || invalidations.contains(user.getId()) || invalidations.contains(cacheKey)) {\n-            return getDelegate().getFederatedIdentity(user, socialProvider, realm);\n+            return getDelegate().getFederatedIdentity(realm, user, socialProvider);\n         }\n \n-        Set<FederatedIdentityModel> federatedIdentities = getFederatedIdentities(user, realm);\n-        for (FederatedIdentityModel socialLink : federatedIdentities) {\n-            if (socialLink.getIdentityProvider().equals(socialProvider)) {\n-                return socialLink;\n-            }\n-        }\n-        return null;\n+        return getFederatedIdentitiesStream(realm, user)\n+                .filter(socialLink -> Objects.equals(socialLink.getIdentityProvider(), socialProvider))\n+                .findFirst().orElse(null);\n     }\n \n     @Override\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "aa4673517308a2f6b8214b192eb2151554564718", "message": "Merge commit", "committedDate": null}, {"oid": "84df008bc2173df12b6cbfa58047ebc120d1f413", "committedDate": "2020-11-18 21:07:51 +0100", "message": "[KEYCLOAK-16341] Make the new stream-based methods in server-spi user interfaces default instead of the collection-based versions.  - this ensures that providing implementation for the collection-based methods is enough, which preserves    backwards compatibility with older custom implementations.  - alternative interfaces now allow new implementations to focus on the stream variants of the query methods."}, {"oid": "73d0bb34c4d8a6826e538f2a81bef515732a59c9", "committedDate": "2020-12-07 19:48:35 +0100", "message": "[KEYCLOAK-16232] Replace usages of deprecated collection-based methods with the respective stream variants"}, {"oid": "8e376aef51b4b5d7ade4e5196ee628a086c1749a", "committedDate": "2020-12-10 08:57:53 +0100", "message": "KEYCLOAK-15847 Add MapUserProvider"}, {"oid": "ba8e2fef6b0a47727f03d58f4fe2809d6e65c017", "committedDate": "2021-01-18 16:56:10 +0100", "message": "KEYCLOAK-15524 Cleanup user related interfaces"}, {"oid": "703e868a5129c147d723e8c367c7eb962843e280", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Preparation for moving User Storage SPI"}, {"oid": "bc8fd21dc6495b7f43f3466eb3545055753114ae", "committedDate": "2022-06-21 08:53:06 +0200", "message": "SingleUserCredentialManager moving in - UserStorageManager now handles authentication for old Kerberos+LDAP style - new getUserByCredential method in MapUserProvider would eventually do the same."}, {"oid": "14a369a8cc4cb68725472d14d5081516d30ae8b1", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Added LegacySessionSupport SPI"}, {"oid": "f69497eb28ab6c6595a4a335607d03b0c7ba229d", "committedDate": "2022-09-06 10:38:28 +0200", "message": "KEYCLOAK-12988 Deprecate getUsers* methods in favor of searchUsers* variants"}, {"oid": "883e83e62540168593046e34292849e16c009760", "committedDate": "2022-10-25 09:01:33 +0200", "message": "Remove deprecated methods from data providers and models"}, {"oid": "fb554c09dbdc833176f2f7f7aa8d2a43d7ba1286", "committedDate": "2023-01-03 14:28:41 -0800", "message": "Incrementally cache consents on a per client basis"}, {"oid": "81aa588ddc33de94884568aef0f9d46868ad8232", "committedDate": "2023-06-05 18:46:23 +0200", "message": "Fix and correlate session timeout calculations in legacy and new map implementations Closes https://github.com/keycloak/keycloak/issues/14854 Closes https://github.com/keycloak/keycloak/issues/11990"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg1ODQ0NQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511858445", "body": "Couldn't we just return already obtained consents? `consents.stream();`?", "bodyText": "Couldn't we just return already obtained consents? consents.stream();?", "bodyHTML": "<p dir=\"auto\">Couldn't we just return already obtained consents? <code>consents.stream();</code>?</p>", "author": "martin-kanis", "createdAt": "2020-10-26T10:29:14Z", "path": "model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java", "diffHunk": "@@ -708,31 +707,25 @@ public UserConsentModel getConsentByClient(RealmModel realm, String userId, Stri\n     }\n \n     @Override\n-    public List<UserConsentModel> getConsents(RealmModel realm, String userId) {\n+    public Stream<UserConsentModel> getConsentsStream(RealmModel realm, String userId) {\n         logger.tracev(\"getConsents: {0}\", userId);\n \n         String cacheKey = getConsentCacheKey(userId);\n         if (realmInvalidations.contains(realm.getId()) || invalidations.contains(userId) || invalidations.contains(cacheKey)) {\n-            return getDelegate().getConsents(realm, userId);\n+            return getDelegate().getConsentsStream(realm, userId);\n         }\n \n         CachedUserConsents cached = cache.get(cacheKey, CachedUserConsents.class);\n \n         if (cached == null) {\n             Long loaded = cache.getCurrentRevision(cacheKey);\n-            List<UserConsentModel> consents = getDelegate().getConsents(realm, userId);\n+            List<UserConsentModel> consents = getDelegate().getConsentsStream(realm, userId).collect(Collectors.toList());\n             cached = new CachedUserConsents(loaded, cacheKey, realm, consents);\n             cache.addRevisioned(cached, startupRevision);\n-            return consents;\n+            return getDelegate().getConsentsStream(realm, userId);", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "changed_code": [{"header": "diff --git a/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java b/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java\nindex d7657ebd7e..6a0c37e105 100755\n--- a/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java\n+++ b/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java\n", "chunk": "@@ -722,7 +722,7 @@ public class UserCacheSession implements UserCache {\n             List<UserConsentModel> consents = getDelegate().getConsentsStream(realm, userId).collect(Collectors.toList());\n             cached = new CachedUserConsents(loaded, cacheKey, realm, consents);\n             cache.addRevisioned(cached, startupRevision);\n-            return getDelegate().getConsentsStream(realm, userId);\n+            return consents.stream();\n         } else {\n             return cached.getConsents().values().stream().map(cachedConsent -> toConsentModel(realm, cachedConsent))\n                     .filter(Objects::nonNull);\n", "next_change": null}]}, "revised_code_in_main": {"commit": "aa4673517308a2f6b8214b192eb2151554564718", "changed_code": [{"header": "diff --git a/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java b/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java\nindex d7657ebd7e..6a0c37e105 100755\n--- a/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java\n+++ b/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java\n", "chunk": "@@ -722,7 +722,7 @@ public class UserCacheSession implements UserCache {\n             List<UserConsentModel> consents = getDelegate().getConsentsStream(realm, userId).collect(Collectors.toList());\n             cached = new CachedUserConsents(loaded, cacheKey, realm, consents);\n             cache.addRevisioned(cached, startupRevision);\n-            return getDelegate().getConsentsStream(realm, userId);\n+            return consents.stream();\n         } else {\n             return cached.getConsents().values().stream().map(cachedConsent -> toConsentModel(realm, cachedConsent))\n                     .filter(Objects::nonNull);\n", "next_change": {"commit": "fb554c09dbdc833176f2f7f7aa8d2a43d7ba1286", "changed_code": [{"header": "diff --git a/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java b/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java\nindex 6a0c37e105..ea1dd01d5e 100755\n--- a/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java\n+++ b/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java\n", "chunk": "@@ -717,10 +725,15 @@ public class UserCacheSession implements UserCache {\n \n         CachedUserConsents cached = cache.get(cacheKey, CachedUserConsents.class);\n \n+        if (cached != null && !cached.isAllConsents()) {\n+            cached = null;\n+            cache.invalidateObject(cacheKey);\n+        }\n+\n         if (cached == null) {\n             Long loaded = cache.getCurrentRevision(cacheKey);\n             List<UserConsentModel> consents = getDelegate().getConsentsStream(realm, userId).collect(Collectors.toList());\n-            cached = new CachedUserConsents(loaded, cacheKey, realm, consents);\n+            cached = new CachedUserConsents(loaded, cacheKey, realm, consents.stream().map(CachedUserConsent::new).collect(Collectors.toList()));\n             cache.addRevisioned(cached, startupRevision);\n             return consents.stream();\n         } else {\n", "next_change": null}, {"header": "diff --git a/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java b/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java\nindex 6a0c37e105..ea1dd01d5e 100755\n--- a/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java\n+++ b/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java\n", "chunk": "@@ -730,6 +743,10 @@ public class UserCacheSession implements UserCache {\n     }\n \n     private UserConsentModel toConsentModel(RealmModel realm, CachedUserConsent cachedConsent) {\n+        if (cachedConsent.isNotExistent()) {\n+            return null;\n+        }\n+\n         ClientModel client = session.clients().getClientById(realm, cachedConsent.getClientDbId());\n         if (client == null) {\n             return null;\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "aa4673517308a2f6b8214b192eb2151554564718", "message": "Merge commit", "committedDate": null}, {"oid": "84df008bc2173df12b6cbfa58047ebc120d1f413", "committedDate": "2020-11-18 21:07:51 +0100", "message": "[KEYCLOAK-16341] Make the new stream-based methods in server-spi user interfaces default instead of the collection-based versions.  - this ensures that providing implementation for the collection-based methods is enough, which preserves    backwards compatibility with older custom implementations.  - alternative interfaces now allow new implementations to focus on the stream variants of the query methods."}, {"oid": "73d0bb34c4d8a6826e538f2a81bef515732a59c9", "committedDate": "2020-12-07 19:48:35 +0100", "message": "[KEYCLOAK-16232] Replace usages of deprecated collection-based methods with the respective stream variants"}, {"oid": "8e376aef51b4b5d7ade4e5196ee628a086c1749a", "committedDate": "2020-12-10 08:57:53 +0100", "message": "KEYCLOAK-15847 Add MapUserProvider"}, {"oid": "ba8e2fef6b0a47727f03d58f4fe2809d6e65c017", "committedDate": "2021-01-18 16:56:10 +0100", "message": "KEYCLOAK-15524 Cleanup user related interfaces"}, {"oid": "703e868a5129c147d723e8c367c7eb962843e280", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Preparation for moving User Storage SPI"}, {"oid": "bc8fd21dc6495b7f43f3466eb3545055753114ae", "committedDate": "2022-06-21 08:53:06 +0200", "message": "SingleUserCredentialManager moving in - UserStorageManager now handles authentication for old Kerberos+LDAP style - new getUserByCredential method in MapUserProvider would eventually do the same."}, {"oid": "14a369a8cc4cb68725472d14d5081516d30ae8b1", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Added LegacySessionSupport SPI"}, {"oid": "f69497eb28ab6c6595a4a335607d03b0c7ba229d", "committedDate": "2022-09-06 10:38:28 +0200", "message": "KEYCLOAK-12988 Deprecate getUsers* methods in favor of searchUsers* variants"}, {"oid": "883e83e62540168593046e34292849e16c009760", "committedDate": "2022-10-25 09:01:33 +0200", "message": "Remove deprecated methods from data providers and models"}, {"oid": "fb554c09dbdc833176f2f7f7aa8d2a43d7ba1286", "committedDate": "2023-01-03 14:28:41 -0800", "message": "Incrementally cache consents on a per client basis"}, {"oid": "81aa588ddc33de94884568aef0f9d46868ad8232", "committedDate": "2023-06-05 18:46:23 +0200", "message": "Fix and correlate session timeout calculations in legacy and new map implementations Closes https://github.com/keycloak/keycloak/issues/14854 Closes https://github.com/keycloak/keycloak/issues/11990"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg2MTcxOA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511861718", "body": "I know you didn't introduce this star import but maybe it's right time to fix it now :)", "bodyText": "I know you didn't introduce this star import but maybe it's right time to fix it now :)", "bodyHTML": "<p dir=\"auto\">I know you didn't introduce this star import but maybe it's right time to fix it now :)</p>", "author": "martin-kanis", "createdAt": "2020-10-26T10:34:37Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java", "diffHunk": "@@ -59,8 +59,13 @@\n import javax.persistence.criteria.Subquery;\n import java.util.*;", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk5ODI5Mw==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511998293", "bodyText": "Hahaha, good catch. Will change it :D", "author": "sguilhen", "createdAt": "2020-10-26T14:23:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg2MTcxOA=="}], "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "changed_code": [{"header": "diff --git a/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java b/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java\nindex da111a9ec3..050355e4b7 100755\n--- a/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java\n+++ b/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java\n", "chunk": "@@ -54,10 +54,21 @@ import javax.persistence.TypedQuery;\n import javax.persistence.criteria.CriteriaBuilder;\n import javax.persistence.criteria.CriteriaQuery;\n import javax.persistence.criteria.Expression;\n+import javax.persistence.criteria.Join;\n import javax.persistence.criteria.Predicate;\n import javax.persistence.criteria.Root;\n import javax.persistence.criteria.Subquery;\n-import java.util.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "aa4673517308a2f6b8214b192eb2151554564718", "changed_code": [{"header": "diff --git a/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java b/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java\nindex da111a9ec3..348009b9d9 100755\n--- a/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java\n+++ b/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java\n", "chunk": "@@ -54,10 +54,21 @@ import javax.persistence.TypedQuery;\n import javax.persistence.criteria.CriteriaBuilder;\n import javax.persistence.criteria.CriteriaQuery;\n import javax.persistence.criteria.Expression;\n+import javax.persistence.criteria.Join;\n import javax.persistence.criteria.Predicate;\n import javax.persistence.criteria.Root;\n import javax.persistence.criteria.Subquery;\n-import java.util.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n", "next_change": {"commit": "edef93cd491e545de642fd39d0df0a53cecee830", "changed_code": [{"header": "diff --git a/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java b/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java\nindex 348009b9d9..b46d7d63c8 100755\n--- a/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java\n+++ b/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java\n", "chunk": "@@ -64,12 +64,10 @@ import java.util.Collection;\n import java.util.Comparator;\n import java.util.HashMap;\n import java.util.HashSet;\n-import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n-import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n import javax.persistence.LockModeType;\n", "next_change": {"commit": "ba8e2fef6b0a47727f03d58f4fe2809d6e65c017", "changed_code": [{"header": "diff --git a/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java b/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java\nindex b46d7d63c8..1f90a7e26f 100755\n--- a/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java\n+++ b/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java\n", "chunk": "@@ -66,12 +65,12 @@ import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n-import java.util.Optional;\n import java.util.Set;\n import java.util.stream.Stream;\n \n import javax.persistence.LockModeType;\n \n+import static org.keycloak.models.jpa.PaginationUtils.paginateQuery;\n import static org.keycloak.utils.StreamsUtil.closing;\n \n \n", "next_change": {"commit": "5b0986e490090433658e9a1e607c0e248f4cc756", "changed_code": [{"header": "diff --git a/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java b/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java\nindex 1f90a7e26f..2e164222cb 100755\n--- a/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java\n+++ b/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java\n", "chunk": "@@ -68,8 +70,6 @@ import java.util.Map;\n import java.util.Set;\n import java.util.stream.Stream;\n \n-import javax.persistence.LockModeType;\n-\n import static org.keycloak.models.jpa.PaginationUtils.paginateQuery;\n import static org.keycloak.utils.StreamsUtil.closing;\n \n", "next_change": {"commit": "f69497eb28ab6c6595a4a335607d03b0c7ba229d", "changed_code": [{"header": "diff --git a/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java b/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java\nindex 2e164222cb..f604d84f4d 100755\n--- a/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java\n+++ b/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java\n", "chunk": "@@ -67,6 +68,7 @@ import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.Set;\n import java.util.stream.Stream;\n \n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "aa4673517308a2f6b8214b192eb2151554564718", "message": "Merge commit", "committedDate": null}, {"oid": "84df008bc2173df12b6cbfa58047ebc120d1f413", "committedDate": "2020-11-18 21:07:51 +0100", "message": "[KEYCLOAK-16341] Make the new stream-based methods in server-spi user interfaces default instead of the collection-based versions.  - this ensures that providing implementation for the collection-based methods is enough, which preserves    backwards compatibility with older custom implementations.  - alternative interfaces now allow new implementations to focus on the stream variants of the query methods."}, {"oid": "edef93cd491e545de642fd39d0df0a53cecee830", "committedDate": "2020-12-07 19:48:35 +0100", "message": "[KEYCLOAK-16232] Streamify the UserCredentialStore and UserCredentialManager interfaces"}, {"oid": "8e376aef51b4b5d7ade4e5196ee628a086c1749a", "committedDate": "2020-12-10 08:57:53 +0100", "message": "KEYCLOAK-15847 Add MapUserProvider"}, {"oid": "1402d021deb014310027ba506e6cfa7686b315b4", "committedDate": "2021-01-08 13:55:48 +0100", "message": "KEYCLOAK-14846 Default roles processing"}, {"oid": "ba8e2fef6b0a47727f03d58f4fe2809d6e65c017", "committedDate": "2021-01-18 16:56:10 +0100", "message": "KEYCLOAK-15524 Cleanup user related interfaces"}, {"oid": "5b0986e490090433658e9a1e607c0e248f4cc756", "committedDate": "2021-10-12 13:08:47 +0200", "message": "[KEYCLOAK-18891] Add support for searching users by custom user attributes"}, {"oid": "9621d513b59b9425ebd8e7ad0a775e602c9060ac", "committedDate": "2022-01-26 17:03:05 +0100", "message": "KEYCLOAK-18727 Improve user search query"}, {"oid": "722ce950bfa477008016b148a07d20568a364b6b", "committedDate": "2022-03-04 14:15:14 +0100", "message": "Improve user search performance"}, {"oid": "ad865e75c14f048e2de6748bab6af6c3b495de33", "committedDate": "2022-03-11 12:21:52 -0300", "message": "Change the flush mode to auto and fixing how entities are checked if they are loaded in the EM"}, {"oid": "820ab52dce148eae0d51ba194ba9248bf83a69c6", "committedDate": "2022-04-13 13:57:22 -0300", "message": "Add support for filtering by enabled attribute on users count endpoint (#9842)"}, {"oid": "f69497eb28ab6c6595a4a335607d03b0c7ba229d", "committedDate": "2022-09-06 10:38:28 +0200", "message": "KEYCLOAK-12988 Deprecate getUsers* methods in favor of searchUsers* variants"}, {"oid": "3af1134975f8cb93264035fb64edce953e2e7bbf", "committedDate": "2022-09-14 08:02:17 -0300", "message": "Update IDP link username when sync mode is \"force\""}, {"oid": "883e83e62540168593046e34292849e16c009760", "committedDate": "2022-10-25 09:01:33 +0200", "message": "Remove deprecated methods from data providers and models"}, {"oid": "bd0a23a865493f5ded151d9a5936e2dd7d67d2d9", "committedDate": "2023-03-24 13:43:47 +0100", "message": "/users/count endpoint with search field has different behavior than /users query endpoint #17620 closes #17620"}, {"oid": "7cff8572387e6bbfca160aa60e9a8191d22e5c85", "committedDate": "2023-04-27 13:36:54 +0200", "message": "Migrate packages from javax.* to jakarta.*"}, {"oid": "ad82252a443c258d962a5c521e3f5936e50c65b0", "committedDate": "2023-04-27 13:36:54 +0200", "message": "Create workaround for \"identifier of an instance altered\""}, {"oid": "a10d511b1202c2e548dfdb0f93142eac15d0f6ec", "committedDate": "2023-05-02 13:43:49 +0200", "message": "Remove workaround for fix available in Hibernate 6.2.1"}, {"oid": "d1ab921c50ad1ffe3a8d1970fae3abab2668a619", "committedDate": "2023-05-05 08:22:05 +0200", "message": "JpaUserProvider count methods are inconsistent with searchForUser's param filter handling"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg4OTY2NQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511889665", "body": "Missing closing of the stream.", "bodyText": "Missing closing of the stream.", "bodyHTML": "<p dir=\"auto\">Missing closing of the stream.</p>", "author": "martin-kanis", "createdAt": "2020-10-26T11:25:13Z", "path": "model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java", "diffHunk": "@@ -164,12 +163,12 @@ public void removeAttribute(RealmModel realm, String userId, String name) {\n     }\n \n     @Override\n-    public List<String> getUsersByUserAttribute(RealmModel realm, String name, String value) {\n+    public Stream<String> getUsersByUserAttributeStream(RealmModel realm, String name, String value) {\n         TypedQuery<String> query = em.createNamedQuery(\"getFederatedAttributesByNameAndValue\", String.class)\n                 .setParameter(\"realmId\", realm.getId())\n                 .setParameter(\"name\", name)\n                 .setParameter(\"value\", value);\n-        return query.getResultList();\n+        return query.getResultStream();", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk5ODUwNQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511998505", "bodyText": "Nice catch, thanks", "author": "sguilhen", "createdAt": "2020-10-26T14:23:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg4OTY2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "changed_code": [{"header": "diff --git a/model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java b/model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java\nindex 9696283532..ee4c4f5ca3 100644\n--- a/model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java\n+++ b/model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java\n", "chunk": "@@ -168,7 +168,7 @@ public class JpaUserFederatedStorageProvider implements\n                 .setParameter(\"realmId\", realm.getId())\n                 .setParameter(\"name\", name)\n                 .setParameter(\"value\", value);\n-        return query.getResultStream();\n+        return closing(query.getResultStream());\n     }\n \n     @Override\n", "next_change": null}]}, "revised_code_in_main": {"commit": "aa4673517308a2f6b8214b192eb2151554564718", "changed_code": [{"header": "diff --git a/model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java b/model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java\nindex 9696283532..ee4c4f5ca3 100644\n--- a/model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java\n+++ b/model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java\n", "chunk": "@@ -168,7 +168,7 @@ public class JpaUserFederatedStorageProvider implements\n                 .setParameter(\"realmId\", realm.getId())\n                 .setParameter(\"name\", name)\n                 .setParameter(\"value\", value);\n-        return query.getResultStream();\n+        return closing(query.getResultStream());\n     }\n \n     @Override\n", "next_change": null}]}, "commits_in_main": [{"oid": "aa4673517308a2f6b8214b192eb2151554564718", "message": "Merge commit", "committedDate": null}, {"oid": "84df008bc2173df12b6cbfa58047ebc120d1f413", "committedDate": "2020-11-18 21:07:51 +0100", "message": "[KEYCLOAK-16341] Make the new stream-based methods in server-spi user interfaces default instead of the collection-based versions.  - this ensures that providing implementation for the collection-based methods is enough, which preserves    backwards compatibility with older custom implementations.  - alternative interfaces now allow new implementations to focus on the stream variants of the query methods."}, {"oid": "73d0bb34c4d8a6826e538f2a81bef515732a59c9", "committedDate": "2020-12-07 19:48:35 +0100", "message": "[KEYCLOAK-16232] Replace usages of deprecated collection-based methods with the respective stream variants"}, {"oid": "edef93cd491e545de642fd39d0df0a53cecee830", "committedDate": "2020-12-07 19:48:35 +0100", "message": "[KEYCLOAK-16232] Streamify the UserCredentialStore and UserCredentialManager interfaces"}, {"oid": "9f580e3ed868223a7d5c3d59481e5f9535a9e163", "committedDate": "2021-01-20 14:39:53 +0100", "message": "KEYCLOAK-15695 Streamification cleanup"}, {"oid": "af0d97e534768424a6153cc5c9904240e478f8b4", "committedDate": "2022-08-25 08:24:09 +0200", "message": "Delete broker links for federated users when an identity provider is deleted"}, {"oid": "883e83e62540168593046e34292849e16c009760", "committedDate": "2022-10-25 09:01:33 +0200", "message": "Remove deprecated methods from data providers and models"}, {"oid": "7cff8572387e6bbfca160aa60e9a8191d22e5c85", "committedDate": "2023-04-27 13:36:54 +0200", "message": "Migrate packages from javax.* to jakarta.*"}, {"oid": "ed473da22b713d599865b4779445dc843258505b", "committedDate": "2023-06-09 17:11:20 +0000", "message": "Clean-up of deprecated methods and interfaces"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5MTk4Mw==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511891983", "body": "Maybe also use `distinct()` here. ", "bodyText": "Maybe also use distinct() here.", "bodyHTML": "<p dir=\"auto\">Maybe also use <code>distinct()</code> here.</p>", "author": "martin-kanis", "createdAt": "2020-10-26T11:29:45Z", "path": "model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java", "diffHunk": "@@ -489,28 +476,21 @@ public void leaveGroup(RealmModel realm, String userId, GroupModel group) {\n         if (max != -1) {\n             query.setMaxResults(max);\n         }\n-\n-        return query.getResultList();\n+        return closing(query.getResultStream());\n     }\n \n     @Override\n-    public Set<String> getRequiredActions(RealmModel realm, String userId) {\n-        Set<String> set = new HashSet<>();\n-        List<FederatedUserRequiredActionEntity> values = getRequiredActionEntities(realm, userId, LockModeType.NONE);\n-        for (FederatedUserRequiredActionEntity entity : values) {\n-            set.add(entity.getAction());\n-        }\n-\n-        return set;\n-\n+    public Stream<String> getRequiredActionsStream(RealmModel realm, String userId) {\n+        return this.getRequiredActionEntitiesStream(realm, userId, LockModeType.NONE).\n+                map(FederatedUserRequiredActionEntity::getAction);", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAwMzk2NA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r512003964", "bodyText": "Yeah, definitely.", "author": "sguilhen", "createdAt": "2020-10-26T14:30:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5MTk4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "changed_code": [{"header": "diff --git a/model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java b/model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java\nindex 9696283532..ee4c4f5ca3 100644\n--- a/model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java\n+++ b/model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java\n", "chunk": "@@ -482,7 +482,7 @@ public class JpaUserFederatedStorageProvider implements\n     @Override\n     public Stream<String> getRequiredActionsStream(RealmModel realm, String userId) {\n         return this.getRequiredActionEntitiesStream(realm, userId, LockModeType.NONE).\n-                map(FederatedUserRequiredActionEntity::getAction);\n+                map(FederatedUserRequiredActionEntity::getAction).distinct();\n     }\n \n     private Stream<FederatedUserRequiredActionEntity> getRequiredActionEntitiesStream(RealmModel realm, String userId, LockModeType lockMode) {\n", "next_change": null}]}, "revised_code_in_main": {"commit": "aa4673517308a2f6b8214b192eb2151554564718", "changed_code": [{"header": "diff --git a/model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java b/model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java\nindex 9696283532..ee4c4f5ca3 100644\n--- a/model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java\n+++ b/model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java\n", "chunk": "@@ -482,7 +482,7 @@ public class JpaUserFederatedStorageProvider implements\n     @Override\n     public Stream<String> getRequiredActionsStream(RealmModel realm, String userId) {\n         return this.getRequiredActionEntitiesStream(realm, userId, LockModeType.NONE).\n-                map(FederatedUserRequiredActionEntity::getAction);\n+                map(FederatedUserRequiredActionEntity::getAction).distinct();\n     }\n \n     private Stream<FederatedUserRequiredActionEntity> getRequiredActionEntitiesStream(RealmModel realm, String userId, LockModeType lockMode) {\n", "next_change": null}]}, "commits_in_main": [{"oid": "aa4673517308a2f6b8214b192eb2151554564718", "message": "Merge commit", "committedDate": null}, {"oid": "84df008bc2173df12b6cbfa58047ebc120d1f413", "committedDate": "2020-11-18 21:07:51 +0100", "message": "[KEYCLOAK-16341] Make the new stream-based methods in server-spi user interfaces default instead of the collection-based versions.  - this ensures that providing implementation for the collection-based methods is enough, which preserves    backwards compatibility with older custom implementations.  - alternative interfaces now allow new implementations to focus on the stream variants of the query methods."}, {"oid": "73d0bb34c4d8a6826e538f2a81bef515732a59c9", "committedDate": "2020-12-07 19:48:35 +0100", "message": "[KEYCLOAK-16232] Replace usages of deprecated collection-based methods with the respective stream variants"}, {"oid": "edef93cd491e545de642fd39d0df0a53cecee830", "committedDate": "2020-12-07 19:48:35 +0100", "message": "[KEYCLOAK-16232] Streamify the UserCredentialStore and UserCredentialManager interfaces"}, {"oid": "9f580e3ed868223a7d5c3d59481e5f9535a9e163", "committedDate": "2021-01-20 14:39:53 +0100", "message": "KEYCLOAK-15695 Streamification cleanup"}, {"oid": "af0d97e534768424a6153cc5c9904240e478f8b4", "committedDate": "2022-08-25 08:24:09 +0200", "message": "Delete broker links for federated users when an identity provider is deleted"}, {"oid": "883e83e62540168593046e34292849e16c009760", "committedDate": "2022-10-25 09:01:33 +0200", "message": "Remove deprecated methods from data providers and models"}, {"oid": "7cff8572387e6bbfca160aa60e9a8191d22e5c85", "committedDate": "2023-04-27 13:36:54 +0200", "message": "Migrate packages from javax.* to jakarta.*"}, {"oid": "ed473da22b713d599865b4779445dc843258505b", "committedDate": "2023-06-09 17:11:20 +0000", "message": "Clean-up of deprecated methods and interfaces"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5NjI2MA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511896260", "body": "You kept the original deprecated method on purpose?", "bodyText": "You kept the original deprecated method on purpose?", "bodyHTML": "<p dir=\"auto\">You kept the original deprecated method on purpose?</p>", "author": "martin-kanis", "createdAt": "2020-10-26T11:38:22Z", "path": "server-spi-private/src/main/java/org/keycloak/storage/adapter/InMemoryUserAdapter.java", "diffHunk": "@@ -160,6 +160,11 @@ public String getFirstAttribute(String name) {\n         return value;\n     }\n \n+    @Override", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA3OTQxNg==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r512079416", "bodyText": "No, that was definitely a brain fart :)", "author": "sguilhen", "createdAt": "2020-10-26T16:05:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5NjI2MA=="}], "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "changed_code": [{"header": "diff --git a/server-spi-private/src/main/java/org/keycloak/storage/adapter/InMemoryUserAdapter.java b/server-spi-private/src/main/java/org/keycloak/storage/adapter/InMemoryUserAdapter.java\nindex b2dae45f12..0d1471e5a2 100644\n--- a/server-spi-private/src/main/java/org/keycloak/storage/adapter/InMemoryUserAdapter.java\n+++ b/server-spi-private/src/main/java/org/keycloak/storage/adapter/InMemoryUserAdapter.java\n", "chunk": "@@ -151,18 +151,10 @@ public class InMemoryUserAdapter extends UserModelDefaultMethods {\n         return attributes.getFirst(name);\n     }\n \n-    @Override\n-    public List<String> getAttribute(String name) {\n-        List<String> value = attributes.get(name);\n-        if (value == null) {\n-            return new LinkedList<>();\n-        }\n-        return value;\n-    }\n-\n     @Override\n     public Stream<String> getAttributeStream(String name) {\n-        return this.getAttribute(name).stream();\n+        List<String> value = this.attributes.get(name);\n+        return value != null ? value.stream() : Stream.empty();\n     }\n \n     @Override\n", "next_change": null}]}, "revised_code_in_main": {"commit": "aa4673517308a2f6b8214b192eb2151554564718", "changed_code": [{"header": "diff --git a/server-spi-private/src/main/java/org/keycloak/storage/adapter/InMemoryUserAdapter.java b/server-spi-private/src/main/java/org/keycloak/storage/adapter/InMemoryUserAdapter.java\nindex b2dae45f12..0d1471e5a2 100644\n--- a/server-spi-private/src/main/java/org/keycloak/storage/adapter/InMemoryUserAdapter.java\n+++ b/server-spi-private/src/main/java/org/keycloak/storage/adapter/InMemoryUserAdapter.java\n", "chunk": "@@ -151,18 +151,10 @@ public class InMemoryUserAdapter extends UserModelDefaultMethods {\n         return attributes.getFirst(name);\n     }\n \n-    @Override\n-    public List<String> getAttribute(String name) {\n-        List<String> value = attributes.get(name);\n-        if (value == null) {\n-            return new LinkedList<>();\n-        }\n-        return value;\n-    }\n-\n     @Override\n     public Stream<String> getAttributeStream(String name) {\n-        return this.getAttribute(name).stream();\n+        List<String> value = this.attributes.get(name);\n+        return value != null ? value.stream() : Stream.empty();\n     }\n \n     @Override\n", "next_change": null}]}, "commits_in_main": [{"oid": "aa4673517308a2f6b8214b192eb2151554564718", "message": "Merge commit", "committedDate": null}, {"oid": "84df008bc2173df12b6cbfa58047ebc120d1f413", "committedDate": "2020-11-18 21:07:51 +0100", "message": "[KEYCLOAK-16341] Make the new stream-based methods in server-spi user interfaces default instead of the collection-based versions.  - this ensures that providing implementation for the collection-based methods is enough, which preserves    backwards compatibility with older custom implementations.  - alternative interfaces now allow new implementations to focus on the stream variants of the query methods."}, {"oid": "1402d021deb014310027ba506e6cfa7686b315b4", "committedDate": "2021-01-08 13:55:48 +0100", "message": "KEYCLOAK-14846 Default roles processing"}, {"oid": "bc8fd21dc6495b7f43f3466eb3545055753114ae", "committedDate": "2022-06-21 08:53:06 +0200", "message": "SingleUserCredentialManager moving in - UserStorageManager now handles authentication for old Kerberos+LDAP style - new getUserByCredential method in MapUserProvider would eventually do the same."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5NjM2MA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511896360", "body": "Same as above", "bodyText": "Same as above", "bodyHTML": "<p dir=\"auto\">Same as above</p>", "author": "martin-kanis", "createdAt": "2020-10-26T11:38:33Z", "path": "server-spi-private/src/main/java/org/keycloak/storage/adapter/InMemoryUserAdapter.java", "diffHunk": "@@ -170,6 +175,11 @@ public String getFirstAttribute(String name) {\n         return requiredActions;\n     }\n \n+    @Override", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "changed_code": [{"header": "diff --git a/server-spi-private/src/main/java/org/keycloak/storage/adapter/InMemoryUserAdapter.java b/server-spi-private/src/main/java/org/keycloak/storage/adapter/InMemoryUserAdapter.java\nindex b2dae45f12..0d1471e5a2 100644\n--- a/server-spi-private/src/main/java/org/keycloak/storage/adapter/InMemoryUserAdapter.java\n+++ b/server-spi-private/src/main/java/org/keycloak/storage/adapter/InMemoryUserAdapter.java\n", "chunk": "@@ -170,14 +162,9 @@ public class InMemoryUserAdapter extends UserModelDefaultMethods {\n         return attributes;\n     }\n \n-    @Override\n-    public Set<String> getRequiredActions() {\n-        return requiredActions;\n-    }\n-\n     @Override\n     public Stream<String> getRequiredActionsStream() {\n-        return this.getRequiredActions().stream();\n+        return this.requiredActions.stream();\n     }\n \n     @Override\n", "next_change": null}]}, "revised_code_in_main": {"commit": "aa4673517308a2f6b8214b192eb2151554564718", "changed_code": [{"header": "diff --git a/server-spi-private/src/main/java/org/keycloak/storage/adapter/InMemoryUserAdapter.java b/server-spi-private/src/main/java/org/keycloak/storage/adapter/InMemoryUserAdapter.java\nindex b2dae45f12..0d1471e5a2 100644\n--- a/server-spi-private/src/main/java/org/keycloak/storage/adapter/InMemoryUserAdapter.java\n+++ b/server-spi-private/src/main/java/org/keycloak/storage/adapter/InMemoryUserAdapter.java\n", "chunk": "@@ -170,14 +162,9 @@ public class InMemoryUserAdapter extends UserModelDefaultMethods {\n         return attributes;\n     }\n \n-    @Override\n-    public Set<String> getRequiredActions() {\n-        return requiredActions;\n-    }\n-\n     @Override\n     public Stream<String> getRequiredActionsStream() {\n-        return this.getRequiredActions().stream();\n+        return this.requiredActions.stream();\n     }\n \n     @Override\n", "next_change": null}]}, "commits_in_main": [{"oid": "aa4673517308a2f6b8214b192eb2151554564718", "message": "Merge commit", "committedDate": null}, {"oid": "84df008bc2173df12b6cbfa58047ebc120d1f413", "committedDate": "2020-11-18 21:07:51 +0100", "message": "[KEYCLOAK-16341] Make the new stream-based methods in server-spi user interfaces default instead of the collection-based versions.  - this ensures that providing implementation for the collection-based methods is enough, which preserves    backwards compatibility with older custom implementations.  - alternative interfaces now allow new implementations to focus on the stream variants of the query methods."}, {"oid": "1402d021deb014310027ba506e6cfa7686b315b4", "committedDate": "2021-01-08 13:55:48 +0100", "message": "KEYCLOAK-14846 Default roles processing"}, {"oid": "bc8fd21dc6495b7f43f3466eb3545055753114ae", "committedDate": "2022-06-21 08:53:06 +0200", "message": "SingleUserCredentialManager moving in - UserStorageManager now handles authentication for old Kerberos+LDAP style - new getUserByCredential method in MapUserProvider would eventually do the same."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5OTM1Mw==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511899353", "body": "Missing Javadoc.", "bodyText": "Missing Javadoc.", "bodyHTML": "<p dir=\"auto\">Missing Javadoc.</p>", "author": "martin-kanis", "createdAt": "2020-10-26T11:44:16Z", "path": "server-spi/src/main/java/org/keycloak/storage/federated/UserGroupMembershipFederatedStorage.java", "diffHunk": "@@ -38,6 +38,15 @@\n \n     void joinGroup(RealmModel realm, String userId, GroupModel group);\n     void leaveGroup(RealmModel realm, String userId, GroupModel group);\n-    List<String> getMembership(RealmModel realm, GroupModel group, int firstResult, int max);\n+\n+    /**\n+     * @deprecated Use {@link #getMembershipStream(RealmModel, GroupModel, int, int) getMembershipStream} instead.\n+     */\n+    @Deprecated\n+    default List<String> getMembership(RealmModel realm, GroupModel group, int firstResult, int max) {\n+        return this.getMembershipStream(realm, group, firstResult, max).collect(Collectors.toList());\n+    }\n+\n+    Stream<String> getMembershipStream(RealmModel realm, GroupModel group, int firstResult, int max);", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "changed_code": [{"header": "diff --git a/server-spi/src/main/java/org/keycloak/storage/federated/UserGroupMembershipFederatedStorage.java b/server-spi/src/main/java/org/keycloak/storage/federated/UserGroupMembershipFederatedStorage.java\nindex 1a86551614..aad956d471 100644\n--- a/server-spi/src/main/java/org/keycloak/storage/federated/UserGroupMembershipFederatedStorage.java\n+++ b/server-spi/src/main/java/org/keycloak/storage/federated/UserGroupMembershipFederatedStorage.java\n", "chunk": "@@ -47,6 +47,15 @@ public interface UserGroupMembershipFederatedStorage {\n         return this.getMembershipStream(realm, group, firstResult, max).collect(Collectors.toList());\n     }\n \n+    /**\n+     * Obtains the federated users that are members of the given {@code group} in the specified {@code realm}.\n+     *\n+     * @param realm a reference to the realm.\n+     * @param group a reference to the group whose federated members are being searched.\n+     * @param firstResult first result to return. Ignored if negative.\n+     * @param max maximum number of results to return. Ignored if negative.\n+     * @return a non-null {@code Stream} of federated user ids that are members of the group in the realm.\n+     */\n     Stream<String> getMembershipStream(RealmModel realm, GroupModel group, int firstResult, int max);\n \n }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "aa4673517308a2f6b8214b192eb2151554564718", "changed_code": [{"header": "diff --git a/server-spi/src/main/java/org/keycloak/storage/federated/UserGroupMembershipFederatedStorage.java b/server-spi/src/main/java/org/keycloak/storage/federated/UserGroupMembershipFederatedStorage.java\nindex 1a86551614..aad956d471 100644\n--- a/server-spi/src/main/java/org/keycloak/storage/federated/UserGroupMembershipFederatedStorage.java\n+++ b/server-spi/src/main/java/org/keycloak/storage/federated/UserGroupMembershipFederatedStorage.java\n", "chunk": "@@ -47,6 +47,15 @@ public interface UserGroupMembershipFederatedStorage {\n         return this.getMembershipStream(realm, group, firstResult, max).collect(Collectors.toList());\n     }\n \n+    /**\n+     * Obtains the federated users that are members of the given {@code group} in the specified {@code realm}.\n+     *\n+     * @param realm a reference to the realm.\n+     * @param group a reference to the group whose federated members are being searched.\n+     * @param firstResult first result to return. Ignored if negative.\n+     * @param max maximum number of results to return. Ignored if negative.\n+     * @return a non-null {@code Stream} of federated user ids that are members of the group in the realm.\n+     */\n     Stream<String> getMembershipStream(RealmModel realm, GroupModel group, int firstResult, int max);\n \n }\n", "next_change": {"commit": "84df008bc2173df12b6cbfa58047ebc120d1f413", "changed_code": [{"header": "diff --git a/server-spi/src/main/java/org/keycloak/storage/federated/UserGroupMembershipFederatedStorage.java b/server-spi/src/main/java/org/keycloak/storage/federated/UserGroupMembershipFederatedStorage.java\nindex aad956d471..0933ad2447 100644\n--- a/server-spi/src/main/java/org/keycloak/storage/federated/UserGroupMembershipFederatedStorage.java\n+++ b/server-spi/src/main/java/org/keycloak/storage/federated/UserGroupMembershipFederatedStorage.java\n", "chunk": "@@ -56,6 +66,34 @@ public interface UserGroupMembershipFederatedStorage {\n      * @param max maximum number of results to return. Ignored if negative.\n      * @return a non-null {@code Stream} of federated user ids that are members of the group in the realm.\n      */\n-    Stream<String> getMembershipStream(RealmModel realm, GroupModel group, int firstResult, int max);\n+    default Stream<String> getMembershipStream(RealmModel realm, GroupModel group, int firstResult, int max) {\n+        List<String> value = this.getMembership(realm, group, firstResult, max);\n+        return value != null ? value.stream() : Stream.empty();\n+    }\n+\n+    /**\n+     * The {@link Streams} interface makes all collection-based methods in {@link UserGroupMembershipFederatedStorage}\n+     * default by providing implementations that delegate to the {@link Stream}-based variants instead of the other way\n+     * around.\n+     * <p/>\n+     * It allows for implementations to focus on the {@link Stream}-based approach for processing sets of data and benefit\n+     * from the potential memory and performance optimizations of that approach.\n+     */\n+    interface Streams extends UserGroupMembershipFederatedStorage {\n+        @Override\n+        default Set<GroupModel> getGroups(RealmModel realm, String userId) {\n+            return getGroupsStream(realm, userId).collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        Stream<GroupModel> getGroupsStream(RealmModel realm, String userId);\n \n+        @Override\n+        default List<String> getMembership(RealmModel realm, GroupModel group, int firstResult, int max) {\n+            return this.getMembershipStream(realm, group, firstResult, max).collect(Collectors.toList());\n+        }\n+\n+        @Override\n+        Stream<String> getMembershipStream(RealmModel realm, GroupModel group, int firstResult, int max);\n+    }\n }\n", "next_change": {"commit": "9f580e3ed868223a7d5c3d59481e5f9535a9e163", "changed_code": [{"header": "diff --git a/server-spi/src/main/java/org/keycloak/storage/federated/UserGroupMembershipFederatedStorage.java b/server-spi/src/main/java/org/keycloak/storage/federated/UserGroupMembershipFederatedStorage.java\nindex 0933ad2447..46189304a7 100644\n--- a/server-spi/src/main/java/org/keycloak/storage/federated/UserGroupMembershipFederatedStorage.java\n+++ b/server-spi/src/main/java/org/keycloak/storage/federated/UserGroupMembershipFederatedStorage.java\n", "chunk": "@@ -94,6 +94,6 @@ public interface UserGroupMembershipFederatedStorage {\n         }\n \n         @Override\n-        Stream<String> getMembershipStream(RealmModel realm, GroupModel group, int firstResult, int max);\n+        Stream<String> getMembershipStream(RealmModel realm, GroupModel group, Integer firstResult, Integer max);\n     }\n }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "aa4673517308a2f6b8214b192eb2151554564718", "message": "Merge commit", "committedDate": null}, {"oid": "84df008bc2173df12b6cbfa58047ebc120d1f413", "committedDate": "2020-11-18 21:07:51 +0100", "message": "[KEYCLOAK-16341] Make the new stream-based methods in server-spi user interfaces default instead of the collection-based versions.  - this ensures that providing implementation for the collection-based methods is enough, which preserves    backwards compatibility with older custom implementations.  - alternative interfaces now allow new implementations to focus on the stream variants of the query methods."}, {"oid": "9f580e3ed868223a7d5c3d59481e5f9535a9e163", "committedDate": "2021-01-20 14:39:53 +0100", "message": "KEYCLOAK-15695 Streamification cleanup"}, {"oid": "1d2d3e5ca526a558ac7b320d290e5455c470133f", "committedDate": "2022-09-11 18:37:45 +0200", "message": "Move UserFederatedStorageProvider into legacy module"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkxMTY4NQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511911685", "body": "To avoid extra lambda  `(int) users.filter(u -> u.getGroupsStream().map(GroupModel::getId).anyMatch(groupIds::contains)).count();`", "bodyText": "To avoid extra lambda  (int) users.filter(u -> u.getGroupsStream().map(GroupModel::getId).anyMatch(groupIds::contains)).count();", "bodyHTML": "<p dir=\"auto\">To avoid extra lambda  <code>(int) users.filter(u -&gt; u.getGroupsStream().map(GroupModel::getId).anyMatch(groupIds::contains)).count();</code></p>", "author": "martin-kanis", "createdAt": "2020-10-26T12:08:19Z", "path": "server-spi/src/main/java/org/keycloak/storage/user/UserQueryProvider.java", "diffHunk": "@@ -126,10 +122,8 @@ default int getUsersCount(Map<String, String> params, RealmModel realm, Set<Stri\n      * @param groupIds id of groups that should be checked for\n      * @return number of users that are in at least one of the groups\n      */\n-    static int countUsersInGroups(List<UserModel> users, Set<String> groupIds) {\n-        return (int) users.stream()\n-                .filter(u -> u.getGroupsStream().anyMatch(group -> groupIds.contains(group.getId())))\n-                .count();\n+    static int countUsersInGroups(Stream<UserModel> users, Set<String> groupIds) {\n+        return (int) users.filter(u -> u.getGroupsStream().anyMatch(group -> groupIds.contains(group.getId()))).count();", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk5NzA2OA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511997068", "bodyText": "Thanks for the suggestion, definitely worth changing.", "author": "sguilhen", "createdAt": "2020-10-26T14:21:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkxMTY4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "changed_code": [{"header": "diff --git a/server-spi/src/main/java/org/keycloak/storage/user/UserQueryProvider.java b/server-spi/src/main/java/org/keycloak/storage/user/UserQueryProvider.java\nindex 6c703650c1..8e8de6ad5b 100644\n--- a/server-spi/src/main/java/org/keycloak/storage/user/UserQueryProvider.java\n+++ b/server-spi/src/main/java/org/keycloak/storage/user/UserQueryProvider.java\n", "chunk": "@@ -123,7 +123,7 @@ public interface UserQueryProvider {\n      * @return number of users that are in at least one of the groups\n      */\n     static int countUsersInGroups(Stream<UserModel> users, Set<String> groupIds) {\n-        return (int) users.filter(u -> u.getGroupsStream().anyMatch(group -> groupIds.contains(group.getId()))).count();\n+        return (int) users.filter(u -> u.getGroupsStream().map(GroupModel::getId).anyMatch(groupIds::contains)).count();\n     }\n \n     /**\n", "next_change": null}]}, "revised_code_in_main": {"commit": "aa4673517308a2f6b8214b192eb2151554564718", "changed_code": [{"header": "diff --git a/server-spi/src/main/java/org/keycloak/storage/user/UserQueryProvider.java b/server-spi/src/main/java/org/keycloak/storage/user/UserQueryProvider.java\nindex 6c703650c1..8e8de6ad5b 100644\n--- a/server-spi/src/main/java/org/keycloak/storage/user/UserQueryProvider.java\n+++ b/server-spi/src/main/java/org/keycloak/storage/user/UserQueryProvider.java\n", "chunk": "@@ -123,7 +123,7 @@ public interface UserQueryProvider {\n      * @return number of users that are in at least one of the groups\n      */\n     static int countUsersInGroups(Stream<UserModel> users, Set<String> groupIds) {\n-        return (int) users.filter(u -> u.getGroupsStream().anyMatch(group -> groupIds.contains(group.getId()))).count();\n+        return (int) users.filter(u -> u.getGroupsStream().map(GroupModel::getId).anyMatch(groupIds::contains)).count();\n     }\n \n     /**\n", "next_change": {"commit": "a175efcb72902a767342941136fe7515733e6f2f", "changed_code": [{"header": "diff --git a/server-spi/src/main/java/org/keycloak/storage/user/UserQueryProvider.java b/server-spi/src/main/java/org/keycloak/storage/user/UserQueryProvider.java\nindex 8e8de6ad5b..c1f020541b 100644\n--- a/server-spi/src/main/java/org/keycloak/storage/user/UserQueryProvider.java\n+++ b/server-spi/src/main/java/org/keycloak/storage/user/UserQueryProvider.java\n", "chunk": "@@ -16,447 +16,19 @@\n  */\n package org.keycloak.storage.user;\n \n-import org.keycloak.models.GroupModel;\n-import org.keycloak.models.RealmModel;\n-import org.keycloak.models.RoleModel;\n-import org.keycloak.models.UserModel;\n-\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n /**\n- * Optional capability interface implemented by UserStorageProviders.\n- * Defines complex queries that are used to locate one or more users.  You must implement this interface\n- * if you want to view and manager users from the administration console.\n- *\n- * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n- * @version $Revision: 1 $\n+ * This is an optional capability interface that is intended to be implemented by any\n+ * <code>UserStorageProvider</code> that supports complex user querying.\n+ * \n+ * It's a combination of {@link UserQueryMethodsProvider} and {@link UserCountMethodsProvider}\n  */\n-public interface UserQueryProvider {\n-\n-    /**\n-     * Returns the number of users, without consider any service account.\n-     *\n-     * @param realm the realm\n-     * @return the number of users\n-     */\n-    int getUsersCount(RealmModel realm);\n-\n-    /**\n-     * Returns the number of users that are in at least one of the groups\n-     * given.\n-     *\n-     * @param realm    the realm\n-     * @param groupIds set of groups id to check for\n-     * @return the number of users that are in at least one of the groups\n-     */\n-    default int getUsersCount(RealmModel realm, Set<String> groupIds) {\n-        if (groupIds == null || groupIds.isEmpty()) {\n-            return 0;\n-        }\n-        return countUsersInGroups(getUsersStream(realm), groupIds);\n-    }\n-\n-    /**\n-     * Returns the number of users that match the given criteria.\n-     *\n-     * @param search search criteria\n-     * @param realm  the realm\n-     * @return number of users that match the search\n-     */\n-    default int getUsersCount(String search, RealmModel realm) {\n-        return (int) searchForUserStream(search, realm).count();\n-    }\n-\n-    /**\n-     * Returns the number of users that match the given criteria and are in\n-     * at least one of the groups given.\n-     *\n-     * @param search   search criteria\n-     * @param realm    the realm\n-     * @param groupIds set of groups to check for\n-     * @return number of users that match the search and given groups\n-     */\n-    default int getUsersCount(String search, RealmModel realm, Set<String> groupIds) {\n-        if (groupIds == null || groupIds.isEmpty()) {\n-            return 0;\n-        }\n-        return countUsersInGroups(searchForUserStream(search, realm), groupIds);\n-    }\n-\n-    /**\n-     * Returns the number of users that match the given filter parameters.\n-     *\n-     * @param params filter parameters\n-     * @param realm  the realm\n-     * @return number of users that match the given filters\n-     */\n-    default int getUsersCount(Map<String, String> params, RealmModel realm) {\n-        return (int) searchForUserStream(params, realm).count();\n-    }\n-\n-    /**\n-     * Returns the number of users that match the given filter parameters and is in\n-     * at least one of the given groups.\n-     *\n-     * @param params   filter parameters\n-     * @param realm    the realm\n-     * @param groupIds set if groups to check for\n-     * @return number of users that match the given filters and groups\n-     */\n-    default int getUsersCount(Map<String, String> params, RealmModel realm, Set<String> groupIds) {\n-        if (groupIds == null || groupIds.isEmpty()) {\n-            return 0;\n-        }\n-        return countUsersInGroups(searchForUserStream(params, realm), groupIds);\n-    }\n-\n-    /**\n-     * Returns the number of users from the given list of users that are in at\n-     * least one of the groups given in the groups set.\n-     *\n-     * @param users    list of users to check\n-     * @param groupIds id of groups that should be checked for\n-     * @return number of users that are in at least one of the groups\n-     */\n-    static int countUsersInGroups(Stream<UserModel> users, Set<String> groupIds) {\n-        return (int) users.filter(u -> u.getGroupsStream().map(GroupModel::getId).anyMatch(groupIds::contains)).count();\n-    }\n+public interface UserQueryProvider extends UserQueryMethodsProvider, UserCountMethodsProvider {\n \n     /**\n-     * Returns the number of users.\n-     *\n-     * @param realm the realm\n-     * @param includeServiceAccount if true, the number of users will also include service accounts. Otherwise, only the number of users.\n-     * @return the number of users\n-     */\n-    default int getUsersCount(RealmModel realm, boolean includeServiceAccount) {\n-        throw new RuntimeException(\"Not implemented\");\n-    }\n-\n-    /**\n-     * @deprecated Use {@link #getUsersStream(RealmModel) getUsersStream} instead.\n-     */\n-    @Deprecated\n-    default List<UserModel> getUsers(RealmModel realm) {\n-        return this.getUsersStream(realm).collect(Collectors.toList());\n-    }\n-\n-    /**\n-     * Searches all users in the realm.\n-     *\n-     * @param realm a reference to the realm.\n-     * @return a non-null {@code Stream} of users.\n-     */\n-    Stream<UserModel> getUsersStream(RealmModel realm);\n-\n-    /**\n-     * @deprecated Use {@link #getUsersStream(RealmModel, int, int) getUsersStream} instead.\n-     */\n-    @Deprecated\n-    default List<UserModel> getUsers(RealmModel realm, int firstResult, int maxResults) {\n-        return this.getUsersStream(realm, firstResult, maxResults).collect(Collectors.toList());\n-    }\n-\n-    /**\n-     * Searches all users in the realm, starting from the {@code firstResult} and containing at most {@code maxResults}.\n-     *\n-     * @param realm a reference to the realm.\n-     * @param firstResult first result to return. Ignored if negative.\n-     * @param maxResults maximum number of results to return. Ignored if negative.\n-     * @return a non-null {@code Stream} of users.\n-     */\n-    Stream<UserModel> getUsersStream(RealmModel realm, int firstResult, int maxResults);\n-\n-    /**\n-     * Search for users with username, email or first + last name that is like search string.\n-     *\n-     * If possible, implementations should treat the parameter values as partial match patterns i.e. in RDMBS terms use LIKE.\n-     *\n-     * This method is used by the admin console search box\n-     *\n-     * @param search\n-     * @param realm\n-     * @return\n-     * @deprecated Use {@link #searchForUserStream(String, RealmModel) searchForUserStream} instead.\n+     * @deprecated This interface is no longer necessary, collection-based methods were removed from the parent interface\n+     * and therefore the parent interface can be used directly\n      */\n     @Deprecated\n-    default List<UserModel> searchForUser(String search, RealmModel realm) {\n-        return this.searchForUserStream(search, realm).collect(Collectors.toList());\n+    interface Streams extends UserQueryProvider {\n     }\n-\n-    /**\n-     * Searches for users with username, email or first + last name that is like search string.  If possible, implementations\n-     * should treat the parameter values as partial match patterns (i.e. in RDMBS terms use LIKE).\n-     * <p/>\n-     * This method is used by the admin console search box\n-     *\n-     * @param search case sensitive search string.\n-     * @param realm a reference to the realm.\n-     * @return a non-null {@code Stream} of users that match the search string.\n-     */\n-    Stream<UserModel> searchForUserStream(String search, RealmModel realm);\n-\n-    /**\n-     * Search for users with username, email or first + last name that is like search string.\n-     *\n-     * If possible, implementations should treat the parameter values as partial match patterns i.e. in RDMBS terms use LIKE.\n-     *\n-     * This method is used by the admin console search box\n-     *\n-     * @param search\n-     * @param realm\n-     * @param firstResult\n-     * @param maxResults\n-     * @return\n-     * @deprecated Use {@link #searchForUserStream(String, RealmModel, int, int) searchForUserStream} instead.\n-     */\n-    @Deprecated\n-    default List<UserModel> searchForUser(String search, RealmModel realm, int firstResult, int maxResults) {\n-        return this.searchForUserStream(search, realm, firstResult, maxResults).collect(Collectors.toList());\n-    }\n-\n-    /**\n-     * Searches for users with username, email or first + last name that is like search string. If possible, implementations\n-     * should treat the parameter values as partial match patterns (i.e. in RDMBS terms use LIKE).\n-     * <p/>\n-     * This method is used by the admin console search box\n-     *\n-     * @param search case sensitive search string.\n-     * @param realm a reference to the realm.\n-     * @param firstResult first result to return. Ignored if negative.\n-     * @param maxResults maximum number of results to return. Ignored if negative.\n-     * @return a non-null {@code Stream} of users that match the search criteria.\n-     */\n-    Stream<UserModel> searchForUserStream(String search, RealmModel realm, int firstResult, int maxResults);\n-\n-    /**\n-     * Search for user by parameter.  Valid parameters are:\n-     * \"first\" - first name\n-     * \"last\" - last name\n-     * \"email\" - email\n-     * \"username\" - username\n-     *\n-     * If possible, implementations should treat the parameter values as partial match patterns i.e. in RDMBS terms use LIKE.\n-     *\n-     * This method is used by the REST API when querying users.\n-     *\n-     *\n-     * @param params\n-     * @param realm\n-     * @return\n-     * @deprecated Use {@link #searchForUserStream(Map, RealmModel) searchForUserStream} instead.\n-     */\n-    @Deprecated\n-    default List<UserModel> searchForUser(Map<String, String> params, RealmModel realm) {\n-        return this.searchForUserStream(params, realm).collect(Collectors.toList());\n-    }\n-\n-    /**\n-     * Searches for user by parameter. If possible, implementations should treat the parameter values as partial match patterns\n-     * (i.e. in RDMBS terms use LIKE). Valid parameters are:\n-     * <ul>\n-     *   <li><b>first</b> - first name</li>\n-     *   <li><b>last</b> - last name</li>\n-     *   <li><b>email</b> - email</li>\n-     *   <li><b>username</b> - username</li>\n-     *   <li><b>enabled</b> - if user is enabled (true/false)</li>\n-     * </ul>\n-     * This method is used by the REST API when querying users.\n-     *\n-     * @param params a map containing the search parameters.\n-     * @param realm a reference to the realm.\n-     * @return a non-null {@code Stream} of users that match the search parameters.\n-     */\n-    Stream<UserModel> searchForUserStream(Map<String, String> params, RealmModel realm);\n-\n-    /**\n-     * Search for user by parameter.    Valid parameters are:\n-     * \"first\" - first name\n-     * \"last\" - last name\n-     * \"email\" - email\n-     * \"username\" - username\n-     * \"enabled\" - is user enabled (true/false)\n-     *\n-     * If possible, implementations should treat the parameter values as patterns i.e. in RDMBS terms use LIKE.\n-     * This method is used by the REST API when querying users.\n-     *\n-     *\n-     * @param params\n-     * @param realm\n-     * @param firstResult\n-     * @param maxResults\n-     * @return\n-     * @deprecated Use {@link #searchForUserStream(Map, RealmModel, int, int) searchForUserStream} instead.\n-     */\n-    @Deprecated\n-    default List<UserModel> searchForUser(Map<String, String> params, RealmModel realm, int firstResult, int maxResults) {\n-        return this.searchForUserStream(params, realm, firstResult, maxResults).collect(Collectors.toList());\n-    }\n-\n-    /**\n-     * Searches for user by parameter. If possible, implementations should treat the parameter values as partial match patterns\n-     * (i.e. in RDMBS terms use LIKE). Valid parameters are:\n-     * <ul>\n-     *   <li><b>first</b> - first name</li>\n-     *   <li><b>last</b> - last name</li>\n-     *   <li><b>email</b> - email</li>\n-     *   <li><b>username</b> - username</li>\n-     *   <li><b>enabled</b> - if user is enabled (true/false)</li>\n-     * </ul>\n-     * This method is used by the REST API when querying users.\n-     *\n-     * @param params a map containing the search parameters.\n-     * @param realm a reference to the realm.\n-     * @param firstResult first result to return. Ignored if negative.\n-     * @param maxResults maximum number of results to return. Ignored if negative.\n-     * @return a non-null {@code Stream} of users that match the search criteria.\n-     */\n-    Stream<UserModel> searchForUserStream(Map<String, String> params, RealmModel realm, int firstResult, int maxResults);\n-\n-    /**\n-     * Get users that belong to a specific group. Implementations do not have to search in UserFederatedStorageProvider\n-     * as this is done automatically.\n-     *\n-     * @see org.keycloak.storage.federated.UserFederatedStorageProvider\n-     *\n-     * @param realm\n-     * @param group\n-     * @return\n-     * @deprecated Use {@link #getGroupMembersStream(RealmModel, GroupModel) getGroupMembersStream} instead.\n-     */\n-    @Deprecated\n-    default List<UserModel> getGroupMembers(RealmModel realm, GroupModel group) {\n-        return this.getGroupMembersStream(realm, group).collect(Collectors.toList());\n-    }\n-\n-    /**\n-     * Obtains users that belong to a specific group. Implementations do not have to search in {@code UserFederatedStorageProvider}\n-     * as this is done automatically.\n-     *\n-     * @see org.keycloak.storage.federated.UserFederatedStorageProvider\n-     *\n-     * @param realm a reference to the realm.\n-     * @param group a reference to the group.\n-     * @return a non-null {@code Stream} of users that belong to the group.\n-     */\n-    Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group);\n-\n-    /**\n-     * Get users that belong to a specific group.  Implementations do not have to search in UserFederatedStorageProvider\n-     * as this is done automatically.\n-     *\n-     * @see org.keycloak.storage.federated.UserFederatedStorageProvider\n-     *\n-     * @param realm\n-     * @param group\n-     * @param firstResult\n-     * @param maxResults\n-     * @return\n-     * @deprecated Use {@link #getGroupMembersStream(RealmModel, GroupModel, int, int) getGroupMembersStream} instead.\n-     */\n-    @Deprecated\n-    default List<UserModel> getGroupMembers(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n-        return this.getGroupMembersStream(realm, group, firstResult, maxResults).collect(Collectors.toList());\n-    }\n-\n-    /**\n-     * Obtains users that belong to a specific group.  Implementations do not have to search in {@code UserFederatedStorageProvider}\n-     * as this is done automatically.\n-     *\n-     * @see org.keycloak.storage.federated.UserFederatedStorageProvider\n-     *\n-     * @param realm a reference to the realm.\n-     * @param group a reference to the group.\n-     * @param firstResult first result to return. Ignored if negative.\n-     * @param maxResults maximum number of results to return. Ignored if negative.\n-     * @return a non-null {@code Stream} of users that belong to the group.\n-     */\n-    Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, int firstResult, int maxResults);\n-\n-    /**\n-     * Get users that belong to a specific role.\n-     *\n-     * @param realm\n-     * @param role\n-     * @return\n-     * @deprecated Use {@link #getRoleMembersStream(RealmModel, RoleModel) getRoleMembersStream} instead.\n-     */\n-    @Deprecated\n-    default List<UserModel> getRoleMembers(RealmModel realm, RoleModel role) {\n-        return this.getRoleMembersStream(realm, role).collect(Collectors.toList());\n-    }\n-\n-    /**\n-     * Obtains users that have the specified role.\n-     *\n-     * @param realm a reference to the realm.\n-     * @param role a reference to the role.\n-     * @return a non-null {@code Stream} of users that have the specified role.\n-     */\n-    default Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role) {\n-        return Stream.empty();\n-    }\n-\n-    /**\n-     * Search for users that have a specific role with a specific roleId.\n-     *\n-     * @param firstResult\n-     * @param maxResults\n-     * @param role\n-     * @return\n-     * @deprecated Use {@link #getRoleMembersStream(RealmModel, RoleModel, int, int) getRoleMembersStream} instead.\n-     */\n-    @Deprecated\n-    default List<UserModel> getRoleMembers(RealmModel realm, RoleModel role, int firstResult, int maxResults) {\n-        return this.getRoleMembersStream(realm, role, firstResult, maxResults).collect(Collectors.toList());\n-    }\n-\n-    /**\n-     * Searches for users that have the specified role.\n-     *\n-     * @param realm a reference to the realm.\n-     * @param role a reference to the role.\n-     * @param firstResult first result to return. Ignored if negative.\n-     * @param maxResults maximum number of results to return. Ignored if negative.\n-     * @return a non-null {@code Stream} of users that have the specified role.\n-     */\n-    default Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role, int firstResult, int maxResults) {\n-        return Stream.empty();\n-    }\n-\n-    /**\n-     * Search for users that have a specific attribute with a specific value.\n-     * Implementations do not have to search in UserFederatedStorageProvider\n-     * as this is done automatically.\n-     *\n-     * @see org.keycloak.storage.federated.UserFederatedStorageProvider\n-     *\n-     * @param attrName\n-     * @param attrValue\n-     * @param realm\n-     * @return\n-     * @deprecated Use {@link #searchForUserByUserAttributeStream(String, String, RealmModel) searchForUserByUserAttributeStream}\n-     * instead.\n-     */\n-    @Deprecated\n-    default List<UserModel> searchForUserByUserAttribute(String attrName, String attrValue, RealmModel realm) {\n-        return this.searchForUserByUserAttributeStream(attrName, attrValue, realm).collect(Collectors.toList());\n-    }\n-\n-    /**\n-     * Searches for users that have a specific attribute with a specific value. Implementations do not have to search in\n-     * {@code UserFederatedStorageProvider} as this is done automatically.\n-     *\n-     * @see org.keycloak.storage.federated.UserFederatedStorageProvider\n-     *\n-     * @param attrName the attribute name.\n-     * @param attrValue the attribute value.\n-     * @param realm a reference to the realm.\n-     * @return a non-null {@code Stream} of users that match the search criteria.\n-     */\n-    Stream<UserModel> searchForUserByUserAttributeStream(String attrName, String attrValue, RealmModel realm);\n }\n", "next_change": {"commit": "ed473da22b713d599865b4779445dc843258505b", "changed_code": [{"header": "diff --git a/server-spi/src/main/java/org/keycloak/storage/user/UserQueryProvider.java b/server-spi/src/main/java/org/keycloak/storage/user/UserQueryProvider.java\nindex c1f020541b..aaa3b8cdf2 100644\n--- a/server-spi/src/main/java/org/keycloak/storage/user/UserQueryProvider.java\n+++ b/server-spi/src/main/java/org/keycloak/storage/user/UserQueryProvider.java\n", "chunk": "@@ -23,12 +23,4 @@ package org.keycloak.storage.user;\n  * It's a combination of {@link UserQueryMethodsProvider} and {@link UserCountMethodsProvider}\n  */\n public interface UserQueryProvider extends UserQueryMethodsProvider, UserCountMethodsProvider {\n-\n-    /**\n-     * @deprecated This interface is no longer necessary, collection-based methods were removed from the parent interface\n-     * and therefore the parent interface can be used directly\n-     */\n-    @Deprecated\n-    interface Streams extends UserQueryProvider {\n-    }\n }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "aa4673517308a2f6b8214b192eb2151554564718", "message": "Merge commit", "committedDate": null}, {"oid": "84df008bc2173df12b6cbfa58047ebc120d1f413", "committedDate": "2020-11-18 21:07:51 +0100", "message": "[KEYCLOAK-16341] Make the new stream-based methods in server-spi user interfaces default instead of the collection-based versions.  - this ensures that providing implementation for the collection-based methods is enough, which preserves    backwards compatibility with older custom implementations.  - alternative interfaces now allow new implementations to focus on the stream variants of the query methods."}, {"oid": "8e376aef51b4b5d7ade4e5196ee628a086c1749a", "committedDate": "2020-12-10 08:57:53 +0100", "message": "KEYCLOAK-15847 Add MapUserProvider"}, {"oid": "ba8e2fef6b0a47727f03d58f4fe2809d6e65c017", "committedDate": "2021-01-18 16:56:10 +0100", "message": "KEYCLOAK-15524 Cleanup user related interfaces"}, {"oid": "9f580e3ed868223a7d5c3d59481e5f9535a9e163", "committedDate": "2021-01-20 14:39:53 +0100", "message": "KEYCLOAK-15695 Streamification cleanup"}, {"oid": "5b0986e490090433658e9a1e607c0e248f4cc756", "committedDate": "2021-10-12 13:08:47 +0200", "message": "[KEYCLOAK-18891] Add support for searching users by custom user attributes"}, {"oid": "82094d113ed93846e0d72ddb8d26ad873db31c0d", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Move User Storage SPI, introduce ExportImportManager"}, {"oid": "f69497eb28ab6c6595a4a335607d03b0c7ba229d", "committedDate": "2022-09-06 10:38:28 +0200", "message": "KEYCLOAK-12988 Deprecate getUsers* methods in favor of searchUsers* variants"}, {"oid": "883e83e62540168593046e34292849e16c009760", "committedDate": "2022-10-25 09:01:33 +0200", "message": "Remove deprecated methods from data providers and models"}, {"oid": "a175efcb72902a767342941136fe7515733e6f2f", "committedDate": "2023-05-31 11:47:54 +0200", "message": "Split `UserQueryProvider` into `UserQueryMethods` and `UserCountMethods` and make `LdapStorageProvider` implement only `UserQueryMethods` Co-authored-by: mhajas <mhajas@redhat.com>"}, {"oid": "ed473da22b713d599865b4779445dc843258505b", "committedDate": "2023-06-09 17:11:20 +0000", "message": "Clean-up of deprecated methods and interfaces"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1NTE1OQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511955159", "body": "I'm wondering if we should time bound the results from federated storage same as we did in `ClientStorageManager.searchClientsByClientIdStream` whenever we concat local and federated entities. ", "bodyText": "I'm wondering if we should time bound the results from federated storage same as we did in ClientStorageManager.searchClientsByClientIdStream whenever we concat local and federated entities.", "bodyHTML": "<p dir=\"auto\">I'm wondering if we should time bound the results from federated storage same as we did in <code>ClientStorageManager.searchClientsByClientIdStream</code> whenever we concat local and federated entities.</p>", "author": "martin-kanis", "createdAt": "2020-10-26T13:24:00Z", "path": "services/src/main/java/org/keycloak/storage/UserStorageManager.java", "diffHunk": "@@ -608,14 +600,13 @@ public UserModel getServiceAccount(ClientModel client) {\n     }\n \n     @Override\n-    public Set<FederatedIdentityModel> getFederatedIdentities(UserModel user, RealmModel realm) {\n+    public Stream<FederatedIdentityModel> getFederatedIdentitiesStream(UserModel user, RealmModel realm) {\n         if (user == null) throw new IllegalStateException(\"Federated user no longer valid\");\n-        Set<FederatedIdentityModel> set = new HashSet<>();\n-        if (StorageId.isLocalStorage(user)) {\n-            set.addAll(localStorage().getFederatedIdentities(user, realm));\n-        }\n-        if (getFederatedStorage() != null) set.addAll(getFederatedStorage().getFederatedIdentities(user.getId(), realm));\n-        return set;\n+        Stream<FederatedIdentityModel> stream = StorageId.isLocalStorage(user) ?\n+                localStorage().getFederatedIdentitiesStream(user, realm) : Stream.empty();\n+        if (getFederatedStorage() != null)\n+            stream = Streams.concat(stream, getFederatedStorage().getFederatedIdentitiesStream(user.getId(), realm));", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk5NjE3Mw==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511996173", "bodyText": "I will check this", "author": "sguilhen", "createdAt": "2020-10-26T14:20:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1NTE1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI3NTYwNQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r512275605", "bodyText": "@mhajas FYI", "author": "hmlnarik", "createdAt": "2020-10-26T21:20:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1NTE1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQ4MjA2OQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r512482069", "bodyText": "Well, this is a good question. However, I don't think we should. The federatedStorage is something little bit confusing, I spent quite a lot of time on investigating what is it for. If I understand correctly, this is the point: if you have some users, from external storage/provider and you are not able to store some keycloak specific properties (attributes, roles, groups etc.) in that external storage, you can configure keycloak to store it for you using this federatedStorage. For example you store a user with id id_pointing_to_external_storage have roles admin and manager. So whenever there is a call to federatedStorage for FederatedIdentityModel, it should be a call to a database/map storage (in future). See current jpa implementation.\nTherefore, If we would time bound federated storage, the same logic would apply also to localStorage() and I don't like this idea. WDYT?", "author": "mhajas", "createdAt": "2020-10-27T08:02:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1NTE1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzNzM1NQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r514437355", "bodyText": "Given @mhajas comment, I'm leaving it as is for now.", "author": "sguilhen", "createdAt": "2020-10-29T17:25:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1NTE1OQ=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "84df008bc2173df12b6cbfa58047ebc120d1f413", "changed_code": [{"header": "diff --git a/services/src/main/java/org/keycloak/storage/UserStorageManager.java b/services/src/main/java/org/keycloak/storage/UserStorageManager.java\nindex 02c4244464..0ab9d6f44f 100755\n--- a/services/src/main/java/org/keycloak/storage/UserStorageManager.java\n+++ b/services/src/main/java/org/keycloak/storage/UserStorageManager.java\n", "chunk": "@@ -605,7 +604,7 @@ public class UserStorageManager extends AbstractStorageManager<UserStorageProvid\n         Stream<FederatedIdentityModel> stream = StorageId.isLocalStorage(user) ?\n                 localStorage().getFederatedIdentitiesStream(user, realm) : Stream.empty();\n         if (getFederatedStorage() != null)\n-            stream = Streams.concat(stream, getFederatedStorage().getFederatedIdentitiesStream(user.getId(), realm));\n+            stream = Stream.concat(stream, getFederatedStorage().getFederatedIdentitiesStream(user.getId(), realm));\n         return stream.distinct();\n     }\n \n", "next_change": {"commit": "ba8e2fef6b0a47727f03d58f4fe2809d6e65c017", "changed_code": [{"header": "diff --git a/services/src/main/java/org/keycloak/storage/UserStorageManager.java b/services/src/main/java/org/keycloak/storage/UserStorageManager.java\nindex 0ab9d6f44f..b4b38418b3 100755\n--- a/services/src/main/java/org/keycloak/storage/UserStorageManager.java\n+++ b/services/src/main/java/org/keycloak/storage/UserStorageManager.java\n", "chunk": "@@ -599,20 +583,20 @@ public class UserStorageManager extends AbstractStorageManager<UserStorageProvid\n     }\n \n     @Override\n-    public Stream<FederatedIdentityModel> getFederatedIdentitiesStream(UserModel user, RealmModel realm) {\n+    public Stream<FederatedIdentityModel> getFederatedIdentitiesStream(RealmModel realm, UserModel user) {\n         if (user == null) throw new IllegalStateException(\"Federated user no longer valid\");\n         Stream<FederatedIdentityModel> stream = StorageId.isLocalStorage(user) ?\n-                localStorage().getFederatedIdentitiesStream(user, realm) : Stream.empty();\n+                localStorage().getFederatedIdentitiesStream(realm, user) : Stream.empty();\n         if (getFederatedStorage() != null)\n             stream = Stream.concat(stream, getFederatedStorage().getFederatedIdentitiesStream(user.getId(), realm));\n         return stream.distinct();\n     }\n \n     @Override\n-    public FederatedIdentityModel getFederatedIdentity(UserModel user, String socialProvider, RealmModel realm) {\n+    public FederatedIdentityModel getFederatedIdentity(RealmModel realm, UserModel user, String socialProvider) {\n         if (user == null) throw new IllegalStateException(\"Federated user no longer valid\");\n         if (StorageId.isLocalStorage(user)) {\n-            FederatedIdentityModel model = localStorage().getFederatedIdentity(user, socialProvider, realm);\n+            FederatedIdentityModel model = localStorage().getFederatedIdentity(realm, user, socialProvider);\n             if (model != null) return model;\n         }\n         if (getFederatedStorage() != null) return getFederatedStorage().getFederatedIdentity(user.getId(), socialProvider, realm);\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "aa4673517308a2f6b8214b192eb2151554564718", "message": "Merge commit", "committedDate": null}, {"oid": "84df008bc2173df12b6cbfa58047ebc120d1f413", "committedDate": "2020-11-18 21:07:51 +0100", "message": "[KEYCLOAK-16341] Make the new stream-based methods in server-spi user interfaces default instead of the collection-based versions.  - this ensures that providing implementation for the collection-based methods is enough, which preserves    backwards compatibility with older custom implementations.  - alternative interfaces now allow new implementations to focus on the stream variants of the query methods."}, {"oid": "8e376aef51b4b5d7ade4e5196ee628a086c1749a", "committedDate": "2020-12-10 08:57:53 +0100", "message": "KEYCLOAK-15847 Add MapUserProvider"}, {"oid": "ba8e2fef6b0a47727f03d58f4fe2809d6e65c017", "committedDate": "2021-01-18 16:56:10 +0100", "message": "KEYCLOAK-15524 Cleanup user related interfaces"}, {"oid": "1e2db74d866bda50f3d78d42892f16e2d7efe4e7", "committedDate": "2021-04-16 17:26:16 +0200", "message": "KEYCLOAK-16932 Authorization map storage"}, {"oid": "f37a24dd91ca2768d478cf735bbf99d041ed58b9", "committedDate": "2021-05-12 15:09:36 +0200", "message": "KEYCLOAK-17348 Add manual pagination into UserStorageManager#query"}, {"oid": "703e868a5129c147d723e8c367c7eb962843e280", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Preparation for moving User Storage SPI"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1NzcwNw==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511957707", "body": "Here again \"-1\" in skip will cause an `IllegalStateException`.", "bodyText": "Here again \"-1\" in skip will cause an IllegalStateException.", "bodyHTML": "<p dir=\"auto\">Here again \"-1\" in skip will cause an <code>IllegalStateException</code>.</p>", "author": "martin-kanis", "createdAt": "2020-10-26T13:27:56Z", "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java", "diffHunk": "@@ -293,49 +291,45 @@ public int getUsersCount(RealmModel realm) {\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm) {\n+    public Stream<UserModel> getUsersStream(RealmModel realm) {\n         return userPasswords.keySet().stream()\n-          .map(userName -> createUser(realm, userName))\n-          .collect(Collectors.toList());\n+          .map(userName -> createUser(realm, userName));\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm, int firstResult, int maxResults) {\n+    public Stream<UserModel> getUsersStream(RealmModel realm, int firstResult, int maxResults) {\n         return userPasswords.keySet().stream()\n           .sorted()\n           .skip(firstResult)", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "changed_code": [{"header": "diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\nindex 4717512ea5..dc8da1c643 100644\n--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n", "chunk": "@@ -298,11 +298,12 @@ public class UserMapStorage implements UserLookupProvider, UserStorageProvider,\n \n     @Override\n     public Stream<UserModel> getUsersStream(RealmModel realm, int firstResult, int maxResults) {\n-        return userPasswords.keySet().stream()\n-          .sorted()\n-          .skip(firstResult)\n-          .limit(maxResults)\n-          .map(userName -> createUser(realm, userName));\n+        Stream<String> userStream = userPasswords.keySet().stream().sorted();\n+        if (firstResult > 0)\n+            userStream = userStream.skip(firstResult);\n+        if (maxResults >= 0)\n+            userStream = userStream.limit(maxResults);\n+        return userStream.map(userName -> createUser(realm, userName));\n     }\n \n     @Override\n", "next_change": null}]}, "revised_code_in_main": {"commit": "aa4673517308a2f6b8214b192eb2151554564718", "changed_code": [{"header": "diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\nindex 4717512ea5..dc8da1c643 100644\n--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n", "chunk": "@@ -298,11 +298,12 @@ public class UserMapStorage implements UserLookupProvider, UserStorageProvider,\n \n     @Override\n     public Stream<UserModel> getUsersStream(RealmModel realm, int firstResult, int maxResults) {\n-        return userPasswords.keySet().stream()\n-          .sorted()\n-          .skip(firstResult)\n-          .limit(maxResults)\n-          .map(userName -> createUser(realm, userName));\n+        Stream<String> userStream = userPasswords.keySet().stream().sorted();\n+        if (firstResult > 0)\n+            userStream = userStream.skip(firstResult);\n+        if (maxResults >= 0)\n+            userStream = userStream.limit(maxResults);\n+        return userStream.map(userName -> createUser(realm, userName));\n     }\n \n     @Override\n", "next_change": {"commit": "8c0c542f09bcc6fa165f7868a1097d64fc4f38d7", "changed_code": [{"header": "diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\nindex dc8da1c643..9a40a1854b 100644\n--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n", "chunk": "@@ -308,17 +307,19 @@ public class UserMapStorage implements UserLookupProvider, UserStorageProvider,\n \n     @Override\n     public Stream<UserModel> searchForUserStream(String search, RealmModel realm) {\n+        String tSearch = translateUserName(search);\n         return userPasswords.keySet().stream()\n           .sorted()\n-          .filter(userName -> userName.contains(search))\n+          .filter(userName -> translateUserName(userName).contains(tSearch))\n           .map(userName -> createUser(realm, userName));\n     }\n \n     @Override\n     public Stream<UserModel> searchForUserStream(String search, RealmModel realm, int firstResult, int maxResults) {\n+        String tSearch = translateUserName(search);\n         Stream<String> userStream = userPasswords.keySet().stream()\n                 .sorted()\n-                .filter(userName -> userName.contains(search));\n+                .filter(userName -> translateUserName(userName).contains(search));\n         if (firstResult > 0)\n             userStream = userStream.skip(firstResult);\n         if (maxResults >= 0)\n", "next_change": {"commit": "8e376aef51b4b5d7ade4e5196ee628a086c1749a", "changed_code": [{"header": "diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\nindex 9a40a1854b..b8d538db77 100644\n--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n", "chunk": "@@ -315,14 +315,14 @@ public class UserMapStorage implements UserLookupProvider, UserStorageProvider,\n     }\n \n     @Override\n-    public Stream<UserModel> searchForUserStream(String search, RealmModel realm, int firstResult, int maxResults) {\n+    public Stream<UserModel> searchForUserStream(String search, RealmModel realm, Integer firstResult, Integer maxResults) {\n         String tSearch = translateUserName(search);\n         Stream<String> userStream = userPasswords.keySet().stream()\n                 .sorted()\n                 .filter(userName -> translateUserName(userName).contains(search));\n-        if (firstResult > 0)\n+        if (firstResult != null && firstResult > 0)\n             userStream = userStream.skip(firstResult);\n-        if (maxResults >= 0)\n+        if (maxResults != null && maxResults >= 0)\n             userStream = userStream.limit(maxResults);\n         return userStream.map(userName -> createUser(realm, userName));\n     }\n", "next_change": {"commit": "ba8e2fef6b0a47727f03d58f4fe2809d6e65c017", "changed_code": [{"header": "diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\nindex b8d538db77..793509436b 100644\n--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n", "chunk": "@@ -315,25 +313,17 @@ public class UserMapStorage implements UserLookupProvider, UserStorageProvider,\n     }\n \n     @Override\n-    public Stream<UserModel> searchForUserStream(String search, RealmModel realm, Integer firstResult, Integer maxResults) {\n+    public Stream<UserModel> searchForUserStream(RealmModel realm, String search, Integer firstResult, Integer maxResults) {\n         String tSearch = translateUserName(search);\n         Stream<String> userStream = userPasswords.keySet().stream()\n                 .sorted()\n                 .filter(userName -> translateUserName(userName).contains(search));\n-        if (firstResult != null && firstResult > 0)\n-            userStream = userStream.skip(firstResult);\n-        if (maxResults != null && maxResults >= 0)\n-            userStream = userStream.limit(maxResults);\n-        return userStream.map(userName -> createUser(realm, userName));\n-    }\n \n-    @Override\n-    public Stream<UserModel> searchForUserStream(Map<String, String> params, RealmModel realm) {\n-        return searchForUserStream(params, realm, 0, Integer.MAX_VALUE - 1);\n+        return paginatedStream(userStream, firstResult, maxResults).map(userName -> createUser(realm, userName));\n     }\n \n     @Override\n-    public Stream<UserModel> searchForUserStream(Map<String, String> params, RealmModel realm, Integer firstResult, Integer maxResults) {\n+    public Stream<UserModel> searchForUserStream(RealmModel realm, Map<String, String> params, Integer firstResult, Integer maxResults) {\n         Stream<String> userStream = userPasswords.keySet().stream()\n           .sorted();\n \n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "aa4673517308a2f6b8214b192eb2151554564718", "message": "Merge commit", "committedDate": null}, {"oid": "84df008bc2173df12b6cbfa58047ebc120d1f413", "committedDate": "2020-11-18 21:07:51 +0100", "message": "[KEYCLOAK-16341] Make the new stream-based methods in server-spi user interfaces default instead of the collection-based versions.  - this ensures that providing implementation for the collection-based methods is enough, which preserves    backwards compatibility with older custom implementations.  - alternative interfaces now allow new implementations to focus on the stream variants of the query methods."}, {"oid": "edef93cd491e545de642fd39d0df0a53cecee830", "committedDate": "2020-12-07 19:48:35 +0100", "message": "[KEYCLOAK-16232] Streamify the UserCredentialStore and UserCredentialManager interfaces"}, {"oid": "8c0c542f09bcc6fa165f7868a1097d64fc4f38d7", "committedDate": "2020-12-07 20:54:06 +0100", "message": "KEYCLOAK-16489 Add ability to run model tests with LDAP"}, {"oid": "8e376aef51b4b5d7ade4e5196ee628a086c1749a", "committedDate": "2020-12-10 08:57:53 +0100", "message": "KEYCLOAK-15847 Add MapUserProvider"}, {"oid": "ba8e2fef6b0a47727f03d58f4fe2809d6e65c017", "committedDate": "2021-01-18 16:56:10 +0100", "message": "KEYCLOAK-15524 Cleanup user related interfaces"}, {"oid": "9f580e3ed868223a7d5c3d59481e5f9535a9e163", "committedDate": "2021-01-20 14:39:53 +0100", "message": "KEYCLOAK-15695 Streamification cleanup"}, {"oid": "a0f8d2bc0eadd0e8da54fbf8828d330032deb94f", "committedDate": "2021-05-20 08:44:24 -0300", "message": "[KEYCLOAK-17399] - Review User Profile SPI"}, {"oid": "bc8fd21dc6495b7f43f3466eb3545055753114ae", "committedDate": "2022-06-21 08:53:06 +0200", "message": "SingleUserCredentialManager moving in - UserStorageManager now handles authentication for old Kerberos+LDAP style - new getUserByCredential method in MapUserProvider would eventually do the same."}, {"oid": "e396d0daa1fed0cb82cf761fe3b461ba24118a10", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Renaming SingleUserCredentialManager and UserModel.getUserCredentialManager(): - class SingleUserCredentialManager to SingleEntityCredentialManager - method UserModel.getUserCredentialManager() to credentialManager()"}, {"oid": "1bc6133e4ecee8f4ebd9b10f8f92d0fca4e11d8e", "committedDate": "2022-06-21 08:53:06 +0200", "message": "redirect calls to userLocalStorage from legacy modules (federation, ldap, sssd, kerberos)"}, {"oid": "1a227212deaf7b933cebc0100cb44871644c7ee5", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Simplify implementation of a federated storage by moving the default implementation to the abstract base class; this will also allow the quickstarts and implementations derived from that to run without changes."}, {"oid": "d41764b19bbb682b187f37a60b71de9a6eb7d612", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Inline deprecated methods in legacy code"}, {"oid": "cb0c88182148fd352969383a33f2eeb56cc4de9f", "committedDate": "2022-06-21 08:53:06 +0200", "message": "rename SingleEntityCredentialManager to SubjectCredentialManager"}, {"oid": "f49582cf63db5b83b399e43a1530b06b18edfad4", "committedDate": "2022-10-14 09:32:38 +0200", "message": "MapUserProvider in KC20 needs to store username compatible with KC19 to be no-downtime-upgradable"}, {"oid": "883e83e62540168593046e34292849e16c009760", "committedDate": "2022-10-25 09:01:33 +0200", "message": "Remove deprecated methods from data providers and models"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1OTU2OA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511959568", "body": "Negative number in skip.", "bodyText": "Negative number in skip.", "bodyHTML": "<p dir=\"auto\">Negative number in skip.</p>", "author": "martin-kanis", "createdAt": "2020-10-26T13:30:21Z", "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java", "diffHunk": "@@ -293,49 +291,45 @@ public int getUsersCount(RealmModel realm) {\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm) {\n+    public Stream<UserModel> getUsersStream(RealmModel realm) {\n         return userPasswords.keySet().stream()\n-          .map(userName -> createUser(realm, userName))\n-          .collect(Collectors.toList());\n+          .map(userName -> createUser(realm, userName));\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm, int firstResult, int maxResults) {\n+    public Stream<UserModel> getUsersStream(RealmModel realm, int firstResult, int maxResults) {\n         return userPasswords.keySet().stream()\n           .sorted()\n           .skip(firstResult)\n           .limit(maxResults)\n-          .map(userName -> createUser(realm, userName))\n-          .collect(Collectors.toList());\n+          .map(userName -> createUser(realm, userName));\n     }\n \n     @Override\n-    public List<UserModel> searchForUser(String search, RealmModel realm) {\n+    public Stream<UserModel> searchForUserStream(String search, RealmModel realm) {\n         return userPasswords.keySet().stream()\n           .sorted()\n           .filter(userName -> userName.contains(search))\n-          .map(userName -> createUser(realm, userName))\n-          .collect(Collectors.toList());\n+          .map(userName -> createUser(realm, userName));\n     }\n \n     @Override\n-    public List<UserModel> searchForUser(String search, RealmModel realm, int firstResult, int maxResults) {\n+    public Stream<UserModel> searchForUserStream(String search, RealmModel realm, int firstResult, int maxResults) {\n         return userPasswords.keySet().stream()\n           .sorted()\n           .filter(userName -> userName.contains(search))\n           .skip(firstResult)", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "changed_code": [{"header": "diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\nindex 4717512ea5..dc8da1c643 100644\n--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n", "chunk": "@@ -315,12 +316,14 @@ public class UserMapStorage implements UserLookupProvider, UserStorageProvider,\n \n     @Override\n     public Stream<UserModel> searchForUserStream(String search, RealmModel realm, int firstResult, int maxResults) {\n-        return userPasswords.keySet().stream()\n-          .sorted()\n-          .filter(userName -> userName.contains(search))\n-          .skip(firstResult)\n-          .limit(maxResults)\n-          .map(userName -> createUser(realm, userName));\n+        Stream<String> userStream = userPasswords.keySet().stream()\n+                .sorted()\n+                .filter(userName -> userName.contains(search));\n+        if (firstResult > 0)\n+            userStream = userStream.skip(firstResult);\n+        if (maxResults >= 0)\n+            userStream = userStream.limit(maxResults);\n+        return userStream.map(userName -> createUser(realm, userName));\n     }\n \n     @Override\n", "next_change": null}]}, "revised_code_in_main": {"commit": "aa4673517308a2f6b8214b192eb2151554564718", "changed_code": [{"header": "diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\nindex 4717512ea5..dc8da1c643 100644\n--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n", "chunk": "@@ -315,12 +316,14 @@ public class UserMapStorage implements UserLookupProvider, UserStorageProvider,\n \n     @Override\n     public Stream<UserModel> searchForUserStream(String search, RealmModel realm, int firstResult, int maxResults) {\n-        return userPasswords.keySet().stream()\n-          .sorted()\n-          .filter(userName -> userName.contains(search))\n-          .skip(firstResult)\n-          .limit(maxResults)\n-          .map(userName -> createUser(realm, userName));\n+        Stream<String> userStream = userPasswords.keySet().stream()\n+                .sorted()\n+                .filter(userName -> userName.contains(search));\n+        if (firstResult > 0)\n+            userStream = userStream.skip(firstResult);\n+        if (maxResults >= 0)\n+            userStream = userStream.limit(maxResults);\n+        return userStream.map(userName -> createUser(realm, userName));\n     }\n \n     @Override\n", "next_change": {"commit": "8e376aef51b4b5d7ade4e5196ee628a086c1749a", "changed_code": [{"header": "diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\nindex dc8da1c643..b8d538db77 100644\n--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n", "chunk": "@@ -308,20 +307,22 @@ public class UserMapStorage implements UserLookupProvider, UserStorageProvider,\n \n     @Override\n     public Stream<UserModel> searchForUserStream(String search, RealmModel realm) {\n+        String tSearch = translateUserName(search);\n         return userPasswords.keySet().stream()\n           .sorted()\n-          .filter(userName -> userName.contains(search))\n+          .filter(userName -> translateUserName(userName).contains(tSearch))\n           .map(userName -> createUser(realm, userName));\n     }\n \n     @Override\n-    public Stream<UserModel> searchForUserStream(String search, RealmModel realm, int firstResult, int maxResults) {\n+    public Stream<UserModel> searchForUserStream(String search, RealmModel realm, Integer firstResult, Integer maxResults) {\n+        String tSearch = translateUserName(search);\n         Stream<String> userStream = userPasswords.keySet().stream()\n                 .sorted()\n-                .filter(userName -> userName.contains(search));\n-        if (firstResult > 0)\n+                .filter(userName -> translateUserName(userName).contains(search));\n+        if (firstResult != null && firstResult > 0)\n             userStream = userStream.skip(firstResult);\n-        if (maxResults >= 0)\n+        if (maxResults != null && maxResults >= 0)\n             userStream = userStream.limit(maxResults);\n         return userStream.map(userName -> createUser(realm, userName));\n     }\n", "next_change": {"commit": "ba8e2fef6b0a47727f03d58f4fe2809d6e65c017", "changed_code": [{"header": "diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\nindex b8d538db77..793509436b 100644\n--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n", "chunk": "@@ -315,25 +313,17 @@ public class UserMapStorage implements UserLookupProvider, UserStorageProvider,\n     }\n \n     @Override\n-    public Stream<UserModel> searchForUserStream(String search, RealmModel realm, Integer firstResult, Integer maxResults) {\n+    public Stream<UserModel> searchForUserStream(RealmModel realm, String search, Integer firstResult, Integer maxResults) {\n         String tSearch = translateUserName(search);\n         Stream<String> userStream = userPasswords.keySet().stream()\n                 .sorted()\n                 .filter(userName -> translateUserName(userName).contains(search));\n-        if (firstResult != null && firstResult > 0)\n-            userStream = userStream.skip(firstResult);\n-        if (maxResults != null && maxResults >= 0)\n-            userStream = userStream.limit(maxResults);\n-        return userStream.map(userName -> createUser(realm, userName));\n-    }\n \n-    @Override\n-    public Stream<UserModel> searchForUserStream(Map<String, String> params, RealmModel realm) {\n-        return searchForUserStream(params, realm, 0, Integer.MAX_VALUE - 1);\n+        return paginatedStream(userStream, firstResult, maxResults).map(userName -> createUser(realm, userName));\n     }\n \n     @Override\n-    public Stream<UserModel> searchForUserStream(Map<String, String> params, RealmModel realm, Integer firstResult, Integer maxResults) {\n+    public Stream<UserModel> searchForUserStream(RealmModel realm, Map<String, String> params, Integer firstResult, Integer maxResults) {\n         Stream<String> userStream = userPasswords.keySet().stream()\n           .sorted();\n \n", "next_change": null}]}}, {"header": "diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\nindex dc8da1c643..b8d538db77 100644\n--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n", "chunk": "@@ -332,7 +333,7 @@ public class UserMapStorage implements UserLookupProvider, UserStorageProvider,\n     }\n \n     @Override\n-    public Stream<UserModel> searchForUserStream(Map<String, String> params, RealmModel realm, int firstResult, int maxResults) {\n+    public Stream<UserModel> searchForUserStream(Map<String, String> params, RealmModel realm, Integer firstResult, Integer maxResults) {\n         Stream<String> userStream = userPasswords.keySet().stream()\n           .sorted();\n \n", "next_change": {"commit": "ba8e2fef6b0a47727f03d58f4fe2809d6e65c017", "changed_code": [{"header": "diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\nindex b8d538db77..793509436b 100644\n--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n", "chunk": "@@ -315,25 +313,17 @@ public class UserMapStorage implements UserLookupProvider, UserStorageProvider,\n     }\n \n     @Override\n-    public Stream<UserModel> searchForUserStream(String search, RealmModel realm, Integer firstResult, Integer maxResults) {\n+    public Stream<UserModel> searchForUserStream(RealmModel realm, String search, Integer firstResult, Integer maxResults) {\n         String tSearch = translateUserName(search);\n         Stream<String> userStream = userPasswords.keySet().stream()\n                 .sorted()\n                 .filter(userName -> translateUserName(userName).contains(search));\n-        if (firstResult != null && firstResult > 0)\n-            userStream = userStream.skip(firstResult);\n-        if (maxResults != null && maxResults >= 0)\n-            userStream = userStream.limit(maxResults);\n-        return userStream.map(userName -> createUser(realm, userName));\n-    }\n \n-    @Override\n-    public Stream<UserModel> searchForUserStream(Map<String, String> params, RealmModel realm) {\n-        return searchForUserStream(params, realm, 0, Integer.MAX_VALUE - 1);\n+        return paginatedStream(userStream, firstResult, maxResults).map(userName -> createUser(realm, userName));\n     }\n \n     @Override\n-    public Stream<UserModel> searchForUserStream(Map<String, String> params, RealmModel realm, Integer firstResult, Integer maxResults) {\n+    public Stream<UserModel> searchForUserStream(RealmModel realm, Map<String, String> params, Integer firstResult, Integer maxResults) {\n         Stream<String> userStream = userPasswords.keySet().stream()\n           .sorted();\n \n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "aa4673517308a2f6b8214b192eb2151554564718", "message": "Merge commit", "committedDate": null}, {"oid": "84df008bc2173df12b6cbfa58047ebc120d1f413", "committedDate": "2020-11-18 21:07:51 +0100", "message": "[KEYCLOAK-16341] Make the new stream-based methods in server-spi user interfaces default instead of the collection-based versions.  - this ensures that providing implementation for the collection-based methods is enough, which preserves    backwards compatibility with older custom implementations.  - alternative interfaces now allow new implementations to focus on the stream variants of the query methods."}, {"oid": "edef93cd491e545de642fd39d0df0a53cecee830", "committedDate": "2020-12-07 19:48:35 +0100", "message": "[KEYCLOAK-16232] Streamify the UserCredentialStore and UserCredentialManager interfaces"}, {"oid": "8c0c542f09bcc6fa165f7868a1097d64fc4f38d7", "committedDate": "2020-12-07 20:54:06 +0100", "message": "KEYCLOAK-16489 Add ability to run model tests with LDAP"}, {"oid": "8e376aef51b4b5d7ade4e5196ee628a086c1749a", "committedDate": "2020-12-10 08:57:53 +0100", "message": "KEYCLOAK-15847 Add MapUserProvider"}, {"oid": "ba8e2fef6b0a47727f03d58f4fe2809d6e65c017", "committedDate": "2021-01-18 16:56:10 +0100", "message": "KEYCLOAK-15524 Cleanup user related interfaces"}, {"oid": "9f580e3ed868223a7d5c3d59481e5f9535a9e163", "committedDate": "2021-01-20 14:39:53 +0100", "message": "KEYCLOAK-15695 Streamification cleanup"}, {"oid": "a0f8d2bc0eadd0e8da54fbf8828d330032deb94f", "committedDate": "2021-05-20 08:44:24 -0300", "message": "[KEYCLOAK-17399] - Review User Profile SPI"}, {"oid": "bc8fd21dc6495b7f43f3466eb3545055753114ae", "committedDate": "2022-06-21 08:53:06 +0200", "message": "SingleUserCredentialManager moving in - UserStorageManager now handles authentication for old Kerberos+LDAP style - new getUserByCredential method in MapUserProvider would eventually do the same."}, {"oid": "e396d0daa1fed0cb82cf761fe3b461ba24118a10", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Renaming SingleUserCredentialManager and UserModel.getUserCredentialManager(): - class SingleUserCredentialManager to SingleEntityCredentialManager - method UserModel.getUserCredentialManager() to credentialManager()"}, {"oid": "1bc6133e4ecee8f4ebd9b10f8f92d0fca4e11d8e", "committedDate": "2022-06-21 08:53:06 +0200", "message": "redirect calls to userLocalStorage from legacy modules (federation, ldap, sssd, kerberos)"}, {"oid": "1a227212deaf7b933cebc0100cb44871644c7ee5", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Simplify implementation of a federated storage by moving the default implementation to the abstract base class; this will also allow the quickstarts and implementations derived from that to run without changes."}, {"oid": "d41764b19bbb682b187f37a60b71de9a6eb7d612", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Inline deprecated methods in legacy code"}, {"oid": "cb0c88182148fd352969383a33f2eeb56cc4de9f", "committedDate": "2022-06-21 08:53:06 +0200", "message": "rename SingleEntityCredentialManager to SubjectCredentialManager"}, {"oid": "f49582cf63db5b83b399e43a1530b06b18edfad4", "committedDate": "2022-10-14 09:32:38 +0200", "message": "MapUserProvider in KC20 needs to store username compatible with KC19 to be no-downtime-upgradable"}, {"oid": "883e83e62540168593046e34292849e16c009760", "committedDate": "2022-10-25 09:01:33 +0200", "message": "Remove deprecated methods from data providers and models"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk2MTQyNA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511961424", "body": "Negative number in skip.", "bodyText": "Negative number in skip.", "bodyHTML": "<p dir=\"auto\">Negative number in skip.</p>", "author": "martin-kanis", "createdAt": "2020-10-26T13:33:02Z", "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java", "diffHunk": "@@ -361,30 +355,27 @@ public int getUsersCount(RealmModel realm) {\n         return userStream\n           .skip(firstResult)", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "changed_code": [{"header": "diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\nindex 4717512ea5..dc8da1c643 100644\n--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n", "chunk": "@@ -352,10 +355,11 @@ public class UserMapStorage implements UserLookupProvider, UserStorageProvider,\n             }\n         }\n \n-        return userStream\n-          .skip(firstResult)\n-          .limit(maxResults)\n-          .map(userName -> createUser(realm, userName));\n+        if (firstResult > 0)\n+            userStream = userStream.skip(firstResult);\n+        if (maxResults >= 0)\n+            userStream = userStream.limit(maxResults);\n+        return userStream.map(userName -> createUser(realm, userName));\n     }\n \n     @Override\n", "next_change": null}]}, "revised_code_in_main": {"commit": "aa4673517308a2f6b8214b192eb2151554564718", "changed_code": [{"header": "diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\nindex 4717512ea5..dc8da1c643 100644\n--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n", "chunk": "@@ -352,10 +355,11 @@ public class UserMapStorage implements UserLookupProvider, UserStorageProvider,\n             }\n         }\n \n-        return userStream\n-          .skip(firstResult)\n-          .limit(maxResults)\n-          .map(userName -> createUser(realm, userName));\n+        if (firstResult > 0)\n+            userStream = userStream.skip(firstResult);\n+        if (maxResults >= 0)\n+            userStream = userStream.limit(maxResults);\n+        return userStream.map(userName -> createUser(realm, userName));\n     }\n \n     @Override\n", "next_change": {"commit": "8e376aef51b4b5d7ade4e5196ee628a086c1749a", "changed_code": [{"header": "diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\nindex dc8da1c643..b8d538db77 100644\n--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n", "chunk": "@@ -355,15 +356,15 @@ public class UserMapStorage implements UserLookupProvider, UserStorageProvider,\n             }\n         }\n \n-        if (firstResult > 0)\n+        if (firstResult != null && firstResult > 0)\n             userStream = userStream.skip(firstResult);\n-        if (maxResults >= 0)\n+        if (maxResults != null && maxResults >= 0)\n             userStream = userStream.limit(maxResults);\n         return userStream.map(userName -> createUser(realm, userName));\n     }\n \n     @Override\n-    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, Integer firstResult, Integer maxResults) {\n         return getMembershipStream(realm, group, firstResult, maxResults)\n           .map(userName -> createUser(realm, userName));\n     }\n", "next_change": {"commit": "ba8e2fef6b0a47727f03d58f4fe2809d6e65c017", "changed_code": [{"header": "diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\nindex b8d538db77..793509436b 100644\n--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n", "chunk": "@@ -356,28 +346,19 @@ public class UserMapStorage implements UserLookupProvider, UserStorageProvider,\n             }\n         }\n \n-        if (firstResult != null && firstResult > 0)\n-            userStream = userStream.skip(firstResult);\n-        if (maxResults != null && maxResults >= 0)\n-            userStream = userStream.limit(maxResults);\n-        return userStream.map(userName -> createUser(realm, userName));\n+        return paginatedStream(userStream, firstResult, maxResults).map(userName -> createUser(realm, userName));\n     }\n \n     @Override\n     public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, Integer firstResult, Integer maxResults) {\n-        return getMembershipStream(realm, group, firstResult, maxResults)\n+        return getMembershipStream(realm, group, firstResult == null ? -1 : firstResult, maxResults == null ? -1 : maxResults)\n           .map(userName -> createUser(realm, userName));\n     }\n \n     @Override\n-    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group) {\n-        return getGroupMembersStream(realm, group, 0, Integer.MAX_VALUE - 1);\n-    }\n-\n-    @Override\n-    public Stream<UserModel> searchForUserByUserAttributeStream(String attrName, String attrValue, RealmModel realm) {\n+    public Stream<UserModel> searchForUserByUserAttributeStream(RealmModel realm, String attrName, String attrValue) {\n         if (isImportEnabled()) {\n-            return session.userLocalStorage().searchForUserByUserAttributeStream(attrName, attrValue, realm);\n+            return session.userLocalStorage().searchForUserByUserAttributeStream(realm, attrName, attrValue);\n         } else {\n             return session.userFederatedStorage().getUsersByUserAttributeStream(realm, attrName, attrValue)\n               .map(userName -> createUser(realm, userName));\n", "next_change": {"commit": "1bc6133e4ecee8f4ebd9b10f8f92d0fca4e11d8e", "changed_code": [{"header": "diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\nindex 793509436b..87cf3a9660 100644\n--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n", "chunk": "@@ -358,7 +367,7 @@ public class UserMapStorage implements UserLookupProvider.Streams, UserStoragePr\n     @Override\n     public Stream<UserModel> searchForUserByUserAttributeStream(RealmModel realm, String attrName, String attrValue) {\n         if (isImportEnabled()) {\n-            return session.userLocalStorage().searchForUserByUserAttributeStream(realm, attrName, attrValue);\n+            return UserStoragePrivateUtil.userLocalStorage(session).searchForUserByUserAttributeStream(realm, attrName, attrValue);\n         } else {\n             return session.userFederatedStorage().getUsersByUserAttributeStream(realm, attrName, attrValue)\n               .map(userName -> createUser(realm, userName));\n", "next_change": {"commit": "d41764b19bbb682b187f37a60b71de9a6eb7d612", "changed_code": [{"header": "diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\nindex 87cf3a9660..131024e138 100644\n--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n", "chunk": "@@ -369,7 +365,7 @@ public class UserMapStorage implements UserLookupProvider.Streams, UserStoragePr\n         if (isImportEnabled()) {\n             return UserStoragePrivateUtil.userLocalStorage(session).searchForUserByUserAttributeStream(realm, attrName, attrValue);\n         } else {\n-            return session.userFederatedStorage().getUsersByUserAttributeStream(realm, attrName, attrValue)\n+            return UserStorageUtil.userFederatedStorage(session).getUsersByUserAttributeStream(realm, attrName, attrValue)\n               .map(userName -> createUser(realm, userName));\n         }\n     }\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "aa4673517308a2f6b8214b192eb2151554564718", "message": "Merge commit", "committedDate": null}, {"oid": "84df008bc2173df12b6cbfa58047ebc120d1f413", "committedDate": "2020-11-18 21:07:51 +0100", "message": "[KEYCLOAK-16341] Make the new stream-based methods in server-spi user interfaces default instead of the collection-based versions.  - this ensures that providing implementation for the collection-based methods is enough, which preserves    backwards compatibility with older custom implementations.  - alternative interfaces now allow new implementations to focus on the stream variants of the query methods."}, {"oid": "edef93cd491e545de642fd39d0df0a53cecee830", "committedDate": "2020-12-07 19:48:35 +0100", "message": "[KEYCLOAK-16232] Streamify the UserCredentialStore and UserCredentialManager interfaces"}, {"oid": "8c0c542f09bcc6fa165f7868a1097d64fc4f38d7", "committedDate": "2020-12-07 20:54:06 +0100", "message": "KEYCLOAK-16489 Add ability to run model tests with LDAP"}, {"oid": "8e376aef51b4b5d7ade4e5196ee628a086c1749a", "committedDate": "2020-12-10 08:57:53 +0100", "message": "KEYCLOAK-15847 Add MapUserProvider"}, {"oid": "ba8e2fef6b0a47727f03d58f4fe2809d6e65c017", "committedDate": "2021-01-18 16:56:10 +0100", "message": "KEYCLOAK-15524 Cleanup user related interfaces"}, {"oid": "9f580e3ed868223a7d5c3d59481e5f9535a9e163", "committedDate": "2021-01-20 14:39:53 +0100", "message": "KEYCLOAK-15695 Streamification cleanup"}, {"oid": "a0f8d2bc0eadd0e8da54fbf8828d330032deb94f", "committedDate": "2021-05-20 08:44:24 -0300", "message": "[KEYCLOAK-17399] - Review User Profile SPI"}, {"oid": "bc8fd21dc6495b7f43f3466eb3545055753114ae", "committedDate": "2022-06-21 08:53:06 +0200", "message": "SingleUserCredentialManager moving in - UserStorageManager now handles authentication for old Kerberos+LDAP style - new getUserByCredential method in MapUserProvider would eventually do the same."}, {"oid": "e396d0daa1fed0cb82cf761fe3b461ba24118a10", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Renaming SingleUserCredentialManager and UserModel.getUserCredentialManager(): - class SingleUserCredentialManager to SingleEntityCredentialManager - method UserModel.getUserCredentialManager() to credentialManager()"}, {"oid": "1bc6133e4ecee8f4ebd9b10f8f92d0fca4e11d8e", "committedDate": "2022-06-21 08:53:06 +0200", "message": "redirect calls to userLocalStorage from legacy modules (federation, ldap, sssd, kerberos)"}, {"oid": "1a227212deaf7b933cebc0100cb44871644c7ee5", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Simplify implementation of a federated storage by moving the default implementation to the abstract base class; this will also allow the quickstarts and implementations derived from that to run without changes."}, {"oid": "d41764b19bbb682b187f37a60b71de9a6eb7d612", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Inline deprecated methods in legacy code"}, {"oid": "cb0c88182148fd352969383a33f2eeb56cc4de9f", "committedDate": "2022-06-21 08:53:06 +0200", "message": "rename SingleEntityCredentialManager to SubjectCredentialManager"}, {"oid": "f49582cf63db5b83b399e43a1530b06b18edfad4", "committedDate": "2022-10-14 09:32:38 +0200", "message": "MapUserProvider in KC20 needs to store username compatible with KC19 to be no-downtime-upgradable"}, {"oid": "883e83e62540168593046e34292849e16c009760", "committedDate": "2022-10-25 09:01:33 +0200", "message": "Remove deprecated methods from data providers and models"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk2MjM1OA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511962358", "body": "Negative number in skip.", "bodyText": "Negative number in skip.", "bodyHTML": "<p dir=\"auto\">Negative number in skip.</p>", "author": "martin-kanis", "createdAt": "2020-10-26T13:34:20Z", "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java", "diffHunk": "@@ -412,15 +403,14 @@ public void leaveGroup(RealmModel realm, String userId, GroupModel group) {\n     }\n \n     @Override\n-    public List<String> getMembership(RealmModel realm, GroupModel group, int firstResult, int max) {\n+    public Stream<String> getMembershipStream(RealmModel realm, GroupModel group, int firstResult, int max) {\n         return userGroups.entrySet().stream()\n           .filter(me -> me.getValue().contains(group.getId()))\n           .map(Map.Entry::getKey)\n           .filter(realmUser -> realmUser.startsWith(realm.getId()))\n           .map(realmUser -> realmUser.substring(realmUser.indexOf(\"/\") + 1))\n           .skip(firstResult)", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "changed_code": [{"header": "diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\nindex 4717512ea5..dc8da1c643 100644\n--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n", "chunk": "@@ -404,13 +408,16 @@ public class UserMapStorage implements UserLookupProvider, UserStorageProvider,\n \n     @Override\n     public Stream<String> getMembershipStream(RealmModel realm, GroupModel group, int firstResult, int max) {\n-        return userGroups.entrySet().stream()\n+        Stream<String> userStream = userGroups.entrySet().stream()\n           .filter(me -> me.getValue().contains(group.getId()))\n           .map(Map.Entry::getKey)\n           .filter(realmUser -> realmUser.startsWith(realm.getId()))\n-          .map(realmUser -> realmUser.substring(realmUser.indexOf(\"/\") + 1))\n-          .skip(firstResult)\n-          .limit(max);\n+          .map(realmUser -> realmUser.substring(realmUser.indexOf(\"/\") + 1));\n+        if (firstResult > 0)\n+            userStream = userStream.skip(firstResult);\n+        if (max >= 0)\n+            userStream = userStream.limit(max);\n+        return userStream;\n     }\n \n     @Override\n", "next_change": null}]}, "revised_code_in_main": {"commit": "aa4673517308a2f6b8214b192eb2151554564718", "changed_code": [{"header": "diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\nindex 4717512ea5..dc8da1c643 100644\n--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n", "chunk": "@@ -404,13 +408,16 @@ public class UserMapStorage implements UserLookupProvider, UserStorageProvider,\n \n     @Override\n     public Stream<String> getMembershipStream(RealmModel realm, GroupModel group, int firstResult, int max) {\n-        return userGroups.entrySet().stream()\n+        Stream<String> userStream = userGroups.entrySet().stream()\n           .filter(me -> me.getValue().contains(group.getId()))\n           .map(Map.Entry::getKey)\n           .filter(realmUser -> realmUser.startsWith(realm.getId()))\n-          .map(realmUser -> realmUser.substring(realmUser.indexOf(\"/\") + 1))\n-          .skip(firstResult)\n-          .limit(max);\n+          .map(realmUser -> realmUser.substring(realmUser.indexOf(\"/\") + 1));\n+        if (firstResult > 0)\n+            userStream = userStream.skip(firstResult);\n+        if (max >= 0)\n+            userStream = userStream.limit(max);\n+        return userStream;\n     }\n \n     @Override\n", "next_change": {"commit": "8c0c542f09bcc6fa165f7868a1097d64fc4f38d7", "changed_code": [{"header": "diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\nindex dc8da1c643..9a40a1854b 100644\n--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n", "chunk": "@@ -422,11 +423,15 @@ public class UserMapStorage implements UserLookupProvider, UserStorageProvider,\n \n     @Override\n     public UserModel validate(RealmModel realm, UserModel local) {\n-        final boolean userExists = userPasswords.containsKey(local.getUsername());\n+        final boolean userExists = userPasswords.containsKey(translateUserName(local.getUsername()));\n         if (! userExists) {\n             userGroups.remove(getUserIdInMap(realm, local.getUsername()));\n         }\n         return userExists ? local : null;\n     }\n \n+    private static String translateUserName(String userName) {\n+        return userName == null ? null : userName.toLowerCase();\n+    }\n+\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "aa4673517308a2f6b8214b192eb2151554564718", "message": "Merge commit", "committedDate": null}, {"oid": "84df008bc2173df12b6cbfa58047ebc120d1f413", "committedDate": "2020-11-18 21:07:51 +0100", "message": "[KEYCLOAK-16341] Make the new stream-based methods in server-spi user interfaces default instead of the collection-based versions.  - this ensures that providing implementation for the collection-based methods is enough, which preserves    backwards compatibility with older custom implementations.  - alternative interfaces now allow new implementations to focus on the stream variants of the query methods."}, {"oid": "edef93cd491e545de642fd39d0df0a53cecee830", "committedDate": "2020-12-07 19:48:35 +0100", "message": "[KEYCLOAK-16232] Streamify the UserCredentialStore and UserCredentialManager interfaces"}, {"oid": "8c0c542f09bcc6fa165f7868a1097d64fc4f38d7", "committedDate": "2020-12-07 20:54:06 +0100", "message": "KEYCLOAK-16489 Add ability to run model tests with LDAP"}, {"oid": "8e376aef51b4b5d7ade4e5196ee628a086c1749a", "committedDate": "2020-12-10 08:57:53 +0100", "message": "KEYCLOAK-15847 Add MapUserProvider"}, {"oid": "ba8e2fef6b0a47727f03d58f4fe2809d6e65c017", "committedDate": "2021-01-18 16:56:10 +0100", "message": "KEYCLOAK-15524 Cleanup user related interfaces"}, {"oid": "9f580e3ed868223a7d5c3d59481e5f9535a9e163", "committedDate": "2021-01-20 14:39:53 +0100", "message": "KEYCLOAK-15695 Streamification cleanup"}, {"oid": "a0f8d2bc0eadd0e8da54fbf8828d330032deb94f", "committedDate": "2021-05-20 08:44:24 -0300", "message": "[KEYCLOAK-17399] - Review User Profile SPI"}, {"oid": "bc8fd21dc6495b7f43f3466eb3545055753114ae", "committedDate": "2022-06-21 08:53:06 +0200", "message": "SingleUserCredentialManager moving in - UserStorageManager now handles authentication for old Kerberos+LDAP style - new getUserByCredential method in MapUserProvider would eventually do the same."}, {"oid": "e396d0daa1fed0cb82cf761fe3b461ba24118a10", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Renaming SingleUserCredentialManager and UserModel.getUserCredentialManager(): - class SingleUserCredentialManager to SingleEntityCredentialManager - method UserModel.getUserCredentialManager() to credentialManager()"}, {"oid": "1bc6133e4ecee8f4ebd9b10f8f92d0fca4e11d8e", "committedDate": "2022-06-21 08:53:06 +0200", "message": "redirect calls to userLocalStorage from legacy modules (federation, ldap, sssd, kerberos)"}, {"oid": "1a227212deaf7b933cebc0100cb44871644c7ee5", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Simplify implementation of a federated storage by moving the default implementation to the abstract base class; this will also allow the quickstarts and implementations derived from that to run without changes."}, {"oid": "d41764b19bbb682b187f37a60b71de9a6eb7d612", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Inline deprecated methods in legacy code"}, {"oid": "cb0c88182148fd352969383a33f2eeb56cc4de9f", "committedDate": "2022-06-21 08:53:06 +0200", "message": "rename SingleEntityCredentialManager to SubjectCredentialManager"}, {"oid": "f49582cf63db5b83b399e43a1530b06b18edfad4", "committedDate": "2022-10-14 09:32:38 +0200", "message": "MapUserProvider in KC20 needs to store username compatible with KC19 to be no-downtime-upgradable"}, {"oid": "883e83e62540168593046e34292849e16c009760", "committedDate": "2022-10-25 09:01:33 +0200", "message": "Remove deprecated methods from data providers and models"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk3MzYxOQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511973619", "body": "What \"-1\" in `maxResults` actually should achieve? If that means we don't want limit number of results shouldn't we use `Integer.MAX_VALUE - 1` ? Not sure if `limit(0)` will do the same. \r\nIf \"-1\" means I don't want any results (which doesn't make sense to me :D ) then it's, I guess correct.", "bodyText": "What \"-1\" in maxResults actually should achieve? If that means we don't want limit number of results shouldn't we use Integer.MAX_VALUE - 1 ? Not sure if limit(0) will do the same.\nIf \"-1\" means I don't want any results (which doesn't make sense to me :D ) then it's, I guess correct.", "bodyHTML": "<p dir=\"auto\">What \"-1\" in <code>maxResults</code> actually should achieve? If that means we don't want limit number of results shouldn't we use <code>Integer.MAX_VALUE - 1</code> ? Not sure if <code>limit(0)</code> will do the same.<br>\nIf \"-1\" means I don't want any results (which doesn't make sense to me :D ) then it's, I guess correct.</p>", "author": "martin-kanis", "createdAt": "2020-10-26T13:50:09Z", "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserPropertyFileStorage.java", "diffHunk": "@@ -146,88 +144,64 @@ public int getUsersCount(RealmModel realm) {\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm) {\n-        List<UserModel> users = new LinkedList<>();\n-        for (Object username : userPasswords.keySet()) {\n-            users.add(createUser(realm, (String)username));\n-        }\n-        return users;\n+    public Stream<UserModel> getUsersStream(RealmModel realm) {\n+        return userPasswords.keySet().stream().map(obj -> createUser(realm, (String) obj));\n     }\n \n     @Override\n-    public List<UserModel> searchForUser(Map<String, String> attributes, RealmModel realm) {\n-        return searchForUser(attributes, realm, 0, Integer.MAX_VALUE - 1);\n+    public Stream<UserModel> searchForUserStream(Map<String, String> attributes, RealmModel realm) {\n+        return searchForUserStream(attributes, realm, 0, Integer.MAX_VALUE - 1);\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm, int firstResult, int maxResults) {\n-        if (maxResults == 0) return Collections.EMPTY_LIST;\n-        List<UserModel> users = new LinkedList<>();\n-        int count = 0;\n-        for (Object un : userPasswords.keySet()) {\n-            if (count++ < firstResult) continue;\n-            String username = (String)un;\n-            users.add(createUser(realm, username));\n-            if (users.size() + 1 > maxResults) break;\n-        }\n-        return users;\n+    public Stream<UserModel> getUsersStream(RealmModel realm, int firstResult, int maxResults) {\n+        return userPasswords.keySet().stream().skip(firstResult < 0 ? 0 : firstResult).limit(maxResults < 0 ? 0 : maxResults)", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk4NzQwNQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511987405", "bodyText": "I will have to check this again, this is a very good point.", "author": "sguilhen", "createdAt": "2020-10-26T14:08:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk3MzYxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "changed_code": [{"header": "diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserPropertyFileStorage.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserPropertyFileStorage.java\nindex 5d0dfa07df..dd8ba1594e 100644\n--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserPropertyFileStorage.java\n+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserPropertyFileStorage.java\n", "chunk": "@@ -155,8 +155,12 @@ public class UserPropertyFileStorage implements UserLookupProvider, UserStorageP\n \n     @Override\n     public Stream<UserModel> getUsersStream(RealmModel realm, int firstResult, int maxResults) {\n-        return userPasswords.keySet().stream().skip(firstResult < 0 ? 0 : firstResult).limit(maxResults < 0 ? 0 : maxResults)\n-                .map(obj -> createUser(realm, (String) obj));\n+        Stream<Object> stream = userPasswords.keySet().stream();\n+        if (firstResult > 0)\n+            stream = stream.skip(firstResult);\n+        if (maxResults >= 0)\n+            stream = stream.limit(maxResults);\n+        return stream.map(obj -> createUser(realm, (String) obj));\n     }\n \n     @Override\n", "next_change": null}]}, "revised_code_in_main": {"commit": "aa4673517308a2f6b8214b192eb2151554564718", "changed_code": [{"header": "diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserPropertyFileStorage.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserPropertyFileStorage.java\nindex 5d0dfa07df..dd8ba1594e 100644\n--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserPropertyFileStorage.java\n+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserPropertyFileStorage.java\n", "chunk": "@@ -155,8 +155,12 @@ public class UserPropertyFileStorage implements UserLookupProvider, UserStorageP\n \n     @Override\n     public Stream<UserModel> getUsersStream(RealmModel realm, int firstResult, int maxResults) {\n-        return userPasswords.keySet().stream().skip(firstResult < 0 ? 0 : firstResult).limit(maxResults < 0 ? 0 : maxResults)\n-                .map(obj -> createUser(realm, (String) obj));\n+        Stream<Object> stream = userPasswords.keySet().stream();\n+        if (firstResult > 0)\n+            stream = stream.skip(firstResult);\n+        if (maxResults >= 0)\n+            stream = stream.limit(maxResults);\n+        return stream.map(obj -> createUser(realm, (String) obj));\n     }\n \n     @Override\n", "next_change": {"commit": "84df008bc2173df12b6cbfa58047ebc120d1f413", "changed_code": [{"header": "diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserPropertyFileStorage.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserPropertyFileStorage.java\nindex dd8ba1594e..25eabfc4b0 100644\n--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserPropertyFileStorage.java\n+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserPropertyFileStorage.java\n", "chunk": "@@ -144,59 +145,67 @@ public class UserPropertyFileStorage implements UserLookupProvider, UserStorageP\n     }\n \n     @Override\n-    public Stream<UserModel> getUsersStream(RealmModel realm) {\n-        return userPasswords.keySet().stream().map(obj -> createUser(realm, (String) obj));\n+    public List<UserModel> getUsers(RealmModel realm) {\n+        List<UserModel> users = new LinkedList<>();\n+        for (Object username : userPasswords.keySet()) {\n+            users.add(createUser(realm, (String)username));\n+        }\n+        return users;\n     }\n \n     @Override\n-    public Stream<UserModel> searchForUserStream(Map<String, String> attributes, RealmModel realm) {\n-        return searchForUserStream(attributes, realm, 0, Integer.MAX_VALUE - 1);\n+    public List<UserModel> searchForUser(Map<String, String> attributes, RealmModel realm) {\n+        return searchForUser(attributes, realm, 0, Integer.MAX_VALUE - 1);\n     }\n \n     @Override\n-    public Stream<UserModel> getUsersStream(RealmModel realm, int firstResult, int maxResults) {\n-        Stream<Object> stream = userPasswords.keySet().stream();\n-        if (firstResult > 0)\n-            stream = stream.skip(firstResult);\n-        if (maxResults >= 0)\n-            stream = stream.limit(maxResults);\n-        return stream.map(obj -> createUser(realm, (String) obj));\n+    public List<UserModel> getUsers(RealmModel realm, int firstResult, int maxResults) {\n+        if (maxResults == 0) return Collections.EMPTY_LIST;\n+        List<UserModel> users = new LinkedList<>();\n+        int count = 0;\n+        for (Object un : userPasswords.keySet()) {\n+            if (count++ < firstResult) continue;\n+            String username = (String)un;\n+            users.add(createUser(realm, username));\n+            if (users.size() + 1 > maxResults) break;\n+        }\n+        return users;\n     }\n \n     @Override\n-    public Stream<UserModel> searchForUserStream(String search, RealmModel realm, int firstResult, int maxResults) {\n-        return searchForUserStream(search, realm, firstResult, maxResults, username -> username.contains(search));\n+    public List<UserModel> searchForUser(String search, RealmModel realm, int firstResult, int maxResults) {\n+        return searchForUser(search, realm, firstResult, maxResults, username -> username.contains(search));\n     }\n \n     @Override\n-    public Stream<UserModel> searchForUserStream(Map<String, String> attributes, RealmModel realm, int firstResult, int maxResults) {\n+    public List<UserModel> searchForUser(Map<String, String> attributes, RealmModel realm, int firstResult, int maxResults) {\n         String search = Optional.ofNullable(attributes.get(UserModel.USERNAME))\n                 .orElseGet(()-> attributes.get(UserModel.SEARCH));\n-        if (search == null) return Stream.empty();\n+        if (search == null) return Collections.EMPTY_LIST;\n         Predicate<String> p = Boolean.valueOf(attributes.getOrDefault(UserModel.EXACT, Boolean.FALSE.toString()))\n-            ? username -> username.equals(search)\n-            : username -> username.contains(search);\n-        return searchForUserStream(search, realm, firstResult, maxResults, p);\n+                ? username -> username.equals(search)\n+                : username -> username.contains(search);\n+        return searchForUser(search, realm, firstResult, maxResults, p);\n     }\n \n     @Override\n-    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n-        return Stream.empty();\n+    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n+        return Collections.EMPTY_LIST;\n     }\n \n     @Override\n-    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group) {\n-        return Stream.empty();\n+    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group) {\n+        return Collections.EMPTY_LIST;\n     }\n \n     @Override\n-    public Stream<UserModel> searchForUserStream(String search, RealmModel realm) {\n-        return searchForUserStream(search, realm, 0, Integer.MAX_VALUE - 1);\n+    public List<UserModel> searchForUser(String search, RealmModel realm) {\n+        return searchForUser(search, realm, 0, Integer.MAX_VALUE - 1);\n     }\n \n     @Override\n-    public Stream<UserModel> searchForUserByUserAttributeStream(String attrName, String attrValue, RealmModel realm) {\n-        return Stream.empty();\n+    public List<UserModel> searchForUserByUserAttribute(String attrName, String attrValue, RealmModel realm) {\n+        return Collections.EMPTY_LIST;\n     }\n \n     @Override\n", "next_change": {"commit": "ba8e2fef6b0a47727f03d58f4fe2809d6e65c017", "changed_code": [{"header": "diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserPropertyFileStorage.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserPropertyFileStorage.java\nindex 25eabfc4b0..5e14a36822 100644\n--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserPropertyFileStorage.java\n+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserPropertyFileStorage.java\n", "chunk": "@@ -145,67 +148,47 @@ public class UserPropertyFileStorage implements UserLookupProvider, UserStorageP\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm) {\n-        List<UserModel> users = new LinkedList<>();\n-        for (Object username : userPasswords.keySet()) {\n-            users.add(createUser(realm, (String)username));\n-        }\n-        return users;\n-    }\n-\n-    @Override\n-    public List<UserModel> searchForUser(Map<String, String> attributes, RealmModel realm) {\n-        return searchForUser(attributes, realm, 0, Integer.MAX_VALUE - 1);\n+    public Stream<UserModel> getUsersStream(RealmModel realm) {\n+        return userPasswords.keySet().stream()\n+                .map(username -> createUser(realm, (String) username));\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm, int firstResult, int maxResults) {\n-        if (maxResults == 0) return Collections.EMPTY_LIST;\n-        List<UserModel> users = new LinkedList<>();\n-        int count = 0;\n-        for (Object un : userPasswords.keySet()) {\n-            if (count++ < firstResult) continue;\n-            String username = (String)un;\n-            users.add(createUser(realm, username));\n-            if (users.size() + 1 > maxResults) break;\n-        }\n-        return users;\n+    public Stream<UserModel> getUsersStream(RealmModel realm, Integer firstResult, Integer maxResults) {\n+        if (maxResults != null && maxResults == 0) return Stream.empty();\n+        return paginatedStream(userPasswords.keySet().stream(), firstResult, maxResults)\n+                .map(username -> createUser(realm, (String) username));\n     }\n \n     @Override\n-    public List<UserModel> searchForUser(String search, RealmModel realm, int firstResult, int maxResults) {\n-        return searchForUser(search, realm, firstResult, maxResults, username -> username.contains(search));\n+    public Stream<UserModel> searchForUserStream(RealmModel realm, String search, Integer firstResult, Integer maxResults) {\n+        return searchForUser(realm, search, firstResult, maxResults, username -> username.contains(search));\n     }\n \n     @Override\n-    public List<UserModel> searchForUser(Map<String, String> attributes, RealmModel realm, int firstResult, int maxResults) {\n+    public Stream<UserModel> searchForUserStream(RealmModel realm, Map<String, String> attributes, Integer firstResult, Integer maxResults) {\n         String search = Optional.ofNullable(attributes.get(UserModel.USERNAME))\n                 .orElseGet(()-> attributes.get(UserModel.SEARCH));\n-        if (search == null) return Collections.EMPTY_LIST;\n+        if (search == null) return Stream.empty();\n         Predicate<String> p = Boolean.valueOf(attributes.getOrDefault(UserModel.EXACT, Boolean.FALSE.toString()))\n                 ? username -> username.equals(search)\n                 : username -> username.contains(search);\n-        return searchForUser(search, realm, firstResult, maxResults, p);\n+        return searchForUser(realm, search, firstResult, maxResults, p);\n     }\n \n     @Override\n-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n-        return Collections.EMPTY_LIST;\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, Integer firstResult, Integer maxResults) {\n+        return Stream.empty();\n     }\n \n     @Override\n-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group) {\n-        return Collections.EMPTY_LIST;\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group) {\n+        return Stream.empty();\n     }\n \n     @Override\n-    public List<UserModel> searchForUser(String search, RealmModel realm) {\n-        return searchForUser(search, realm, 0, Integer.MAX_VALUE - 1);\n-    }\n-\n-    @Override\n-    public List<UserModel> searchForUserByUserAttribute(String attrName, String attrValue, RealmModel realm) {\n-        return Collections.EMPTY_LIST;\n+    public Stream<UserModel> searchForUserByUserAttributeStream(RealmModel realm, String attrName, String attrValue) {\n+        return Stream.empty();\n     }\n \n     @Override\n", "next_change": null}, {"header": "diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserPropertyFileStorage.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserPropertyFileStorage.java\nindex 25eabfc4b0..5e14a36822 100644\n--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserPropertyFileStorage.java\n+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserPropertyFileStorage.java\n", "chunk": "@@ -213,20 +196,11 @@ public class UserPropertyFileStorage implements UserLookupProvider, UserStorageP\n \n     }\n \n-    private List<UserModel> searchForUser(String search, RealmModel realm, int firstResult, int maxResults, Predicate<String> matcher) {\n-        if (maxResults == 0) return Collections.EMPTY_LIST;\n-        List<UserModel> users = new LinkedList<>();\n-        int count = 0;\n-        for (Object un : userPasswords.keySet()) {\n-            String username = (String)un;\n-            if (matcher.test(username)) {\n-                if (count++ < firstResult) {\n-                    continue;\n-                }\n-                users.add(createUser(realm, username));\n-                if (users.size() + 1 > maxResults) break;\n-            }\n-        }\n-        return users;\n+    private Stream<UserModel> searchForUser(RealmModel realm, String search, Integer firstResult, Integer maxResults, Predicate<String> matcher) {\n+        if (maxResults != null && maxResults == 0) return Stream.empty();\n+        return paginatedStream(userPasswords.keySet().stream(), firstResult, maxResults)\n+                .map(String.class::cast)\n+                .filter(matcher)\n+                .map(username -> createUser(realm, username));\n     }\n }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "aa4673517308a2f6b8214b192eb2151554564718", "message": "Merge commit", "committedDate": null}, {"oid": "84df008bc2173df12b6cbfa58047ebc120d1f413", "committedDate": "2020-11-18 21:07:51 +0100", "message": "[KEYCLOAK-16341] Make the new stream-based methods in server-spi user interfaces default instead of the collection-based versions.  - this ensures that providing implementation for the collection-based methods is enough, which preserves    backwards compatibility with older custom implementations.  - alternative interfaces now allow new implementations to focus on the stream variants of the query methods."}, {"oid": "ba8e2fef6b0a47727f03d58f4fe2809d6e65c017", "committedDate": "2021-01-18 16:56:10 +0100", "message": "KEYCLOAK-15524 Cleanup user related interfaces"}, {"oid": "9f580e3ed868223a7d5c3d59481e5f9535a9e163", "committedDate": "2021-01-20 14:39:53 +0100", "message": "KEYCLOAK-15695 Streamification cleanup"}, {"oid": "f37a24dd91ca2768d478cf735bbf99d041ed58b9", "committedDate": "2021-05-12 15:09:36 +0200", "message": "KEYCLOAK-17348 Add manual pagination into UserStorageManager#query"}, {"oid": "bc8fd21dc6495b7f43f3466eb3545055753114ae", "committedDate": "2022-06-21 08:53:06 +0200", "message": "SingleUserCredentialManager moving in - UserStorageManager now handles authentication for old Kerberos+LDAP style - new getUserByCredential method in MapUserProvider would eventually do the same."}, {"oid": "e396d0daa1fed0cb82cf761fe3b461ba24118a10", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Renaming SingleUserCredentialManager and UserModel.getUserCredentialManager(): - class SingleUserCredentialManager to SingleEntityCredentialManager - method UserModel.getUserCredentialManager() to credentialManager()"}, {"oid": "1a227212deaf7b933cebc0100cb44871644c7ee5", "committedDate": "2022-06-21 08:53:06 +0200", "message": "Simplify implementation of a federated storage by moving the default implementation to the abstract base class; this will also allow the quickstarts and implementations derived from that to run without changes."}, {"oid": "cb0c88182148fd352969383a33f2eeb56cc4de9f", "committedDate": "2022-06-21 08:53:06 +0200", "message": "rename SingleEntityCredentialManager to SubjectCredentialManager"}, {"oid": "883e83e62540168593046e34292849e16c009760", "committedDate": "2022-10-25 09:01:33 +0200", "message": "Remove deprecated methods from data providers and models"}, {"oid": "a175efcb72902a767342941136fe7515733e6f2f", "committedDate": "2023-05-31 11:47:54 +0200", "message": "Split `UserQueryProvider` into `UserQueryMethods` and `UserCountMethods` and make `LdapStorageProvider` implement only `UserQueryMethods` Co-authored-by: mhajas <mhajas@redhat.com>"}]}, {"oid": "b839690d32f81140a94289f9a443ed61111fa8e5", "url": "https://github.com/keycloak/keycloak/commit/b839690d32f81140a94289f9a443ed61111fa8e5", "message": "[KEYCLOAK-15200] Complement methods for accessing users with Stream variants", "committedDate": "2020-10-29T17:23:27Z", "type": "forcePushed"}, {"oid": "73b8207ab295a9a00c192d2d5debc14317a05816", "url": "https://github.com/keycloak/keycloak/commit/73b8207ab295a9a00c192d2d5debc14317a05816", "message": "[KEYCLOAK-15200] Complement methods for accessing users with Stream variants", "committedDate": "2020-10-30T19:28:40Z", "type": "forcePushed"}, {"oid": "ce4c5764c2a2c85c895f63957dda72b22bd0a289", "url": "https://github.com/keycloak/keycloak/commit/ce4c5764c2a2c85c895f63957dda72b22bd0a289", "message": "[KEYCLOAK-15200] Complement methods for accessing users with Stream variants", "committedDate": "2020-11-09T12:21:05Z", "type": "commit"}, {"oid": "ce4c5764c2a2c85c895f63957dda72b22bd0a289", "url": "https://github.com/keycloak/keycloak/commit/ce4c5764c2a2c85c895f63957dda72b22bd0a289", "message": "[KEYCLOAK-15200] Complement methods for accessing users with Stream variants", "committedDate": "2020-11-09T12:21:05Z", "type": "forcePushed"}]}