{"pr_number": 6336, "pr_title": "Segment reset API", "pr_author": "npawar", "pr_createdAt": "2020-12-08T21:37:58Z", "pr_url": "https://github.com/apache/pinot/pull/6336", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg3MDY2Mg==", "url": "https://github.com/apache/pinot/pull/6336#discussion_r538870662", "body": "Can you document what this API call does (or, is supposed to do)?  Can it throw some exceptions that we need to catch (or not catch)?", "bodyText": "Can you document what this API call does (or, is supposed to do)?  Can it throw some exceptions that we need to catch (or not catch)?", "bodyHTML": "<p dir=\"auto\">Can you document what this API call does (or, is supposed to do)?  Can it throw some exceptions that we need to catch (or not catch)?</p>", "author": "mcvsubbu", "createdAt": "2020-12-08T22:56:45Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1768,6 +1770,63 @@ public int reloadSegment(String tableNameWithType, String segmentName) {\n     return numMessagesSent;\n   }\n \n+  /**\n+   * Resets a segment by disabling and then enabling the segment\n+   */\n+  public void resetSegment(String tableNameWithType, String segmentName) {\n+    IdealState idealState = getTableIdealState(tableNameWithType);\n+    Preconditions.checkState(idealState != null, \"Could not find ideal state for table: %s\", tableNameWithType);\n+    ExternalView externalView = getTableExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+    Set<String> instanceSet = idealState.getInstanceSet(segmentName);\n+    Preconditions\n+        .checkState(CollectionUtils.isNotEmpty(instanceSet), \"Could not find segment: %s in ideal state for table: %s\");\n+    Map<String, String> externalViewStateMap = externalView.getStateMap(segmentName);\n+    List<String> partitions = Lists.newArrayList(segmentName);\n+    for (String instance : instanceSet) {\n+      if (externalViewStateMap == null || SegmentStateModel.ERROR.equals(externalViewStateMap.get(instance))) {\n+        _helixAdmin.resetPartition(_helixClusterName, instance, tableNameWithType, partitions);", "originalCommit": "28559440d71cf762b3c0605aba417e4713242d11", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg3MDkxNw==", "url": "https://github.com/apache/pinot/pull/6336#discussion_r538870917", "body": "I remember we used to have this disable/enable (aka toggle)  in segments API before, we had a lot of problems with it. We used it for refreshing segments, and then we moved to use the refresh helix message instead.", "bodyText": "I remember we used to have this disable/enable (aka toggle)  in segments API before, we had a lot of problems with it. We used it for refreshing segments, and then we moved to use the refresh helix message instead.", "bodyHTML": "<p dir=\"auto\">I remember we used to have this disable/enable (aka toggle)  in segments API before, we had a lot of problems with it. We used it for refreshing segments, and then we moved to use the refresh helix message instead.</p>", "author": "mcvsubbu", "createdAt": "2020-12-08T22:56:57Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1768,6 +1770,63 @@ public int reloadSegment(String tableNameWithType, String segmentName) {\n     return numMessagesSent;\n   }\n \n+  /**\n+   * Resets a segment by disabling and then enabling the segment\n+   */\n+  public void resetSegment(String tableNameWithType, String segmentName) {\n+    IdealState idealState = getTableIdealState(tableNameWithType);\n+    Preconditions.checkState(idealState != null, \"Could not find ideal state for table: %s\", tableNameWithType);\n+    ExternalView externalView = getTableExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+    Set<String> instanceSet = idealState.getInstanceSet(segmentName);\n+    Preconditions\n+        .checkState(CollectionUtils.isNotEmpty(instanceSet), \"Could not find segment: %s in ideal state for table: %s\");\n+    Map<String, String> externalViewStateMap = externalView.getStateMap(segmentName);\n+    List<String> partitions = Lists.newArrayList(segmentName);\n+    for (String instance : instanceSet) {\n+      if (externalViewStateMap == null || SegmentStateModel.ERROR.equals(externalViewStateMap.get(instance))) {\n+        _helixAdmin.resetPartition(_helixClusterName, instance, tableNameWithType, partitions);\n+      } else {\n+        _helixAdmin.enablePartition(false, _helixClusterName, instance, tableNameWithType, partitions);\n+      }", "originalCommit": "28559440d71cf762b3c0605aba417e4713242d11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU4NDk1NA==", "url": "https://github.com/apache/pinot/pull/6336#discussion_r539584954", "bodyText": "the problem with using SegmentRefreshMessage is that there's no way to bring about a change of state in the External View with that. A consuming segment in ERROR state will remain in ERROR state even after refreshed, unless we go through disable/enable partition", "author": "npawar", "createdAt": "2020-12-09T19:28:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg3MDkxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU4Njc0NA==", "url": "https://github.com/apache/pinot/pull/6336#discussion_r539586744", "bodyText": "Oh I know that. I am not saying that we use a message here. I am just pointing out that we had problems with the toggle API before. I forget the details, but it probably had to do with not waiting until EV stabilized", "author": "mcvsubbu", "createdAt": "2020-12-09T19:30:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg3MDkxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU4ODU2Nw==", "url": "https://github.com/apache/pinot/pull/6336#discussion_r539588567", "bodyText": "yes, we might have to wait for EV to change/stabilize", "author": "kishoreg", "createdAt": "2020-12-09T19:33:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg3MDkxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg3MTI3OQ==", "url": "https://github.com/apache/pinot/pull/6336#discussion_r538871279", "body": "Dont we need to wait until externalview stabiliizes before calling enable again?", "bodyText": "Dont we need to wait until externalview stabiliizes before calling enable again?", "bodyHTML": "<p dir=\"auto\">Dont we need to wait until externalview stabiliizes before calling enable again?</p>", "author": "mcvsubbu", "createdAt": "2020-12-08T22:57:17Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1768,6 +1770,63 @@ public int reloadSegment(String tableNameWithType, String segmentName) {\n     return numMessagesSent;\n   }\n \n+  /**\n+   * Resets a segment by disabling and then enabling the segment\n+   */\n+  public void resetSegment(String tableNameWithType, String segmentName) {\n+    IdealState idealState = getTableIdealState(tableNameWithType);\n+    Preconditions.checkState(idealState != null, \"Could not find ideal state for table: %s\", tableNameWithType);\n+    ExternalView externalView = getTableExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+    Set<String> instanceSet = idealState.getInstanceSet(segmentName);\n+    Preconditions\n+        .checkState(CollectionUtils.isNotEmpty(instanceSet), \"Could not find segment: %s in ideal state for table: %s\");\n+    Map<String, String> externalViewStateMap = externalView.getStateMap(segmentName);\n+    List<String> partitions = Lists.newArrayList(segmentName);\n+    for (String instance : instanceSet) {\n+      if (externalViewStateMap == null || SegmentStateModel.ERROR.equals(externalViewStateMap.get(instance))) {\n+        _helixAdmin.resetPartition(_helixClusterName, instance, tableNameWithType, partitions);\n+      } else {\n+        _helixAdmin.enablePartition(false, _helixClusterName, instance, tableNameWithType, partitions);\n+      }\n+      _helixAdmin.enablePartition(true, _helixClusterName, instance, tableNameWithType, partitions);", "originalCommit": "28559440d71cf762b3c0605aba417e4713242d11", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "aedf147b503d212266985ca27fc7371a3fb310ae", "url": "https://github.com/apache/pinot/commit/aedf147b503d212266985ca27fc7371a3fb310ae", "message": "Segment reset API", "committedDate": "2020-12-22T17:25:14Z", "type": "commit"}, {"oid": "d4952f9e7f01143a286bed19bbd0102525ad12c2", "url": "https://github.com/apache/pinot/commit/d4952f9e7f01143a286bed19bbd0102525ad12c2", "message": "Wait for EV to stabilize", "committedDate": "2020-12-23T03:12:28Z", "type": "commit"}, {"oid": "d4952f9e7f01143a286bed19bbd0102525ad12c2", "url": "https://github.com/apache/pinot/commit/d4952f9e7f01143a286bed19bbd0102525ad12c2", "message": "Wait for EV to stabilize", "committedDate": "2020-12-23T03:12:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA3Njg0MA==", "url": "https://github.com/apache/pinot/pull/6336#discussion_r548076840", "body": "Can we keep the log messages consistent? Let us call it a segment instead of partition.  (please check other log messages as well)", "bodyText": "Can we keep the log messages consistent? Let us call it a segment instead of partition.  (please check other log messages as well)", "bodyHTML": "<p dir=\"auto\">Can we keep the log messages consistent? Let us call it a segment instead of partition.  (please check other log messages as well)</p>", "author": "mcvsubbu", "createdAt": "2020-12-23T17:36:44Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1777,6 +1779,143 @@ public int reloadSegment(String tableNameWithType, String segmentName) {\n     return numMessagesSent;\n   }\n \n+  /**\n+   * Resets a segment by disabling and then enabling the segment\n+   */\n+  public void resetSegment(String tableNameWithType, String segmentName, long externalViewWaitTimeMs) {\n+    IdealState idealState = getTableIdealState(tableNameWithType);\n+    Preconditions.checkState(idealState != null, \"Could not find ideal state for table: %s\", tableNameWithType);\n+    ExternalView externalView = getTableExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+    Set<String> instanceSet = idealState.getInstanceSet(segmentName);\n+    Preconditions\n+        .checkState(CollectionUtils.isNotEmpty(instanceSet), \"Could not find segment: %s in ideal state for table: %s\");\n+    Map<String, String> externalViewStateMap = externalView.getStateMap(segmentName);\n+    List<String> partitions = Lists.newArrayList(segmentName);\n+\n+    // First, disable or reset partition\n+    for (String instance : instanceSet) {\n+      if (externalViewStateMap == null || SegmentStateModel.ERROR.equals(externalViewStateMap.get(instance))) {\n+        LOGGER.info(\"Resetting partition: {} of table: {}\", segmentName, tableNameWithType);", "originalCommit": "d4952f9e7f01143a286bed19bbd0102525ad12c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA3NjkzMw==", "url": "https://github.com/apache/pinot/pull/6336#discussion_r548076933", "body": "All that this parameter does is to override the admin command wait time. Why not call it something like that? We can then add it to any admin command now or later with the same name.\r\nSuggested:\r\n```suggestion\r\n      @ApiParam(value = \"Maximum time in milliseconds to wait for reset to be completed\") @QueryParam(\"maxWaitTimeMs\") long externalViewWaitTimeMs) {\r\n```", "bodyText": "All that this parameter does is to override the admin command wait time. Why not call it something like that? We can then add it to any admin command now or later with the same name.\nSuggested:\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  @ApiParam(value = \"Time in millis to wait for external view to converge\") @QueryParam(\"externalViewWaitTimeMs\") long externalViewWaitTimeMs) {\n          \n          \n            \n                  @ApiParam(value = \"Maximum time in milliseconds to wait for reset to be completed\") @QueryParam(\"maxWaitTimeMs\") long externalViewWaitTimeMs) {", "bodyHTML": "<p dir=\"auto\">All that this parameter does is to override the admin command wait time. Why not call it something like that? We can then add it to any admin command now or later with the same name.<br>\nSuggested:</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">      <span class=\"pl-k\">@ApiParam</span>(<span class=\"pl-c1\">value</span> <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"x x-first x-last\">Time </span>in <span class=\"x x-first x-last\">millis</span> to wait for <span class=\"x x-first x-last\">external view </span>to <span class=\"x x-first x-last\">converge</span><span class=\"pl-pds\">\"</span></span>) <span class=\"pl-k\">@QueryParam</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"x x-first x-last\">externalViewWaitTimeMs</span><span class=\"pl-pds\">\"</span></span>) <span class=\"pl-k\">long</span> externalViewWaitTimeMs) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      <span class=\"pl-k\">@ApiParam</span>(<span class=\"pl-c1\">value</span> <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"x x-first x-last\">Maximum time </span>in <span class=\"x x-first x-last\">milliseconds</span> to wait for <span class=\"x x-first x-last\">reset </span>to <span class=\"x x-first x-last\">be completed</span><span class=\"pl-pds\">\"</span></span>) <span class=\"pl-k\">@QueryParam</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"x x-first x-last\">maxWaitTimeMs</span><span class=\"pl-pds\">\"</span></span>) <span class=\"pl-k\">long</span> externalViewWaitTimeMs) {</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "mcvsubbu", "createdAt": "2020-12-23T17:36:50Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -355,6 +354,61 @@ public SuccessResponse reloadSegment(\n     }\n   }\n \n+  /**\n+   * Resets the segment of the table, by disabling and then enabling it.\n+   * This API will take segments to OFFLINE state, wait for External View to stabilize, and then back to ONLINE/CONSUMING state,\n+   * thus effective in resetting segments or consumers in error states.\n+   */\n+  @POST\n+  @Path(\"segments/{tableNameWithType}/{segmentName}/reset\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Resets a segment by first disabling it, waiting for external view to stabilize, and finally enabling it again\",\n+      notes = \"Resets a segment by disabling and then enabling a segment\")\n+  public SuccessResponse resetSegment(\n+      @ApiParam(value = \"Name of the table with type\", required = true) @PathParam(\"tableNameWithType\") String tableNameWithType,\n+      @ApiParam(value = \"Name of the segment\", required = true) @PathParam(\"segmentName\") @Encoded String segmentName,\n+      @ApiParam(value = \"Time in millis to wait for external view to converge\") @QueryParam(\"externalViewWaitTimeMs\") long externalViewWaitTimeMs) {", "originalCommit": "d4952f9e7f01143a286bed19bbd0102525ad12c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI1Mzc2Nw==", "url": "https://github.com/apache/pinot/pull/6336#discussion_r548253767", "bodyText": "This is not a generic max wait time, but a wait time for external view to stabilize.", "author": "npawar", "createdAt": "2020-12-23T21:27:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA3NjkzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMxMzU0NA==", "url": "https://github.com/apache/pinot/pull/6336#discussion_r548313544", "bodyText": "I am trying to avoid documenting what external view means. We know it as pinot devs, but probably better to minimize exposure of this to basic beginner users (and I think that is who we are targeting here). For all practical purposes, the ev wait will really translate to the total admin command wait time, so a re-use of that same term will save us some explanation -- is my thought.  I am flexible on this", "author": "mcvsubbu", "createdAt": "2020-12-23T23:08:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA3NjkzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA3ODcwNQ==", "url": "https://github.com/apache/pinot/pull/6336#discussion_r548078705", "body": "Please make sure that this error message shows up on the console or curl command if table type is not given. Sometimes we see that the precondition check error message does not show up, and we get a 5xx error (this should be a 4xx error)", "bodyText": "Please make sure that this error message shows up on the console or curl command if table type is not given. Sometimes we see that the precondition check error message does not show up, and we get a 5xx error (this should be a 4xx error)", "bodyHTML": "<p dir=\"auto\">Please make sure that this error message shows up on the console or curl command if table type is not given. Sometimes we see that the precondition check error message does not show up, and we get a 5xx error (this should be a 4xx error)</p>", "author": "mcvsubbu", "createdAt": "2020-12-23T17:38:52Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -355,6 +354,61 @@ public SuccessResponse reloadSegment(\n     }\n   }\n \n+  /**\n+   * Resets the segment of the table, by disabling and then enabling it.\n+   * This API will take segments to OFFLINE state, wait for External View to stabilize, and then back to ONLINE/CONSUMING state,\n+   * thus effective in resetting segments or consumers in error states.\n+   */\n+  @POST\n+  @Path(\"segments/{tableNameWithType}/{segmentName}/reset\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Resets a segment by first disabling it, waiting for external view to stabilize, and finally enabling it again\",\n+      notes = \"Resets a segment by disabling and then enabling a segment\")\n+  public SuccessResponse resetSegment(\n+      @ApiParam(value = \"Name of the table with type\", required = true) @PathParam(\"tableNameWithType\") String tableNameWithType,\n+      @ApiParam(value = \"Name of the segment\", required = true) @PathParam(\"segmentName\") @Encoded String segmentName,\n+      @ApiParam(value = \"Time in millis to wait for external view to converge\") @QueryParam(\"externalViewWaitTimeMs\") long externalViewWaitTimeMs) {\n+    segmentName = URIUtils.decode(segmentName);\n+    TableType tableType = TableNameBuilder.getTableTypeFromTableName(tableNameWithType);\n+    try {\n+      Preconditions.checkState(tableType != null, \"Must provide table name with type: %s\", tableNameWithType);", "originalCommit": "d4952f9e7f01143a286bed19bbd0102525ad12c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUzNTg1MA==", "url": "https://github.com/apache/pinot/pull/6336#discussion_r549535850", "bodyText": "It does show up.\n{\n  \"code\": 404,\n  \"error\": \"Failed to reset segments in table: foo_REALTIME. Could not find ideal state for table: foo_REALTIME\"\n}\n\nAlso, all places which you've commented for 4xx are already throwing 4xx.", "author": "npawar", "createdAt": "2020-12-29T01:24:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA3ODcwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA3OTA4Mg==", "url": "https://github.com/apache/pinot/pull/6336#discussion_r548079082", "body": "better to include the table name in the message. Also, you may want to word it such that it clearly implies that the reset is completed.", "bodyText": "better to include the table name in the message. Also, you may want to word it such that it clearly implies that the reset is completed.", "bodyHTML": "<p dir=\"auto\">better to include the table name in the message. Also, you may want to word it such that it clearly implies that the reset is completed.</p>", "author": "mcvsubbu", "createdAt": "2020-12-23T17:39:21Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -355,6 +354,61 @@ public SuccessResponse reloadSegment(\n     }\n   }\n \n+  /**\n+   * Resets the segment of the table, by disabling and then enabling it.\n+   * This API will take segments to OFFLINE state, wait for External View to stabilize, and then back to ONLINE/CONSUMING state,\n+   * thus effective in resetting segments or consumers in error states.\n+   */\n+  @POST\n+  @Path(\"segments/{tableNameWithType}/{segmentName}/reset\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Resets a segment by first disabling it, waiting for external view to stabilize, and finally enabling it again\",\n+      notes = \"Resets a segment by disabling and then enabling a segment\")\n+  public SuccessResponse resetSegment(\n+      @ApiParam(value = \"Name of the table with type\", required = true) @PathParam(\"tableNameWithType\") String tableNameWithType,\n+      @ApiParam(value = \"Name of the segment\", required = true) @PathParam(\"segmentName\") @Encoded String segmentName,\n+      @ApiParam(value = \"Time in millis to wait for external view to converge\") @QueryParam(\"externalViewWaitTimeMs\") long externalViewWaitTimeMs) {\n+    segmentName = URIUtils.decode(segmentName);\n+    TableType tableType = TableNameBuilder.getTableTypeFromTableName(tableNameWithType);\n+    try {\n+      Preconditions.checkState(tableType != null, \"Must provide table name with type: %s\", tableNameWithType);\n+      _pinotHelixResourceManager.resetSegment(tableNameWithType, segmentName,\n+          externalViewWaitTimeMs > 0 ? externalViewWaitTimeMs\n+              : _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+      return new SuccessResponse(\"Successfully invoked segment reset\");\n+    } catch (Exception e) {\n+      throw new ControllerApplicationException(LOGGER,\n+          String.format(\"Failed to reset segment: %s in table: %s. %s\", segmentName, tableNameWithType, e.getMessage()),\n+          Status.NOT_FOUND);\n+    }\n+  }\n+\n+  /**\n+   * Resets all segments of the given table\n+   * This API will take segments to OFFLINE state, wait for External View to stabilize, and then back to ONLINE/CONSUMING state,\n+   * thus effective in resetting segments or consumers in error states.\n+   */\n+  @POST\n+  @Path(\"segments/{tableNameWithType}/reset\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Resets all segments of the table, by first disabling them, waiting for external view to stabilize, and finally enabling the segments\",\n+      notes = \"Resets a segment by disabling and then enabling a segment\")\n+  public SuccessResponse resetAllSegments(\n+      @ApiParam(value = \"Name of the table with type\", required = true) @PathParam(\"tableNameWithType\") String tableNameWithType,\n+      @ApiParam(value = \"Time in millis to wait for external view to converge\") @QueryParam(\"externalViewWaitTimeMs\") long externalViewWaitTimeMs) {\n+    TableType tableType = TableNameBuilder.getTableTypeFromTableName(tableNameWithType);\n+    try {\n+      Preconditions.checkState(tableType != null, \"Must provide table name with type: %s\", tableNameWithType);\n+      _pinotHelixResourceManager.resetAllSegments(tableNameWithType, externalViewWaitTimeMs > 0 ? externalViewWaitTimeMs\n+          : _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+      return new SuccessResponse(\"Successfully invoked segment reset\");", "originalCommit": "d4952f9e7f01143a286bed19bbd0102525ad12c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA3OTgyOQ==", "url": "https://github.com/apache/pinot/pull/6336#discussion_r548079829", "body": "should be a 4xx error", "bodyText": "should be a 4xx error", "bodyHTML": "<p dir=\"auto\">should be a 4xx error</p>", "author": "mcvsubbu", "createdAt": "2020-12-23T17:40:12Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1777,6 +1779,143 @@ public int reloadSegment(String tableNameWithType, String segmentName) {\n     return numMessagesSent;\n   }\n \n+  /**\n+   * Resets a segment by disabling and then enabling the segment\n+   */\n+  public void resetSegment(String tableNameWithType, String segmentName, long externalViewWaitTimeMs) {\n+    IdealState idealState = getTableIdealState(tableNameWithType);\n+    Preconditions.checkState(idealState != null, \"Could not find ideal state for table: %s\", tableNameWithType);\n+    ExternalView externalView = getTableExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+    Set<String> instanceSet = idealState.getInstanceSet(segmentName);\n+    Preconditions\n+        .checkState(CollectionUtils.isNotEmpty(instanceSet), \"Could not find segment: %s in ideal state for table: %s\");", "originalCommit": "d4952f9e7f01143a286bed19bbd0102525ad12c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA4MDE2Mw==", "url": "https://github.com/apache/pinot/pull/6336#discussion_r548080163", "body": "should be 4xx error (unless pinot messed up real bad. :-))", "bodyText": "should be 4xx error (unless pinot messed up real bad. :-))", "bodyHTML": "<p dir=\"auto\">should be 4xx error (unless pinot messed up real bad. :-))</p>", "author": "mcvsubbu", "createdAt": "2020-12-23T17:40:35Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1777,6 +1779,143 @@ public int reloadSegment(String tableNameWithType, String segmentName) {\n     return numMessagesSent;\n   }\n \n+  /**\n+   * Resets a segment by disabling and then enabling the segment\n+   */\n+  public void resetSegment(String tableNameWithType, String segmentName, long externalViewWaitTimeMs) {\n+    IdealState idealState = getTableIdealState(tableNameWithType);\n+    Preconditions.checkState(idealState != null, \"Could not find ideal state for table: %s\", tableNameWithType);", "originalCommit": "d4952f9e7f01143a286bed19bbd0102525ad12c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA4MjYzOQ==", "url": "https://github.com/apache/pinot/pull/6336#discussion_r548082639", "body": "Please add a thread.sleep here instead of a busy-wait loop. Suggestion:\r\n`\r\nThread.sleep(min(100,maxWaitTimeMillis/10))\r\n`", "bodyText": "Please add a thread.sleep here instead of a busy-wait loop. Suggestion:\nThread.sleep(min(100,maxWaitTimeMillis/10))", "bodyHTML": "<p dir=\"auto\">Please add a thread.sleep here instead of a busy-wait loop. Suggestion:<br>\n<code>Thread.sleep(min(100,maxWaitTimeMillis/10))</code></p>", "author": "mcvsubbu", "createdAt": "2020-12-23T17:43:38Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1777,6 +1779,143 @@ public int reloadSegment(String tableNameWithType, String segmentName) {\n     return numMessagesSent;\n   }\n \n+  /**\n+   * Resets a segment by disabling and then enabling the segment\n+   */\n+  public void resetSegment(String tableNameWithType, String segmentName, long externalViewWaitTimeMs) {\n+    IdealState idealState = getTableIdealState(tableNameWithType);\n+    Preconditions.checkState(idealState != null, \"Could not find ideal state for table: %s\", tableNameWithType);\n+    ExternalView externalView = getTableExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+    Set<String> instanceSet = idealState.getInstanceSet(segmentName);\n+    Preconditions\n+        .checkState(CollectionUtils.isNotEmpty(instanceSet), \"Could not find segment: %s in ideal state for table: %s\");\n+    Map<String, String> externalViewStateMap = externalView.getStateMap(segmentName);\n+    List<String> partitions = Lists.newArrayList(segmentName);\n+\n+    // First, disable or reset partition\n+    for (String instance : instanceSet) {\n+      if (externalViewStateMap == null || SegmentStateModel.ERROR.equals(externalViewStateMap.get(instance))) {\n+        LOGGER.info(\"Resetting partition: {} of table: {}\", segmentName, tableNameWithType);\n+        _helixAdmin.resetPartition(_helixClusterName, instance, tableNameWithType, partitions);\n+      } else {\n+        LOGGER.info(\"Disabling partition: {} of table: {}\", segmentName, tableNameWithType);\n+        _helixAdmin.enablePartition(false, _helixClusterName, instance, tableNameWithType, partitions);\n+      }\n+    }\n+\n+    // Wait for external view to stabilize\n+    LOGGER.info(\"Waiting {} ms for external view to stabilize after disable/reset of partition: {} of table: {}\",\n+        externalViewWaitTimeMs, segmentName, tableNameWithType);\n+    long startTime = System.currentTimeMillis();\n+    Set<String> instancesToCheck = new HashSet<>(instanceSet);\n+    while (!instancesToCheck.isEmpty() && System.currentTimeMillis() - startTime < externalViewWaitTimeMs) {\n+      ExternalView newExternalView = getTableExternalView(tableNameWithType);\n+      Preconditions\n+          .checkState(newExternalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+      Map<String, String> newExternalViewStateMap = newExternalView.getStateMap(segmentName);\n+      if (newExternalViewStateMap == null) {\n+        continue;\n+      }\n+      instancesToCheck.removeIf(instance -> SegmentStateModel.OFFLINE.equals(newExternalViewStateMap.get(instance)));\n+    }", "originalCommit": "d4952f9e7f01143a286bed19bbd0102525ad12c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA4NDg0NQ==", "url": "https://github.com/apache/pinot/pull/6336#discussion_r548084845", "body": "suggest naming the variables with `segments` instead of `partritions`. We do have two other semantics of partitions that is already confusing (stream partitions, and partitioning of data in segment assignment)", "bodyText": "suggest naming the variables with segments instead of partritions. We do have two other semantics of partitions that is already confusing (stream partitions, and partitioning of data in segment assignment)", "bodyHTML": "<p dir=\"auto\">suggest naming the variables with <code>segments</code> instead of <code>partritions</code>. We do have two other semantics of partitions that is already confusing (stream partitions, and partitioning of data in segment assignment)</p>", "author": "mcvsubbu", "createdAt": "2020-12-23T17:46:52Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1777,6 +1779,143 @@ public int reloadSegment(String tableNameWithType, String segmentName) {\n     return numMessagesSent;\n   }\n \n+  /**\n+   * Resets a segment by disabling and then enabling the segment\n+   */\n+  public void resetSegment(String tableNameWithType, String segmentName, long externalViewWaitTimeMs) {\n+    IdealState idealState = getTableIdealState(tableNameWithType);\n+    Preconditions.checkState(idealState != null, \"Could not find ideal state for table: %s\", tableNameWithType);\n+    ExternalView externalView = getTableExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+    Set<String> instanceSet = idealState.getInstanceSet(segmentName);\n+    Preconditions\n+        .checkState(CollectionUtils.isNotEmpty(instanceSet), \"Could not find segment: %s in ideal state for table: %s\");\n+    Map<String, String> externalViewStateMap = externalView.getStateMap(segmentName);\n+    List<String> partitions = Lists.newArrayList(segmentName);\n+\n+    // First, disable or reset partition\n+    for (String instance : instanceSet) {\n+      if (externalViewStateMap == null || SegmentStateModel.ERROR.equals(externalViewStateMap.get(instance))) {\n+        LOGGER.info(\"Resetting partition: {} of table: {}\", segmentName, tableNameWithType);\n+        _helixAdmin.resetPartition(_helixClusterName, instance, tableNameWithType, partitions);\n+      } else {\n+        LOGGER.info(\"Disabling partition: {} of table: {}\", segmentName, tableNameWithType);\n+        _helixAdmin.enablePartition(false, _helixClusterName, instance, tableNameWithType, partitions);\n+      }\n+    }\n+\n+    // Wait for external view to stabilize\n+    LOGGER.info(\"Waiting {} ms for external view to stabilize after disable/reset of partition: {} of table: {}\",\n+        externalViewWaitTimeMs, segmentName, tableNameWithType);\n+    long startTime = System.currentTimeMillis();\n+    Set<String> instancesToCheck = new HashSet<>(instanceSet);\n+    while (!instancesToCheck.isEmpty() && System.currentTimeMillis() - startTime < externalViewWaitTimeMs) {\n+      ExternalView newExternalView = getTableExternalView(tableNameWithType);\n+      Preconditions\n+          .checkState(newExternalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+      Map<String, String> newExternalViewStateMap = newExternalView.getStateMap(segmentName);\n+      if (newExternalViewStateMap == null) {\n+        continue;\n+      }\n+      instancesToCheck.removeIf(instance -> SegmentStateModel.OFFLINE.equals(newExternalViewStateMap.get(instance)));\n+    }\n+    if (!instancesToCheck.isEmpty()) {\n+      throw new IllegalStateException(String.format(\n+          \"Timed out waiting for external view to stabilize after disable/reset call. Skipping enable of partition: %s of table: %s\",\n+          segmentName, tableNameWithType));\n+    }\n+\n+    // Enable partition\n+    LOGGER.info(\"Enabling partition: {} of table: {}\", segmentName, tableNameWithType);\n+    for (String instance : instanceSet) {\n+      _helixAdmin.enablePartition(true, _helixClusterName, instance, tableNameWithType, partitions);\n+    }\n+  }\n+\n+  /**\n+   * Resets all segments of a table by disabling and then enabling the segments\n+   */\n+  public void resetAllSegments(String tableNameWithType, long externalViewWaitTimeMs) {\n+    IdealState idealState = getTableIdealState(tableNameWithType);\n+    Preconditions.checkState(idealState != null, \"Could not find ideal state for table: %s\", tableNameWithType);\n+    ExternalView externalView = getTableExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+\n+    Map<String, Set<String>> resetInstanceToPartitionsMap = new HashMap<>();", "originalCommit": "d4952f9e7f01143a286bed19bbd0102525ad12c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI0OTE1Nw==", "url": "https://github.com/apache/pinot/pull/6336#discussion_r548249157", "bodyText": "I want to keep it partitions because the calls being made are resetPartition and enablePartition", "author": "npawar", "createdAt": "2020-12-23T21:21:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA4NDg0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMxNDE2Mg==", "url": "https://github.com/apache/pinot/pull/6336#discussion_r548314162", "bodyText": "Yes, when we make calls to helix we have to use partition. But within pinot we always refer to a segment as a segment . It will really reduce confusion if you keep the segment term when we refer to that.", "author": "mcvsubbu", "createdAt": "2020-12-23T23:11:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA4NDg0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA4Njk0OA==", "url": "https://github.com/apache/pinot/pull/6336#discussion_r548086948", "body": "Dont you have to enable the partition (segment) again after this call?", "bodyText": "Dont you have to enable the partition (segment) again after this call?", "bodyHTML": "<p dir=\"auto\">Dont you have to enable the partition (segment) again after this call?</p>", "author": "mcvsubbu", "createdAt": "2020-12-23T17:49:17Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1777,6 +1779,143 @@ public int reloadSegment(String tableNameWithType, String segmentName) {\n     return numMessagesSent;\n   }\n \n+  /**\n+   * Resets a segment by disabling and then enabling the segment\n+   */\n+  public void resetSegment(String tableNameWithType, String segmentName, long externalViewWaitTimeMs) {\n+    IdealState idealState = getTableIdealState(tableNameWithType);\n+    Preconditions.checkState(idealState != null, \"Could not find ideal state for table: %s\", tableNameWithType);\n+    ExternalView externalView = getTableExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+    Set<String> instanceSet = idealState.getInstanceSet(segmentName);\n+    Preconditions\n+        .checkState(CollectionUtils.isNotEmpty(instanceSet), \"Could not find segment: %s in ideal state for table: %s\");\n+    Map<String, String> externalViewStateMap = externalView.getStateMap(segmentName);\n+    List<String> partitions = Lists.newArrayList(segmentName);\n+\n+    // First, disable or reset partition\n+    for (String instance : instanceSet) {\n+      if (externalViewStateMap == null || SegmentStateModel.ERROR.equals(externalViewStateMap.get(instance))) {\n+        LOGGER.info(\"Resetting partition: {} of table: {}\", segmentName, tableNameWithType);\n+        _helixAdmin.resetPartition(_helixClusterName, instance, tableNameWithType, partitions);\n+      } else {\n+        LOGGER.info(\"Disabling partition: {} of table: {}\", segmentName, tableNameWithType);\n+        _helixAdmin.enablePartition(false, _helixClusterName, instance, tableNameWithType, partitions);", "originalCommit": "d4952f9e7f01143a286bed19bbd0102525ad12c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI1MjEzMg==", "url": "https://github.com/apache/pinot/pull/6336#discussion_r548252132", "bodyText": "Did not follow your comment. That is exactly what's happening few lines below after the external view stabilizes", "author": "npawar", "createdAt": "2020-12-23T21:25:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA4Njk0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMxMzgzMQ==", "url": "https://github.com/apache/pinot/pull/6336#discussion_r548313831", "bodyText": "My bad. I did not see the 'false' argument there. (God, I wish helix went a little extra inch to provide a disablePartition api :-)", "author": "mcvsubbu", "createdAt": "2020-12-23T23:09:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA4Njk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA4ODAxNQ==", "url": "https://github.com/apache/pinot/pull/6336#discussion_r548088015", "body": "Not sure if we can start off with no external view at thsi point, since helix will still be processing the reset calls.", "bodyText": "Not sure if we can start off with no external view at thsi point, since helix will still be processing the reset calls.", "bodyHTML": "<p dir=\"auto\">Not sure if we can start off with no external view at thsi point, since helix will still be processing the reset calls.</p>", "author": "mcvsubbu", "createdAt": "2020-12-23T17:50:50Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1777,6 +1779,143 @@ public int reloadSegment(String tableNameWithType, String segmentName) {\n     return numMessagesSent;\n   }\n \n+  /**\n+   * Resets a segment by disabling and then enabling the segment\n+   */\n+  public void resetSegment(String tableNameWithType, String segmentName, long externalViewWaitTimeMs) {\n+    IdealState idealState = getTableIdealState(tableNameWithType);\n+    Preconditions.checkState(idealState != null, \"Could not find ideal state for table: %s\", tableNameWithType);\n+    ExternalView externalView = getTableExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+    Set<String> instanceSet = idealState.getInstanceSet(segmentName);\n+    Preconditions\n+        .checkState(CollectionUtils.isNotEmpty(instanceSet), \"Could not find segment: %s in ideal state for table: %s\");\n+    Map<String, String> externalViewStateMap = externalView.getStateMap(segmentName);\n+    List<String> partitions = Lists.newArrayList(segmentName);\n+\n+    // First, disable or reset partition\n+    for (String instance : instanceSet) {\n+      if (externalViewStateMap == null || SegmentStateModel.ERROR.equals(externalViewStateMap.get(instance))) {\n+        LOGGER.info(\"Resetting partition: {} of table: {}\", segmentName, tableNameWithType);\n+        _helixAdmin.resetPartition(_helixClusterName, instance, tableNameWithType, partitions);\n+      } else {\n+        LOGGER.info(\"Disabling partition: {} of table: {}\", segmentName, tableNameWithType);\n+        _helixAdmin.enablePartition(false, _helixClusterName, instance, tableNameWithType, partitions);\n+      }\n+    }\n+\n+    // Wait for external view to stabilize\n+    LOGGER.info(\"Waiting {} ms for external view to stabilize after disable/reset of partition: {} of table: {}\",\n+        externalViewWaitTimeMs, segmentName, tableNameWithType);\n+    long startTime = System.currentTimeMillis();\n+    Set<String> instancesToCheck = new HashSet<>(instanceSet);\n+    while (!instancesToCheck.isEmpty() && System.currentTimeMillis() - startTime < externalViewWaitTimeMs) {\n+      ExternalView newExternalView = getTableExternalView(tableNameWithType);\n+      Preconditions\n+          .checkState(newExternalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+      Map<String, String> newExternalViewStateMap = newExternalView.getStateMap(segmentName);\n+      if (newExternalViewStateMap == null) {\n+        continue;\n+      }\n+      instancesToCheck.removeIf(instance -> SegmentStateModel.OFFLINE.equals(newExternalViewStateMap.get(instance)));\n+    }\n+    if (!instancesToCheck.isEmpty()) {\n+      throw new IllegalStateException(String.format(\n+          \"Timed out waiting for external view to stabilize after disable/reset call. Skipping enable of partition: %s of table: %s\",\n+          segmentName, tableNameWithType));\n+    }\n+\n+    // Enable partition\n+    LOGGER.info(\"Enabling partition: {} of table: {}\", segmentName, tableNameWithType);\n+    for (String instance : instanceSet) {\n+      _helixAdmin.enablePartition(true, _helixClusterName, instance, tableNameWithType, partitions);\n+    }\n+  }\n+\n+  /**\n+   * Resets all segments of a table by disabling and then enabling the segments\n+   */\n+  public void resetAllSegments(String tableNameWithType, long externalViewWaitTimeMs) {\n+    IdealState idealState = getTableIdealState(tableNameWithType);\n+    Preconditions.checkState(idealState != null, \"Could not find ideal state for table: %s\", tableNameWithType);\n+    ExternalView externalView = getTableExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+\n+    Map<String, Set<String>> resetInstanceToPartitionsMap = new HashMap<>();\n+    Map<String, Set<String>> disableInstanceToPartitionsMap = new HashMap<>();\n+    Map<String, Set<String>> partitionInstancesToCheck = new HashMap<>();\n+\n+    for (String partition : idealState.getPartitionSet()) {\n+      Set<String> instanceSet = idealState.getInstanceSet(partition);\n+      Map<String, String> externalViewStateMap = externalView.getStateMap(partition);\n+      for (String instance : instanceSet) {\n+        if (externalViewStateMap == null || SegmentStateModel.ERROR.equals(externalViewStateMap.get(instance))) {\n+          resetInstanceToPartitionsMap.computeIfAbsent(instance, i -> new HashSet<>()).add(partition);\n+        } else {\n+          disableInstanceToPartitionsMap.computeIfAbsent(instance, i -> new HashSet<>()).add(partition);\n+        }\n+      }\n+      partitionInstancesToCheck.put(partition, new HashSet<>(instanceSet));\n+    }\n+\n+    // First, disable/reset the partitions\n+    LOGGER.info(\"Disabling/resetting partitions of table: {}\", tableNameWithType);\n+    for (Map.Entry<String, Set<String>> entry : resetInstanceToPartitionsMap.entrySet()) {\n+      ArrayList<String> partitions = Lists.newArrayList(entry.getValue());\n+      _helixAdmin.resetPartition(_helixClusterName, entry.getKey(), tableNameWithType, partitions);\n+    }\n+    for (Map.Entry<String, Set<String>> entry : disableInstanceToPartitionsMap.entrySet()) {\n+      ArrayList<String> partitions = Lists.newArrayList(entry.getValue());\n+      _helixAdmin.enablePartition(false, _helixClusterName, entry.getKey(), tableNameWithType, partitions);\n+    }\n+\n+    // Wait for external view to stabilize\n+    LOGGER.info(\"Waiting {} ms for external view to stabilize after disable/reset of partitions of table: {}\",\n+        externalViewWaitTimeMs, tableNameWithType);\n+    long startTime = System.currentTimeMillis();\n+    while (!partitionInstancesToCheck.isEmpty() && System.currentTimeMillis() - startTime < externalViewWaitTimeMs) {\n+      ExternalView newExternalView = getTableExternalView(tableNameWithType);\n+      Preconditions", "originalCommit": "d4952f9e7f01143a286bed19bbd0102525ad12c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI0OTkwMw==", "url": "https://github.com/apache/pinot/pull/6336#discussion_r548249903", "bodyText": "Not sure what you mean. This is just a safeguard against table being deleted in between", "author": "npawar", "createdAt": "2020-12-23T21:22:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA4ODAxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMxNDcyNQ==", "url": "https://github.com/apache/pinot/pull/6336#discussion_r548314725", "bodyText": "I see, yes that is good.\nMy question was, will we ever get into this with an empty EV in a valid case. So, let us say, a beginner starts running pinot, has things badly configured so that EV never appears. Now, they correct the config and click on 'reset'. Is this a valid scenario? Do we not want to support that scenario if it is valid?", "author": "mcvsubbu", "createdAt": "2020-12-23T23:13:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA4ODAxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUzNjA3MA==", "url": "https://github.com/apache/pinot/pull/6336#discussion_r549536070", "bodyText": "Empty EV will go through this call. But null EV will not. I dont think we should try to support that. I'm not sure what null EV would mean for making reset/disable calls.", "author": "npawar", "createdAt": "2020-12-29T01:25:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA4ODAxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA4ODkwMQ==", "url": "https://github.com/apache/pinot/pull/6336#discussion_r548088901", "body": "Please add a sleep here like in the other case, instead of busy-waiting.", "bodyText": "Please add a sleep here like in the other case, instead of busy-waiting.", "bodyHTML": "<p dir=\"auto\">Please add a sleep here like in the other case, instead of busy-waiting.</p>", "author": "mcvsubbu", "createdAt": "2020-12-23T17:51:48Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1777,6 +1779,143 @@ public int reloadSegment(String tableNameWithType, String segmentName) {\n     return numMessagesSent;\n   }\n \n+  /**\n+   * Resets a segment by disabling and then enabling the segment\n+   */\n+  public void resetSegment(String tableNameWithType, String segmentName, long externalViewWaitTimeMs) {\n+    IdealState idealState = getTableIdealState(tableNameWithType);\n+    Preconditions.checkState(idealState != null, \"Could not find ideal state for table: %s\", tableNameWithType);\n+    ExternalView externalView = getTableExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+    Set<String> instanceSet = idealState.getInstanceSet(segmentName);\n+    Preconditions\n+        .checkState(CollectionUtils.isNotEmpty(instanceSet), \"Could not find segment: %s in ideal state for table: %s\");\n+    Map<String, String> externalViewStateMap = externalView.getStateMap(segmentName);\n+    List<String> partitions = Lists.newArrayList(segmentName);\n+\n+    // First, disable or reset partition\n+    for (String instance : instanceSet) {\n+      if (externalViewStateMap == null || SegmentStateModel.ERROR.equals(externalViewStateMap.get(instance))) {\n+        LOGGER.info(\"Resetting partition: {} of table: {}\", segmentName, tableNameWithType);\n+        _helixAdmin.resetPartition(_helixClusterName, instance, tableNameWithType, partitions);\n+      } else {\n+        LOGGER.info(\"Disabling partition: {} of table: {}\", segmentName, tableNameWithType);\n+        _helixAdmin.enablePartition(false, _helixClusterName, instance, tableNameWithType, partitions);\n+      }\n+    }\n+\n+    // Wait for external view to stabilize\n+    LOGGER.info(\"Waiting {} ms for external view to stabilize after disable/reset of partition: {} of table: {}\",\n+        externalViewWaitTimeMs, segmentName, tableNameWithType);\n+    long startTime = System.currentTimeMillis();\n+    Set<String> instancesToCheck = new HashSet<>(instanceSet);\n+    while (!instancesToCheck.isEmpty() && System.currentTimeMillis() - startTime < externalViewWaitTimeMs) {\n+      ExternalView newExternalView = getTableExternalView(tableNameWithType);\n+      Preconditions\n+          .checkState(newExternalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+      Map<String, String> newExternalViewStateMap = newExternalView.getStateMap(segmentName);\n+      if (newExternalViewStateMap == null) {\n+        continue;\n+      }\n+      instancesToCheck.removeIf(instance -> SegmentStateModel.OFFLINE.equals(newExternalViewStateMap.get(instance)));\n+    }\n+    if (!instancesToCheck.isEmpty()) {\n+      throw new IllegalStateException(String.format(\n+          \"Timed out waiting for external view to stabilize after disable/reset call. Skipping enable of partition: %s of table: %s\",\n+          segmentName, tableNameWithType));\n+    }\n+\n+    // Enable partition\n+    LOGGER.info(\"Enabling partition: {} of table: {}\", segmentName, tableNameWithType);\n+    for (String instance : instanceSet) {\n+      _helixAdmin.enablePartition(true, _helixClusterName, instance, tableNameWithType, partitions);\n+    }\n+  }\n+\n+  /**\n+   * Resets all segments of a table by disabling and then enabling the segments\n+   */\n+  public void resetAllSegments(String tableNameWithType, long externalViewWaitTimeMs) {\n+    IdealState idealState = getTableIdealState(tableNameWithType);\n+    Preconditions.checkState(idealState != null, \"Could not find ideal state for table: %s\", tableNameWithType);\n+    ExternalView externalView = getTableExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+\n+    Map<String, Set<String>> resetInstanceToPartitionsMap = new HashMap<>();\n+    Map<String, Set<String>> disableInstanceToPartitionsMap = new HashMap<>();\n+    Map<String, Set<String>> partitionInstancesToCheck = new HashMap<>();\n+\n+    for (String partition : idealState.getPartitionSet()) {\n+      Set<String> instanceSet = idealState.getInstanceSet(partition);\n+      Map<String, String> externalViewStateMap = externalView.getStateMap(partition);\n+      for (String instance : instanceSet) {\n+        if (externalViewStateMap == null || SegmentStateModel.ERROR.equals(externalViewStateMap.get(instance))) {\n+          resetInstanceToPartitionsMap.computeIfAbsent(instance, i -> new HashSet<>()).add(partition);\n+        } else {\n+          disableInstanceToPartitionsMap.computeIfAbsent(instance, i -> new HashSet<>()).add(partition);\n+        }\n+      }\n+      partitionInstancesToCheck.put(partition, new HashSet<>(instanceSet));\n+    }\n+\n+    // First, disable/reset the partitions\n+    LOGGER.info(\"Disabling/resetting partitions of table: {}\", tableNameWithType);\n+    for (Map.Entry<String, Set<String>> entry : resetInstanceToPartitionsMap.entrySet()) {\n+      ArrayList<String> partitions = Lists.newArrayList(entry.getValue());\n+      _helixAdmin.resetPartition(_helixClusterName, entry.getKey(), tableNameWithType, partitions);\n+    }\n+    for (Map.Entry<String, Set<String>> entry : disableInstanceToPartitionsMap.entrySet()) {\n+      ArrayList<String> partitions = Lists.newArrayList(entry.getValue());\n+      _helixAdmin.enablePartition(false, _helixClusterName, entry.getKey(), tableNameWithType, partitions);\n+    }\n+\n+    // Wait for external view to stabilize\n+    LOGGER.info(\"Waiting {} ms for external view to stabilize after disable/reset of partitions of table: {}\",\n+        externalViewWaitTimeMs, tableNameWithType);\n+    long startTime = System.currentTimeMillis();\n+    while (!partitionInstancesToCheck.isEmpty() && System.currentTimeMillis() - startTime < externalViewWaitTimeMs) {\n+      ExternalView newExternalView = getTableExternalView(tableNameWithType);\n+      Preconditions\n+          .checkState(newExternalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+      Iterator<Map.Entry<String, Set<String>>> iterator = partitionInstancesToCheck.entrySet().iterator();\n+      while (iterator.hasNext()) {\n+        Map.Entry<String, Set<String>> entryToCheck = iterator.next();\n+        String partitionToCheck = entryToCheck.getKey();\n+        Set<String> instancesToCheck = entryToCheck.getValue();\n+        Map<String, String> newExternalViewStateMap = newExternalView.getStateMap(partitionToCheck);\n+        if (newExternalViewStateMap == null) {\n+          continue;\n+        }\n+        boolean allOffline = true;\n+        for (String instance : instancesToCheck) {\n+          if (!SegmentStateModel.OFFLINE.equals(newExternalViewStateMap.get(instance))) {\n+            allOffline = false;\n+            break;\n+          }\n+        }\n+        if (allOffline) {\n+          iterator.remove();\n+        }\n+      }\n+    }", "originalCommit": "d4952f9e7f01143a286bed19bbd0102525ad12c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA5MDI3Ng==", "url": "https://github.com/apache/pinot/pull/6336#discussion_r548090276", "body": "Why do we have an enable here and one in line 1869? Can you clarify again if helix expects two of these in the reset api ?", "bodyText": "Why do we have an enable here and one in line 1869? Can you clarify again if helix expects two of these in the reset api ?", "bodyHTML": "<p dir=\"auto\">Why do we have an enable here and one in line 1869? Can you clarify again if helix expects two of these in the reset api ?</p>", "author": "mcvsubbu", "createdAt": "2020-12-23T17:53:28Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1777,6 +1779,143 @@ public int reloadSegment(String tableNameWithType, String segmentName) {\n     return numMessagesSent;\n   }\n \n+  /**\n+   * Resets a segment by disabling and then enabling the segment\n+   */\n+  public void resetSegment(String tableNameWithType, String segmentName, long externalViewWaitTimeMs) {\n+    IdealState idealState = getTableIdealState(tableNameWithType);\n+    Preconditions.checkState(idealState != null, \"Could not find ideal state for table: %s\", tableNameWithType);\n+    ExternalView externalView = getTableExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+    Set<String> instanceSet = idealState.getInstanceSet(segmentName);\n+    Preconditions\n+        .checkState(CollectionUtils.isNotEmpty(instanceSet), \"Could not find segment: %s in ideal state for table: %s\");\n+    Map<String, String> externalViewStateMap = externalView.getStateMap(segmentName);\n+    List<String> partitions = Lists.newArrayList(segmentName);\n+\n+    // First, disable or reset partition\n+    for (String instance : instanceSet) {\n+      if (externalViewStateMap == null || SegmentStateModel.ERROR.equals(externalViewStateMap.get(instance))) {\n+        LOGGER.info(\"Resetting partition: {} of table: {}\", segmentName, tableNameWithType);\n+        _helixAdmin.resetPartition(_helixClusterName, instance, tableNameWithType, partitions);\n+      } else {\n+        LOGGER.info(\"Disabling partition: {} of table: {}\", segmentName, tableNameWithType);\n+        _helixAdmin.enablePartition(false, _helixClusterName, instance, tableNameWithType, partitions);\n+      }\n+    }\n+\n+    // Wait for external view to stabilize\n+    LOGGER.info(\"Waiting {} ms for external view to stabilize after disable/reset of partition: {} of table: {}\",\n+        externalViewWaitTimeMs, segmentName, tableNameWithType);\n+    long startTime = System.currentTimeMillis();\n+    Set<String> instancesToCheck = new HashSet<>(instanceSet);\n+    while (!instancesToCheck.isEmpty() && System.currentTimeMillis() - startTime < externalViewWaitTimeMs) {\n+      ExternalView newExternalView = getTableExternalView(tableNameWithType);\n+      Preconditions\n+          .checkState(newExternalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+      Map<String, String> newExternalViewStateMap = newExternalView.getStateMap(segmentName);\n+      if (newExternalViewStateMap == null) {\n+        continue;\n+      }\n+      instancesToCheck.removeIf(instance -> SegmentStateModel.OFFLINE.equals(newExternalViewStateMap.get(instance)));\n+    }\n+    if (!instancesToCheck.isEmpty()) {\n+      throw new IllegalStateException(String.format(\n+          \"Timed out waiting for external view to stabilize after disable/reset call. Skipping enable of partition: %s of table: %s\",\n+          segmentName, tableNameWithType));\n+    }\n+\n+    // Enable partition\n+    LOGGER.info(\"Enabling partition: {} of table: {}\", segmentName, tableNameWithType);\n+    for (String instance : instanceSet) {\n+      _helixAdmin.enablePartition(true, _helixClusterName, instance, tableNameWithType, partitions);\n+    }\n+  }\n+\n+  /**\n+   * Resets all segments of a table by disabling and then enabling the segments\n+   */\n+  public void resetAllSegments(String tableNameWithType, long externalViewWaitTimeMs) {\n+    IdealState idealState = getTableIdealState(tableNameWithType);\n+    Preconditions.checkState(idealState != null, \"Could not find ideal state for table: %s\", tableNameWithType);\n+    ExternalView externalView = getTableExternalView(tableNameWithType);\n+    Preconditions.checkState(externalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+\n+    Map<String, Set<String>> resetInstanceToPartitionsMap = new HashMap<>();\n+    Map<String, Set<String>> disableInstanceToPartitionsMap = new HashMap<>();\n+    Map<String, Set<String>> partitionInstancesToCheck = new HashMap<>();\n+\n+    for (String partition : idealState.getPartitionSet()) {\n+      Set<String> instanceSet = idealState.getInstanceSet(partition);\n+      Map<String, String> externalViewStateMap = externalView.getStateMap(partition);\n+      for (String instance : instanceSet) {\n+        if (externalViewStateMap == null || SegmentStateModel.ERROR.equals(externalViewStateMap.get(instance))) {\n+          resetInstanceToPartitionsMap.computeIfAbsent(instance, i -> new HashSet<>()).add(partition);\n+        } else {\n+          disableInstanceToPartitionsMap.computeIfAbsent(instance, i -> new HashSet<>()).add(partition);\n+        }\n+      }\n+      partitionInstancesToCheck.put(partition, new HashSet<>(instanceSet));\n+    }\n+\n+    // First, disable/reset the partitions\n+    LOGGER.info(\"Disabling/resetting partitions of table: {}\", tableNameWithType);\n+    for (Map.Entry<String, Set<String>> entry : resetInstanceToPartitionsMap.entrySet()) {\n+      ArrayList<String> partitions = Lists.newArrayList(entry.getValue());\n+      _helixAdmin.resetPartition(_helixClusterName, entry.getKey(), tableNameWithType, partitions);\n+    }\n+    for (Map.Entry<String, Set<String>> entry : disableInstanceToPartitionsMap.entrySet()) {\n+      ArrayList<String> partitions = Lists.newArrayList(entry.getValue());\n+      _helixAdmin.enablePartition(false, _helixClusterName, entry.getKey(), tableNameWithType, partitions);\n+    }\n+\n+    // Wait for external view to stabilize\n+    LOGGER.info(\"Waiting {} ms for external view to stabilize after disable/reset of partitions of table: {}\",\n+        externalViewWaitTimeMs, tableNameWithType);\n+    long startTime = System.currentTimeMillis();\n+    while (!partitionInstancesToCheck.isEmpty() && System.currentTimeMillis() - startTime < externalViewWaitTimeMs) {\n+      ExternalView newExternalView = getTableExternalView(tableNameWithType);\n+      Preconditions\n+          .checkState(newExternalView != null, \"Could not find external view for table: %s\", tableNameWithType);\n+      Iterator<Map.Entry<String, Set<String>>> iterator = partitionInstancesToCheck.entrySet().iterator();\n+      while (iterator.hasNext()) {\n+        Map.Entry<String, Set<String>> entryToCheck = iterator.next();\n+        String partitionToCheck = entryToCheck.getKey();\n+        Set<String> instancesToCheck = entryToCheck.getValue();\n+        Map<String, String> newExternalViewStateMap = newExternalView.getStateMap(partitionToCheck);\n+        if (newExternalViewStateMap == null) {\n+          continue;\n+        }\n+        boolean allOffline = true;\n+        for (String instance : instancesToCheck) {\n+          if (!SegmentStateModel.OFFLINE.equals(newExternalViewStateMap.get(instance))) {\n+            allOffline = false;\n+            break;\n+          }\n+        }\n+        if (allOffline) {\n+          iterator.remove();\n+        }\n+      }\n+    }\n+    if (!partitionInstancesToCheck.isEmpty()) {\n+      throw new IllegalStateException(String.format(\n+          \"Timed out waiting for external view to stabilize after disable/reset call. Skipping enable of segments of table: %s\",\n+          tableNameWithType));\n+    }\n+\n+    // Enable partitions\n+    LOGGER.info(\"Enabling partitions of table: {}\", tableNameWithType);\n+    for (Map.Entry<String, Set<String>> entry : resetInstanceToPartitionsMap.entrySet()) {\n+      ArrayList<String> partitions = Lists.newArrayList(entry.getValue());\n+      _helixAdmin.enablePartition(true, _helixClusterName, entry.getKey(), tableNameWithType, partitions);\n+    }\n+    for (Map.Entry<String, Set<String>> entry : disableInstanceToPartitionsMap.entrySet()) {\n+      ArrayList<String> partitions = Lists.newArrayList(entry.getValue());\n+      _helixAdmin.enablePartition(true, _helixClusterName, entry.getKey(), tableNameWithType, partitions);", "originalCommit": "d4952f9e7f01143a286bed19bbd0102525ad12c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI1MDQyMA==", "url": "https://github.com/apache/pinot/pull/6336#discussion_r548250420", "bodyText": "the one in line 1869 is a disable.", "author": "npawar", "createdAt": "2020-12-23T21:23:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA5MDI3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMxNDc4Mw==", "url": "https://github.com/apache/pinot/pull/6336#discussion_r548314783", "bodyText": "Agreed. My bad.", "author": "mcvsubbu", "createdAt": "2020-12-23T23:14:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA5MDI3Ng=="}], "type": "inlineReview"}, {"oid": "b85aec7b8d62f702bc633ce81243edad8219de75", "url": "https://github.com/apache/pinot/commit/b85aec7b8d62f702bc633ce81243edad8219de75", "message": "s/partitions/segments", "committedDate": "2020-12-29T00:40:52Z", "type": "commit"}, {"oid": "7b42d947d15256a2150074f08045b803dc11f73f", "url": "https://github.com/apache/pinot/commit/7b42d947d15256a2150074f08045b803dc11f73f", "message": "some comments", "committedDate": "2020-12-29T01:22:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk1MzczNQ==", "url": "https://github.com/apache/pinot/pull/6336#discussion_r549953735", "body": "what is the exception thrown if it takes longer for whatever reason?", "bodyText": "what is the exception thrown if it takes longer for whatever reason?", "bodyHTML": "<p dir=\"auto\">what is the exception thrown if it takes longer for whatever reason?</p>", "author": "kishoreg", "createdAt": "2020-12-30T06:44:58Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -355,6 +355,67 @@ public SuccessResponse reloadSegment(\n     }\n   }\n \n+  /**\n+   * Resets the segment of the table, by disabling and then enabling it.\n+   * This API will take segments to OFFLINE state, wait for External View to stabilize, and then back to ONLINE/CONSUMING state,\n+   * thus effective in resetting segments or consumers in error states.\n+   */\n+  @POST\n+  @Path(\"segments/{tableNameWithType}/{segmentName}/reset\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Resets a segment by first disabling it, waiting for external view to stabilize, and finally enabling it again\", notes = \"Resets a segment by disabling and then enabling the segment\")\n+  public SuccessResponse resetSegment(\n+      @ApiParam(value = \"Name of the table with type\", required = true) @PathParam(\"tableNameWithType\") String tableNameWithType,\n+      @ApiParam(value = \"Name of the segment\", required = true) @PathParam(\"segmentName\") @Encoded String segmentName,\n+      @ApiParam(value = \"Maximum time in milliseconds to wait for reset to be completed. By default, uses serverAdminRequestTimeout\") @QueryParam(\"maxWaitTimeMs\") long maxWaitTimeMs) {\n+    segmentName = URIUtils.decode(segmentName);\n+    TableType tableType = TableNameBuilder.getTableTypeFromTableName(tableNameWithType);\n+    try {\n+      Preconditions.checkState(tableType != null, \"Must provide table name with type: %s\", tableNameWithType);\n+      _pinotHelixResourceManager.resetSegment(tableNameWithType, segmentName,\n+          maxWaitTimeMs > 0 ? maxWaitTimeMs : _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+      return new SuccessResponse(\n+          String.format(\"Successfully reset segment: %s of table: %s\", segmentName, tableNameWithType));\n+    } catch (IllegalStateException e) {\n+      throw new ControllerApplicationException(LOGGER,\n+          String.format(\"Failed to reset segments in table: %s. %s\", tableNameWithType, e.getMessage()),\n+          Status.NOT_FOUND);\n+    } catch (Exception e) {\n+      throw new ControllerApplicationException(LOGGER,\n+          String.format(\"Failed to reset segment: %s of table: %s. %s\", segmentName, tableNameWithType, e.getMessage()),\n+          Status.INTERNAL_SERVER_ERROR);\n+    }\n+  }\n+\n+  /**\n+   * Resets all segments of the given table\n+   * This API will take segments to OFFLINE state, wait for External View to stabilize, and then back to ONLINE/CONSUMING state,\n+   * thus effective in resetting segments or consumers in error states.\n+   */\n+  @POST\n+  @Path(\"segments/{tableNameWithType}/reset\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Resets all segments of the table, by first disabling them, waiting for external view to stabilize, and finally enabling the segments\", notes = \"Resets a segment by disabling and then enabling a segment\")\n+  public SuccessResponse resetAllSegments(\n+      @ApiParam(value = \"Name of the table with type\", required = true) @PathParam(\"tableNameWithType\") String tableNameWithType,\n+      @ApiParam(value = \"Maximum time in milliseconds to wait for reset to be completed. By default, uses serverAdminRequestTimeout\") @QueryParam(\"maxWaitTimeMs\") long maxWaitTimeMs) {\n+    TableType tableType = TableNameBuilder.getTableTypeFromTableName(tableNameWithType);\n+    try {\n+      Preconditions.checkState(tableType != null, \"Must provide table name with type: %s\", tableNameWithType);\n+      _pinotHelixResourceManager.resetAllSegments(tableNameWithType,", "originalCommit": "7b42d947d15256a2150074f08045b803dc11f73f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDAwODA2MQ==", "url": "https://github.com/apache/pinot/pull/6336#discussion_r550008061", "bodyText": "Timed out waiting for external view to stabilize after call to disable/reset segment: %s of table: %s. Skipping enable of segment", "author": "npawar", "createdAt": "2020-12-30T07:59:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk1MzczNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk1NTYwNQ==", "url": "https://github.com/apache/pinot/pull/6336#discussion_r549955605", "body": "handle timeout exception separately and lets make sure we provide the right message that it timed out but it might get completed in the background?", "bodyText": "handle timeout exception separately and lets make sure we provide the right message that it timed out but it might get completed in the background?", "bodyHTML": "<p dir=\"auto\">handle timeout exception separately and lets make sure we provide the right message that it timed out but it might get completed in the background?</p>", "author": "kishoreg", "createdAt": "2020-12-30T06:47:30Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -355,6 +355,67 @@ public SuccessResponse reloadSegment(\n     }\n   }\n \n+  /**\n+   * Resets the segment of the table, by disabling and then enabling it.\n+   * This API will take segments to OFFLINE state, wait for External View to stabilize, and then back to ONLINE/CONSUMING state,\n+   * thus effective in resetting segments or consumers in error states.\n+   */\n+  @POST\n+  @Path(\"segments/{tableNameWithType}/{segmentName}/reset\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Resets a segment by first disabling it, waiting for external view to stabilize, and finally enabling it again\", notes = \"Resets a segment by disabling and then enabling the segment\")\n+  public SuccessResponse resetSegment(\n+      @ApiParam(value = \"Name of the table with type\", required = true) @PathParam(\"tableNameWithType\") String tableNameWithType,\n+      @ApiParam(value = \"Name of the segment\", required = true) @PathParam(\"segmentName\") @Encoded String segmentName,\n+      @ApiParam(value = \"Maximum time in milliseconds to wait for reset to be completed. By default, uses serverAdminRequestTimeout\") @QueryParam(\"maxWaitTimeMs\") long maxWaitTimeMs) {\n+    segmentName = URIUtils.decode(segmentName);\n+    TableType tableType = TableNameBuilder.getTableTypeFromTableName(tableNameWithType);\n+    try {\n+      Preconditions.checkState(tableType != null, \"Must provide table name with type: %s\", tableNameWithType);\n+      _pinotHelixResourceManager.resetSegment(tableNameWithType, segmentName,\n+          maxWaitTimeMs > 0 ? maxWaitTimeMs : _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+      return new SuccessResponse(\n+          String.format(\"Successfully reset segment: %s of table: %s\", segmentName, tableNameWithType));\n+    } catch (IllegalStateException e) {\n+      throw new ControllerApplicationException(LOGGER,\n+          String.format(\"Failed to reset segments in table: %s. %s\", tableNameWithType, e.getMessage()),\n+          Status.NOT_FOUND);\n+    } catch (Exception e) {\n+      throw new ControllerApplicationException(LOGGER,\n+          String.format(\"Failed to reset segment: %s of table: %s. %s\", segmentName, tableNameWithType, e.getMessage()),\n+          Status.INTERNAL_SERVER_ERROR);\n+    }\n+  }\n+\n+  /**\n+   * Resets all segments of the given table\n+   * This API will take segments to OFFLINE state, wait for External View to stabilize, and then back to ONLINE/CONSUMING state,\n+   * thus effective in resetting segments or consumers in error states.\n+   */\n+  @POST\n+  @Path(\"segments/{tableNameWithType}/reset\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Resets all segments of the table, by first disabling them, waiting for external view to stabilize, and finally enabling the segments\", notes = \"Resets a segment by disabling and then enabling a segment\")\n+  public SuccessResponse resetAllSegments(\n+      @ApiParam(value = \"Name of the table with type\", required = true) @PathParam(\"tableNameWithType\") String tableNameWithType,\n+      @ApiParam(value = \"Maximum time in milliseconds to wait for reset to be completed. By default, uses serverAdminRequestTimeout\") @QueryParam(\"maxWaitTimeMs\") long maxWaitTimeMs) {\n+    TableType tableType = TableNameBuilder.getTableTypeFromTableName(tableNameWithType);\n+    try {\n+      Preconditions.checkState(tableType != null, \"Must provide table name with type: %s\", tableNameWithType);\n+      _pinotHelixResourceManager.resetAllSegments(tableNameWithType,\n+          maxWaitTimeMs > 0 ? maxWaitTimeMs : _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+      return new SuccessResponse(String.format(\"Successfully reset all segments of table: %s\", tableNameWithType));\n+    } catch (IllegalStateException e) {\n+      throw new ControllerApplicationException(LOGGER,\n+          String.format(\"Failed to reset segments in table: %s. %s\", tableNameWithType, e.getMessage()),\n+          Status.NOT_FOUND);\n+    } catch (Exception e) {", "originalCommit": "7b42d947d15256a2150074f08045b803dc11f73f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDAwNTgzMg==", "url": "https://github.com/apache/pinot/pull/6336#discussion_r550005832", "bodyText": "In case of timeout, the message will be Timed out waiting for external view to stabilize after call to disable/reset segment: %s of table: %s. Skipping enable of segment..\nThe way it is handled right now, we will return the message from the exception. And for timeout, generally 5xx response code is recommended, hence kept it with the general exception which is also 5xx.\nThe task will not get completed if there's a timeout. We will skip the enabling (as indicated in the message). In such a case, user would have to invoke API again with increased timeout.", "author": "npawar", "createdAt": "2020-12-30T07:56:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk1NTYwNQ=="}], "type": "inlineReview"}, {"oid": "415a6c75df77d28627b87764417b2424feb13a2f", "url": "https://github.com/apache/pinot/commit/415a6c75df77d28627b87764417b2424feb13a2f", "message": "Better message", "committedDate": "2020-12-30T18:19:56Z", "type": "commit"}]}