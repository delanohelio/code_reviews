{"pr_number": 3194, "pr_title": "[DROOLS-5730] improve performances of arguments fetch in executable m\u2026", "pr_author": "mariofusco", "pr_createdAt": "2020-10-27T15:49:26Z", "pr_url": "https://github.com/kiegroup/drools/pull/3194", "timeline": [{"oid": "101b2f8e00f3aebab89ce104acb7262d446ecbf3", "url": "https://github.com/kiegroup/drools/commit/101b2f8e00f3aebab89ce104acb7262d446ecbf3", "message": "[DROOLS-5730] improve performances of arguments fetch in executable model consequence", "committedDate": "2020-10-27T15:13:55Z", "type": "commit"}, {"oid": "d887b0a52f53e7a5e4c1256388dc8eafca60a22d", "url": "https://github.com/kiegroup/drools/commit/d887b0a52f53e7a5e4c1256388dc8eafca60a22d", "message": "wip", "committedDate": "2020-10-27T17:02:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI1MjM4NA==", "url": "https://github.com/kiegroup/drools/pull/3194#discussion_r513252384", "body": "Is it possible to wrap this logic in a method to improve readability? \r\n```java\r\n/**\r\n * When rule has only AND as top level, it is possible to precalculate requiredDeclarations as optimization \r\n */\r\nprivate Declaration[] getRequiredDeclarationsIfPossible( RuleContext ctx, Consequence consequence, String name ) {\r\n        boolean ruleHasFirstLevelOr = ruleHasFirstLevelOr(ctx.getRule());\r\n        Variable[] consequenceVars = consequence.getDeclarations();\r\n        String[] requiredDeclarationNames = new String[consequenceVars.length];\r\n        Declaration[] requiredDeclarations = ruleHasFirstLevelOr ? null : new Declaration[consequenceVars.length];\r\n        for (int i = 0; i < consequenceVars.length; i++) {\r\n            requiredDeclarationNames[i] = consequenceVars[i].getName();\r\n            if (!ruleHasFirstLevelOr) {\r\n                requiredDeclarations[i] = ctx.getRule().getDeclaration( requiredDeclarationNames[i] );\r\n            }\r\n        }\r\n\r\n        ctx.getRule().setRequiredDeclarationsForConsequence( name, requiredDeclarationNames );\r\n        return requiredDeclarations;\r\n}", "bodyText": "Is it possible to wrap this logic in a method to improve readability?\n/**\n * When rule has only AND as top level, it is possible to precalculate requiredDeclarations as optimization \n */\nprivate Declaration[] getRequiredDeclarationsIfPossible( RuleContext ctx, Consequence consequence, String name ) {\n        boolean ruleHasFirstLevelOr = ruleHasFirstLevelOr(ctx.getRule());\n        Variable[] consequenceVars = consequence.getDeclarations();\n        String[] requiredDeclarationNames = new String[consequenceVars.length];\n        Declaration[] requiredDeclarations = ruleHasFirstLevelOr ? null : new Declaration[consequenceVars.length];\n        for (int i = 0; i < consequenceVars.length; i++) {\n            requiredDeclarationNames[i] = consequenceVars[i].getName();\n            if (!ruleHasFirstLevelOr) {\n                requiredDeclarations[i] = ctx.getRule().getDeclaration( requiredDeclarationNames[i] );\n            }\n        }\n\n        ctx.getRule().setRequiredDeclarationsForConsequence( name, requiredDeclarationNames );\n        return requiredDeclarations;\n}", "bodyHTML": "<p dir=\"auto\">Is it possible to wrap this logic in a method to improve readability?</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"/**\n * When rule has only AND as top level, it is possible to precalculate requiredDeclarations as optimization \n */\nprivate Declaration[] getRequiredDeclarationsIfPossible( RuleContext ctx, Consequence consequence, String name ) {\n        boolean ruleHasFirstLevelOr = ruleHasFirstLevelOr(ctx.getRule());\n        Variable[] consequenceVars = consequence.getDeclarations();\n        String[] requiredDeclarationNames = new String[consequenceVars.length];\n        Declaration[] requiredDeclarations = ruleHasFirstLevelOr ? null : new Declaration[consequenceVars.length];\n        for (int i = 0; i &lt; consequenceVars.length; i++) {\n            requiredDeclarationNames[i] = consequenceVars[i].getName();\n            if (!ruleHasFirstLevelOr) {\n                requiredDeclarations[i] = ctx.getRule().getDeclaration( requiredDeclarationNames[i] );\n            }\n        }\n\n        ctx.getRule().setRequiredDeclarationsForConsequence( name, requiredDeclarationNames );\n        return requiredDeclarations;\n}\"><pre><span class=\"pl-c\"><span class=\"pl-c\">/**</span></span>\n<span class=\"pl-c\"> * When rule has only AND as top level, it is possible to precalculate requiredDeclarations as optimization </span>\n<span class=\"pl-c\"> <span class=\"pl-c\">*/</span></span>\n<span class=\"pl-k\">private</span> <span class=\"pl-k\">Declaration</span>[] getRequiredDeclarationsIfPossible( <span class=\"pl-smi\">RuleContext</span> ctx, <span class=\"pl-smi\">Consequence</span> consequence, <span class=\"pl-smi\">String</span> name ) {\n        <span class=\"pl-k\">boolean</span> ruleHasFirstLevelOr <span class=\"pl-k\">=</span> ruleHasFirstLevelOr(ctx<span class=\"pl-k\">.</span>getRule());\n        <span class=\"pl-k\">Variable</span>[] consequenceVars <span class=\"pl-k\">=</span> consequence<span class=\"pl-k\">.</span>getDeclarations();\n        <span class=\"pl-k\">String</span>[] requiredDeclarationNames <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">String</span>[consequenceVars<span class=\"pl-k\">.</span>length];\n        <span class=\"pl-k\">Declaration</span>[] requiredDeclarations <span class=\"pl-k\">=</span> ruleHasFirstLevelOr <span class=\"pl-k\">?</span> <span class=\"pl-c1\">null</span> <span class=\"pl-k\">:</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">Declaration</span>[consequenceVars<span class=\"pl-k\">.</span>length];\n        <span class=\"pl-k\">for</span> (<span class=\"pl-k\">int</span> i <span class=\"pl-k\">=</span> <span class=\"pl-c1\">0</span>; i <span class=\"pl-k\">&lt;</span> consequenceVars<span class=\"pl-k\">.</span>length; i<span class=\"pl-k\">++</span>) {\n            requiredDeclarationNames[i] <span class=\"pl-k\">=</span> consequenceVars[i]<span class=\"pl-k\">.</span>getName();\n            <span class=\"pl-k\">if</span> (<span class=\"pl-k\">!</span>ruleHasFirstLevelOr) {\n                requiredDeclarations[i] <span class=\"pl-k\">=</span> ctx<span class=\"pl-k\">.</span>getRule()<span class=\"pl-k\">.</span>getDeclaration( requiredDeclarationNames[i] );\n            }\n        }\n\n        ctx<span class=\"pl-k\">.</span>getRule()<span class=\"pl-k\">.</span>setRequiredDeclarationsForConsequence( name, requiredDeclarationNames );\n        <span class=\"pl-k\">return</span> requiredDeclarations;\n}</pre></div>", "author": "danielezonca", "createdAt": "2020-10-28T08:18:43Z", "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/KiePackagesBuilder.java", "diffHunk": "@@ -375,30 +375,50 @@ private void addQueryPattern( Query query, QueryImpl queryImpl, RuleContext ctx\n         queryImpl.setParameters( declarations );\n     }\n \n-    private void processConsequences( RuleContext ctx, Rule rule ) {\n-        for (Map.Entry<String, Consequence> entry : rule.getConsequences().entrySet()) {\n+    private void processConsequences( RuleContext ctx, Map<String, Consequence> consequences ) {\n+        for (Map.Entry<String, Consequence> entry : consequences.entrySet()) {\n             processConsequence( ctx, entry.getValue(), entry.getKey() );\n         }\n     }\n \n     private void processConsequence( RuleContext ctx, Consequence consequence, String name ) {\n+        boolean ruleHasFirstLevelOr = ruleHasFirstLevelOr(ctx.getRule());\n+        Variable[] consequenceVars = consequence.getDeclarations();\n+        String[] requiredDeclarationNames = new String[consequenceVars.length];\n+        Declaration[] requiredDeclarations = ruleHasFirstLevelOr ? null : new Declaration[consequenceVars.length];\n+        for (int i = 0; i < consequenceVars.length; i++) {\n+            requiredDeclarationNames[i] = consequenceVars[i].getName();\n+            if (!ruleHasFirstLevelOr) {\n+                requiredDeclarations[i] = ctx.getRule().getDeclaration( requiredDeclarationNames[i] );\n+            }\n+        }\n+\n+        ctx.getRule().setRequiredDeclarationsForConsequence( name, requiredDeclarationNames );", "originalCommit": "d887b0a52f53e7a5e4c1256388dc8eafca60a22d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI1Mzg0Ng==", "url": "https://github.com/kiegroup/drools/pull/3194#discussion_r513253846", "body": "```suggestion\r\n        // declarations is not null when first level rule is AND so it is possible to calculate them upfront\r\n        } else {\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } else {\n          \n          \n            \n                    // declarations is not null when first level rule is AND so it is possible to calculate them upfront\n          \n          \n            \n                    } else {", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"62\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"x x-first\">} </span><span class=\"pl-k x\">else</span><span class=\"x x-last\"> {</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"62\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-c\"><span class=\"pl-c x x-first\">//</span><span class=\"x x-last\"> declarations is not null when first level rule is AND so it is possible to calculate them upfront</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"63\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        } <span class=\"pl-k\">else</span> {</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "danielezonca", "createdAt": "2020-10-28T08:21:14Z", "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/consequence/LambdaConsequence.java", "diffHunk": "@@ -43,23 +52,28 @@ public String getName() {\n \n     @Override\n     public void evaluate( KnowledgeHelper knowledgeHelper, WorkingMemory workingMemory ) throws Exception {\n-        Declaration[] declarations = ((RuleTerminalNode)knowledgeHelper.getMatch().getTuple().getTupleSink()).getRequiredDeclarations();\n-        Object[] facts = declarationsToFacts( knowledgeHelper, workingMemory, knowledgeHelper.getTuple(), declarations, consequence.getVariables(), consequence.isUsingDrools() );\n+        Object[] facts;\n+        if ( this.declarations == null ) {\n+            Declaration[] declarations = (( RuleTerminalNode ) knowledgeHelper.getMatch().getTuple().getTupleSink()).getRequiredDeclarations();\n+            facts = declarationsToFacts( knowledgeHelper, ( InternalWorkingMemory ) workingMemory, knowledgeHelper.getTuple(), declarations, consequence.getVariables(), consequence.isUsingDrools() );\n+        } else {", "originalCommit": "d887b0a52f53e7a5e4c1256388dc8eafca60a22d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI1NDM1NQ==", "url": "https://github.com/kiegroup/drools/pull/3194#discussion_r513254355", "body": "Is this an additional/unrelated bugfix/improvement?", "bodyText": "Is this an additional/unrelated bugfix/improvement?", "bodyHTML": "<p dir=\"auto\">Is this an additional/unrelated bugfix/improvement?</p>", "author": "danielezonca", "createdAt": "2020-10-28T08:22:07Z", "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/consequence/LambdaConsequence.java", "diffHunk": "@@ -69,19 +83,184 @@ public void evaluate( KnowledgeHelper knowledgeHelper, WorkingMemory workingMemo\n             if ( var.isFact() ) {\n                 Declaration declaration = declarations[declrCounter++];\n                 InternalFactHandle fh = getOriginalFactHandle( tuple.get( declaration ) );\n-                if (useDrools) {\n-                    ( (DroolsImpl) facts[0] ).registerFactHandle( fh );\n+                if ( useDrools ) {\n+                    (( DroolsImpl ) facts[0]).registerFactHandle( fh );\n                 }\n-                facts[factsOffset++] = declaration.getValue( (InternalWorkingMemory ) workingMemory, fh.getObject() );\n+                facts[factsOffset++] = declaration.getValue( workingMemory, fh.getObject() );\n             } else {\n                 facts[factsOffset++] = workingMemory.getGlobal( var.getName() );\n             }\n         }\n         return facts;\n     }\n \n-    private static InternalFactHandle getOriginalFactHandle(InternalFactHandle handle) {\n-        InternalFactHandle linkedFH = handle.isEvent() ? ((EventFactHandle )handle).getLinkedFactHandle() : null;\n+    private static InternalFactHandle getOriginalFactHandle( InternalFactHandle handle ) {\n+        if ( !handle.isEvent() ) {\n+            return handle;\n+        }", "originalCommit": "d887b0a52f53e7a5e4c1256388dc8eafca60a22d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI2MDQ5OA==", "url": "https://github.com/kiegroup/drools/pull/3194#discussion_r513260498", "bodyText": "If look at the old code\n    private static InternalFactHandle getOriginalFactHandle( InternalFactHandle handle ) {\n        InternalFactHandle linkedFH = handle.isEvent() ? ((EventFactHandle )handle).getLinkedFactHandle() : null;\n        return linkedFH != null ? linkedFH : handle;\n    }\n\n\nand at the new one\n    private static InternalFactHandle getOriginalFactHandle( InternalFactHandle handle ) {\n        if ( !handle.isEvent() ) {\n            return handle;\n        }\n        InternalFactHandle linkedFH = (( EventFactHandle ) handle).getLinkedFactHandle();\n        return linkedFH != null ? linkedFH : handle;\n    }\n\nyou will realize that the 2 codes are functionally identical: if the handle is not an event nothing has to be done and the handle can be used as it is. I just wanted to make this thing more explicit and avoid a useless second null check in that case.", "author": "mariofusco", "createdAt": "2020-10-28T08:32:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI1NDM1NQ=="}], "type": "inlineReview"}, {"oid": "3e28754f3289232005c0aba1ef3d96ed59612112", "url": "https://github.com/kiegroup/drools/commit/3e28754f3289232005c0aba1ef3d96ed59612112", "message": "fix multithreading use of LambdaConsequence + add a few comments", "committedDate": "2020-10-28T08:55:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3MTEzNw==", "url": "https://github.com/kiegroup/drools/pull/3194#discussion_r513571137", "body": "Can you please first introduce the optimization and then explain why it is not applicable to `OR`? :)", "bodyText": "Can you please first introduce the optimization and then explain why it is not applicable to OR? :)", "bodyHTML": "<p dir=\"auto\">Can you please first introduce the optimization and then explain why it is not applicable to <code>OR</code>? :)</p>", "author": "danielezonca", "createdAt": "2020-10-28T16:08:10Z", "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/KiePackagesBuilder.java", "diffHunk": "@@ -375,30 +375,54 @@ private void addQueryPattern( Query query, QueryImpl queryImpl, RuleContext ctx\n         queryImpl.setParameters( declarations );\n     }\n \n-    private void processConsequences( RuleContext ctx, Rule rule ) {\n-        for (Map.Entry<String, Consequence> entry : rule.getConsequences().entrySet()) {\n+    private void processConsequences( RuleContext ctx, Map<String, Consequence> consequences ) {\n+        for (Map.Entry<String, Consequence> entry : consequences.entrySet()) {\n             processConsequence( ctx, entry.getValue(), entry.getKey() );\n         }\n     }\n \n     private void processConsequence( RuleContext ctx, Consequence consequence, String name ) {\n+        // If there's an OR in the rule the fired tuple hasn't fixed structure and size because it dependens\n+        // on which branch of the OR gets activated. In this case no optimization is possible and it's usless\n+        // to precalculate the declartions at compile time.", "originalCommit": "3e28754f3289232005c0aba1ef3d96ed59612112", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3ODIyOA==", "url": "https://github.com/kiegroup/drools/pull/3194#discussion_r513578228", "body": "Can you refer the optimization here too (in the future we will not have the PR to see the whole code together :) )?", "bodyText": "Can you refer the optimization here too (in the future we will not have the PR to see the whole code together :) )?", "bodyHTML": "<p dir=\"auto\">Can you refer the optimization here too (in the future we will not have the PR to see the whole code together :) )?</p>", "author": "danielezonca", "createdAt": "2020-10-28T16:17:16Z", "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/consequence/LambdaConsequence.java", "diffHunk": "@@ -69,19 +84,196 @@ public void evaluate( KnowledgeHelper knowledgeHelper, WorkingMemory workingMemo\n             if ( var.isFact() ) {\n                 Declaration declaration = declarations[declrCounter++];\n                 InternalFactHandle fh = getOriginalFactHandle( tuple.get( declaration ) );\n-                if (useDrools) {\n-                    ( (DroolsImpl) facts[0] ).registerFactHandle( fh );\n+                if ( useDrools ) {\n+                    (( DroolsImpl ) facts[0]).registerFactHandle( fh );\n                 }\n-                facts[factsOffset++] = declaration.getValue( (InternalWorkingMemory ) workingMemory, fh.getObject() );\n+                facts[factsOffset++] = declaration.getValue( workingMemory, fh.getObject() );\n             } else {\n                 facts[factsOffset++] = workingMemory.getGlobal( var.getName() );\n             }\n         }\n         return facts;\n     }\n \n-    private static InternalFactHandle getOriginalFactHandle(InternalFactHandle handle) {\n-        InternalFactHandle linkedFH = handle.isEvent() ? ((EventFactHandle )handle).getLinkedFactHandle() : null;\n+    private static InternalFactHandle getOriginalFactHandle( InternalFactHandle handle ) {\n+        if ( !handle.isEvent() ) {\n+            return handle;\n+        }\n+        InternalFactHandle linkedFH = (( EventFactHandle ) handle).getLinkedFactHandle();\n         return linkedFH != null ? linkedFH : handle;\n     }\n-}\n+\n+    private Object[] fetchFacts( KnowledgeHelper knowledgeHelper, InternalWorkingMemory workingMemory ) {\n+        Tuple tuple = knowledgeHelper.getTuple();\n+        if (factSuppliers == null) {\n+            return initConsequence(knowledgeHelper, workingMemory, tuple);\n+        }\n+        Object[] facts = new Object[factSuppliers.length];\n+        for (int i = 0; i < facts.length; i++) {\n+            tuple = factSuppliers[i].get( facts, knowledgeHelper, workingMemory, tuple );\n+        }\n+        return facts;\n+    }\n+\n+    private Object[] initConsequence( KnowledgeHelper knowledgeHelper, InternalWorkingMemory workingMemory, Tuple tuple ) {\n+        Variable[] vars = consequence.getVariables();\n+        List<FactSupplier> factSuppliers = new ArrayList<>();\n+\n+        Object[] facts;\n+        int factsOffset = 0;\n+        if ( consequence.isUsingDrools() ) {\n+            factsOffset++;\n+            factSuppliers.add( DroolsImplSupplier.INSTANCE );\n+            facts = new Object[vars.length + 1];\n+            facts[0] = new DroolsImpl( knowledgeHelper, workingMemory );\n+        } else {\n+            facts = new Object[vars.length];\n+        }\n+\n+        int declrCounter = 0;\n+        for (Variable var : vars) {\n+            if ( var.isFact() ) {\n+                factSuppliers.add( new TupleFactSupplier(factsOffset, declarations[declrCounter++], consequence.isUsingDrools()) );\n+            } else {\n+                facts[factsOffset] = workingMemory.getGlobal( var.getName() );\n+                factSuppliers.add( new GlobalSupplier(factsOffset, var.getName()) );\n+            }\n+            factsOffset++;\n+        }\n+\n+        // At this point the FactSuppliers (each of them supplying a single argument to be passed to the consequence)", "originalCommit": "3e28754f3289232005c0aba1ef3d96ed59612112", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1df73e5ba100d99c28b3f4ad55fe1e1da17f546b", "url": "https://github.com/kiegroup/drools/commit/1df73e5ba100d99c28b3f4ad55fe1e1da17f546b", "message": "wip", "committedDate": "2020-10-28T18:05:41Z", "type": "commit"}]}