{"pr_number": 8026, "pr_title": "ISPN-11050 StreamDistPartitionHandlingTest.testUsingIteratorButPartit\u2026", "pr_author": "wburns", "pr_createdAt": "2020-03-10T20:15:52Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8026", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY2NTY3Mw==", "url": "https://github.com/infinispan/infinispan/pull/8026#discussion_r391665673", "body": "I suggest extracting a variable for the executor.\r\n\r\nCurrently even `CheckPoint.future()` has an executor parameter, so that we don't block the main thread that's triggering the event, but I wonder if we could make the executor a `CheckPoint` constructor parameter and always use `AbstractInfinispanTest.testExecutor()`.", "bodyText": "I suggest extracting a variable for the executor.\nCurrently even CheckPoint.future() has an executor parameter, so that we don't block the main thread that's triggering the event, but I wonder if we could make the executor a CheckPoint constructor parameter and always use AbstractInfinispanTest.testExecutor().", "bodyHTML": "<p dir=\"auto\">I suggest extracting a variable for the executor.</p>\n<p dir=\"auto\">Currently even <code>CheckPoint.future()</code> has an executor parameter, so that we don't block the main thread that's triggering the event, but I wonder if we could make the executor a <code>CheckPoint</code> constructor parameter and always use <code>AbstractInfinispanTest.testExecutor()</code>.</p>", "author": "danberindei", "createdAt": "2020-03-12T14:37:21Z", "path": "core/src/test/java/org/infinispan/partitionhandling/StreamDistPartitionHandlingTest.java", "diffHunk": "@@ -81,7 +87,8 @@ public void testUsingIteratorButPartitionOccursBeforeRetrievingRemoteValues() th\n       // We let the completeable future be returned - but don't let it process the values yet\n       iteratorCP.triggerForever(Mocks.BEFORE_RELEASE);\n       // This must be before the stream is generated or else it won't see the update\n-      blockUntilRemoteNodesRespond(iteratorCP, cache0);\n+      blockUntilRemoteNodesRespond(iteratorCP, cache0, TestingUtil.extractGlobalComponent(cache0.getCacheManager(),\n+            Executor.class, KnownComponentNames.BLOCKING_EXECUTOR));", "originalCommit": "8c7e06140530ca8fdca5db055bbd2fb8187c7182", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgxNjI2MQ==", "url": "https://github.com/infinispan/infinispan/pull/8026#discussion_r391816261", "bodyText": "I was unaware of Checkpoint.future tbh.", "author": "wburns", "createdAt": "2020-03-12T18:34:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY2NTY3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY3MDI1NQ==", "url": "https://github.com/infinispan/infinispan/pull/8026#discussion_r391670255", "body": "I feel like this obfuscates things a bit, because the CP doesn't block by itself, so the comment should be about who's waiting on those CP events.", "bodyText": "I feel like this obfuscates things a bit, because the CP doesn't block by itself, so the comment should be about who's waiting on those CP events.", "bodyHTML": "<p dir=\"auto\">I feel like this obfuscates things a bit, because the CP doesn't block by itself, so the comment should be about who's waiting on those CP events.</p>", "author": "danberindei", "createdAt": "2020-03-12T14:44:02Z", "path": "core/src/test/java/org/infinispan/partitionhandling/StreamDistPartitionHandlingTest.java", "diffHunk": "@@ -119,11 +126,20 @@ public void testUsingIteratorButPartitionOccursAfterRetrievingRemoteValues() thr\n       cache0.put(new MagicKey(cache(1), cache(2)), \"not-local\");\n       cache0.put(new MagicKey(cache(0), cache(1)), \"local\");\n \n+      CheckPoint iteratorCP = new CheckPoint();\n+      // Let the iterator CP just continue without blocking", "originalCommit": "8c7e06140530ca8fdca5db055bbd2fb8187c7182", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgxODg0Nw==", "url": "https://github.com/infinispan/infinispan/pull/8026#discussion_r391818847", "bodyText": "Reworded and moved.", "author": "wburns", "createdAt": "2020-03-12T18:39:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY3MDI1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY3Mjk0NQ==", "url": "https://github.com/infinispan/infinispan/pull/8026#discussion_r391672945", "body": "The method name suggests that we're waiting for an event here, but looking at the implementation it looks like the publisher is going to block until we unblock it?\r\n\r\n`blockUntilRemoteNodesRespond()` has the same problem of appearing to block the current thread at the call site but actually blocking something else.", "bodyText": "The method name suggests that we're waiting for an event here, but looking at the implementation it looks like the publisher is going to block until we unblock it?\nblockUntilRemoteNodesRespond() has the same problem of appearing to block the current thread at the call site but actually blocking something else.", "bodyHTML": "<p dir=\"auto\">The method name suggests that we're waiting for an event here, but looking at the implementation it looks like the publisher is going to block until we unblock it?</p>\n<p dir=\"auto\"><code>blockUntilRemoteNodesRespond()</code> has the same problem of appearing to block the current thread at the call site but actually blocking something else.</p>", "author": "danberindei", "createdAt": "2020-03-12T14:47:52Z", "path": "core/src/test/java/org/infinispan/partitionhandling/StreamDistPartitionHandlingTest.java", "diffHunk": "@@ -119,11 +126,20 @@ public void testUsingIteratorButPartitionOccursAfterRetrievingRemoteValues() thr\n       cache0.put(new MagicKey(cache(1), cache(2)), \"not-local\");\n       cache0.put(new MagicKey(cache(0), cache(1)), \"local\");\n \n+      CheckPoint iteratorCP = new CheckPoint();\n+      // Let the iterator CP just continue without blocking\n+      iteratorCP.triggerForever(Mocks.BEFORE_RELEASE);\n+      iteratorCP.triggerForever(Mocks.AFTER_RELEASE);\n+\n+      blockUntilPublisherComplete(iteratorCP, cache0);", "originalCommit": "8c7e06140530ca8fdca5db055bbd2fb8187c7182", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgyNTkyNw==", "url": "https://github.com/infinispan/infinispan/pull/8026#discussion_r391825927", "bodyText": "Renaming", "author": "wburns", "createdAt": "2020-03-12T18:52:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY3Mjk0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY4NDU2NA==", "url": "https://github.com/infinispan/infinispan/pull/8026#discussion_r391684564", "body": "If at all possible, I'd rather create a mock that delegates to the existing component instead of using `spy()`.\r\n\r\nThe instance created by `spy()` has all the annotations, so after copying the state of the existing component (without any synchronization), the component registry will call `start()` on the new instance, which may break things.\r\n\r\nOf course, using `mock()` has the opposite problem: the component registry won't call `stop()` on it, which depending on component may hang the test during shutdown. For this reason I've usually written a custom mock class for the component I'm mocking, but it should be possible to use a generic `AbstractMockComponent` class that delegates injection/start/stop and then use `mock(AbstractMockComponent.class, withSettings.additionalInterfaces(componentClass)` to implement the needed interface.\r\n\r\nAnd after writing all of this I realize it's probably too much for this PR, which is merely moving the method...\r\nI'll put it on my TODO list and maybe get to it at some point :)", "bodyText": "If at all possible, I'd rather create a mock that delegates to the existing component instead of using spy().\nThe instance created by spy() has all the annotations, so after copying the state of the existing component (without any synchronization), the component registry will call start() on the new instance, which may break things.\nOf course, using mock() has the opposite problem: the component registry won't call stop() on it, which depending on component may hang the test during shutdown. For this reason I've usually written a custom mock class for the component I'm mocking, but it should be possible to use a generic AbstractMockComponent class that delegates injection/start/stop and then use mock(AbstractMockComponent.class, withSettings.additionalInterfaces(componentClass) to implement the needed interface.\nAnd after writing all of this I realize it's probably too much for this PR, which is merely moving the method...\nI'll put it on my TODO list and maybe get to it at some point :)", "bodyHTML": "<p dir=\"auto\">If at all possible, I'd rather create a mock that delegates to the existing component instead of using <code>spy()</code>.</p>\n<p dir=\"auto\">The instance created by <code>spy()</code> has all the annotations, so after copying the state of the existing component (without any synchronization), the component registry will call <code>start()</code> on the new instance, which may break things.</p>\n<p dir=\"auto\">Of course, using <code>mock()</code> has the opposite problem: the component registry won't call <code>stop()</code> on it, which depending on component may hang the test during shutdown. For this reason I've usually written a custom mock class for the component I'm mocking, but it should be possible to use a generic <code>AbstractMockComponent</code> class that delegates injection/start/stop and then use <code>mock(AbstractMockComponent.class, withSettings.additionalInterfaces(componentClass)</code> to implement the needed interface.</p>\n<p dir=\"auto\">And after writing all of this I realize it's probably too much for this PR, which is merely moving the method...<br>\nI'll put it on my TODO list and maybe get to it at some point :)</p>", "author": "danberindei", "createdAt": "2020-03-12T15:04:10Z", "path": "core/src/test/java/org/infinispan/test/Mocks.java", "diffHunk": "@@ -208,4 +214,20 @@ private Mocks() { }\n          blockingPublisher((Subscriber<? super E> innerSubscriber) -> publisher.subscribe(innerSubscriber, complete), checkPoint).subscribe(s);\n       };\n    }\n+\n+   /**\n+    * Replaces the given component with a spy and returns it for further mocking as needed. Note the original component\n+    * is not retrieved and thus requires retrieving before invoking this method if needed.\n+    * @param cache the cache to get the component from\n+    * @param componentClass the class of the component to retrieve\n+    * @param <C> the component class\n+    * @return the spied component which has already been replaced and wired in the cache\n+    */\n+   public static <C> C replaceComponentWithSpy(Cache<?,?> cache, Class<C> componentClass) {\n+      C component = TestingUtil.extractComponent(cache, componentClass);\n+      C spiedComponent = spy(component);", "originalCommit": "8c7e06140530ca8fdca5db055bbd2fb8187c7182", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgxOTY4MQ==", "url": "https://github.com/infinispan/infinispan/pull/8026#discussion_r391819681", "bodyText": "Sounds good.", "author": "wburns", "createdAt": "2020-03-12T18:40:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY4NDU2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgxOTk1Nw==", "url": "https://github.com/infinispan/infinispan/pull/8026#discussion_r391819957", "bodyText": "I personally feel that our components should work fine being stopped and restarted, but that may be just a pipe dream.", "author": "wburns", "createdAt": "2020-03-12T18:41:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY4NDU2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI2NjU3OA==", "url": "https://github.com/infinispan/infinispan/pull/8026#discussion_r392266578", "bodyText": "Maybe we could make components restart properly without removing them from the registry and adding a new instance, but that wouldn't really help with spy(), because you're copying a component that has already been started and you're starting it again without calling stop() before.", "author": "danberindei", "createdAt": "2020-03-13T14:36:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY4NDU2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI2ODA3OQ==", "url": "https://github.com/infinispan/infinispan/pull/8026#discussion_r392268079", "bodyText": "Gotcha \ud83d\udc4d", "author": "wburns", "createdAt": "2020-03-13T14:38:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY4NDU2NA=="}], "type": "inlineReview"}, {"oid": "2df96f6a0a7e094482634d4e2ff160882fd5df6b", "url": "https://github.com/infinispan/infinispan/commit/2df96f6a0a7e094482634d4e2ff160882fd5df6b", "message": "ISPN-11050 StreamDistPartitionHandlingTest.testUsingIteratorButPartitionOccursAfterRetrievingRemoteValues random failures", "committedDate": "2020-03-12T18:53:11Z", "type": "commit"}, {"oid": "2df96f6a0a7e094482634d4e2ff160882fd5df6b", "url": "https://github.com/infinispan/infinispan/commit/2df96f6a0a7e094482634d4e2ff160882fd5df6b", "message": "ISPN-11050 StreamDistPartitionHandlingTest.testUsingIteratorButPartitionOccursAfterRetrievingRemoteValues random failures", "committedDate": "2020-03-12T18:53:11Z", "type": "forcePushed"}]}