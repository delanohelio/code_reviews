{"pr_number": 8571, "pr_title": "ISPN-10249 Upgrade to Hibernate Search 6", "pr_author": "fax4ever", "pr_createdAt": "2020-07-21T15:18:35Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8571", "merge_commit": "91d194f1a4e6f6990903ea42094be659142bb4d5", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwMTAxNA==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r458201014", "body": "I think you don't have to remove this, just replace `LUCENE_CURRENT` with `LATEST`.", "bodyText": "I think you don't have to remove this, just replace LUCENE_CURRENT with LATEST.", "bodyHTML": "<p dir=\"auto\">I think you don't have to remove this, just replace <code>LUCENE_CURRENT</code> with <code>LATEST</code>.</p>", "author": "yrodiere", "createdAt": "2020-07-21T15:46:51Z", "path": "client/hotrod-client/src/test/java/org/infinispan/client/hotrod/event/ClientListenerWithDslFilterObjectStorageTest.java", "diffHunk": "@@ -81,8 +81,7 @@ protected ConfigurationBuilder getConfigurationBuilder() {\n       cfgBuilder.encoding().key().mediaType(MediaType.APPLICATION_OBJECT_TYPE);\n       cfgBuilder.encoding().value().mediaType(MediaType.APPLICATION_OBJECT_TYPE);\n       cfgBuilder.indexing().enable()\n-            .addProperty(\"default.directory_provider\", \"local-heap\")\n-            .addProperty(\"lucene_version\", \"LUCENE_CURRENT\");", "originalCommit": "45b82c7749dc5e80335c5e14daeb6b7be47f9697", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwMTYwMg==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r458201602", "bodyText": "Though this property is indeed not necessary (LATEST is the default)", "author": "yrodiere", "createdAt": "2020-07-21T15:47:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwMTAxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI0OTU0Mw==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r459249543", "bodyText": "Shall I replace the old LUCENE_CURRENT with the LATEST? I removed them since in general I prefer have less code than more :P and in this case LATEST is the default one", "author": "fax4ever", "createdAt": "2020-07-23T06:59:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwMTAxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI1NjIxNQ==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r459256215", "bodyText": "I think it was there to avoid the warning, maybe? I just mentioned this because I was surprised by this seemingly unnecessary change.\nAnyway, it's probably not worth your time. Let's dropt his, sorry for the noise.", "author": "yrodiere", "createdAt": "2020-07-23T07:16:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwMTAxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTMwODM4Ng==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r459308386", "bodyText": "@yrodiere No noise at all, thanks. I asked myself the same question when I did this change.", "author": "fax4ever", "createdAt": "2020-07-23T08:59:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwMTAxNA=="}], "type": "inlineReview", "revised_code": {"commit": "32718114c38cd1cf83048d759033d952387d0a7e", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/event/ClientListenerWithDslFilterObjectStorageTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/event/ClientListenerWithDslFilterObjectStorageTest.java\nindex 5fa5a00f8c..25298f2d2e 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/event/ClientListenerWithDslFilterObjectStorageTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/event/ClientListenerWithDslFilterObjectStorageTest.java\n", "chunk": "@@ -81,7 +81,8 @@ protected ConfigurationBuilder getConfigurationBuilder() {\n       cfgBuilder.encoding().key().mediaType(MediaType.APPLICATION_OBJECT_TYPE);\n       cfgBuilder.encoding().value().mediaType(MediaType.APPLICATION_OBJECT_TYPE);\n       cfgBuilder.indexing().enable()\n-            .addProperty(\"directory.type\", \"local-heap\");\n+            .addProperty(\"default.directory_provider\", \"local-heap\")\n+            .addProperty(\"lucene_version\", \"LUCENE_CURRENT\");\n       return cfgBuilder;\n    }\n \n", "next_change": {"commit": "bb18590bbe7e5e9948bca940518235678d1a4fae", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/event/ClientListenerWithDslFilterObjectStorageTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/event/ClientListenerWithDslFilterObjectStorageTest.java\nindex 25298f2d2e..5fa5a00f8c 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/event/ClientListenerWithDslFilterObjectStorageTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/event/ClientListenerWithDslFilterObjectStorageTest.java\n", "chunk": "@@ -81,8 +81,7 @@ protected ConfigurationBuilder getConfigurationBuilder() {\n       cfgBuilder.encoding().key().mediaType(MediaType.APPLICATION_OBJECT_TYPE);\n       cfgBuilder.encoding().value().mediaType(MediaType.APPLICATION_OBJECT_TYPE);\n       cfgBuilder.indexing().enable()\n-            .addProperty(\"default.directory_provider\", \"local-heap\")\n-            .addProperty(\"lucene_version\", \"LUCENE_CURRENT\");\n+            .addProperty(\"directory.type\", \"local-heap\");\n       return cfgBuilder;\n    }\n \n", "next_change": {"commit": "b76eeeee768bb075a447e35324baa3d6986830f1", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/event/ClientListenerWithDslFilterObjectStorageTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/event/ClientListenerWithDslFilterObjectStorageTest.java\nindex 5fa5a00f8c..25298f2d2e 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/event/ClientListenerWithDslFilterObjectStorageTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/event/ClientListenerWithDslFilterObjectStorageTest.java\n", "chunk": "@@ -81,7 +81,8 @@ protected ConfigurationBuilder getConfigurationBuilder() {\n       cfgBuilder.encoding().key().mediaType(MediaType.APPLICATION_OBJECT_TYPE);\n       cfgBuilder.encoding().value().mediaType(MediaType.APPLICATION_OBJECT_TYPE);\n       cfgBuilder.indexing().enable()\n-            .addProperty(\"directory.type\", \"local-heap\");\n+            .addProperty(\"default.directory_provider\", \"local-heap\")\n+            .addProperty(\"lucene_version\", \"LUCENE_CURRENT\");\n       return cfgBuilder;\n    }\n \n", "next_change": {"commit": "917da575b1ba55b0147d9cbeb1e553e3b24fc837", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/event/ClientListenerWithDslFilterObjectStorageTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/event/ClientListenerWithDslFilterObjectStorageTest.java\nindex 25298f2d2e..5fa5a00f8c 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/event/ClientListenerWithDslFilterObjectStorageTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/event/ClientListenerWithDslFilterObjectStorageTest.java\n", "chunk": "@@ -81,8 +81,7 @@ protected ConfigurationBuilder getConfigurationBuilder() {\n       cfgBuilder.encoding().key().mediaType(MediaType.APPLICATION_OBJECT_TYPE);\n       cfgBuilder.encoding().value().mediaType(MediaType.APPLICATION_OBJECT_TYPE);\n       cfgBuilder.indexing().enable()\n-            .addProperty(\"default.directory_provider\", \"local-heap\")\n-            .addProperty(\"lucene_version\", \"LUCENE_CURRENT\");\n+            .addProperty(\"directory.type\", \"local-heap\");\n       return cfgBuilder;\n    }\n \n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "977d9301785ce917e98af6558d2ae77f7c27f5cf", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/event/ClientListenerWithDslFilterObjectStorageTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/event/ClientListenerWithDslFilterObjectStorageTest.java\nindex 5fa5a00f8c..6e7028a8bb 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/event/ClientListenerWithDslFilterObjectStorageTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/event/ClientListenerWithDslFilterObjectStorageTest.java\n", "chunk": "@@ -81,6 +82,7 @@ protected ConfigurationBuilder getConfigurationBuilder() {\n       cfgBuilder.encoding().key().mediaType(MediaType.APPLICATION_OBJECT_TYPE);\n       cfgBuilder.encoding().value().mediaType(MediaType.APPLICATION_OBJECT_TYPE);\n       cfgBuilder.indexing().enable()\n+            .addIndexedEntities(UserHS.class)\n             .addProperty(\"directory.type\", \"local-heap\");\n       return cfgBuilder;\n    }\n", "next_change": {"commit": "27013524412dd967281110da5edd13d20b956941", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/event/ClientListenerWithDslFilterObjectStorageTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/event/ClientListenerWithDslFilterObjectStorageTest.java\nindex 6e7028a8bb..f877899278 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/event/ClientListenerWithDslFilterObjectStorageTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/event/ClientListenerWithDslFilterObjectStorageTest.java\n", "chunk": "@@ -82,8 +83,8 @@ protected ConfigurationBuilder getConfigurationBuilder() {\n       cfgBuilder.encoding().key().mediaType(MediaType.APPLICATION_OBJECT_TYPE);\n       cfgBuilder.encoding().value().mediaType(MediaType.APPLICATION_OBJECT_TYPE);\n       cfgBuilder.indexing().enable()\n-            .addIndexedEntities(UserHS.class)\n-            .addProperty(\"directory.type\", \"local-heap\");\n+            .storage(LOCAL_HEAP)\n+            .addIndexedEntities(UserHS.class);\n       return cfgBuilder;\n    }\n \n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "91d194f1a4e6f6990903ea42094be659142bb4d5", "message": "Merge commit", "committedDate": null}, {"oid": "977d9301785ce917e98af6558d2ae77f7c27f5cf", "committedDate": "2020-10-02 18:18:48 +0300", "message": "ISPN-12286 Indexed entity declaration not enforced"}, {"oid": "27013524412dd967281110da5edd13d20b956941", "committedDate": "2020-11-27 15:54:21 +0100", "message": "ISPN-11797 Introduce strong typed indexing configuration"}]}, {"oid": "973742666427584064f0529d85af66024e57d0ab", "url": "https://github.com/infinispan/infinispan/commit/973742666427584064f0529d85af66024e57d0ab", "message": "ISPN-10249 Filter indexed-protobuf entities by cache", "committedDate": "2020-07-21T18:02:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY2OTM2NQ==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r458669365", "body": "@fax4ever Unless I'm mistaken, you're not closing the search mapping, which leads to the test failures in CI mentioning \"leaked threads\".\r\n\r\nThere are other test failures mentioning thread leaks, maybe you should have a look at them? The name of the test generally appears somewhere in the stack trace.", "bodyText": "@fax4ever Unless I'm mistaken, you're not closing the search mapping, which leads to the test failures in CI mentioning \"leaked threads\".\nThere are other test failures mentioning thread leaks, maybe you should have a look at them? The name of the test generally appears somewhere in the stack trace.", "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/fax4ever/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/fax4ever\">@fax4ever</a> Unless I'm mistaken, you're not closing the search mapping, which leads to the test failures in CI mentioning \"leaked threads\".</p>\n<p dir=\"auto\">There are other test failures mentioning thread leaks, maybe you should have a look at them? The name of the test generally appears somewhere in the stack trace.</p>", "author": "yrodiere", "createdAt": "2020-07-22T09:43:23Z", "path": "query/src/test/java/org/infinispan/query/dsl/embedded/impl/HibernateSearchPropertyHelperTest.java", "diffHunk": "@@ -20,14 +21,14 @@\n  */\n public class HibernateSearchPropertyHelperTest {\n \n-   @Rule\n-   public SearchFactoryHolder factoryHolder = new SearchFactoryHolder(TestEntity.class);\n-\n    private HibernateSearchPropertyHelper propertyHelper;\n \n    @Before\n    public void setup() {\n-      propertyHelper = new HibernateSearchPropertyHelper(factoryHolder.getSearchFactory(), new ReflectionEntityNamesResolver(null));\n+      SearchMappingHolder mappingHolder = mock(SearchMappingHolder.class);\n+      when(mappingHolder.getSearchMapping()).thenReturn(\n+            SearchMappingHelper.createSearchMappingForTests(TestEntity.class));", "originalCommit": "973742666427584064f0529d85af66024e57d0ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY3NzI5Ng==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r458677296", "bodyText": "Sure. They seems to be related to LuceneTransformationTest test instance.", "author": "fax4ever", "createdAt": "2020-07-22T09:57:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY2OTM2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY3ODA0MA==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r458678040", "bodyText": "in this test we open and (close -- maybe not) a search mapping instance manually to check the Lucene queries derived from it", "author": "fax4ever", "createdAt": "2020-07-22T09:58:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY2OTM2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY4MzQ4Mg==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r458683482", "bodyText": "Sure. They seems to be related to LuceneTransformationTest test instance.\n\nActually they are not. If you look at the stack trace, the threads were created in other tests. HibernateSearchPropertyHelperTest in particular, but there may be others.", "author": "yrodiere", "createdAt": "2020-07-22T10:07:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY2OTM2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "32718114c38cd1cf83048d759033d952387d0a7e", "changed_code": [{"header": "diff --git a/query/src/test/java/org/infinispan/query/dsl/embedded/impl/HibernateSearchPropertyHelperTest.java b/query/src/test/java/org/infinispan/query/dsl/embedded/impl/HibernateSearchPropertyHelperTest.java\nindex 54be5494cb..1c1683fef0 100644\n--- a/query/src/test/java/org/infinispan/query/dsl/embedded/impl/HibernateSearchPropertyHelperTest.java\n+++ b/query/src/test/java/org/infinispan/query/dsl/embedded/impl/HibernateSearchPropertyHelperTest.java\n", "chunk": "@@ -21,14 +20,14 @@\n  */\n public class HibernateSearchPropertyHelperTest {\n \n+   @Rule\n+   public SearchFactoryHolder factoryHolder = new SearchFactoryHolder(TestEntity.class);\n+\n    private HibernateSearchPropertyHelper propertyHelper;\n \n    @Before\n    public void setup() {\n-      SearchMappingHolder mappingHolder = mock(SearchMappingHolder.class);\n-      when(mappingHolder.getSearchMapping()).thenReturn(\n-            SearchMappingHelper.createSearchMappingForTests(TestEntity.class));\n-      propertyHelper = new HibernateSearchPropertyHelper(mappingHolder, new ReflectionEntityNamesResolver(null));\n+      propertyHelper = new HibernateSearchPropertyHelper(factoryHolder.getSearchFactory(), new ReflectionEntityNamesResolver(null));\n    }\n \n    private Object convertToPropertyType(Class<?> type, String propertyName, String value) {\n", "next_change": {"commit": "bb18590bbe7e5e9948bca940518235678d1a4fae", "changed_code": [{"header": "diff --git a/query/src/test/java/org/infinispan/query/dsl/embedded/impl/HibernateSearchPropertyHelperTest.java b/query/src/test/java/org/infinispan/query/dsl/embedded/impl/HibernateSearchPropertyHelperTest.java\nindex 1c1683fef0..54be5494cb 100644\n--- a/query/src/test/java/org/infinispan/query/dsl/embedded/impl/HibernateSearchPropertyHelperTest.java\n+++ b/query/src/test/java/org/infinispan/query/dsl/embedded/impl/HibernateSearchPropertyHelperTest.java\n", "chunk": "@@ -20,14 +21,14 @@\n  */\n public class HibernateSearchPropertyHelperTest {\n \n-   @Rule\n-   public SearchFactoryHolder factoryHolder = new SearchFactoryHolder(TestEntity.class);\n-\n    private HibernateSearchPropertyHelper propertyHelper;\n \n    @Before\n    public void setup() {\n-      propertyHelper = new HibernateSearchPropertyHelper(factoryHolder.getSearchFactory(), new ReflectionEntityNamesResolver(null));\n+      SearchMappingHolder mappingHolder = mock(SearchMappingHolder.class);\n+      when(mappingHolder.getSearchMapping()).thenReturn(\n+            SearchMappingHelper.createSearchMappingForTests(TestEntity.class));\n+      propertyHelper = new HibernateSearchPropertyHelper(mappingHolder, new ReflectionEntityNamesResolver(null));\n    }\n \n    private Object convertToPropertyType(Class<?> type, String propertyName, String value) {\n", "next_change": {"commit": "b76eeeee768bb075a447e35324baa3d6986830f1", "changed_code": [{"header": "diff --git a/query/src/test/java/org/infinispan/query/dsl/embedded/impl/HibernateSearchPropertyHelperTest.java b/query/src/test/java/org/infinispan/query/dsl/embedded/impl/HibernateSearchPropertyHelperTest.java\nindex 54be5494cb..1c1683fef0 100644\n--- a/query/src/test/java/org/infinispan/query/dsl/embedded/impl/HibernateSearchPropertyHelperTest.java\n+++ b/query/src/test/java/org/infinispan/query/dsl/embedded/impl/HibernateSearchPropertyHelperTest.java\n", "chunk": "@@ -21,14 +20,14 @@\n  */\n public class HibernateSearchPropertyHelperTest {\n \n+   @Rule\n+   public SearchFactoryHolder factoryHolder = new SearchFactoryHolder(TestEntity.class);\n+\n    private HibernateSearchPropertyHelper propertyHelper;\n \n    @Before\n    public void setup() {\n-      SearchMappingHolder mappingHolder = mock(SearchMappingHolder.class);\n-      when(mappingHolder.getSearchMapping()).thenReturn(\n-            SearchMappingHelper.createSearchMappingForTests(TestEntity.class));\n-      propertyHelper = new HibernateSearchPropertyHelper(mappingHolder, new ReflectionEntityNamesResolver(null));\n+      propertyHelper = new HibernateSearchPropertyHelper(factoryHolder.getSearchFactory(), new ReflectionEntityNamesResolver(null));\n    }\n \n    private Object convertToPropertyType(Class<?> type, String propertyName, String value) {\n", "next_change": {"commit": "917da575b1ba55b0147d9cbeb1e553e3b24fc837", "changed_code": [{"header": "diff --git a/query/src/test/java/org/infinispan/query/dsl/embedded/impl/HibernateSearchPropertyHelperTest.java b/query/src/test/java/org/infinispan/query/dsl/embedded/impl/HibernateSearchPropertyHelperTest.java\nindex 1c1683fef0..54be5494cb 100644\n--- a/query/src/test/java/org/infinispan/query/dsl/embedded/impl/HibernateSearchPropertyHelperTest.java\n+++ b/query/src/test/java/org/infinispan/query/dsl/embedded/impl/HibernateSearchPropertyHelperTest.java\n", "chunk": "@@ -20,14 +21,14 @@\n  */\n public class HibernateSearchPropertyHelperTest {\n \n-   @Rule\n-   public SearchFactoryHolder factoryHolder = new SearchFactoryHolder(TestEntity.class);\n-\n    private HibernateSearchPropertyHelper propertyHelper;\n \n    @Before\n    public void setup() {\n-      propertyHelper = new HibernateSearchPropertyHelper(factoryHolder.getSearchFactory(), new ReflectionEntityNamesResolver(null));\n+      SearchMappingHolder mappingHolder = mock(SearchMappingHolder.class);\n+      when(mappingHolder.getSearchMapping()).thenReturn(\n+            SearchMappingHelper.createSearchMappingForTests(TestEntity.class));\n+      propertyHelper = new HibernateSearchPropertyHelper(mappingHolder, new ReflectionEntityNamesResolver(null));\n    }\n \n    private Object convertToPropertyType(Class<?> type, String propertyName, String value) {\n", "next_change": {"commit": "646927489d0b43deaf39b24f4ecf19d6de430e8c", "changed_code": [{"header": "diff --git a/query/src/test/java/org/infinispan/query/dsl/embedded/impl/HibernateSearchPropertyHelperTest.java b/query/src/test/java/org/infinispan/query/dsl/embedded/impl/HibernateSearchPropertyHelperTest.java\nindex 54be5494cb..005e073ea5 100644\n--- a/query/src/test/java/org/infinispan/query/dsl/embedded/impl/HibernateSearchPropertyHelperTest.java\n+++ b/query/src/test/java/org/infinispan/query/dsl/embedded/impl/HibernateSearchPropertyHelperTest.java\n", "chunk": "@@ -21,16 +24,24 @@\n  */\n public class HibernateSearchPropertyHelperTest {\n \n+   private SearchMapping searchMapping;\n    private HibernateSearchPropertyHelper propertyHelper;\n \n    @Before\n    public void setup() {\n       SearchMappingHolder mappingHolder = mock(SearchMappingHolder.class);\n-      when(mappingHolder.getSearchMapping()).thenReturn(\n-            SearchMappingHelper.createSearchMappingForTests(TestEntity.class));\n+      searchMapping = SearchMappingHelper.createSearchMappingForTests(TestEntity.class);\n+      when(mappingHolder.getSearchMapping()).thenReturn(searchMapping);\n       propertyHelper = new HibernateSearchPropertyHelper(mappingHolder, new ReflectionEntityNamesResolver(null));\n    }\n \n+   @After\n+   public void cleanUp() {\n+      if ( searchMapping != null ) {\n+         searchMapping.close();\n+      }\n+   }\n+\n    private Object convertToPropertyType(Class<?> type, String propertyName, String value) {\n       return propertyHelper.convertToPropertyType(type, new String[]{propertyName}, value);\n    }\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "91d194f1a4e6f6990903ea42094be659142bb4d5", "changed_code": [{"header": "diff --git a/query/src/test/java/org/infinispan/query/dsl/embedded/impl/HibernateSearchPropertyHelperTest.java b/query/src/test/java/org/infinispan/query/dsl/embedded/impl/HibernateSearchPropertyHelperTest.java\nindex 54be5494cb..005e073ea5 100644\n--- a/query/src/test/java/org/infinispan/query/dsl/embedded/impl/HibernateSearchPropertyHelperTest.java\n+++ b/query/src/test/java/org/infinispan/query/dsl/embedded/impl/HibernateSearchPropertyHelperTest.java\n", "chunk": "@@ -21,16 +24,24 @@\n  */\n public class HibernateSearchPropertyHelperTest {\n \n+   private SearchMapping searchMapping;\n    private HibernateSearchPropertyHelper propertyHelper;\n \n    @Before\n    public void setup() {\n       SearchMappingHolder mappingHolder = mock(SearchMappingHolder.class);\n-      when(mappingHolder.getSearchMapping()).thenReturn(\n-            SearchMappingHelper.createSearchMappingForTests(TestEntity.class));\n+      searchMapping = SearchMappingHelper.createSearchMappingForTests(TestEntity.class);\n+      when(mappingHolder.getSearchMapping()).thenReturn(searchMapping);\n       propertyHelper = new HibernateSearchPropertyHelper(mappingHolder, new ReflectionEntityNamesResolver(null));\n    }\n \n+   @After\n+   public void cleanUp() {\n+      if ( searchMapping != null ) {\n+         searchMapping.close();\n+      }\n+   }\n+\n    private Object convertToPropertyType(Class<?> type, String propertyName, String value) {\n       return propertyHelper.convertToPropertyType(type, new String[]{propertyName}, value);\n    }\n", "next_change": {"commit": "337c7f8cd2a815a4ac6eb38e0db2dc0648a06668", "changed_code": [{"header": "diff --git a/query/src/test/java/org/infinispan/query/dsl/embedded/impl/HibernateSearchPropertyHelperTest.java b/query/src/test/java/org/infinispan/query/dsl/embedded/impl/HibernateSearchPropertyHelperTest.java\nindex 005e073ea5..4c816b09d0 100644\n--- a/query/src/test/java/org/infinispan/query/dsl/embedded/impl/HibernateSearchPropertyHelperTest.java\n+++ b/query/src/test/java/org/infinispan/query/dsl/embedded/impl/HibernateSearchPropertyHelperTest.java\n", "chunk": "@@ -29,15 +26,13 @@ public class HibernateSearchPropertyHelperTest {\n \n    @Before\n    public void setup() {\n-      SearchMappingHolder mappingHolder = mock(SearchMappingHolder.class);\n       searchMapping = SearchMappingHelper.createSearchMappingForTests(TestEntity.class);\n-      when(mappingHolder.getSearchMapping()).thenReturn(searchMapping);\n-      propertyHelper = new HibernateSearchPropertyHelper(mappingHolder, new ReflectionEntityNamesResolver(null));\n+      propertyHelper = new HibernateSearchPropertyHelper(searchMapping, new ReflectionEntityNamesResolver(null));\n    }\n \n    @After\n    public void cleanUp() {\n-      if ( searchMapping != null ) {\n+      if (searchMapping != null) {\n          searchMapping.close();\n       }\n    }\n", "next_change": {"commit": "b1db081655471507e500327af03cd0c51ecf2354", "changed_code": [{"header": "diff --git a/query/src/test/java/org/infinispan/query/dsl/embedded/impl/HibernateSearchPropertyHelperTest.java b/query/src/test/java/org/infinispan/query/dsl/embedded/impl/HibernateSearchPropertyHelperTest.java\nindex 4c816b09d0..37247f63fc 100644\n--- a/query/src/test/java/org/infinispan/query/dsl/embedded/impl/HibernateSearchPropertyHelperTest.java\n+++ b/query/src/test/java/org/infinispan/query/dsl/embedded/impl/HibernateSearchPropertyHelperTest.java\n", "chunk": "@@ -3,38 +3,51 @@\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n-import org.hibernate.search.annotations.Analyze;\n-import org.hibernate.search.annotations.Field;\n-import org.hibernate.search.annotations.Indexed;\n-import org.hibernate.search.annotations.Store;\n import org.hibernate.search.mapper.pojo.mapping.definition.annotation.DocumentId;\n+import org.infinispan.api.annotations.indexing.Basic;\n+import org.infinispan.api.annotations.indexing.Indexed;\n+import org.infinispan.api.annotations.indexing.Text;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n import org.infinispan.objectfilter.impl.syntax.parser.ReflectionEntityNamesResolver;\n import org.infinispan.query.helper.SearchMappingHelper;\n import org.infinispan.search.mapper.mapping.SearchMapping;\n-import org.junit.After;\n-import org.junit.Before;\n-import org.junit.Test;\n+import org.infinispan.test.SingleCacheManagerTest;\n+import org.infinispan.test.fwk.TestCacheManagerFactory;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.NonBlockingManager;\n+import org.testng.annotations.Test;\n \n /**\n  * @author anistor@redhat.com\n  * @since 9.0\n  */\n-public class HibernateSearchPropertyHelperTest {\n+public class HibernateSearchPropertyHelperTest extends SingleCacheManagerTest {\n \n    private SearchMapping searchMapping;\n    private HibernateSearchPropertyHelper propertyHelper;\n \n-   @Before\n-   public void setup() {\n-      searchMapping = SearchMappingHelper.createSearchMappingForTests(TestEntity.class);\n+   @Override\n+   protected EmbeddedCacheManager createCacheManager() throws Exception {\n+      EmbeddedCacheManager cacheManager = TestCacheManagerFactory.createCacheManager();\n+\n+      GlobalComponentRegistry componentRegistry = cacheManager.getGlobalComponentRegistry();\n+      BlockingManager blockingManager = componentRegistry.getComponent(BlockingManager.class);\n+      NonBlockingManager nonBlockingManager = componentRegistry.getComponent(NonBlockingManager.class);\n+\n+      // the cache manager is created only to provide manager instances to the search mapping\n+      searchMapping = SearchMappingHelper.createSearchMappingForTests(blockingManager, nonBlockingManager, TestEntity.class);\n       propertyHelper = new HibernateSearchPropertyHelper(searchMapping, new ReflectionEntityNamesResolver(null));\n+\n+      return cacheManager;\n    }\n \n-   @After\n-   public void cleanUp() {\n+   @Override\n+   protected void teardown() {\n       if (searchMapping != null) {\n          searchMapping.close();\n       }\n+      super.teardown();\n    }\n \n    private Object convertToPropertyType(Class<?> type, String propertyName, String value) {\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "91d194f1a4e6f6990903ea42094be659142bb4d5", "message": "Merge commit", "committedDate": null}, {"oid": "8886d88b423e631bbd4fd530e80f85d5191b8e43", "committedDate": "2020-09-04 10:54:55 +0100", "message": "ISPN-12169 Free HibernateSearchPropertyHelper from SearchMappingHolder"}, {"oid": "337c7f8cd2a815a4ac6eb38e0db2dc0648a06668", "committedDate": "2020-09-28 13:02:00 +0300", "message": "ISPN-12288 Add support for annotations on fields"}, {"oid": "5d4417ba758c74bbbef9d41bdb8496024d355238", "committedDate": "2022-04-14 10:36:50 +0200", "message": "ISPN-13820 Align field metadata to search 6"}, {"oid": "b97fe5ac444dea98fd8df20e2db6efce1143f305", "committedDate": "2022-05-18 09:25:56 +0200", "message": "ISPN-13842 Infinispan indexing annotations (#10125)"}, {"oid": "b1db081655471507e500327af03cd0c51ecf2354", "committedDate": "2022-09-23 11:08:16 -0400", "message": "ISPN-14127 Pass blocking managers to InfinispanMapping for tests"}, {"oid": "b79b631ba787a5ff2a9fd32d2871e1a38887538b", "committedDate": "2023-03-28 13:43:27 -0400", "message": "ISPN-14483 Remove indexing non-blocking extra layer"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODYyNDI1OQ==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r458624259", "body": "We deprecated ```SearchManager``` in 11, and it's going to be removed in 12, so It's better to not add features to it", "bodyText": "We deprecated SearchManager in 11, and it's going to be removed in 12, so It's better to not add features to it", "bodyHTML": "<p dir=\"auto\">We deprecated <code>SearchManager</code> in 11, and it's going to be removed in 12, so It's better to not add features to it</p>", "author": "gustavocoding", "createdAt": "2020-07-22T08:28:12Z", "path": "query/src/main/java/org/infinispan/query/SearchManager.java", "diffHunk": "@@ -88,6 +53,8 @@\n    @Deprecated\n    void purge(Class<?> entityType);\n \n+   void refresh(Class<?> entityType);", "originalCommit": "973742666427584064f0529d85af66024e57d0ab", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6300e5d5e53a1e59b9349292cdc7d87ce9d476da", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/SearchManager.java b/query/src/main/java/org/infinispan/query/SearchManager.java\nindex 4a3fccc35f..75c8b52b18 100644\n--- a/query/src/main/java/org/infinispan/query/SearchManager.java\n+++ b/query/src/main/java/org/infinispan/query/SearchManager.java\n", "chunk": "@@ -53,8 +53,6 @@ public interface SearchManager {\n    @Deprecated\n    void purge(Class<?> entityType);\n \n-   void refresh(Class<?> entityType);\n-\n    /**\n     * This method gives access to internal Infinispan implementation details, and should not be normally needed. The\n     * interface of the internal types does not constitute a public API and can (and probably will) change without\n", "next_change": null}]}, "revised_code_in_main": {"commit": "91d194f1a4e6f6990903ea42094be659142bb4d5", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/SearchManager.java b/query/src/main/java/org/infinispan/query/SearchManager.java\nindex 4a3fccc35f..75c8b52b18 100644\n--- a/query/src/main/java/org/infinispan/query/SearchManager.java\n+++ b/query/src/main/java/org/infinispan/query/SearchManager.java\n", "chunk": "@@ -53,8 +53,6 @@ public interface SearchManager {\n    @Deprecated\n    void purge(Class<?> entityType);\n \n-   void refresh(Class<?> entityType);\n-\n    /**\n     * This method gives access to internal Infinispan implementation details, and should not be normally needed. The\n     * interface of the internal types does not constitute a public API and can (and probably will) change without\n", "next_change": {"commit": "86be6afd3a356a47b5be033c2bd65ff79acfef2b", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/SearchManager.java b/query/src/main/java/org/infinispan/query/SearchManager.java\ndeleted file mode 100644\nindex 75c8b52b18..0000000000\n--- a/query/src/main/java/org/infinispan/query/SearchManager.java\n+++ /dev/null\n", "chunk": "@@ -1,68 +0,0 @@\n-package org.infinispan.query;\n-\n-import org.infinispan.query.dsl.IndexedQueryMode;\n-\n-/**\n- * The SearchManager is the entry point to create full text queries on top of an indexed cache.\n- *\n- * @author Sanne Grinovero &lt;sanne@hibernate.org&gt; (C) 2011 Red Hat Inc.\n- * @author Marko Luksa\n- * @deprecated since 11.0, all search operations should be done with the {@link Search} entry point.\n- */\n-@Deprecated\n-public interface SearchManager {\n-\n-   /**\n-    * Builds a {@link CacheQuery} from an Ickle query string.\n-    *\n-    * @throws org.hibernate.search.util.common.SearchException if the queryString cannot be converted to an indexed query,\n-    *                                                        due to lack of indexes to resolve it fully or if contains\n-    *                                                        aggregations and grouping.\n-    * @deprecated since 11.0 with no replacement. To be removed in next major version.\n-    */\n-   @Deprecated\n-   <E> CacheQuery<E> getQuery(String queryString, IndexedQueryMode indexedQueryMode);\n-\n-   /**\n-    * Builds a {@link CacheQuery} from an Ickle query string, assuming the correct value for {@link IndexedQueryMode} to\n-    * query all data in the cluster\n-    * @param queryString the Ickle query\n-    * @return\n-    * @deprecated since 11.0, all search operations should be done with the {@link Search} entry point.\n-    */\n-   <E> CacheQuery<E> getQuery(String queryString);\n-\n-   /**\n-    * The MassIndexer can be used to rebuild the Lucene indexes from the entries stored in Infinispan.\n-    *\n-    * @return the MassIndexer component\n-    * @deprecated Since 11.0, use {@link Search#getIndexer(Cache)} instead.\n-    */\n-   @Deprecated\n-   MassIndexer getMassIndexer();\n-\n-   // TODO HSEARCH-3129 Restore support for statistics\n-   // Statistics getStatistics();\n-\n-   /**\n-    * Remove all entities of particular class from the index.\n-    *\n-    * @param entityType The class of the entity to remove.\n-    * @deprecated Since 11.0, use {@link Indexer#remove()} obtained from {@link Search#getIndexer(Cache)}.\n-    */\n-   @Deprecated\n-   void purge(Class<?> entityType);\n-\n-   /**\n-    * This method gives access to internal Infinispan implementation details, and should not be normally needed. The\n-    * interface of the internal types does not constitute a public API and can (and probably will) change without\n-    * notice.\n-    *\n-    * @param cls the class of the desired internal component\n-    * @return the 'unwrapped' internal component\n-    * @throws IllegalArgumentException if the class of the requested internal component is not recognized\n-    * @deprecated Since 11.0, with no replacement.\n-    */\n-   @Deprecated\n-   <T> T unwrap(Class<T> cls);\n-}\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "91d194f1a4e6f6990903ea42094be659142bb4d5", "message": "Merge commit", "committedDate": null}, {"oid": "86be6afd3a356a47b5be033c2bd65ff79acfef2b", "committedDate": "2020-08-12 09:48:25 +0100", "message": "ISPN-12189 Remove deprecated indexed query classes"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODYyNjgwMQ==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r458626801", "body": "```CacheQuery``` is also deprecated, so better not to change it. ", "bodyText": "CacheQuery is also deprecated, so better not to change it.", "bodyHTML": "<p dir=\"auto\"><code>CacheQuery</code> is also deprecated, so better not to change it.</p>", "author": "gustavocoding", "createdAt": "2020-07-22T08:32:14Z", "path": "query/src/main/java/org/infinispan/query/CacheQuery.java", "diffHunk": "@@ -67,70 +63,22 @@\n     */\n    CacheQuery<E> maxResults(int numResults);\n \n-   /**\n-    * @return return the manager for all faceting related operations\n-    */\n-   FacetManager getFacetManager();\n-\n    /**\n     * Gets the total number of results matching the query, ignoring pagination (firstResult, maxResult).\n     *\n     * @return total number of results.\n     */\n-   int getResultSize();\n+   long getResultSize();", "originalCommit": "973742666427584064f0529d85af66024e57d0ab", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6300e5d5e53a1e59b9349292cdc7d87ce9d476da", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/CacheQuery.java b/query/src/main/java/org/infinispan/query/CacheQuery.java\nindex f106d3f9b8..3843a82ba6 100644\n--- a/query/src/main/java/org/infinispan/query/CacheQuery.java\n+++ b/query/src/main/java/org/infinispan/query/CacheQuery.java\n", "chunk": "@@ -68,7 +68,7 @@\n     *\n     * @return total number of results.\n     */\n-   long getResultSize();\n+   int getResultSize();\n \n    /**\n     * Return the Lucene {@link org.apache.lucene.search.Explanation}\n", "next_change": {"commit": "32718114c38cd1cf83048d759033d952387d0a7e", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/CacheQuery.java b/query/src/main/java/org/infinispan/query/CacheQuery.java\nindex 3843a82ba6..b8f9819af4 100644\n--- a/query/src/main/java/org/infinispan/query/CacheQuery.java\n+++ b/query/src/main/java/org/infinispan/query/CacheQuery.java\n", "chunk": "@@ -75,10 +84,53 @@\n     * object describing the score computation for the matching object/document\n     * in the current query\n     *\n-    * @param id The id of the document to test.\n+    * @param documentId Lucene Document id to be explain. This is NOT the object key\n     * @return Lucene Explanation\n     */\n-   Explanation explain(String id);\n+   Explanation explain(int documentId);\n+\n+   /**\n+    * Allows lucene to sort the results. Integers are sorted in descending order.\n+    *\n+    * @param s - lucene sort object\n+    */\n+   CacheQuery<E> sort(Sort s);\n+\n+   /**\n+    * Defines the Lucene field names projected and returned in a query result\n+    * Each field is converted back to it's object representation, an Object[] being returned for each \"row\"\n+    * <p/>\n+    * A projectable field must be stored in the Lucene index and use a {@link org.hibernate.search.bridge.TwoWayFieldBridge}\n+    * Unless notified in their JavaDoc, all built-in bridges are two-way. All @DocumentId fields are projectable by design.\n+    * <p/>\n+    * If the projected field is not a projectable field, null is returned in the object[]\n+    *\n+    * @param fields the projected field names\n+    * @return {@code this} to allow for method chaining, but the type parameter now becomes {@code Object[]}\n+    */\n+   CacheQuery<Object[]> projection(String... fields);\n+\n+   /**\n+    * Enable a given filter by its name.\n+    *\n+    * @param name of filter.\n+    * @return a FullTextFilter object.\n+    */\n+   FullTextFilter enableFullTextFilter(String name);\n+\n+   /**\n+    * Disable a given filter by its name.\n+    *\n+    * @param name of filter.\n+    */\n+   CacheQuery<E> disableFullTextFilter(String name);\n+\n+   /**\n+    * Allows lucene to filter the results.\n+    *\n+    * @param f - lucene filter\n+    */\n+   CacheQuery<E> filter(Filter f);\n \n    /**\n     * Set the timeout for this query. If the query hasn't finished processing before the timeout,\n", "next_change": {"commit": "bb18590bbe7e5e9948bca940518235678d1a4fae", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/CacheQuery.java b/query/src/main/java/org/infinispan/query/CacheQuery.java\nindex b8f9819af4..3843a82ba6 100644\n--- a/query/src/main/java/org/infinispan/query/CacheQuery.java\n+++ b/query/src/main/java/org/infinispan/query/CacheQuery.java\n", "chunk": "@@ -84,53 +75,10 @@\n     * object describing the score computation for the matching object/document\n     * in the current query\n     *\n-    * @param documentId Lucene Document id to be explain. This is NOT the object key\n+    * @param id The id of the document to test.\n     * @return Lucene Explanation\n     */\n-   Explanation explain(int documentId);\n-\n-   /**\n-    * Allows lucene to sort the results. Integers are sorted in descending order.\n-    *\n-    * @param s - lucene sort object\n-    */\n-   CacheQuery<E> sort(Sort s);\n-\n-   /**\n-    * Defines the Lucene field names projected and returned in a query result\n-    * Each field is converted back to it's object representation, an Object[] being returned for each \"row\"\n-    * <p/>\n-    * A projectable field must be stored in the Lucene index and use a {@link org.hibernate.search.bridge.TwoWayFieldBridge}\n-    * Unless notified in their JavaDoc, all built-in bridges are two-way. All @DocumentId fields are projectable by design.\n-    * <p/>\n-    * If the projected field is not a projectable field, null is returned in the object[]\n-    *\n-    * @param fields the projected field names\n-    * @return {@code this} to allow for method chaining, but the type parameter now becomes {@code Object[]}\n-    */\n-   CacheQuery<Object[]> projection(String... fields);\n-\n-   /**\n-    * Enable a given filter by its name.\n-    *\n-    * @param name of filter.\n-    * @return a FullTextFilter object.\n-    */\n-   FullTextFilter enableFullTextFilter(String name);\n-\n-   /**\n-    * Disable a given filter by its name.\n-    *\n-    * @param name of filter.\n-    */\n-   CacheQuery<E> disableFullTextFilter(String name);\n-\n-   /**\n-    * Allows lucene to filter the results.\n-    *\n-    * @param f - lucene filter\n-    */\n-   CacheQuery<E> filter(Filter f);\n+   Explanation explain(String id);\n \n    /**\n     * Set the timeout for this query. If the query hasn't finished processing before the timeout,\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "91d194f1a4e6f6990903ea42094be659142bb4d5", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/CacheQuery.java b/query/src/main/java/org/infinispan/query/CacheQuery.java\nindex f106d3f9b8..3843a82ba6 100644\n--- a/query/src/main/java/org/infinispan/query/CacheQuery.java\n+++ b/query/src/main/java/org/infinispan/query/CacheQuery.java\n", "chunk": "@@ -68,7 +68,7 @@\n     *\n     * @return total number of results.\n     */\n-   long getResultSize();\n+   int getResultSize();\n \n    /**\n     * Return the Lucene {@link org.apache.lucene.search.Explanation}\n", "next_change": {"commit": "86be6afd3a356a47b5be033c2bd65ff79acfef2b", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/CacheQuery.java b/query/src/main/java/org/infinispan/query/CacheQuery.java\ndeleted file mode 100644\nindex 3843a82ba6..0000000000\n--- a/query/src/main/java/org/infinispan/query/CacheQuery.java\n+++ /dev/null\n", "chunk": "@@ -1,92 +0,0 @@\n-package org.infinispan.query;\n-\n-import java.util.List;\n-import java.util.concurrent.TimeUnit;\n-\n-import org.apache.lucene.search.Explanation;\n-\n-/**\n- * A cache-query is what will be returned when the getQuery() method is run on {@link org.infinispan.query.impl.SearchManagerImpl}. This object can\n- * have methods such as list, setFirstResult,setMaxResults, setFetchSize, getResultSize and setSort.\n- * <p/>\n- *\n- * @author Manik Surtani\n- * @author Navin Surtani\n- * @author Sanne Grinovero &lt;sanne@hibernate.org&gt; (C) 2011 Red Hat Inc.\n- * @author Marko Luksa\n- * @see org.infinispan.query.impl.SearchManagerImpl#getQuery(String)\n- * @deprecated Since 11.0, replaced by {@link org.infinispan.query.dsl.Query} in the Query API and\n- * {@link org.infinispan.query.impl.IndexedQuery} internally.\n- */\n-@Deprecated\n-public interface CacheQuery<E> extends Iterable<E> {\n-\n-   /**\n-    * Returns the results of a search as a list.\n-    *\n-    * @return list of objects that were found from the search.\n-    */\n-   List<E> list();\n-\n-   /**\n-    * Returns the results of a search as a {@link ResultIterator}.\n-    *\n-    * Warning: the return type is an extension of {@link java.util.Iterator} which introduces a {@link ResultIterator#close()}\n-    * method. This close method needs to be invoked when the iteration is complete to avoid resource leakage.\n-    *\n-    * @param fetchOptions how to fetch results (see @link FetchOptions)\n-    * @return a QueryResultIterator which can be used to iterate through the results that were found.\n-    */\n-   ResultIterator<E> iterator(FetchOptions fetchOptions);\n-\n-   /**\n-    * Returns the results of a search as a {@link ResultIterator}. This calls {@link CacheQuery#iterator(FetchOptions fetchOptions)}\n-    * with default FetchOptions; this implies eager loading of all results.\n-    *\n-    * @return a ResultIterator which can be used to iterate through the results that were found.\n-    */\n-   @Override\n-   ResultIterator<E> iterator();\n-\n-   /**\n-    * Sets a result with a given index to the first result.\n-    *\n-    * @param index of result to be set to the first.\n-    * @throws IllegalArgumentException if the index given is less than zero.\n-    */\n-   CacheQuery<E> firstResult(int index);\n-\n-   /**\n-    * Sets the maximum number of results to the number passed in as a parameter.\n-    *\n-    * @param numResults that are to be set to the maxResults.\n-    */\n-   CacheQuery<E> maxResults(int numResults);\n-\n-   /**\n-    * Gets the total number of results matching the query, ignoring pagination (firstResult, maxResult).\n-    *\n-    * @return total number of results.\n-    */\n-   int getResultSize();\n-\n-   /**\n-    * Return the Lucene {@link org.apache.lucene.search.Explanation}\n-    * object describing the score computation for the matching object/document\n-    * in the current query\n-    *\n-    * @param id The id of the document to test.\n-    * @return Lucene Explanation\n-    */\n-   Explanation explain(String id);\n-\n-   /**\n-    * Set the timeout for this query. If the query hasn't finished processing before the timeout,\n-    * an exception will be thrown.\n-    *\n-    * @param timeout the timeout duration\n-    * @param timeUnit the time unit of the timeout parameter\n-    * @return\n-    */\n-   CacheQuery<E> timeout(long timeout, TimeUnit timeUnit);\n-}\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "91d194f1a4e6f6990903ea42094be659142bb4d5", "message": "Merge commit", "committedDate": null}, {"oid": "86be6afd3a356a47b5be033c2bd65ff79acfef2b", "committedDate": "2020-08-12 09:48:25 +0100", "message": "ISPN-12189 Remove deprecated indexed query classes"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODYyODIxNw==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r458628217", "body": "This class is also deprecated. Same as CacheQuery and SearchManager. Could you avoid changing them, and if it's not possible, just remove?", "bodyText": "This class is also deprecated. Same as CacheQuery and SearchManager. Could you avoid changing them, and if it's not possible, just remove?", "bodyHTML": "<p dir=\"auto\">This class is also deprecated. Same as CacheQuery and SearchManager. Could you avoid changing them, and if it's not possible, just remove?</p>", "author": "gustavocoding", "createdAt": "2020-07-22T08:34:43Z", "path": "query/src/main/java/org/infinispan/query/spi/SearchManagerImplementor.java", "diffHunk": "@@ -15,33 +12,13 @@\n @Deprecated\n public interface SearchManagerImplementor extends SearchManager {\n \n-   /**\n-    * Define the timeout exception factory to customize the exception thrown when the query timeout is exceeded.\n-    *\n-    * @param timeoutExceptionFactory the timeout exception factory to use\n-    * @deprecated Since 11.0, without replacement. To be removed in next major version.\n-    */\n-   @Deprecated\n-   void setTimeoutExceptionFactory(TimeoutExceptionFactory timeoutExceptionFactory);\n-\n    /**\n     * Creates a cache query based on a {@link QueryDefinition} and a custom metadata.\n     * @deprecated Since 11.0, without replacement. To be removed in next major version.\n     */\n    @Deprecated\n-   <E> CacheQuery<E> getQuery(QueryDefinition queryDefinition, IndexedQueryMode indexedQueryMode, IndexedTypeMap<CustomTypeMetadata> indexedTypeMap);\n+   <E> CacheQuery<E> getQuery(QueryDefinition queryDefinition, IndexedQueryMode indexedQueryMode);", "originalCommit": "973742666427584064f0529d85af66024e57d0ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI0NzkzNw==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r459247937", "bodyText": "Sure", "author": "fax4ever", "createdAt": "2020-07-23T06:55:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODYyODIxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTMzNTY0OA==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r459335648", "bodyText": "Unfortunately IndexedTypeMap is a Hibernate Search 5\u2019s class. So I think we need to remove it. Doing now...", "author": "fax4ever", "createdAt": "2020-07-23T09:50:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODYyODIxNw=="}], "type": "inlineReview", "revised_code": {"commit": "6300e5d5e53a1e59b9349292cdc7d87ce9d476da", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/spi/SearchManagerImplementor.java b/query/src/main/java/org/infinispan/query/spi/SearchManagerImplementor.java\ndeleted file mode 100644\nindex dd9b5f5a37..0000000000\n--- a/query/src/main/java/org/infinispan/query/spi/SearchManagerImplementor.java\n+++ /dev/null\n", "chunk": "@@ -1,24 +0,0 @@\n-package org.infinispan.query.spi;\n-\n-import org.infinispan.query.CacheQuery;\n-import org.infinispan.query.SearchManager;\n-import org.infinispan.query.dsl.IndexedQueryMode;\n-import org.infinispan.query.dsl.embedded.impl.SearchQueryBuilder;\n-import org.infinispan.query.impl.QueryDefinition;\n-\n-/**\n- * @deprecated Since 11.0, without replacement. To be removed in next major version.\n- */\n-@Deprecated\n-public interface SearchManagerImplementor extends SearchManager {\n-\n-   /**\n-    * Creates a cache query based on a {@link QueryDefinition} and a custom metadata.\n-    * @deprecated Since 11.0, without replacement. To be removed in next major version.\n-    */\n-   @Deprecated\n-   <E> CacheQuery<E> getQuery(QueryDefinition queryDefinition, IndexedQueryMode indexedQueryMode);\n-\n-   @Deprecated\n-   <E> CacheQuery<E> getQuery(SearchQueryBuilder searchQuery);\n-}\n", "next_change": {"commit": "32718114c38cd1cf83048d759033d952387d0a7e", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/spi/SearchManagerImplementor.java b/query/src/main/java/org/infinispan/query/spi/SearchManagerImplementor.java\nnew file mode 100644\nindex 0000000000..fd3d27eea8\n--- /dev/null\n+++ b/query/src/main/java/org/infinispan/query/spi/SearchManagerImplementor.java\n", "chunk": "@@ -0,0 +1,47 @@\n+package org.infinispan.query.spi;\n+\n+import org.apache.lucene.search.Query;\n+import org.hibernate.search.query.engine.spi.TimeoutExceptionFactory;\n+import org.hibernate.search.spi.CustomTypeMetadata;\n+import org.hibernate.search.spi.IndexedTypeMap;\n+import org.infinispan.query.CacheQuery;\n+import org.infinispan.query.SearchManager;\n+import org.infinispan.query.dsl.IndexedQueryMode;\n+import org.infinispan.query.impl.QueryDefinition;\n+\n+/**\n+ * @deprecated Since 11.0, without replacement. To be removed in next major version.\n+ */\n+@Deprecated\n+public interface SearchManagerImplementor extends SearchManager {\n+\n+   /**\n+    * Define the timeout exception factory to customize the exception thrown when the query timeout is exceeded.\n+    *\n+    * @param timeoutExceptionFactory the timeout exception factory to use\n+    * @deprecated Since 11.0, without replacement. To be removed in next major version.\n+    */\n+   @Deprecated\n+   void setTimeoutExceptionFactory(TimeoutExceptionFactory timeoutExceptionFactory);\n+\n+   /**\n+    * Creates a cache query based on a {@link QueryDefinition} and a custom metadata.\n+    * @deprecated Since 11.0, without replacement. To be removed in next major version.\n+    */\n+   @Deprecated\n+   <E> CacheQuery<E> getQuery(QueryDefinition queryDefinition, IndexedQueryMode indexedQueryMode, IndexedTypeMap<CustomTypeMetadata> indexedTypeMap);\n+\n+   /**\n+    * This is a simple method that will just return a {@link CacheQuery}, filtered according to a set of classes passed\n+    * in.  If no classes are passed in, it is assumed that no type filtering is performed and so all known types will\n+    * be searched.\n+    *\n+    * @param luceneQuery      {@link org.apache.lucene.search.Query}\n+    * @param indexedQueryMode The {@link IndexedQueryMode} used when executing the query.\n+    * @param entity          The entity type to query against.\n+    * @return the CacheQuery object which can be used to iterate through results.\n+    * @deprecated Since 11.0 without replacement. To be removed in next major version.\n+    */\n+   @Deprecated\n+   <E> CacheQuery<E> getQuery(Query luceneQuery, IndexedQueryMode indexedQueryMode, Class<?> entity);\n+}\n", "next_change": {"commit": "bb18590bbe7e5e9948bca940518235678d1a4fae", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/spi/SearchManagerImplementor.java b/query/src/main/java/org/infinispan/query/spi/SearchManagerImplementor.java\ndeleted file mode 100644\nindex fd3d27eea8..0000000000\n--- a/query/src/main/java/org/infinispan/query/spi/SearchManagerImplementor.java\n+++ /dev/null\n", "chunk": "@@ -1,47 +0,0 @@\n-package org.infinispan.query.spi;\n-\n-import org.apache.lucene.search.Query;\n-import org.hibernate.search.query.engine.spi.TimeoutExceptionFactory;\n-import org.hibernate.search.spi.CustomTypeMetadata;\n-import org.hibernate.search.spi.IndexedTypeMap;\n-import org.infinispan.query.CacheQuery;\n-import org.infinispan.query.SearchManager;\n-import org.infinispan.query.dsl.IndexedQueryMode;\n-import org.infinispan.query.impl.QueryDefinition;\n-\n-/**\n- * @deprecated Since 11.0, without replacement. To be removed in next major version.\n- */\n-@Deprecated\n-public interface SearchManagerImplementor extends SearchManager {\n-\n-   /**\n-    * Define the timeout exception factory to customize the exception thrown when the query timeout is exceeded.\n-    *\n-    * @param timeoutExceptionFactory the timeout exception factory to use\n-    * @deprecated Since 11.0, without replacement. To be removed in next major version.\n-    */\n-   @Deprecated\n-   void setTimeoutExceptionFactory(TimeoutExceptionFactory timeoutExceptionFactory);\n-\n-   /**\n-    * Creates a cache query based on a {@link QueryDefinition} and a custom metadata.\n-    * @deprecated Since 11.0, without replacement. To be removed in next major version.\n-    */\n-   @Deprecated\n-   <E> CacheQuery<E> getQuery(QueryDefinition queryDefinition, IndexedQueryMode indexedQueryMode, IndexedTypeMap<CustomTypeMetadata> indexedTypeMap);\n-\n-   /**\n-    * This is a simple method that will just return a {@link CacheQuery}, filtered according to a set of classes passed\n-    * in.  If no classes are passed in, it is assumed that no type filtering is performed and so all known types will\n-    * be searched.\n-    *\n-    * @param luceneQuery      {@link org.apache.lucene.search.Query}\n-    * @param indexedQueryMode The {@link IndexedQueryMode} used when executing the query.\n-    * @param entity          The entity type to query against.\n-    * @return the CacheQuery object which can be used to iterate through results.\n-    * @deprecated Since 11.0 without replacement. To be removed in next major version.\n-    */\n-   @Deprecated\n-   <E> CacheQuery<E> getQuery(Query luceneQuery, IndexedQueryMode indexedQueryMode, Class<?> entity);\n-}\n", "next_change": {"commit": "b76eeeee768bb075a447e35324baa3d6986830f1", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/spi/SearchManagerImplementor.java b/query/src/main/java/org/infinispan/query/spi/SearchManagerImplementor.java\nnew file mode 100644\nindex 0000000000..dd9b5f5a37\n--- /dev/null\n+++ b/query/src/main/java/org/infinispan/query/spi/SearchManagerImplementor.java\n", "chunk": "@@ -0,0 +1,24 @@\n+package org.infinispan.query.spi;\n+\n+import org.infinispan.query.CacheQuery;\n+import org.infinispan.query.SearchManager;\n+import org.infinispan.query.dsl.IndexedQueryMode;\n+import org.infinispan.query.dsl.embedded.impl.SearchQueryBuilder;\n+import org.infinispan.query.impl.QueryDefinition;\n+\n+/**\n+ * @deprecated Since 11.0, without replacement. To be removed in next major version.\n+ */\n+@Deprecated\n+public interface SearchManagerImplementor extends SearchManager {\n+\n+   /**\n+    * Creates a cache query based on a {@link QueryDefinition} and a custom metadata.\n+    * @deprecated Since 11.0, without replacement. To be removed in next major version.\n+    */\n+   @Deprecated\n+   <E> CacheQuery<E> getQuery(QueryDefinition queryDefinition, IndexedQueryMode indexedQueryMode);\n+\n+   @Deprecated\n+   <E> CacheQuery<E> getQuery(SearchQueryBuilder searchQuery);\n+}\n", "next_change": {"commit": "917da575b1ba55b0147d9cbeb1e553e3b24fc837", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/spi/SearchManagerImplementor.java b/query/src/main/java/org/infinispan/query/spi/SearchManagerImplementor.java\ndeleted file mode 100644\nindex dd9b5f5a37..0000000000\n--- a/query/src/main/java/org/infinispan/query/spi/SearchManagerImplementor.java\n+++ /dev/null\n", "chunk": "@@ -1,24 +0,0 @@\n-package org.infinispan.query.spi;\n-\n-import org.infinispan.query.CacheQuery;\n-import org.infinispan.query.SearchManager;\n-import org.infinispan.query.dsl.IndexedQueryMode;\n-import org.infinispan.query.dsl.embedded.impl.SearchQueryBuilder;\n-import org.infinispan.query.impl.QueryDefinition;\n-\n-/**\n- * @deprecated Since 11.0, without replacement. To be removed in next major version.\n- */\n-@Deprecated\n-public interface SearchManagerImplementor extends SearchManager {\n-\n-   /**\n-    * Creates a cache query based on a {@link QueryDefinition} and a custom metadata.\n-    * @deprecated Since 11.0, without replacement. To be removed in next major version.\n-    */\n-   @Deprecated\n-   <E> CacheQuery<E> getQuery(QueryDefinition queryDefinition, IndexedQueryMode indexedQueryMode);\n-\n-   @Deprecated\n-   <E> CacheQuery<E> getQuery(SearchQueryBuilder searchQuery);\n-}\n", "next_change": {"commit": "d8d307f379ffaa6ca9b4d670e4abe4e0f2ae33f3", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/spi/SearchManagerImplementor.java b/query/src/main/java/org/infinispan/query/spi/SearchManagerImplementor.java\nnew file mode 100644\nindex 0000000000..dd9b5f5a37\n--- /dev/null\n+++ b/query/src/main/java/org/infinispan/query/spi/SearchManagerImplementor.java\n", "chunk": "@@ -0,0 +1,24 @@\n+package org.infinispan.query.spi;\n+\n+import org.infinispan.query.CacheQuery;\n+import org.infinispan.query.SearchManager;\n+import org.infinispan.query.dsl.IndexedQueryMode;\n+import org.infinispan.query.dsl.embedded.impl.SearchQueryBuilder;\n+import org.infinispan.query.impl.QueryDefinition;\n+\n+/**\n+ * @deprecated Since 11.0, without replacement. To be removed in next major version.\n+ */\n+@Deprecated\n+public interface SearchManagerImplementor extends SearchManager {\n+\n+   /**\n+    * Creates a cache query based on a {@link QueryDefinition} and a custom metadata.\n+    * @deprecated Since 11.0, without replacement. To be removed in next major version.\n+    */\n+   @Deprecated\n+   <E> CacheQuery<E> getQuery(QueryDefinition queryDefinition, IndexedQueryMode indexedQueryMode);\n+\n+   @Deprecated\n+   <E> CacheQuery<E> getQuery(SearchQueryBuilder searchQuery);\n+}\n", "next_change": {"commit": "009c09a6330ce8005925f73687179122582805ed", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/spi/SearchManagerImplementor.java b/query/src/main/java/org/infinispan/query/spi/SearchManagerImplementor.java\ndeleted file mode 100644\nindex dd9b5f5a37..0000000000\n--- a/query/src/main/java/org/infinispan/query/spi/SearchManagerImplementor.java\n+++ /dev/null\n", "chunk": "@@ -1,24 +0,0 @@\n-package org.infinispan.query.spi;\n-\n-import org.infinispan.query.CacheQuery;\n-import org.infinispan.query.SearchManager;\n-import org.infinispan.query.dsl.IndexedQueryMode;\n-import org.infinispan.query.dsl.embedded.impl.SearchQueryBuilder;\n-import org.infinispan.query.impl.QueryDefinition;\n-\n-/**\n- * @deprecated Since 11.0, without replacement. To be removed in next major version.\n- */\n-@Deprecated\n-public interface SearchManagerImplementor extends SearchManager {\n-\n-   /**\n-    * Creates a cache query based on a {@link QueryDefinition} and a custom metadata.\n-    * @deprecated Since 11.0, without replacement. To be removed in next major version.\n-    */\n-   @Deprecated\n-   <E> CacheQuery<E> getQuery(QueryDefinition queryDefinition, IndexedQueryMode indexedQueryMode);\n-\n-   @Deprecated\n-   <E> CacheQuery<E> getQuery(SearchQueryBuilder searchQuery);\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "91d194f1a4e6f6990903ea42094be659142bb4d5", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/spi/SearchManagerImplementor.java b/query/src/main/java/org/infinispan/query/spi/SearchManagerImplementor.java\ndeleted file mode 100644\nindex dd9b5f5a37..0000000000\n--- a/query/src/main/java/org/infinispan/query/spi/SearchManagerImplementor.java\n+++ /dev/null\n", "chunk": "@@ -1,24 +0,0 @@\n-package org.infinispan.query.spi;\n-\n-import org.infinispan.query.CacheQuery;\n-import org.infinispan.query.SearchManager;\n-import org.infinispan.query.dsl.IndexedQueryMode;\n-import org.infinispan.query.dsl.embedded.impl.SearchQueryBuilder;\n-import org.infinispan.query.impl.QueryDefinition;\n-\n-/**\n- * @deprecated Since 11.0, without replacement. To be removed in next major version.\n- */\n-@Deprecated\n-public interface SearchManagerImplementor extends SearchManager {\n-\n-   /**\n-    * Creates a cache query based on a {@link QueryDefinition} and a custom metadata.\n-    * @deprecated Since 11.0, without replacement. To be removed in next major version.\n-    */\n-   @Deprecated\n-   <E> CacheQuery<E> getQuery(QueryDefinition queryDefinition, IndexedQueryMode indexedQueryMode);\n-\n-   @Deprecated\n-   <E> CacheQuery<E> getQuery(SearchQueryBuilder searchQuery);\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "91d194f1a4e6f6990903ea42094be659142bb4d5", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc4MDkyNQ==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r458780925", "body": "Is there an easy way to create an alias at Infinispan side so that we could deprecate the old properties instead of removing them?", "bodyText": "Is there an easy way to create an alias at Infinispan side so that we could deprecate the old properties instead of removing them?", "bodyHTML": "<p dir=\"auto\">Is there an easy way to create an alias at Infinispan side so that we could deprecate the old properties instead of removing them?</p>", "author": "gustavocoding", "createdAt": "2020-07-22T13:13:40Z", "path": "client/hotrod-client/src/test/java/org/infinispan/client/hotrod/admin/RemoteCacheAdminTest.java", "diffHunk": "@@ -46,7 +47,7 @@ protected void createCacheManagers() throws Throwable {\n             getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false));\n       builder.indexing().enable()\n              .addIndexedEntity(\"sample_bank_account.Transaction\")\n-             .addProperty(\"default.directory_provider\", \"local-heap\");", "originalCommit": "973742666427584064f0529d85af66024e57d0ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODg1MjA3NQ==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r458852075", "bodyText": "There is no plan to handle that kind of things in Hibernate Search 6. And some properties cannot be directly translated, because some things are now configured programatically instead of being configured through properties; that's the case of similarity for example (used to be a class passed to property hibernate.search.similarity).\nCurrently in Search 6, we simply fail the boot when someone uses old properties which are no longer supported.\nThat being said, you can transform the properties before passing them to Hibernate Search, of course.\nYou can find a list of old properties here, if that's useful: https://github.com/hibernate/hibernate-search/blob/0220c7a345ba46f9559e73ec5ae5d9ccddbec2df/engine/src/main/java/org/hibernate/search/engine/cfg/spi/HibernateSearch5Properties.java", "author": "yrodiere", "createdAt": "2020-07-22T14:50:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc4MDkyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI0NzM0NQ==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r459247345", "bodyText": "As @yrodiere said there is no one-to-one correspondence for some properties.\nFor those for which there is, we could create such a compatibility layer in org.infinispan.search.mapper.mapping.impl.IndexProperties.\nAt the moment in this class we simplify a little the prefix needed to be used by the user to configure Hibernate Search properties, so it looks like the right place to implement it.", "author": "fax4ever", "createdAt": "2020-07-23T06:54:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc4MDkyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI1MzYzNw==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r459253637", "bodyText": "Cool, we can defer this to a follow up PR", "author": "gustavonalle", "createdAt": "2020-07-23T07:10:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc4MDkyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "32718114c38cd1cf83048d759033d952387d0a7e", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/admin/RemoteCacheAdminTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/admin/RemoteCacheAdminTest.java\nindex 2147935b42..2243be73bd 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/admin/RemoteCacheAdminTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/admin/RemoteCacheAdminTest.java\n", "chunk": "@@ -47,7 +46,7 @@ protected void createCacheManagers() throws Throwable {\n             getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false));\n       builder.indexing().enable()\n              .addIndexedEntity(\"sample_bank_account.Transaction\")\n-             .addProperty(SearchConfig.DIRECTORY_TYPE, SearchConfig.HEAP);\n+             .addProperty(\"default.directory_provider\", \"local-heap\");\n       createHotRodServers(2, builder);\n    }\n \n", "next_change": {"commit": "bb18590bbe7e5e9948bca940518235678d1a4fae", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/admin/RemoteCacheAdminTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/admin/RemoteCacheAdminTest.java\nindex 2243be73bd..2147935b42 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/admin/RemoteCacheAdminTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/admin/RemoteCacheAdminTest.java\n", "chunk": "@@ -46,7 +47,7 @@ protected void createCacheManagers() throws Throwable {\n             getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false));\n       builder.indexing().enable()\n              .addIndexedEntity(\"sample_bank_account.Transaction\")\n-             .addProperty(\"default.directory_provider\", \"local-heap\");\n+             .addProperty(SearchConfig.DIRECTORY_TYPE, SearchConfig.HEAP);\n       createHotRodServers(2, builder);\n    }\n \n", "next_change": {"commit": "b76eeeee768bb075a447e35324baa3d6986830f1", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/admin/RemoteCacheAdminTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/admin/RemoteCacheAdminTest.java\nindex 2147935b42..2243be73bd 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/admin/RemoteCacheAdminTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/admin/RemoteCacheAdminTest.java\n", "chunk": "@@ -47,7 +46,7 @@ protected void createCacheManagers() throws Throwable {\n             getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false));\n       builder.indexing().enable()\n              .addIndexedEntity(\"sample_bank_account.Transaction\")\n-             .addProperty(SearchConfig.DIRECTORY_TYPE, SearchConfig.HEAP);\n+             .addProperty(\"default.directory_provider\", \"local-heap\");\n       createHotRodServers(2, builder);\n    }\n \n", "next_change": {"commit": "917da575b1ba55b0147d9cbeb1e553e3b24fc837", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/admin/RemoteCacheAdminTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/admin/RemoteCacheAdminTest.java\nindex 2243be73bd..2147935b42 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/admin/RemoteCacheAdminTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/admin/RemoteCacheAdminTest.java\n", "chunk": "@@ -46,7 +47,7 @@ protected void createCacheManagers() throws Throwable {\n             getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false));\n       builder.indexing().enable()\n              .addIndexedEntity(\"sample_bank_account.Transaction\")\n-             .addProperty(\"default.directory_provider\", \"local-heap\");\n+             .addProperty(SearchConfig.DIRECTORY_TYPE, SearchConfig.HEAP);\n       createHotRodServers(2, builder);\n    }\n \n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "27013524412dd967281110da5edd13d20b956941", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/admin/RemoteCacheAdminTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/admin/RemoteCacheAdminTest.java\nindex 2147935b42..20b1804e39 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/admin/RemoteCacheAdminTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/admin/RemoteCacheAdminTest.java\n", "chunk": "@@ -46,8 +47,8 @@ protected void createCacheManagers() throws Throwable {\n       ConfigurationBuilder builder = hotRodCacheConfiguration(\n             getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false));\n       builder.indexing().enable()\n-             .addIndexedEntity(\"sample_bank_account.Transaction\")\n-             .addProperty(SearchConfig.DIRECTORY_TYPE, SearchConfig.HEAP);\n+             .storage(LOCAL_HEAP)\n+             .addIndexedEntity(\"sample_bank_account.Transaction\");\n       createHotRodServers(2, builder);\n    }\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "91d194f1a4e6f6990903ea42094be659142bb4d5", "message": "Merge commit", "committedDate": null}, {"oid": "4f1bb1fd70fc5d1ae37b8997cad662acafbca053", "committedDate": "2020-10-19 21:24:25 +0200", "message": "ISPN-12394 Allow templates to be defined clusterwide and persisted"}, {"oid": "27013524412dd967281110da5edd13d20b956941", "committedDate": "2020-11-27 15:54:21 +0100", "message": "ISPN-11797 Introduce strong typed indexing configuration"}, {"oid": "011fcd80b1eafbef9793aa4316b0a8399b8b9609", "committedDate": "2020-12-18 17:04:59 +0100", "message": "ISPN-12133 Support XML Fragments in CacheContainerAdmin"}, {"oid": "0322cab5d06d10c7fa0561b1690d985376d13f19", "committedDate": "2021-03-19 10:42:11 -0400", "message": "ISPN-12801 Hot Rod client logs a timeout error after every server error"}, {"oid": "3e19533beb118a49fabc688e72925fcac0357c89", "committedDate": "2021-11-29 17:25:05 +0100", "message": "ISPN-13529 Create caches over Hot Rod with XML, JSON and YAML"}, {"oid": "ff2c02acb12f2b86458adb628991a124ba126575", "committedDate": "2022-01-13 08:45:44 -0500", "message": "ISPN-13611 REST server invokes potentially blocking operations"}, {"oid": "7bd0ed0b68eaa48b8b6e15496316da54914cc895", "committedDate": "2022-05-25 09:16:04 +0200", "message": "ISPN-13648 Schema evolution with respect to indices without downtime (#10114)"}, {"oid": "26d9491c334f6a7334b289948c539cc950e2d107", "committedDate": "2023-03-14 12:23:09 +0100", "message": "ISPN-14085 Expose update attribute operation with hotrod"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc4MzE1NA==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r458783154", "body": "Why did this change? Did the POJO in the test change or is it something new brougth by  HSearch 6?", "bodyText": "Why did this change? Did the POJO in the test change or is it something new brougth by  HSearch 6?", "bodyHTML": "<p dir=\"auto\">Why did this change? Did the POJO in the test change or is it something new brougth by  HSearch 6?</p>", "author": "gustavocoding", "createdAt": "2020-07-22T13:17:00Z", "path": "client/hotrod-client/src/test/java/org/infinispan/client/hotrod/marshall/NonIndexedEmbeddedRemoteQueryTest.java", "diffHunk": "@@ -25,10 +24,4 @@ protected ConfigurationBuilder createConfigBuilder() {\n       builder.encoding().value().mediaType(MediaType.APPLICATION_OBJECT_TYPE);\n       return builder;\n    }\n-\n-   @Test(expectedExceptions = HotRodClientException.class, expectedExceptionsMessageRegExp = \"org.infinispan.objectfilter.ParsingException: ISPN028521: Full-text queries cannot be applied to property 'longDescription' in type sample_bank_account.Transaction unless the property is indexed and analyzed.\")\n-   @Override\n-   public void testRemoteFullTextQuery() {\n-      super.testRemoteFullTextQuery();\n-   }", "originalCommit": "973742666427584064f0529d85af66024e57d0ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTkzMjAxNw==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r459932017", "bodyText": "I removed the test since I had to change the base implementation, that is EmbeddedRemoteInteropQueryTest#testRemoteFullTextQuery.\nThe change is caused by the fact that Hibernate Search 6 does not support a field that is sortable and full text at the same time.\nAnyway, I think that we can keep the original implementation for the subclass, so that we can keep the test case. I'm doing that...", "author": "fax4ever", "createdAt": "2020-07-24T08:57:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc4MzE1NA=="}], "type": "inlineReview", "revised_code": {"commit": "32718114c38cd1cf83048d759033d952387d0a7e", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/marshall/NonIndexedEmbeddedRemoteQueryTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/marshall/NonIndexedEmbeddedRemoteQueryTest.java\nindex 40e509b532..717067370b 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/marshall/NonIndexedEmbeddedRemoteQueryTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/marshall/NonIndexedEmbeddedRemoteQueryTest.java\n", "chunk": "@@ -24,4 +25,10 @@ protected ConfigurationBuilder createConfigBuilder() {\n       builder.encoding().value().mediaType(MediaType.APPLICATION_OBJECT_TYPE);\n       return builder;\n    }\n+\n+   @Test(expectedExceptions = HotRodClientException.class, expectedExceptionsMessageRegExp = \"org.infinispan.objectfilter.ParsingException: ISPN028521: Full-text queries cannot be applied to property 'longDescription' in type sample_bank_account.Transaction unless the property is indexed and analyzed.\")\n+   @Override\n+   public void testRemoteFullTextQuery() {\n+      super.testRemoteFullTextQuery();\n+   }\n }\n", "next_change": {"commit": "bb18590bbe7e5e9948bca940518235678d1a4fae", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/marshall/NonIndexedEmbeddedRemoteQueryTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/marshall/NonIndexedEmbeddedRemoteQueryTest.java\nindex 717067370b..049d8cacd3 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/marshall/NonIndexedEmbeddedRemoteQueryTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/marshall/NonIndexedEmbeddedRemoteQueryTest.java\n", "chunk": "@@ -29,6 +38,22 @@ protected ConfigurationBuilder createConfigBuilder() {\n    @Test(expectedExceptions = HotRodClientException.class, expectedExceptionsMessageRegExp = \"org.infinispan.objectfilter.ParsingException: ISPN028521: Full-text queries cannot be applied to property 'longDescription' in type sample_bank_account.Transaction unless the property is indexed and analyzed.\")\n    @Override\n    public void testRemoteFullTextQuery() {\n-      super.testRemoteFullTextQuery();\n+      Transaction transaction = new TransactionHS();\n+      transaction.setId(3);\n+      transaction.setDescription(\"Hotel\");\n+      transaction.setLongDescription(\"Expenses for Infinispan F2F meeting\");\n+      transaction.setAccountId(2);\n+      transaction.setAmount(99);\n+      transaction.setDate(new Date(42));\n+      transaction.setDebit(true);\n+      transaction.setValid(true);\n+      cache.put(transaction.getId(), transaction);\n+\n+      QueryFactory qf = Search.getQueryFactory(remoteCache);\n+\n+      Query<Transaction> q = qf.create(\"from sample_bank_account.Transaction where longDescription:'Expenses for Infinispan F2F meeting'\");\n+\n+      List<Transaction> list = q.execute().list();\n+      assertEquals(1, list.size());\n    }\n }\n", "next_change": {"commit": "b76eeeee768bb075a447e35324baa3d6986830f1", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/marshall/NonIndexedEmbeddedRemoteQueryTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/marshall/NonIndexedEmbeddedRemoteQueryTest.java\nindex 049d8cacd3..717067370b 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/marshall/NonIndexedEmbeddedRemoteQueryTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/marshall/NonIndexedEmbeddedRemoteQueryTest.java\n", "chunk": "@@ -38,22 +29,6 @@ protected ConfigurationBuilder createConfigBuilder() {\n    @Test(expectedExceptions = HotRodClientException.class, expectedExceptionsMessageRegExp = \"org.infinispan.objectfilter.ParsingException: ISPN028521: Full-text queries cannot be applied to property 'longDescription' in type sample_bank_account.Transaction unless the property is indexed and analyzed.\")\n    @Override\n    public void testRemoteFullTextQuery() {\n-      Transaction transaction = new TransactionHS();\n-      transaction.setId(3);\n-      transaction.setDescription(\"Hotel\");\n-      transaction.setLongDescription(\"Expenses for Infinispan F2F meeting\");\n-      transaction.setAccountId(2);\n-      transaction.setAmount(99);\n-      transaction.setDate(new Date(42));\n-      transaction.setDebit(true);\n-      transaction.setValid(true);\n-      cache.put(transaction.getId(), transaction);\n-\n-      QueryFactory qf = Search.getQueryFactory(remoteCache);\n-\n-      Query<Transaction> q = qf.create(\"from sample_bank_account.Transaction where longDescription:'Expenses for Infinispan F2F meeting'\");\n-\n-      List<Transaction> list = q.execute().list();\n-      assertEquals(1, list.size());\n+      super.testRemoteFullTextQuery();\n    }\n }\n", "next_change": {"commit": "917da575b1ba55b0147d9cbeb1e553e3b24fc837", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/marshall/NonIndexedEmbeddedRemoteQueryTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/marshall/NonIndexedEmbeddedRemoteQueryTest.java\nindex 717067370b..049d8cacd3 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/marshall/NonIndexedEmbeddedRemoteQueryTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/marshall/NonIndexedEmbeddedRemoteQueryTest.java\n", "chunk": "@@ -29,6 +38,22 @@ protected ConfigurationBuilder createConfigBuilder() {\n    @Test(expectedExceptions = HotRodClientException.class, expectedExceptionsMessageRegExp = \"org.infinispan.objectfilter.ParsingException: ISPN028521: Full-text queries cannot be applied to property 'longDescription' in type sample_bank_account.Transaction unless the property is indexed and analyzed.\")\n    @Override\n    public void testRemoteFullTextQuery() {\n-      super.testRemoteFullTextQuery();\n+      Transaction transaction = new TransactionHS();\n+      transaction.setId(3);\n+      transaction.setDescription(\"Hotel\");\n+      transaction.setLongDescription(\"Expenses for Infinispan F2F meeting\");\n+      transaction.setAccountId(2);\n+      transaction.setAmount(99);\n+      transaction.setDate(new Date(42));\n+      transaction.setDebit(true);\n+      transaction.setValid(true);\n+      cache.put(transaction.getId(), transaction);\n+\n+      QueryFactory qf = Search.getQueryFactory(remoteCache);\n+\n+      Query<Transaction> q = qf.create(\"from sample_bank_account.Transaction where longDescription:'Expenses for Infinispan F2F meeting'\");\n+\n+      List<Transaction> list = q.execute().list();\n+      assertEquals(1, list.size());\n    }\n }\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "91d194f1a4e6f6990903ea42094be659142bb4d5", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/marshall/NonIndexedEmbeddedRemoteQueryTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/marshall/NonIndexedEmbeddedRemoteQueryTest.java\nindex 40e509b532..049d8cacd3 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/marshall/NonIndexedEmbeddedRemoteQueryTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/marshall/NonIndexedEmbeddedRemoteQueryTest.java\n", "chunk": "@@ -24,4 +34,26 @@ protected ConfigurationBuilder createConfigBuilder() {\n       builder.encoding().value().mediaType(MediaType.APPLICATION_OBJECT_TYPE);\n       return builder;\n    }\n+\n+   @Test(expectedExceptions = HotRodClientException.class, expectedExceptionsMessageRegExp = \"org.infinispan.objectfilter.ParsingException: ISPN028521: Full-text queries cannot be applied to property 'longDescription' in type sample_bank_account.Transaction unless the property is indexed and analyzed.\")\n+   @Override\n+   public void testRemoteFullTextQuery() {\n+      Transaction transaction = new TransactionHS();\n+      transaction.setId(3);\n+      transaction.setDescription(\"Hotel\");\n+      transaction.setLongDescription(\"Expenses for Infinispan F2F meeting\");\n+      transaction.setAccountId(2);\n+      transaction.setAmount(99);\n+      transaction.setDate(new Date(42));\n+      transaction.setDebit(true);\n+      transaction.setValid(true);\n+      cache.put(transaction.getId(), transaction);\n+\n+      QueryFactory qf = Search.getQueryFactory(remoteCache);\n+\n+      Query<Transaction> q = qf.create(\"from sample_bank_account.Transaction where longDescription:'Expenses for Infinispan F2F meeting'\");\n+\n+      List<Transaction> list = q.execute().list();\n+      assertEquals(1, list.size());\n+   }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "91d194f1a4e6f6990903ea42094be659142bb4d5", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc4NjM0Ng==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r458786346", "body": "It seems many of the new config added here is unrelated to the old config. So that we can understand and proper document in the upgrade guide, would it be possible to replace them with the equivalent new ones, keeping the same numeric values if possible?", "bodyText": "It seems many of the new config added here is unrelated to the old config. So that we can understand and proper document in the upgrade guide, would it be possible to replace them with the equivalent new ones, keeping the same numeric values if possible?", "bodyHTML": "<p dir=\"auto\">It seems many of the new config added here is unrelated to the old config. So that we can understand and proper document in the upgrade guide, would it be possible to replace them with the equivalent new ones, keeping the same numeric values if possible?</p>", "author": "gustavocoding", "createdAt": "2020-07-22T13:21:30Z", "path": "client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/MultiServerStoreQueryTest.java", "diffHunk": "@@ -90,12 +91,13 @@ public Configuration buildIndexedConfig(String storeName) {\n       ConfigurationBuilder builder = hotRodCacheConfiguration(getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false));\n       builder.indexing().enable()\n              .addIndexedEntity(\"News\")\n-             .addProperty(\"default.directory_provider\", \"local-heap\")\n-             .addProperty(\"default.worker.execution\", \"async\")\n-             .addProperty(\"default.index_flush_interval\", \"500\")\n-             .addProperty(\"default.indexwriter.merge_factor\", \"30\")\n-             .addProperty(\"default.indexwriter.merge_max_size\", \"1024\")\n-             .addProperty(\"default.indexwriter.ram_buffer_size\", \"256\");\n+             .addProperty(SearchConfig.DIRECTORY_TYPE, SearchConfig.HEAP)\n+            .addProperty(SearchConfig.THREAD_POOL_SIZE, \"6\")\n+             .addProperty(SearchConfig.QUEUE_COUNT, \"6\")\n+             .addProperty(SearchConfig.QUEUE_SIZE, \"4096\")\n+             .addProperty(SearchConfig.COMMIT_INTERVAL, \"10000\")\n+             .addProperty(SearchConfig.SHARDING_STRATEGY, SearchConfig.HASH)\n+             .addProperty(SearchConfig.NUMBER_OF_SHARDS, \"6\");", "originalCommit": "973742666427584064f0529d85af66024e57d0ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAzMzU4NQ==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r460033585", "bodyText": "When I did the change we didn't have all the options we have right now. I'm restoring the old config using the new properties. This looks like the last comment I still have to fix. Isn\u2019t it?", "author": "fax4ever", "createdAt": "2020-07-24T12:53:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc4NjM0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAzNTg4Mg==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r460035882", "bodyText": "Moreover, it looks like we don't need a constant class now, we can use the official one, that is \"org.hibernate.search.backend.lucene.cfg.LuceneIndexSettings\". Doing the change now... forget it we have to use the ISPN now, since we simply the prefixes..", "author": "fax4ever", "createdAt": "2020-07-24T12:58:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc4NjM0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "32718114c38cd1cf83048d759033d952387d0a7e", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/MultiServerStoreQueryTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/MultiServerStoreQueryTest.java\nindex 1721dc6b98..368055e907 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/MultiServerStoreQueryTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/MultiServerStoreQueryTest.java\n", "chunk": "@@ -91,13 +90,12 @@ public Configuration buildIndexedConfig(String storeName) {\n       ConfigurationBuilder builder = hotRodCacheConfiguration(getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false));\n       builder.indexing().enable()\n              .addIndexedEntity(\"News\")\n-             .addProperty(SearchConfig.DIRECTORY_TYPE, SearchConfig.HEAP)\n-            .addProperty(SearchConfig.THREAD_POOL_SIZE, \"6\")\n-             .addProperty(SearchConfig.QUEUE_COUNT, \"6\")\n-             .addProperty(SearchConfig.QUEUE_SIZE, \"4096\")\n-             .addProperty(SearchConfig.COMMIT_INTERVAL, \"10000\")\n-             .addProperty(SearchConfig.SHARDING_STRATEGY, SearchConfig.HASH)\n-             .addProperty(SearchConfig.NUMBER_OF_SHARDS, \"6\");\n+             .addProperty(\"default.directory_provider\", \"local-heap\")\n+             .addProperty(\"default.worker.execution\", \"async\")\n+             .addProperty(\"default.index_flush_interval\", \"500\")\n+             .addProperty(\"default.indexwriter.merge_factor\", \"30\")\n+             .addProperty(\"default.indexwriter.merge_max_size\", \"1024\")\n+             .addProperty(\"default.indexwriter.ram_buffer_size\", \"256\");\n       builder.memory().storageType(storageType);\n       if (evictionSize > 0) {\n          builder.memory().size(evictionSize);\n", "next_change": {"commit": "bb18590bbe7e5e9948bca940518235678d1a4fae", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/MultiServerStoreQueryTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/MultiServerStoreQueryTest.java\nindex 368055e907..1721dc6b98 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/MultiServerStoreQueryTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/MultiServerStoreQueryTest.java\n", "chunk": "@@ -90,12 +91,13 @@ public Configuration buildIndexedConfig(String storeName) {\n       ConfigurationBuilder builder = hotRodCacheConfiguration(getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false));\n       builder.indexing().enable()\n              .addIndexedEntity(\"News\")\n-             .addProperty(\"default.directory_provider\", \"local-heap\")\n-             .addProperty(\"default.worker.execution\", \"async\")\n-             .addProperty(\"default.index_flush_interval\", \"500\")\n-             .addProperty(\"default.indexwriter.merge_factor\", \"30\")\n-             .addProperty(\"default.indexwriter.merge_max_size\", \"1024\")\n-             .addProperty(\"default.indexwriter.ram_buffer_size\", \"256\");\n+             .addProperty(SearchConfig.DIRECTORY_TYPE, SearchConfig.HEAP)\n+            .addProperty(SearchConfig.THREAD_POOL_SIZE, \"6\")\n+             .addProperty(SearchConfig.QUEUE_COUNT, \"6\")\n+             .addProperty(SearchConfig.QUEUE_SIZE, \"4096\")\n+             .addProperty(SearchConfig.COMMIT_INTERVAL, \"10000\")\n+             .addProperty(SearchConfig.SHARDING_STRATEGY, SearchConfig.HASH)\n+             .addProperty(SearchConfig.NUMBER_OF_SHARDS, \"6\");\n       builder.memory().storageType(storageType);\n       if (evictionSize > 0) {\n          builder.memory().size(evictionSize);\n", "next_change": {"commit": "b76eeeee768bb075a447e35324baa3d6986830f1", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/MultiServerStoreQueryTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/MultiServerStoreQueryTest.java\nindex 1721dc6b98..368055e907 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/MultiServerStoreQueryTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/MultiServerStoreQueryTest.java\n", "chunk": "@@ -91,13 +90,12 @@ public Configuration buildIndexedConfig(String storeName) {\n       ConfigurationBuilder builder = hotRodCacheConfiguration(getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false));\n       builder.indexing().enable()\n              .addIndexedEntity(\"News\")\n-             .addProperty(SearchConfig.DIRECTORY_TYPE, SearchConfig.HEAP)\n-            .addProperty(SearchConfig.THREAD_POOL_SIZE, \"6\")\n-             .addProperty(SearchConfig.QUEUE_COUNT, \"6\")\n-             .addProperty(SearchConfig.QUEUE_SIZE, \"4096\")\n-             .addProperty(SearchConfig.COMMIT_INTERVAL, \"10000\")\n-             .addProperty(SearchConfig.SHARDING_STRATEGY, SearchConfig.HASH)\n-             .addProperty(SearchConfig.NUMBER_OF_SHARDS, \"6\");\n+             .addProperty(\"default.directory_provider\", \"local-heap\")\n+             .addProperty(\"default.worker.execution\", \"async\")\n+             .addProperty(\"default.index_flush_interval\", \"500\")\n+             .addProperty(\"default.indexwriter.merge_factor\", \"30\")\n+             .addProperty(\"default.indexwriter.merge_max_size\", \"1024\")\n+             .addProperty(\"default.indexwriter.ram_buffer_size\", \"256\");\n       builder.memory().storageType(storageType);\n       if (evictionSize > 0) {\n          builder.memory().size(evictionSize);\n", "next_change": {"commit": "917da575b1ba55b0147d9cbeb1e553e3b24fc837", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/MultiServerStoreQueryTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/MultiServerStoreQueryTest.java\nindex 368055e907..1721dc6b98 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/MultiServerStoreQueryTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/MultiServerStoreQueryTest.java\n", "chunk": "@@ -90,12 +91,13 @@ public Configuration buildIndexedConfig(String storeName) {\n       ConfigurationBuilder builder = hotRodCacheConfiguration(getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false));\n       builder.indexing().enable()\n              .addIndexedEntity(\"News\")\n-             .addProperty(\"default.directory_provider\", \"local-heap\")\n-             .addProperty(\"default.worker.execution\", \"async\")\n-             .addProperty(\"default.index_flush_interval\", \"500\")\n-             .addProperty(\"default.indexwriter.merge_factor\", \"30\")\n-             .addProperty(\"default.indexwriter.merge_max_size\", \"1024\")\n-             .addProperty(\"default.indexwriter.ram_buffer_size\", \"256\");\n+             .addProperty(SearchConfig.DIRECTORY_TYPE, SearchConfig.HEAP)\n+            .addProperty(SearchConfig.THREAD_POOL_SIZE, \"6\")\n+             .addProperty(SearchConfig.QUEUE_COUNT, \"6\")\n+             .addProperty(SearchConfig.QUEUE_SIZE, \"4096\")\n+             .addProperty(SearchConfig.COMMIT_INTERVAL, \"10000\")\n+             .addProperty(SearchConfig.SHARDING_STRATEGY, SearchConfig.HASH)\n+             .addProperty(SearchConfig.NUMBER_OF_SHARDS, \"6\");\n       builder.memory().storageType(storageType);\n       if (evictionSize > 0) {\n          builder.memory().size(evictionSize);\n", "next_change": {"commit": "d8d307f379ffaa6ca9b4d670e4abe4e0f2ae33f3", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/MultiServerStoreQueryTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/MultiServerStoreQueryTest.java\nindex 1721dc6b98..6d4af6581a 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/MultiServerStoreQueryTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/MultiServerStoreQueryTest.java\n", "chunk": "@@ -90,14 +90,14 @@ public Configuration getLuceneCacheConfig(String storeName) {\n    public Configuration buildIndexedConfig(String storeName) {\n       ConfigurationBuilder builder = hotRodCacheConfiguration(getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false));\n       builder.indexing().enable()\n-             .addIndexedEntity(\"News\")\n-             .addProperty(SearchConfig.DIRECTORY_TYPE, SearchConfig.HEAP)\n-            .addProperty(SearchConfig.THREAD_POOL_SIZE, \"6\")\n-             .addProperty(SearchConfig.QUEUE_COUNT, \"6\")\n-             .addProperty(SearchConfig.QUEUE_SIZE, \"4096\")\n-             .addProperty(SearchConfig.COMMIT_INTERVAL, \"10000\")\n-             .addProperty(SearchConfig.SHARDING_STRATEGY, SearchConfig.HASH)\n-             .addProperty(SearchConfig.NUMBER_OF_SHARDS, \"6\");\n+            .addIndexedEntity(\"News\")\n+            .addProperty(SearchConfig.DIRECTORY_TYPE, SearchConfig.HEAP)\n+            .addProperty(SearchConfig.IO_STRATEGY, SearchConfig.NEAR_REAL_TIME)\n+            .addProperty(SearchConfig.COMMIT_INTERVAL, \"500\")\n+            .addProperty(SearchConfig.IO_MERGE_FACTOR, \"30\")\n+            .addProperty(SearchConfig.IO_MERGE_MAX_SIZE, \"1024\")\n+            .addProperty(SearchConfig.IO_WRITER_RAM_BUFFER_SIZE, \"256\");\n+\n       builder.memory().storageType(storageType);\n       if (evictionSize > 0) {\n          builder.memory().size(evictionSize);\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "91d194f1a4e6f6990903ea42094be659142bb4d5", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/MultiServerStoreQueryTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/MultiServerStoreQueryTest.java\nindex 1721dc6b98..6d4af6581a 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/MultiServerStoreQueryTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/MultiServerStoreQueryTest.java\n", "chunk": "@@ -90,14 +90,14 @@ public Configuration getLuceneCacheConfig(String storeName) {\n    public Configuration buildIndexedConfig(String storeName) {\n       ConfigurationBuilder builder = hotRodCacheConfiguration(getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false));\n       builder.indexing().enable()\n-             .addIndexedEntity(\"News\")\n-             .addProperty(SearchConfig.DIRECTORY_TYPE, SearchConfig.HEAP)\n-            .addProperty(SearchConfig.THREAD_POOL_SIZE, \"6\")\n-             .addProperty(SearchConfig.QUEUE_COUNT, \"6\")\n-             .addProperty(SearchConfig.QUEUE_SIZE, \"4096\")\n-             .addProperty(SearchConfig.COMMIT_INTERVAL, \"10000\")\n-             .addProperty(SearchConfig.SHARDING_STRATEGY, SearchConfig.HASH)\n-             .addProperty(SearchConfig.NUMBER_OF_SHARDS, \"6\");\n+            .addIndexedEntity(\"News\")\n+            .addProperty(SearchConfig.DIRECTORY_TYPE, SearchConfig.HEAP)\n+            .addProperty(SearchConfig.IO_STRATEGY, SearchConfig.NEAR_REAL_TIME)\n+            .addProperty(SearchConfig.COMMIT_INTERVAL, \"500\")\n+            .addProperty(SearchConfig.IO_MERGE_FACTOR, \"30\")\n+            .addProperty(SearchConfig.IO_MERGE_MAX_SIZE, \"1024\")\n+            .addProperty(SearchConfig.IO_WRITER_RAM_BUFFER_SIZE, \"256\");\n+\n       builder.memory().storageType(storageType);\n       if (evictionSize > 0) {\n          builder.memory().size(evictionSize);\n", "next_change": {"commit": "27013524412dd967281110da5edd13d20b956941", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/MultiServerStoreQueryTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/MultiServerStoreQueryTest.java\nindex 6d4af6581a..87e5ecbc5e 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/MultiServerStoreQueryTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/MultiServerStoreQueryTest.java\n", "chunk": "@@ -90,13 +90,10 @@ public Configuration getLuceneCacheConfig(String storeName) {\n    public Configuration buildIndexedConfig(String storeName) {\n       ConfigurationBuilder builder = hotRodCacheConfiguration(getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false));\n       builder.indexing().enable()\n-            .addIndexedEntity(\"News\")\n-            .addProperty(SearchConfig.DIRECTORY_TYPE, SearchConfig.HEAP)\n-            .addProperty(SearchConfig.IO_STRATEGY, SearchConfig.NEAR_REAL_TIME)\n-            .addProperty(SearchConfig.COMMIT_INTERVAL, \"500\")\n-            .addProperty(SearchConfig.IO_MERGE_FACTOR, \"30\")\n-            .addProperty(SearchConfig.IO_MERGE_MAX_SIZE, \"1024\")\n-            .addProperty(SearchConfig.IO_WRITER_RAM_BUFFER_SIZE, \"256\");\n+            .storage(LOCAL_HEAP)\n+            .writer().commitInterval(500).ramBufferSize(256)\n+            .merge().factor(30).maxSize(1024)\n+            .addIndexedEntity(\"News\");\n \n       builder.memory().storageType(storageType);\n       if (evictionSize > 0) {\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "91d194f1a4e6f6990903ea42094be659142bb4d5", "message": "Merge commit", "committedDate": null}, {"oid": "27013524412dd967281110da5edd13d20b956941", "committedDate": "2020-11-27 15:54:21 +0100", "message": "ISPN-11797 Introduce strong typed indexing configuration"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc4ODUxMA==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r458788510", "body": "Could you drop a comment here what is the equivalent of ```near-real-time``` in HS6? ", "bodyText": "Could you drop a comment here what is the equivalent of near-real-time in HS6?", "bodyHTML": "<p dir=\"auto\">Could you drop a comment here what is the equivalent of <code>near-real-time</code> in HS6?</p>", "author": "gustavocoding", "createdAt": "2020-07-22T13:24:38Z", "path": "client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryDslConditionsTunedTest.java", "diffHunk": "@@ -29,23 +30,26 @@ protected ConfigurationBuilder getConfigurationBuilder() {\n              .addIndexedEntity(\"sample_bank_account.User\")\n              .addIndexedEntity(\"sample_bank_account.Account\")\n              .addIndexedEntity(\"sample_bank_account.Transaction\")\n-             .addProperty(\"default.indexmanager\", \"near-real-time\")\n-             .addProperty(\"default.indexBase\", indexDirectory)\n-             .addProperty(\"default.exclusive_index_use\", \"true\")\n-             .addProperty(\"default.indexwriter.merge_factor\", \"30\")\n-             .addProperty(\"default.indexwriter.merge_max_size\", \"4096\")\n-             .addProperty(\"default.indexwriter.ram_buffer_size\", \"220\")\n-             .addProperty(\"default.locking_strategy\", \"native\")\n-             .addProperty(\"default.sharding_strategy.nbr_of_shards\", String.valueOf(NUM_SHARDS));\n+             .addProperty(SearchConfig.DIRECTORY_TYPE, SearchConfig.FILE)\n+             .addProperty(SearchConfig.DIRECTORY_ROOT, indexDirectory)\n+             .addProperty(SearchConfig.THREAD_POOL_SIZE, String.valueOf(NUM_SHARDS))\n+             .addProperty(SearchConfig.QUEUE_COUNT, String.valueOf(NUM_SHARDS))\n+             .addProperty(SearchConfig.QUEUE_SIZE, \"4096\")\n+             .addProperty(SearchConfig.COMMIT_INTERVAL, \"10000\")\n+             .addProperty(SearchConfig.SHARDING_STRATEGY, SearchConfig.HASH)\n+             .addProperty(SearchConfig.NUMBER_OF_SHARDS, String.valueOf(NUM_SHARDS));", "originalCommit": "973742666427584064f0529d85af66024e57d0ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODg0OTM5NA==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r458849394", "bodyText": "I think we discussed this already a few months ago, but let's summarize it here.\nNRT is enabled by default, sort of. Commits are asynchronous by default and index readers are aware of uncommitted changes by default.\nConfiguration in Hibernate Search 6 is different from Hibernate Search 5:\n\nWhen you request indexing, you (Infinispan) can request that the commit happens immediately.\n\nIf you do, the commit will happen before the indexing operation returns. Obviously, it will perform badly if you index your documents one by one.\nIf you don't the commit will happen some time after the indexing operation returns. By default it's 1000ms, but you can set it to a different number.\n\n\nReaders are always aware of uncommitted changes by default, i.e. they are aware of changes still in the index writer buffers.\n\nReaders are typically cached, and recreated only when necessary.\nIf you can accept out-of-date readers, you can go a step further and set a refresh interval so that readers are only re-created every 10000ms, for example. That's where manual refreshes become useful.\n\n\n\nMore information: https://docs.jboss.org/hibernate/search/6.0/reference/en-US/html_single/#backend-lucene-io", "author": "yrodiere", "createdAt": "2020-07-22T14:47:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc4ODUxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODg1OTc4MA==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r458859780", "bodyText": "Right, thanks for the reminder. I don't remember if we discussed that, but in HSearch 5, there was org.hibernate.search.backend.impl.lucene.SyncWorkProcessor that would guarantee that, if multiple threads were writing to the index at the same time, the backend would \"batch\" their changes to do a single commit, rather than do one commit per document, is that still the case in Hibernate Search 6?", "author": "gustavonalle", "createdAt": "2020-07-22T15:01:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc4ODUxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODg2ODg2OQ==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r458868869", "bodyText": "is that still the case in Hibernate Search 6?\n\nIf you force the commit, it will happen ASAP, so no.\nIf you don't force the commit, then Hibernate Search will still return before the commit, which will happen asynchronously. However, if you set the commit interval 0, it will commit just after each \"batch\" of operations. The size of batches can be configured.\nIf you want guarantees that changes are flushed to disk, that's obviously not enough. Depending on Infinispan's needs, we could introduce another behavior where you don't force the commit, but ask Hibernate Search to only consider the indexing operation completed when the next commit happens (whenever that is). I believe that shouldn't be too much work. That will have to wait until after this PR is merged, though (we need another release of Search).\nI believe that shouldn't be too much work => Well actually, thinking about it, it may be a bit complex, due to operations being applied in parallel in different threads. I need to give it a closer look", "author": "yrodiere", "createdAt": "2020-07-22T15:13:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc4ODUxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODg5NDQ1Mw==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r458894453", "bodyText": "Hold on a sec. So basically, we are moving from\n\nmaster, where NRT is not enabled by default, and will commit on every document synchronously, but will coalesce writing threads to reduce the number of commits. Once the cache operation completes, it is guarantee the document is indexed on disk and it's visible on searches.\n\nto\n\nISPN-10249 (this PR), where NRT is ON by default, commits are done by batch size or time, cache operations guarantee immediate visibility on searches but not immediate persistence of the index, but only once every second (configurable)\n\nCorrect?\nIf so, I reckon 2) is overall better than 1), so I wouldn't rush to implement the old behaviour", "author": "gustavonalle", "createdAt": "2020-07-22T15:48:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc4ODUxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkwMzMyMg==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r458903322", "bodyText": "Correct.\nThe only drawback of the new behavior is there is no way to get a guarantee that each change is on disk after the cache operation completes unless you accept bad performance (one commit per cache operation).\nI believe that kind of requirement is a bit unreasonable for a secondary source of truth such as Lucene indexes, though. We will probably have a look at some time in the future, for the sake of completeness, but I agree with you this can wait.", "author": "yrodiere", "createdAt": "2020-07-22T16:00:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc4ODUxMA=="}], "type": "inlineReview", "revised_code": {"commit": "32718114c38cd1cf83048d759033d952387d0a7e", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryDslConditionsTunedTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryDslConditionsTunedTest.java\nindex 6fcae55db4..c5bf191ec4 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryDslConditionsTunedTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryDslConditionsTunedTest.java\n", "chunk": "@@ -30,26 +29,23 @@ protected ConfigurationBuilder getConfigurationBuilder() {\n              .addIndexedEntity(\"sample_bank_account.User\")\n              .addIndexedEntity(\"sample_bank_account.Account\")\n              .addIndexedEntity(\"sample_bank_account.Transaction\")\n-             .addProperty(SearchConfig.DIRECTORY_TYPE, SearchConfig.FILE)\n-             .addProperty(SearchConfig.DIRECTORY_ROOT, indexDirectory)\n-             .addProperty(SearchConfig.THREAD_POOL_SIZE, String.valueOf(NUM_SHARDS))\n-             .addProperty(SearchConfig.QUEUE_COUNT, String.valueOf(NUM_SHARDS))\n-             .addProperty(SearchConfig.QUEUE_SIZE, \"4096\")\n-             .addProperty(SearchConfig.COMMIT_INTERVAL, \"10000\")\n-             .addProperty(SearchConfig.SHARDING_STRATEGY, SearchConfig.HASH)\n-             .addProperty(SearchConfig.NUMBER_OF_SHARDS, String.valueOf(NUM_SHARDS));\n+             .addProperty(\"default.indexmanager\", \"near-real-time\")\n+             .addProperty(\"default.indexBase\", indexDirectory)\n+             .addProperty(\"default.exclusive_index_use\", \"true\")\n+             .addProperty(\"default.indexwriter.merge_factor\", \"30\")\n+             .addProperty(\"default.indexwriter.merge_max_size\", \"4096\")\n+             .addProperty(\"default.indexwriter.ram_buffer_size\", \"220\")\n+             .addProperty(\"default.locking_strategy\", \"native\")\n+             .addProperty(\"default.sharding_strategy.nbr_of_shards\", String.valueOf(NUM_SHARDS));\n       return builder;\n    }\n \n    @Override\n    public void testIndexPresence() {\n-      SearchMapping searchMapping = TestingUtil.extractComponent(cache, SearchMappingHolder.class)\n-            .getSearchMapping();\n-\n-      // we have indexing for remote query!\n-      assertTrue(searchMapping.allIndexedTypes().containsValue(ProtobufValueWrapper.class));\n-\n-      // we have some indexes for this cache\n-      assertEquals(2, searchMapping.allIndexedTypes().size());\n+      SearchIntegrator searchIntegrator = TestingUtil.extractComponent(cache, SearchIntegrator.class);\n+      assertTrue(searchIntegrator.getIndexBindings().containsKey(ProtobufValueWrapper.INDEXING_TYPE));\n+      for (int shard = 0; shard < NUM_SHARDS; shard++) {\n+         assertNotNull(searchIntegrator.getIndexManager(ProgrammaticSearchMappingProviderImpl.getIndexName(cache.getName()) + '.' + shard));\n+      }\n    }\n }\n", "next_change": {"commit": "bb18590bbe7e5e9948bca940518235678d1a4fae", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryDslConditionsTunedTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryDslConditionsTunedTest.java\nindex c5bf191ec4..6fcae55db4 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryDslConditionsTunedTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryDslConditionsTunedTest.java\n", "chunk": "@@ -29,23 +30,26 @@ protected ConfigurationBuilder getConfigurationBuilder() {\n              .addIndexedEntity(\"sample_bank_account.User\")\n              .addIndexedEntity(\"sample_bank_account.Account\")\n              .addIndexedEntity(\"sample_bank_account.Transaction\")\n-             .addProperty(\"default.indexmanager\", \"near-real-time\")\n-             .addProperty(\"default.indexBase\", indexDirectory)\n-             .addProperty(\"default.exclusive_index_use\", \"true\")\n-             .addProperty(\"default.indexwriter.merge_factor\", \"30\")\n-             .addProperty(\"default.indexwriter.merge_max_size\", \"4096\")\n-             .addProperty(\"default.indexwriter.ram_buffer_size\", \"220\")\n-             .addProperty(\"default.locking_strategy\", \"native\")\n-             .addProperty(\"default.sharding_strategy.nbr_of_shards\", String.valueOf(NUM_SHARDS));\n+             .addProperty(SearchConfig.DIRECTORY_TYPE, SearchConfig.FILE)\n+             .addProperty(SearchConfig.DIRECTORY_ROOT, indexDirectory)\n+             .addProperty(SearchConfig.THREAD_POOL_SIZE, String.valueOf(NUM_SHARDS))\n+             .addProperty(SearchConfig.QUEUE_COUNT, String.valueOf(NUM_SHARDS))\n+             .addProperty(SearchConfig.QUEUE_SIZE, \"4096\")\n+             .addProperty(SearchConfig.COMMIT_INTERVAL, \"10000\")\n+             .addProperty(SearchConfig.SHARDING_STRATEGY, SearchConfig.HASH)\n+             .addProperty(SearchConfig.NUMBER_OF_SHARDS, String.valueOf(NUM_SHARDS));\n       return builder;\n    }\n \n    @Override\n    public void testIndexPresence() {\n-      SearchIntegrator searchIntegrator = TestingUtil.extractComponent(cache, SearchIntegrator.class);\n-      assertTrue(searchIntegrator.getIndexBindings().containsKey(ProtobufValueWrapper.INDEXING_TYPE));\n-      for (int shard = 0; shard < NUM_SHARDS; shard++) {\n-         assertNotNull(searchIntegrator.getIndexManager(ProgrammaticSearchMappingProviderImpl.getIndexName(cache.getName()) + '.' + shard));\n-      }\n+      SearchMapping searchMapping = TestingUtil.extractComponent(cache, SearchMappingHolder.class)\n+            .getSearchMapping();\n+\n+      // we have indexing for remote query!\n+      assertTrue(searchMapping.allIndexedTypes().containsValue(ProtobufValueWrapper.class));\n+\n+      // we have some indexes for this cache\n+      assertEquals(2, searchMapping.allIndexedTypes().size());\n    }\n }\n", "next_change": {"commit": "b76eeeee768bb075a447e35324baa3d6986830f1", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryDslConditionsTunedTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryDslConditionsTunedTest.java\nindex 6fcae55db4..c5bf191ec4 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryDslConditionsTunedTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryDslConditionsTunedTest.java\n", "chunk": "@@ -30,26 +29,23 @@ protected ConfigurationBuilder getConfigurationBuilder() {\n              .addIndexedEntity(\"sample_bank_account.User\")\n              .addIndexedEntity(\"sample_bank_account.Account\")\n              .addIndexedEntity(\"sample_bank_account.Transaction\")\n-             .addProperty(SearchConfig.DIRECTORY_TYPE, SearchConfig.FILE)\n-             .addProperty(SearchConfig.DIRECTORY_ROOT, indexDirectory)\n-             .addProperty(SearchConfig.THREAD_POOL_SIZE, String.valueOf(NUM_SHARDS))\n-             .addProperty(SearchConfig.QUEUE_COUNT, String.valueOf(NUM_SHARDS))\n-             .addProperty(SearchConfig.QUEUE_SIZE, \"4096\")\n-             .addProperty(SearchConfig.COMMIT_INTERVAL, \"10000\")\n-             .addProperty(SearchConfig.SHARDING_STRATEGY, SearchConfig.HASH)\n-             .addProperty(SearchConfig.NUMBER_OF_SHARDS, String.valueOf(NUM_SHARDS));\n+             .addProperty(\"default.indexmanager\", \"near-real-time\")\n+             .addProperty(\"default.indexBase\", indexDirectory)\n+             .addProperty(\"default.exclusive_index_use\", \"true\")\n+             .addProperty(\"default.indexwriter.merge_factor\", \"30\")\n+             .addProperty(\"default.indexwriter.merge_max_size\", \"4096\")\n+             .addProperty(\"default.indexwriter.ram_buffer_size\", \"220\")\n+             .addProperty(\"default.locking_strategy\", \"native\")\n+             .addProperty(\"default.sharding_strategy.nbr_of_shards\", String.valueOf(NUM_SHARDS));\n       return builder;\n    }\n \n    @Override\n    public void testIndexPresence() {\n-      SearchMapping searchMapping = TestingUtil.extractComponent(cache, SearchMappingHolder.class)\n-            .getSearchMapping();\n-\n-      // we have indexing for remote query!\n-      assertTrue(searchMapping.allIndexedTypes().containsValue(ProtobufValueWrapper.class));\n-\n-      // we have some indexes for this cache\n-      assertEquals(2, searchMapping.allIndexedTypes().size());\n+      SearchIntegrator searchIntegrator = TestingUtil.extractComponent(cache, SearchIntegrator.class);\n+      assertTrue(searchIntegrator.getIndexBindings().containsKey(ProtobufValueWrapper.INDEXING_TYPE));\n+      for (int shard = 0; shard < NUM_SHARDS; shard++) {\n+         assertNotNull(searchIntegrator.getIndexManager(ProgrammaticSearchMappingProviderImpl.getIndexName(cache.getName()) + '.' + shard));\n+      }\n    }\n }\n", "next_change": {"commit": "917da575b1ba55b0147d9cbeb1e553e3b24fc837", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryDslConditionsTunedTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryDslConditionsTunedTest.java\nindex c5bf191ec4..6fcae55db4 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryDslConditionsTunedTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryDslConditionsTunedTest.java\n", "chunk": "@@ -29,23 +30,26 @@ protected ConfigurationBuilder getConfigurationBuilder() {\n              .addIndexedEntity(\"sample_bank_account.User\")\n              .addIndexedEntity(\"sample_bank_account.Account\")\n              .addIndexedEntity(\"sample_bank_account.Transaction\")\n-             .addProperty(\"default.indexmanager\", \"near-real-time\")\n-             .addProperty(\"default.indexBase\", indexDirectory)\n-             .addProperty(\"default.exclusive_index_use\", \"true\")\n-             .addProperty(\"default.indexwriter.merge_factor\", \"30\")\n-             .addProperty(\"default.indexwriter.merge_max_size\", \"4096\")\n-             .addProperty(\"default.indexwriter.ram_buffer_size\", \"220\")\n-             .addProperty(\"default.locking_strategy\", \"native\")\n-             .addProperty(\"default.sharding_strategy.nbr_of_shards\", String.valueOf(NUM_SHARDS));\n+             .addProperty(SearchConfig.DIRECTORY_TYPE, SearchConfig.FILE)\n+             .addProperty(SearchConfig.DIRECTORY_ROOT, indexDirectory)\n+             .addProperty(SearchConfig.THREAD_POOL_SIZE, String.valueOf(NUM_SHARDS))\n+             .addProperty(SearchConfig.QUEUE_COUNT, String.valueOf(NUM_SHARDS))\n+             .addProperty(SearchConfig.QUEUE_SIZE, \"4096\")\n+             .addProperty(SearchConfig.COMMIT_INTERVAL, \"10000\")\n+             .addProperty(SearchConfig.SHARDING_STRATEGY, SearchConfig.HASH)\n+             .addProperty(SearchConfig.NUMBER_OF_SHARDS, String.valueOf(NUM_SHARDS));\n       return builder;\n    }\n \n    @Override\n    public void testIndexPresence() {\n-      SearchIntegrator searchIntegrator = TestingUtil.extractComponent(cache, SearchIntegrator.class);\n-      assertTrue(searchIntegrator.getIndexBindings().containsKey(ProtobufValueWrapper.INDEXING_TYPE));\n-      for (int shard = 0; shard < NUM_SHARDS; shard++) {\n-         assertNotNull(searchIntegrator.getIndexManager(ProgrammaticSearchMappingProviderImpl.getIndexName(cache.getName()) + '.' + shard));\n-      }\n+      SearchMapping searchMapping = TestingUtil.extractComponent(cache, SearchMappingHolder.class)\n+            .getSearchMapping();\n+\n+      // we have indexing for remote query!\n+      assertTrue(searchMapping.allIndexedTypes().containsValue(ProtobufValueWrapper.class));\n+\n+      // we have some indexes for this cache\n+      assertEquals(2, searchMapping.allIndexedTypes().size());\n    }\n }\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "91d194f1a4e6f6990903ea42094be659142bb4d5", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryDslConditionsTunedTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryDslConditionsTunedTest.java\nindex 6fcae55db4..05622ff12e 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryDslConditionsTunedTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryDslConditionsTunedTest.java\n", "chunk": "@@ -27,17 +27,19 @@ public class RemoteQueryDslConditionsTunedTest extends RemoteQueryDslConditionsF\n    protected ConfigurationBuilder getConfigurationBuilder() {\n       ConfigurationBuilder builder = new ConfigurationBuilder();\n       builder.indexing().enable()\n-             .addIndexedEntity(\"sample_bank_account.User\")\n-             .addIndexedEntity(\"sample_bank_account.Account\")\n-             .addIndexedEntity(\"sample_bank_account.Transaction\")\n-             .addProperty(SearchConfig.DIRECTORY_TYPE, SearchConfig.FILE)\n-             .addProperty(SearchConfig.DIRECTORY_ROOT, indexDirectory)\n-             .addProperty(SearchConfig.THREAD_POOL_SIZE, String.valueOf(NUM_SHARDS))\n-             .addProperty(SearchConfig.QUEUE_COUNT, String.valueOf(NUM_SHARDS))\n-             .addProperty(SearchConfig.QUEUE_SIZE, \"4096\")\n-             .addProperty(SearchConfig.COMMIT_INTERVAL, \"10000\")\n-             .addProperty(SearchConfig.SHARDING_STRATEGY, SearchConfig.HASH)\n-             .addProperty(SearchConfig.NUMBER_OF_SHARDS, String.valueOf(NUM_SHARDS));\n+            .addIndexedEntity(\"sample_bank_account.User\")\n+            .addIndexedEntity(\"sample_bank_account.Account\")\n+            .addIndexedEntity(\"sample_bank_account.Transaction\")\n+            .addProperty(SearchConfig.IO_STRATEGY, SearchConfig.NEAR_REAL_TIME)\n+            .addProperty(SearchConfig.DIRECTORY_TYPE, SearchConfig.FILE)\n+            .addProperty(SearchConfig.DIRECTORY_ROOT, indexDirectory)\n+            .addProperty(SearchConfig.IO_MERGE_FACTOR, \"30\")\n+            .addProperty(SearchConfig.IO_MERGE_MAX_SIZE, \"4096\")\n+            .addProperty(SearchConfig.IO_WRITER_RAM_BUFFER_SIZE, \"220\")\n+            .addProperty(SearchConfig.DIRECTORY_LOCKING_STRATEGY, SearchConfig.NATIVE)\n+            .addProperty(SearchConfig.NUMBER_OF_SHARDS, String.valueOf(NUM_SHARDS))\n+            .addProperty(SearchConfig.SHARDING_STRATEGY, SearchConfig.HASH);\n+\n       return builder;\n    }\n \n", "next_change": {"commit": "ab7d55888a70763bdfebc8db5fe2a3d21aa8e0a0", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryDslConditionsTunedTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryDslConditionsTunedTest.java\nindex 05622ff12e..66d9af576a 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryDslConditionsTunedTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryDslConditionsTunedTest.java\n", "chunk": "@@ -45,8 +44,7 @@ protected ConfigurationBuilder getConfigurationBuilder() {\n \n    @Override\n    public void testIndexPresence() {\n-      SearchMapping searchMapping = TestingUtil.extractComponent(cache, SearchMappingHolder.class)\n-            .getSearchMapping();\n+      SearchMapping searchMapping = TestingUtil.extractComponent(cache, SearchMapping.class);\n \n       // we have indexing for remote query!\n       assertTrue(searchMapping.allIndexedTypes().containsValue(ProtobufValueWrapper.class));\n", "next_change": {"commit": "2ac53aac5f05c44ac291d358eda785cbc991f769", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryDslConditionsTunedTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryDslConditionsTunedTest.java\nindex 66d9af576a..a711b5be19 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryDslConditionsTunedTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryDslConditionsTunedTest.java\n", "chunk": "@@ -47,9 +40,11 @@ public void testIndexPresence() {\n       SearchMapping searchMapping = TestingUtil.extractComponent(cache, SearchMapping.class);\n \n       // we have indexing for remote query!\n-      assertTrue(searchMapping.allIndexedTypes().containsValue(ProtobufValueWrapper.class));\n+      assertNotNull(searchMapping.indexedEntity(\"sample_bank_account.User\"));\n+      assertNotNull(searchMapping.indexedEntity(\"sample_bank_account.Account\"));\n+      assertNotNull(searchMapping.indexedEntity(\"sample_bank_account.Transaction\"));\n \n       // we have some indexes for this cache\n-      assertEquals(2, searchMapping.allIndexedTypes().size());\n+      assertEquals(3, searchMapping.allIndexedEntities().size());\n    }\n }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "91d194f1a4e6f6990903ea42094be659142bb4d5", "message": "Merge commit", "committedDate": null}, {"oid": "ab7d55888a70763bdfebc8db5fe2a3d21aa8e0a0", "committedDate": "2020-09-04 10:54:55 +0100", "message": "ISPN-12169 Free some tests from SearchMappingHolder"}, {"oid": "f03aab519c73faeb7ec1b6e0fcdc7290ca2c7978", "committedDate": "2020-11-27 09:44:12 +0100", "message": "ISPN-12464 Update to Hibernate Search 6.0.0.CR1"}, {"oid": "27013524412dd967281110da5edd13d20b956941", "committedDate": "2020-11-27 15:54:21 +0100", "message": "ISPN-11797 Introduce strong typed indexing configuration"}, {"oid": "2ac53aac5f05c44ac291d358eda785cbc991f769", "committedDate": "2020-12-18 12:57:31 +0200", "message": "ISPN-12522 Clean up access to indexed entity metadata from the InfinispanMapping"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc5MTQyNw==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r458791427", "body": "Can you add the indexed entities in the config so that it does not change the test behaviour?", "bodyText": "Can you add the indexed entities in the config so that it does not change the test behaviour?", "bodyHTML": "<p dir=\"auto\">Can you add the indexed entities in the config so that it does not change the test behaviour?</p>", "author": "gustavocoding", "createdAt": "2020-07-22T13:28:50Z", "path": "client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryNonQueryableCacheTest.java", "diffHunk": "@@ -53,18 +54,22 @@ private Configuration createCache(String mediaType) {\n \n    private Configuration createIndexedCache() {\n       ConfigurationBuilder builder = new ConfigurationBuilder();\n-      builder.indexing().enable().addProperty(\"default.directory_provider\", \"local-heap\");\n+      builder.indexing().enable().addProperty(SearchConfig.DIRECTORY_TYPE, SearchConfig.HEAP);\n       return builder.build();\n    }\n \n    @Test\n    public void testQueryable() {\n       executeQuery(DEFAULT_CACHE);\n-      executeQuery(INDEXED_CACHE);\n       executeQuery(PROTOBUF_CACHE);\n       executeQuery(POJO_CACHE);\n    }\n \n+   @Test(expectedExceptions = HotRodClientException.class, expectedExceptionsMessageRegExp = \".*ISPN014054.*\")\n+   public void assertErrorForIndexedCacheButWithoutIndexedEntities() {\n+      executeQuery(INDEXED_CACHE);\n+   }", "originalCommit": "973742666427584064f0529d85af66024e57d0ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk0MjMyMg==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r459942322", "bodyText": "I'll change the configuration to add an indexed protobuf entity, providing its protobuf schema in the serialization context. Doing now..", "author": "fax4ever", "createdAt": "2020-07-24T09:16:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc5MTQyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk0MjgyMQ==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r459942821", "bodyText": "Since that now declaring a protobuf entity without its protobuf schema has no impact...", "author": "fax4ever", "createdAt": "2020-07-24T09:17:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc5MTQyNw=="}], "type": "inlineReview", "revised_code": {"commit": "32718114c38cd1cf83048d759033d952387d0a7e", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryNonQueryableCacheTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryNonQueryableCacheTest.java\nindex 0a309943ab..fb4f1904bc 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryNonQueryableCacheTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryNonQueryableCacheTest.java\n", "chunk": "@@ -54,22 +53,18 @@ private Configuration createCache(String mediaType) {\n \n    private Configuration createIndexedCache() {\n       ConfigurationBuilder builder = new ConfigurationBuilder();\n-      builder.indexing().enable().addProperty(SearchConfig.DIRECTORY_TYPE, SearchConfig.HEAP);\n+      builder.indexing().enable().addProperty(\"default.directory_provider\", \"local-heap\");\n       return builder.build();\n    }\n \n    @Test\n    public void testQueryable() {\n       executeQuery(DEFAULT_CACHE);\n+      executeQuery(INDEXED_CACHE);\n       executeQuery(PROTOBUF_CACHE);\n       executeQuery(POJO_CACHE);\n    }\n \n-   @Test(expectedExceptions = HotRodClientException.class, expectedExceptionsMessageRegExp = \".*ISPN014054.*\")\n-   public void assertErrorForIndexedCacheButWithoutIndexedEntities() {\n-      executeQuery(INDEXED_CACHE);\n-   }\n-\n    @Test(expectedExceptions = HotRodClientException.class, expectedExceptionsMessageRegExp = \".*ISPN028015.*\")\n    public void assertErrorForCacheWithoutNonQueryableEncoding() {\n       executeQuery(JSON_CACHE);\n", "next_change": {"commit": "bb18590bbe7e5e9948bca940518235678d1a4fae", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryNonQueryableCacheTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryNonQueryableCacheTest.java\nindex fb4f1904bc..0a309943ab 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryNonQueryableCacheTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryNonQueryableCacheTest.java\n", "chunk": "@@ -53,18 +54,22 @@ private Configuration createCache(String mediaType) {\n \n    private Configuration createIndexedCache() {\n       ConfigurationBuilder builder = new ConfigurationBuilder();\n-      builder.indexing().enable().addProperty(\"default.directory_provider\", \"local-heap\");\n+      builder.indexing().enable().addProperty(SearchConfig.DIRECTORY_TYPE, SearchConfig.HEAP);\n       return builder.build();\n    }\n \n    @Test\n    public void testQueryable() {\n       executeQuery(DEFAULT_CACHE);\n-      executeQuery(INDEXED_CACHE);\n       executeQuery(PROTOBUF_CACHE);\n       executeQuery(POJO_CACHE);\n    }\n \n+   @Test(expectedExceptions = HotRodClientException.class, expectedExceptionsMessageRegExp = \".*ISPN014054.*\")\n+   public void assertErrorForIndexedCacheButWithoutIndexedEntities() {\n+      executeQuery(INDEXED_CACHE);\n+   }\n+\n    @Test(expectedExceptions = HotRodClientException.class, expectedExceptionsMessageRegExp = \".*ISPN028015.*\")\n    public void assertErrorForCacheWithoutNonQueryableEncoding() {\n       executeQuery(JSON_CACHE);\n", "next_change": {"commit": "b76eeeee768bb075a447e35324baa3d6986830f1", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryNonQueryableCacheTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryNonQueryableCacheTest.java\nindex 0a309943ab..fb4f1904bc 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryNonQueryableCacheTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryNonQueryableCacheTest.java\n", "chunk": "@@ -54,22 +53,18 @@ private Configuration createCache(String mediaType) {\n \n    private Configuration createIndexedCache() {\n       ConfigurationBuilder builder = new ConfigurationBuilder();\n-      builder.indexing().enable().addProperty(SearchConfig.DIRECTORY_TYPE, SearchConfig.HEAP);\n+      builder.indexing().enable().addProperty(\"default.directory_provider\", \"local-heap\");\n       return builder.build();\n    }\n \n    @Test\n    public void testQueryable() {\n       executeQuery(DEFAULT_CACHE);\n+      executeQuery(INDEXED_CACHE);\n       executeQuery(PROTOBUF_CACHE);\n       executeQuery(POJO_CACHE);\n    }\n \n-   @Test(expectedExceptions = HotRodClientException.class, expectedExceptionsMessageRegExp = \".*ISPN014054.*\")\n-   public void assertErrorForIndexedCacheButWithoutIndexedEntities() {\n-      executeQuery(INDEXED_CACHE);\n-   }\n-\n    @Test(expectedExceptions = HotRodClientException.class, expectedExceptionsMessageRegExp = \".*ISPN028015.*\")\n    public void assertErrorForCacheWithoutNonQueryableEncoding() {\n       executeQuery(JSON_CACHE);\n", "next_change": {"commit": "917da575b1ba55b0147d9cbeb1e553e3b24fc837", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryNonQueryableCacheTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryNonQueryableCacheTest.java\nindex fb4f1904bc..d99b4ff73a 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryNonQueryableCacheTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryNonQueryableCacheTest.java\n", "chunk": "@@ -71,9 +77,8 @@ public void assertErrorForCacheWithoutNonQueryableEncoding() {\n    }\n \n    private void executeQuery(String cacheName) {\n-      RemoteCache<String, Person> remoteCache = remoteCacheManager.getCache(cacheName);\n-      remoteCache.put(\"1\", new Person(\"John\"));\n-      Query<Person> q = Search.getQueryFactory(remoteCache).create(\"FROM org.infinispan.test.core.Person\");\n+      RemoteCache<String, User> remoteCache = remoteCacheManager.getCache(cacheName);\n+      Query<User> q = Search.getQueryFactory(remoteCache).create(\"FROM sample_bank_account.User\");\n       q.execute();\n    }\n }\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "91d194f1a4e6f6990903ea42094be659142bb4d5", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryNonQueryableCacheTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryNonQueryableCacheTest.java\nindex 0a309943ab..d99b4ff73a 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryNonQueryableCacheTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryNonQueryableCacheTest.java\n", "chunk": "@@ -54,31 +55,30 @@ private Configuration createCache(String mediaType) {\n \n    private Configuration createIndexedCache() {\n       ConfigurationBuilder builder = new ConfigurationBuilder();\n-      builder.indexing().enable().addProperty(SearchConfig.DIRECTORY_TYPE, SearchConfig.HEAP);\n+      builder.indexing().enable()\n+            .addIndexedEntity(\"sample_bank_account.User\")\n+            .addIndexedEntity(\"sample_bank_account.Account\")\n+            .addIndexedEntity(\"sample_bank_account.Transaction\")\n+            .addProperty(SearchConfig.DIRECTORY_TYPE, SearchConfig.HEAP);\n       return builder.build();\n    }\n \n    @Test\n    public void testQueryable() {\n       executeQuery(DEFAULT_CACHE);\n+      executeQuery(INDEXED_CACHE);\n       executeQuery(PROTOBUF_CACHE);\n       executeQuery(POJO_CACHE);\n    }\n \n-   @Test(expectedExceptions = HotRodClientException.class, expectedExceptionsMessageRegExp = \".*ISPN014054.*\")\n-   public void assertErrorForIndexedCacheButWithoutIndexedEntities() {\n-      executeQuery(INDEXED_CACHE);\n-   }\n-\n    @Test(expectedExceptions = HotRodClientException.class, expectedExceptionsMessageRegExp = \".*ISPN028015.*\")\n    public void assertErrorForCacheWithoutNonQueryableEncoding() {\n       executeQuery(JSON_CACHE);\n    }\n \n    private void executeQuery(String cacheName) {\n-      RemoteCache<String, Person> remoteCache = remoteCacheManager.getCache(cacheName);\n-      remoteCache.put(\"1\", new Person(\"John\"));\n-      Query<Person> q = Search.getQueryFactory(remoteCache).create(\"FROM org.infinispan.test.core.Person\");\n+      RemoteCache<String, User> remoteCache = remoteCacheManager.getCache(cacheName);\n+      Query<User> q = Search.getQueryFactory(remoteCache).create(\"FROM sample_bank_account.User\");\n       q.execute();\n    }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "91d194f1a4e6f6990903ea42094be659142bb4d5", "message": "Merge commit", "committedDate": null}, {"oid": "27013524412dd967281110da5edd13d20b956941", "committedDate": "2020-11-27 15:54:21 +0100", "message": "ISPN-11797 Introduce strong typed indexing configuration"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc5MzQ5Nw==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r458793497", "body": "Could you clarify what is this about? What do you mean \"one change of serialization context\" ? ", "bodyText": "Could you clarify what is this about? What do you mean \"one change of serialization context\" ?", "bodyHTML": "<p dir=\"auto\">Could you clarify what is this about? What do you mean \"one change of serialization context\" ?</p>", "author": "gustavocoding", "createdAt": "2020-07-22T13:31:54Z", "path": "client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryWithProtostreamAnnotationsTest.java", "diffHunk": "@@ -31,7 +31,9 @@\n  *\n  * @author Adrian Nistor\n  */\n-@Test(testName = \"client.hotrod.query.RemoteQueryWithProtostreamAnnotationsTest\", groups = \"functional\")\n+// TODO Hibernate Search 6 cannot handle more than one change of serialization context", "originalCommit": "973742666427584064f0529d85af66024e57d0ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQxOTAxNw==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r459419017", "bodyText": "@gustavonalle now that lifecycle has been changed so that all the protobuf entities are in the serialization context when the cache is starting, we don't need the skip and this comment anymore. Removing it now the test passes, so I'm removing it.", "author": "fax4ever", "createdAt": "2020-07-23T12:42:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc5MzQ5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "6300e5d5e53a1e59b9349292cdc7d87ce9d476da", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryWithProtostreamAnnotationsTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryWithProtostreamAnnotationsTest.java\nindex af00baf306..9d41affb11 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryWithProtostreamAnnotationsTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryWithProtostreamAnnotationsTest.java\n", "chunk": "@@ -31,9 +31,7 @@\n  *\n  * @author Adrian Nistor\n  */\n-// TODO Hibernate Search 6 cannot handle more than one change of serialization context\n-@Test(testName = \"client.hotrod.query.RemoteQueryWithProtostreamAnnotationsTest\", groups = \"functional\",\n-enabled = false)\n+@Test(testName = \"client.hotrod.query.RemoteQueryWithProtostreamAnnotationsTest\", groups = \"functional\")\n public class RemoteQueryWithProtostreamAnnotationsTest extends SingleHotRodServerTest {\n \n    @ProtoDoc(\"@Indexed\")\n", "next_change": null}]}, "revised_code_in_main": {"commit": "91d194f1a4e6f6990903ea42094be659142bb4d5", "changed_code": [{"header": "diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryWithProtostreamAnnotationsTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryWithProtostreamAnnotationsTest.java\nindex af00baf306..9d41affb11 100644\n--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryWithProtostreamAnnotationsTest.java\n+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/RemoteQueryWithProtostreamAnnotationsTest.java\n", "chunk": "@@ -31,9 +31,7 @@\n  *\n  * @author Adrian Nistor\n  */\n-// TODO Hibernate Search 6 cannot handle more than one change of serialization context\n-@Test(testName = \"client.hotrod.query.RemoteQueryWithProtostreamAnnotationsTest\", groups = \"functional\",\n-enabled = false)\n+@Test(testName = \"client.hotrod.query.RemoteQueryWithProtostreamAnnotationsTest\", groups = \"functional\")\n public class RemoteQueryWithProtostreamAnnotationsTest extends SingleHotRodServerTest {\n \n    @ProtoDoc(\"@Indexed\")\n", "next_change": null}]}, "commits_in_main": [{"oid": "91d194f1a4e6f6990903ea42094be659142bb4d5", "message": "Merge commit", "committedDate": null}, {"oid": "7cef33db4090cd147079bdd6e57010fb0098df2e", "committedDate": "2020-10-29 13:10:55 +0000", "message": "ISPN-12441 Tests cleanup"}, {"oid": "27013524412dd967281110da5edd13d20b956941", "committedDate": "2020-11-27 15:54:21 +0100", "message": "ISPN-11797 Introduce strong typed indexing configuration"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgwMTM3Mw==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r458801373", "body": "This concept of refresh was not part of HSearch 5, what does it do? Could you add some javadoc? If it's something IndexWriter related, I prefer this to be on ```org.infinispan.query.Indexer```", "bodyText": "This concept of refresh was not part of HSearch 5, what does it do? Could you add some javadoc? If it's something IndexWriter related, I prefer this to be on org.infinispan.query.Indexer", "bodyHTML": "<p dir=\"auto\">This concept of refresh was not part of HSearch 5, what does it do? Could you add some javadoc? If it's something IndexWriter related, I prefer this to be on <code>org.infinispan.query.Indexer</code></p>", "author": "gustavocoding", "createdAt": "2020-07-22T13:43:06Z", "path": "query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java", "diffHunk": "@@ -322,69 +314,66 @@ public Object visitReadWriteManyEntriesCommand(InvocationContext ctx, ReadWriteM\n     * Remove all entries from all known indexes\n     */\n    public void purgeAllIndexes() {\n-      purgeAllIndexes(NoTransactionContext.INSTANCE);\n+      SearchMapping searchMapping = searchMappingHolder.getSearchMapping();\n+      if (searchMapping == null) {\n+         return;\n+      }\n+\n+      searchMapping.scopeAll().workspace().purge();\n    }\n \n    public void purgeIndex(Class<?> entityType) {\n-      purgeIndex(NoTransactionContext.INSTANCE, entityType);\n+      SearchMapping searchMapping = searchMappingHolder.getSearchMapping();\n+      if (searchMapping == null) {\n+         return;\n+      }\n+\n+      searchMapping.scope(entityType).workspace().purge();\n+   }\n+\n+   public void refreshIndex(Class<?> entityType) {\n+      SearchMapping searchMapping = searchMappingHolder.getSearchMapping();", "originalCommit": "973742666427584064f0529d85af66024e57d0ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODg0MzkzNA==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r458843934", "bodyText": "Refresh will create new index readers. This is mostly only relevant if you tell Hibernate Search to reuse out-of-date index readers by setting hibernate.search.backends.myBackend.index_defaults.io.refresh_interval to something higher than 0.\nSee https://docs.jboss.org/hibernate/search/6.0/reference/en-US/html_single/#backend-lucene-io-refresh", "author": "yrodiere", "createdAt": "2020-07-22T14:40:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgwMTM3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ1NzA2Mw==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r459457063", "bodyText": "Yes the method was in the wrong place, I removed it.", "author": "fax4ever", "createdAt": "2020-07-23T13:41:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgwMTM3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "6300e5d5e53a1e59b9349292cdc7d87ce9d476da", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java b/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java\nindex 50cb7053ab..2aebd6287b 100644\n--- a/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java\n+++ b/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java\n", "chunk": "@@ -331,15 +331,6 @@ public void purgeIndex(Class<?> entityType) {\n       searchMapping.scope(entityType).workspace().purge();\n    }\n \n-   public void refreshIndex(Class<?> entityType) {\n-      SearchMapping searchMapping = searchMappingHolder.getSearchMapping();\n-      if (searchMapping == null) {\n-         return;\n-      }\n-\n-      searchMapping.scope(entityType).workspace().refresh();\n-   }\n-\n    /**\n     * Removes from the index the entries corresponding to the supplied segments, if the index is local.\n     */\n", "next_change": {"commit": "32718114c38cd1cf83048d759033d952387d0a7e", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java b/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java\nindex 2aebd6287b..6d427c8a56 100644\n--- a/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java\n+++ b/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java\n", "chunk": "@@ -314,57 +322,69 @@ public Object visitReadWriteManyEntriesCommand(InvocationContext ctx, ReadWriteM\n     * Remove all entries from all known indexes\n     */\n    public void purgeAllIndexes() {\n-      SearchMapping searchMapping = searchMappingHolder.getSearchMapping();\n-      if (searchMapping == null) {\n-         return;\n-      }\n-\n-      searchMapping.scopeAll().workspace().purge();\n+      purgeAllIndexes(NoTransactionContext.INSTANCE);\n    }\n \n    public void purgeIndex(Class<?> entityType) {\n-      SearchMapping searchMapping = searchMappingHolder.getSearchMapping();\n-      if (searchMapping == null) {\n-         return;\n-      }\n-\n-      searchMapping.scope(entityType).workspace().purge();\n+      purgeIndex(NoTransactionContext.INSTANCE, entityType);\n    }\n \n    /**\n     * Removes from the index the entries corresponding to the supplied segments, if the index is local.\n     */\n    void purgeIndex(IntSet segments) {\n-      if (segments == null || segments.isEmpty()) return;\n-\n-      SearchMapping searchMapping = searchMappingHolder.getSearchMapping();\n-      if (searchMapping == null) {\n-         return;\n+      if (segments == null) return;\n+      for (int segment : segments) {\n+         DeletionQuery deletionQuery = new SingularTermDeletionQuery(SEGMENT_FIELD, String.valueOf(segment));\n+         for (IndexedTypeIdentifier type : searchFactory.getIndexBindings().keySet()) {\n+            Work deleteWork = new DeleteByQueryWork(type, deletionQuery);\n+            performSearchWork(deleteWork, NoTransactionContext.INSTANCE);\n+         }\n       }\n-\n-      Set<String> routingKeys = segments.intStream().boxed().map(Objects::toString).collect(Collectors.toSet());\n-      searchMapping.scopeAll().workspace().purge(routingKeys);\n    }\n \n    /**\n     * Remove entries from all indexes by key.\n     */\n-   void removeFromIndexes(Object key, int segment) {\n-      Futures.unwrappedExceptionJoin(getSearchIndexer().purge(keyToString(key, segment), segment+\"\"));\n+   void removeFromIndexes(TransactionContext transactionContext, Object key, int segment) {\n+      for (IndexedTypeIdentifier type : searchFactory.getIndexBindings().keySet()) {\n+         performSearchWork(searchWorkCreator.createPerEntityWork(keyToString(key, segment), type, WorkType.DELETE), transactionContext);\n+      }\n+   }\n+\n+   private void purgeIndex(TransactionContext transactionContext, Class<?> entityType) {\n+      IndexedTypeIdentifier type = new PojoIndexedTypeIdentifier(entityType);\n+      if (searchFactory.getIndexBindings().containsKey(type)) {\n+         performSearchWork(searchWorkCreator.createPerEntityTypeWork(type, WorkType.PURGE_ALL), transactionContext);\n+      }\n+   }\n+\n+   private void purgeAllIndexes(TransactionContext transactionContext) {\n+      for (IndexedTypeIdentifier type : searchFactory.getIndexBindings().keySet()) {\n+         performSearchWork(searchWorkCreator.createPerEntityTypeWork(type, WorkType.PURGE_ALL), transactionContext);\n+      }\n    }\n \n    // Method that will be called when data needs to be removed from Lucene.\n-   private void removeFromIndexes(Object value, Object key, int segment) {\n-      Futures.unwrappedExceptionJoin(getSearchIndexer().delete(keyToString(key, segment), value));\n+   private void removeFromIndexes(Object value, Object key, TransactionContext transactionContext, int segment) {\n+      performSearchWork(value, keyToString(key, segment), WorkType.DELETE, transactionContext);\n    }\n \n-   private void updateIndexes(boolean usingSkipIndexCleanupFlag, Object value, Object key, int segment) {\n+   private void updateIndexes(boolean usingSkipIndexCleanupFlag, Object value, Object key, TransactionContext transactionContext, int segment) {\n       // Note: it's generally unsafe to assume there is no previous entry to cleanup: always use UPDATE\n       // unless the specific flag is allowing this.\n-      if (usingSkipIndexCleanupFlag) {\n-         Futures.unwrappedExceptionJoin(getSearchIndexer().add(keyToString(key, segment), value));\n-      } else {\n-         Futures.unwrappedExceptionJoin(getSearchIndexer().addOrUpdate(keyToString(key, segment), value));\n+      performSearchWork(value, keyToString(key, segment), usingSkipIndexCleanupFlag ? WorkType.ADD : WorkType.UPDATE, transactionContext);\n+   }\n+\n+   private void performSearchWork(Object value, Serializable id, WorkType workType, TransactionContext transactionContext) {\n+      if (value == null) throw new NullPointerException(\"Cannot handle a null value!\");\n+      performSearchWork(searchWorkCreator.createPerEntityWork(value, id, workType), transactionContext);\n+   }\n+\n+   private void performSearchWork(Work work, TransactionContext transactionContext) {\n+      if (work != null) {\n+         Worker worker = searchFactory.getWorker();\n+         worker.performWork(work, transactionContext);\n       }\n    }\n \n", "next_change": {"commit": "bb18590bbe7e5e9948bca940518235678d1a4fae", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java b/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java\nindex 6d427c8a56..ea7dfc518b 100644\n--- a/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java\n+++ b/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java\n", "chunk": "@@ -322,69 +314,57 @@ public Object visitReadWriteManyEntriesCommand(InvocationContext ctx, ReadWriteM\n     * Remove all entries from all known indexes\n     */\n    public void purgeAllIndexes() {\n-      purgeAllIndexes(NoTransactionContext.INSTANCE);\n+      SearchMapping searchMapping = searchMappingHolder.getSearchMapping();\n+      if (searchMapping == null) {\n+         return;\n+      }\n+\n+      searchMapping.scopeAll().workspace().purge();\n    }\n \n    public void purgeIndex(Class<?> entityType) {\n-      purgeIndex(NoTransactionContext.INSTANCE, entityType);\n+      SearchMapping searchMapping = searchMappingHolder.getSearchMapping();\n+      if (searchMapping == null) {\n+         return;\n+      }\n+\n+      searchMapping.scope(entityType).workspace().purge();\n    }\n \n    /**\n     * Removes from the index the entries corresponding to the supplied segments, if the index is local.\n     */\n    void purgeIndex(IntSet segments) {\n-      if (segments == null) return;\n-      for (int segment : segments) {\n-         DeletionQuery deletionQuery = new SingularTermDeletionQuery(SEGMENT_FIELD, String.valueOf(segment));\n-         for (IndexedTypeIdentifier type : searchFactory.getIndexBindings().keySet()) {\n-            Work deleteWork = new DeleteByQueryWork(type, deletionQuery);\n-            performSearchWork(deleteWork, NoTransactionContext.INSTANCE);\n-         }\n+      if (segments == null || segments.isEmpty()) return;\n+\n+      SearchMapping searchMapping = searchMappingHolder.getSearchMapping();\n+      if (searchMapping == null) {\n+         return;\n       }\n+\n+      Set<String> routingKeys = segments.intStream().boxed().map(Objects::toString).collect(Collectors.toSet());\n+      searchMapping.scopeAll().workspace().purge(routingKeys);\n    }\n \n    /**\n     * Remove entries from all indexes by key.\n     */\n-   void removeFromIndexes(TransactionContext transactionContext, Object key, int segment) {\n-      for (IndexedTypeIdentifier type : searchFactory.getIndexBindings().keySet()) {\n-         performSearchWork(searchWorkCreator.createPerEntityWork(keyToString(key, segment), type, WorkType.DELETE), transactionContext);\n-      }\n-   }\n-\n-   private void purgeIndex(TransactionContext transactionContext, Class<?> entityType) {\n-      IndexedTypeIdentifier type = new PojoIndexedTypeIdentifier(entityType);\n-      if (searchFactory.getIndexBindings().containsKey(type)) {\n-         performSearchWork(searchWorkCreator.createPerEntityTypeWork(type, WorkType.PURGE_ALL), transactionContext);\n-      }\n-   }\n-\n-   private void purgeAllIndexes(TransactionContext transactionContext) {\n-      for (IndexedTypeIdentifier type : searchFactory.getIndexBindings().keySet()) {\n-         performSearchWork(searchWorkCreator.createPerEntityTypeWork(type, WorkType.PURGE_ALL), transactionContext);\n-      }\n+   void removeFromIndexes(Object key, int segment) {\n+      Futures.unwrappedExceptionJoin(getSearchIndexer().purge(keyToString(key, segment), segment+\"\"));\n    }\n \n    // Method that will be called when data needs to be removed from Lucene.\n-   private void removeFromIndexes(Object value, Object key, TransactionContext transactionContext, int segment) {\n-      performSearchWork(value, keyToString(key, segment), WorkType.DELETE, transactionContext);\n+   private void removeFromIndexes(Object value, Object key, int segment) {\n+      Futures.unwrappedExceptionJoin(getSearchIndexer().delete(keyToString(key, segment), value));\n    }\n \n-   private void updateIndexes(boolean usingSkipIndexCleanupFlag, Object value, Object key, TransactionContext transactionContext, int segment) {\n+   private void updateIndexes(boolean usingSkipIndexCleanupFlag, Object value, Object key, int segment) {\n       // Note: it's generally unsafe to assume there is no previous entry to cleanup: always use UPDATE\n       // unless the specific flag is allowing this.\n-      performSearchWork(value, keyToString(key, segment), usingSkipIndexCleanupFlag ? WorkType.ADD : WorkType.UPDATE, transactionContext);\n-   }\n-\n-   private void performSearchWork(Object value, Serializable id, WorkType workType, TransactionContext transactionContext) {\n-      if (value == null) throw new NullPointerException(\"Cannot handle a null value!\");\n-      performSearchWork(searchWorkCreator.createPerEntityWork(value, id, workType), transactionContext);\n-   }\n-\n-   private void performSearchWork(Work work, TransactionContext transactionContext) {\n-      if (work != null) {\n-         Worker worker = searchFactory.getWorker();\n-         worker.performWork(work, transactionContext);\n+      if (usingSkipIndexCleanupFlag) {\n+         Futures.unwrappedExceptionJoin(getSearchIndexer().add(keyToString(key, segment), value));\n+      } else {\n+         Futures.unwrappedExceptionJoin(getSearchIndexer().addOrUpdate(keyToString(key, segment), value));\n       }\n    }\n \n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "91d194f1a4e6f6990903ea42094be659142bb4d5", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java b/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java\nindex 50cb7053ab..ea7dfc518b 100644\n--- a/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java\n+++ b/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java\n", "chunk": "@@ -331,15 +331,6 @@ public void purgeIndex(Class<?> entityType) {\n       searchMapping.scope(entityType).workspace().purge();\n    }\n \n-   public void refreshIndex(Class<?> entityType) {\n-      SearchMapping searchMapping = searchMappingHolder.getSearchMapping();\n-      if (searchMapping == null) {\n-         return;\n-      }\n-\n-      searchMapping.scope(entityType).workspace().refresh();\n-   }\n-\n    /**\n     * Removes from the index the entries corresponding to the supplied segments, if the index is local.\n     */\n", "next_change": {"commit": "fd7203a0b2c24ddf8eeb5521730a097892ca4816", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java b/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java\nindex ea7dfc518b..9c125b45f7 100644\n--- a/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java\n+++ b/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java\n", "chunk": "@@ -335,10 +326,7 @@ public void purgeIndex(Class<?> entityType) {\n     * Removes from the index the entries corresponding to the supplied segments, if the index is local.\n     */\n    void purgeIndex(IntSet segments) {\n-      if (segments == null || segments.isEmpty()) return;\n-\n-      SearchMapping searchMapping = searchMappingHolder.getSearchMapping();\n-      if (searchMapping == null) {\n+      if (segments == null || segments.isEmpty() || searchMapping == null) {\n          return;\n       }\n \n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "91d194f1a4e6f6990903ea42094be659142bb4d5", "message": "Merge commit", "committedDate": null}, {"oid": "43f494989cf91d79cb2c70ab7bbe0f756ffc67b4", "committedDate": "2020-08-02 23:26:31 -0400", "message": "ISPN-12178 Query broadcast blocks on the non-blocking executor"}, {"oid": "5d0bf286d76bda64ddb918ec31872ea9f54070d6", "committedDate": "2020-08-02 23:26:31 -0400", "message": "ISPN-12178 Remove unused fields and parameters"}, {"oid": "1770a64871ec7e148ca71ab19c8024142c7bcd34", "committedDate": "2020-08-12 21:48:59 +0300", "message": "ISPN-12186 Update to Hibernate Search 6.0.0.Beta9"}, {"oid": "c68c255f3b81dfcb71a25051b38be94700ad5ef5", "committedDate": "2020-08-17 12:24:55 -0400", "message": "ISPN-11731 Add blockhound to query module"}, {"oid": "fd7203a0b2c24ddf8eeb5521730a097892ca4816", "committedDate": "2020-09-04 10:54:55 +0100", "message": "ISPN-12169 Free QueryInterceptor from SearchMappingHolder"}, {"oid": "2d53d0a1e59f2dc3335235f9dafb8e93e611c60e", "committedDate": "2020-09-07 11:44:18 +0100", "message": "ISPN-11802 Create SPI for Cross-Site Replication conflict resolution"}, {"oid": "0753647c23d47fd1f035473b94d182c6da84e701", "committedDate": "2020-12-14 17:38:18 +0200", "message": "ISPN-12469 Do not cache trace level statically"}, {"oid": "7206596b4a0258d0b8f1a20d78259e7f270a81ec", "committedDate": "2020-12-14 17:38:18 +0200", "message": "ISPN-12469 Don't cache isTraceEnabled/isDebugEnabled calls"}, {"oid": "41e1f86ccc4e892b95cee3984de157b395eca9ca", "committedDate": "2020-12-18 12:57:31 +0200", "message": "ISPN-12522 Leverage Hibernate Search's identifier conversion mechanics to convert keys"}, {"oid": "2ac53aac5f05c44ac291d358eda785cbc991f769", "committedDate": "2020-12-18 12:57:31 +0200", "message": "ISPN-12522 Clean up access to indexed entity metadata from the InfinispanMapping"}, {"oid": "128874af7ab7204db85bb1ea1ed8248b3828ffdd", "committedDate": "2021-03-31 17:17:49 +0100", "message": "ISPN-11299 Stale values can be indexed during State Transfer"}, {"oid": "7b9bbb3e90b2e5110b814efa3af88417d2d21765", "committedDate": "2021-05-03 09:32:12 +0200", "message": "ISPN-12994 Cache and indexes can become out of sync when indexing operation fails"}, {"oid": "e9f942add8fe6277df69bf853271251e4a51c2b8", "committedDate": "2021-06-24 10:28:45 +0200", "message": "ISPN-13101 Replace assertion"}, {"oid": "91d75550738b5d681c74113f7e6832cfc1142623", "committedDate": "2021-08-30 10:29:59 +0100", "message": "ISPN-12881 Support for adding stores dynamically"}, {"oid": "1f3a15c455dacd3d788eab3f3109239492f1e675", "committedDate": "2022-04-01 13:31:34 -0400", "message": "ISPN-13792 Non-blocking transaction commit/rollback"}, {"oid": "7bd0ed0b68eaa48b8b6e15496316da54914cc895", "committedDate": "2022-05-25 09:16:04 +0200", "message": "ISPN-13648 Schema evolution with respect to indices without downtime (#10114)"}, {"oid": "777bcb90ffc7882062caca503c385bc4cd84e0b7", "committedDate": "2022-09-08 09:47:40 +0200", "message": "ISPN-14115 Rename the should remove method"}, {"oid": "fb5fe86ebc7a462ddbfda6940e7fe0755b777af0", "committedDate": "2022-09-08 09:47:40 +0200", "message": "ISPN-14115 Fix deadlock in index writer threads under heavy load"}, {"oid": "f5a9f7f3ba7f00bc6bbcfe2856f282cfd62f604a", "committedDate": "2023-03-28 13:43:27 -0400", "message": "ISPN-14483 Set log indexing operations to trace"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgwMzg1NA==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r458803854", "body": "I've seen this check in many places, in which scenarios it can be null? On master, the QueryInterceptor is only installed if the cache is indexed, and if it is, the ```SearchFactory``` was never null. ", "bodyText": "I've seen this check in many places, in which scenarios it can be null? On master, the QueryInterceptor is only installed if the cache is indexed, and if it is, the SearchFactory was never null.", "bodyHTML": "<p dir=\"auto\">I've seen this check in many places, in which scenarios it can be null? On master, the QueryInterceptor is only installed if the cache is indexed, and if it is, the <code>SearchFactory</code> was never null.</p>", "author": "gustavocoding", "createdAt": "2020-07-22T13:46:24Z", "path": "query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java", "diffHunk": "@@ -322,69 +314,66 @@ public Object visitReadWriteManyEntriesCommand(InvocationContext ctx, ReadWriteM\n     * Remove all entries from all known indexes\n     */\n    public void purgeAllIndexes() {\n-      purgeAllIndexes(NoTransactionContext.INSTANCE);\n+      SearchMapping searchMapping = searchMappingHolder.getSearchMapping();\n+      if (searchMapping == null) {\n+         return;\n+      }\n+\n+      searchMapping.scopeAll().workspace().purge();\n    }\n \n    public void purgeIndex(Class<?> entityType) {\n-      purgeIndex(NoTransactionContext.INSTANCE, entityType);\n+      SearchMapping searchMapping = searchMappingHolder.getSearchMapping();\n+      if (searchMapping == null) {\n+         return;\n+      }\n+\n+      searchMapping.scope(entityType).workspace().purge();\n+   }\n+\n+   public void refreshIndex(Class<?> entityType) {\n+      SearchMapping searchMapping = searchMappingHolder.getSearchMapping();\n+      if (searchMapping == null) {\n+         return;\n+      }\n+\n+      searchMapping.scope(entityType).workspace().refresh();\n    }\n \n    /**\n     * Removes from the index the entries corresponding to the supplied segments, if the index is local.\n     */\n    void purgeIndex(IntSet segments) {\n-      if (segments == null) return;\n-      for (int segment : segments) {\n-         DeletionQuery deletionQuery = new SingularTermDeletionQuery(SEGMENT_FIELD, String.valueOf(segment));\n-         for (IndexedTypeIdentifier type : searchFactory.getIndexBindings().keySet()) {\n-            Work deleteWork = new DeleteByQueryWork(type, deletionQuery);\n-            performSearchWork(deleteWork, NoTransactionContext.INSTANCE);\n-         }\n+      if (segments == null || segments.isEmpty()) return;\n+\n+      SearchMapping searchMapping = searchMappingHolder.getSearchMapping();\n+      if (searchMapping == null) {", "originalCommit": "973742666427584064f0529d85af66024e57d0ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ2MDAzMg==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r459460032", "bodyText": "There was for the same reason of #8571 (comment).\nGoing to remove these checks...\nMoreover, probably thanks to #8575 we can get rid of the entire SearchMappingHolder class, but maybe this could be a follow up. What do you think about that? Thanks", "author": "fax4ever", "createdAt": "2020-07-23T13:45:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgwMzg1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTkyMDM2Mg==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r459920362", "bodyText": "Looking deeper at the issue, I think that we should keep these null checks or change the way we handle the case where we declare a cache as indexed but we don't provide any entity in the indexedEntities configuration.\nBasically, if we remove these checks, we will have these three tests not working:\n\nContinuousQueryObjectStorageTest\nDataFormatIndexedTest\nClientListenerWithDslFilterObjectStorageTest\n\nIn all these cases we configure the cache in this way:\ncfgBuilder.indexing().enable()\n            .addProperty(\"directory.type\", \"local-heap\");\nThe cache is indexed but we don\u2019t provide any indexed entity in the configuration.\nI think that it would be the same if we defined some entities, but all of them were not contained in the serialization context at the time of cache starting.\nWithout the check we will get a null pointer exception locally, that will produce a timeout exception remotely.\nThe issue seems to be bound to the methods:\n\nQueryInterceptor#purgeAllIndexes\nQueryInterceptor#purgeIndex by segment\n\nTo be honest, I have no idea why a purge could be invoked on an indexed cache without no entities. Can you help me with that? Thanks", "author": "fax4ever", "createdAt": "2020-07-24T08:30:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgwMzg1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk0MTIzOA==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r459941238", "bodyText": "Let's just handle it in a follow up", "author": "gustavonalle", "createdAt": "2020-07-24T09:14:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgwMzg1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk0MzM0Nw==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r459943347", "bodyText": "Let's assume indexedEntities will always have at least 1 declared entity starting with ispn 12", "author": "anistor", "createdAt": "2020-07-24T09:19:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgwMzg1NA=="}], "type": "inlineReview", "revised_code": {"commit": "6300e5d5e53a1e59b9349292cdc7d87ce9d476da", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java b/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java\nindex 50cb7053ab..2aebd6287b 100644\n--- a/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java\n+++ b/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java\n", "chunk": "@@ -331,15 +331,6 @@ public void purgeIndex(Class<?> entityType) {\n       searchMapping.scope(entityType).workspace().purge();\n    }\n \n-   public void refreshIndex(Class<?> entityType) {\n-      SearchMapping searchMapping = searchMappingHolder.getSearchMapping();\n-      if (searchMapping == null) {\n-         return;\n-      }\n-\n-      searchMapping.scope(entityType).workspace().refresh();\n-   }\n-\n    /**\n     * Removes from the index the entries corresponding to the supplied segments, if the index is local.\n     */\n", "next_change": {"commit": "32718114c38cd1cf83048d759033d952387d0a7e", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java b/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java\nindex 2aebd6287b..6d427c8a56 100644\n--- a/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java\n+++ b/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java\n", "chunk": "@@ -314,57 +322,69 @@ public Object visitReadWriteManyEntriesCommand(InvocationContext ctx, ReadWriteM\n     * Remove all entries from all known indexes\n     */\n    public void purgeAllIndexes() {\n-      SearchMapping searchMapping = searchMappingHolder.getSearchMapping();\n-      if (searchMapping == null) {\n-         return;\n-      }\n-\n-      searchMapping.scopeAll().workspace().purge();\n+      purgeAllIndexes(NoTransactionContext.INSTANCE);\n    }\n \n    public void purgeIndex(Class<?> entityType) {\n-      SearchMapping searchMapping = searchMappingHolder.getSearchMapping();\n-      if (searchMapping == null) {\n-         return;\n-      }\n-\n-      searchMapping.scope(entityType).workspace().purge();\n+      purgeIndex(NoTransactionContext.INSTANCE, entityType);\n    }\n \n    /**\n     * Removes from the index the entries corresponding to the supplied segments, if the index is local.\n     */\n    void purgeIndex(IntSet segments) {\n-      if (segments == null || segments.isEmpty()) return;\n-\n-      SearchMapping searchMapping = searchMappingHolder.getSearchMapping();\n-      if (searchMapping == null) {\n-         return;\n+      if (segments == null) return;\n+      for (int segment : segments) {\n+         DeletionQuery deletionQuery = new SingularTermDeletionQuery(SEGMENT_FIELD, String.valueOf(segment));\n+         for (IndexedTypeIdentifier type : searchFactory.getIndexBindings().keySet()) {\n+            Work deleteWork = new DeleteByQueryWork(type, deletionQuery);\n+            performSearchWork(deleteWork, NoTransactionContext.INSTANCE);\n+         }\n       }\n-\n-      Set<String> routingKeys = segments.intStream().boxed().map(Objects::toString).collect(Collectors.toSet());\n-      searchMapping.scopeAll().workspace().purge(routingKeys);\n    }\n \n    /**\n     * Remove entries from all indexes by key.\n     */\n-   void removeFromIndexes(Object key, int segment) {\n-      Futures.unwrappedExceptionJoin(getSearchIndexer().purge(keyToString(key, segment), segment+\"\"));\n+   void removeFromIndexes(TransactionContext transactionContext, Object key, int segment) {\n+      for (IndexedTypeIdentifier type : searchFactory.getIndexBindings().keySet()) {\n+         performSearchWork(searchWorkCreator.createPerEntityWork(keyToString(key, segment), type, WorkType.DELETE), transactionContext);\n+      }\n+   }\n+\n+   private void purgeIndex(TransactionContext transactionContext, Class<?> entityType) {\n+      IndexedTypeIdentifier type = new PojoIndexedTypeIdentifier(entityType);\n+      if (searchFactory.getIndexBindings().containsKey(type)) {\n+         performSearchWork(searchWorkCreator.createPerEntityTypeWork(type, WorkType.PURGE_ALL), transactionContext);\n+      }\n+   }\n+\n+   private void purgeAllIndexes(TransactionContext transactionContext) {\n+      for (IndexedTypeIdentifier type : searchFactory.getIndexBindings().keySet()) {\n+         performSearchWork(searchWorkCreator.createPerEntityTypeWork(type, WorkType.PURGE_ALL), transactionContext);\n+      }\n    }\n \n    // Method that will be called when data needs to be removed from Lucene.\n-   private void removeFromIndexes(Object value, Object key, int segment) {\n-      Futures.unwrappedExceptionJoin(getSearchIndexer().delete(keyToString(key, segment), value));\n+   private void removeFromIndexes(Object value, Object key, TransactionContext transactionContext, int segment) {\n+      performSearchWork(value, keyToString(key, segment), WorkType.DELETE, transactionContext);\n    }\n \n-   private void updateIndexes(boolean usingSkipIndexCleanupFlag, Object value, Object key, int segment) {\n+   private void updateIndexes(boolean usingSkipIndexCleanupFlag, Object value, Object key, TransactionContext transactionContext, int segment) {\n       // Note: it's generally unsafe to assume there is no previous entry to cleanup: always use UPDATE\n       // unless the specific flag is allowing this.\n-      if (usingSkipIndexCleanupFlag) {\n-         Futures.unwrappedExceptionJoin(getSearchIndexer().add(keyToString(key, segment), value));\n-      } else {\n-         Futures.unwrappedExceptionJoin(getSearchIndexer().addOrUpdate(keyToString(key, segment), value));\n+      performSearchWork(value, keyToString(key, segment), usingSkipIndexCleanupFlag ? WorkType.ADD : WorkType.UPDATE, transactionContext);\n+   }\n+\n+   private void performSearchWork(Object value, Serializable id, WorkType workType, TransactionContext transactionContext) {\n+      if (value == null) throw new NullPointerException(\"Cannot handle a null value!\");\n+      performSearchWork(searchWorkCreator.createPerEntityWork(value, id, workType), transactionContext);\n+   }\n+\n+   private void performSearchWork(Work work, TransactionContext transactionContext) {\n+      if (work != null) {\n+         Worker worker = searchFactory.getWorker();\n+         worker.performWork(work, transactionContext);\n       }\n    }\n \n", "next_change": {"commit": "bb18590bbe7e5e9948bca940518235678d1a4fae", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java b/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java\nindex 6d427c8a56..ea7dfc518b 100644\n--- a/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java\n+++ b/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java\n", "chunk": "@@ -322,69 +314,57 @@ public Object visitReadWriteManyEntriesCommand(InvocationContext ctx, ReadWriteM\n     * Remove all entries from all known indexes\n     */\n    public void purgeAllIndexes() {\n-      purgeAllIndexes(NoTransactionContext.INSTANCE);\n+      SearchMapping searchMapping = searchMappingHolder.getSearchMapping();\n+      if (searchMapping == null) {\n+         return;\n+      }\n+\n+      searchMapping.scopeAll().workspace().purge();\n    }\n \n    public void purgeIndex(Class<?> entityType) {\n-      purgeIndex(NoTransactionContext.INSTANCE, entityType);\n+      SearchMapping searchMapping = searchMappingHolder.getSearchMapping();\n+      if (searchMapping == null) {\n+         return;\n+      }\n+\n+      searchMapping.scope(entityType).workspace().purge();\n    }\n \n    /**\n     * Removes from the index the entries corresponding to the supplied segments, if the index is local.\n     */\n    void purgeIndex(IntSet segments) {\n-      if (segments == null) return;\n-      for (int segment : segments) {\n-         DeletionQuery deletionQuery = new SingularTermDeletionQuery(SEGMENT_FIELD, String.valueOf(segment));\n-         for (IndexedTypeIdentifier type : searchFactory.getIndexBindings().keySet()) {\n-            Work deleteWork = new DeleteByQueryWork(type, deletionQuery);\n-            performSearchWork(deleteWork, NoTransactionContext.INSTANCE);\n-         }\n+      if (segments == null || segments.isEmpty()) return;\n+\n+      SearchMapping searchMapping = searchMappingHolder.getSearchMapping();\n+      if (searchMapping == null) {\n+         return;\n       }\n+\n+      Set<String> routingKeys = segments.intStream().boxed().map(Objects::toString).collect(Collectors.toSet());\n+      searchMapping.scopeAll().workspace().purge(routingKeys);\n    }\n \n    /**\n     * Remove entries from all indexes by key.\n     */\n-   void removeFromIndexes(TransactionContext transactionContext, Object key, int segment) {\n-      for (IndexedTypeIdentifier type : searchFactory.getIndexBindings().keySet()) {\n-         performSearchWork(searchWorkCreator.createPerEntityWork(keyToString(key, segment), type, WorkType.DELETE), transactionContext);\n-      }\n-   }\n-\n-   private void purgeIndex(TransactionContext transactionContext, Class<?> entityType) {\n-      IndexedTypeIdentifier type = new PojoIndexedTypeIdentifier(entityType);\n-      if (searchFactory.getIndexBindings().containsKey(type)) {\n-         performSearchWork(searchWorkCreator.createPerEntityTypeWork(type, WorkType.PURGE_ALL), transactionContext);\n-      }\n-   }\n-\n-   private void purgeAllIndexes(TransactionContext transactionContext) {\n-      for (IndexedTypeIdentifier type : searchFactory.getIndexBindings().keySet()) {\n-         performSearchWork(searchWorkCreator.createPerEntityTypeWork(type, WorkType.PURGE_ALL), transactionContext);\n-      }\n+   void removeFromIndexes(Object key, int segment) {\n+      Futures.unwrappedExceptionJoin(getSearchIndexer().purge(keyToString(key, segment), segment+\"\"));\n    }\n \n    // Method that will be called when data needs to be removed from Lucene.\n-   private void removeFromIndexes(Object value, Object key, TransactionContext transactionContext, int segment) {\n-      performSearchWork(value, keyToString(key, segment), WorkType.DELETE, transactionContext);\n+   private void removeFromIndexes(Object value, Object key, int segment) {\n+      Futures.unwrappedExceptionJoin(getSearchIndexer().delete(keyToString(key, segment), value));\n    }\n \n-   private void updateIndexes(boolean usingSkipIndexCleanupFlag, Object value, Object key, TransactionContext transactionContext, int segment) {\n+   private void updateIndexes(boolean usingSkipIndexCleanupFlag, Object value, Object key, int segment) {\n       // Note: it's generally unsafe to assume there is no previous entry to cleanup: always use UPDATE\n       // unless the specific flag is allowing this.\n-      performSearchWork(value, keyToString(key, segment), usingSkipIndexCleanupFlag ? WorkType.ADD : WorkType.UPDATE, transactionContext);\n-   }\n-\n-   private void performSearchWork(Object value, Serializable id, WorkType workType, TransactionContext transactionContext) {\n-      if (value == null) throw new NullPointerException(\"Cannot handle a null value!\");\n-      performSearchWork(searchWorkCreator.createPerEntityWork(value, id, workType), transactionContext);\n-   }\n-\n-   private void performSearchWork(Work work, TransactionContext transactionContext) {\n-      if (work != null) {\n-         Worker worker = searchFactory.getWorker();\n-         worker.performWork(work, transactionContext);\n+      if (usingSkipIndexCleanupFlag) {\n+         Futures.unwrappedExceptionJoin(getSearchIndexer().add(keyToString(key, segment), value));\n+      } else {\n+         Futures.unwrappedExceptionJoin(getSearchIndexer().addOrUpdate(keyToString(key, segment), value));\n       }\n    }\n \n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "91d194f1a4e6f6990903ea42094be659142bb4d5", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java b/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java\nindex 50cb7053ab..ea7dfc518b 100644\n--- a/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java\n+++ b/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java\n", "chunk": "@@ -331,15 +331,6 @@ public void purgeIndex(Class<?> entityType) {\n       searchMapping.scope(entityType).workspace().purge();\n    }\n \n-   public void refreshIndex(Class<?> entityType) {\n-      SearchMapping searchMapping = searchMappingHolder.getSearchMapping();\n-      if (searchMapping == null) {\n-         return;\n-      }\n-\n-      searchMapping.scope(entityType).workspace().refresh();\n-   }\n-\n    /**\n     * Removes from the index the entries corresponding to the supplied segments, if the index is local.\n     */\n", "next_change": {"commit": "fd7203a0b2c24ddf8eeb5521730a097892ca4816", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java b/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java\nindex ea7dfc518b..9c125b45f7 100644\n--- a/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java\n+++ b/query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java\n", "chunk": "@@ -335,10 +326,7 @@ public void purgeIndex(Class<?> entityType) {\n     * Removes from the index the entries corresponding to the supplied segments, if the index is local.\n     */\n    void purgeIndex(IntSet segments) {\n-      if (segments == null || segments.isEmpty()) return;\n-\n-      SearchMapping searchMapping = searchMappingHolder.getSearchMapping();\n-      if (searchMapping == null) {\n+      if (segments == null || segments.isEmpty() || searchMapping == null) {\n          return;\n       }\n \n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "91d194f1a4e6f6990903ea42094be659142bb4d5", "message": "Merge commit", "committedDate": null}, {"oid": "43f494989cf91d79cb2c70ab7bbe0f756ffc67b4", "committedDate": "2020-08-02 23:26:31 -0400", "message": "ISPN-12178 Query broadcast blocks on the non-blocking executor"}, {"oid": "5d0bf286d76bda64ddb918ec31872ea9f54070d6", "committedDate": "2020-08-02 23:26:31 -0400", "message": "ISPN-12178 Remove unused fields and parameters"}, {"oid": "1770a64871ec7e148ca71ab19c8024142c7bcd34", "committedDate": "2020-08-12 21:48:59 +0300", "message": "ISPN-12186 Update to Hibernate Search 6.0.0.Beta9"}, {"oid": "c68c255f3b81dfcb71a25051b38be94700ad5ef5", "committedDate": "2020-08-17 12:24:55 -0400", "message": "ISPN-11731 Add blockhound to query module"}, {"oid": "fd7203a0b2c24ddf8eeb5521730a097892ca4816", "committedDate": "2020-09-04 10:54:55 +0100", "message": "ISPN-12169 Free QueryInterceptor from SearchMappingHolder"}, {"oid": "2d53d0a1e59f2dc3335235f9dafb8e93e611c60e", "committedDate": "2020-09-07 11:44:18 +0100", "message": "ISPN-11802 Create SPI for Cross-Site Replication conflict resolution"}, {"oid": "0753647c23d47fd1f035473b94d182c6da84e701", "committedDate": "2020-12-14 17:38:18 +0200", "message": "ISPN-12469 Do not cache trace level statically"}, {"oid": "7206596b4a0258d0b8f1a20d78259e7f270a81ec", "committedDate": "2020-12-14 17:38:18 +0200", "message": "ISPN-12469 Don't cache isTraceEnabled/isDebugEnabled calls"}, {"oid": "41e1f86ccc4e892b95cee3984de157b395eca9ca", "committedDate": "2020-12-18 12:57:31 +0200", "message": "ISPN-12522 Leverage Hibernate Search's identifier conversion mechanics to convert keys"}, {"oid": "2ac53aac5f05c44ac291d358eda785cbc991f769", "committedDate": "2020-12-18 12:57:31 +0200", "message": "ISPN-12522 Clean up access to indexed entity metadata from the InfinispanMapping"}, {"oid": "128874af7ab7204db85bb1ea1ed8248b3828ffdd", "committedDate": "2021-03-31 17:17:49 +0100", "message": "ISPN-11299 Stale values can be indexed during State Transfer"}, {"oid": "7b9bbb3e90b2e5110b814efa3af88417d2d21765", "committedDate": "2021-05-03 09:32:12 +0200", "message": "ISPN-12994 Cache and indexes can become out of sync when indexing operation fails"}, {"oid": "e9f942add8fe6277df69bf853271251e4a51c2b8", "committedDate": "2021-06-24 10:28:45 +0200", "message": "ISPN-13101 Replace assertion"}, {"oid": "91d75550738b5d681c74113f7e6832cfc1142623", "committedDate": "2021-08-30 10:29:59 +0100", "message": "ISPN-12881 Support for adding stores dynamically"}, {"oid": "1f3a15c455dacd3d788eab3f3109239492f1e675", "committedDate": "2022-04-01 13:31:34 -0400", "message": "ISPN-13792 Non-blocking transaction commit/rollback"}, {"oid": "7bd0ed0b68eaa48b8b6e15496316da54914cc895", "committedDate": "2022-05-25 09:16:04 +0200", "message": "ISPN-13648 Schema evolution with respect to indices without downtime (#10114)"}, {"oid": "777bcb90ffc7882062caca503c385bc4cd84e0b7", "committedDate": "2022-09-08 09:47:40 +0200", "message": "ISPN-14115 Rename the should remove method"}, {"oid": "fb5fe86ebc7a462ddbfda6940e7fe0755b777af0", "committedDate": "2022-09-08 09:47:40 +0200", "message": "ISPN-14115 Fix deadlock in index writer threads under heavy load"}, {"oid": "f5a9f7f3ba7f00bc6bbcfe2856f282cfd62f604a", "committedDate": "2023-03-28 13:43:27 -0400", "message": "ISPN-14483 Set log indexing operations to trace"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgxNzkyNA==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r458817924", "body": "heads up, we've deprecated the whole \"CacheQuery\" class in 11, and this include the so called \"lazy\" iterator. So you could just get rid of it", "bodyText": "heads up, we've deprecated the whole \"CacheQuery\" class in 11, and this include the so called \"lazy\" iterator. So you could just get rid of it", "bodyHTML": "<p dir=\"auto\">heads up, we've deprecated the whole \"CacheQuery\" class in 11, and this include the so called \"lazy\" iterator. So you could just get rid of it</p>", "author": "gustavocoding", "createdAt": "2020-07-22T14:05:24Z", "path": "query/src/main/java/org/infinispan/query/clustered/ClusteredQueryOperation.java", "diffHunk": "@@ -38,12 +38,12 @@ public QueryDefinition getQueryDefinition() {\n       return queryDefinition;\n    }\n \n-   static ClusteredQueryOperation createLazyIterator(QueryDefinition queryDefinition, UUID queryId) {\n+   /*static ClusteredQueryOperation createLazyIterator(QueryDefinition queryDefinition, UUID queryId) {", "originalCommit": "973742666427584064f0529d85af66024e57d0ab", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6300e5d5e53a1e59b9349292cdc7d87ce9d476da", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/clustered/ClusteredQueryOperation.java b/query/src/main/java/org/infinispan/query/clustered/ClusteredQueryOperation.java\nindex 344929c9f1..afbaad7f53 100644\n--- a/query/src/main/java/org/infinispan/query/clustered/ClusteredQueryOperation.java\n+++ b/query/src/main/java/org/infinispan/query/clustered/ClusteredQueryOperation.java\n", "chunk": "@@ -38,13 +38,6 @@ public QueryDefinition getQueryDefinition() {\n       return queryDefinition;\n    }\n \n-   /*static ClusteredQueryOperation createLazyIterator(QueryDefinition queryDefinition, UUID queryId) {\n-      ClusteredQueryOperation cmd = new ClusteredQueryOperation(CQCommandType.CREATE_LAZY_ITERATOR);\n-      cmd.queryDefinition = queryDefinition;\n-      cmd.queryId = queryId;\n-      return cmd;\n-   }*/\n-\n    static ClusteredQueryOperation getResultSize(QueryDefinition queryDefinition) {\n       ClusteredQueryOperation cmd = new ClusteredQueryOperation(CQCommandType.GET_RESULT_SIZE);\n       cmd.queryDefinition = queryDefinition;\n", "next_change": {"commit": "32718114c38cd1cf83048d759033d952387d0a7e", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/clustered/ClusteredQueryOperation.java b/query/src/main/java/org/infinispan/query/clustered/ClusteredQueryOperation.java\nindex afbaad7f53..c0f3e594b5 100644\n--- a/query/src/main/java/org/infinispan/query/clustered/ClusteredQueryOperation.java\n+++ b/query/src/main/java/org/infinispan/query/clustered/ClusteredQueryOperation.java\n", "chunk": "@@ -38,6 +38,13 @@ public QueryDefinition getQueryDefinition() {\n       return queryDefinition;\n    }\n \n+   static ClusteredQueryOperation createLazyIterator(QueryDefinition queryDefinition, UUID queryId) {\n+      ClusteredQueryOperation cmd = new ClusteredQueryOperation(CQCommandType.CREATE_LAZY_ITERATOR);\n+      cmd.queryDefinition = queryDefinition;\n+      cmd.queryId = queryId;\n+      return cmd;\n+   }\n+\n    static ClusteredQueryOperation getResultSize(QueryDefinition queryDefinition) {\n       ClusteredQueryOperation cmd = new ClusteredQueryOperation(CQCommandType.GET_RESULT_SIZE);\n       cmd.queryDefinition = queryDefinition;\n", "next_change": {"commit": "bb18590bbe7e5e9948bca940518235678d1a4fae", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/clustered/ClusteredQueryOperation.java b/query/src/main/java/org/infinispan/query/clustered/ClusteredQueryOperation.java\nindex c0f3e594b5..afbaad7f53 100644\n--- a/query/src/main/java/org/infinispan/query/clustered/ClusteredQueryOperation.java\n+++ b/query/src/main/java/org/infinispan/query/clustered/ClusteredQueryOperation.java\n", "chunk": "@@ -38,13 +38,6 @@ public QueryDefinition getQueryDefinition() {\n       return queryDefinition;\n    }\n \n-   static ClusteredQueryOperation createLazyIterator(QueryDefinition queryDefinition, UUID queryId) {\n-      ClusteredQueryOperation cmd = new ClusteredQueryOperation(CQCommandType.CREATE_LAZY_ITERATOR);\n-      cmd.queryDefinition = queryDefinition;\n-      cmd.queryId = queryId;\n-      return cmd;\n-   }\n-\n    static ClusteredQueryOperation getResultSize(QueryDefinition queryDefinition) {\n       ClusteredQueryOperation cmd = new ClusteredQueryOperation(CQCommandType.GET_RESULT_SIZE);\n       cmd.queryDefinition = queryDefinition;\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "91d194f1a4e6f6990903ea42094be659142bb4d5", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/clustered/ClusteredQueryOperation.java b/query/src/main/java/org/infinispan/query/clustered/ClusteredQueryOperation.java\nindex 344929c9f1..afbaad7f53 100644\n--- a/query/src/main/java/org/infinispan/query/clustered/ClusteredQueryOperation.java\n+++ b/query/src/main/java/org/infinispan/query/clustered/ClusteredQueryOperation.java\n", "chunk": "@@ -38,13 +38,6 @@ public QueryDefinition getQueryDefinition() {\n       return queryDefinition;\n    }\n \n-   /*static ClusteredQueryOperation createLazyIterator(QueryDefinition queryDefinition, UUID queryId) {\n-      ClusteredQueryOperation cmd = new ClusteredQueryOperation(CQCommandType.CREATE_LAZY_ITERATOR);\n-      cmd.queryDefinition = queryDefinition;\n-      cmd.queryId = queryId;\n-      return cmd;\n-   }*/\n-\n    static ClusteredQueryOperation getResultSize(QueryDefinition queryDefinition) {\n       ClusteredQueryOperation cmd = new ClusteredQueryOperation(CQCommandType.GET_RESULT_SIZE);\n       cmd.queryDefinition = queryDefinition;\n", "next_change": {"commit": "763c5e1bf3567de383860e51693e3198ef25690a", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/clustered/ClusteredQueryOperation.java b/query/src/main/java/org/infinispan/query/clustered/ClusteredQueryOperation.java\nindex afbaad7f53..43c958b1c1 100644\n--- a/query/src/main/java/org/infinispan/query/clustered/ClusteredQueryOperation.java\n+++ b/query/src/main/java/org/infinispan/query/clustered/ClusteredQueryOperation.java\n", "chunk": "@@ -39,18 +41,18 @@ public QueryDefinition getQueryDefinition() {\n    }\n \n    static ClusteredQueryOperation getResultSize(QueryDefinition queryDefinition) {\n-      ClusteredQueryOperation cmd = new ClusteredQueryOperation(CQCommandType.GET_RESULT_SIZE);\n-      cmd.queryDefinition = queryDefinition;\n-      return cmd;\n+      return new ClusteredQueryOperation(CQCommandType.GET_RESULT_SIZE, queryDefinition);\n+   }\n+\n+   static ClusteredQueryOperation delete(QueryDefinition queryDefinition) {\n+      return new ClusteredQueryOperation(CQCommandType.DELETE, queryDefinition);\n    }\n \n    static ClusteredQueryOperation createEagerIterator(QueryDefinition queryDefinition) {\n-      ClusteredQueryOperation cmd = new ClusteredQueryOperation(CQCommandType.CREATE_EAGER_ITERATOR);\n-      cmd.queryDefinition = queryDefinition;\n-      return cmd;\n+      return new ClusteredQueryOperation(CQCommandType.CREATE_EAGER_ITERATOR, queryDefinition);\n    }\n \n-   public QueryResponse perform(Cache<?, ?> cache, BitSet segments) {\n+   public CompletionStage<QueryResponse> perform(Cache<?, ?> cache, BitSet segments) {\n       return commandType.perform(cache.getAdvancedCache(), queryDefinition, queryId, docIndex, segments);\n    }\n \n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "91d194f1a4e6f6990903ea42094be659142bb4d5", "message": "Merge commit", "committedDate": null}, {"oid": "43f494989cf91d79cb2c70ab7bbe0f756ffc67b4", "committedDate": "2020-08-02 23:26:31 -0400", "message": "ISPN-12178 Query broadcast blocks on the non-blocking executor"}, {"oid": "763c5e1bf3567de383860e51693e3198ef25690a", "committedDate": "2021-10-12 17:52:37 +0200", "message": "ISPN-12642 Ickle, delete by query"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgxOTA5MQ==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r458819091", "body": "Shouldn't be deleted", "bodyText": "Shouldn't be deleted", "bodyHTML": "<p dir=\"auto\">Shouldn't be deleted</p>", "author": "gustavocoding", "createdAt": "2020-07-22T14:07:02Z", "path": "query/src/main/java/org/infinispan/query/clustered/commandworkers/package-info.java", "diffHunk": "@@ -1,4 +0,0 @@\n-/**\n- * @private\n- */\n-package org.infinispan.query.clustered.commandworkers;", "originalCommit": "973742666427584064f0529d85af66024e57d0ab", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6300e5d5e53a1e59b9349292cdc7d87ce9d476da", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/clustered/commandworkers/package-info.java b/query/src/main/java/org/infinispan/query/clustered/commandworkers/package-info.java\nnew file mode 100644\nindex 0000000000..2567c3a712\n--- /dev/null\n+++ b/query/src/main/java/org/infinispan/query/clustered/commandworkers/package-info.java\n", "chunk": "@@ -0,0 +1,4 @@\n+/**\n+ * @private\n+ */\n+package org.infinispan.query.clustered.commandworkers;\n", "next_change": null}]}, "revised_code_in_main": {"commit": "91d194f1a4e6f6990903ea42094be659142bb4d5", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/clustered/commandworkers/package-info.java b/query/src/main/java/org/infinispan/query/clustered/commandworkers/package-info.java\nnew file mode 100644\nindex 0000000000..2567c3a712\n--- /dev/null\n+++ b/query/src/main/java/org/infinispan/query/clustered/commandworkers/package-info.java\n", "chunk": "@@ -0,0 +1,4 @@\n+/**\n+ * @private\n+ */\n+package org.infinispan.query.clustered.commandworkers;\n", "next_change": {"commit": "ae2cd613734210e5219c39fd42f1c8f408e11373", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/clustered/commandworkers/package-info.java b/query/src/main/java/org/infinispan/query/clustered/commandworkers/package-info.java\nindex 2567c3a712..fa98e8ab82 100644\n--- a/query/src/main/java/org/infinispan/query/clustered/commandworkers/package-info.java\n+++ b/query/src/main/java/org/infinispan/query/clustered/commandworkers/package-info.java\n", "chunk": "@@ -1,4 +1,4 @@\n /**\n- * @private\n+ * @api.private\n  */\n package org.infinispan.query.clustered.commandworkers;\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "91d194f1a4e6f6990903ea42094be659142bb4d5", "message": "Merge commit", "committedDate": null}, {"oid": "ae2cd613734210e5219c39fd42f1c8f408e11373", "committedDate": "2022-05-23 10:27:06 +0100", "message": "ISPN-13905 Allow building JavaDocs with JDK 17"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgxOTY5Mg==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r458819692", "body": "Did you fix this @fax4ever ? If not, let's keep it as a reminder :)", "bodyText": "Did you fix this @fax4ever ? If not, let's keep it as a reminder :)", "bodyHTML": "<p dir=\"auto\">Did you fix this <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/fax4ever/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/fax4ever\">@fax4ever</a> ? If not, let's keep it as a reminder :)</p>", "author": "gustavocoding", "createdAt": "2020-07-22T14:07:51Z", "path": "query/src/main/java/org/infinispan/query/dsl/embedded/impl/EmbeddedLuceneQuery.java", "diffHunk": "@@ -83,21 +83,23 @@ public void resetQuery() {\n \n    @Override\n    public QueryResult<T> execute() {\n-      List<T> results = StreamSupport.stream(spliterator(), false).collect(Collectors.toList());\n-      long hits = createCacheQuery().getResultSize();\n-      return new QueryResultImpl<>(hits, results);\n+      List<?> results = StreamSupport.stream(spliterator(), false)\n+            .map(i -> (projection == null) ? i : convertProjectionItem(i))\n+            .collect(Collectors.toList());\n+\n+      int hits = Math.toIntExact(createCacheQuery().getResultSize());\n+      return new QueryResultImpl<>(hits, (List<T>) results);\n    }\n \n    @Override\n    public CloseableIterator<T> iterator() {\n-      CloseableIterator<T> iterator = createCacheQuery().iterator();\n-      return rowProcessor == null ? iterator : new MappingIterator(iterator, t -> rowProcessor.apply((Object[]) t));\n+      IndexedQuery<T> cacheQuery = createCacheQuery();\n+      return new MappingIterator(cacheQuery.iterator(), i -> (projection == null) ? i : convertProjectionItem(i) );\n    }\n \n    @Override\n    public int getResultSize() {\n-      //todo [anistor] optimize this by running a slightly modified query that performs just COUNT only, ignoring projections or sorting", "originalCommit": "973742666427584064f0529d85af66024e57d0ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI3OTUzNw==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r459279537", "bodyText": "I have to check :P", "author": "fax4ever", "createdAt": "2020-07-23T08:06:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgxOTY5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ0Mzg2MQ==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r459443861", "bodyText": "From what I can see it seems that we did it. Because fetchTotalHitCount Search 6 API invokes a specific work that does not involve pagination and sorting. @yrodiere Did I say something wrong? (Thanks)", "author": "fax4ever", "createdAt": "2020-07-23T13:21:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgxOTY5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ0Njg3NQ==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r459446875", "bodyText": "You're right. And from what I can see getResultSize() calls fetchTotalHitCount, so we already optimize everything we need.", "author": "yrodiere", "createdAt": "2020-07-23T13:26:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgxOTY5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "32718114c38cd1cf83048d759033d952387d0a7e", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/dsl/embedded/impl/EmbeddedLuceneQuery.java b/query/src/main/java/org/infinispan/query/dsl/embedded/impl/EmbeddedLuceneQuery.java\nindex cdb8dc2d1e..4774e9de84 100644\n--- a/query/src/main/java/org/infinispan/query/dsl/embedded/impl/EmbeddedLuceneQuery.java\n+++ b/query/src/main/java/org/infinispan/query/dsl/embedded/impl/EmbeddedLuceneQuery.java\n", "chunk": "@@ -83,23 +83,21 @@ public List<T> list() {\n \n    @Override\n    public QueryResult<T> execute() {\n-      List<?> results = StreamSupport.stream(spliterator(), false)\n-            .map(i -> (projection == null) ? i : convertProjectionItem(i))\n-            .collect(Collectors.toList());\n-\n-      int hits = Math.toIntExact(createCacheQuery().getResultSize());\n-      return new QueryResultImpl<>(hits, (List<T>) results);\n+      List<T> results = StreamSupport.stream(spliterator(), false).collect(Collectors.toList());\n+      long hits = createCacheQuery().getResultSize();\n+      return new QueryResultImpl<>(hits, results);\n    }\n \n    @Override\n    public CloseableIterator<T> iterator() {\n-      IndexedQuery<T> cacheQuery = createCacheQuery();\n-      return new MappingIterator(cacheQuery.iterator(), i -> (projection == null) ? i : convertProjectionItem(i) );\n+      CloseableIterator<T> iterator = createCacheQuery().iterator();\n+      return rowProcessor == null ? iterator : new MappingIterator(iterator, t -> rowProcessor.apply((Object[]) t));\n    }\n \n    @Override\n    public int getResultSize() {\n-      return Math.toIntExact(createCacheQuery().getResultSize());\n+      //todo [anistor] optimize this by running a slightly modified query that performs just COUNT only, ignoring projections or sorting\n+      return createCacheQuery().getResultSize();\n    }\n \n    @Override\n", "next_change": {"commit": "bb18590bbe7e5e9948bca940518235678d1a4fae", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/dsl/embedded/impl/EmbeddedLuceneQuery.java b/query/src/main/java/org/infinispan/query/dsl/embedded/impl/EmbeddedLuceneQuery.java\nindex 4774e9de84..bb16b467dd 100644\n--- a/query/src/main/java/org/infinispan/query/dsl/embedded/impl/EmbeddedLuceneQuery.java\n+++ b/query/src/main/java/org/infinispan/query/dsl/embedded/impl/EmbeddedLuceneQuery.java\n", "chunk": "@@ -83,21 +83,22 @@ public List<T> list() {\n \n    @Override\n    public QueryResult<T> execute() {\n-      List<T> results = StreamSupport.stream(spliterator(), false).collect(Collectors.toList());\n-      long hits = createCacheQuery().getResultSize();\n-      return new QueryResultImpl<>(hits, results);\n+      List<?> results = StreamSupport.stream(spliterator(), false)\n+            .map(i -> (projection == null) ? i : convertProjectionItem(i))\n+            .collect(Collectors.toList());\n+\n+      return new QueryResultImpl<>(createCacheQuery().getResultSize(), (List<T>) results);\n    }\n \n    @Override\n    public CloseableIterator<T> iterator() {\n-      CloseableIterator<T> iterator = createCacheQuery().iterator();\n-      return rowProcessor == null ? iterator : new MappingIterator(iterator, t -> rowProcessor.apply((Object[]) t));\n+      IndexedQuery<T> cacheQuery = createCacheQuery();\n+      return new MappingIterator(cacheQuery.iterator(), i -> (projection == null) ? i : convertProjectionItem(i) );\n    }\n \n    @Override\n    public int getResultSize() {\n-      //todo [anistor] optimize this by running a slightly modified query that performs just COUNT only, ignoring projections or sorting\n-      return createCacheQuery().getResultSize();\n+      return Math.toIntExact(createCacheQuery().getResultSize());\n    }\n \n    @Override\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "86be6afd3a356a47b5be033c2bd65ff79acfef2b", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/dsl/embedded/impl/EmbeddedLuceneQuery.java b/query/src/main/java/org/infinispan/query/dsl/embedded/impl/EmbeddedLuceneQuery.java\nindex cdb8dc2d1e..4b004f0a1c 100644\n--- a/query/src/main/java/org/infinispan/query/dsl/embedded/impl/EmbeddedLuceneQuery.java\n+++ b/query/src/main/java/org/infinispan/query/dsl/embedded/impl/EmbeddedLuceneQuery.java\n", "chunk": "@@ -87,14 +83,13 @@ public QueryResult<T> execute() {\n             .map(i -> (projection == null) ? i : convertProjectionItem(i))\n             .collect(Collectors.toList());\n \n-      int hits = Math.toIntExact(createCacheQuery().getResultSize());\n-      return new QueryResultImpl<>(hits, (List<T>) results);\n+      return new QueryResultImpl<>(createCacheQuery().getResultSize(), (List<T>) results);\n    }\n \n    @Override\n    public CloseableIterator<T> iterator() {\n       IndexedQuery<T> cacheQuery = createCacheQuery();\n-      return new MappingIterator(cacheQuery.iterator(), i -> (projection == null) ? i : convertProjectionItem(i) );\n+      return new MappingIterator(cacheQuery.iterator(), i -> (projection == null) ? i : convertProjectionItem(i));\n    }\n \n    @Override\n", "next_change": {"commit": "528f96cead9efe61cac24776612be9871391eac2", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/dsl/embedded/impl/EmbeddedLuceneQuery.java b/query/src/main/java/org/infinispan/query/dsl/embedded/impl/EmbeddedLuceneQuery.java\nindex 4b004f0a1c..6feaae6a40 100644\n--- a/query/src/main/java/org/infinispan/query/dsl/embedded/impl/EmbeddedLuceneQuery.java\n+++ b/query/src/main/java/org/infinispan/query/dsl/embedded/impl/EmbeddedLuceneQuery.java\n", "chunk": "@@ -79,22 +78,20 @@ public List<T> list() {\n \n    @Override\n    public QueryResult<T> execute() {\n-      List<?> results = StreamSupport.stream(spliterator(), false)\n-            .map(i -> (projection == null) ? i : convertProjectionItem(i))\n-            .collect(Collectors.toList());\n-\n-      return new QueryResultImpl<>(createCacheQuery().getResultSize(), (List<T>) results);\n+      QueryResult<T> execute = createIndexedQuery().execute();\n+      List<Object> collect = execute.list().stream().map(this::convertResult).collect(Collectors.toList());\n+      return new QueryResultImpl<>(execute.hitCount().orElse(-1), (List<T>) collect);\n    }\n \n    @Override\n    public CloseableIterator<T> iterator() {\n-      IndexedQuery<T> cacheQuery = createCacheQuery();\n-      return new MappingIterator(cacheQuery.iterator(), i -> (projection == null) ? i : convertProjectionItem(i));\n+      IndexedQuery<T> indexedQuery = createIndexedQuery();\n+      return new MappingIterator(indexedQuery.iterator(), this::convertResult);\n    }\n \n    @Override\n    public int getResultSize() {\n-      return Math.toIntExact(createCacheQuery().getResultSize());\n+      return Math.toIntExact(createIndexedQuery().getResultSize());\n    }\n \n    @Override\n", "next_change": {"commit": "763c5e1bf3567de383860e51693e3198ef25690a", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/dsl/embedded/impl/EmbeddedLuceneQuery.java b/query/src/main/java/org/infinispan/query/dsl/embedded/impl/EmbeddedLuceneQuery.java\nindex 6feaae6a40..355aa7d082 100644\n--- a/query/src/main/java/org/infinispan/query/dsl/embedded/impl/EmbeddedLuceneQuery.java\n+++ b/query/src/main/java/org/infinispan/query/dsl/embedded/impl/EmbeddedLuceneQuery.java\n", "chunk": "@@ -78,20 +78,31 @@ public List<T> list() {\n \n    @Override\n    public QueryResult<T> execute() {\n-      QueryResult<T> execute = createIndexedQuery().execute();\n-      List<Object> collect = execute.list().stream().map(this::convertResult).collect(Collectors.toList());\n-      return new QueryResultImpl<>(execute.hitCount().orElse(-1), (List<T>) collect);\n+      IndexedQuery<?> indexedQuery = createIndexedQuery();\n+      QueryResult<?> result = indexedQuery.execute();\n+      List<Object> collect = result.list().stream().map(this::convertResult).collect(Collectors.toList());\n+      return new QueryResultImpl<>(result.hitCount().orElse(-1), (List<T>) collect);\n    }\n \n    @Override\n-   public CloseableIterator<T> iterator() {\n+   public int executeStatement() {\n       IndexedQuery<T> indexedQuery = createIndexedQuery();\n-      return new MappingIterator(indexedQuery.iterator(), this::convertResult);\n+      return indexedQuery.executeStatement();\n+   }\n+\n+   @Override\n+   public CloseableIterator<T> iterator() {\n+      return new MappingIterator(createIndexedQuery().iterator(), this::convertResult);\n+   }\n+\n+   @Override\n+   public <K> CloseableIterator<Map.Entry<K, T>> entryIterator() {\n+      return new MappingIterator(createIndexedQuery().entryIterator(), null);\n    }\n \n    @Override\n    public int getResultSize() {\n-      return Math.toIntExact(createIndexedQuery().getResultSize());\n+      return createIndexedQuery().getResultSize();\n    }\n \n    @Override\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "91d194f1a4e6f6990903ea42094be659142bb4d5", "message": "Merge commit", "committedDate": null}, {"oid": "86be6afd3a356a47b5be033c2bd65ff79acfef2b", "committedDate": "2020-08-12 09:48:25 +0100", "message": "ISPN-12189 Remove deprecated indexed query classes"}, {"oid": "528f96cead9efe61cac24776612be9871391eac2", "committedDate": "2021-05-10 23:57:35 +0200", "message": "ISPN-11013 ISPN-11014 ISPN-12959 Fixes for query result count"}, {"oid": "1a36c3b49bf8258f2a7004785630459939f51626", "committedDate": "2021-05-19 17:58:46 +0100", "message": "ISPN-12359 Support for local query operations"}, {"oid": "763c5e1bf3567de383860e51693e3198ef25690a", "committedDate": "2021-10-12 17:52:37 +0200", "message": "ISPN-12642 Ickle, delete by query"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgyMTY0Mw==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r458821643", "body": "We are not caching query result size or list anymore:  https://infinispan.org/docs/stable/titles/upgrading/upgrading.html#querying \r\nIs this something you need to do?", "bodyText": "We are not caching query result size or list anymore:  https://infinispan.org/docs/stable/titles/upgrading/upgrading.html#querying\nIs this something you need to do?", "bodyHTML": "<p dir=\"auto\">We are not caching query result size or list anymore:  <a href=\"https://infinispan.org/docs/stable/titles/upgrading/upgrading.html#querying\" rel=\"nofollow\">https://infinispan.org/docs/stable/titles/upgrading/upgrading.html#querying</a><br>\nIs this something you need to do?</p>", "author": "gustavocoding", "createdAt": "2020-07-22T14:10:33Z", "path": "query/src/main/java/org/infinispan/query/impl/CacheQueryImpl.java", "diffHunk": "@@ -42,83 +36,36 @@\n    private static final FetchOptions DEFAULT_FETCH_OPTIONS = new FetchOptions().fetchMode(FetchMode.EAGER);\n \n    protected final AdvancedCache<?, ?> cache;\n-   protected final KeyTransformationHandler keyTransformationHandler;\n    protected final PartitionHandlingSupport partitionHandlingSupport;\n    protected QueryDefinition queryDefinition;\n-   private ProjectionConverter projectionConverter;\n \n-   /**\n-    * Create a CacheQueryImpl based on a Lucene query.\n-    */\n-   public CacheQueryImpl(Query luceneQuery, SearchIntegrator searchFactory, AdvancedCache<?, ?> cache,\n-                         KeyTransformationHandler keyTransformationHandler, TimeoutExceptionFactory timeoutExceptionFactory,\n-                         Class<?> entity) {\n-      this(timeoutExceptionFactory == null ? searchFactory.createHSQuery(luceneQuery, entity) :\n-                  searchFactory.createHSQuery(luceneQuery, entity).timeoutExceptionFactory(timeoutExceptionFactory),\n-            cache, keyTransformationHandler);\n-   }\n+   // caching result size, since Search 6 doesn't do that\n+   private Long resultSize;", "originalCommit": "973742666427584064f0529d85af66024e57d0ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQyMjA1Mw==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r459422053", "bodyText": "Right! There is no reason to emulate a deprecated behavior in a deprecated API. I'm removing it.", "author": "fax4ever", "createdAt": "2020-07-23T12:47:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgyMTY0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "32718114c38cd1cf83048d759033d952387d0a7e", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/impl/CacheQueryImpl.java b/query/src/main/java/org/infinispan/query/impl/CacheQueryImpl.java\nindex 367ed7c990..f4c31299b4 100644\n--- a/query/src/main/java/org/infinispan/query/impl/CacheQueryImpl.java\n+++ b/query/src/main/java/org/infinispan/query/impl/CacheQueryImpl.java\n", "chunk": "@@ -36,36 +42,83 @@\n    private static final FetchOptions DEFAULT_FETCH_OPTIONS = new FetchOptions().fetchMode(FetchMode.EAGER);\n \n    protected final AdvancedCache<?, ?> cache;\n+   protected final KeyTransformationHandler keyTransformationHandler;\n    protected final PartitionHandlingSupport partitionHandlingSupport;\n    protected QueryDefinition queryDefinition;\n+   private ProjectionConverter projectionConverter;\n \n-   // caching result size, since Search 6 doesn't do that\n-   private Long resultSize;\n+   /**\n+    * Create a CacheQueryImpl based on a Lucene query.\n+    */\n+   public CacheQueryImpl(Query luceneQuery, SearchIntegrator searchFactory, AdvancedCache<?, ?> cache,\n+                         KeyTransformationHandler keyTransformationHandler, TimeoutExceptionFactory timeoutExceptionFactory,\n+                         Class<?> entity) {\n+      this(timeoutExceptionFactory == null ? searchFactory.createHSQuery(luceneQuery, entity) :\n+                  searchFactory.createHSQuery(luceneQuery, entity).timeoutExceptionFactory(timeoutExceptionFactory),\n+            cache, keyTransformationHandler);\n+   }\n \n-   public CacheQueryImpl(QueryDefinition queryDefinition, AdvancedCache<?, ?> cache) {\n+   public CacheQueryImpl(QueryDefinition queryDefinition, AdvancedCache<?, ?> cache,\n+                         KeyTransformationHandler keyTransformationHandler) {\n       this.queryDefinition = queryDefinition;\n       this.cache = cache;\n+      this.keyTransformationHandler = keyTransformationHandler;\n       this.partitionHandlingSupport = new PartitionHandlingSupport(cache);\n    }\n \n    /**\n-    * Create a CacheQueryImpl based on a SearchQuery.\n+    * Create a CacheQueryImpl based on a HSQuery.\n     */\n-   public CacheQueryImpl(SearchQueryBuilder searchQuery, AdvancedCache<?, ?> cache) {\n-      this(new QueryDefinition(searchQuery), cache);\n+   public CacheQueryImpl(HSQuery hSearchQuery, AdvancedCache<?, ?> cache, KeyTransformationHandler keyTransformationHandler) {\n+      this(new QueryDefinition(hSearchQuery), cache, keyTransformationHandler);\n    }\n \n    /**\n-    * @return The result size of the query.\n+    * Takes in a lucene filter and sets it to the filter field in the class.\n+    *\n+    * @param filter - lucene filter\n     */\n    @Override\n-   public long getResultSize() {\n-      if (resultSize != null) {\n-         return resultSize;\n-      }\n+   public IndexedQuery<E> filter(Filter filter) {\n+      queryDefinition.filter(filter);\n+      return this;\n+   }\n \n+   /**\n+    * @return The result size of the query.\n+    */\n+   @Override\n+   public int getResultSize() {\n       partitionHandlingSupport.checkCacheAvailable();\n-      return queryDefinition.getSearchQuery().build().fetchTotalHitCount();\n+      return queryDefinition.getHsQuery().queryResultSize();\n+   }\n+\n+   @Override\n+   public IndexedQuery<E> sort(Sort sort) {\n+      queryDefinition.setSort(sort);\n+      return this;\n+   }\n+\n+   /**\n+    * Enable a given filter by its name.\n+    *\n+    * @param name of filter.\n+    * @return a FullTextFilter object.\n+    */\n+   @Override\n+   public FullTextFilter enableFullTextFilter(String name) {\n+      return queryDefinition.enableFullTextFilter(name);\n+   }\n+\n+   /**\n+    * Disable a given filter by its name.\n+    *\n+    * @param name of filter.\n+    */\n+   @Override\n+   public IndexedQuery<E> disableFullTextFilter(String name) {\n+      queryDefinition.disableFullTextFilter(name);\n+      return this;\n    }\n \n    /**\n", "next_change": {"commit": "bb18590bbe7e5e9948bca940518235678d1a4fae", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/impl/CacheQueryImpl.java b/query/src/main/java/org/infinispan/query/impl/CacheQueryImpl.java\nindex f4c31299b4..c9796770bd 100644\n--- a/query/src/main/java/org/infinispan/query/impl/CacheQueryImpl.java\n+++ b/query/src/main/java/org/infinispan/query/impl/CacheQueryImpl.java\n", "chunk": "@@ -90,35 +57,7 @@ public IndexedQuery<E> filter(Filter filter) {\n    @Override\n    public int getResultSize() {\n       partitionHandlingSupport.checkCacheAvailable();\n-      return queryDefinition.getHsQuery().queryResultSize();\n-   }\n-\n-   @Override\n-   public IndexedQuery<E> sort(Sort sort) {\n-      queryDefinition.setSort(sort);\n-      return this;\n-   }\n-\n-   /**\n-    * Enable a given filter by its name.\n-    *\n-    * @param name of filter.\n-    * @return a FullTextFilter object.\n-    */\n-   @Override\n-   public FullTextFilter enableFullTextFilter(String name) {\n-      return queryDefinition.enableFullTextFilter(name);\n-   }\n-\n-   /**\n-    * Disable a given filter by its name.\n-    *\n-    * @param name of filter.\n-    */\n-   @Override\n-   public IndexedQuery<E> disableFullTextFilter(String name) {\n-      queryDefinition.disableFullTextFilter(name);\n-      return this;\n+      return Math.toIntExact(queryDefinition.getSearchQuery().build().fetchTotalHitCount());\n    }\n \n    /**\n", "next_change": {"commit": "b76eeeee768bb075a447e35324baa3d6986830f1", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/impl/CacheQueryImpl.java b/query/src/main/java/org/infinispan/query/impl/CacheQueryImpl.java\nindex c9796770bd..0a6042fe64 100644\n--- a/query/src/main/java/org/infinispan/query/impl/CacheQueryImpl.java\n+++ b/query/src/main/java/org/infinispan/query/impl/CacheQueryImpl.java\n", "chunk": "@@ -56,6 +60,10 @@ public CacheQueryImpl(SearchQueryBuilder searchQuery, AdvancedCache<?, ?> cache)\n     */\n    @Override\n    public int getResultSize() {\n+      if (resultSize != null) {\n+         return Math.toIntExact(resultSize);\n+      }\n+\n       partitionHandlingSupport.checkCacheAvailable();\n       return Math.toIntExact(queryDefinition.getSearchQuery().build().fetchTotalHitCount());\n    }\n", "next_change": {"commit": "917da575b1ba55b0147d9cbeb1e553e3b24fc837", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/impl/CacheQueryImpl.java b/query/src/main/java/org/infinispan/query/impl/CacheQueryImpl.java\nindex 0a6042fe64..c9796770bd 100644\n--- a/query/src/main/java/org/infinispan/query/impl/CacheQueryImpl.java\n+++ b/query/src/main/java/org/infinispan/query/impl/CacheQueryImpl.java\n", "chunk": "@@ -60,10 +56,6 @@ public CacheQueryImpl(SearchQueryBuilder searchQuery, AdvancedCache<?, ?> cache)\n     */\n    @Override\n    public int getResultSize() {\n-      if (resultSize != null) {\n-         return Math.toIntExact(resultSize);\n-      }\n-\n       partitionHandlingSupport.checkCacheAvailable();\n       return Math.toIntExact(queryDefinition.getSearchQuery().build().fetchTotalHitCount());\n    }\n", "next_change": {"commit": "d8d307f379ffaa6ca9b4d670e4abe4e0f2ae33f3", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/impl/CacheQueryImpl.java b/query/src/main/java/org/infinispan/query/impl/CacheQueryImpl.java\nindex c9796770bd..0a6042fe64 100644\n--- a/query/src/main/java/org/infinispan/query/impl/CacheQueryImpl.java\n+++ b/query/src/main/java/org/infinispan/query/impl/CacheQueryImpl.java\n", "chunk": "@@ -56,6 +60,10 @@ public CacheQueryImpl(SearchQueryBuilder searchQuery, AdvancedCache<?, ?> cache)\n     */\n    @Override\n    public int getResultSize() {\n+      if (resultSize != null) {\n+         return Math.toIntExact(resultSize);\n+      }\n+\n       partitionHandlingSupport.checkCacheAvailable();\n       return Math.toIntExact(queryDefinition.getSearchQuery().build().fetchTotalHitCount());\n    }\n", "next_change": {"commit": "10f23a187bce36db7fa046a4541c77808b6b3f8a", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/impl/CacheQueryImpl.java b/query/src/main/java/org/infinispan/query/impl/CacheQueryImpl.java\nindex 0a6042fe64..c9796770bd 100644\n--- a/query/src/main/java/org/infinispan/query/impl/CacheQueryImpl.java\n+++ b/query/src/main/java/org/infinispan/query/impl/CacheQueryImpl.java\n", "chunk": "@@ -60,10 +56,6 @@ public CacheQueryImpl(SearchQueryBuilder searchQuery, AdvancedCache<?, ?> cache)\n     */\n    @Override\n    public int getResultSize() {\n-      if (resultSize != null) {\n-         return Math.toIntExact(resultSize);\n-      }\n-\n       partitionHandlingSupport.checkCacheAvailable();\n       return Math.toIntExact(queryDefinition.getSearchQuery().build().fetchTotalHitCount());\n    }\n", "next_change": null}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "91d194f1a4e6f6990903ea42094be659142bb4d5", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/impl/CacheQueryImpl.java b/query/src/main/java/org/infinispan/query/impl/CacheQueryImpl.java\nindex 367ed7c990..c9796770bd 100644\n--- a/query/src/main/java/org/infinispan/query/impl/CacheQueryImpl.java\n+++ b/query/src/main/java/org/infinispan/query/impl/CacheQueryImpl.java\n", "chunk": "@@ -39,9 +38,6 @@\n    protected final PartitionHandlingSupport partitionHandlingSupport;\n    protected QueryDefinition queryDefinition;\n \n-   // caching result size, since Search 6 doesn't do that\n-   private Long resultSize;\n-\n    public CacheQueryImpl(QueryDefinition queryDefinition, AdvancedCache<?, ?> cache) {\n       this.queryDefinition = queryDefinition;\n       this.cache = cache;\n", "next_change": {"commit": "86be6afd3a356a47b5be033c2bd65ff79acfef2b", "changed_code": [{"header": "diff --git a/query/src/main/java/org/infinispan/query/impl/CacheQueryImpl.java b/query/src/main/java/org/infinispan/query/impl/IndexedQueryImpl.java\nsimilarity index 56%\nrename from query/src/main/java/org/infinispan/query/impl/CacheQueryImpl.java\nrename to query/src/main/java/org/infinispan/query/impl/IndexedQueryImpl.java\nindex c9796770bd..73ecb26991 100644\n--- a/query/src/main/java/org/infinispan/query/impl/CacheQueryImpl.java\n+++ b/query/src/main/java/org/infinispan/query/impl/IndexedQueryImpl.java\n", "chunk": "@@ -1,44 +1,32 @@\n package org.infinispan.query.impl;\n \n import java.util.List;\n+import java.util.Objects;\n import java.util.concurrent.TimeUnit;\n \n-import org.apache.lucene.search.Explanation;\n-import org.hibernate.search.backend.lucene.LuceneExtension;\n-import org.hibernate.search.backend.lucene.search.query.LuceneSearchQuery;\n import org.hibernate.search.engine.search.query.SearchQuery;\n import org.hibernate.search.util.common.SearchException;\n import org.infinispan.AdvancedCache;\n-import org.infinispan.query.FetchOptions;\n-import org.infinispan.query.FetchOptions.FetchMode;\n-import org.infinispan.query.ResultIterator;\n+import org.infinispan.commons.util.CloseableIterator;\n+import org.infinispan.commons.util.FilterIterator;\n import org.infinispan.query.core.impl.PartitionHandlingSupport;\n import org.infinispan.query.dsl.embedded.impl.SearchQueryBuilder;\n \n /**\n- * Implementation class of the CacheQuery interface.\n+ * Implementation class of the Lucene based query interface.\n  * <p/>\n  *\n  * @author Navin Surtani\n  * @author Sanne Grinovero &lt;sanne@hibernate.org&gt; (C) 2011 Red Hat Inc.\n  * @author Marko Luksa\n  */\n-public class CacheQueryImpl<E> implements IndexedQuery<E> {\n-\n-   /**\n-    * Since CacheQuery extends {@link Iterable} it is possible to implicitly invoke\n-    * {@link #iterator()} in an \"enhanced for loop\".\n-    * When using the {@link FetchMode#LAZY} it is mandatory to close the {@link ResultIterator},\n-    * but users of the enhanced loop have no chance to invoke the method.\n-    * Therefore, it's important that the default fetch options use EAGER iteration.\n-    */\n-   private static final FetchOptions DEFAULT_FETCH_OPTIONS = new FetchOptions().fetchMode(FetchMode.EAGER);\n+public class IndexedQueryImpl<E> implements IndexedQuery<E> {\n \n    protected final AdvancedCache<?, ?> cache;\n    protected final PartitionHandlingSupport partitionHandlingSupport;\n    protected QueryDefinition queryDefinition;\n \n-   public CacheQueryImpl(QueryDefinition queryDefinition, AdvancedCache<?, ?> cache) {\n+   public IndexedQueryImpl(QueryDefinition queryDefinition, AdvancedCache<?, ?> cache) {\n       this.queryDefinition = queryDefinition;\n       this.cache = cache;\n       this.partitionHandlingSupport = new PartitionHandlingSupport(cache);\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "91d194f1a4e6f6990903ea42094be659142bb4d5", "message": "Merge commit", "committedDate": null}, {"oid": "86be6afd3a356a47b5be033c2bd65ff79acfef2b", "committedDate": "2020-08-12 09:48:25 +0100", "message": "ISPN-12189 Remove deprecated indexed query classes"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM2Mzc1MQ==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r459363751", "body": "Why this change ? LOCAL_HEAP_DIRECTORY_PROVIDER is \"local-heap\" \r\n", "bodyText": "Why this change ? LOCAL_HEAP_DIRECTORY_PROVIDER is \"local-heap\"", "bodyHTML": "<p dir=\"auto\">Why this change ? LOCAL_HEAP_DIRECTORY_PROVIDER is \"local-heap\"</p>", "author": "anistor", "createdAt": "2020-07-23T10:47:35Z", "path": "core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java", "diffHunk": "@@ -320,9 +320,9 @@ public IndexingConfiguration create() {\n       // check for presence of index providers that are not persistent upon restart\n       boolean isVolatile = typedProperties.entrySet().stream()\n                                      .anyMatch(e -> {\n-                                        if (((String) e.getKey()).endsWith(DIRECTORY_PROVIDER_SUFFIX)) {\n+                                        if (((String) e.getKey()).endsWith(\"directory.type\")) {\n                                            String directoryImplementationName = String.valueOf(e.getValue()).trim();\n-                                           return LOCAL_HEAP_DIRECTORY_PROVIDER.equalsIgnoreCase(directoryImplementationName)\n+                                           return \"local-heap\".equalsIgnoreCase(directoryImplementationName)", "originalCommit": "973742666427584064f0529d85af66024e57d0ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM4MjYwOA==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r459382608", "bodyText": "Ideally I would have not wanted to change the core at all. This is (and the subsequent comment is about this same change) the only change we did to the ISPN core. The reason is that isVolatile must be true if and only if the local heap is used as directory type and we have different names in Search 6 for such property (key and value). I don't know actually if there is any other way to reach the same goal.", "author": "fax4ever", "createdAt": "2020-07-23T11:29:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM2Mzc1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM4Mzc0Mg==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r459383742", "bodyText": "Sorry I didn't see well the constant value. Yes I think we can use it. I'm changing it...", "author": "fax4ever", "createdAt": "2020-07-23T11:32:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM2Mzc1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "6300e5d5e53a1e59b9349292cdc7d87ce9d476da", "changed_code": [{"header": "diff --git a/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java b/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\nindex 0799ada813..57d47c2abf 100644\n--- a/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\n+++ b/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\n", "chunk": "@@ -320,9 +321,9 @@ public IndexingConfiguration create() {\n       // check for presence of index providers that are not persistent upon restart\n       boolean isVolatile = typedProperties.entrySet().stream()\n                                      .anyMatch(e -> {\n-                                        if (((String) e.getKey()).endsWith(\"directory.type\")) {\n+                                        if (((String) e.getKey()).endsWith(DIRECTORY_PROVIDER_SUFFIX)) {\n                                            String directoryImplementationName = String.valueOf(e.getValue()).trim();\n-                                           return \"local-heap\".equalsIgnoreCase(directoryImplementationName)\n+                                           return LOCAL_HEAP_DIRECTORY_PROVIDER.equalsIgnoreCase(directoryImplementationName)\n                                                  || LOCAL_HEAP_DIRECTORY_PROVIDER_FQN.equalsIgnoreCase(directoryImplementationName)\n                                                  || RAM_DIRECTORY_PROVIDER.equals(directoryImplementationName);\n                                         }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "91d194f1a4e6f6990903ea42094be659142bb4d5", "changed_code": [{"header": "diff --git a/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java b/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\nindex 0799ada813..b31663d479 100644\n--- a/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\n+++ b/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\n", "chunk": "@@ -320,9 +320,9 @@ public IndexingConfiguration create() {\n       // check for presence of index providers that are not persistent upon restart\n       boolean isVolatile = typedProperties.entrySet().stream()\n                                      .anyMatch(e -> {\n-                                        if (((String) e.getKey()).endsWith(\"directory.type\")) {\n+                                        if (((String) e.getKey()).endsWith(DIRECTORY_PROVIDER_SUFFIX)) {\n                                            String directoryImplementationName = String.valueOf(e.getValue()).trim();\n-                                           return \"local-heap\".equalsIgnoreCase(directoryImplementationName)\n+                                           return LOCAL_HEAP_DIRECTORY_PROVIDER.equalsIgnoreCase(directoryImplementationName)\n                                                  || LOCAL_HEAP_DIRECTORY_PROVIDER_FQN.equalsIgnoreCase(directoryImplementationName)\n                                                  || RAM_DIRECTORY_PROVIDER.equals(directoryImplementationName);\n                                         }\n", "next_change": {"commit": "27013524412dd967281110da5edd13d20b956941", "changed_code": [{"header": "diff --git a/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java b/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\nindex b31663d479..9cde79c25f 100644\n--- a/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\n+++ b/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\n", "chunk": "@@ -309,45 +365,92 @@ private void applyAutoConfig(TypedProperties properties) {\n    @Override\n    public IndexingConfiguration create() {\n       TypedProperties typedProperties = attributes.attribute(PROPERTIES).get();\n+      if (typedProperties.size() > 0) {\n+         CONFIG.indexingPropertiesDeprecated(typedProperties);\n+         applyLegacyProperties(typedProperties);\n+      }\n       if (autoConfig()) {\n          applyAutoConfig(typedProperties);\n          attributes.attribute(PROPERTIES).set(typedProperties);\n \n-         // check that after autoconfig we still do not have multiple configured providers\n-         ensureSingleIndexingProvider();\n+         // check that after autoConfig we still do not have multiple configured providers\n+         ensureSingleIndexingConfig();\n       }\n \n-      // check for presence of index providers that are not persistent upon restart\n-      boolean isVolatile = typedProperties.entrySet().stream()\n-                                     .anyMatch(e -> {\n-                                        if (((String) e.getKey()).endsWith(DIRECTORY_PROVIDER_SUFFIX)) {\n-                                           String directoryImplementationName = String.valueOf(e.getValue()).trim();\n-                                           return LOCAL_HEAP_DIRECTORY_PROVIDER.equalsIgnoreCase(directoryImplementationName)\n-                                                 || LOCAL_HEAP_DIRECTORY_PROVIDER_FQN.equalsIgnoreCase(directoryImplementationName)\n-                                                 || RAM_DIRECTORY_PROVIDER.equals(directoryImplementationName);\n-                                        }\n-                                        return false;\n-                                     });\n-\n       // todo [anistor] if storage media type is not configured then log a warning because this is not supported with indexing\n+      if (enabled()) {\n+         IndexStorage storage = attributes.attribute(STORAGE).get();\n+         if (storage.equals(IndexStorage.LOCAL_HEAP)) {\n+            typedProperties.put(DIRECTORY_PROVIDER_KEY, LOCAL_HEAP_DIRECTORY_PROVIDER);\n+         } else {\n+            typedProperties.put(DIRECTORY_PROVIDER_KEY, FS_PROVIDER);\n+            String path = attributes.attribute(PATH).get();\n+            if (path != null) {\n+               typedProperties.put(DIRECTORY_ROOT_KEY, StringPropertyReplacer.replaceProperties(path));\n+            }\n+         }\n+         typedProperties.putAll(readerConfigurationBuilder.asInternalProperties());\n+         typedProperties.putAll(writerConfigurationBuilder.asInternalProperties());\n+      }\n \n-      return new IndexingConfiguration(attributes.protect(), isVolatile, resolvedIndexedClasses);\n+      return new IndexingConfiguration(attributes.protect(), resolvedIndexedClasses, readerConfigurationBuilder.create(), writerConfigurationBuilder.create());\n+   }\n+\n+   /**\n+    * Apply ISPN 11 index properties\n+    */\n+   private void applyLegacyProperties(TypedProperties properties) {\n+      properties.forEach((k, v) -> {\n+         String prop = k.toString();\n+         String propValue = v.toString();\n+         if (prop.endsWith(\".directory_provider\")) {\n+            if (LOCAL_HEAP_DIRECTORY_PROVIDER.equals(propValue)) {\n+               storage(IndexStorage.LOCAL_HEAP);\n+            } else {\n+               storage(IndexStorage.FILESYSTEM);\n+            }\n+         }\n+         if (prop.endsWith(\".indexBase\")) path(propValue);\n+         if (prop.endsWith(\".merge_factor\")) writer().merge().factor(Integer.parseInt(propValue));\n+         if (prop.endsWith(\".merge_max_size\")) writer().merge().maxSize(Integer.parseInt(propValue));\n+         if (prop.endsWith(\".ram_buffer_size\")) writer().ramBufferSize(Integer.parseInt(propValue));\n+         if (prop.endsWith(\".index_flush_interval\")) writer().commitInterval(Integer.parseInt(propValue));\n+         if (prop.endsWith(\".reader.async_refresh_period_ms\")) reader().refreshInterval(Long.parseLong(propValue));\n+      });\n    }\n \n    @Override\n    public IndexingConfigurationBuilder read(IndexingConfiguration template) {\n       attributes.read(template.attributes());\n+\n+      // ensures inheritance works properly even when inheriting from an old config\n+      // that uses INDEX or AUTO_CONFIG instead of ENABLED\n+      Index index = attributes.attribute(INDEX).get();\n+      if (index != null) {\n+         enabled(index != Index.NONE);\n+      }\n+      if (autoConfig() && !attributes.attribute(ENABLED).isModified()) {\n+         enable();\n+      }\n+      this.resolvedIndexedClasses.clear();\n+      this.resolvedIndexedClasses.addAll(template.indexedEntities());\n+      this.readerConfigurationBuilder.read(template.reader());\n+      this.writerConfigurationBuilder.read(template.writer());\n       return this;\n    }\n \n    @Override\n-   public ElementDefinition getElementDefinition() {\n+   public ElementDefinition<IndexingConfiguration> getElementDefinition() {\n       return IndexingConfiguration.ELEMENT_DEFINITION;\n    }\n \n    @Override\n    public String toString() {\n-      return \"IndexingConfigurationBuilder [attributes=\" + attributes + \"]\";\n+      return \"IndexingConfigurationBuilder{\" +\n+            \"attributes=\" + attributes +\n+            \", readerConfigurationBuilder=\" + readerConfigurationBuilder +\n+            \", writerConfigurationBuilder=\" + writerConfigurationBuilder +\n+            '}';\n    }\n \n    @Override\n", "next_change": {"commit": "b28d3509a72f5bf62229034927e31b9bbc300c55", "changed_code": [{"header": "diff --git a/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java b/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\nindex 9cde79c25f..963af15fc3 100644\n--- a/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\n+++ b/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\n", "chunk": "@@ -453,8 +430,4 @@ public String toString() {\n             '}';\n    }\n \n-   @Override\n-   public AttributeSet attributes() {\n-      return attributes;\n-   }\n }\n", "next_change": {"commit": "1b92b4e1c4bffc50a0dbcdb55a0150acb2fb1511", "changed_code": [{"header": "diff --git a/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java b/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\nindex 963af15fc3..7267644e2c 100644\n--- a/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\n+++ b/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\n", "chunk": "@@ -427,6 +454,7 @@ public String toString() {\n             \"attributes=\" + attributes +\n             \", readerConfigurationBuilder=\" + readerConfigurationBuilder +\n             \", writerConfigurationBuilder=\" + writerConfigurationBuilder +\n+            \", shardingConfigurationBuilder=\" + shardingConfigurationBuilder +\n             '}';\n    }\n \n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "91d194f1a4e6f6990903ea42094be659142bb4d5", "message": "Merge commit", "committedDate": null}, {"oid": "22c19b04a499f541a8b102696ddc5fc3ec86c7ab", "committedDate": "2020-10-02 14:35:40 +0300", "message": "ISPN-12357 Indexing configurations should not be inherited when explicitly disabled"}, {"oid": "977d9301785ce917e98af6558d2ae77f7c27f5cf", "committedDate": "2020-10-02 18:18:48 +0300", "message": "ISPN-12286 Indexed entity declaration not enforced"}, {"oid": "33b6d6926e70da85b82cf2ac3de8ba4eb79df063", "committedDate": "2020-10-20 07:39:42 +0100", "message": "ISPN-12406 Simplify the configuration key for the Hibernate Search backend"}, {"oid": "84abfbbecb828aa16940c7644c4a93065c62d0ea", "committedDate": "2020-11-02 19:30:34 +0100", "message": "ISPN-12401 Support for query and indexing statistics"}, {"oid": "27013524412dd967281110da5edd13d20b956941", "committedDate": "2020-11-27 15:54:21 +0100", "message": "ISPN-11797 Introduce strong typed indexing configuration"}, {"oid": "07bd31c9c97114386a341d730d624f29033427a3", "committedDate": "2021-01-18 16:21:14 +0100", "message": "ISPN-12535 Fix WARN messages org.hibernate.search"}, {"oid": "995b8205fbca775317e1ae85b94850f1004ff3cf", "committedDate": "2021-01-21 10:05:02 +0000", "message": "ISPN-12536 Use the global storage to store indexes in the server"}, {"oid": "b28d3509a72f5bf62229034927e31b9bbc300c55", "committedDate": "2021-08-16 15:51:56 +0100", "message": "ISPN-12722 Config I/O for JSON"}, {"oid": "0ec2209a5588917b5f133bbb54b51d484b23128d", "committedDate": "2022-04-28 17:22:29 +0200", "message": "ISPN-13784 Add indexing startup mode config"}, {"oid": "6e0f2a21a695ce4210b9550a1f5dfd042243bb09", "committedDate": "2022-04-28 17:22:29 +0200", "message": "ISPN-13784 Parse the startup mode indexing property"}, {"oid": "d8a298755d6a8826141195deb9462dc961b0a8d5", "committedDate": "2023-01-25 13:14:37 +0000", "message": "ISPN-14423 Make all Builders return the AttributeSet"}, {"oid": "85c7a8e3f47876702c21f812fb7e922b764d3ef5", "committedDate": "2023-04-14 12:52:25 +0200", "message": "ISPN-14722 Add indexing mode config"}, {"oid": "1b92b4e1c4bffc50a0dbcdb55a0150acb2fb1511", "committedDate": "2023-04-14 12:52:25 +0200", "message": "ISPN-14723 Add index sharding config"}, {"oid": "6a64683e75d7972c5515e29625475b591bfcb168", "committedDate": "2023-04-14 12:52:25 +0200", "message": "ISPN-14575 Remove indexing properties and auto-config"}, {"oid": "c0bf2a461c8e60c6f6bcd3785dcd0239a54fff5f", "committedDate": "2023-04-14 12:52:25 +0200", "message": "ISPN-14575 Remove deprecated indexing > index property"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM2NDM1MQ==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r459364351", "body": "DIRECTORY_PROVIDER_SUFFIX should probably become \"directory.type\". It is used in other places in this class, which I think are broken now unless we make the change", "bodyText": "DIRECTORY_PROVIDER_SUFFIX should probably become \"directory.type\". It is used in other places in this class, which I think are broken now unless we make the change", "bodyHTML": "<p dir=\"auto\">DIRECTORY_PROVIDER_SUFFIX should probably become \"directory.type\". It is used in other places in this class, which I think are broken now unless we make the change</p>", "author": "anistor", "createdAt": "2020-07-23T10:48:54Z", "path": "core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java", "diffHunk": "@@ -320,9 +320,9 @@ public IndexingConfiguration create() {\n       // check for presence of index providers that are not persistent upon restart\n       boolean isVolatile = typedProperties.entrySet().stream()\n                                      .anyMatch(e -> {\n-                                        if (((String) e.getKey()).endsWith(DIRECTORY_PROVIDER_SUFFIX)) {\n+                                        if (((String) e.getKey()).endsWith(\"directory.type\")) {", "originalCommit": "973742666427584064f0529d85af66024e57d0ab", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6300e5d5e53a1e59b9349292cdc7d87ce9d476da", "changed_code": [{"header": "diff --git a/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java b/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\nindex 0799ada813..57d47c2abf 100644\n--- a/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\n+++ b/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\n", "chunk": "@@ -320,9 +321,9 @@ public IndexingConfiguration create() {\n       // check for presence of index providers that are not persistent upon restart\n       boolean isVolatile = typedProperties.entrySet().stream()\n                                      .anyMatch(e -> {\n-                                        if (((String) e.getKey()).endsWith(\"directory.type\")) {\n+                                        if (((String) e.getKey()).endsWith(DIRECTORY_PROVIDER_SUFFIX)) {\n                                            String directoryImplementationName = String.valueOf(e.getValue()).trim();\n-                                           return \"local-heap\".equalsIgnoreCase(directoryImplementationName)\n+                                           return LOCAL_HEAP_DIRECTORY_PROVIDER.equalsIgnoreCase(directoryImplementationName)\n                                                  || LOCAL_HEAP_DIRECTORY_PROVIDER_FQN.equalsIgnoreCase(directoryImplementationName)\n                                                  || RAM_DIRECTORY_PROVIDER.equals(directoryImplementationName);\n                                         }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "91d194f1a4e6f6990903ea42094be659142bb4d5", "changed_code": [{"header": "diff --git a/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java b/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\nindex 0799ada813..b31663d479 100644\n--- a/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\n+++ b/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\n", "chunk": "@@ -320,9 +320,9 @@ public IndexingConfiguration create() {\n       // check for presence of index providers that are not persistent upon restart\n       boolean isVolatile = typedProperties.entrySet().stream()\n                                      .anyMatch(e -> {\n-                                        if (((String) e.getKey()).endsWith(\"directory.type\")) {\n+                                        if (((String) e.getKey()).endsWith(DIRECTORY_PROVIDER_SUFFIX)) {\n                                            String directoryImplementationName = String.valueOf(e.getValue()).trim();\n-                                           return \"local-heap\".equalsIgnoreCase(directoryImplementationName)\n+                                           return LOCAL_HEAP_DIRECTORY_PROVIDER.equalsIgnoreCase(directoryImplementationName)\n                                                  || LOCAL_HEAP_DIRECTORY_PROVIDER_FQN.equalsIgnoreCase(directoryImplementationName)\n                                                  || RAM_DIRECTORY_PROVIDER.equals(directoryImplementationName);\n                                         }\n", "next_change": {"commit": "27013524412dd967281110da5edd13d20b956941", "changed_code": [{"header": "diff --git a/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java b/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\nindex b31663d479..9cde79c25f 100644\n--- a/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\n+++ b/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\n", "chunk": "@@ -309,45 +365,92 @@ private void applyAutoConfig(TypedProperties properties) {\n    @Override\n    public IndexingConfiguration create() {\n       TypedProperties typedProperties = attributes.attribute(PROPERTIES).get();\n+      if (typedProperties.size() > 0) {\n+         CONFIG.indexingPropertiesDeprecated(typedProperties);\n+         applyLegacyProperties(typedProperties);\n+      }\n       if (autoConfig()) {\n          applyAutoConfig(typedProperties);\n          attributes.attribute(PROPERTIES).set(typedProperties);\n \n-         // check that after autoconfig we still do not have multiple configured providers\n-         ensureSingleIndexingProvider();\n+         // check that after autoConfig we still do not have multiple configured providers\n+         ensureSingleIndexingConfig();\n       }\n \n-      // check for presence of index providers that are not persistent upon restart\n-      boolean isVolatile = typedProperties.entrySet().stream()\n-                                     .anyMatch(e -> {\n-                                        if (((String) e.getKey()).endsWith(DIRECTORY_PROVIDER_SUFFIX)) {\n-                                           String directoryImplementationName = String.valueOf(e.getValue()).trim();\n-                                           return LOCAL_HEAP_DIRECTORY_PROVIDER.equalsIgnoreCase(directoryImplementationName)\n-                                                 || LOCAL_HEAP_DIRECTORY_PROVIDER_FQN.equalsIgnoreCase(directoryImplementationName)\n-                                                 || RAM_DIRECTORY_PROVIDER.equals(directoryImplementationName);\n-                                        }\n-                                        return false;\n-                                     });\n-\n       // todo [anistor] if storage media type is not configured then log a warning because this is not supported with indexing\n+      if (enabled()) {\n+         IndexStorage storage = attributes.attribute(STORAGE).get();\n+         if (storage.equals(IndexStorage.LOCAL_HEAP)) {\n+            typedProperties.put(DIRECTORY_PROVIDER_KEY, LOCAL_HEAP_DIRECTORY_PROVIDER);\n+         } else {\n+            typedProperties.put(DIRECTORY_PROVIDER_KEY, FS_PROVIDER);\n+            String path = attributes.attribute(PATH).get();\n+            if (path != null) {\n+               typedProperties.put(DIRECTORY_ROOT_KEY, StringPropertyReplacer.replaceProperties(path));\n+            }\n+         }\n+         typedProperties.putAll(readerConfigurationBuilder.asInternalProperties());\n+         typedProperties.putAll(writerConfigurationBuilder.asInternalProperties());\n+      }\n \n-      return new IndexingConfiguration(attributes.protect(), isVolatile, resolvedIndexedClasses);\n+      return new IndexingConfiguration(attributes.protect(), resolvedIndexedClasses, readerConfigurationBuilder.create(), writerConfigurationBuilder.create());\n+   }\n+\n+   /**\n+    * Apply ISPN 11 index properties\n+    */\n+   private void applyLegacyProperties(TypedProperties properties) {\n+      properties.forEach((k, v) -> {\n+         String prop = k.toString();\n+         String propValue = v.toString();\n+         if (prop.endsWith(\".directory_provider\")) {\n+            if (LOCAL_HEAP_DIRECTORY_PROVIDER.equals(propValue)) {\n+               storage(IndexStorage.LOCAL_HEAP);\n+            } else {\n+               storage(IndexStorage.FILESYSTEM);\n+            }\n+         }\n+         if (prop.endsWith(\".indexBase\")) path(propValue);\n+         if (prop.endsWith(\".merge_factor\")) writer().merge().factor(Integer.parseInt(propValue));\n+         if (prop.endsWith(\".merge_max_size\")) writer().merge().maxSize(Integer.parseInt(propValue));\n+         if (prop.endsWith(\".ram_buffer_size\")) writer().ramBufferSize(Integer.parseInt(propValue));\n+         if (prop.endsWith(\".index_flush_interval\")) writer().commitInterval(Integer.parseInt(propValue));\n+         if (prop.endsWith(\".reader.async_refresh_period_ms\")) reader().refreshInterval(Long.parseLong(propValue));\n+      });\n    }\n \n    @Override\n    public IndexingConfigurationBuilder read(IndexingConfiguration template) {\n       attributes.read(template.attributes());\n+\n+      // ensures inheritance works properly even when inheriting from an old config\n+      // that uses INDEX or AUTO_CONFIG instead of ENABLED\n+      Index index = attributes.attribute(INDEX).get();\n+      if (index != null) {\n+         enabled(index != Index.NONE);\n+      }\n+      if (autoConfig() && !attributes.attribute(ENABLED).isModified()) {\n+         enable();\n+      }\n+      this.resolvedIndexedClasses.clear();\n+      this.resolvedIndexedClasses.addAll(template.indexedEntities());\n+      this.readerConfigurationBuilder.read(template.reader());\n+      this.writerConfigurationBuilder.read(template.writer());\n       return this;\n    }\n \n    @Override\n-   public ElementDefinition getElementDefinition() {\n+   public ElementDefinition<IndexingConfiguration> getElementDefinition() {\n       return IndexingConfiguration.ELEMENT_DEFINITION;\n    }\n \n    @Override\n    public String toString() {\n-      return \"IndexingConfigurationBuilder [attributes=\" + attributes + \"]\";\n+      return \"IndexingConfigurationBuilder{\" +\n+            \"attributes=\" + attributes +\n+            \", readerConfigurationBuilder=\" + readerConfigurationBuilder +\n+            \", writerConfigurationBuilder=\" + writerConfigurationBuilder +\n+            '}';\n    }\n \n    @Override\n", "next_change": {"commit": "b28d3509a72f5bf62229034927e31b9bbc300c55", "changed_code": [{"header": "diff --git a/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java b/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\nindex 9cde79c25f..963af15fc3 100644\n--- a/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\n+++ b/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\n", "chunk": "@@ -453,8 +430,4 @@ public String toString() {\n             '}';\n    }\n \n-   @Override\n-   public AttributeSet attributes() {\n-      return attributes;\n-   }\n }\n", "next_change": {"commit": "1b92b4e1c4bffc50a0dbcdb55a0150acb2fb1511", "changed_code": [{"header": "diff --git a/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java b/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\nindex 963af15fc3..7267644e2c 100644\n--- a/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\n+++ b/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\n", "chunk": "@@ -427,6 +454,7 @@ public String toString() {\n             \"attributes=\" + attributes +\n             \", readerConfigurationBuilder=\" + readerConfigurationBuilder +\n             \", writerConfigurationBuilder=\" + writerConfigurationBuilder +\n+            \", shardingConfigurationBuilder=\" + shardingConfigurationBuilder +\n             '}';\n    }\n \n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "91d194f1a4e6f6990903ea42094be659142bb4d5", "message": "Merge commit", "committedDate": null}, {"oid": "22c19b04a499f541a8b102696ddc5fc3ec86c7ab", "committedDate": "2020-10-02 14:35:40 +0300", "message": "ISPN-12357 Indexing configurations should not be inherited when explicitly disabled"}, {"oid": "977d9301785ce917e98af6558d2ae77f7c27f5cf", "committedDate": "2020-10-02 18:18:48 +0300", "message": "ISPN-12286 Indexed entity declaration not enforced"}, {"oid": "33b6d6926e70da85b82cf2ac3de8ba4eb79df063", "committedDate": "2020-10-20 07:39:42 +0100", "message": "ISPN-12406 Simplify the configuration key for the Hibernate Search backend"}, {"oid": "84abfbbecb828aa16940c7644c4a93065c62d0ea", "committedDate": "2020-11-02 19:30:34 +0100", "message": "ISPN-12401 Support for query and indexing statistics"}, {"oid": "27013524412dd967281110da5edd13d20b956941", "committedDate": "2020-11-27 15:54:21 +0100", "message": "ISPN-11797 Introduce strong typed indexing configuration"}, {"oid": "07bd31c9c97114386a341d730d624f29033427a3", "committedDate": "2021-01-18 16:21:14 +0100", "message": "ISPN-12535 Fix WARN messages org.hibernate.search"}, {"oid": "995b8205fbca775317e1ae85b94850f1004ff3cf", "committedDate": "2021-01-21 10:05:02 +0000", "message": "ISPN-12536 Use the global storage to store indexes in the server"}, {"oid": "b28d3509a72f5bf62229034927e31b9bbc300c55", "committedDate": "2021-08-16 15:51:56 +0100", "message": "ISPN-12722 Config I/O for JSON"}, {"oid": "0ec2209a5588917b5f133bbb54b51d484b23128d", "committedDate": "2022-04-28 17:22:29 +0200", "message": "ISPN-13784 Add indexing startup mode config"}, {"oid": "6e0f2a21a695ce4210b9550a1f5dfd042243bb09", "committedDate": "2022-04-28 17:22:29 +0200", "message": "ISPN-13784 Parse the startup mode indexing property"}, {"oid": "d8a298755d6a8826141195deb9462dc961b0a8d5", "committedDate": "2023-01-25 13:14:37 +0000", "message": "ISPN-14423 Make all Builders return the AttributeSet"}, {"oid": "85c7a8e3f47876702c21f812fb7e922b764d3ef5", "committedDate": "2023-04-14 12:52:25 +0200", "message": "ISPN-14722 Add indexing mode config"}, {"oid": "1b92b4e1c4bffc50a0dbcdb55a0150acb2fb1511", "committedDate": "2023-04-14 12:52:25 +0200", "message": "ISPN-14723 Add index sharding config"}, {"oid": "6a64683e75d7972c5515e29625475b591bfcb168", "committedDate": "2023-04-14 12:52:25 +0200", "message": "ISPN-14575 Remove indexing properties and auto-config"}, {"oid": "c0bf2a461c8e60c6f6bcd3785dcd0239a54fff5f", "committedDate": "2023-04-14 12:52:25 +0200", "message": "ISPN-14575 Remove deprecated indexing > index property"}]}, {"oid": "6300e5d5e53a1e59b9349292cdc7d87ce9d476da", "url": "https://github.com/infinispan/infinispan/commit/6300e5d5e53a1e59b9349292cdc7d87ce9d476da", "message": "ISPN-10249 Avoid to change the deprecated interface\n\nUnfortunately IndexedTypeMap is a Hibernate Search 5\u2019s class, so I think we had to remove it.", "committedDate": "2020-07-23T12:43:55Z", "type": "forcePushed"}, {"oid": "32718114c38cd1cf83048d759033d952387d0a7e", "url": "https://github.com/infinispan/infinispan/commit/32718114c38cd1cf83048d759033d952387d0a7e", "message": "ISPN-10249 Add ISPN search mapper module", "committedDate": "2020-07-24T07:23:53Z", "type": "commit"}, {"oid": "51d3df78264303cd72212e2cd169a0bf89349736", "url": "https://github.com/infinispan/infinispan/commit/51d3df78264303cd72212e2cd169a0bf89349736", "message": "ISPN-10249 Introduce pseudo-HS5 annotation support", "committedDate": "2020-07-24T07:23:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTkzNDU1Mw==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r459934553", "body": "I suspect the suffix ```directory_provider``` here also must become ```directory.type```", "bodyText": "I suspect the suffix directory_provider here also must become directory.type", "bodyHTML": "<p dir=\"auto\">I suspect the suffix <code>directory_provider</code> here also must become <code>directory.type</code></p>", "author": "anistor", "createdAt": "2020-07-24T09:02:13Z", "path": "core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java", "diffHunk": "@@ -29,11 +29,12 @@\n  */\n public class IndexingConfigurationBuilder extends AbstractConfigurationChildBuilder implements Builder<IndexingConfiguration>, ConfigurationBuilderInfo {\n \n-   private static final String DIRECTORY_PROVIDER_SUFFIX = \".directory_provider\";\n+   private static final String DIRECTORY_PROVIDER_SUFFIX = \"directory.type\";\n \n+   // TODO Check if *KEY1* can be used\n    private static final String DIRECTORY_PROVIDER_KEY1 = \"hibernate.search.default.directory_provider\";", "originalCommit": "55832fad3a9ae160316397b34fb49e0af665d09f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk0OTQzOA==", "url": "https://github.com/infinispan/infinispan/pull/8571#discussion_r459949438", "bodyText": "Doing the change now... Anyway the full property path is hibernate.search.backends.infinispan_backend.directory.type, see org.infinispan.search.mapper.mapping.impl.IndexProperties, in particular the line:\nonfigurationPropertySource basePropertySource =\n            propertyChecker.wrap(ConfigurationPropertySource.fromMap(backendProperties))\n                  .withPrefix(BACKEND_PROPERTIES_PREFIX);\nOf course you can arrange the simplification of the path as you wish, I did here an example of that.", "author": "fax4ever", "createdAt": "2020-07-24T09:32:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTkzNDU1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "b76eeeee768bb075a447e35324baa3d6986830f1", "changed_code": [{"header": "diff --git a/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java b/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\nindex 57d47c2abf..b31663d479 100644\n--- a/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\n+++ b/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\n", "chunk": "@@ -31,8 +31,7 @@ public class IndexingConfigurationBuilder extends AbstractConfigurationChildBuil\n \n    private static final String DIRECTORY_PROVIDER_SUFFIX = \"directory.type\";\n \n-   // TODO Check if *KEY1* can be used\n-   private static final String DIRECTORY_PROVIDER_KEY1 = \"hibernate.search.default.directory_provider\";\n+   private static final String DIRECTORY_PROVIDER_KEY1 = \"hibernate.search.backends.infinispan_backend.directory.type\";\n \n    private static final String DIRECTORY_PROVIDER_KEY2 = \"directory.type\";\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "91d194f1a4e6f6990903ea42094be659142bb4d5", "changed_code": [{"header": "diff --git a/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java b/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\nindex 57d47c2abf..b31663d479 100644\n--- a/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\n+++ b/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\n", "chunk": "@@ -31,8 +31,7 @@ public class IndexingConfigurationBuilder extends AbstractConfigurationChildBuil\n \n    private static final String DIRECTORY_PROVIDER_SUFFIX = \"directory.type\";\n \n-   // TODO Check if *KEY1* can be used\n-   private static final String DIRECTORY_PROVIDER_KEY1 = \"hibernate.search.default.directory_provider\";\n+   private static final String DIRECTORY_PROVIDER_KEY1 = \"hibernate.search.backends.infinispan_backend.directory.type\";\n \n    private static final String DIRECTORY_PROVIDER_KEY2 = \"directory.type\";\n \n", "next_change": {"commit": "33b6d6926e70da85b82cf2ac3de8ba4eb79df063", "changed_code": [{"header": "diff --git a/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java b/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\nindex b31663d479..a05e2fd077 100644\n--- a/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\n+++ b/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\n", "chunk": "@@ -31,7 +31,7 @@ public class IndexingConfigurationBuilder extends AbstractConfigurationChildBuil\n \n    private static final String DIRECTORY_PROVIDER_SUFFIX = \"directory.type\";\n \n-   private static final String DIRECTORY_PROVIDER_KEY1 = \"hibernate.search.backends.infinispan_backend.directory.type\";\n+   private static final String DIRECTORY_PROVIDER_KEY1 = \"hibernate.search.backend.directory.type\";\n \n    private static final String DIRECTORY_PROVIDER_KEY2 = \"directory.type\";\n \n", "next_change": {"commit": "27013524412dd967281110da5edd13d20b956941", "changed_code": [{"header": "diff --git a/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java b/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\nindex a05e2fd077..9cde79c25f 100644\n--- a/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\n+++ b/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\n", "chunk": "@@ -27,13 +33,13 @@\n /**\n  * Configures indexing of entries in the cache for searching.\n  */\n-public class IndexingConfigurationBuilder extends AbstractConfigurationChildBuilder implements Builder<IndexingConfiguration>, ConfigurationBuilderInfo {\n+public class IndexingConfigurationBuilder extends AbstractConfigurationChildBuilder implements IndexingConfigurationChildBuilder, Builder<IndexingConfiguration>, ConfigurationBuilderInfo {\n \n-   private static final String DIRECTORY_PROVIDER_SUFFIX = \"directory.type\";\n+   private static final String BACKEND_PREFIX = \"hibernate.search.backend.\";\n \n-   private static final String DIRECTORY_PROVIDER_KEY1 = \"hibernate.search.backend.directory.type\";\n+   private static final String DIRECTORY_PROVIDER_KEY = BACKEND_PREFIX + \"directory.type\";\n \n-   private static final String DIRECTORY_PROVIDER_KEY2 = \"directory.type\";\n+   private static final String DIRECTORY_ROOT_KEY = BACKEND_PREFIX + \"directory.root\";\n \n    private static final String EXCLUSIVE_INDEX_USE = \"hibernate.search.default.exclusive_index_use\";\n \n", "next_change": {"commit": "07bd31c9c97114386a341d730d624f29033427a3", "changed_code": [{"header": "diff --git a/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java b/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\nindex 9cde79c25f..175083e94a 100644\n--- a/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\n+++ b/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\n", "chunk": "@@ -39,8 +38,6 @@ public class IndexingConfigurationBuilder extends AbstractConfigurationChildBuil\n \n    private static final String DIRECTORY_PROVIDER_KEY = BACKEND_PREFIX + \"directory.type\";\n \n-   private static final String DIRECTORY_ROOT_KEY = BACKEND_PREFIX + \"directory.root\";\n-\n    private static final String EXCLUSIVE_INDEX_USE = \"hibernate.search.default.exclusive_index_use\";\n \n    private static final String INDEX_MANAGER = \"hibernate.search.default.indexmanager\";\n", "next_change": {"commit": "6a64683e75d7972c5515e29625475b591bfcb168", "changed_code": [{"header": "diff --git a/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java b/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\nindex 175083e94a..3de5566f5c 100644\n--- a/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\n+++ b/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\n", "chunk": "@@ -32,51 +29,27 @@\n /**\n  * Configures indexing of entries in the cache for searching.\n  */\n-public class IndexingConfigurationBuilder extends AbstractConfigurationChildBuilder implements IndexingConfigurationChildBuilder, Builder<IndexingConfiguration>, ConfigurationBuilderInfo {\n-\n-   private static final String BACKEND_PREFIX = \"hibernate.search.backend.\";\n-\n-   private static final String DIRECTORY_PROVIDER_KEY = BACKEND_PREFIX + \"directory.type\";\n-\n-   private static final String EXCLUSIVE_INDEX_USE = \"hibernate.search.default.exclusive_index_use\";\n-\n-   private static final String INDEX_MANAGER = \"hibernate.search.default.indexmanager\";\n-\n-   private static final String READER_STRATEGY = \"hibernate.search.default.reader.strategy\";\n-\n-   private static final String FS_PROVIDER = \"local-filesystem\";\n-\n-   /**\n-    * Legacy name \"ram\" was replaced by \"local-heap\" many years ago.\n-    *\n-    * @deprecated To be removed after migration to hibernate search 6, if the version no longer supports this legacy\n-    * name.\n-    */\n-   @Deprecated\n-   private static final String RAM_DIRECTORY_PROVIDER = \"ram\";\n-\n-   private static final String LOCAL_HEAP_DIRECTORY_PROVIDER = \"local-heap\";\n+public class IndexingConfigurationBuilder extends AbstractConfigurationChildBuilder implements IndexingConfigurationChildBuilder, Builder<IndexingConfiguration> {\n \n    private final AttributeSet attributes;\n \n    private final Set<Class<?>> resolvedIndexedClasses = new HashSet<>();\n \n-   private final List<ConfigurationBuilderInfo> subElements = new ArrayList<>();\n    private final IndexReaderConfigurationBuilder readerConfigurationBuilder;\n    private final IndexWriterConfigurationBuilder writerConfigurationBuilder;\n+   private final IndexShardingConfigurationBuilder shardingConfigurationBuilder;\n \n    IndexingConfigurationBuilder(ConfigurationBuilder builder) {\n       super(builder);\n       attributes = IndexingConfiguration.attributeDefinitionSet();\n       readerConfigurationBuilder = new IndexReaderConfigurationBuilder(this);\n       writerConfigurationBuilder = new IndexWriterConfigurationBuilder(this);\n-      this.subElements.add(readerConfigurationBuilder);\n-      this.subElements.add(writerConfigurationBuilder);\n+      shardingConfigurationBuilder = new IndexShardingConfigurationBuilder(this);\n    }\n \n    @Override\n-   public Collection<ConfigurationBuilderInfo> getChildrenInfo() {\n-      return subElements;\n+   public AttributeSet attributes() {\n+      return attributes;\n    }\n \n    public IndexingConfigurationBuilder enabled(boolean enabled) {\n", "next_change": {"commit": "c0bf2a461c8e60c6f6bcd3785dcd0239a54fff5f", "changed_code": [{"header": "diff --git a/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java b/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\nindex 3de5566f5c..f0bd84245f 100644\n--- a/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\n+++ b/core/src/main/java/org/infinispan/configuration/cache/IndexingConfigurationBuilder.java\n", "chunk": "@@ -53,9 +52,6 @@ public AttributeSet attributes() {\n    }\n \n    public IndexingConfigurationBuilder enabled(boolean enabled) {\n-      if (attributes.attribute(INDEX).isModified()) {\n-         throw CONFIG.indexEnabledAndIndexModeAreExclusive();\n-      }\n       if (!enabled) {\n          // discard any eventually inherited indexing config if indexing is not going to be enabled\n          reset();\n", "next_change": null}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "91d194f1a4e6f6990903ea42094be659142bb4d5", "message": "Merge commit", "committedDate": null}, {"oid": "22c19b04a499f541a8b102696ddc5fc3ec86c7ab", "committedDate": "2020-10-02 14:35:40 +0300", "message": "ISPN-12357 Indexing configurations should not be inherited when explicitly disabled"}, {"oid": "977d9301785ce917e98af6558d2ae77f7c27f5cf", "committedDate": "2020-10-02 18:18:48 +0300", "message": "ISPN-12286 Indexed entity declaration not enforced"}, {"oid": "33b6d6926e70da85b82cf2ac3de8ba4eb79df063", "committedDate": "2020-10-20 07:39:42 +0100", "message": "ISPN-12406 Simplify the configuration key for the Hibernate Search backend"}, {"oid": "84abfbbecb828aa16940c7644c4a93065c62d0ea", "committedDate": "2020-11-02 19:30:34 +0100", "message": "ISPN-12401 Support for query and indexing statistics"}, {"oid": "27013524412dd967281110da5edd13d20b956941", "committedDate": "2020-11-27 15:54:21 +0100", "message": "ISPN-11797 Introduce strong typed indexing configuration"}, {"oid": "07bd31c9c97114386a341d730d624f29033427a3", "committedDate": "2021-01-18 16:21:14 +0100", "message": "ISPN-12535 Fix WARN messages org.hibernate.search"}, {"oid": "995b8205fbca775317e1ae85b94850f1004ff3cf", "committedDate": "2021-01-21 10:05:02 +0000", "message": "ISPN-12536 Use the global storage to store indexes in the server"}, {"oid": "b28d3509a72f5bf62229034927e31b9bbc300c55", "committedDate": "2021-08-16 15:51:56 +0100", "message": "ISPN-12722 Config I/O for JSON"}, {"oid": "0ec2209a5588917b5f133bbb54b51d484b23128d", "committedDate": "2022-04-28 17:22:29 +0200", "message": "ISPN-13784 Add indexing startup mode config"}, {"oid": "6e0f2a21a695ce4210b9550a1f5dfd042243bb09", "committedDate": "2022-04-28 17:22:29 +0200", "message": "ISPN-13784 Parse the startup mode indexing property"}, {"oid": "d8a298755d6a8826141195deb9462dc961b0a8d5", "committedDate": "2023-01-25 13:14:37 +0000", "message": "ISPN-14423 Make all Builders return the AttributeSet"}, {"oid": "85c7a8e3f47876702c21f812fb7e922b764d3ef5", "committedDate": "2023-04-14 12:52:25 +0200", "message": "ISPN-14722 Add indexing mode config"}, {"oid": "1b92b4e1c4bffc50a0dbcdb55a0150acb2fb1511", "committedDate": "2023-04-14 12:52:25 +0200", "message": "ISPN-14723 Add index sharding config"}, {"oid": "6a64683e75d7972c5515e29625475b591bfcb168", "committedDate": "2023-04-14 12:52:25 +0200", "message": "ISPN-14575 Remove indexing properties and auto-config"}, {"oid": "c0bf2a461c8e60c6f6bcd3785dcd0239a54fff5f", "committedDate": "2023-04-14 12:52:25 +0200", "message": "ISPN-14575 Remove deprecated indexing > index property"}]}, {"oid": "bb18590bbe7e5e9948bca940518235678d1a4fae", "url": "https://github.com/infinispan/infinispan/commit/bb18590bbe7e5e9948bca940518235678d1a4fae", "message": "ISPN-10249 Avoid to cache result size in deprecated class", "committedDate": "2020-07-24T09:05:53Z", "type": "forcePushed"}, {"oid": "b76eeeee768bb075a447e35324baa3d6986830f1", "url": "https://github.com/infinispan/infinispan/commit/b76eeeee768bb075a447e35324baa3d6986830f1", "message": "ISPN-10249 Upgrade to Hibernate Search 6", "committedDate": "2020-07-24T11:59:20Z", "type": "commit"}, {"oid": "917da575b1ba55b0147d9cbeb1e553e3b24fc837", "url": "https://github.com/infinispan/infinispan/commit/917da575b1ba55b0147d9cbeb1e553e3b24fc837", "message": "ISPN-10249 Avoid to cache result size in deprecated class", "committedDate": "2020-07-24T11:59:20Z", "type": "forcePushed"}, {"oid": "d8d307f379ffaa6ca9b4d670e4abe4e0f2ae33f3", "url": "https://github.com/infinispan/infinispan/commit/d8d307f379ffaa6ca9b4d670e4abe4e0f2ae33f3", "message": "ISPN-10249 Use Search 6 configuration properties", "committedDate": "2020-07-24T14:33:02Z", "type": "commit"}, {"oid": "c83177e2efd0cf6eb026e5de93579765c2426db8", "url": "https://github.com/infinispan/infinispan/commit/c83177e2efd0cf6eb026e5de93579765c2426db8", "message": "ISPN-10249 Comment feature pack modules\n\nHibernate Search 6 does not provide feature packs", "committedDate": "2020-07-24T14:33:02Z", "type": "commit"}, {"oid": "752b631b9f1023ac64e64754df5d0d4471cb353a", "url": "https://github.com/infinispan/infinispan/commit/752b631b9f1023ac64e64754df5d0d4471cb353a", "message": "ISPN-10249 Filter indexed-protobuf entities by cache", "committedDate": "2020-07-24T14:33:02Z", "type": "commit"}, {"oid": "cf985dc7268a283902985cc777e9dff1425dabb6", "url": "https://github.com/infinispan/infinispan/commit/cf985dc7268a283902985cc777e9dff1425dabb6", "message": "ISPN-10249 Provide entity lists in cache configuration", "committedDate": "2020-07-24T14:33:02Z", "type": "commit"}, {"oid": "009c09a6330ce8005925f73687179122582805ed", "url": "https://github.com/infinispan/infinispan/commit/009c09a6330ce8005925f73687179122582805ed", "message": "ISPN-10249 Avoid to change the deprecated interface\n\nUnfortunately IndexedTypeMap is a Hibernate Search 5\u2019s class, so I think we had to remove it.", "committedDate": "2020-07-24T14:33:02Z", "type": "commit"}, {"oid": "10f23a187bce36db7fa046a4541c77808b6b3f8a", "url": "https://github.com/infinispan/infinispan/commit/10f23a187bce36db7fa046a4541c77808b6b3f8a", "message": "ISPN-10249 Avoid to cache result size in deprecated class", "committedDate": "2020-07-24T14:33:02Z", "type": "commit"}, {"oid": "646927489d0b43deaf39b24f4ecf19d6de430e8c", "url": "https://github.com/infinispan/infinispan/commit/646927489d0b43deaf39b24f4ecf19d6de430e8c", "message": "ISPN-10249 Solve thread leak in HibernateSearchPropertyHelperTest", "committedDate": "2020-07-24T14:33:02Z", "type": "commit"}, {"oid": "646927489d0b43deaf39b24f4ecf19d6de430e8c", "url": "https://github.com/infinispan/infinispan/commit/646927489d0b43deaf39b24f4ecf19d6de430e8c", "message": "ISPN-10249 Solve thread leak in HibernateSearchPropertyHelperTest", "committedDate": "2020-07-24T14:33:02Z", "type": "forcePushed"}, {"oid": "06f2f946415446db192654e514d1717555ee301f", "url": "https://github.com/infinispan/infinispan/commit/06f2f946415446db192654e514d1717555ee301f", "message": "Ignore Wildfly search tests for now", "committedDate": "2020-07-24T14:38:17Z", "type": "commit"}]}