{"pr_number": 8629, "pr_title": "ISPN-12205 Add RocksDB Meta Column Family", "pr_author": "ryanemerson", "pr_createdAt": "2020-08-18T12:17:10Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8629", "merge_commit": "383f95b8537b24622add2e2a77635f4310cf3fdd", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY3MTM2Mg==", "url": "https://github.com/infinispan/infinispan/pull/8629#discussion_r483671362", "body": "Do we have a JIRA for this?", "bodyText": "Do we have a JIRA for this?", "bodyHTML": "<p dir=\"auto\">Do we have a JIRA for this?</p>", "author": "wburns", "createdAt": "2020-09-04T14:55:54Z", "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java", "diffHunk": "@@ -134,6 +137,13 @@\n          try {\n             db = handler.open(getLocation(), dataDbOptions());\n             expiredDb = openDatabase(getExpirationLocation(), expiredDbOptions());\n+\n+            MetadataImpl existingMeta = handler.loadMetadata();\n+            if (existingMeta != null) {\n+               // TODO Perform validation/migration", "originalCommit": "aa63889cfde348edc7ad554617cfef8ae3558aa8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY3MjU3MA==", "url": "https://github.com/infinispan/infinispan/pull/8629#discussion_r483672570", "bodyText": "Maybe for this iteration we can just verify the version and if there is a mismatch log a WARN/INFO message?", "author": "wburns", "createdAt": "2020-09-04T14:57:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY3MTM2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY4MjM1Mg==", "url": "https://github.com/infinispan/infinispan/pull/8629#discussion_r483682352", "bodyText": "Tbh as this is the first version that has this logic, I'm not sure how there could be a mismatch. It's also possible (in fact desirable) in future versions that loading from a previous major should not require migration, so logging would only add noise IMO.", "author": "ryanemerson", "createdAt": "2020-09-04T15:15:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY3MTM2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "f37550c7528d7fc0fd79b7333ecf3427bc292503", "changed_code": [{"header": "diff --git a/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java b/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\nindex 3640038590..5fe4d3a52d 100644\n--- a/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\n+++ b/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\n", "chunk": "@@ -140,7 +140,8 @@ public CompletionStage<Void> start(InitializationContext ctx) {\n \n             MetadataImpl existingMeta = handler.loadMetadata();\n             if (existingMeta != null) {\n-               // TODO Perform validation/migration\n+               // TODO Perform data migration as part of ISPN-11614\n+               assert existingMeta.version == Version.getVersionShort();\n             }\n             // Update the metadata entry to use the current Infinispan version\n             handler.writeMetadata();\n", "next_change": {"commit": "f6bee24bdbd113c1895d843e2d27d473d97bcaea", "changed_code": [{"header": "diff --git a/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java b/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\nindex 5fe4d3a52d..3517f3339e 100644\n--- a/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\n+++ b/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\n", "chunk": "@@ -139,12 +139,14 @@ public CompletionStage<Void> start(InitializationContext ctx) {\n             expiredDb = openDatabase(getExpirationLocation(), expiredDbOptions());\n \n             MetadataImpl existingMeta = handler.loadMetadata();\n+            boolean versionsMatch = true;\n             if (existingMeta != null) {\n-               // TODO Perform data migration as part of ISPN-11614\n-               assert existingMeta.version == Version.getVersionShort();\n+               // TODO Perform data migration as part of ISPN-11614 and remove versionsMatch check\n+               versionsMatch = existingMeta.version == Version.getVersionShort();\n             }\n             // Update the metadata entry to use the current Infinispan version\n-            handler.writeMetadata();\n+            if (versionsMatch)\n+               handler.writeMetadata();\n          } catch (Exception e) {\n             throw new CacheConfigurationException(\"Unable to open database\", e);\n          }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "383f95b8537b24622add2e2a77635f4310cf3fdd", "changed_code": [{"header": "diff --git a/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java b/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\nindex 3640038590..3517f3339e 100644\n--- a/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\n+++ b/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\n", "chunk": "@@ -139,11 +139,14 @@ public CompletionStage<Void> start(InitializationContext ctx) {\n             expiredDb = openDatabase(getExpirationLocation(), expiredDbOptions());\n \n             MetadataImpl existingMeta = handler.loadMetadata();\n+            boolean versionsMatch = true;\n             if (existingMeta != null) {\n-               // TODO Perform validation/migration\n+               // TODO Perform data migration as part of ISPN-11614 and remove versionsMatch check\n+               versionsMatch = existingMeta.version == Version.getVersionShort();\n             }\n             // Update the metadata entry to use the current Infinispan version\n-            handler.writeMetadata();\n+            if (versionsMatch)\n+               handler.writeMetadata();\n          } catch (Exception e) {\n             throw new CacheConfigurationException(\"Unable to open database\", e);\n          }\n", "next_change": {"commit": "c3b6aa5ae1ab5695037e6a9e34afcca584c7a5ca", "changed_code": [{"header": "diff --git a/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java b/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\nindex 3517f3339e..2480f499a9 100644\n--- a/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\n+++ b/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\n", "chunk": "@@ -135,30 +135,111 @@ public CompletionStage<Void> start(InitializationContext ctx) {\n \n       return blockingManager.runBlocking(() -> {\n          try {\n-            db = handler.open(getLocation(), dataDbOptions());\n-            expiredDb = openDatabase(getExpirationLocation(), expiredDbOptions());\n-\n+            initDefaultHandler();\n             MetadataImpl existingMeta = handler.loadMetadata();\n-            boolean versionsMatch = true;\n-            if (existingMeta != null) {\n-               // TODO Perform data migration as part of ISPN-11614 and remove versionsMatch check\n-               versionsMatch = existingMeta.version == Version.getVersionShort();\n+            if (existingMeta == null && !configuration.purgeOnStartup()) {\n+               // Metadata does not exist, therefore we must be reading from a pre-12.x store. Migrate the old data\n+               PERSISTENCE.startMigratingPersistenceData();\n+               migrateFromV11();\n+               PERSISTENCE.persistedDataSuccessfulMigrated();\n             }\n             // Update the metadata entry to use the current Infinispan version\n-            if (versionsMatch)\n-               handler.writeMetadata();\n+            handler.writeMetadata();\n          } catch (Exception e) {\n             throw new CacheConfigurationException(\"Unable to open database\", e);\n          }\n       }, \"rocksdb-open\");\n    }\n \n+   private void initDefaultHandler() throws RocksDBException {\n+      this.handler = createHandler(getLocation(), getExpirationLocation());\n+      this.db = handler.db;\n+      this.expiredDb = handler.expiredDb;\n+   }\n+\n+   private RocksDBHandler createHandler(Path data, Path expired) throws RocksDBException {\n+      AdvancedCache<?, ?> cache = ctx.getCache().getAdvancedCache();\n+      if (configuration.segmented()) {\n+         return new SegmentedRocksDBHandler(data, expired, cache.getCacheConfiguration().clustering().hash().numSegments());\n+      }\n+      return new NonSegmentedRocksDBHandler(data, expired, keyPartitioner);\n+   }\n+\n+   private void migrateFromV11() throws IOException, RocksDBException {\n+      IntSet segments;\n+      if (configuration.segmented()) {\n+         int numSegments = ctx.getCache().getCacheConfiguration().clustering().hash().numSegments();\n+         segments = IntSets.immutableRangeSet(numSegments);\n+      } else {\n+         segments = null;\n+      }\n+\n+      // If no entries exist in the store, then nothing to migrate\n+      if (CompletionStages.join(handler.size(segments)) == 0)\n+         return;\n+\n+      Path newDbLocation = getQualifiedLocation(\"new_data\");\n+      Path newExpiredDbLocation = getQualifiedLocation(\"new_expired\");\n+      try {\n+         // Create new DB and open handle\n+         RocksDBHandler migrationHandler = createHandler(newDbLocation, newExpiredDbLocation);\n+\n+         Function<RocksIterator, Flowable<MarshallableEntry<K, V>>> function =\n+               it -> Flowable.fromIterable(() -> new RocksLegacyEntryIterator(it));\n+\n+         // Iterate and convert entries from old handle\n+         Publisher<MarshallableEntry<K, V>> publisher = configuration.segmented() ?\n+               ((SegmentedRocksDBHandler) handler).handleIteratorFunction(function, segments) :\n+               handler.publish(-1, function);\n+\n+         WriteBatch batch = new WriteBatch();\n+         Set<MarshallableEntry<K, V>> expirableEntries = new HashSet<>();\n+         Flowable.fromPublisher(publisher)\n+               .subscribe(e -> {\n+                  ColumnFamilyHandle handle = migrationHandler.getHandle(keyPartitioner.getSegment(e.getKey()));\n+                  batch.put(handle, e.getKeyBytes().copy().getBuf(), marshall(e.getMarshalledValue()));\n+                  if (e.expiryTime() > 1)\n+                     expirableEntries.add(e);\n+               });\n+\n+         if (batch.count() <= 0)\n+            batch.close();\n+\n+         migrationHandler.db.write(dataWriteOptions(), batch);\n+         for (MarshallableEntry<K, V> e : expirableEntries)\n+            addNewExpiry(migrationHandler.expiredDb, e);\n+\n+         // Close original and new handler\n+         handler.close();\n+         migrationHandler.close();\n+\n+         // Copy new db to original location\n+         Path dataLocation = getLocation();\n+         Path expirationLocation = getExpirationLocation();\n+         Util.recursiveFileRemove(dataLocation);\n+         Util.recursiveFileRemove(expirationLocation);\n+         Files.move(newDbLocation, dataLocation, StandardCopyOption.REPLACE_EXISTING);\n+         Files.move(newExpiredDbLocation, expirationLocation, StandardCopyOption.REPLACE_EXISTING);\n+\n+         // Open db handle to new db at original location\n+         initDefaultHandler();\n+      } finally {\n+         // In the event of a failure, always remove the new dbs\n+         Util.recursiveFileRemove(newDbLocation);\n+         Util.recursiveFileRemove(newExpiredDbLocation);\n+      }\n+   }\n+\n+   private Path getQualifiedLocation(String qualifier) {\n+      return org.infinispan.persistence.PersistenceUtil.getQualifiedLocation(ctx.getGlobalConfiguration(), configuration.location(), ctx.getCache().getName(), qualifier);\n+   }\n+\n    private Path getLocation() {\n-      return getQualifiedLocation(ctx.getGlobalConfiguration(), configuration.location(), ctx.getCache().getName(), \"data\");\n+      return getQualifiedLocation(\"data\");\n    }\n \n    private Path getExpirationLocation() {\n-      return getQualifiedLocation(ctx.getGlobalConfiguration(), configuration.expiredLocation(), ctx.getCache().getName(), \"expired\");\n+      return getQualifiedLocation(\"expired\");\n    }\n \n    private WriteOptions dataWriteOptions() {\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "383f95b8537b24622add2e2a77635f4310cf3fdd", "message": "Merge commit", "committedDate": null}, {"oid": "133086b5564b2cf39522cffda3ef82fa1798cd11", "committedDate": "2020-10-23 09:46:13 +0300", "message": "ISPN-8241 Refactor RocksDB clearThreshold"}, {"oid": "0753647c23d47fd1f035473b94d182c6da84e701", "committedDate": "2020-12-14 17:38:18 +0200", "message": "ISPN-12469 Do not cache trace level statically"}, {"oid": "7206596b4a0258d0b8f1a20d78259e7f270a81ec", "committedDate": "2020-12-14 17:38:18 +0200", "message": "ISPN-12469 Don't cache isTraceEnabled/isDebugEnabled calls"}, {"oid": "c3b6aa5ae1ab5695037e6a9e34afcca584c7a5ca", "committedDate": "2020-12-16 10:19:32 -0500", "message": "ISPN-11614 Stores updated to migrate incompatible data from 11.x -> 12.x"}, {"oid": "e0e25c748cc07588ef7faa82a1bf6bb190469fca", "committedDate": "2021-01-29 20:05:40 +0000", "message": "ISPN-12665 Add cache name to peristence migration logs"}, {"oid": "d1f034cc6daad797e1feef46ce3278e3c763518b", "committedDate": "2021-08-11 17:30:30 -0400", "message": "ISPN-12638 Make NonBlockingStore.delete() return value optional"}, {"oid": "80a7081e8f3d4858b5fbecc7c2471e68741089a1", "committedDate": "2021-11-04 19:26:18 +0000", "message": "ISPN-13392 Fix Tomcat integration test setup"}, {"oid": "9a1d6ea91eacfff4f43b60dc0bea4486c0d1c638", "committedDate": "2022-02-04 11:01:36 -0500", "message": "ISPN-13421 Add approximate size metrics"}, {"oid": "1f3a15c455dacd3d788eab3f3109239492f1e675", "committedDate": "2022-04-01 13:31:34 -0400", "message": "ISPN-13792 Non-blocking transaction commit/rollback"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY3MzM4NQ==", "url": "https://github.com/infinispan/infinispan/pull/8629#discussion_r483673385", "body": "I am not sure we want to do this if the versions don't match.", "bodyText": "I am not sure we want to do this if the versions don't match.", "bodyHTML": "<p dir=\"auto\">I am not sure we want to do this if the versions don't match.</p>", "author": "wburns", "createdAt": "2020-09-04T14:59:15Z", "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java", "diffHunk": "@@ -134,6 +137,13 @@\n          try {\n             db = handler.open(getLocation(), dataDbOptions());\n             expiredDb = openDatabase(getExpirationLocation(), expiredDbOptions());\n+\n+            MetadataImpl existingMeta = handler.loadMetadata();\n+            if (existingMeta != null) {\n+               // TODO Perform validation/migration\n+            }\n+            // Update the metadata entry to use the current Infinispan version\n+            handler.writeMetadata();", "originalCommit": "aa63889cfde348edc7ad554617cfef8ae3558aa8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY4MTAzNw==", "url": "https://github.com/infinispan/infinispan/pull/8629#discussion_r483681037", "bodyText": "My plan was that if there are any incompatibilies they will be handled via the migration logic between x and latest version, or if this is not possible an exception is thrown before this statement is reached.", "author": "ryanemerson", "createdAt": "2020-09-04T15:12:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY3MzM4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwNjAzNQ==", "url": "https://github.com/infinispan/infinispan/pull/8629#discussion_r483706035", "bodyText": "Oh I agree. I am more saying in case we never get this completed. I know how some features have ideas for the future but it never comes to fruition.", "author": "wburns", "createdAt": "2020-09-04T15:46:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY3MzM4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxMzA4MA==", "url": "https://github.com/infinispan/infinispan/pull/8629#discussion_r483713080", "bodyText": "Ok. I've added a variable to prevent this in the meantime.", "author": "ryanemerson", "createdAt": "2020-09-04T15:59:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY3MzM4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "f37550c7528d7fc0fd79b7333ecf3427bc292503", "changed_code": [{"header": "diff --git a/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java b/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\nindex 3640038590..5fe4d3a52d 100644\n--- a/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\n+++ b/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\n", "chunk": "@@ -140,7 +140,8 @@ public CompletionStage<Void> start(InitializationContext ctx) {\n \n             MetadataImpl existingMeta = handler.loadMetadata();\n             if (existingMeta != null) {\n-               // TODO Perform validation/migration\n+               // TODO Perform data migration as part of ISPN-11614\n+               assert existingMeta.version == Version.getVersionShort();\n             }\n             // Update the metadata entry to use the current Infinispan version\n             handler.writeMetadata();\n", "next_change": {"commit": "f6bee24bdbd113c1895d843e2d27d473d97bcaea", "changed_code": [{"header": "diff --git a/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java b/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\nindex 5fe4d3a52d..3517f3339e 100644\n--- a/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\n+++ b/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\n", "chunk": "@@ -139,12 +139,14 @@ public CompletionStage<Void> start(InitializationContext ctx) {\n             expiredDb = openDatabase(getExpirationLocation(), expiredDbOptions());\n \n             MetadataImpl existingMeta = handler.loadMetadata();\n+            boolean versionsMatch = true;\n             if (existingMeta != null) {\n-               // TODO Perform data migration as part of ISPN-11614\n-               assert existingMeta.version == Version.getVersionShort();\n+               // TODO Perform data migration as part of ISPN-11614 and remove versionsMatch check\n+               versionsMatch = existingMeta.version == Version.getVersionShort();\n             }\n             // Update the metadata entry to use the current Infinispan version\n-            handler.writeMetadata();\n+            if (versionsMatch)\n+               handler.writeMetadata();\n          } catch (Exception e) {\n             throw new CacheConfigurationException(\"Unable to open database\", e);\n          }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "383f95b8537b24622add2e2a77635f4310cf3fdd", "changed_code": [{"header": "diff --git a/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java b/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\nindex 3640038590..3517f3339e 100644\n--- a/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\n+++ b/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\n", "chunk": "@@ -139,11 +139,14 @@ public CompletionStage<Void> start(InitializationContext ctx) {\n             expiredDb = openDatabase(getExpirationLocation(), expiredDbOptions());\n \n             MetadataImpl existingMeta = handler.loadMetadata();\n+            boolean versionsMatch = true;\n             if (existingMeta != null) {\n-               // TODO Perform validation/migration\n+               // TODO Perform data migration as part of ISPN-11614 and remove versionsMatch check\n+               versionsMatch = existingMeta.version == Version.getVersionShort();\n             }\n             // Update the metadata entry to use the current Infinispan version\n-            handler.writeMetadata();\n+            if (versionsMatch)\n+               handler.writeMetadata();\n          } catch (Exception e) {\n             throw new CacheConfigurationException(\"Unable to open database\", e);\n          }\n", "next_change": {"commit": "c3b6aa5ae1ab5695037e6a9e34afcca584c7a5ca", "changed_code": [{"header": "diff --git a/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java b/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\nindex 3517f3339e..2480f499a9 100644\n--- a/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\n+++ b/persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java\n", "chunk": "@@ -135,30 +135,111 @@ public CompletionStage<Void> start(InitializationContext ctx) {\n \n       return blockingManager.runBlocking(() -> {\n          try {\n-            db = handler.open(getLocation(), dataDbOptions());\n-            expiredDb = openDatabase(getExpirationLocation(), expiredDbOptions());\n-\n+            initDefaultHandler();\n             MetadataImpl existingMeta = handler.loadMetadata();\n-            boolean versionsMatch = true;\n-            if (existingMeta != null) {\n-               // TODO Perform data migration as part of ISPN-11614 and remove versionsMatch check\n-               versionsMatch = existingMeta.version == Version.getVersionShort();\n+            if (existingMeta == null && !configuration.purgeOnStartup()) {\n+               // Metadata does not exist, therefore we must be reading from a pre-12.x store. Migrate the old data\n+               PERSISTENCE.startMigratingPersistenceData();\n+               migrateFromV11();\n+               PERSISTENCE.persistedDataSuccessfulMigrated();\n             }\n             // Update the metadata entry to use the current Infinispan version\n-            if (versionsMatch)\n-               handler.writeMetadata();\n+            handler.writeMetadata();\n          } catch (Exception e) {\n             throw new CacheConfigurationException(\"Unable to open database\", e);\n          }\n       }, \"rocksdb-open\");\n    }\n \n+   private void initDefaultHandler() throws RocksDBException {\n+      this.handler = createHandler(getLocation(), getExpirationLocation());\n+      this.db = handler.db;\n+      this.expiredDb = handler.expiredDb;\n+   }\n+\n+   private RocksDBHandler createHandler(Path data, Path expired) throws RocksDBException {\n+      AdvancedCache<?, ?> cache = ctx.getCache().getAdvancedCache();\n+      if (configuration.segmented()) {\n+         return new SegmentedRocksDBHandler(data, expired, cache.getCacheConfiguration().clustering().hash().numSegments());\n+      }\n+      return new NonSegmentedRocksDBHandler(data, expired, keyPartitioner);\n+   }\n+\n+   private void migrateFromV11() throws IOException, RocksDBException {\n+      IntSet segments;\n+      if (configuration.segmented()) {\n+         int numSegments = ctx.getCache().getCacheConfiguration().clustering().hash().numSegments();\n+         segments = IntSets.immutableRangeSet(numSegments);\n+      } else {\n+         segments = null;\n+      }\n+\n+      // If no entries exist in the store, then nothing to migrate\n+      if (CompletionStages.join(handler.size(segments)) == 0)\n+         return;\n+\n+      Path newDbLocation = getQualifiedLocation(\"new_data\");\n+      Path newExpiredDbLocation = getQualifiedLocation(\"new_expired\");\n+      try {\n+         // Create new DB and open handle\n+         RocksDBHandler migrationHandler = createHandler(newDbLocation, newExpiredDbLocation);\n+\n+         Function<RocksIterator, Flowable<MarshallableEntry<K, V>>> function =\n+               it -> Flowable.fromIterable(() -> new RocksLegacyEntryIterator(it));\n+\n+         // Iterate and convert entries from old handle\n+         Publisher<MarshallableEntry<K, V>> publisher = configuration.segmented() ?\n+               ((SegmentedRocksDBHandler) handler).handleIteratorFunction(function, segments) :\n+               handler.publish(-1, function);\n+\n+         WriteBatch batch = new WriteBatch();\n+         Set<MarshallableEntry<K, V>> expirableEntries = new HashSet<>();\n+         Flowable.fromPublisher(publisher)\n+               .subscribe(e -> {\n+                  ColumnFamilyHandle handle = migrationHandler.getHandle(keyPartitioner.getSegment(e.getKey()));\n+                  batch.put(handle, e.getKeyBytes().copy().getBuf(), marshall(e.getMarshalledValue()));\n+                  if (e.expiryTime() > 1)\n+                     expirableEntries.add(e);\n+               });\n+\n+         if (batch.count() <= 0)\n+            batch.close();\n+\n+         migrationHandler.db.write(dataWriteOptions(), batch);\n+         for (MarshallableEntry<K, V> e : expirableEntries)\n+            addNewExpiry(migrationHandler.expiredDb, e);\n+\n+         // Close original and new handler\n+         handler.close();\n+         migrationHandler.close();\n+\n+         // Copy new db to original location\n+         Path dataLocation = getLocation();\n+         Path expirationLocation = getExpirationLocation();\n+         Util.recursiveFileRemove(dataLocation);\n+         Util.recursiveFileRemove(expirationLocation);\n+         Files.move(newDbLocation, dataLocation, StandardCopyOption.REPLACE_EXISTING);\n+         Files.move(newExpiredDbLocation, expirationLocation, StandardCopyOption.REPLACE_EXISTING);\n+\n+         // Open db handle to new db at original location\n+         initDefaultHandler();\n+      } finally {\n+         // In the event of a failure, always remove the new dbs\n+         Util.recursiveFileRemove(newDbLocation);\n+         Util.recursiveFileRemove(newExpiredDbLocation);\n+      }\n+   }\n+\n+   private Path getQualifiedLocation(String qualifier) {\n+      return org.infinispan.persistence.PersistenceUtil.getQualifiedLocation(ctx.getGlobalConfiguration(), configuration.location(), ctx.getCache().getName(), qualifier);\n+   }\n+\n    private Path getLocation() {\n-      return getQualifiedLocation(ctx.getGlobalConfiguration(), configuration.location(), ctx.getCache().getName(), \"data\");\n+      return getQualifiedLocation(\"data\");\n    }\n \n    private Path getExpirationLocation() {\n-      return getQualifiedLocation(ctx.getGlobalConfiguration(), configuration.expiredLocation(), ctx.getCache().getName(), \"expired\");\n+      return getQualifiedLocation(\"expired\");\n    }\n \n    private WriteOptions dataWriteOptions() {\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "383f95b8537b24622add2e2a77635f4310cf3fdd", "message": "Merge commit", "committedDate": null}, {"oid": "133086b5564b2cf39522cffda3ef82fa1798cd11", "committedDate": "2020-10-23 09:46:13 +0300", "message": "ISPN-8241 Refactor RocksDB clearThreshold"}, {"oid": "0753647c23d47fd1f035473b94d182c6da84e701", "committedDate": "2020-12-14 17:38:18 +0200", "message": "ISPN-12469 Do not cache trace level statically"}, {"oid": "7206596b4a0258d0b8f1a20d78259e7f270a81ec", "committedDate": "2020-12-14 17:38:18 +0200", "message": "ISPN-12469 Don't cache isTraceEnabled/isDebugEnabled calls"}, {"oid": "c3b6aa5ae1ab5695037e6a9e34afcca584c7a5ca", "committedDate": "2020-12-16 10:19:32 -0500", "message": "ISPN-11614 Stores updated to migrate incompatible data from 11.x -> 12.x"}, {"oid": "e0e25c748cc07588ef7faa82a1bf6bb190469fca", "committedDate": "2021-01-29 20:05:40 +0000", "message": "ISPN-12665 Add cache name to peristence migration logs"}, {"oid": "d1f034cc6daad797e1feef46ce3278e3c763518b", "committedDate": "2021-08-11 17:30:30 -0400", "message": "ISPN-12638 Make NonBlockingStore.delete() return value optional"}, {"oid": "80a7081e8f3d4858b5fbecc7c2471e68741089a1", "committedDate": "2021-11-04 19:26:18 +0000", "message": "ISPN-13392 Fix Tomcat integration test setup"}, {"oid": "9a1d6ea91eacfff4f43b60dc0bea4486c0d1c638", "committedDate": "2022-02-04 11:01:36 -0500", "message": "ISPN-13421 Add approximate size metrics"}, {"oid": "1f3a15c455dacd3d788eab3f3109239492f1e675", "committedDate": "2022-04-01 13:31:34 -0400", "message": "ISPN-13792 Non-blocking transaction commit/rollback"}]}, {"oid": "f37550c7528d7fc0fd79b7333ecf3427bc292503", "url": "https://github.com/infinispan/infinispan/commit/f37550c7528d7fc0fd79b7333ecf3427bc292503", "message": "ISPN-12205 Add RocksDB Meta Column Family", "committedDate": "2020-09-04T15:13:08Z", "type": "forcePushed"}, {"oid": "f6bee24bdbd113c1895d843e2d27d473d97bcaea", "url": "https://github.com/infinispan/infinispan/commit/f6bee24bdbd113c1895d843e2d27d473d97bcaea", "message": "ISPN-12205 Add RocksDB Meta Column Family", "committedDate": "2020-09-04T15:59:02Z", "type": "commit"}, {"oid": "f6bee24bdbd113c1895d843e2d27d473d97bcaea", "url": "https://github.com/infinispan/infinispan/commit/f6bee24bdbd113c1895d843e2d27d473d97bcaea", "message": "ISPN-12205 Add RocksDB Meta Column Family", "committedDate": "2020-09-04T15:59:02Z", "type": "forcePushed"}]}